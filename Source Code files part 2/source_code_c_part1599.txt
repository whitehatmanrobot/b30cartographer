      if (NULL == pFollower)
            {
                ppPointerToFillIn = &(m_CustomActionHash[pNewCustomAction->Type]);
            }
            else
            {
                ppPointerToFillIn = &(pFollower->Next);
            }

            hr = DuplicateCustomActionListItem(pNewCustomAction, ppPointerToFillIn);
        
            if (SUCCEEDED(hr))
            {
                (*ppPointerToFillIn)->Next = pExistingItem->Next;
                CmFree(pExistingItem->pszParameters);
                CmFree(pExistingItem);
                pExistingItem = NULL;
            }
        }
        else
        {
            hr = Find (hInstance, pNewCustomAction->szDescription, pNewCustomAction->Type, &pTemp, &pTempFollower);

            if (SUCCEEDED(hr))
            {
                //
                //  If the caller really wants to do this, then have them delete the old custom action
                //  and then call edit with the new custom action as both old and new.
                //
                hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);                
            }
            else
            {
                //
                //  If the types are different then it needs to go on a different sub list.  If
                //  only the name is different then we just need to copy it over.
                //
                if(pOldCustomAction->Type != pNewCustomAction->Type)
                {
                    //
                    //  Delete the old action of type X
                    //
                    hr = Delete(hInstance, pOldCustomAction->szDescription, pOldCustomAction->Type);
                    MYDBGASSERT(SUCCEEDED(hr));

                    //
                    //  Add the new action of type Y
                    //
                    if (SUCCEEDED(hr))
                    {
                        hr = Add(hInstance, pNewCustomAction, pszShortServiceName);
                        MYDBGASSERT(SUCCEEDED(hr));
                    }
                }
                else
                {
                    if (NULL == pFollower)
                    {
                        ppPointerToFillIn = &(m_CustomActionHash[pNewCustomAction->Type]);
                    }
                    else
                    {
                        ppPointerToFillIn = &(pFollower->Next);
                    }

                    hr = DuplicateCustomActionListItem(pNewCustomAction, ppPointerToFillIn);
        
                    if (SUCCEEDED(hr))
                    {
                        (*ppPointerToFillIn)->Next = pExistingItem->Next;
                        CmFree(pExistingItem->pszParameters);
                        CmFree(pExistingItem);
                        pExistingItem = NULL;
                    }
                }
            }            
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::Find
//
// Synopsis:  This function searches the array of linked lists for an item with
//            the given type and description.  If it finds the the item it returns
//            successfully and fills in the ppItem and ppFollower pointers with
//            pointers to the item itself and the item before the requested item,
//            respectively.  If the item is the first item in the list, then
//            *ppFollower will be NULL.  Note that this function is internal to the
//            class because it returns pointers to the classes internal data.
//            Also note, that if we have a list, but don't find the desired item
//            then *ppFollower returns the last item in the list.  This is desired
//            behavior since it allows Add to use *ppFollower to directly add a new
//            item to the list.
//
// Arguments: HINSTANCE hInstance - instance handle for resources
//            LPCTSTR pszDescription - description of the item to look for
//            CustomActionTypes Type - type of the item to look for
//            CustomActionListItem** ppItem - an OUT param that is filled in with
//                                            a pointer to the item on a successful find
//            CustomActionListItem** ppFollower - an OUT param that is filled in with
//                                                a pointer to the item before the
//                                                item in the list on a successful find
//                                                (note that this is useful since it
//                                                is a singly linked list).  This
//                                                param will be NULL if the item is the
//                                                first item in the list on a successful
//                                                find.
//                                                 
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::Find(HINSTANCE hInstance, LPCTSTR pszDescription, CustomActionTypes Type, CustomActionListItem** ppItem, CustomActionListItem** ppFollower)
{
    if ((NULL == hInstance) || (NULL == pszDescription) || (TEXT('\0') == pszDescription[0]) || (NULL == ppItem) || (NULL == ppFollower))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    CustomActionListItem* pCurrent = m_CustomActionHash[Type];
    TCHAR szDescWithBuiltInSuffix[MAX_PATH+1];
    
    *ppFollower = NULL;
    *ppItem = NULL;

    LPTSTR pszBuiltInSuffix = CmLoadString(hInstance, IDS_BUILT_IN); // if we got a NULL pointer then just don't do the extra compare
    MYDBGASSERT(pszBuiltInSuffix);

    //
    //  Search the list to find the item
    //
    while (pCurrent)
    {
        if (0 == lstrcmpi(pCurrent->szDescription, pszDescription))
        {
            //
            //  We found the item
            //
            *ppItem = pCurrent;

            hr = S_OK;
            break;
        }
        else if (pszBuiltInSuffix && pCurrent->bBuiltInAction)
        {
            //
            //  This is a built in action, lets try adding the builtin string to the description
            //  and try the comparision again
            //
            wsprintf(szDescWithBuiltInSuffix, TEXT("%s%s"), pCurrent->szDescription, pszBuiltInSuffix);

            if (0 == lstrcmpi(szDescWithBuiltInSuffix, pszDescription))
            {
                *ppItem = pCurrent;

                hr = S_OK;
                break;            
            }
            else
            {
                *ppFollower = pCurrent;
                pCurrent = pCurrent->Next;
            }
        }
        else
        {
            *ppFollower = pCurrent;
            pCurrent = pCurrent->Next;
        }
    }

    CmFree(pszBuiltInSuffix);

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::Delete
//
// Synopsis:  This function searches through the array of custom action lists
//            to find an item with the given description and type.  If it finds
//            the item it deletes it from the list.  If the item cannot be found
//            an error is returned.
//
// Arguments: TCHAR* pszDescription - description of the item to look for
//            CustomActionTypes Type - type of the item to look for
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::Delete(HINSTANCE hInstance, TCHAR* pszDescription, CustomActionTypes Type)
{
    HRESULT hr = S_OK;

    if ((NULL == pszDescription) || (TEXT('\0') == pszDescription[0]))
    {
        return E_INVALIDARG;
    }

    CustomActionListItem* pCurrent = NULL;
    CustomActionListItem* pFollower = NULL;

    hr = Find(hInstance, pszDescription, Type, &pCurrent, &pFollower);

    if (SUCCEEDED(hr))
    {
        //
        //  We found the item to delete
        //
        if (pFollower)
        {
            pFollower->Next = pCurrent->Next;
        }
        else
        {
            //
            //  It is the first item in the list
            //
            m_CustomActionHash[Type] = pCurrent->Next;
        }

        CmFree(pCurrent->pszParameters);
        CmFree(pCurrent);       
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::MoveUp
//
// Synopsis:  Moves the custom action specified by the given description and type
//            up one place in the linked list for the given type.  Note that if
//            the custom action is already at the top of its list, we return
//            S_FALSE;
//
// Arguments: TCHAR* pszDescription - description of the custom action to move
//            CustomActionTypes Type - type of the custom action to move
//
// Returns:   HRESULT - standard COM error codes.  Note that S_FALSE denotes that
//                      MoveUp succeeded but that the item was already at the
//                      head of its list and thus couldn't be moved.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::MoveUp(HINSTANCE hInstance, TCHAR* pszDescription, CustomActionTypes Type)
{
    if ((NULL == pszDescription) || (TEXT('\0') == pszDescription[0]))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = E_UNEXPECTED;
    CustomActionListItem* pCurrent = NULL;
    CustomActionListItem* pFollower = NULL;
    CustomActionListItem* pBeforeFollower = NULL;

    hr = Find(hInstance, pszDescription, Type, &pCurrent, &pFollower);

    if (SUCCEEDED(hr))
    {
        //
        //  We found the item to move up
        //
        if (pFollower)
        {
            //
            //  Now Find the item in front of pFollower
            //
            hr = Find(hInstance, pFollower->szDescription, pFollower->Type, &pFollower, &pBeforeFollower);

            if (SUCCEEDED(hr))
            {
                if (pBeforeFollower)
                {
                    pBeforeFollower->Next = pCurrent;
                }
                else
                {
                    //
                    //  pFollower is first in the list
                    //
                    m_CustomActionHash[Type] = pCurrent;
                }

                pFollower->Next = pCurrent->Next;
                pCurrent->Next = pFollower;

                hr = S_OK;
            }            
        }
        else
        {
            //
            //  It is the first item in the list, we cannot move it up
            //
            hr = S_FALSE;
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::MoveDown
//
// Synopsis:  Moves the custom action specified by the given description and type
//            down one place in the linked list for the given type.  Note that if
//            the custom action is already at the bottom of its list, we return
//            S_FALSE;
//
// Arguments: TCHAR* pszDescription - description of the custom action to move
//            CustomActionTypes Type - type of the custom action to move
//
// Returns:   HRESULT - standard COM error codes.  Note that S_FALSE denotes that
//                      MoveDown succeeded but that the item was already at the
//                      tail of its list and thus couldn't be moved.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::MoveDown(HINSTANCE hInstance, TCHAR* pszDescription, CustomActionTypes Type)
{
    if ((NULL == pszDescription) || (TEXT('\0') == pszDescription[0]))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = E_UNEXPECTED;
    CustomActionListItem* pCurrent = NULL;
    CustomActionListItem* pFollower = NULL;

    hr = Find(hInstance, pszDescription, Type, &pCurrent, &pFollower);

    if (SUCCEEDED(hr))
    {
        //
        //  We found the item to move down
        //

        if (NULL == pCurrent->Next)
        {
            //
            //  The item is already last in its list
            //
            hr = S_FALSE;
        }
        else if (pFollower)
        {
            pFollower->Next = pCurrent->Next;
            pCurrent->Next = pFollower->Next->Next;
            pFollower->Next->Next = pCurrent;
        }
        else
        {
            //
            //  Then the item is first in the list
            //
            m_CustomActionHash[Type] = pCurrent->Next;
            pCurrent->Next = m_CustomActionHash[Type]->Next;
            m_CustomActionHash[Type]->Next = pCurrent;        
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::AddCustomActionTypesToComboBox
//
// Synopsis:  This function adds the custom action type strings (Pre-Connect,
//            Post-Connect, etc.) to the given combo box.  Note that whether
//            tunneling is enabled or not and whether the All string is asked for
//            or not affects the strings added to the combo.
//
// Arguments: HWND hDlg - Window handle of the dialog that contains the combobox
//            UINT uCtrlId - combo box control ID to add the strings too
//            HINSTANCE hInstance - instance handle used to load resource strings
//            BOOL bUseTunneling - is this a tunneling profile?
//            BOOL bAddAll - should we include the <All> selection in the list?
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::AddCustomActionTypesToComboBox(HWND hDlg, UINT uCtrlId, HINSTANCE hInstance, BOOL bUseTunneling, BOOL bAddAll)
{

    if ((0 == hDlg) || (0 == uCtrlId))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    //  Clear the combo list
    //
    SendDlgItemMessage(hDlg, uCtrlId, CB_RESETCONTENT, 0, (LPARAM)0); //lint !e534 CB_RESETCONTENT doesn't return anything useful

    //
    //  Ensure the type strings are loaded
    //

    hr = EnsureActionTypeStringsLoaded(hInstance);

    if (SUCCEEDED(hr))
    {
        //
        //  Setup the all display string, if needed
        //
        if (bAddAll)
        {
            SendDlgItemMessage(hDlg, uCtrlId, CB_ADDSTRING, 0, (LPARAM)m_pszAllTypeString);
        }

        //
        //  Setup the rest of the display strings
        //
        for (int i = 0; i < c_iNumCustomActionTypes; i++)
        {
            //
            //  Don't Add the PreTunnel String unless we are tunneling
            //  
            if (i != PRETUNNEL || (i == PRETUNNEL && bUseTunneling))
            {
                SendDlgItemMessage(hDlg, uCtrlId, CB_ADDSTRING, 0, (LPARAM)m_ActionTypeStrings[i]);
            }
        }    
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("CustomActionList::AddCustomActionTypesToComboBox -- Failed to load type strings"));
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::AddCustomActionsToListView
//
// Synopsis:  This function adds actions of the given type to the given
//            list view control.  After adding the actions it sets the
//            selection mark and highlight to the given value (defaulting
//            to the first item in the list).
//
// Arguments: HWND hListView - window handle of the list view control
//            HINSTANCE hInstance - instance handle of the exe, used for resources
//            CustomActionTypes Type - type of custom action to add to the list
//                                     view control, see the CustomActionTypes
//                                     definition for more info
//            BOOL bUseTunneling - whether the tunneling is enabled or not for
//                                 the current profile.  Determines whether 
//                                 PreTunnel actions should be shown in the
//                                 ALL action view (and raises an error if 
//                                 PreTunnel is specified but FALSE is passed).
//            int iItemToSelect - after the items are added to the list, the
//                                selection mark is set.  This defaults to 0, but
//                                if the caller wants a specific index selected
//                                they can pass it in here.  If the index is
//                                invalid then 0 is selected.
//            BOOL bTypeInSecondCol - when TRUE the second column is filled with
//                                    the type string instead of the program.
//
// Returns:   HRESULT - standard COM error codes.  Note that S_FALSE denotes that
//                      the function could not set the requested item index (iItemToSelect)
//                      as the selected item.  Thus it set 0 as the selected item.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::AddCustomActionsToListView(HWND hListView, HINSTANCE hInstance, CustomActionTypes Type, BOOL bUseTunneling, int iItemToSelect, BOOL bTypeInSecondCol)
{
    if ((NULL == hListView) || (-1 > Type) || (c_iNumCustomActionTypes < Type) || (!bUseTunneling && PRETUNNEL == Type))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    LVITEM lvItem = {0};
    TCHAR szTemp[MAX_PATH+1];
    CustomActionListItem* pCurrent;

    //
    //  Clear all of the items in the list view
    //
    MYVERIFY(FALSE != ListView_DeleteAllItems(hListView));

    hr = EnsureActionTypeStringsLoaded(hInstance);

    if (FAILED(hr))
    {
        CMASSERTMSG(FALSE, TEXT("CustomActionList::AddCustomActionsToListView -- Failed to load type strings."));
        return E_UNEXPECTED;
    }

    //
    //  Figure out what type of items to add to the list view
    //
    int iStart;
    int iEnd;
    int iTotalCount = 0;

    if (ALL == Type)
    {
        iStart = 0;
        iEnd = c_iNumCustomActionTypes;
    }
    else
    {
        iStart = Type;
        iEnd = iStart + 1;
    }

    //
    //  Load the built in string suffix just in case we have some built in actions to display
    //
    LPTSTR pszBuiltInSuffix = CmLoadString(hInstance, IDS_BUILT_IN); // if we have a NULL then just don't append anything
    MYDBGASSERT(pszBuiltInSuffix);

    //
    //  Now add the items
    //
    for (int i = iStart; i < iEnd; i++)
    {
        //
        //  Don't display PreTunnel actions unless we are tunneling
        //
        if (!bUseTunneling && (PRETUNNEL == i))
        {
            pCurrent = NULL;
        }
        else
        {
            pCurrent = m_CustomActionHash[i];        
        }
        
        while(pCurrent)
        {
            //
            //  Add the initial item
            //
            LPTSTR pszDescription;
            TCHAR szDescription[MAX_PATH+1];

            if (pszBuiltInSuffix && pCurrent->bBuiltInAction)
            {
                lstrcpy(szDescription, pCurrent->szDescription);
                lstrcat(szDescription, pszBuiltInSuffix);

                pszDescription = szDescription;
            }
            else
            {
                pszDescription = pCurrent->szDescription;
            }

            lvItem.mask = LVIF_TEXT;
            lvItem.pszText = pszDescription;
            lvItem.iItem = iTotalCount;
            lvItem.iSubItem = 0;

            if (-1 == ListView_InsertItem(hListView,  &lvItem))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CMTRACE2(TEXT("CustomActionList::AddCustomActionsToListView -- unable to add %s, hr 0x%x"), pCurrent->szDescription, hr);
            }

            //
            //  Now add the type of the item
            //
            lvItem.iSubItem = 1;

            if (bTypeInSecondCol)
            {
                lvItem.pszText = m_ActionTypeStrings[pCurrent->Type];
            }
            else
            {
                if (pCurrent->bIncludeBinary)
                {
                    lvItem.pszText = CmStrrchr(pCurrent->szProgram, TEXT('\\'));

                    if (lvItem.pszText)
                    {
                        //
                        //  Advance past the slash
                        //
                        lvItem.pszText = CharNext(lvItem.pszText);
                    }
                    else
                    {
                        //
                        //  We couldn't take out the shortservicename\
                        //  Instead of erroring, lets show them the whole string, better than nothing.
                        //
                        lvItem.pszText = pCurrent->szProgram;
                    }
                }
                else
                {
                    lvItem.pszText = pCurrent->szProgram;                
                }
            }

            if (0 == ListView_SetItem(hListView,  &lvItem))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CMTRACE2(TEXT("CustomActionList::AddCustomActionsToListView -- unable to add type for %s, hr 0x%x"), pCurrent->szDescription, hr);
            }
            
            pCurrent = pCurrent->Next;
            iTotalCount++;
        }
    }

    CmFree(pszBuiltInSuffix);

    //
    //  Now that we have added everything to the list, set the cursor selection to the
    //  desired item in the list, if we have any.
    //

    int iCurrentCount = ListView_GetItemCount(hListView);
    if (iCurrentCount)
    {
        //
        //  If we have enough items to satisfy iItemToSelect, then
        //  select the first item in the list.
        //
        if (iCurrentCount < iItemToSelect)
        {
            hr = S_FALSE;
            iItemToSelect = 0;
        }
        
        //
        //  Select the item
        //
        SetListViewSelection(hListView, iItemToSelect);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::GetExistingActionData
//
// Synopsis:  This function looks up an action of the given type and
//            description and then duplicates the item into the provided pointer.
//            The function returns an error if it cannot find the requested item.
//
// Arguments: HINSTANCE hInstance - instance handle for resources
//            LPCTSTR pszDescription - description of the item to look up
//            CustomActionTypes Type - type of the item to lookup
//            CustomActionListItem** ppCustomAction - pointer to hold the 
//                                                    returned item, note
//                                                    it is the user responsibility
//                                                    to free this item
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::GetExistingActionData(HINSTANCE hInstance, LPCTSTR pszDescription, CustomActionTypes Type, CustomActionListItem** ppCustomAction)
{
    if ((NULL == pszDescription) || (TEXT('\0') == pszDescription[0]) || (NULL == ppCustomAction))
    {
        return E_INVALIDARG;
    }

    //
    //  Find the existing entry
    //
    CustomActionListItem* pCurrent = NULL;
    CustomActionListItem* pFollower = NULL;

    HRESULT hr = Find(hInstance, pszDescription, Type, &pCurrent, &pFollower);

    if (SUCCEEDED(hr))
    {
        hr = DuplicateCustomActionListItem(pCurrent, ppCustomAction);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::GetTypeFromTypeString
//
// Synopsis:  This function takes the inputted type string and compares it
//            against the type strings it has loaded to tell the caller the
//            numerical value of the type.
//            
//
// Arguments: HINSTANCE hInstance - instance handle used to load strings
//            TCHAR* pszTypeString - type string that the caller is looking for
//                                   the numerical type of.
//            CustomActionTypes* pType - pointer to recieve the type on success
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::GetTypeFromTypeString(HINSTANCE hInstance, TCHAR* pszTypeString, CustomActionTypes* pType)
{
    if (NULL == pszTypeString || NULL == pType)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = EnsureActionTypeStringsLoaded(hInstance);

    if (SUCCEEDED(hr))
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        for (int i = 0; i < c_iNumCustomActionTypes; i++)
        {
            if (0 == lstrcmpi(m_ActionTypeStrings[i], pszTypeString))
            {
                hr = S_OK;
                *pType = (CustomActionTypes)i;
            }
        }

        //
        //  Check for all
        //
        if (FAILED(hr))
        {
            if (0 == lstrcmpi(m_pszAllTypeString, pszTypeString))
            {
                hr = S_OK;
                *pType = (CustomActionTypes)i;
            }    
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::GetTypeStringFromType
//
// Synopsis:  This function returns the type string of the given numerical
//            type.  Note that the returned string is an allocated string that
//            is the caller's responsibility to free.  The function will not
//            return a NULL string if the function succeeds.
//            
//
// Arguments: HINSTANCE hInstance - instance handle used to load strings
//            TCHAR* pszTypeString - type string that the caller is looking for
//                                   the numerical type of.
//            CustomActionTypes* pType - pointer to recieve the type on success
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::GetTypeStringFromType(HINSTANCE hInstance, CustomActionTypes Type, TCHAR** ppszTypeString)
{
    if (NULL == ppszTypeString || (-1 > Type) || (c_iNumCustomActionTypes <= Type))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = EnsureActionTypeStringsLoaded(hInstance);

    if (SUCCEEDED(hr))
    {
        if (ALL == Type)
        {
            *ppszTypeString = CmStrCpyAlloc(m_pszAllTypeString);
        }
        else
        {
            *ppszTypeString = CmStrCpyAlloc(m_ActionTypeStrings[Type]);
        }

        if (NULL == ppszTypeString)
        {
            hr = E_OUTOFMEMORY;
        }
    }    

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::EnsureActionTypeStringsLoaded
//
// Synopsis:  This function ensures that all of the action type strings have
//            been loaded from string resources.  If any of the action type
//            strings are NULL the function will try to load them.  If the
//            any of the loads fail, the function fails.  Thus the caller is
//            gauranteed to have all of the type strings available for use
//            if this function succeeds.  The loaded strings are freed by the
//            class destructor.  If the CmLoadString call fails, the function
//            will try to use a copy of the Action Section strings instead.
//            
//
// Arguments: HINSTANCE hInstance - instance handle used to load strings
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::EnsureActionTypeStringsLoaded(HINSTANCE hInstance)
{

    HRESULT hr = E_OUTOFMEMORY;

    //
    //  First load the All type string
    //
    if (NULL == m_pszAllTypeString)
    {
        //
        //  LoadString the string we will display to the user in
        //  the action type combo box for the current type.
        //
        m_pszAllTypeString = CmLoadString(hInstance, IDS_ALLCONACT);

        if (NULL == m_pszAllTypeString)
        {
            CMASSERTMSG(FALSE, TEXT("EnsureActionTypeStringsLoaded -- Failed to load a all action display string."));

            //
            //  Special case the all string because we don't have a section string for it
            //
            m_pszAllTypeString = CmStrCpyAlloc(TEXT("All"));

            if (NULL == m_pszAllTypeString)
            {
                goto exit;
            }            
        }
    }

    //
    //  Load the rest of the type display strings
    //
    for (int i = 0; i < c_iNumCustomActionTypes; i++)
    {
        if (NULL == m_ActionTypeStrings[i])
        {
            //
            //  LoadString the string we will display to the user in
            //  the action type combo box for the current type.
            //
            m_ActionTypeStrings[i] = CmLoadString(hInstance, BASE_ACTION_STRING_ID + i);
            if (NULL == m_ActionTypeStrings[i])
            {
                CMASSERTMSG(FALSE, TEXT("EnsureActionTypeStringsLoaded -- Failed to load a custom action type display string."));

                //
                //  Try to use the section name instead of the localized version, if that fails then bail
                //
                m_ActionTypeStrings[i] = CmStrCpyAlloc(m_ActionSectionStrings[i]);

                if (NULL == m_ActionTypeStrings[i])
                {
                    goto exit;
                }            
            }
        }
    }

    //
    //  If we got this far everything should be peachy
    //
    hr = S_OK;

exit:
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::AddExecutionTypesToComboBox
//
// Synopsis:  This function adds the execution type strings (Direct connections only,
//            Dialup connections only, etc.) to the given combobox.  Note that if
//            tunneling is disabled then the combo box is disabled after being
//            filled in.  This is because this choice is only relevant to tunneling
//            profiles.
//
// Arguments: HWND hDlg - window handle of the dialog containing the combo box
//            UINT uCtrlId - combo box control ID
//            HINSTANCE hInstance - instance handle for loading string resources
//            BOOL bUseTunneling - is this a tunneling profile?
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::AddExecutionTypesToComboBox(HWND hDlg, UINT uCtrlId, HINSTANCE hInstance, BOOL bUseTunneling)
{
    HRESULT hr = E_OUTOFMEMORY;
    INT_PTR nResult;
    //
    //  Clear the combo list
    //
    SendDlgItemMessage(hDlg, uCtrlId, CB_RESETCONTENT, 0, (LPARAM)0); //lint !e534 CB_RESETCONTENT doesn't return anything useful

    //
    //  Load the of the execution display strings
    //

    for (int i = 0; i < c_iNumCustomActionExecutionStates; i++)
    {
        if (NULL == m_ExecutionStrings[i])
        {
            //
            //  LoadString the string we will display to the user in
            //  the execution combo box on the custom action popup dialog
            //
            m_ExecutionStrings[i] = CmLoadString(hInstance, BASE_EXECUTION_STRING_ID + i);
            if (NULL == m_ExecutionStrings[i])
            {
                CMASSERTMSG(FALSE, TEXT("AddExecutionTypesToComboBox -- Failed to load a custom action execution display string."));
                goto exit;
            }
        }

        //
        //  Add the string to the combo box
        //
        SendDlgItemMessage(hDlg, uCtrlId, CB_ADDSTRING, 0, (LPARAM)m_ExecutionStrings[i]);            
    }    

    //
    //  Pick the first item in the list by default
    //
    nResult = SendDlgItemMessage(hDlg, uCtrlId, CB_GETCOUNT, (WPARAM)0, (LPARAM)0);
    if ((CB_ERR != nResult) && (nResult > 0))
    {
        MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, uCtrlId, CB_SETCURSEL, (WPARAM)0, (LPARAM)0));
    }


    //
    //  If we aren't tunneling, then the control should be disabled since we only
    //  have one type of connection available to the user ... dialup connections.
    //  However, we will set the flags to 0 at this point, indicating connect for
    //  all connections (to fit in with legacy behavior).
    //
    if (!bUseTunneling)
    {
        EnableWindow(GetDlgItem(hDlg, uCtrlId), FALSE);
    }

    //
    //  If we got this far everything should be peachy
    //
    hr = S_OK;

exit:
    return hr;

}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::FillInTempDescription
//
// Synopsis:  This function creates the temporary description used for a custom
//            action if the user didn't specify one.  The temporary description
//            is the Program concatenated with the displayed parameters string
//            (namely the function name and the parameters together).
//
// Arguments: HWND hDlg - window handle of the dialog containing the combo box
//            UINT uCtrlId - combo box control ID
//            HINSTANCE hInstance - instance handle for loading string resources
//            BOOL bUseTunneling - is this a tunneling profile?
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::FillInTempDescription(CustomActionListItem* pCustomAction)
{
    MYDBGASSERT(pCustomAction);
    MYDBGASSERT(TEXT('\0') == pCustomAction->szDescription[0]);

    if ((NULL == pCustomAction) || (TEXT('\0') != pCustomAction->szDescription[0]))
    {
        return E_INVALIDARG;
    }

    TCHAR* pszFileName;
    pCustomAction->bTempDescription = TRUE;

    if (pCustomAction->bIncludeBinary)
    {
        //
        //  We want just the filename (not the entire path) associated with the
        //  item if the user is including the binary.
        //
        pszFileName = CmStrrchr(pCustomAction->szProgram, TEXT('\\'));

        if (pszFileName)
        {
            pszFileName = CharNext(pszFileName);
        }
        else
        {
            pszFileName = pCustomAction->szProgram;
        }
    }
    else
    {
        pszFileName = pCustomAction->szProgram;
    }

    lstrcpyn(pCustomAction->szDescription, pszFileName, CELEMS(pCustomAction->szDescription));
    UINT uNumCharsLeftInDesc = CELEMS(pCustomAction->szDescription) - lstrlen(pCustomAction->szDescription);
    LPTSTR pszCurrent = pCustomAction->szDescription + lstrlen(pCustomAction->szDescription);

    if (pCustomAction->szFunctionName[0] && uNumCharsLeftInDesc)
    {
        //
        //  If we have space left in the description add a space and the function name next
        //
        *pszCurrent = TEXT(' ');
        uNumCharsLeftInDesc--;
        pszCurrent++;

        lstrcpyn(pszCurrent, pCustomAction->szFunctionName, uNumCharsLeftInDesc);

        pszCurrent = pCustomAction->szDescription + lstrlen(pCustomAction->szDescription);
        uNumCharsLeftInDesc = (UINT)(CELEMS(pCustomAction->szDescription) - (pszCurrent - pCustomAction->szDescription) - 1);// one for the NULL char
    }

    if (pCustomAction->pszParameters && pCustomAction->pszParameters[0] && uNumCharsLeftInDesc)
    {
        *pszCurrent = TEXT(' ');
        uNumCharsLeftInDesc--;
        pszCurrent++;

        lstrcpyn(pszCurrent, pCustomAction->pszParameters, uNumCharsLeftInDesc);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::MapIndexToFlags
//
// Synopsis:  This function gives the caller the Flags value for the given
//            combobox index.
//
// Arguments: int iIndex - combo index to retrieve the flags for
//            DWORD* pdwFlags - DWORD pointer to receive the flags value
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::MapIndexToFlags(int iIndex, DWORD* pdwFlags)
{
    if ((NULL == pdwFlags) || (c_iNumCustomActionExecutionStates <= iIndex) || (0 > iIndex))
    {
        return E_INVALIDARG;
    }

    *pdwFlags = (CustomActionExecutionStates)c_iExecutionIndexToFlagsMap[iIndex];

    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::MapFlagsToIndex
//
// Synopsis:  This function gives the caller the index value of the given flags
//            value.  Thus if you have a flags value, this function will tell you
//            which combobox index to pick to get the string for that flags value.
//
// Arguments: DWORD dwFlags - flags value to lookup the index for
//            int* piIndex - pointer to recieve the index value
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::MapFlagsToIndex(DWORD dwFlags, int* piIndex)
{
    if ((NULL == piIndex) || (c_dwLargestExecutionState < dwFlags))
    {
        return E_INVALIDARG;
    }

    //
    //  The flags are based on a bit mask.  First look for all connections (since its
    //  zero) and then start looking for the most specific connection types first 
    //  (direct/dialup only before all dialup/tunnel).  Also note that we give precedent
    //  to tunnel connections.
    //
    DWORD dwHighestBitSet;

    if (ALL_CONNECTIONS == dwFlags)
    {
        dwHighestBitSet = 0;    
    }
    else if (dwFlags & DIRECT_ONLY)
    {
        dwHighestBitSet = 1;
    }
    else if (dwFlags & DIALUP_ONLY)
    {
        dwHighestBitSet = 3;
    }
    else if (dwFlags & ALL_TUNNEL)
    {
        dwHighestBitSet = 4;
    }
    else if (dwFlags & ALL_DIALUP)
    {
        dwHighestBitSet = 2;
    }
    else
    {
        return E_INVALIDARG;
    }

    *piIndex = c_iExecutionFlagsToIndexMap[dwHighestBitSet];

    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::GetListPositionAndBuiltInState
//
// Synopsis:  This function searches for the item in question and returns to the
//            caller whether the item has the following boolean properties:
//              First in its custom action list
//              Last in its custom action list
//              A built in custom action
//            Note that -1 (0xFFFFFFFF) is returned for a true value
//                       0 for a false value
//
//
// Arguments: CustomActionListItem* pItem - item to look for (only desc and 
//                                          type are needed)
//            int* piFirstInList - pointer to store whether this is the first
//                                 item in the list or not
//            int* piLastInList - pointer to store whether this is the last
//                                 item in the list or not
//            int* piIsBuiltIn - pointer to store whether this item is a built
//                               in custom action or not
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::GetListPositionAndBuiltInState(HINSTANCE hInstance, CustomActionListItem* pItem, int* piFirstInList, 
                                                         int* piLastInList, int *piIsBuiltIn)
{
    MYDBGASSERT(pItem);
    MYDBGASSERT(piFirstInList);
    MYDBGASSERT(piLastInList);
    MYDBGASSERT(piIsBuiltIn);

    if ((NULL == pItem) || (NULL == piFirstInList) || (NULL == piLastInList) || (NULL == piIsBuiltIn))
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    CustomActionListItem* pCurrent = NULL;
    CustomActionListItem* pFollower = NULL;

    //
    //  Search for the item
    //
    hr = Find(hInstance, pItem->szDescription, pItem->Type, &pCurrent, &pFollower);

    if (SUCCEEDED(hr))
    {
        *piFirstInList = (m_CustomActionHash[pItem->Type] == pCurrent) ? -1 : 0;

        *piLastInList = (pCurrent && (NULL == pCurrent->Next)) ? -1 : 0;

        *piIsBuiltIn = (pCurrent->bBuiltInAction) ? -1 : 0;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::IsCmDl
//
// Synopsis:  Checks to see if the passed in filename cmdl32.exe
//
// Arguments: LPTSTR szFileName - filename to check
//
// Returns:   BOOL - returns TRUE if the dll is one of the cmdl dll's
//
// History:   quintinb  Created    11/24/97
//
//+----------------------------------------------------------------------------
BOOL CustomActionList::IsCmDl(CustomActionListItem* pItem)
{
    MYDBGASSERT(pItem);

    BOOL bRet = FALSE;

    if (pItem && (ONCONNECT == pItem->Type))
    {
        LPTSTR pszFileName = CmStrrchr(pItem->szProgram, TEXT('\\'));

        if (pszFileName)
        {
            pszFileName = CharNext(pszFileName);
        }
        else
        {
            pszFileName = pItem->szProgram;
        }

        if (0 == lstrcmpi(pszFileName, TEXT("cmdl32.exe")))
        {
            bRet = TRUE;
        }
    }
    return bRet;
}


//+----------------------------------------------------------------------------
//
// Function:  CustomActionListEnumerator::CustomActionListEnumerator
//
// Synopsis:  Constructor for the CustomActionListEnumerator class.  This function
//            requires a CustomActionList to enumerate from.
//
// Arguments: CustomActionList* pActionListToWorkFrom - custom action list class
//                                                      to enumerate
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
CustomActionListEnumerator::CustomActionListEnumerator(CustomActionList* pActionListToWorkFrom)
{
    MYDBGASSERT(pActionListToWorkFrom);
    m_pActionList = pActionListToWorkFrom;

    Reset();
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionListEnumerator::Reset
//
// Synopsis:  Resets the CustomActionListEnumerator class.  Thus the user can
//            restart the enumeration by resetting the class.
//
// Arguments: None
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
void CustomActionListEnumerator::Reset()
{
    m_iCurrentList = 0;
    m_pCurrentListItem = NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionListEnumerator::GetNextIncludedProgram
//
// Synopsis:  This function is the work horse of the enumerator.  It gets the
//            next item in the enumeration with an included program.  This
//            enumerator is useful for getting all of the files that need to be
//            included in the profile.
//
// Arguments: TCHAR* pszProgram - string buffer to hold the next program
//            DWORD dwBufferSize - size of the passed in buffer
//
// Returns:   HRESULT - standard COM error codes.
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionListEnumerator::GetNextIncludedProgram(TCHAR* pszProgram, DWORD dwBufferSize)
{
    HRESULT hr = S_FALSE;
    CustomActionListItem* pItem;

    if (pszProgram && dwBufferSize)
    {
        if (m_pActionList)
        {
            while (m_iCurrentList < c_iNumCustomActionTypes)
            {
                if (m_pCurrentListItem)
                {
                    //
                    //  We are in the middle of an enumeration, use pCurrentProgramFileNameItem
                    //  as the next item to examine.
                    //
                    pItem = m_pCurrentListItem;
                }
                else
                {
                    //
                    //  We are just starting or we have exhausted the current list
                    //
                    pItem = m_pActionList->m_CustomActionHash[m_iCurrentList];
                }

                while (pItem)
                {

                    if (pItem->bIncludeBinary)
                    {
                        //
                        //  We have the next item to pass back
                        //
                        lstrcpyn(pszProgram, pItem->szProgram, dwBufferSize);
                        
                        //
                        //  Next time we look for an item, start with the next in the list
                        //
                        m_pCurrentListItem = pItem->Next;

                        //
                        //  If m_pCurrentListItem is NULL, we are at the end of the list now
                        //  and we want to increment m_iCurrentList so that we start at the
                        //  next list for the next item or terminate properly if we are
                        //  on the last list
                        //
                        if (NULL == m_pCurrentListItem)
                        {
                            m_iCurrentList++;
                        }
                        
                        hr = S_OK;
                        goto exit;
                    }

                    pItem = pItem->Next;
                }
                
                m_pCurrentListItem = NULL;
                m_iCurrentList++;
            }
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\profwiz\listview.h ===
//+----------------------------------------------------------------------------
//
// File:     listview.h
//
// Module:   CMAK.EXE
//
// Synopsis: Function definitions of the helper functions used by CMAK to deal
//           with the custom action list view control.
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   quintinb   Created                         02/26/00
//
//+----------------------------------------------------------------------------

BOOL UpdateListViewColumnHeadings(HINSTANCE hInstance, HWND hListView, UINT uStringID, int iColumnIndex);
BOOL AddListViewColumnHeadings(HINSTANCE hInstance, HWND hListView);

HRESULT MapComboSelectionToType(HWND hDlg, UINT uCtrlID, BOOL bIncludesAll, BOOL bUseTunneling, CustomActionTypes* pType);
HRESULT GetDescriptionAndTypeOfItem(HINSTANCE hInstance, HWND hDlg, HWND hListView, UINT uComboBoxId, CustomActionListItem* pItem, int* piItemIndex, BOOL bUseTunneling);
HRESULT GetItemTypeByListViewIndex(HINSTANCE hInstance, HWND hListView, CustomActionTypes* pType, int* piIndex);
void SetListViewSelection(HWND hListView, int iIndex);

void RefreshEditDeleteMoveButtonStates(HINSTANCE hInstance, HWND hDlg, HWND hListView, UINT uComboCtrlId, int* piIndex, BOOL bUseTunneling);
void RefreshListView(HINSTANCE hInstance, HWND hDlg, UINT uComboCtrlId, HWND hListView, int iItemToSelect, BOOL bUseTunneling);
void OnProcessCustomActionsAdd(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling);
void OnProcessCustomActionsDelete(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling);
void OnProcessCustomActionsEdit(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling);
void OnProcessCustomActionsMoveUp(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling);
void OnProcessCustomActionsMoveDown(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling);
void OnProcessCustomActionsContextMenu(HINSTANCE hInstance, HWND hDlg, HWND hListView, 
                                       NMITEMACTIVATE* pItemActivate, BOOL bUseTunneling, UINT uComboCtrlId);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\profwiz\customaction.h ===
//+----------------------------------------------------------------------------
//
// File:     customaction.h
//
// Module:   CMAK.EXE
//
// Synopsis: Header file for the CustomActionList and CustomActionListEnumerator
//           classes used by CMAK to handle its custom actions.
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   quintinb   Created                         02/26/00
//
//+----------------------------------------------------------------------------

#include "conact.h"

//
//  We display the flags to the user in a different order than the flags were created.  Thus we have to arrays to
//  map between the display order and the actual order and vice versa.
//
const int c_iExecutionIndexToFlagsMap[c_iNumCustomActionExecutionStates] = {ALL_CONNECTIONS, ALL_DIALUP, ALL_TUNNEL, DIRECT_ONLY, DIALUP_ONLY};
const int c_iExecutionFlagsToIndexMap[c_iNumCustomActionExecutionStates] = {0, 3, 1, 4, 2};

//
//  Enum for Connect Action Types
//
const int c_iNumCustomActionTypes = 9;
enum CustomActionTypes
{
    PREINIT = 0,
    PRECONNECT = 1,
    PREDIAL = 2,
    PRETUNNEL = 3,
    ONCONNECT = 4,
    ONINTCONNECT = 5,
    ONDISCONNECT = 6,
    ONCANCEL = 7,
    ONERROR = 8,
    ALL = -1
};

struct CustomActionListItem
{
    TCHAR szDescription[MAX_PATH+1];
    TCHAR szProgram[MAX_PATH+1];
    TCHAR szFunctionName[MAX_PATH+1];
    LPTSTR pszParameters;
    BOOL bIncludeBinary;
    BOOL bBuiltInAction;
    BOOL bTempDescription;
    CustomActionTypes Type;
    DWORD dwFlags;
    CustomActionListItem* Next;
};

class CustomActionList
{

    //
    //  This enumerator class is used to enumerate
    //  the data in the Custom Action List class.
    //  This allows the enumerator to have access to
    //  the private data of CustomActionList but
    //  controls how the user of this class accesses
    //  that data.
    //
    friend class CustomActionListEnumerator;

private:

    //
    //  Array of Linked lists to hold the custom actions
    //
    CustomActionListItem* m_CustomActionHash[c_iNumCustomActionTypes];

    //
    //  Array of string pointers to hold the custom action type strings, plus
    //  the special All type string pointer.
    //
    TCHAR* m_ActionTypeStrings[c_iNumCustomActionTypes];
    TCHAR* m_pszAllTypeString;

    //
    //  Array of string pointers to hold the CMS section names for each type
    //  of custom action.  Note that these strings are const TCHAR* const and
    //  shouldn't be free-ed.
    //
    TCHAR* m_ActionSectionStrings[c_iNumCustomActionTypes];
    
    //
    //  Array of string pointers to hold the custom action execution state
    //  strings.  These are added to the combo box on the Add/Edit custom
    //  action dialog to allow the user to pick when a custom action is
    //  executed
    //
    TCHAR* m_ExecutionStrings[c_iNumCustomActionExecutionStates];

    //
    //  Functions internal to the class
    //
    HRESULT ParseCustomActionString(LPTSTR pszStringToParse, CustomActionListItem* pCustomAction, TCHAR* pszShortServiceName);
    HRESULT Find(HINSTANCE hInstance, LPCTSTR pszDescription, CustomActionTypes Type, CustomActionListItem** ppItem, CustomActionListItem** ppFollower);
    HRESULT EnsureActionTypeStringsLoaded(HINSTANCE hInstance);
    BOOL IsCmDl(CustomActionListItem* pItem);


public:
    CustomActionList();
    ~CustomActionList();
    HRESULT ReadCustomActionsFromCms(HINSTANCE hInstance, TCHAR* pszCmsFile, TCHAR* pszShortServiceName);
    HRESULT WriteCustomActionsToCms(TCHAR* pszCmsFile, TCHAR* pszShortServiceName, BOOL bUseTunneling);
    HRESULT Add(HINSTANCE hInstance, CustomActionListItem* pCustomAction, LPCTSTR pszShortServiceName);
    HRESULT Edit(HINSTANCE hInstance, CustomActionListItem* pOldCustomAction, CustomActionListItem* pNewCustomAction, LPCTSTR pszShortServiceName);
    HRESULT GetExistingActionData(HINSTANCE hInstance, LPCTSTR pszDescription, CustomActionTypes Type, CustomActionListItem** ppCustomAction);
    HRESULT Delete(HINSTANCE hInstance, TCHAR* pszDescription, CustomActionTypes Type);
    HRESULT MoveUp(HINSTANCE hInstance, TCHAR* pszDescription, CustomActionTypes Type);
    HRESULT MoveDown(HINSTANCE hInstance, TCHAR* pszDescription, CustomActionTypes Type);
    HRESULT AddCustomActionTypesToComboBox(HWND hDlg, UINT uCtrlId, HINSTANCE hInstance, BOOL bUseTunneling, BOOL bAddAll);
    HRESULT AddCustomActionsToListView(HWND hListView, HINSTANCE hInstance, CustomActionTypes Type, BOOL bUseTunneling, int iItemToSelect, BOOL bTypeInSecondCol);
    HRESULT GetTypeFromTypeString(HINSTANCE hInstance, TCHAR* pszTypeString, CustomActionTypes* pType);
    HRESULT GetTypeStringFromType(HINSTANCE hInstance, CustomActionTypes Type, TCHAR** ppszTypeString);
    HRESULT AddExecutionTypesToComboBox(HWND hDlg, UINT uCtrlId, HINSTANCE hInstance, BOOL bUseTunneling);
    HRESULT MapIndexToFlags(int iIndex, DWORD* pdwFlags);
    HRESULT MapFlagsToIndex(DWORD dwFlags, int* piIndex);
    HRESULT FillInTempDescription(CustomActionListItem* pCustomAction);
    HRESULT GetListPositionAndBuiltInState(HINSTANCE hInstance, CustomActionListItem* pItem, BOOL* pbFirstInList, BOOL* pbLastInList, BOOL *pIsBuiltIn);
    HRESULT AddOrRemoveCmdl(HINSTANCE hInstance, BOOL bAddCmdl, BOOL bForVpn);
};

class CustomActionListEnumerator
{
private:
    int m_iCurrentList;
    CustomActionListItem* m_pCurrentListItem;
    CustomActionList* m_pActionList;

public:
    CustomActionListEnumerator(CustomActionList* pActionListToWorkFrom);
//    ~CustomActionListEnumerator(); // currently not needed
    void Reset();
    HRESULT GetNextIncludedProgram(TCHAR* pszProgram, DWORD dwBufferSize);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\profwiz\netsettings.h ===
//+----------------------------------------------------------------------------
//
// File:     netsettings.h
//
// Module:   CMAK.EXE
//
// Synopsis: Function headers and structures dealing with network 
//           settings (DUN settings)
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   quintinb   Created     03/22/00
//
//+----------------------------------------------------------------------------

#define SAME_ON_ALL_PLATFORMS           0
#define SEPARATE_FOR_LEGACY_AND_WIN2K   1
#define FORCE_WIN2K_AND_ABOVE           2

class CDunSetting
{
public:
    //
    //  Functions
    //
    CDunSetting(BOOL bTunnel = FALSE);
    ~CDunSetting();

    //
    //  Basic Settings
    //
    BOOL bNetworkLogon; // defaults to zero on Dialup but 1 on Tunnel
    BOOL bPppSoftwareCompression;
    BOOL bDisableLCP;

    TCHAR szScript[MAX_PATH+1];
    DWORD dwVpnStrategy;
    BOOL bTunnelDunSetting;

    //
    //  TCP/IP Settings
    //
    DWORD dwPrimaryDns;
    DWORD dwSecondaryDns;
    DWORD dwPrimaryWins;
    DWORD dwSecondaryWins;
    BOOL bIpHeaderCompression;
    BOOL bGatewayOnRemote;

    //
    //  Security Settings
    //
    BOOL bPWEncrypt;
    BOOL bPWEncrypt_MS;
    BOOL bDataEncrypt;
    DWORD dwEncryptionType;
    BOOL bAllowPap;
    BOOL bAllowSpap;
    BOOL bAllowEap;
    BOOL bAllowChap;
    BOOL bAllowMsChap;
    BOOL bAllowMsChap2;
    BOOL bAllowW95MsChap;
    BOOL bSecureLocalFiles;
    int iHowToHandleSecuritySettings;

    //
    //  EAP Data
    //
    DWORD dwCustomAuthKey;
    LPBYTE pCustomAuthData;
    DWORD dwCustomAuthDataSize;

    //
    //  Pre-shared Key
    //
    BOOL bUsePresharedKey;
};

//
// From RAS\UI\COMMON\PBK\UTIL.C
//

#ifndef EAP_CUSTOM_DATA

#define EAP_CUSTOM_KEY      0x43424431

typedef struct _EAP_CUSTOM_DATA
{
    DWORD dwSignature;
    DWORD dwCustomAuthKey;
    DWORD dwSize;
    BYTE  abdata[1];
} EAP_CUSTOM_DATA;

#endif

typedef struct EAPDataStruct
{
    DWORD dwCustomAuthKey;
    LPBYTE pCustomAuthData;
    DWORD dwCustomAuthDataSize;
    LPTSTR pszFriendlyName;
    LPTSTR pszConfigDllPath;
    BOOL bSupportsEncryption;
    BOOL bMustConfig;
    BOOL bNotInstalled;
}EAPData;

typedef struct GetBoolSettingsStruct
{
    LPCTSTR pszKeyName;
    LPBOOL pbValue;
    BOOL bDefault;
}GetBoolSettings;

typedef struct SetBoolSettingsStruct
{
    LPTSTR pszSectionName;
    LPCTSTR pszKeyName;
    BOOL bValue;
}SetBoolSettings;

BOOL ReadDunServerSettings(LPCTSTR pszSectionName, CDunSetting* pDunSetting, LPCTSTR pszCmsFile, BOOL bTunnelDunSetting);
BOOL ReadDunNetworkingSettings(LPCTSTR pszSectionName, CDunSetting* pDunSetting, LPCTSTR pszCmsFile, BOOL bTunnel);
DWORD ConvertIpStringToDword(LPTSTR pszIpAddress);
int ConvertIpDwordToString(DWORD dwIpAddress, LPTSTR pszIpAddress);
BOOL ReadDunTcpIpSettings(LPCTSTR pszSectionName, CDunSetting* pDunSetting, LPCTSTR pszCmsFile);
BOOL ReadDunScriptingSettings(LPCTSTR pszSectionName, CDunSetting* pDunSetting, LPCTSTR pszOsDir, LPCTSTR pszCmsFile);
BOOL AddDunNameToListIfDoesNotExist(LPCTSTR pszDunName, ListBxList **pHeadDns, ListBxList** pTailDns, BOOL bTunnelDunName);
BOOL GetDunEntryNamesFromPbk(LPCTSTR pszPhoneBook, ListBxList **pHeadDns, ListBxList** pTailDns);
BOOL ReadNetworkSettings(LPCTSTR pszCmsFile, LPCTSTR pszLongServiceName, LPCTSTR pszPhoneBook, 
                         ListBxList **pHeadDns, ListBxList** pTailDns, LPCTSTR pszOsDir, BOOL bLookingForVpnEntries);
void WriteOutNetworkingEntry(LPCTSTR pszDunName, CDunSetting* pDunSetting, LPCTSTR pszShortServiceName, LPCTSTR pszCmsFile);
void EraseNetworkingSections(LPCTSTR pszDunName, LPCTSTR pszCmsFile);
void WriteNetworkingEntries(LPCTSTR pszCmsFile, LPCTSTR pszLongServiceName, LPCTSTR pszShortServiceName, ListBxList *pHeadDns);
void EnableAppropriateSecurityControls(HWND hDlg);
void EnableDisableSecurityButtons(HWND hDlg);
INT_PTR CreateNetworkingEntryPropertySheet(HINSTANCE hInstance, HWND hWizard, LPARAM lParam, BOOL bEdit);
void OnProcessDunEntriesAdd(HINSTANCE hInstance, HWND hDlg, UINT uListCtrlId, ListBxStruct** pHeadDns, ListBxStruct** pTailDns, BOOL bCreateTunnelEntry, LPCTSTR pszLongServiceName, LPCTSTR pszCmsFile);
void OnProcessDunEntriesEdit(HINSTANCE hInstance, HWND hDlg, UINT uListCtrlId, ListBxStruct** pHeadDns, ListBxStruct** pTailDns, LPCTSTR pszLongServiceName, LPCTSTR pszCmsFile);
void OnProcessDunEntriesDelete(HINSTANCE hInstance, HWND hDlg, UINT uListCtrlId, ListBxStruct** pHeadDns, ListBxStruct** pTailDns, LPCTSTR pszLongServiceName, LPCTSTR pszCmsFile);
void EnableDisableIpAddressControls(HWND hDlg);
INT_PTR APIENTRY ProcessSecurityPopup(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY ProcessWin2kSecurityPopup(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY GeneralPropSheetProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY TcpIpPropSheetProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY SecurityPropSheetProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
void RefreshDnsList(HINSTANCE hInstance, HWND hDlg, UINT uCtrlId, ListBxList * pHead, LPCTSTR pszLongServiceName, LPCTSTR pszCmsFile, LPTSTR pszItemToSelect);

HRESULT HrAddAvailableEAPsToCombo(HWND hDlg, UINT uCtrlId, CDunSetting* pDunSetting);
HRESULT HrQueryRegStringWithAlloc(HKEY hKey, LPCTSTR pszValueName, TCHAR** ppszReturnString);
void SelectAppropriateEAP(HWND hDlg, UINT uCtrlId, CDunSetting* pDunSetting);
void FreeEapData(HWND hDlg, UINT uCtrlId);
BOOL ReadDunSettingsEapData(LPCTSTR pszSection, LPBYTE* ppbEapData, LPDWORD pdwEapSize, const DWORD dwCustomAuthKey, LPCTSTR pszCmsFile);
HRESULT WriteDunSettingsEapData(LPCTSTR pszSection, CDunSetting* pDunSetting, LPCTSTR pszCmsFile);
HRESULT EraseDunSettingsEapData(LPCTSTR pszSection, LPCTSTR pszCmsFile);
BYTE HexValue(IN CHAR ch);
CHAR HexChar(IN BYTE byte);
void FreeDnsList(ListBxList ** pHeadPtr, ListBxList ** pTailPtr);
void EnableDisableDunEntryButtons(HINSTANCE hInstance, HWND hDlg, LPCTSTR pszCmsFile, LPCTSTR pszLongServiceName);
int MapEncryptionTypeToComboId(DWORD dwEncryptionType);
DWORD MapComboIdToEncryptionType(INT_PTR iComboIndex);
BOOL VerifyVpnFile(LPCTSTR pszVpnFile);
BOOL CheckForDUNversusVPNNameConflicts(HWND hDlg, ListBxList * pHeadDunEntry, ListBxList * pHeadVpnEntry);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\profwiz\listview.cpp ===
//+----------------------------------------------------------------------------
//
// File:     listview.cpp
//
// Module:   CMAK.EXE
//
// Synopsis: Implemenation of the helper functions used by CMAK to deal with the
//           custom action list view control.
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   quintinb   Created                         02/26/00
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//+----------------------------------------------------------------------------
//
// Function:  UpdateListViewColumnHeadings
//
// Synopsis:  This function sets the column heading text specified by the given
//            column index and list view control window handle to the string
//            resource specified by the given instance handle and string Id.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hListView - window handle of the list view control
//            UINT uStringID - string id of the desired text
//            int iColumnIndex - desired column to update the text of
//
// Returns:   BOOL - TRUE on success, FALSE otherwise
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
BOOL UpdateListViewColumnHeadings(HINSTANCE hInstance, HWND hListView, UINT uStringID, int iColumnIndex)
{
    BOOL bReturn = FALSE;

    MYDBGASSERT(hInstance);
    MYDBGASSERT(hListView);
    MYDBGASSERT(uStringID);

    if (hInstance && hListView && uStringID)
    {
        //
        //  First get the requested string
        //
        LVCOLUMN lvColumn = {0};

        lvColumn.mask = LVCF_TEXT;
        lvColumn.pszText = CmLoadString(hInstance, uStringID);

        MYDBGASSERT(lvColumn.pszText);
        if (lvColumn.pszText)
        {
            bReturn = ListView_SetColumn(hListView, iColumnIndex, &lvColumn);
            CmFree(lvColumn.pszText);
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  AddListViewColumnHeadings
//
// Synopsis:  This function creates the description and type columns
//            used by the default view of the custom action page.  Once this
//            function has been called, UpdateListViewColumnHeadings should
//            be used to change the column headings as necessary.  This function
//            will need to be modified if more columns are deemed necessary.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hListView - window handle of the list view control
//
// Returns:   BOOL - TRUE on success, FALSE otherwise
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
BOOL AddListViewColumnHeadings(HINSTANCE hInstance, HWND hListView)
{
    //
    //  Add the column headings
    //
    LVCOLUMN lvColumn = {0};

    lvColumn.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.pszText = CmLoadString(hInstance, IDS_DESC_COL_TITLE);
    lvColumn.iSubItem = 0;

    MYDBGASSERT(lvColumn.pszText);
    if (lvColumn.pszText)
    {
        ListView_InsertColumn(hListView, 0, &lvColumn);
        CmFree(lvColumn.pszText);
    }
    else
    {
        return FALSE;
    }
    
    lvColumn.pszText = CmLoadString(hInstance, IDS_TYPE_COL_TITLE);
    lvColumn.iSubItem = 1;

    MYDBGASSERT(lvColumn.pszText);
    if (lvColumn.pszText)
    {
        ListView_InsertColumn(hListView, 1, &lvColumn);
        CmFree(lvColumn.pszText);
    }
    else
    {
        return FALSE;
    }

    //
    //  Now lets size the columns so that the text is visible.  Since we
    //  only have two columns of text, lets call GetWindowRect on the
    //  list view control and then set the column widths to each take
    //  up about half of the space available.
    //
    RECT Rect = {0};
    LONG lColumnWidth;

    if (GetWindowRect(hListView, &Rect))
    {
        //
        //  Subtract 5 from each to keep a scroll bar from appearing
        //
        lColumnWidth = (Rect.right - Rect.left)/2 - 5;

        if (0 < lColumnWidth)
        {
            for (int i=0; i < 2; i++)
            {
                MYVERIFY(ListView_SetColumnWidth(hListView, i, lColumnWidth));
            }
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  MapComboSelectionToType
//
// Synopsis:  This function gets the current selection from the given
//            combobox and maps the index to a custom action type.
//
// Arguments: HWND hDlg - window handle to the dialog that contains the combobox
//            UINT uCtrlID - control id of the combobox
//            BOOL bIncludesAll - when TRUE
//            BOOL bUseTunneling - whether this is a tunneling profile or not
//            CustomActionTypes* pType
//
// Returns:   HRESULT - Standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT MapComboSelectionToType(HWND hDlg, UINT uCtrlID, BOOL bIncludesAll, BOOL bUseTunneling, CustomActionTypes* pType)
{
    //
    //  Check Params
    //
    if ((NULL == hDlg) || (0 == uCtrlID) || (NULL == pType))
    {
        CMASSERTMSG(FALSE, TEXT("MapComboSelectionToType -- invalid parameter passed"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    INT_PTR nResult = SendDlgItemMessage(hDlg, uCtrlID, CB_GETCURSEL, 0, (LPARAM)0);

    if (nResult != LB_ERR)
    {
        //
        //  If the combobox contains the All choice, we need to correct
        //  the type depending on what the user chose.
        //

        if (bIncludesAll)
        {
            if (0 == nResult)
            {
                *pType = ALL;
                goto exit;
            }
            else
            {
                nResult--;
            }                    
        }

        //
        //  We need to make a correction if we aren't Tunneling because the 
        //  tunneling type won't be in the combobox
        //
        if (FALSE == bUseTunneling)
        {
            if (PRETUNNEL <= (CustomActionTypes)nResult)
            {
                nResult++;            
            }
        }

        *pType = (CustomActionTypes)nResult;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

exit:
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  GetItemTypeByListViewIndex
//
// Synopsis:  This function gets the current selection index of the list view
//            control and gets the type string.  The type string is then
//            converted into a numeric type and returned via the pType
//            pointer.
//
// Arguments: HINSTANCE hInstance - instance handle for string resources
//            HWND hListView - window handle of the list view control
//            CustomActionTypes* pType - pointer to hold the type of the item
//
// Returns:   HRESULT - Standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT GetItemTypeByListViewIndex(HINSTANCE hInstance, HWND hListView, CustomActionTypes* pType, int *piIndex)
{
    //
    //  Check params
    //
    if ((NULL == hListView) || (NULL == pType) || (NULL == g_pCustomActionList))
    {
        CMASSERTMSG(FALSE, TEXT("GetItemTypeByListViewIndex -- invalid parameter passed"));
        return E_INVALIDARG;
    }

    //
    //  The user has the All view selected, further work is needed to select the
    //  appropriate type.
    //
    HRESULT hr = S_OK;

    if (-1 == *piIndex)
    {
        *piIndex = ListView_GetSelectionMark(hListView);
    }

    int iTemp = *piIndex;

    if (-1 != iTemp)
    {
        LVITEM lvItem = {0};
        TCHAR szTemp[MAX_PATH+1];

        szTemp[0] = TEXT('\0');

        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = szTemp;
        lvItem.cchTextMax = MAX_PATH;
        lvItem.iItem = iTemp;
        lvItem.iSubItem = 1;

        if (ListView_GetItem(hListView,  &lvItem))
        {
            hr = g_pCustomActionList->GetTypeFromTypeString(hInstance, lvItem.pszText, pType);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);    
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  GetDescriptionAndTypeOfItem
//
// Synopsis:  This function gets the type and description of the item specified
//            by the passed in item index.  If the caller passes -1 for this index,
//            the currently selected item is used and the actual index is passed
//            back via this in/out pointer.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hDlg - window handle of the dialog containing the type combo
//            HWND hListView - window handle to the list view control
//            UINT uComboBoxId - combo box id containing the type info
//            CustomActionListItem* pItem - pointer to a custom action struct to
//                                          hold the returned type and description
//            int* piItemIndex - index of the item to get the description and
//                               type of.  If -1, then the current selection mark
//                               is used and the actual index is returned in *piItemIndex
//            BOOL bUseTunneling - whether this profile uses tunneling or not
//
// Returns:   HRESULT - Standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT GetDescriptionAndTypeOfItem(HINSTANCE hInstance, HWND hDlg, HWND hListView, UINT uComboBoxId, 
                                    CustomActionListItem* pItem, int* piItemIndex, BOOL bUseTunneling)
{
    //
    //  Check Params
    //
    if (NULL == hDlg || NULL == hListView || 0 == uComboBoxId || NULL == pItem || NULL == piItemIndex)
    {
        CMASSERTMSG(FALSE, TEXT("GetDescriptionAndTypeOfSelection -- Invalid parameter passed."));
        return E_INVALIDARG;
    }

    HRESULT hr = E_UNEXPECTED;

    //
    //  If the user passed us a -1 in *piItemIndex then they want the Description and Type of the
    //  selected item.  Otherwise, they gave us a specific item index that they want data on.
    //
    int iTemp;

    if (-1 == *piItemIndex)
    {
        iTemp = ListView_GetSelectionMark(hListView);    
    }
    else
    {
        iTemp = ListView_GetItemCount(hListView);

        if ((0 > *piItemIndex) || (iTemp <= *piItemIndex))
        {
            iTemp = -1;
        }
        else
        {
            iTemp = *piItemIndex;
        }
    }

    if (-1 != iTemp)
    {
        //
        //  Figure out the type of the item
        //
        ZeroMemory(pItem, sizeof(CustomActionListItem));

        hr = MapComboSelectionToType(hDlg, uComboBoxId, TRUE, bUseTunneling, &(pItem->Type)); //bIncludesAll == TRUE

        if (SUCCEEDED(hr))
        {
            if (ALL == pItem->Type)
            {
                hr = GetItemTypeByListViewIndex(hInstance, hListView, &(pItem->Type), &iTemp);
            }
        }

        //
        //  Now Figure out the description of the item
        //
        if (SUCCEEDED(hr))
        {
            ListView_GetItemText(hListView, iTemp, 0, pItem->szDescription, CELEMS(pItem->szDescription));
        }

        *piItemIndex = iTemp;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  RefreshEditDeleteMoveButtonStates
//
// Synopsis:  This function sets the enabled/disabled state of the Edit, Delete,
//            Move up and Move Down buttons based on the custom action specified by
//            the list view index passed in through the piIndex param.  If this
//            parameter is -1 then the currently selected item is used and
//            the actual index is returned through the int pointer.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hDlg - window handle of the dialog containing the type combo
//            HWND hListView - window handle to the list view control
//            UINT uComboBoxId - combo box id containing the type info
//            int* piIndex - index of the list view item to base the move up
//                           and move down button state on.  Again -1 will use
//                           the currently selected item.
//            BOOl bUseTunneling - whether this profile uses tunneling or not
//
// Returns:   Nothing
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
void RefreshEditDeleteMoveButtonStates(HINSTANCE hInstance, HWND hDlg, HWND hListView, UINT uComboCtrlId, int* piIndex, BOOL bUseTunneling)
{
    if ((NULL == hInstance) || (NULL == hDlg) || (NULL == hListView) || 
        (0 == uComboCtrlId) || (NULL == piIndex) || (NULL == g_pCustomActionList))
    {
        CMASSERTMSG(FALSE, TEXT("RefreshEditDeleteMoveButtonStates -- invalid parameter passed."));
        return;
    }

    int iDisableMoveUp = -1;    // -1 is the true value for GetListPositionAndBuiltInState
    int iDisableMoveDown = -1;
    int iDisableDeleteAndEdit = -1;
    HWND hControl;
    CustomActionListItem Item;

    if (ListView_GetItemCount(hListView))
    {
        //
        //  Get the description and type of the item *piIndex (if -1 then the currently selected item)
        //
        //

        ZeroMemory(&Item, sizeof(Item));
        HRESULT hr = GetDescriptionAndTypeOfItem(hInstance, hDlg, hListView, uComboCtrlId, &Item, piIndex, bUseTunneling);

        if (SUCCEEDED(hr))
        {
            hr = g_pCustomActionList->GetListPositionAndBuiltInState(hInstance, &Item, &iDisableMoveUp, &iDisableMoveDown, &iDisableDeleteAndEdit);
            MYDBGASSERT(SUCCEEDED(hr));
        }
    }

    HWND hCurrentFocus = GetFocus();
    HWND hEditButton = GetDlgItem(hDlg, IDC_BUTTON2);
    HWND hDeleteButton = GetDlgItem(hDlg, IDC_BUTTON3);
    HWND hMoveUpButton = GetDlgItem(hDlg, IDC_BUTTON4);
    HWND hMoveDownButton = GetDlgItem(hDlg, IDC_BUTTON5);

    if (hEditButton)
    {
        EnableWindow(hEditButton, (iDisableDeleteAndEdit ? 0 : 1));
    }            

    if (hDeleteButton)
    {
        EnableWindow(hDeleteButton, (iDisableDeleteAndEdit ? 0 : 1));
    }

    if (hMoveUpButton)
    {
        EnableWindow(hMoveUpButton, (iDisableMoveUp ? 0 : 1));
    }            

    if (hMoveDownButton)
    {
        EnableWindow(hMoveDownButton, (iDisableMoveDown ? 0 : 1));
    }

    
    if (FALSE == IsWindowEnabled(hCurrentFocus))
    {
        if (hDeleteButton == hCurrentFocus)
        {
            //
            //  If delete is disabled and contained the focus, shift it to the Add button
            //
            SendMessage(hDlg, DM_SETDEFID, IDC_BUTTON1, (LPARAM)0L); //lint !e534 DM_SETDEFID doesn't return error info
            hControl = GetDlgItem(hDlg, IDC_BUTTON1);
            SetFocus(hControl);
        }
        else if ((hMoveUpButton == hCurrentFocus) && IsWindowEnabled(hMoveDownButton))
        {
            SendMessage(hDlg, DM_SETDEFID, IDC_BUTTON5, (LPARAM)0L); //lint !e534 DM_SETDEFID doesn't return error info
            SetFocus(hMoveDownButton);
        }
        else if ((hMoveDownButton == hCurrentFocus) && IsWindowEnabled(hMoveUpButton))
        {
            SendMessage(hDlg, DM_SETDEFID, IDC_BUTTON4, (LPARAM)0L); //lint !e534 DM_SETDEFID doesn't return error info
            SetFocus(hMoveUpButton);                
        }
        else
        {
            //
            //  If all else fails set the focus to the listview control
            //
            SetFocus(hListView);
        }    
    }
}

//+----------------------------------------------------------------------------
//
// Function:  SelectListViewItem
//
// Synopsis:  This function trys to select a list view item with the given
//            type and description in the given listview control.  If the listview
//            doesn't contain the item we are looking for it returns FALSE and
//            doesn't change the selection.
//
// Arguments: HINSTANCE hInstance - instance handle for resources
//            HWND hDlg - window handle of the dialog containing the type combo
//            UINT uComboBoxId - combo box id containing the type info
//            HWND hListView - window handle to the list view control
//            BOOL bUseTunneling - whether this is a tunneling profile or not, 
//                                 affects whether Pre-Tunnel actions are displayed
//                                 or not.
//            CustomActionTypes TypeToSelect - type of the item to select
//            LPCTSTR pszDescription - description of the item to select
//
// Returns:   TRUE if the required item was found and selected
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
/*
BOOL SelectListViewItem(HWND hDlg, UINT uComboCtrlId, HWND hListView, BOOL bUseTunneling, CustomActionTypes TypeToSelect, LPCTSTR pszDescription)
{
    CustomActionTypes Type;
    BOOL bReturn = FALSE;
    HRESULT hr = MapComboSelectionToType(hDlg, uComboCtrlId, TRUE, bUseTunneling, &Type); //bIncludesAll == TRUE

    if ((ALL == Type) || (TypeToSelect == Type))
    {
        LVFINDINFO lvFindInfo = {0};
        LVITEM lvItem = {0};
        
        lvFindInfo.flags = LVFI_STRING;
        lvFindInfo.psz = pszDescription;

        int iIndex = ListView_FindItem(hListView, -1, &lvFindInfo);

        if (-1 != iIndex)
        {
            //
            //  Select the item
            //
            ListView_SetSelectionMark(hListView, iIndex);

            //
            //  Now set the selection state so it shows up as selected in the UI.
            //
            lvItem.mask = LVIF_STATE;
            lvItem.state = LVIS_SELECTED;
            lvItem.stateMask = LVIS_SELECTED;
            lvItem.iItem = iIndex;
            lvItem.iSubItem = 0;

            MYVERIFY(ListView_SetItem(hListView,  &lvItem));

            //
            //  Now Verify that the selection is visible
            //
            MYVERIFY(ListView_EnsureVisible(hListView, iIndex, FALSE)); // FALSE = fPartialOK, we want full visibility

            bReturn = TRUE;
        }
    }

    return bReturn;
}
*/
void SetListViewSelection(HWND hListView, int iIndex)
{
    ListView_SetSelectionMark(hListView, iIndex);

    //
    //  Now set the selection state so it shows up as selected in the UI.
    //
    LVITEM lvItem = {0};

    lvItem.mask = LVIF_STATE;
    lvItem.state = LVIS_SELECTED;
    lvItem.stateMask = LVIS_SELECTED;
    lvItem.iItem = iIndex;
    lvItem.iSubItem = 0;

    MYVERIFY(ListView_SetItem(hListView,  &lvItem));

    //
    //  Now Verify that the selection is visible
    //
    MYVERIFY(ListView_EnsureVisible(hListView, iIndex, FALSE)); // FALSE = fPartialOK, we want full visibility
}

BOOL SelectListViewItem(HINSTANCE hInstance, HWND hDlg, UINT uComboCtrlId, HWND hListView, BOOL bUseTunneling, CustomActionTypes TypeToSelect, LPCTSTR pszDescription)
{
    if ((NULL == pszDescription) || (TEXT('\0') == pszDescription[0]) || (0 == uComboCtrlId) || (NULL == hDlg))
    {
        CMASSERTMSG(FALSE, TEXT("SelectListViewItem -- Invalid parameter passed."));
        return FALSE;
    }

    CustomActionTypes Type;
    CustomActionTypes TypeSelectedInCombo;
    BOOL bReturn = FALSE;

    //
    //  If the current view is ALL, then we may have multiple items with the same name but different types.  Thus
    //  we must check the type string of the item and search again if it isn't the correct item.  If we are viewing
    //  items only of the TypeToSelect then we are guarenteed that there is only one item of that name.  Finally if
    //  we are viewing a different item type we don't want to do anything to the selection as the item we want to
    //  select won't be visible.
    //

    HRESULT hr = MapComboSelectionToType(hDlg, uComboCtrlId, TRUE, bUseTunneling, &TypeSelectedInCombo); //bIncludesAll == TRUE

    if (SUCCEEDED(hr) && ((TypeToSelect == TypeSelectedInCombo) || (ALL == TypeSelectedInCombo)))
    {
        //
        //  Setup the find structure
        //
        LVFINDINFO lvFindInfo = {0};
        lvFindInfo.flags = LVFI_STRING;
        lvFindInfo.psz = pszDescription;

        //
        //  Setup the Item structure
        //
        LVITEM lvItem = {0};
        TCHAR szTemp[MAX_PATH+1];
        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = szTemp;
        lvItem.cchTextMax = MAX_PATH;
        lvItem.iSubItem = 1;

        BOOL bExitLoop;
        int iIndex = -1;

        do
        {
            bExitLoop = TRUE;
            iIndex = ListView_FindItem(hListView, iIndex, &lvFindInfo);

            if ((-1 != iIndex) && (ALL == TypeSelectedInCombo))
            {
                //
                //  Now check to see if this has the type we are looking for
                //
                szTemp[0] = TEXT('\0');
                lvItem.iItem = iIndex;

                if (ListView_GetItem(hListView,  &lvItem))
                {
                    hr = g_pCustomActionList->GetTypeFromTypeString(hInstance, lvItem.pszText, &Type);

                    if (SUCCEEDED(hr))
                    {
                        bExitLoop = (TypeToSelect == Type);
                    }
                }
            }

        } while(!bExitLoop);

        if (-1 != iIndex)
        {
            SetListViewSelection(hListView, iIndex);
            bReturn = TRUE;
        }
    }

    return bReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  RefreshListView
//
// Synopsis:  This function refreshes the list view data from that contained
//            in the global CustomActionList class.  Gets the type of data to
//            display from the combo box specified by the hDlg and uComboCtrlId
//            parameters
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hDlg - window handle of the dialog containing the type combo
//            UINT uComboBoxId - combo box id containing the type info
//            HWND hListView - window handle to the list view control
//            int iItemToSelect - item the caller wants selected after the refresh
//            BOOL bUseTunneling - whether this is a tunneling profile or not, 
//                                 affects whether Pre-Tunnel actions are displayed
//                                 or not.
//
// Returns:   Nothing
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
void RefreshListView(HINSTANCE hInstance, HWND hDlg, UINT uComboCtrlId, HWND hListView, 
                     int iItemToSelect, BOOL bUseTunneling)
{
    //
    //  Refresh the list view
    //
    CustomActionTypes Type;
    HWND hControl;
    BOOL bEnableDeleteAndEdit = FALSE;
    BOOL bDisableMoveDown;
    BOOL bDisableMoveUp;

    CMASSERTMSG(hInstance && hDlg && uComboCtrlId && hListView && g_pCustomActionList, TEXT("RefreshListView -- Invalid Parameters passed, skipping refresh"));

    if (hDlg && uComboCtrlId && hListView && g_pCustomActionList)
    {
        HRESULT hr = MapComboSelectionToType(hDlg, uComboCtrlId, TRUE, bUseTunneling, &Type); //bIncludesAll == TRUE

        //
        //  Add the items to the list view and set the selection to iItemToSelect
        //
        if (SUCCEEDED(hr))
        {
            hr = g_pCustomActionList->AddCustomActionsToListView(hListView, hInstance, Type, bUseTunneling, iItemToSelect, (ALL == Type));

            MYDBGASSERT(SUCCEEDED(hr));
        }

        //
        //  If the caller asked for an item that we couldn't select, then the item selected would be the first item.  To avoid
        //  confusion we will just use the currently selected item by passing -1;
        //
        int iIndex = -1;
        RefreshEditDeleteMoveButtonStates(hInstance, hDlg, hListView, uComboCtrlId, &iIndex, bUseTunneling);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  OnProcessCustomActionsAdd
//
// Synopsis:  This function is called when the user presses the Add button
//            on the custom action pane of CMAK.  This function is basically a
//            wrapper for the add functionality so that context menus and other
//            commands can also call it with duplicate code.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hDlg - window handle of the dialog containing the type combo
//            HWND hListView - window handle to the list view control
//            BOOL bUseTunneling - whether this profile uses tunneling or not
//
// Returns:   Nothing
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
void OnProcessCustomActionsAdd(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling)
{
    MYDBGASSERT(hInstance);
    MYDBGASSERT(hDlg);
    MYDBGASSERT(hListView);

    if (hInstance && hDlg && hListView)
    {
        CustomActionListItem ListItem;
        CustomActionTypes Type;

        INT_PTR nResult = -1;  // get info on currently selected item

        //
        //  First figure out what type of connect action the list view is showing.  We
        //  want to preset the combo box on the add/edit dialog to the correct type
        //  of custom action, unless it is showing all and then just set it to the first
        //  item in the list.
        //
        HRESULT hr = MapComboSelectionToType(hDlg, IDC_COMBO1, TRUE, bUseTunneling, &Type); //bIncludesAll == TRUE
        ZeroMemory(&ListItem, sizeof(CustomActionListItem));

        if (SUCCEEDED(hr))
        {
            if (ALL != Type)
            {
                ListItem.Type = Type;
            }
        }

        //
        //  Still call the Add dialog even if we couldn't determine the type
        //
        nResult = DialogBoxParam(NULL, MAKEINTRESOURCE(IDD_CUSTOM_ACTIONS_POPUP), hDlg, 
            (DLGPROC)ProcessCustomActionPopup,(LPARAM)&ListItem);

        if (IDOK == nResult)
        {
            RefreshListView(hInstance, hDlg, IDC_COMBO1, hListView, 0, bUseTunneling);
            SelectListViewItem(hInstance, hDlg, IDC_COMBO1, hListView, bUseTunneling, ListItem.Type, ListItem.szDescription);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  OnProcessCustomActionsDelete
//
// Synopsis:  This function is called when the user presses the Delete button
//            on the custom action pane of CMAK.  This function is basically a
//            wrapper for the delete functionality so that context menus and other
//            commands can also call it with duplicate code.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hDlg - window handle of the dialog containing the type combo
//            HWND hListView - window handle to the list view control
//            BOOL bUseTunneling - whether this profile uses tunneling or not
//
// Returns:   Nothing
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
void OnProcessCustomActionsDelete(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling)
{
    MYDBGASSERT(hInstance);
    MYDBGASSERT(hDlg);
    MYDBGASSERT(hListView);
    MYDBGASSERT(g_pCustomActionList);

    if (hInstance && hDlg && hListView && g_pCustomActionList)
    {
        CustomActionListItem ListItem;

        int iTemp = -1;  // get info on currently selected item

        HRESULT hr = GetDescriptionAndTypeOfItem(hInstance, hDlg, hListView, IDC_COMBO1, &ListItem, &iTemp, bUseTunneling);

        if (SUCCEEDED(hr))
        {
            hr = g_pCustomActionList->Delete(hInstance, ListItem.szDescription, ListItem.Type);
        
            if (SUCCEEDED(hr))
            {                        
                RefreshListView(hInstance, hDlg, IDC_COMBO1, hListView, 0, bUseTunneling);
            }
        }
        else
        {
            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOSELECTION, MB_OK));                    
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  OnProcessCustomActionsEdit
//
// Synopsis:  This function is called when the user presses the Edit button
//            on the custom action pane of CMAK.  This function is basically a
//            wrapper for the edit functionality so that context menus and other
//            commands can also call it with duplicate code.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hDlg - window handle of the dialog containing the type combo
//            HWND hListView - window handle to the list view control
//            BOOL bUseTunneling - whether this profile uses tunneling or not
//
// Returns:   Nothing
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
void OnProcessCustomActionsEdit(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling)
{

    MYDBGASSERT(hInstance);
    MYDBGASSERT(hDlg);
    MYDBGASSERT(hListView);
    MYDBGASSERT(g_pCustomActionList);

    if (hInstance && hDlg && hListView && g_pCustomActionList)
    {
        //
        //  First find the name and type of the Connect Action to edit
        //
        CustomActionListItem ListItem;

        int iTemp = -1;  // get info on currently selected item
        HRESULT hr = GetDescriptionAndTypeOfItem(hInstance, hDlg, hListView, IDC_COMBO1, &ListItem, &iTemp, bUseTunneling);

        if (SUCCEEDED(hr))
        {
            int iFirstInList;
            int iLastInList;
            int iBuiltIn;

            //
            //  Screen out the built in custom actions
            //
            hr = g_pCustomActionList->GetListPositionAndBuiltInState(hInstance, &ListItem, &iFirstInList, &iLastInList, &iBuiltIn);

            if (SUCCEEDED(hr))
            {
                if (0 == iBuiltIn)
                {
                    INT_PTR nResult = DialogBoxParam(NULL, MAKEINTRESOURCE(IDD_CUSTOM_ACTIONS_POPUP), hDlg, 
                                                     (DLGPROC)ProcessCustomActionPopup,(LPARAM)&ListItem);

                    if (IDOK == nResult)
                    {
                        RefreshListView(hInstance, hDlg, IDC_COMBO1, hListView, 0, bUseTunneling);
                        SelectListViewItem(hInstance, hDlg, IDC_COMBO1, hListView, bUseTunneling, ListItem.Type, ListItem.szDescription);
                    }
                }
            }
            else
            {
                MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOSELECTION, MB_OK));                    
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  OnProcessCustomActionsMoveUp
//
// Synopsis:  This function is called when the user presses the Move Up button
//            on the custom action pane of CMAK.  This function is basically a
//            wrapper for the move up functionality so that context menus and other
//            commands can also call it with duplicate code.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hDlg - window handle of the dialog containing the type combo
//            HWND hListView - window handle to the list view control
//            BOOL bUseTunneling - whether this profile uses tunneling or not
//
// Returns:   Nothing
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
void OnProcessCustomActionsMoveUp(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling)
{

    MYDBGASSERT(hInstance);
    MYDBGASSERT(hDlg);
    MYDBGASSERT(hListView);
    MYDBGASSERT(g_pCustomActionList);

    if (hInstance && hDlg && hListView && g_pCustomActionList)
    {
        //
        //  First find the name and type of the Connect Action to edit
        //
        CustomActionListItem ListItem;

        int iTemp = -1;  // get info on currently selected item

        HRESULT hr = GetDescriptionAndTypeOfItem(hInstance, hDlg, hListView, IDC_COMBO1, &ListItem, &iTemp, bUseTunneling);

        if (SUCCEEDED(hr))
        {
            hr = g_pCustomActionList->MoveUp(hInstance, ListItem.szDescription, ListItem.Type);

            if (SUCCEEDED(hr) && (S_FALSE != hr)) // S_FALSE means it is already first in the list
            {                        
                RefreshListView(hInstance, hDlg, IDC_COMBO1, hListView, (iTemp - 1), bUseTunneling);
            }
        }
        else
        {
            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOSELECTION, MB_OK));                    
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  OnProcessCustomActionsMoveDown
//
// Synopsis:  This function is called when the user presses the Move Down button
//            on the custom action pane of CMAK.  This function is basically a
//            wrapper for the move down functionality so that context menus and other
//            commands can also call it with duplicate code.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hDlg - window handle of the dialog containing the type combo
//            HWND hListView - window handle to the list view control
//            BOOL bUseTunneling - whether this profile uses tunneling or not
//
// Returns:   Nothing
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
void OnProcessCustomActionsMoveDown(HINSTANCE hInstance, HWND hDlg, HWND hListView, BOOL bUseTunneling)
{

    MYDBGASSERT(hInstance);
    MYDBGASSERT(hDlg);
    MYDBGASSERT(hListView);
    MYDBGASSERT(g_pCustomActionList);

    if (hInstance && hDlg && hListView && g_pCustomActionList)
    {
        //
        //  First find the name and type of the Connect Action to edit
        //
        CustomActionListItem ListItem;

        int iTemp = -1;  // get info on currently selected item

        HRESULT hr = GetDescriptionAndTypeOfItem(hInstance, hDlg, hListView, IDC_COMBO1, &ListItem, &iTemp, bUseTunneling);

        if (SUCCEEDED(hr))
        {
            hr = g_pCustomActionList->MoveDown(hInstance, ListItem.szDescription, ListItem.Type);

            if (SUCCEEDED(hr) && (S_FALSE != hr)) // S_FALSE means it is already last in the list
            {                        
                RefreshListView(hInstance, hDlg, IDC_COMBO1, hListView, (iTemp + 1), bUseTunneling);
            }
        }
        else
        {
            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOSELECTION, MB_OK));                    
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  OnProcessCustomActionsContextMenu
//
// Synopsis:  This function is called when the user right clicks on the list view
//            control or invokes the context menu via the keyboard (shift+F10 or
//            the context menu key).  The function displays the context menu at
//            the coordinates specified by the NMITEMACTIVATE structure and
//            determines which context menu to display based on whether the
//            NMITEMACTIVATE struct contains an item identifier (it will be
//            -1 if the user doesn't click on an item specifically) and the
//            position in the custom action list of the item selected.  The
//            function will also call the appropriate command function
//            as necessary once the user has made a context menu selection.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            HWND hDlg - window handle of the dialog containing the type combo
//            HWND hListView - window handle to the list view control
//            NMITEMACTIVATE* pItemActivate - contains item and location information
//                                            used to display the context menu.
//            BOOL bUseTunneling - whether this profile uses tunneling or not
//            UINT uComboCtrlId - control id of the combo box containing
//                                the custom action type selection
//
// Returns:   Nothing
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
void OnProcessCustomActionsContextMenu(HINSTANCE hInstance, HWND hDlg, HWND hListView, 
                                       NMITEMACTIVATE* pItemActivate, BOOL bUseTunneling, UINT uComboCtrlId)
{
    MYDBGASSERT(hInstance);
    MYDBGASSERT(hDlg);
    MYDBGASSERT(hListView);
    MYDBGASSERT(pItemActivate);
    MYDBGASSERT(g_pCustomActionList);

    UINT uMenuIdToDisplay = IDM_CA_ADD_ONLY;
    int iDisableMoveUp;
    int iDisableMoveDown;
    int iDisableDeleteAndEdit;

    if (hInstance && hDlg && hListView && pItemActivate && g_pCustomActionList)
    {
        //
        //  If we aren't directly on an item, then we will only
        //  display the Add item, set as default.  If we are on
        //  an item then we will display Edit (default), add, delete,
        //  and the appropriate choices for moveup and movedown (one,
        //  both, none).  We will add a separator between the moveup/movedown
        //  choices and the regular options if we have moveup or movedown.
        //

        if (-1 == pItemActivate->iItem)
        {
            //
            //  Then the user right clicked in the area of the control and not on a specific item.
            //  Thus we only need to show a menu with Add as the default item.
            //
            uMenuIdToDisplay = IDM_CA_ADD_ONLY;
        }
        else if (0 == pItemActivate->ptAction.y)
        {
            //
            //  When the user clicks on the column headers we always get back a y value of zero and
            //  a really large (probably meant to be negative) x value.  Since this throws off where
            //  the menu shows up, lets just disable the context menu here.
            //
            return;
        }
        else
        {
            //
            //  The user actually right clicked on an item and we need to figure out which menu
            //  to display.
            //

            MYDBGASSERT(0 != ListView_GetItemCount(hListView));
            
            //
            //  Get the description and type of the item
            //

            int iIndex = pItemActivate->iItem;
            CustomActionListItem Item;

            ZeroMemory(&Item, sizeof(Item));
            HRESULT hr = GetDescriptionAndTypeOfItem(hInstance, hDlg, hListView, uComboCtrlId, &Item, &iIndex, bUseTunneling);

            if (SUCCEEDED(hr))
            {
                //
                //  Note that GetListPositionAndBuiltInState returns either -1 (0xFFFFFFF) or 0, thus making the
                //  bitwise ANDs below work out to the correct index.
                //
                hr = g_pCustomActionList->GetListPositionAndBuiltInState(hInstance, &Item, &iDisableMoveUp, &iDisableMoveDown, &iDisableDeleteAndEdit);
                
                if (SUCCEEDED(hr))
                {
                    const UINT c_ArrayOfContextMenuIds[8] = {IDM_CA_FULL, IDM_CA_ADD_MOVEUPORDOWN, IDM_CA_NO_DOWN, IDM_CA_ADD_MOVEUP, 
                                                             IDM_CA_NO_UP, IDM_CA_ADD_MOVEDOWN, IDM_CA_NO_MOVE, IDM_CA_ADD_ONLY};

                    DWORD dwIndex = (iDisableMoveUp & 0x4) + (iDisableMoveDown & 0x2) + (iDisableDeleteAndEdit & 0x1);
                    uMenuIdToDisplay = c_ArrayOfContextMenuIds[dwIndex];
                }
            }
        }

        //
        //  Now that we have figured out what menu to use, go add and display it
        //

        HMENU hLoadedMenu;
        HMENU hContextMenu;
        POINT ptClientToScreen;

        hLoadedMenu = LoadMenu(hInstance, MAKEINTRESOURCE(uMenuIdToDisplay));
    
        if (hLoadedMenu)
        {
            hContextMenu = GetSubMenu(hLoadedMenu, 0);

            if (hContextMenu)
            {
                CopyMemory(&ptClientToScreen, &(pItemActivate->ptAction), sizeof(POINT));

                if (ClientToScreen(hListView, &ptClientToScreen))
                {
                    int iMenuSelection = TrackPopupMenu(hContextMenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD, 
                                                        ptClientToScreen.x , ptClientToScreen.y, 0, hDlg, NULL);

                    switch(iMenuSelection)
                    {
                    case IDM_CA_ADD:
                        OnProcessCustomActionsAdd(hInstance, hDlg, hListView, bUseTunneling);
                        break;
                    case IDM_CA_EDIT:
                        OnProcessCustomActionsEdit(hInstance, hDlg, hListView, bUseTunneling);
                        break;
                    case IDM_CA_DELETE:
                        OnProcessCustomActionsDelete(hInstance, hDlg, hListView, bUseTunneling);
                        break;
                    case IDM_CA_MOVE_UP:
                        OnProcessCustomActionsMoveUp(hInstance, hDlg, hListView, bUseTunneling);
                        break;
                    case IDM_CA_MOVE_DOWN:
                        OnProcessCustomActionsMoveDown(hInstance, hDlg, hListView, bUseTunneling);
                        break;
                    default:
                        //
                        //  Do nothing the user canceled the menu or an error occurred.
                        //
                        break;
                    }
                }
            }

            DestroyMenu(hLoadedMenu);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\profwiz\netsettings.cpp ===
//+----------------------------------------------------------------------------
//
// File:     netsettings.cpp
//
// Module:   CMAK.EXE
//
// Synopsis: Code dealing with network settings (DUN settings).
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   quintinb   Created     03/22/00
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//+----------------------------------------------------------------------------
//
// Function:  ReadDunServerSettings
//
// Synopsis:  Reads in all of the settings from the Server DUN setting section
//            specified.
//
// Arguments: LPCTSTR pszSectionName - full name of the server section to read
//                                     (Server&Fred or whatever)
//            CDunSetting* pDunSetting - Dun Settings data structure to store 
//                                       the read in values to
//            LPCTSTR pszCmsFile - Cms file to read the settings from
//            BOOL bTunnelDunSetting - whether this is a tunnel dun setting or not
//
// Returns:   BOOL - TRUE if the settings were read in correctly
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
BOOL ReadDunServerSettings(LPCTSTR pszSectionName, CDunSetting* pDunSetting, LPCTSTR pszCmsFile, BOOL bTunnelDunSetting)
{
    if ((NULL == pszSectionName) || (NULL == pDunSetting) || (NULL == pszCmsFile) ||
        (TEXT('\0') == pszSectionName[0]) || (TEXT('\0') == pszCmsFile[0]))
    {
        CMASSERTMSG(FALSE, TEXT("ReadDunServerSettings -- invalid parameter"));
        return FALSE;
    }

    GetBoolSettings ArrayOfServerSettings[] = {
        {c_pszCmEntryDunServerNetworkLogon, &(pDunSetting->bNetworkLogon), bTunnelDunSetting},
        {c_pszCmEntryDunServerSwCompress, &(pDunSetting->bPppSoftwareCompression), 1},
        {c_pszCmEntryDunServerDisableLcp, &(pDunSetting->bDisableLCP), 0},
        {c_pszCmEntryDunServerPwEncrypt, &(pDunSetting->bPWEncrypt), 0},
        {c_pszCmEntryDunServerPwEncryptMs, &(pDunSetting->bPWEncrypt_MS), 0},
        {c_pszCmEntryDunServerSecureLocalFiles, &(pDunSetting->bSecureLocalFiles), 0},
        {c_pszCmEntryDunServerRequirePap, &(pDunSetting->bAllowPap), 0},
        {c_pszCmEntryDunServerRequireSpap, &(pDunSetting->bAllowSpap), 0},
        {c_pszCmEntryDunServerRequireEap, &(pDunSetting->bAllowEap), 0},
        {c_pszCmEntryDunServerRequireChap, &(pDunSetting->bAllowChap), 0},
        {c_pszCmEntryDunServerRequireMsChap, &(pDunSetting->bAllowMsChap), 0},
        {c_pszCmEntryDunServerRequireMsChap2, &(pDunSetting->bAllowMsChap2), 0},
        {c_pszCmEntryDunServerRequireW95MsChap, &(pDunSetting->bAllowW95MsChap), 0},
        {c_pszCmEntryDunServerDataEncrypt, &(pDunSetting->bDataEncrypt), 0},
    };

    const int c_iNumDunServerBools = sizeof(ArrayOfServerSettings)/sizeof(ArrayOfServerSettings[0]);

    for (int i = 0; i < c_iNumDunServerBools; i++)
    {
        *(ArrayOfServerSettings[i].pbValue) = GetPrivateProfileInt(pszSectionName, ArrayOfServerSettings[i].pszKeyName, 
                                                                   ArrayOfServerSettings[i].bDefault, pszCmsFile);
    }

    //
    //  Now get the EAP settings if necessary
    //

    pDunSetting->dwCustomAuthKey = GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunServerCustomAuthKey, 0, pszCmsFile);

    if (pDunSetting->dwCustomAuthKey)
    {
        if (!ReadDunSettingsEapData(pszSectionName, &(pDunSetting->pCustomAuthData), &(pDunSetting->dwCustomAuthDataSize), pDunSetting->dwCustomAuthKey, pszCmsFile))
        {
            CMASSERTMSG(FALSE, TEXT("ReadDunServerSettings -- Failed to read in EAP Data."));
            pDunSetting->dwCustomAuthDataSize = 0;
            CmFree(pDunSetting->pCustomAuthData);
            pDunSetting->pCustomAuthData = NULL;
        }
    }

    //
    //  Now get the Encryption type
    //
    pDunSetting->dwEncryptionType = (DWORD)GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunServerEncryptionType, 
                                                                (bTunnelDunSetting ? ET_Require : ET_Optional), pszCmsFile);

    //
    //  Figure out what type of security model we are using
    //
    if (GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunServerEnforceCustomSecurity, 0, pszCmsFile))
    {
        pDunSetting->iHowToHandleSecuritySettings = FORCE_WIN2K_AND_ABOVE;
    }
    else
    {
        int iWin2kSecSettings = pDunSetting->bAllowPap | pDunSetting->bAllowSpap | pDunSetting->bAllowEap | 
                                pDunSetting->bAllowChap | pDunSetting->bAllowMsChap | pDunSetting->bAllowMsChap2 | 
                                pDunSetting->bAllowW95MsChap;

        if (iWin2kSecSettings)
        {
            pDunSetting->iHowToHandleSecuritySettings = SEPARATE_FOR_LEGACY_AND_WIN2K;
        }
        else
        {
            pDunSetting->iHowToHandleSecuritySettings = SAME_ON_ALL_PLATFORMS;

            //
            //  In case the user chooses the advanced tab without configuring settings, lets
            //  set some reasonable defaults for them.  If they have already configured their
            //  Win2k settings we don't want to mess with them.  Also note that if the user
            //  doesn't change the iHowToHandleSecuritySettings value, we won't write out
            //  the advanced security settings anyway.
            //
            pDunSetting->bAllowChap = !bTunnelDunSetting;
            pDunSetting->bAllowMsChap = 1;
            pDunSetting->bAllowMsChap2 = 1;
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  ReadDunNetworkingSettings
//
// Synopsis:  Reads in all of the settings from the DUN Networking section
//            specified.
//
// Arguments: LPCTSTR pszSectionName - full name of the networking section to read
//                                     (Networking&Fred or whatever)
//            CDunSetting* pDunSetting - Dun Settings data structure to store 
//                                       the read in values to
//            LPCTSTR pszCmsFile - Cms file to read the settings from
//            BOOL bTunnel - is this a tunnel DUN setting or not
//
// Returns:   BOOL - TRUE if the settings were read in correctly
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
BOOL ReadDunNetworkingSettings(LPCTSTR pszSectionName, CDunSetting* pDunSetting, LPCTSTR pszCmsFile, BOOL bTunnel)
{
    if ((NULL == pszSectionName) || (NULL == pDunSetting) || (NULL == pszCmsFile) ||
        (TEXT('\0') == pszSectionName[0]) || (TEXT('\0') == pszCmsFile[0]))
    {
        CMASSERTMSG(FALSE, TEXT("ReadDunNetworkingSettings -- invalid parameter"));
        return FALSE;
    }

    pDunSetting->dwVpnStrategy = (DWORD)GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunNetworkingVpnStrategy, 
                                                             (bTunnel ? VS_PptpFirst : 0), pszCmsFile);

    //
    //  If the profile had automatic, then set it to VS_PptpFirst instead.
    //

    if (bTunnel && ((VS_PptpOnly > pDunSetting->dwVpnStrategy) || (VS_L2tpFirst < pDunSetting->dwVpnStrategy)))
    {
        pDunSetting->dwVpnStrategy = VS_PptpFirst;
    }

    pDunSetting->bUsePresharedKey = (BOOL)GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunNetworkingUsePreSharedKey, 
                                                               FALSE, pszCmsFile);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  ConvertIpStringToDword
//
// Synopsis:  This function takes the given string containing an IP address and
//            converts it to a packed DWORD.  The first octet of the IP address
//            going in the most significant byte of the DWORD, the next octet in
//            the second most significant byte of the DWORD, etc.  The packed
//            DWORD format is used by the IP address common controls and is a much
//            easier format to store the data in than a string.
//
// Arguments: LPTSTR pszIpAddress - string containing the ip address, each octet
//                                  seperated by a period.
//
// Returns:   DWORD - the ip address specified by the inputted string in
//                    packed byte format (first octet in the most significant)
//                    Note that zero is returned if there is a problem with the
//                    IP address format (one of the numbers is out of bounds or
//                    there are too many or too few octets).
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
DWORD ConvertIpStringToDword(LPTSTR pszIpAddress)
{
    DWORD dwIpAddress = 0;

    if (pszIpAddress && pszIpAddress[0])
    {
        CmStrTrim(pszIpAddress);

        LPTSTR pszCurrent = pszIpAddress;
        DWORD dwOctetCounter = 0;
        DWORD dwCurrentOctetValue = 0;
        const int c_iCharBase = TEXT('0');
        BOOL bExitLoop = FALSE;

        while (pszCurrent && !bExitLoop)
        {        
            switch(*pszCurrent)
            {

                case TEXT('.'):                

                    if (3 > dwOctetCounter)
                    {
                        dwIpAddress = (dwIpAddress << 8) + dwCurrentOctetValue;

                        dwOctetCounter++;
                        dwCurrentOctetValue = 0;
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("ConvertIpStringToDword -- Too many octets"));
                        return 0;                
                    }
                    break;

                case TEXT('\0'):

                        if (3 == dwOctetCounter)
                        {
                            dwIpAddress = (dwIpAddress << 8) + dwCurrentOctetValue;
                            bExitLoop = TRUE;
                        }
                        else
                        {
                            CMASSERTMSG(FALSE, TEXT("ConvertIpStringToDword -- Incorrect number of octets"));
                            return 0;
                        }
                    break;

                default:
                
                    dwCurrentOctetValue = dwCurrentOctetValue*10 + (int(*pszCurrent) - c_iCharBase);
                
                    if (255 < dwCurrentOctetValue)
                    {
                        CMASSERTMSG(FALSE, TEXT("ConvertIpStringToDword -- Octet value out of range"));
                        return 0;
                    }
                    break;
                }

            pszCurrent = CharNext(pszCurrent);
        }
    }

    return dwIpAddress;
}

//+----------------------------------------------------------------------------
//
// Function:  ConvertIpDwordToString
//
// Synopsis:  This function takes the given Packed DWORD and returns an IP
//            address string for it, making sure to print the octets so that
//            the most significant bits are printed in the string first.
//
// Arguments: DWORD dwIpAddress - packed DWORD containing the Ip address to convert
//            LPTSTR pszIpAddress - string to write the IP address too
//
// Returns:   int - the number of chars written to the string buffer.  Zero signifies
//                  failure.
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
int ConvertIpDwordToString(DWORD dwIpAddress, LPTSTR pszIpAddress)
{
    int iReturn = 0;

    if (pszIpAddress)
    {
        iReturn = wsprintf(pszIpAddress, TEXT("%d.%d.%d.%d"), FIRST_IPADDRESS(dwIpAddress), SECOND_IPADDRESS(dwIpAddress), 
                           THIRD_IPADDRESS(dwIpAddress), FOURTH_IPADDRESS(dwIpAddress));
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("ConvertIpDwordToString -- Null pointer passed for pszIpAddress"));
    }

    return iReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  ReadDunTcpIpSettings
//
// Synopsis:  This function reads the TCP/IP DUN settings from the specified
//            section and stores them in the given pDunSetting structure.
//
// Arguments: LPCTSTR pszSectionName - complete section name to read the TCP/IP
//                                     settings from, ie. Networking&Fred
//            CDunSetting* pDunSetting - pointer to a DUN setting structure to hold
//                                       the read in data
//            LPCTSTR pszCmsFile - cms file to read the settings from
//
// Returns:   BOOL - TRUE on success
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
BOOL ReadDunTcpIpSettings(LPCTSTR pszSectionName, CDunSetting* pDunSetting, LPCTSTR pszCmsFile)
{
    if ((NULL == pszSectionName) || (NULL == pDunSetting) || (NULL == pszCmsFile) ||
        (TEXT('\0') == pszSectionName[0]) || (TEXT('\0') == pszCmsFile[0]))
    {
        CMASSERTMSG(FALSE, TEXT("ReadDunTcpIpSettings -- invalid parameter"));
        return FALSE;
    }

    TCHAR szTemp[MAX_PATH];

    //
    //  Are we using Admin specified DNS and WINS settings or is the server going to assign them
    //
    if (GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunTcpIpSpecifyServerAddress, 0, pszCmsFile))
    {
        //
        //  Get the DNS and WINS configurations that were specified
        //
        GetPrivateProfileString(pszSectionName, c_pszCmEntryDunTcpIpDnsAddress, TEXT(""), szTemp, CELEMS(szTemp), pszCmsFile);
        pDunSetting->dwPrimaryDns = ConvertIpStringToDword (szTemp);
        
        GetPrivateProfileString(pszSectionName, c_pszCmEntryDunTcpIpDnsAltAddress, TEXT(""), szTemp, CELEMS(szTemp), pszCmsFile);
        pDunSetting->dwSecondaryDns = ConvertIpStringToDword (szTemp);
        
        GetPrivateProfileString(pszSectionName, c_pszCmEntryDunTcpIpWinsAddress, TEXT(""), szTemp, CELEMS(szTemp), pszCmsFile);
        pDunSetting->dwPrimaryWins = ConvertIpStringToDword (szTemp);

        GetPrivateProfileString(pszSectionName, c_pszCmEntryDunTcpIpWinsAltAddress, TEXT(""), szTemp, CELEMS(szTemp), pszCmsFile);
        pDunSetting->dwSecondaryWins = ConvertIpStringToDword (szTemp);

    }
    else
    {
        pDunSetting->dwPrimaryDns = 0;        
        pDunSetting->dwSecondaryDns = 0;        
        pDunSetting->dwPrimaryWins = 0;
        pDunSetting->dwSecondaryWins = 0;
    }

    //
    //  Now Read in IP Header Compress and whether to use the Remote Gateway or not
    //
    pDunSetting->bIpHeaderCompression = GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunTcpIpIpHeaderCompress, 1, pszCmsFile);
    pDunSetting->bGatewayOnRemote = GetPrivateProfileInt(pszSectionName, c_pszCmEntryDunTcpIpGatewayOnRemote, 1, pszCmsFile);

    return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  ReadDunScriptingSettings
//
// Synopsis:  This function reads in the script name from the passed in scripting
//            section name and stores it in the passed in DUN setting struct.
//
// Arguments: LPCTSTR pszSectionName - complete section name to read the scripting
//                                     settings from, ie. Scripting&Fred
//            CDunSetting* pDunSetting - pointer to a DUN setting structure to hold
//                                       the read in data
//            LPCTSTR pszCmsFile - cms file to read the settings from
//
// Returns:   BOOL - TRUE on success
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
BOOL ReadDunScriptingSettings(LPCTSTR pszSectionName, CDunSetting* pDunSetting, LPCTSTR pszOsDir, LPCTSTR pszCmsFile)
{
    if ((NULL == pszSectionName) || (NULL == pDunSetting) || (NULL == pszCmsFile) || (NULL == pszOsDir) ||
        (TEXT('\0') == pszSectionName[0]) || (TEXT('\0') == pszCmsFile[0]) || (TEXT('\0') == pszOsDir[0]))
    {
        CMASSERTMSG(FALSE, TEXT("ReadDunScriptingSettings -- invalid parameter"));
        return FALSE;
    }

    TCHAR szTemp[MAX_PATH+1] = TEXT("");

    if (GetPrivateProfileString(pszSectionName, c_pszCmEntryDunScriptingName, TEXT(""), 
         szTemp, CELEMS(szTemp), pszCmsFile))
    {
        MYVERIFY(CELEMS(pDunSetting->szScript) > (UINT)wsprintf(pDunSetting->szScript, TEXT("%s%s"), pszOsDir, szTemp));
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  AddDunNameToListIfDoesNotExist
//
// Synopsis:  This function walks through the list of existing DUN settings
//            to see if it can find a setting with the name pszDunName.  If it
//            finds the entry, then fine it returns TRUE.  If it cannot find the
//            entry then it creates an otherwise blank entry and adds it to the list.
//
// Arguments: LPCTSTR pszDunName - name of the item to add to the list if 
//                                 it doesn't already exist
//            ListBxList **pHeadDns - head of the list of DUN entries
//            ListBxList** pTailDns - tail of the list of DUN entries
//            BOOL bTunnelDunName - whether this is a tunnel DUN name or not
//
// Returns:   BOOL - TRUE if the item was added or if it already existed in the list
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
BOOL AddDunNameToListIfDoesNotExist(LPCTSTR pszDunName, ListBxList **pHeadDns, ListBxList** pTailDns, BOOL bTunnelDunName)
{
    if ((NULL == pszDunName) || (NULL == pHeadDns) || (NULL == pTailDns) || (TEXT('\0') == pszDunName[0]))
    {
        CMASSERTMSG(FALSE, TEXT("AddDunNameToListIfDoesNotExist -- Invalid Parameter"));
        return FALSE;
    }

    ListBxList* pCurrent = *pHeadDns;
    BOOL bReturn = TRUE;

    while (pCurrent)
    {    
        if (0 == lstrcmpi(pszDunName, pCurrent->szName))
        {
            //
            //  We already have this item, nothing to do
            //
            goto exit;
        }

        pCurrent = pCurrent->next;
    }

    //
    //  If we are here then either we didn't find the item or the list
    //  is empty.  Either way, add the item.
    //
    pCurrent = (ListBxList*)CmMalloc(sizeof(ListBxList));

    if (pCurrent)
    {
        pCurrent->ListBxData = new CDunSetting(bTunnelDunName);

        if (NULL == pCurrent->ListBxData)
        {
            CmFree(pCurrent);
            CMASSERTMSG(FALSE, TEXT("AddDunNameToListIfDoesNotExist -- Failed to allocate a new CDunSetting"));
            return FALSE;
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("ReadDunServerSettings -- Failed to allocate a new ListBxList struct"));
        return FALSE;
    }

    //
    //  Now that we have allocated a pCurrent, we need to add it to the list
    //
    if (NULL == *pHeadDns)
    {
        *pHeadDns = pCurrent;
    }
    else
    {
        (*pTailDns)->next = pCurrent;
    }

    *pTailDns = pCurrent;

    //
    //  Finally copy the name over
    //
    lstrcpy(pCurrent->szName, pszDunName);

exit:
    return bReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  GetVpnEntryNamesFromFile
//
// Synopsis:  This function parses through the tunnel server address entries within
//            the given VPN file.  For each entry that contains a VPN setting,
//            if calls AddDunNameToListIfDoesNotExist.
//
// Arguments: LPCTSTR pszPhoneBook - VPN file to search for VPN entry names
//            ListBxList **pHeadDns - head of the VPN entry list
//            ListBxList** pTailDns - tail of the VPN entry list
//
// Returns:   BOOL - TRUE if the phonebook was successfully parsed.
//
// History:   quintinb Created     10/28/00
//
//+----------------------------------------------------------------------------
BOOL GetVpnEntryNamesFromFile(LPCTSTR pszVpnFile, ListBxList **pHeadDns, ListBxList** pTailDns)
{
    if ((NULL == pszVpnFile) || (NULL == pHeadDns) || (NULL == pTailDns))
    {
        CMASSERTMSG(FALSE, TEXT("GetVpnEntryNamesFromFile -- invalid params passed."));
        return FALSE;
    }

    //
    //  Note that the vpn file string passed in may be empty.  That is okay because the profile
    //  may be a tunneling profile using only one tunnel address.
    //
    if ((TEXT('\0') != pszVpnFile[0]))
    {
        LPTSTR pszVpnServersSection = GetPrivateProfileSectionWithAlloc(c_pszCmSectionVpnServers, pszVpnFile);

        if (pszVpnServersSection)
        {
            LPTSTR pszCurrentLine = pszVpnServersSection;
            LPTSTR pszVpnSetting = NULL;

            while (TEXT('\0') != (*pszCurrentLine))
            {
                //
                //  First look for the equal sign
                //
                pszVpnSetting = CmStrchr(pszCurrentLine, TEXT('='));

                if (pszVpnSetting)
                {
                    //
                    //  Now look for the last comma
                    //
                    pszVpnSetting = CmStrrchr(pszVpnSetting, TEXT(','));
                    if (pszVpnSetting)
                    {
                        pszVpnSetting = CharNext(pszVpnSetting);
                        MYVERIFY(AddDunNameToListIfDoesNotExist(pszVpnSetting, pHeadDns, pTailDns, TRUE)); // TRUE == bTunnelDunName
                    }
                }

                //
                //  Find the next string by going to the end of the string
                //  and then going one more char.  Note that we cannot use
                //  CharNext here but must use just ++.
                //
                pszCurrentLine = CmEndOfStr(pszCurrentLine);
                pszCurrentLine++;
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("GetVpnEntryNamesFromFile -- GetPrivateProfileSectionWithAlloc return NULL."));
            return FALSE;
        }

        CmFree(pszVpnServersSection);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  VerifyVpnFile
//
// Synopsis:  This function examines the VPN servers section of a VPN file
//            to ensure that at least one line of a valid format is found.  While
//            this doesn't guarantee that the entry is valid (it could be a bogus
//            server name), it does at least mean the Admin didn't give the user a
//            junk file.  This is important because the user cannot enter their own
//            tunnel server destination.
//
// Arguments: LPCTSTR pszPhoneBook - VPN file to search for VPN entry names
//
// Returns:   BOOL - TRUE if the VPN file contains at least one tunnel server
//                   entry in a valid format
//
// History:   quintinb Created     10/28/00
//
//+----------------------------------------------------------------------------
BOOL VerifyVpnFile(LPCTSTR pszVpnFile)
{
    if (NULL == pszVpnFile)
    {
        CMASSERTMSG(FALSE, TEXT("VerifyVpnFile -- invalid params passed."));
        return FALSE;
    }

    BOOL bReturn = FALSE;

    //
    //  Note that the vpn file string passed in may be empty.  That is okay because the profile
    //  may be a tunneling profile using only one tunnel address.
    //
    if ((TEXT('\0') != pszVpnFile[0]))
    {
        LPTSTR pszVpnServersSection = GetPrivateProfileSectionWithAlloc(c_pszCmSectionVpnServers, pszVpnFile);

        if (pszVpnServersSection)
        {
            LPTSTR pszCurrentLine = pszVpnServersSection;
            LPTSTR pszEqualSign = NULL;

            while ((TEXT('\0') != (*pszCurrentLine)) && !bReturn)
            {
                //
                //  To be considered a "valid" line, all we need is to have
                //  an equal sign (=) surrounded by text.  Not that stringent of a test
                //  but better than nothing.
                //
                pszEqualSign = CmStrchr(pszCurrentLine, TEXT('='));

                if (pszEqualSign && (pszEqualSign != pszCurrentLine)) // line cannot start with an equal sign to count
                {
                    pszCurrentLine = CharNext(pszEqualSign);
                    CmStrTrim(pszCurrentLine);

                    if (*pszCurrentLine)
                    {
                        bReturn = TRUE;
                    }
                }

                //
                //  Find the next string by going to the end of the string
                //  and then going one more char.  Note that we cannot use
                //  CharNext here but must use just ++.
                //
                pszCurrentLine = CmEndOfStr(pszCurrentLine);
                pszCurrentLine++;
            }
            CmFree(pszVpnServersSection);
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetDunEntryNamesFromPbk
//
// Synopsis:  This function memory maps the given phonebook into memory and
//            then walks through it as one big string.  The function is searching
//            the phonebook for DUN entry names.  If it finds a DUN entry name then
//            it uses AddDunNameToListIfDoesNotExist to add the entry name if
//            it doesn't already exist.
//
// Arguments: LPCTSTR pszPhoneBook - phonebook to search for DUN entry names
//            ListBxList **pHeadDns - head of the DUN entry list
//            ListBxList** pTailDns - tail of the DUN entry list
//
// Returns:   BOOL - TRUE if the phonebook was successfully parsed.
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
BOOL GetDunEntryNamesFromPbk(LPCTSTR pszPhoneBook, ListBxList **pHeadDns, ListBxList** pTailDns)
{
    if ((NULL == pszPhoneBook) || (NULL == pHeadDns) || (NULL == pTailDns))
    {
        CMASSERTMSG(FALSE, TEXT("GetDunEntryNamesFromPbk -- Invalid Parameter"));
        return FALSE;
    }

    BOOL bReturn = TRUE;

    if ((TEXT('\0') != pszPhoneBook[0]))
    {
        HANDLE hPhoneBookFile = CreateFile(pszPhoneBook, GENERIC_READ, FILE_SHARE_READ, NULL, 
                                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

        if (INVALID_HANDLE_VALUE != hPhoneBookFile)
        {
            //
            //  Get the size of the file
            //
            DWORD dwFileSize = GetFileSize(hPhoneBookFile, NULL);
            if (-1 != dwFileSize)
            {
                //
                //  Create a file mapping
                //
                HANDLE hFileMapping = CreateFileMapping(hPhoneBookFile, NULL, PAGE_READONLY, 0, 0, NULL);

                if (INVALID_HANDLE_VALUE != hFileMapping)
                {
                    CHAR* pszPhoneBookContents = (CHAR*)MapViewOfFileEx(hFileMapping, FILE_MAP_READ, 0, 0, 0, NULL);

                    CHAR* pszCurrent = pszPhoneBookContents;
                    LPSTR pszLastComma = NULL;

                    //
                    //  We want to walk through the file character by character.  Whenever we encounter
                    //  a '\n', we know that is the end of a line.  If we hit EOF then we are done with the file.
                    //  We are looking for all of the DUN entry names in the phonebook file.
                    //

                    while (pszCurrent && ((dwFileSize + pszPhoneBookContents) > pszCurrent))
                    {
                        CHAR szTemp[MAX_PATH+1];
                        int iNumChars;

                        switch (*pszCurrent)
                        {
                        case ',':
                            pszLastComma = pszCurrent;
                            break;

                        case '\r':
                            //
                            //  End of a line, remember we have a \r\n <CRLF> to end a line in a file.
                            //
                            if (pszLastComma)
                            {
                                iNumChars = (int)(pszCurrent - pszLastComma);

                                if (iNumChars - 1)
                                {
                                    lstrcpynA(szTemp, CharNextA(pszLastComma), iNumChars);
                                    LPTSTR pszUnicodeDunName = SzToWzWithAlloc(szTemp);
                                    MYDBGASSERT(pszUnicodeDunName);

                                    if (pszUnicodeDunName)
                                    {
                                        MYVERIFY(AddDunNameToListIfDoesNotExist(pszUnicodeDunName, pHeadDns, pTailDns, FALSE)); // FALSE == bTunnelDunName
                                        CmFree(pszUnicodeDunName);
                                    }
                                }

                                //
                                //  Reset the last comma
                                //
                                pszLastComma = NULL;
                            }
                            break;

                        case '\0':
                        case EOF:

                            //
                            //  We shouldn't hit an EOF or a zero byte in a memory mapped text file.
                            //                            
                            
                            bReturn = FALSE;
                            CMASSERTMSG(FALSE, TEXT("GetDunEntryNamesFromPbk -- phonebook file format incorrect!"));

                            break;
                        }

                        //
                        //  Advance to the next line assuming we still have some of the file
                        //  to parse
                        //
                        if (pszCurrent && ((EOF == *pszCurrent) || ('\0' == *pszCurrent)))
                        {
                            //
                            //  Then we have an invalid file and it is time to exit...
                            //
                            pszCurrent = NULL;
                        }
                        else if (pszCurrent)
                        {
                            pszCurrent = CharNextA(pszCurrent);
                        }
                    }

                    MYVERIFY(UnmapViewOfFile(pszPhoneBookContents));
                    CloseHandle(hFileMapping);
                }
            }

            CloseHandle(hPhoneBookFile);
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  CDunSetting::CDunSetting
//
// Synopsis:  Constructor for the CDunSetting data structure.  Note that all
//            default values should be changed here and not imposed anywhere
//            else.  All the DUN setting UI is setup to read from a DUN setting
//            structure, either a newly constructed one (thus setting up the defaults)
//            or one read in from the cms.
//
// Arguments: BOOL bTunnel - tells whether this is a Tunnel DUN setting or not
//                           note that this value defaults to FALSE.
//
// Returns:   Nothing
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
CDunSetting::CDunSetting(BOOL bTunnel)
{
    //
    //  Note that bTunnelDunSetting has a default value of FALSE.
    //  Init the class params.
    //
    bNetworkLogon = bTunnel ? 1 : 0;
    bPppSoftwareCompression = 1;
    bDisableLCP = 0;
    bPWEncrypt = 0;
    bPWEncrypt_MS = 0;

    szScript[0] = TEXT('\0');
    dwVpnStrategy = bTunnel ? VS_PptpFirst : 0;
    bTunnelDunSetting = bTunnel;

    //
    //  TCP/IP Settings
    //
    dwPrimaryDns = 0;
    dwSecondaryDns = 0;
    dwPrimaryWins = 0;
    dwSecondaryWins = 0;
    bIpHeaderCompression = 1;
    bGatewayOnRemote = 1;

    //
    //  Security Settings
    //
    dwEncryptionType = bTunnel ? ET_Require : ET_Optional;
    bDataEncrypt = 0;
    bAllowPap = 0;
    bAllowSpap = 0;
    bAllowEap = 0;
    bAllowChap = !bTunnel;
    bAllowMsChap = 1;
    bAllowMsChap2 = 1;
    bAllowW95MsChap = 0;
    bSecureLocalFiles = 0;
    iHowToHandleSecuritySettings = 0;
    dwCustomAuthKey = 0;
    pCustomAuthData = NULL;
    dwCustomAuthDataSize = 0;
}

//+----------------------------------------------------------------------------
//
// Function:  CDunSetting::~CDunSetting
//
// Synopsis:  Destructor for the CDunSetting data structure.  Frees the EAP
//            blob if one exists
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
CDunSetting::~CDunSetting()
{
    CmFree(pCustomAuthData);
}

//+----------------------------------------------------------------------------
//
// Function:  ReadNetworkSettings
//
// Synopsis:  Constructor for the CDunSetting data structure.  Note that all
//            default values should be changed here and not imposed anywhere
//            else.  All the DUN setting UI is setup to read from a DUN setting
//            structure, either a newly constructed one (thus setting up the defaults)
//            or one read in from the cms.
//
// Arguments: LPCTSTR pszCmsFile - Cms file to read the network settings from
//            LPCTSTR pszLongServiceName - Long service name of the profile
//            LPCTSTR pszPhoneBook - phonebook of the current service profile,
//                                   if the profile doesn't have a phonebook
//                                   then "" should be passed
//            ListBxList **pHeadDns - pointer to the head of the DUN settings list
//            ListBxList** pTailDns - pointer to the tail of the DUN settings list
//            LPCTSTR pszOsDir - full path of the profiles directory
//
// Returns:   BOOL - TRUE if successful
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
BOOL ReadNetworkSettings(LPCTSTR pszCmsFile, LPCTSTR pszLongServiceName, LPCTSTR pszPhoneBook, 
                         ListBxList **pHeadDns, ListBxList** pTailDns, LPCTSTR pszOsDir, BOOL bLookingForVpnEntries)
{
    //
    //  Check inputs, note that the phonebook could be ""
    //
    if ((NULL == pszCmsFile) || (NULL == pszLongServiceName) || (NULL == pszPhoneBook) || (NULL == pszOsDir) || (NULL == pHeadDns) ||
        (NULL == pTailDns) || (TEXT('\0') == pszCmsFile[0]) || (TEXT('\0') == pszLongServiceName[0]) || (TEXT('\0') == pszOsDir[0]) ||
        ((NULL == *pHeadDns) ^ (NULL == *pTailDns)))
    {
        CMASSERTMSG(FALSE, TEXT("ReadNetworkSettings -- invalid parameter"));
        return FALSE;
    }

    //
    //  By calling WritePrivateProfileString with all NULL's we flush the file cache 
    //  (win95 only).  This call will return 0.
    //

    WritePrivateProfileString(NULL, NULL, NULL, pszCmsFile); //lint !e534 this call will always return 0


    BOOL bReturn = TRUE;
    LPTSTR pszCurrentSectionName = NULL;
    TCHAR szDefaultDunName[MAX_PATH+1] = TEXT("");
    TCHAR szTunnelDunName[MAX_PATH+1] = TEXT("");

    //
    //  First we want to call GetPrivateProfileString with a NULL AppName and a NULL KeyName.  This will
    //  Return all of the Section Names in the file in a buffer.  We can then go through the buffer and
    //  get the section information that interests us.
    //
    LPTSTR pszSectionNames = GetPrivateProfileStringWithAlloc(NULL, NULL, TEXT(""), pszCmsFile);

    if ((NULL == pszSectionNames) || (TEXT('\0') == pszSectionNames[0]))
    {
        CMTRACE(TEXT("ReadNetworkSettings -- GetPrivateProfileStringWithAlloc failed"));
        bReturn = FALSE;
        goto exit;
    }


    //
    //  At this point we have a list of section names, they are all NULL terminated with the last one double
    //  NULL terminated.  We need to walk through the list and see if any of them start with "[TCP/IP&" if
    //  so then we have a DUN section and we want to read it in.
    //

    LPTSTR pszAmpersand;
    LPTSTR pszDunName;
    TCHAR szTemp[MAX_PATH+1];
    BOOL bTunnelDunSetting;
    pszCurrentSectionName = pszSectionNames;

    //
    //  Get the name of the Tunnel Dun setting
    //
    MYVERIFY(0 != GetTunnelDunSettingName(pszCmsFile, pszLongServiceName, szTunnelDunName, CELEMS(szTunnelDunName)));    

    //
    //  Get the name of the default Dun setting
    //
    MYVERIFY(0 != GetDefaultDunSettingName(pszCmsFile, pszLongServiceName, szDefaultDunName, CELEMS(szDefaultDunName)));    

    while (TEXT('\0') != (*pszCurrentSectionName))
    {
        pszAmpersand = CmStrchr(pszCurrentSectionName, TEXT('&'));

        if (pszAmpersand)
        {
            //
            //  Then we have a DUN or VPN section name.
            //
            pszDunName = CharNext(pszAmpersand);

            //
            //  Next we need to see if the entry that we have is of the type we
            //  are looking for ... a VPN entry if bLookingForVpnEntries is TRUE
            //  or a DUN entry if bLookingForVpnEntries is FALSE.  We can tell the
            //  DUN and VPN entries apart by the existence of a Networking&<name>
            //  section or because it is the VPN default entryname.
            //
            wsprintf(szTemp, TEXT("%s&%s"), c_pszCmSectionDunNetworking, pszDunName);
            
            BOOL bIsVpnEntry = GetPrivateProfileInt(szTemp, c_pszCmEntryDunNetworkingVpnEntry, 0, pszCmsFile);

            bTunnelDunSetting = (bIsVpnEntry || (0 == lstrcmpi(szTunnelDunName, pszDunName)));

            //
            //  If we have a VPN entry and are looking for VPN entries or we have a DUN entry and are looking for
            //  DUN entries, then go ahead and process it.
            //
            if ((bTunnelDunSetting && bLookingForVpnEntries) || (!bTunnelDunSetting && !bLookingForVpnEntries))
            {
                ListBxList * pCurrent = *pHeadDns;

                while (pCurrent)
                {
                    if(0 == lstrcmpi(pCurrent->szName, pszDunName))
                    {
                        //
                        //  Then we already have a DUN setting of this name
                        //
                        break;
                    }

                    pCurrent = pCurrent->next;
                }

                //
                //  We didn't find the item we were looking for, lets create one.
                //

                if (NULL == pCurrent)
                {
                    pCurrent = (ListBxList*)CmMalloc(sizeof(ListBxList));

                    if (pCurrent)
                    {
                        pCurrent->ListBxData = new CDunSetting(bTunnelDunSetting);

                        if (NULL == pCurrent->ListBxData)
                        {
                            CmFree(pCurrent);
                            CMASSERTMSG(FALSE, TEXT("ReadDunServerSettings -- Failed to allocate a new DunSettingData struct"));
                            bReturn = FALSE;
                            goto exit;
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("ReadDunServerSettings -- Failed to allocate a new ListBxList struct"));
                        bReturn = FALSE;
                        goto exit;
                    }

                    //
                    //  Now that we have allocated a pCurrent, we need to add it to the list
                    //
                    if (NULL == *pHeadDns)
                    {
                        *pHeadDns = pCurrent;
                    }
                    else
                    {
                        (*pTailDns)->next = pCurrent;
                    }

                    *pTailDns = pCurrent;

                    //
                    //  Finally copy the name over
                    //
                    lstrcpy(pCurrent->szName, pszDunName);
                    ((CDunSetting*)(pCurrent->ListBxData))->bTunnelDunSetting = bTunnelDunSetting;
                }

                //
                //  Now lets figure out which section type we have
                //
                DWORD dwSize = (DWORD)(pszAmpersand - pszCurrentSectionName + 1);
                lstrcpyn(szTemp, pszCurrentSectionName, dwSize);

                if (0 == lstrcmpi(szTemp, c_pszCmSectionDunServer))
                {
                    ReadDunServerSettings(pszCurrentSectionName, (CDunSetting*)pCurrent->ListBxData, pszCmsFile, bTunnelDunSetting);
                }
                else if (0 == lstrcmpi(szTemp, c_pszCmSectionDunNetworking))
                {
                    ReadDunNetworkingSettings(pszCurrentSectionName, (CDunSetting*)pCurrent->ListBxData, pszCmsFile, bTunnelDunSetting);
                }
                else if (0 == lstrcmpi(szTemp, c_pszCmSectionDunTcpIp))
                {
                    ReadDunTcpIpSettings(pszCurrentSectionName, (CDunSetting*)pCurrent->ListBxData, pszCmsFile);
                }
                else if (0 == lstrcmpi(szTemp, c_pszCmSectionDunScripting))
                {
                    ReadDunScriptingSettings(pszCurrentSectionName, (CDunSetting*)pCurrent->ListBxData, pszOsDir, pszCmsFile);
                }
            }
        }
        //
        //  Find the next string by going to the end of the string
        //  and then going one more char.  Note that we cannot use
        //  CharNext here but must use just ++.
        //
        pszCurrentSectionName = CmEndOfStr(pszCurrentSectionName);
        pszCurrentSectionName++;
    }

    //
    //  Now we have processed all of the settings that the user has, how about
    //  the settings that they could have.  Lets add the default setting, the
    //  default Tunnel setting, and all of the settings from the
    //  current phonebook if there is one.  Note that everyone has a tunnel setting,
    //  but we won't show it in the listbox if the user isn't tunneling.
    //

    if (bLookingForVpnEntries)
    {
        MYVERIFY(GetVpnEntryNamesFromFile(pszPhoneBook, pHeadDns, pTailDns));
        MYVERIFY(AddDunNameToListIfDoesNotExist(szTunnelDunName, pHeadDns, pTailDns, TRUE)); // TRUE == bTunnelDunName    
    }
    else
    {
        MYVERIFY(GetDunEntryNamesFromPbk(pszPhoneBook, pHeadDns, pTailDns));
        MYVERIFY(AddDunNameToListIfDoesNotExist(szDefaultDunName, pHeadDns, pTailDns, FALSE)); // FALSE == bTunnelDunName        
    }

exit:
    CmFree(pszSectionNames);

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteOutNetworkingEntry
//
// Synopsis:  This function writes out the given networking entry to the
//            appropriate DUN sections in the given cms file.
//
// Arguments: LPCTSTR pszDunName - name of the DUN setting
//            CDunSetting* pDunSetting - settings data to output
//            LPCTSTR pszShortServiceName - short service name of the profile
//            LPCTSTR pszCmsFile - Cms file to write the settings too
//
// Returns:   Nothing
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
void WriteOutNetworkingEntry(LPCTSTR pszDunName, CDunSetting* pDunSetting, LPCTSTR pszShortServiceName, LPCTSTR pszCmsFile)
{
    if ((NULL == pszDunName) || (NULL == pDunSetting) || (NULL == pszCmsFile) || (NULL == pszShortServiceName) ||
        (TEXT('\0') == pszCmsFile[0]) || (TEXT('\0') == pszDunName[0]) || (TEXT('\0') == pszShortServiceName[0]))
    {
        CMASSERTMSG(FALSE, TEXT("WriteOutNetworkingEntry -- Invalid input parameter"));
        return;
    }

    //
    //  Lets build our four section headers
    //
    TCHAR szServerSection[MAX_PATH+1];
    TCHAR szNetworkingSection[MAX_PATH+1];
    TCHAR szTcpIpSection[MAX_PATH+1];
    TCHAR szScriptingSection[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1] = {0};
    TCHAR szEncryptionType[2] = {0};
    TCHAR szVpnStrategy[2] = {0};
    TCHAR szCustomAuthKey[32] = {0};

    MYVERIFY(CELEMS(szServerSection) > (UINT)wsprintf(szServerSection, TEXT("%s&%s"), c_pszCmSectionDunServer, pszDunName));
    MYVERIFY(CELEMS(szNetworkingSection) > (UINT)wsprintf(szNetworkingSection, TEXT("%s&%s"), c_pszCmSectionDunNetworking, pszDunName));
    MYVERIFY(CELEMS(szTcpIpSection) > (UINT)wsprintf(szTcpIpSection, TEXT("%s&%s"), c_pszCmSectionDunTcpIp, pszDunName));
    MYVERIFY(CELEMS(szScriptingSection) > (UINT)wsprintf(szScriptingSection, TEXT("%s&%s"), c_pszCmSectionDunScripting, pszDunName));

    //
    //  Now setup a list of all of the Booleans we need to set.
    //

    SetBoolSettings SetBoolSettingsStruct[] = {
        {szServerSection, c_pszCmEntryDunServerNetworkLogon, pDunSetting->bNetworkLogon},
        {szServerSection, c_pszCmEntryDunServerSwCompress, pDunSetting->bPppSoftwareCompression},
        {szServerSection, c_pszCmEntryDunServerDisableLcp, pDunSetting->bDisableLCP},
        {szServerSection, c_pszCmEntryDunServerNegotiateTcpIp, 1}, // always negotiate TCP/IP
        {szServerSection, c_pszCmEntryDunServerSecureLocalFiles, pDunSetting->bSecureLocalFiles},
        {szTcpIpSection, c_pszCmEntryDunTcpIpIpHeaderCompress, pDunSetting->bIpHeaderCompression},
        {szTcpIpSection, c_pszCmEntryDunTcpIpGatewayOnRemote, pDunSetting->bGatewayOnRemote}
    };

    const int c_iNumBools = sizeof(SetBoolSettingsStruct)/sizeof(SetBoolSettingsStruct[0]);

    //
    //  Write out the boolean values
    //

    for (int i = 0; i < c_iNumBools; i++)
    {
        MYVERIFY(0 != WritePrivateProfileString(SetBoolSettingsStruct[i].pszSectionName, 
                                                SetBoolSettingsStruct[i].pszKeyName,
                                                ((SetBoolSettingsStruct[i].bValue) ? c_pszOne : c_pszZero),
                                                pszCmsFile));
    }

    //
    //  Write out the security settings.  If the user choose to use the same settings everywhere, then we
    //  only want to write out the legacy security flags.  If the user choose to have separate settings
    //  then we need to write out both sets of settings.  Or if the user choose to force win2k and above,
    //  we want to write out only the newer settings and set the EnforceCustomSecurity flag to TRUE
    //
    LPTSTR pszCustomSecurity = NULL;
    LPTSTR pszEnforceCustomSecurity = NULL;
    LPTSTR pszAllowPap = NULL;
    LPTSTR pszAllowSpap = NULL;
    LPTSTR pszAllowChap = NULL;
    LPTSTR pszAllowMsChap = NULL;
    LPTSTR pszAllowW95MsChap = NULL;
    LPTSTR pszAllowMsChap2 = NULL;
    LPTSTR pszAllowEAP = NULL;
    LPTSTR pszEncryptionType = NULL;
    LPTSTR pszVpnStrategy = NULL;
    LPTSTR pszCustomAuthKey = NULL;
    LPTSTR pszUsePresharedKey = NULL;

    LPTSTR pszPwEncrypt = NULL;
    LPTSTR pszPwEncryptMs = NULL;
    LPTSTR pszDataEncrypt = NULL;

    //
    //  Set the legacy security settings if we aren't forcing Win2k+
    //
    if ((SAME_ON_ALL_PLATFORMS == pDunSetting->iHowToHandleSecuritySettings) || 
        (SEPARATE_FOR_LEGACY_AND_WIN2K == pDunSetting->iHowToHandleSecuritySettings))
    {
        pszPwEncrypt = (LPTSTR)(pDunSetting->bPWEncrypt ? c_pszOne : c_pszZero);
        pszPwEncryptMs = (LPTSTR)(pDunSetting->bPWEncrypt_MS ? c_pszOne : c_pszZero);
        pszDataEncrypt = (LPTSTR)((pDunSetting->bPWEncrypt_MS & pDunSetting->bDataEncrypt) ? c_pszOne : c_pszZero);
    }

    //
    //  Set the Win2k specific settings if we aren't using the same settings everywhere
    //
    if ((FORCE_WIN2K_AND_ABOVE == pDunSetting->iHowToHandleSecuritySettings) ||
        (SEPARATE_FOR_LEGACY_AND_WIN2K == pDunSetting->iHowToHandleSecuritySettings))
    {
        if (FORCE_WIN2K_AND_ABOVE == pDunSetting->iHowToHandleSecuritySettings)
        {
            pszEnforceCustomSecurity = (LPTSTR)c_pszOne;
        }
        else
        {
            pszEnforceCustomSecurity = (LPTSTR)c_pszZero;        
        }

        pszCustomSecurity = (LPTSTR)c_pszOne;

        if (pDunSetting->bAllowEap)
        {
            pszAllowEAP = (LPTSTR)c_pszOne;

            wsprintf(szCustomAuthKey, TEXT("%d"), pDunSetting->dwCustomAuthKey);
            pszCustomAuthKey = szCustomAuthKey;
        }
        else
        {
            pszAllowPap = (LPTSTR)(pDunSetting->bAllowPap ? c_pszOne : c_pszZero);
            pszAllowSpap = (LPTSTR)(pDunSetting->bAllowSpap ? c_pszOne : c_pszZero);
            pszAllowChap = (LPTSTR)(pDunSetting->bAllowChap ? c_pszOne : c_pszZero);
            pszAllowMsChap = (LPTSTR)(pDunSetting->bAllowMsChap ? c_pszOne : c_pszZero);
            pszAllowMsChap2 = (LPTSTR)(pDunSetting->bAllowMsChap2 ? c_pszOne : c_pszZero);
            pszAllowW95MsChap = (LPTSTR)(pDunSetting->bAllowW95MsChap ? c_pszOne : c_pszZero);
        }

        wsprintf(szEncryptionType, TEXT("%d"), pDunSetting->dwEncryptionType);
        pszEncryptionType = szEncryptionType;

        if (pDunSetting->bTunnelDunSetting)
        {
            wsprintf(szVpnStrategy, TEXT("%d"), pDunSetting->dwVpnStrategy);
            pszVpnStrategy = szVpnStrategy;
        }

        pszUsePresharedKey = (LPTSTR)(pDunSetting->bUsePresharedKey ? c_pszOne : c_pszZero);
    }

    //
    //  Now write out the Win2k security settings
    //
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerEnforceCustomSecurity, pszEnforceCustomSecurity, pszCmsFile);    
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerCustomSecurity, pszCustomSecurity, pszCmsFile);

    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerRequireEap, pszAllowEAP, pszCmsFile);
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerCustomAuthKey, pszCustomAuthKey, pszCmsFile);

    if (pszAllowEAP)
    {
        MYVERIFY(SUCCEEDED(WriteDunSettingsEapData(szServerSection, pDunSetting, pszCmsFile)));
    }
    else
    {
        MYVERIFY(SUCCEEDED(EraseDunSettingsEapData(szServerSection, pszCmsFile)));    
    }

    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerRequirePap, pszAllowPap, pszCmsFile);
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerRequireSpap, pszAllowSpap, pszCmsFile);
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerRequireChap, pszAllowChap, pszCmsFile);
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerRequireMsChap, pszAllowMsChap, pszCmsFile);
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerRequireMsChap2, pszAllowMsChap2, pszCmsFile);
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerRequireW95MsChap, pszAllowW95MsChap, pszCmsFile);

    WritePrivateProfileString(szNetworkingSection, c_pszCmEntryDunNetworkingVpnStrategy, pszVpnStrategy, pszCmsFile);
    WritePrivateProfileString(szNetworkingSection, c_pszCmEntryDunNetworkingUsePreSharedKey, pszUsePresharedKey, pszCmsFile);
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerEncryptionType, pszEncryptionType, pszCmsFile);

    //
    //  If this is a VPN entry then let's mark it as such
    //
    if (pDunSetting->bTunnelDunSetting)
    {
        WritePrivateProfileString(szNetworkingSection, c_pszCmEntryDunNetworkingVpnEntry, c_pszOne, pszCmsFile);
    }
    else
    {
        WritePrivateProfileString(szNetworkingSection, NULL, NULL, pszCmsFile);    
    }

    //
    //  Write the legacy security settings
    //
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerPwEncrypt, pszPwEncrypt, pszCmsFile);
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerPwEncryptMs, pszPwEncryptMs, pszCmsFile);        
    WritePrivateProfileString(szServerSection, c_pszCmEntryDunServerDataEncrypt, pszDataEncrypt, pszCmsFile);

    //
    //  Now write out the script section if we have one
    //
    if (pDunSetting->szScript[0])
    {
        TCHAR szScriptFile[MAX_PATH+1];
        GetFileName(pDunSetting->szScript, szTemp);
        MYVERIFY(CELEMS(szScriptFile) > (UINT)wsprintf(szScriptFile, TEXT("%s\\%s"), pszShortServiceName, szTemp));

        MYVERIFY(0 != WritePrivateProfileString(szScriptingSection, c_pszCmEntryDunScriptingName, szScriptFile, pszCmsFile));
    }
    else
    {
        MYVERIFY(0 != WritePrivateProfileString(szScriptingSection, c_pszCmEntryDunScriptingName, NULL, pszCmsFile));
    }

    //
    //  Did the admin specify Wins and Dns addresses or is the server going to set them
    //
    if ((pDunSetting->dwPrimaryDns) || (pDunSetting->dwSecondaryDns) || (pDunSetting->dwPrimaryWins) || (pDunSetting->dwSecondaryWins))
    {
        MYVERIFY(ConvertIpDwordToString(pDunSetting->dwPrimaryDns, szTemp));
        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpDnsAddress, szTemp, pszCmsFile));

        MYVERIFY(ConvertIpDwordToString(pDunSetting->dwSecondaryDns, szTemp));
        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpDnsAltAddress, szTemp, pszCmsFile));

        MYVERIFY(ConvertIpDwordToString(pDunSetting->dwPrimaryWins, szTemp));
        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpWinsAddress, szTemp, pszCmsFile));

        MYVERIFY(ConvertIpDwordToString(pDunSetting->dwSecondaryWins, szTemp));
        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpWinsAltAddress, szTemp, pszCmsFile));

        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpSpecifyServerAddress, c_pszOne, pszCmsFile));
    }
    else
    {
        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpSpecifyServerAddress, c_pszZero, pszCmsFile));

        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpDnsAddress, NULL, pszCmsFile));
        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpDnsAltAddress, NULL, pszCmsFile));
        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpWinsAddress, NULL, pszCmsFile));
        MYVERIFY(0 != WritePrivateProfileString(szTcpIpSection, c_pszCmEntryDunTcpIpWinsAltAddress, NULL, pszCmsFile));
    }
}

//+----------------------------------------------------------------------------
//
// Function:  EraseNetworkingSections
//
// Synopsis:  This function erases all the networking sections for the given
//            DUN name.  Thus if you give it a DUN name of Fred, it will 
//            erase Server&Fred, Networking&Fred, etc.
//
// Arguments: LPCTSTR pszDunName - base dun name to erase all of the settings for
//            LPCTSTR pszCmsFile - cms file to erase the setting from
//
// Returns:   Nothing
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
void EraseNetworkingSections(LPCTSTR pszDunName, LPCTSTR pszCmsFile)
{
    TCHAR szSection[MAX_PATH+1];
    const int c_iNumDunSubSections = 4;
    const TCHAR* const ArrayOfSubSections[c_iNumDunSubSections] = 
    {
        c_pszCmSectionDunServer, 
        c_pszCmSectionDunNetworking, 
        c_pszCmSectionDunTcpIp, 
        c_pszCmSectionDunScripting
    };

    if (pszDunName)
    {
        for (int i = 0; i < c_iNumDunSubSections; i++)
        {
            MYVERIFY(CELEMS(szSection) > (UINT)wsprintf(szSection, TEXT("%s&%s"), ArrayOfSubSections[i], pszDunName));
            MYVERIFY(0 != WritePrivateProfileString(szSection, NULL, NULL, pszCmsFile));        
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  WriteNetworkingEntries
//
// Synopsis:  This function walks through the list of networking entries and
//            either adds the networking entry to the given CMS file or
//            if the entry is a VPN entry and the user turned off VPN's then
//            it erases the VPN sections.
//
// Arguments: LPCTSTR pszCmsFile - Cms File to write the networking entries too
//            LPCTSTR pszLongServiceName - long service name of the profile
//            LPCTSTR pszShortServiceName - short service name of the profile
//            ListBxList *g_pHeadDns - pointer to the head of the Dun entries list
//
// Returns:   Nothing
//
// History:   quintinb Created     03/22/00
//
//+----------------------------------------------------------------------------
void WriteNetworkingEntries(LPCTSTR pszCmsFile, LPCTSTR pszLongServiceName, LPCTSTR pszShortServiceName, ListBxList *pHeadDns)
{
    MYDBGASSERT(pszCmsFile);
    MYDBGASSERT(pszShortServiceName);
    MYDBGASSERT(pszLongServiceName);

    if (pszCmsFile && pszShortServiceName && pszLongServiceName && pHeadDns)
    {

        ListBxList * pCurrent = pHeadDns;
        TCHAR szTemp[MAX_PATH];
        TCHAR szTunnelDunName[MAX_PATH] = TEXT("");

        //
        //  Get the name of the Tunnel Dun setting
        //
        MYVERIFY(0 != GetTunnelDunSettingName(pszCmsFile, pszLongServiceName, szTunnelDunName, CELEMS(szTunnelDunName)));

        while  (pCurrent)
        {
            //
            //  If we don't have any data for the entry (it was a placeholder that the user choose not to fill in) or
            //  if the entry is the tunneling entry and we aren't actually Tunneling then erase the entry instead of actually
            //  writing it out.
            //
            if (NULL == pCurrent->ListBxData)
            {
                EraseNetworkingSections(pCurrent->szName, pszCmsFile);
            }
            else
            {
                WriteOutNetworkingEntry(pCurrent->szName, (CDunSetting*)pCurrent->ListBxData, pszShortServiceName, pszCmsFile);
            }

            pCurrent = pCurrent->next;
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  EnableDisableDataEncryptCheckbox
//
// Synopsis:  This function enables or disables the data encrypt checkbox
//            depending on whether the user has selected to allow MsChap or not.
//            For data encryption to be negotiated, the authentication protocol
//            must be MsChap.
//
// Arguments: HWND hDlg - window handle to the dialog
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void EnableDisableDataEncryptCheckbox(HWND hDlg)
{
    BOOL bMsChapEnabled = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_MS_ENCRYPTED_AUTH));

    HWND hControl = GetDlgItem(hDlg, IDC_CHECK1);

    if (hControl)
    {
        EnableWindow (hControl, bMsChapEnabled);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessSecurityPopup
//
// Synopsis:  This function processes messages for the simple security dialog.
//            This dialog only contains authorization protocols and encryption
//            settings supported on all platforms.
//
// Arguments: HWND hDlg - window handle to the dialog
//            UINT message - the current message to process
//            WPARAM wParam - wParam see individual message type for details
//            LPARAM lParam - lParam see individual message type for details
//
// Returns:   INT_PTR - TRUE if the message was completely handled
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessSecurityPopup(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static CDunSetting* pDunSetting = NULL;

    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_DENTRY)) return TRUE;
    
    switch (message)
    {
        case WM_INITDIALOG:
            if (lParam)
            {
                pDunSetting = (CDunSetting*)lParam;

                //
                //  Set the radio button to the correct choice
                //
                UINT uRadioButtonToSet;

                if (pDunSetting->bPWEncrypt_MS)
                {
                    uRadioButtonToSet = IDC_MS_ENCRYPTED_AUTH;

                    //
                    //  Set the Data Encryption checkbox, note that data encryption requires MSChap
                    //
                    MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK1, pDunSetting->bDataEncrypt));
                }
                else if (pDunSetting->bPWEncrypt)
                {
                    uRadioButtonToSet = IDC_ENCRYPTED_AUTH;                
                }
                else
                {
                    uRadioButtonToSet = IDC_ANY_AUTH;
                }

                MYVERIFY(0 != CheckRadioButton(hDlg, IDC_ANY_AUTH, IDC_MS_ENCRYPTED_AUTH, uRadioButtonToSet));
            }
            else
            {
                pDunSetting = NULL;
                CMASSERTMSG(FALSE, TEXT("ProcessSecurityPopup -- NULL lParam passed to InitDialog.  Dialog controls will all be set to off."));            
            }

            EnableDisableDataEncryptCheckbox(hDlg);

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_MS_ENCRYPTED_AUTH:
                case IDC_ENCRYPTED_AUTH:
                case IDC_ANY_AUTH:
                    EnableDisableDataEncryptCheckbox(hDlg);
                break;
                case IDOK:
                    
                    MYDBGASSERT(pDunSetting);
                    
                    if (pDunSetting)
                    {
                        pDunSetting->bDataEncrypt = IsDlgButtonChecked(hDlg, IDC_CHECK1); // if mschap isn't enabled we will write out zero for DataEncrypt

                        pDunSetting->bPWEncrypt_MS = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_MS_ENCRYPTED_AUTH));
                        pDunSetting->bPWEncrypt = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ENCRYPTED_AUTH));
                    }

                    EndDialog(hDlg, IDOK);

                    break;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    break;

                default:
                    break;
            }

            break;
    }
    return FALSE;   
}

//+----------------------------------------------------------------------------
//
// Function:  EnableDisableEapPropertiesButton
//
// Synopsis:  This function enables or disables the EAP properties button found
//            on the Win2k specific security settings dialog.  If the currently
//            selected EAP has configuration UI then the properties button should
//            be enabled.  The function determines this by getting the EAPData
//            structure pointer that is cached in the ItemData of the combobox.
//            Note that the Properties button should also be disabled when EAP
//            is disabled but that this function doesn't deal with that case.
//
// Arguments: HWND hDlg - window handle to the win2k security dialog
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void EnableDisableEapPropertiesButton(HWND hDlg)
{
    BOOL bEnablePropButton = FALSE;

    LRESULT lResult = SendDlgItemMessage(hDlg, IDC_EAP_TYPES, CB_GETCURSEL, 0, 0);

    if (CB_ERR != lResult)
    {
        lResult = SendDlgItemMessage(hDlg, IDC_EAP_TYPES, CB_GETITEMDATA, (WPARAM)lResult, 0);
        EAPData* pEAPData = (EAPData*)lResult;

        if (pEAPData)
        {
            bEnablePropButton = (pEAPData->pszConfigDllPath && pEAPData->pszConfigDllPath[0]);
        }
    }

    EnableWindow(GetDlgItem(hDlg, IDC_EAP_PROPERTIES), bEnablePropButton);
}

//+----------------------------------------------------------------------------
//
// Function:  EnableAppropriateSecurityControls
//
// Synopsis:  This function enables or disables all of the authorization
//            protocol controls on the win2k security dialog.  If EAP
//            is selected then only the EAP combobox and potentially the
//            EAP properties button should be enabled (depending on if the
//            currently selected EAP supports configuration UI or not).
//            If EAP is NOT selected then the EAP controls should be disabled
//            and the other authorization checkboxes (PAP, SPAP, CHAP, etc.)
//            should be enabled.
//
// Arguments: HWND hDlg - window handle to the win2k security dialog
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void EnableAppropriateSecurityControls(HWND hDlg)
{
    BOOL bUseEAP = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_USE_EAP));

    //
    //  If EAP is enabled then we need to disable all of the
    //  other security authorization protocols.
    //
    EnableWindow(GetDlgItem(hDlg, IDC_ALLOW_PAP), !bUseEAP);
    EnableWindow(GetDlgItem(hDlg, IDC_ALLOW_SPAP), !bUseEAP);
    EnableWindow(GetDlgItem(hDlg, IDC_ALLOW_CHAP), !bUseEAP);
    EnableWindow(GetDlgItem(hDlg, IDC_ALLOW_MSCHAP), !bUseEAP);
    EnableWindow(GetDlgItem(hDlg, IDC_ALLOW_MSCHAP2), !bUseEAP);

    //
    //  If EAP is disabled then we need to enable the enable combobox
    //  and the EAP properties button.
    //
    EnableWindow(GetDlgItem(hDlg, IDC_EAP_TYPES), bUseEAP);

    if (bUseEAP)
    {
        EnableDisableEapPropertiesButton(hDlg);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_EAP_PROPERTIES), FALSE);    
    }
}

#define MAX_BLOB_CHARS_PER_LINE 128

//
// From ras\ui\common\nouiutil\noui.c
//
BYTE HexValue(IN CHAR ch)

    /* Returns the value 0 to 15 of hexadecimal character 'ch'.
    */
{
    if (ch >= '0' && ch <= '9')
        return (BYTE )(ch - '0');
    else if (ch >= 'A' && ch <= 'F')
        return (BYTE )((ch - 'A') + 10);
    else if (ch >= 'a' && ch <= 'f')
        return (BYTE )((ch - 'a') + 10);
    else
        return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  ReadDunSettingsEapData
//
// Synopsis:  Retrieves DUN setting for EAP config (opaque blob) data. The 
//            entry may span several lines and contain several EAP data blocks.
//
// Arguments: CIni *pIni - Ptr to ini object to be used.
//            LPBYTE* ppbEapData - Address of pointer to store EapData, allocated here.
//            LPDWORD pdwEapSize - Ptr to a DWORD to record the size of the data blob.
//            DWORD dwCustomAuthKey - The EAP type that we are interested in.
//
// Returns:   TRUE on success
//
// Note:      CM expects blob data to be provided in numbered entries such as:
//                    CustomAuthData0=, CustomAuthData1=, CustomAuthData2=, etc.
//
// History:   nickball    Created                                       08/24/98
//            nickball    Handle multiple EAP data blocks in blob.      09/11/99
//            quintinb    modified not to use CIni                      03/27/00
//
//+----------------------------------------------------------------------------
BOOL ReadDunSettingsEapData(LPCTSTR pszSection, LPBYTE* ppbEapData, LPDWORD pdwEapSize, const DWORD dwCustomAuthKey, LPCTSTR pszCmsFile)
{
    CHAR *pchBuf = NULL;
    CHAR szTmp[MAX_BLOB_CHARS_PER_LINE + 2]; 
    CHAR szEntry[128];
    int nLine = -1;
    int nRead = -1; 
    int nTotal = 0;

    LPBYTE pbEapBytes = NULL;

    MYDBGASSERT(pszSection);
    MYDBGASSERT(pszSection[0]);
    MYDBGASSERT(ppbEapData);
    MYDBGASSERT(pdwEapSize);

    if ((NULL == pszSection) || (NULL == ppbEapData) || (NULL == pdwEapSize) || (TEXT('\0') == pszSection[0]))
    {
        return FALSE;
    }

    //
    // Convert the Section and the CMS File to ANSI strings
    //
    BOOL bRet = FALSE;
    LPSTR pszAnsiSection = WzToSzWithAlloc(pszSection);       
    LPSTR pszAnsiCmsFile = WzToSzWithAlloc(pszCmsFile);

    if (!pszAnsiSection || !pszAnsiCmsFile)
    {
        bRet = FALSE;
        goto exit;
    }

    // 
    // Read numbered entries until there are no more. 
    // Note: RAS blob doesn't exceed 64 chars, but can wrap over multiple lines
    //

    while (nRead)
    {
        //
        // Read CustomAuthDataX where X is the number of entries
        // 

        nLine++;
        wsprintfA(szEntry, "%s%d", c_pszCmEntryDunServerCustomAuthData, nLine);

        nRead = GetPrivateProfileStringA(pszAnsiSection, szEntry, "", szTmp, sizeof(szTmp), pszAnsiCmsFile);

        if (nRead)
        {               
            //
            // If line exceeded 128 chars, it is considered corrupt
            // 

            if (MAX_BLOB_CHARS_PER_LINE < nRead)
            {                               
                nTotal = 0;
                break;
            }

            //
            // Update our local master buffer with the latest fragment
            //

            if (nLine)
            {
                pchBuf = CmStrCatAllocA(&pchBuf, szTmp);
            }
            else
            {
                pchBuf = CmStrCpyAllocA(szTmp);
            }

            if (!pchBuf)
            {
                bRet = FALSE;
                goto exit;
            }

            nTotal += nRead;
        }
    }

    //
    // At this point we should have the entire entry in pchBuf in HEX format
    // Convert the buffer to byte format and store in supplied EAP buffer.
    //

    if (nTotal && !(nTotal & 1))
    {
        nTotal /= 2; // Only need half the hex char size

        pbEapBytes = (BYTE *) CmMalloc(nTotal + 1);

        if (!pbEapBytes)
        {
            goto exit;
        }

        CHAR *pch = pchBuf;
        BYTE *pb = pbEapBytes;

        while (*pch != '\0')
        {
            *pb = HexValue( *pch++ ) * 16;
            *pb += HexValue( *pch++ );
            ++pb;
        }

        //
        // Now we have the bytes, locate and extract the data block that we
        // are after. Note: Multiple blocks are arrayed using the following 
        // header:
        //
        //  typedef struct _EAP_CUSTOM_DATA
        //  {
        //      DWORD dwSignature;
        //      DWORD dwCustomAuthKey;
        //      DWORD dwSize;
        //      BYTE  abdata[1];
        //  } EAP_CUSTOM_DATA;
        //

        EAP_CUSTOM_DATA *pCustomData = (EAP_CUSTOM_DATA *) pbEapBytes;

        while (((LPBYTE) pCustomData - pbEapBytes) < nTotal)
        {
            if (pCustomData->dwCustomAuthKey == dwCustomAuthKey)
            {
                //
                // Bingo! We have a match, first make sure that the indicated 
                // size isn't pointing out into space, then make a copy and 
                // run for the hills.
                //

                if (((LPBYTE) pCustomData - pbEapBytes) + sizeof(EAP_CUSTOM_DATA) + pCustomData->dwSize > (DWORD) nTotal)
                {
                    MYDBGASSERT(FALSE);
                    goto exit;
                }

                *ppbEapData = (BYTE *) CmMalloc(pCustomData->dwSize);        

                if (*ppbEapData)
                {   
                    CopyMemory(*ppbEapData, pCustomData->abdata, pCustomData->dwSize);                    

                    *pdwEapSize = pCustomData->dwSize;                                                     
                    bRet = TRUE;
                    goto exit;                                
                }
            }       

            //
            // Locate the next data block
            //

            pCustomData = (EAP_CUSTOM_DATA *) ((LPBYTE) pCustomData + sizeof(EAP_CUSTOM_DATA) + pCustomData->dwSize); 
        }
    }
    else if (0 == nTotal)
    {
        //
        //  No CustomAuthData, that is perfectly exceptable.  MD5 challenge for instance doesn't require any
        //
        *ppbEapData = NULL;
        *pdwEapSize = 0;
        bRet = TRUE;
    }

exit:

    CmFree(pchBuf);
    CmFree(pszAnsiSection);
    CmFree(pszAnsiCmsFile);
    CmFree(pbEapBytes);

    return bRet;
}

//
// From ras\ui\common\nouiutil\noui.c
//
CHAR HexChar(IN BYTE byte)

    /* Returns an ASCII hexidecimal character corresponding to 0 to 15 value,
    ** 'byte'.
    */
{
    const CHAR* pszHexDigits = "0123456789ABCDEF";

    if (byte >= 0 && byte < 16)
        return pszHexDigits[ byte ];
    else
        return '0';
}

//+----------------------------------------------------------------------------
//
// Function:  EraseDunSettingsEapData
//
// Synopsis:  This function erases the CustomAuthData key of the EAP settings
//            for the given section and CMS file
//
// Arguments: LPCTSTR pszSection - section name to erase the CustomAuthData from
//            LPCTSTR pszCmsFile - cms file to erase the data from
//
// Returns:   HRESULT - standard COM style error codes
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
HRESULT EraseDunSettingsEapData(LPCTSTR pszSection, LPCTSTR pszCmsFile)
{
    if ((NULL == pszSection) || (NULL == pszCmsFile) || 
        (TEXT('\0') == pszSection[0]) || (TEXT('\0') == pszCmsFile[0]))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    int iLineNum = 0;
    DWORD dwRet = -1;
    TCHAR szKeyName[MAX_PATH+1];
    TCHAR szLine[MAX_PATH+1];

    while(0 != dwRet)
    {
        wsprintf(szKeyName, TEXT("%S%d"), c_pszCmEntryDunServerCustomAuthData, iLineNum);

        dwRet = GetPrivateProfileString(pszSection, szKeyName, TEXT(""), szLine, MAX_PATH, pszCmsFile);

        if (dwRet)
        {
            MYVERIFY(0 != WritePrivateProfileString(pszSection, szKeyName, NULL, pszCmsFile));
        }

        iLineNum++;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteDunSettingsEapData
//
// Synopsis:  This function writes out the CustomAuthData key of the EAP settings
//            to the given section and CMS file.  Since CM expects the EAP data
//            to have the RAS EAP header on it (the header that RAS adds when it
//            puts the EAP data in the phonebook) and thus we need to add this
//            to the EAP blob before writing it to the CMS.
//
// Arguments: LPCTSTR pszSection - section name to write the CustomAuthData to
//            CDunSetting* pDunSetting - Dun settings data
//            LPCTSTR pszCmsFile - cms file to write the data to
//
// Returns:   HRESULT - standard COM style error codes
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
HRESULT WriteDunSettingsEapData(LPCTSTR pszSection, CDunSetting* pDunSetting, LPCTSTR pszCmsFile)
{
    if ((NULL == pszSection) || (NULL == pDunSetting) || (NULL == pszCmsFile) || 
        (TEXT('\0') == pszSection[0]) || (TEXT('\0') == pszCmsFile[0]))
    {
        return E_INVALIDARG;
    }

    //
    //  Make sure to erase any existing lines just in case the existing data is longer
    //  than our current data.  If we leave lines around that don't need to be there then
    //  the EAP data will be invalid.
    //
    HRESULT hr = EraseDunSettingsEapData(pszSection, pszCmsFile);

    //
    //  Check to see if we need to do anything.  Not all EAP's require custom data so
    //  let's not try to write it out unless we have some.
    //
    if (pDunSetting->dwCustomAuthDataSize && pDunSetting->pCustomAuthData)
    {
        //
        //  We need to add the EAP_CUSTOM_DATA header to the
        //  data returned from the EAP because this is the format
        //  that CM expects to find it in (the format it would be in
        //  if an Admin copied it by hand).
        //
        hr = S_OK;
        DWORD dwSize = pDunSetting->dwCustomAuthDataSize + sizeof(EAP_CUSTOM_DATA);

        EAP_CUSTOM_DATA* pEAPCustomData = (EAP_CUSTOM_DATA*)CmMalloc(dwSize);
        LPSTR pszAnsiSection = WzToSzWithAlloc(pszSection);
        LPSTR pszAnsiCmsFile = WzToSzWithAlloc(pszCmsFile);

        if (pEAPCustomData && pszAnsiSection && pszAnsiCmsFile)
        {
            pEAPCustomData->dwSignature = EAP_CUSTOM_KEY;
            pEAPCustomData->dwCustomAuthKey = pDunSetting->dwCustomAuthKey;
            pEAPCustomData->dwSize = pDunSetting->dwCustomAuthDataSize;
            CopyMemory(pEAPCustomData->abdata, pDunSetting->pCustomAuthData, pDunSetting->dwCustomAuthDataSize);

            CHAR szOutput[MAX_BLOB_CHARS_PER_LINE+1];
            CHAR szAnsiKeyName[MAX_BLOB_CHARS_PER_LINE];
            CHAR* pszOutput;
            LPBYTE pCurrentByte = (LPBYTE)pEAPCustomData;
            int iCount = 0;
            int iLineNum = 0;
            pszOutput = szOutput;

            while (pCurrentByte < ((LPBYTE)pEAPCustomData + dwSize))
            {
                *pszOutput++ = HexChar( (BYTE )(*pCurrentByte / 16) );
                *pszOutput++ = HexChar( (BYTE )(*pCurrentByte % 16) );
                pCurrentByte++;
                iCount = iCount + 2; // keep track of number of chars in ansi output buffer

                if ((MAX_BLOB_CHARS_PER_LINE == iCount) || (pCurrentByte == ((LPBYTE)pEAPCustomData + dwSize)))
                {
                    *pszOutput = '\0';
                    wsprintfA(szAnsiKeyName, "%s%d", c_pszCmEntryDunServerCustomAuthData, iLineNum);

                    MYVERIFY(0 != WritePrivateProfileStringA(pszAnsiSection, szAnsiKeyName, szOutput, pszAnsiCmsFile));
                
                    pszOutput = szOutput;
                    iCount = 0;
                    iLineNum++;
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        CmFree(pEAPCustomData);
        CmFree(pszAnsiCmsFile);
        CmFree(pszAnsiSection);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  GetEAPDataFromUser
//
// Synopsis:  This function is called when the user hits the properties button
//            for EAP configuration.  This function gets the EAP configuration
//            UI path from the EAPData structure cached in the Combobox Item data
//            and tries to call the configuration UI.  If the user configures the
//            EAP then the new EAP data and data size are set in the EAPData
//            struct for the combobox.  If the user cancels then nothing is changed.
//            Note that when the user hits OK on the win2k security dialog the EAP
//            data will be retrieved from the EAPData struct and set in the
//            actual DUN setting.
//
// Arguments: HWND hDlg - dialog window handle
//            UINT uCtrlId - control ID of the EAP combobox
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void GetEAPDataFromUser(HWND hDlg, UINT uCtrlId)
{
    MYDBGASSERT(hDlg && uCtrlId);

    if (hDlg && uCtrlId)
    {
        LRESULT lResult = SendDlgItemMessage(hDlg, uCtrlId, CB_GETCURSEL, 0, 0);

        MYDBGASSERT(CB_ERR != lResult);

        if (CB_ERR != lResult)
        {
            lResult = SendDlgItemMessage(hDlg, uCtrlId, CB_GETITEMDATA, (WPARAM)lResult, 0);
            EAPData* pEAPData = (EAPData*)lResult;

            if (pEAPData && pEAPData->pszConfigDllPath && pEAPData->pszConfigDllPath[0])
            {
                HINSTANCE hEapConfigDll = LoadLibrary(pEAPData->pszConfigDllPath);

                if (hEapConfigDll)
                {
                    typedef DWORD (WINAPI *RasEapInvokeConfigUIProc)(DWORD, HWND, DWORD, BYTE*, DWORD, BYTE**, DWORD*);
                    typedef DWORD (WINAPI *RasEapFreeMemoryProc)(BYTE*);
                    const char* const c_pszRasEapFreeMemory = "RasEapFreeMemory";
                    const char* const c_pszRasEapInvokeConfigUI = "RasEapInvokeConfigUI";

                    RasEapFreeMemoryProc pfnRasEapFreeMemory = (RasEapFreeMemoryProc)GetProcAddress(hEapConfigDll, c_pszRasEapFreeMemory);
                    RasEapInvokeConfigUIProc pfnRasEapInvokeConfigUI = (RasEapInvokeConfigUIProc)GetProcAddress(hEapConfigDll, c_pszRasEapInvokeConfigUI);

                    if (pfnRasEapFreeMemory && pfnRasEapInvokeConfigUI)
                    {
                        DWORD dwNewSize = 0;
                        BYTE* pNewData = NULL;

                        DWORD dwReturn = pfnRasEapInvokeConfigUI(pEAPData->dwCustomAuthKey, hDlg, 0, pEAPData->pCustomAuthData, 
                                                                 pEAPData->dwCustomAuthDataSize, &pNewData, &dwNewSize);

                        if (NO_ERROR == dwReturn)
                        {
                            CmFree(pEAPData->pCustomAuthData);

                            pEAPData->pCustomAuthData = (LPBYTE)CmMalloc(dwNewSize);

                            if (pEAPData->pCustomAuthData)
                            {
                                pEAPData->dwCustomAuthDataSize = dwNewSize;

                                CopyMemory(pEAPData->pCustomAuthData, pNewData, dwNewSize);
                            }
                            else
                            {
                                pEAPData->dwCustomAuthDataSize = 0;
                                pEAPData->pCustomAuthData = NULL;
                                CMASSERTMSG(FALSE, TEXT("GetEAPDataFromUser -- CmMalloc failed."));
                            }

                            MYVERIFY(NO_ERROR == pfnRasEapFreeMemory(pNewData));
                        }
                        else if (ERROR_CANCELLED != dwReturn)
                        {
                            CMTRACE3(TEXT("EAP %d (%s) failed with return code %d"), pEAPData->dwCustomAuthKey, pEAPData->pszConfigDllPath, dwReturn);
                            CMASSERTMSG(FALSE, TEXT("GetEAPDataFromUser -- pfnRasEapInvokeConfigUI from EAP dll failed."));
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("GetEAPDataFromUser -- GetProcAddressFailed on the EAP dll."));                    
                    }
                }
                else
                {
                    CMTRACE2(TEXT("Failed to load EAP %d (%s)"), pEAPData->dwCustomAuthKey, pEAPData->pszConfigDllPath);
                    CMASSERTMSG(FALSE, TEXT("GetEAPDataFromUser -- Unable to load the specified EAP Dll."));                    
                }
            }
        }    
    }
}

int MapEncryptionTypeToComboId(DWORD dwEncryptionType)
{
    int iReturn;

    switch(dwEncryptionType)
    {
        case ET_None:
            iReturn = 0;
            break;

        case ET_RequireMax:
        case ET_Require:
            iReturn = 1;
            break;

        case ET_Optional:
        default:
            iReturn = 2;
            break;
    }

    return iReturn;

}

DWORD MapComboIdToEncryptionType(INT_PTR iComboIndex)
{
    DWORD dwReturn;

    switch(iComboIndex)
    {
        case 0:
            dwReturn = ET_None;
            break;

        case 1:
            dwReturn = ET_Require; // note that we never set require max
            break;

        case 2:
        default:
            dwReturn = ET_Optional;
            break;
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessWin2kSecurityPopup
//
// Synopsis:  This function processes messages for the Win2k+ security dialog.
//            This dialog contains configuration UI for all of the advanced
//            settings allowed by Win2k (EAP, PAP, SPAP, etc plus encryption
//            type and vpn strategy).
//
// Arguments: HWND hDlg - window handle to the dialog
//            UINT message - the current message to process
//            WPARAM wParam - wParam see individual message type for details
//            LPARAM lParam - lParam see individual message type for details
//
// Returns:   INT_PTR - TRUE if the message was completely handled
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessWin2kSecurityPopup(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static CDunSetting* pDunSetting = NULL;

    SetDefaultGUIFont(hDlg, message, IDC_ENCRYPTION_TYPE);
    SetDefaultGUIFont(hDlg, message, IDC_EAP_TYPES);
    SetDefaultGUIFont(hDlg, message, IDC_VPN_TYPE);

    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_DENTRY)) return TRUE;
    
    switch (message)
    {
        case WM_INITDIALOG:
            if (lParam)
            {
                pDunSetting = (CDunSetting*)lParam;

                //
                //  Load and add the strings to the Data Encryption combobox
                //
                LPTSTR pszString;
                for (int i = BASE_ENCRYPT_TYPE_ID; i < (BASE_ENCRYPT_TYPE_ID + NUM_ENCRYPT_TYPES); i++)
                {
                    pszString = CmLoadString(g_hInstance, i);
                    MYDBGASSERT(pszString);

                    if (pszString)
                    {
                        SendDlgItemMessage(hDlg, IDC_ENCRYPTION_TYPE, CB_ADDSTRING, 0, (LPARAM)pszString);
                        CmFree(pszString);
                    }
                }

                //
                //  Now pick the type of encryption the user has selected
                //
                MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, IDC_ENCRYPTION_TYPE, CB_SETCURSEL, (WPARAM)MapEncryptionTypeToComboId(pDunSetting->dwEncryptionType), (LPARAM)0));

                //
                //  Enumerate all of the available EAP's on the machine
                //
                MYVERIFY(SUCCEEDED(HrAddAvailableEAPsToCombo(hDlg, IDC_EAP_TYPES, pDunSetting)));

                //
                //  Select the appropriate EAP as necessary
                //
                SelectAppropriateEAP(hDlg, IDC_EAP_TYPES, pDunSetting);

                //
                //  Figure out what authentication protocols the user wants to allow.
                //  Note that if we are doing EAP then that is all we allow them to do
                //  and the other settings will be ignored.  Also note that we don't have
                //  UI for w95CHAP but we won't touch the setting if it exists.
                //
                MYVERIFY(0 != CheckDlgButton(hDlg, IDC_ALLOW_PAP, pDunSetting->bAllowPap));
                MYVERIFY(0 != CheckDlgButton(hDlg, IDC_ALLOW_SPAP, pDunSetting->bAllowSpap));
                MYVERIFY(0 != CheckDlgButton(hDlg, IDC_ALLOW_CHAP, pDunSetting->bAllowChap));
                MYVERIFY(0 != CheckDlgButton(hDlg, IDC_ALLOW_MSCHAP, pDunSetting->bAllowMsChap));
                MYVERIFY(0 != CheckDlgButton(hDlg, IDC_ALLOW_MSCHAP2, pDunSetting->bAllowMsChap2));

                if (pDunSetting->bAllowEap)
                {
                    MYVERIFY(0 != CheckRadioButton(hDlg, IDC_USE_EAP, IDC_ALLOWED_PROTOCOLS, IDC_USE_EAP));
                }
                else
                {
                    MYVERIFY(0 != CheckRadioButton(hDlg, IDC_USE_EAP, IDC_ALLOWED_PROTOCOLS, IDC_ALLOWED_PROTOCOLS));                
                }

                //
                //  Note that the VPN controls do not exist unless we have a Tunnel Dun Setting and are
                //  thus using the tunnel dun setting dialog.
                //
                if (pDunSetting->bTunnelDunSetting)
                {
                    //
                    //  Load and add the Vpn type string to the vpn type combobox
                    //
                    for (int i = BASE_VPN_TYPE_ID; i < (BASE_VPN_TYPE_ID + NUM_VPN_TYPES); i++)
                    {
                        pszString = CmLoadString(g_hInstance, i);
                        MYDBGASSERT(pszString);

                        if (pszString)
                        {
                            SendDlgItemMessage(hDlg, IDC_VPN_TYPE, CB_ADDSTRING, 0, (LPARAM)pszString);
                            CmFree(pszString);
                        }
                    }

                    //
                    //  Pick the type of vpn strategy the user has selected
                    //
                    MYDBGASSERT(pDunSetting->dwVpnStrategy != 0);
                    MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, IDC_VPN_TYPE, CB_SETCURSEL, (WPARAM)(pDunSetting->dwVpnStrategy - 1), (LPARAM)0));
                }

                //
                //  We only want either the EAP controls or the non-EAP auth controls
                //  enabled at once.  Thus figure out which to enable/disable
                //
                EnableAppropriateSecurityControls(hDlg);
            }
            else
            {
                pDunSetting = NULL;
                CMASSERTMSG(FALSE, TEXT("ProcessWin2kSecurityPopup -- NULL lParam passed to InitDialog.  Dialog controls will all be set to off."));            
            }

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_EAP_PROPERTIES:
                    GetEAPDataFromUser(hDlg, IDC_EAP_TYPES);
                    break;

                case IDOK:

                    MYDBGASSERT(pDunSetting);
                    
                    if (pDunSetting)
                    {
                        //
                        //  Since we are storing the settings directly in the data struct given to us, first 
                        //  verify that the authentication protocol and the encryption type match up properly.
                        //  Otherwise a user could modify settings, hit OK, we tell them the settings are
                        //  inappropriate and they hit cancel.  Any settings we modifed before we did the 
                        //  verification would then actually be modified.  To avoid that check to make sure
                        //  we have at least one security protocol checked before continuing.
                        //
                        BOOL bHasAuthProtocol = FALSE;

                        for (int i = BASE_AUTH_CONTROL_ID; i < (BASE_AUTH_CONTROL_ID + NUM_AUTH_TYPES); i++)
                        {
                            if (BST_CHECKED == IsDlgButtonChecked(hDlg, i))
                            {
                                bHasAuthProtocol = TRUE;
                                break;
                            }
                        }

                        if ((FALSE == bHasAuthProtocol) && (BST_UNCHECKED == IsDlgButtonChecked(hDlg, IDC_USE_EAP)))
                        {
                            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NEED_AUTH_PROTOCOL, MB_OK | MB_ICONSTOP));
                            return TRUE;
                        }

                        //
                        //  Next we need to decide whether the user is using EAP or not.  Retrieving the data
                        //  for the EAP they have picked from the combo (if any) will help us decide whether the
                        //  auth protocol they choose matches up with the encryption settings they asked for.
                        //
                        EAPData* pEAPData = NULL;

                        if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_USE_EAP))
                        {
                            //
                            //  Get the EAP Type and the data associated with it.
                            //
                            LRESULT lResult = SendDlgItemMessage(hDlg, IDC_EAP_TYPES, CB_GETCURSEL, 0, 0);

                            MYDBGASSERT(CB_ERR != lResult);

                            if (CB_ERR != lResult)
                            {
                                lResult = SendDlgItemMessage(hDlg, IDC_EAP_TYPES, CB_GETITEMDATA, (WPARAM)lResult, 0);
                                pEAPData = (EAPData*)lResult;

                                if (pEAPData && pEAPData->bMustConfig && (NULL == pEAPData->pCustomAuthData))
                                {
                                    LPTSTR pszMsg = CmFmtMsg(g_hInstance, IDS_EAP_NEEDS_CONFIG, pEAPData->pszFriendlyName);

                                    if (pszMsg)
                                    {
                                        MessageBox(hDlg, pszMsg, g_szAppTitle, MB_OK | MB_ICONSTOP);

                                        CmFree(pszMsg);
                                    }
                                    else
                                    {
                                        CMASSERTMSG(FALSE, TEXT("ProcessWin2kSecurityPopup -- CmMalloc failed!"));
                                    }

                                    HWND hButton = GetDlgItem(hDlg, IDC_EAP_PROPERTIES);

                                    if (hButton && IsWindowEnabled(hButton))
                                    {
                                        SetFocus(hButton);
                                    }
                                    
                                    return TRUE;       
                                }
                            }
                        }

                        //
                        //  Now get the encryption type that the user selected.  Note that in order to negotiate
                        //  encryption we must have EAP or some sort of MSCHAP.
                        //
                        LRESULT lResult = (DWORD)SendDlgItemMessage(hDlg, IDC_ENCRYPTION_TYPE, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);

                        DWORD dwTemp = MapComboIdToEncryptionType(lResult);

                        MYDBGASSERT(ET_RequireMax != dwTemp); // we should never be setting require max

                        if ((ET_Require == dwTemp) || (ET_Optional == dwTemp))
                        {
                            //
                            //  If the user is using EAP, then the EAP type they picked must support
                            //  encryption.  Otherwise, the user must not be using EAP and they must
                            //  be using some sort of MSChap.  The following could be expressed more
                            //  succintly, but there is no sense in confusing the issue.
                            //
                            BOOL bEncryptionAllowed = FALSE;

                            if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_USE_EAP))
                            {
                                if (pEAPData)
                                {
                                    bEncryptionAllowed = pEAPData->bSupportsEncryption;
                                }
                            }
                            else
                            {
                                bEncryptionAllowed = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_MSCHAP)) ||
                                                     (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_MSCHAP2));
                            }

                            if (FALSE == bEncryptionAllowed)
                            {
                                MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NEED_EAP_OR_MSCHAP, MB_OK | MB_ICONSTOP));
                                return TRUE;
                            }
                        }

                        //
                        //  Now save the actual settings
                        //
                        pDunSetting->dwEncryptionType = dwTemp;

                        if (pEAPData)
                        {
                            //
                            //  Now lets update pDunSetting with the actual data.  Note that we are past the
                            //  last place we could throw an error to the user and thus it is okay to touch
                            //  the pDunSetting data (even if the user got an error and then hit cancel we will
                            //  leave their previous data untouched). Note that we don't want to touch the existing
                            //  data if we don't have the EAP installed because we know that we couldn't have
                            //  actually changed the data.
                            //
                            pDunSetting->bAllowEap = TRUE;

                            if (FALSE == pEAPData->bNotInstalled)
                            {
                                CmFree(pDunSetting->pCustomAuthData);

                                pDunSetting->dwCustomAuthKey = pEAPData->dwCustomAuthKey;
                                pDunSetting->pCustomAuthData = pEAPData->pCustomAuthData;
                                pDunSetting->dwCustomAuthDataSize = pEAPData->dwCustomAuthDataSize;

                                //
                                //  Now NULL out the pEapData entry, this saves us from having to
                                //  allocate mem and copy to pDunSetting but keeps the code
                                //  that cleans up the EapData structs from freeing our data
                                //
                                pEAPData->pCustomAuthData = NULL;
                                pEAPData->dwCustomAuthDataSize = 0;
                            }                        
                        }
                        else
                        {
                            pDunSetting->bAllowEap = FALSE;
                        }

                        //
                        //  Get the non-EAP protocols.  Note that if the user selected EAP we will clear
                        //  these before writing them out.
                        //
                        pDunSetting->bAllowPap = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_PAP));
                        pDunSetting->bAllowSpap = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_SPAP));
                        pDunSetting->bAllowChap = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_CHAP));
                        pDunSetting->bAllowMsChap = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_MSCHAP));
                        pDunSetting->bAllowMsChap2 = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_ALLOW_MSCHAP2));

                        if (pDunSetting->bTunnelDunSetting)
                        {
                            pDunSetting->dwVpnStrategy = (DWORD)SendDlgItemMessage(hDlg, IDC_VPN_TYPE, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
                            if (CB_ERR == pDunSetting->dwVpnStrategy)
                            {
                                CMASSERTMSG(FALSE, TEXT("ProcessWin2kSecurityPopup -- CB_ERR returned for VPN strategy."));
                                pDunSetting->dwVpnStrategy = VS_PptpFirst;
                            }
                            else
                            {
                                //
                                //  Adjust Vpn Strategy because we no longer offer Automatic as a choice
                                //
                                pDunSetting->dwVpnStrategy += 1;
                                MYDBGASSERT((pDunSetting->dwVpnStrategy >= VS_PptpOnly) && (pDunSetting->dwVpnStrategy <= VS_L2tpFirst));
                            }
                        }

                    }

                    FreeEapData(hDlg, IDC_EAP_TYPES);

                    EndDialog(hDlg, IDOK);
                    break;

                case IDCANCEL:
                    FreeEapData(hDlg, IDC_EAP_TYPES);

                    EndDialog(hDlg, IDCANCEL);
                    break;

                case IDC_USE_EAP:
                    MYDBGASSERT(pDunSetting);

                    if (pDunSetting)
                    {
                        SelectAppropriateEAP(hDlg, IDC_EAP_TYPES, pDunSetting);
                    }

                case IDC_ALLOWED_PROTOCOLS:
                    EnableAppropriateSecurityControls(hDlg);
                    break;

                case IDC_EAP_TYPES:
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        EnableDisableEapPropertiesButton(hDlg);
                    }
                    break;

                default:
                    break;
            }

            break;
    }
    return FALSE;   
}

//+----------------------------------------------------------------------------
//
// Function:  EnableDisableSecurityButtons
//
// Synopsis:  This function determines which of the two configure buttons
//            should be enabled.  The configure buttons allow the user to
//            configure the security settings of the DUN settings.  There is
//            one button for platform independent security settings and one for
//            win2k+ security settings.
//
// Arguments: HWND hDlg - window handle to the general property sheet
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void EnableDisableSecurityButtons(HWND hDlg)
{
    INT_PTR nResult = SendDlgItemMessage(hDlg, IDC_COMBO1, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);

    if (CB_ERR == nResult)
    {
        nResult = 0;
    }

    //
    //  Disable the Win2k config button if the first selection is chosen
    //
    EnableWindow(GetDlgItem(hDlg, IDC_CONFIG_WIN2K), (0 != nResult));

    //
    //  Disable the standard config button if the last selection is chosen
    //
    EnableWindow(GetDlgItem(hDlg, IDC_CONFIG_ALL), (2 != nResult));

    //
    //  Disable the L2TP/IPSec buttons if L2TP is impossible
    //
    EnableWindow(GetDlgItem(hDlg, IDC_CERT_PSK_GROUPBOX), (0 != nResult));
    EnableWindow(GetDlgItem(hDlg, IDC_USE_CERT), (0 != nResult));
    EnableWindow(GetDlgItem(hDlg, IDC_USE_PRESHARED_KEY), (0 != nResult));
}

//+----------------------------------------------------------------------------
//
// Function:  GeneralPropSheetProc
//
// Synopsis:  This function processes messages for General property sheet of
//            the DUN settings UI.  This property sheet holds UI for configuring
//            the name of the DUN setting and dialup scripting.
//
// Arguments: HWND hDlg - window handle to the dialog
//            UINT message - the current message to process
//            WPARAM wParam - wParam see individual message type for details
//            LPARAM lParam - lParam see individual message type for details
//
// Returns:   INT_PTR - TRUE if the message was completely handled
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY GeneralPropSheetProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR* pnmHeader = (NMHDR*)lParam;
    INT_PTR nResult;
    DWORD_PTR HelpId;
    static ListBxList* pListEntry = NULL;
    static CDunSetting* pDunSetting = NULL;

    SetDefaultGUIFont(hDlg, message, IDC_EDIT1);
    SetDefaultGUIFont(hDlg, message, IDC_EDIT2);

    HelpId = ((pDunSetting && pDunSetting->bTunnelDunSetting) ? IDH_VENTRY : IDH_DENTRY);
    if (ProcessHelp(hDlg, message, wParam, lParam, HelpId)) return TRUE;

    switch (message)
    {
        case WM_INITDIALOG:
            if (lParam)
            {
                PROPSHEETPAGE* pPropSheetPage = (PROPSHEETPAGE*)lParam;

                if (pPropSheetPage->lParam)
                {
                    pListEntry = (ListBxList*)pPropSheetPage->lParam;
                    pDunSetting = (CDunSetting*)pListEntry->ListBxData;

                    if (pListEntry && pDunSetting)
                    {
                        if (pListEntry->szName[0])
                        {
                            MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDIT1), WM_SETTEXT, 0, (LPARAM)pListEntry->szName));
                            EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), FALSE); // don't allow the user to edit the name
                        }

                        //
                        //  Now lets set the disable file and printer sharing checkbox and the network logon checkbox
                        //
                        MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK1, pDunSetting->bSecureLocalFiles));
                        MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK2, pDunSetting->bNetworkLogon));

                        if (pDunSetting->szScript[0])
                        {
                            MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDIT2), WM_SETTEXT, 0, (LPARAM)GetName(pDunSetting->szScript)));
                        }

                        //
                        //  If this is a VPN DUN setting, then hide the script controls
                        //
                        if (pDunSetting->bTunnelDunSetting)
                        {
                            ShowWindow(GetDlgItem(hDlg, IDC_SCRIPT_LABEL), SW_HIDE);
                            ShowWindow(GetDlgItem(hDlg, IDC_EDIT2), SW_HIDE);
                            ShowWindow(GetDlgItem(hDlg, IDC_BUTTON1), SW_HIDE);
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("GeneralPropSheetProc -- pListEntry or pDunSetting are NULL"));
                    }
                }
                else
                {
                    pListEntry = NULL;
                    pDunSetting = NULL;
                    CMASSERTMSG(FALSE, TEXT("GeneralPropSheetProc -- NULL lParam passed to InitDialog.  Dialog controls will all be set to off."));
                }
            }
            else
            {
                pListEntry = NULL;
                pDunSetting = NULL;
                CMASSERTMSG(FALSE, TEXT("GeneralPropSheetProc -- NULL PropSheetPage pointer passed for lParam."));
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_BUTTON1: // browse button

                    if (pDunSetting)
                    {
                        UINT uScpFilter = IDS_SCPFILTER;
                        TCHAR* szScpMask = TEXT("*.scp");

                        MYVERIFY(0 != DoBrowse(hDlg, &uScpFilter, &szScpMask, 1, IDC_EDIT2,
                            TEXT("scp"), pDunSetting->szScript));
                    }

                    break;
            }

            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {
                case PSN_APPLY:
                if (pListEntry && pDunSetting)
                {
                    //
                    //  Get the name of the entry
                    //
                    nResult = GetTextFromControl(hDlg, IDC_EDIT1, pListEntry->szName, MAX_PATH, TRUE); // bDisplayError == TRUE

                    if (-1 == nResult)
                    {
                        //
                        //  If we read in a string we cannot convert from the cms file and then the user editted the entry
                        //  then the edit control may contain "bad" data but the user won't be able to edit it.  Since this
                        //  is extremely unlikely we won't add special handling for it other than to prevent the focus from
                        //  being set to a disabled control.
                        //
                        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_EDIT1)))
                        {
                            SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                        }
                        
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }

                    //
                    //  Now, let's trim the name and make sure it isn't empty
                    //
                    CmStrTrim(pListEntry->szName);

                    if ((TEXT('\0') == pListEntry->szName[0]) || (0 == nResult))
                    {
                        ShowMessage(hDlg, IDS_NEED_DUN_NAME, MB_OK);
                        
                        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_EDIT1)))
                        {
                            SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                        }

                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;                    
                    }

                    //
                    //  Get the values for the Secure local files and the network logon checkboxes
                    //
                    pDunSetting->bSecureLocalFiles = IsDlgButtonChecked(hDlg, IDC_CHECK1);
                    pDunSetting->bNetworkLogon = IsDlgButtonChecked(hDlg, IDC_CHECK2);

                    //
                    //  Get and verify the script
                    //
                    if (FALSE == pDunSetting->bTunnelDunSetting)
                    {
                        if (!VerifyFile(hDlg, IDC_EDIT2, pDunSetting->szScript, TRUE))
                        {
                            SetFocus(GetDlgItem(hDlg, IDC_EDIT2));
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                            return TRUE;
                        }
                    }
                    break;
                }
            }

            break;
        default:
            return FALSE;
    }
    return FALSE;   
}

//+----------------------------------------------------------------------------
//
// Function:  SecurityPropSheetProc
//
// Synopsis:  This function processes messages for Security property sheet of
//            the DUN settings UI.  This property sheet holds UI for configuring
//            how the user wants their security settings applied.
//
// Arguments: HWND hDlg - window handle to the dialog
//            UINT message - the current message to process
//            WPARAM wParam - wParam see individual message type for details
//            LPARAM lParam - lParam see individual message type for details
//
// Returns:   INT_PTR - TRUE if the message was completely handled
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY SecurityPropSheetProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR* pnmHeader = (NMHDR*)lParam;
    INT_PTR nResult;
    DWORD_PTR HelpId;
    static ListBxList* pListEntry = NULL;
    static CDunSetting* pDunSetting = NULL;

    SetDefaultGUIFont(hDlg, message, IDC_COMBO1);

    HelpId = ((pDunSetting && pDunSetting->bTunnelDunSetting) ? IDH_VENTRY : IDH_DENTRY);
    if (ProcessHelp(hDlg, message, wParam, lParam, HelpId)) return TRUE;

    switch (message)
    {
        case WM_INITDIALOG:
            if (lParam)
            {
                PROPSHEETPAGE* pPropSheetPage = (PROPSHEETPAGE*)lParam;

                if (pPropSheetPage->lParam)
                {
                    pListEntry = (ListBxList*)pPropSheetPage->lParam;
                    pDunSetting = (CDunSetting*)pListEntry->ListBxData;

                    if (pListEntry && pDunSetting) // this will give a big visual clue that something is wrong
                    {
                        //
                        //  Load and set the strings for the combo box
                        //
                        LPTSTR pszString;

                        for (int i = BASE_SECURITY_SCENARIO_ID; i < (BASE_SECURITY_SCENARIO_ID + NUM_SECURITY_SCENARIOS); i++)
                        {
                            pszString = CmLoadString(g_hInstance, i);
                            MYDBGASSERT(pszString);

                            if (pszString)
                            {
                                SendDlgItemMessage(hDlg, IDC_COMBO1, CB_ADDSTRING, 0, (LPARAM)pszString);
                                CmFree(pszString);
                            }
                        }

                        //
                        //  Now figure out which selection to pick
                        //
                        MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, IDC_COMBO1, CB_SETCURSEL, (WPARAM)(pDunSetting->iHowToHandleSecuritySettings), (LPARAM)0));

                        EnableDisableSecurityButtons(hDlg);

                        if (pDunSetting && pDunSetting->bTunnelDunSetting)
                        {
                            //
                            //  If this profile is NOT using a pre-shared key, set certs as the default
                            //
                            int iDlgId = IDC_USE_CERT;
                            if (pDunSetting->bUsePresharedKey)
                            {
                                iDlgId = IDC_USE_PRESHARED_KEY;
                            }
                            MYVERIFY(0 != CheckRadioButton(hDlg, IDC_USE_CERT, IDC_USE_PRESHARED_KEY, iDlgId));
                        }
                        else
                        {
                            //
                            //  If this is NOT a VPN DUN setting, hide the cert/presharedkey controls
                            //
                            ShowWindow(GetDlgItem(hDlg, IDC_CERT_PSK_GROUPBOX), SW_HIDE);
                            ShowWindow(GetDlgItem(hDlg, IDC_USE_CERT), SW_HIDE);
                            ShowWindow(GetDlgItem(hDlg, IDC_USE_PRESHARED_KEY), SW_HIDE);
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("SecurityPropSheetProc -- pListEntry or pDunSetting is NULL"));
                    }
                }
                else
                {
                    pListEntry = NULL;
                    pDunSetting = NULL;
                    CMASSERTMSG(FALSE, TEXT("SecurityPropSheetProc -- NULL lParam passed to InitDialog.  Dialog controls will all be set to off."));
                }
            }
            else
            {
                pListEntry = NULL;
                pDunSetting = NULL;
                CMASSERTMSG(FALSE, TEXT("SecurityPropSheetProc -- NULL PropSheetPage pointer passed for lParam."));
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_CONFIG_ALL:
                    nResult = DialogBoxParam(NULL, MAKEINTRESOURCE(IDD_DUN_SECURITY_POPUP), hDlg, ProcessSecurityPopup, (LPARAM)pDunSetting);

                    break;

                case IDC_CONFIG_WIN2K:
                    if (pDunSetting)
                    {                       
                        UINT uDialogId = pDunSetting->bTunnelDunSetting ? IDD_WIN2K_SECURITY_TUNNEL_POPUP: IDD_WIN2K_SECURITY_POPUP;
                        nResult = DialogBoxParam(NULL, MAKEINTRESOURCE(uDialogId), hDlg, ProcessWin2kSecurityPopup, (LPARAM)pDunSetting);
                    }
                    
                    break;

                case IDC_COMBO1: // how does the user want the security settings applied
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        EnableDisableSecurityButtons(hDlg);
                    }

                    break;
            }

            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {
                case PSN_APPLY:
                if (pListEntry && pDunSetting)
                {
                    //
                    //  Figure out if the Admin wanted us to enforce the Win2k custom security flags or not
                    //
                    pDunSetting->iHowToHandleSecuritySettings = (int)SendDlgItemMessage(hDlg, IDC_COMBO1, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);

                    if (0 != pDunSetting->iHowToHandleSecuritySettings)
                    {
                        pDunSetting->bUsePresharedKey = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_USE_PRESHARED_KEY));
                    }

                    break;
                }
            }

            break;
        default:
            return FALSE;
    }
    return FALSE;   
}

//+----------------------------------------------------------------------------
//
// Function:  CreateNetworkingEntryPropertySheet
//
// Synopsis:  This function creates and launches the Networking DUN entry
//            property sheet which allows networking entry configuration.
//
// Arguments: HINSTANCE hInstance - instance handle for resources
//            HWND hWizard - window handle of the current CMAK wizard page
//            LPARAM lParam - initialization parameter passed to each propsheet page
//            BOOL bEdit - whether we are launching the property sheet to edit
//                         an existing entry or add a new one (affects the title).
//
// Returns:   int - returns a positive value if successful, -1 on error
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
INT_PTR CreateNetworkingEntryPropertySheet(HINSTANCE hInstance, HWND hWizard, LPARAM lParam, BOOL bEdit, BOOL bUseVpnTitle)
{

    PROPSHEETPAGE psp[3]; 
    PROPSHEETHEADER psh = {0};
    LPTSTR pszCaption = NULL;
    INT_PTR iReturn = -1;
    UINT uTitleStringId;

    //
    //  Check the params, note that lParam could be NULL
    //
    if ((NULL == hInstance) || (NULL == hWizard))
    {
        CMASSERTMSG(FALSE, TEXT("CreateNetworkingEntryPropertySheet -- Invalid Parameter passed."));
        goto exit;
    }

    //
    //  Fill in the property page structures
    //

    for (int i = 0; i < 3; i++)
    {
        psp[i].dwSize = sizeof(psp[0]);
        psp[i].dwFlags = PSP_HASHELP;
        psp[i].hInstance = hInstance;
        psp[i].lParam = lParam;
    }

    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_GENERAL);
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_TCPIP_SETTINGS);
    psp[2].pszTemplate = MAKEINTRESOURCE(IDD_SECURITY);
    psp[0].pfnDlgProc = GeneralPropSheetProc;
    psp[1].pfnDlgProc = TcpIpPropSheetProc;
    psp[2].pfnDlgProc = SecurityPropSheetProc;

    //
    //  Load the caption
    //

    uTitleStringId = bUseVpnTitle ? BASE_VPN_ENTRY_TITLE : BASE_DUN_ENTRY_TITLE;

    if (bEdit)
    {
        uTitleStringId = uTitleStringId + EDIT_INCREMENT;
    }
    else
    {
        uTitleStringId = uTitleStringId + NEW_INCREMENT;
    }

    pszCaption = CmLoadString(hInstance, uTitleStringId);

    if (NULL == pszCaption)
    {
        CMASSERTMSG(FALSE, TEXT("CreateNetworkingEntryPropertySheet -- CmLoadString failed trying to load the prop sheet title."));
        goto exit;
    }

    //
    //  Fill in the property sheet header
    //
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_HASHELP | PSH_NOCONTEXTHELP;
    psh.hwndParent = hWizard;
    psh.pszCaption = pszCaption;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    //
    //  Launch the property sheet
    //
    iReturn = PropertySheet(&psh);

    if (-1 == iReturn)
    {
        CMTRACE1(TEXT("CreateNetworkingEntryPropertySheet -- PropertySheet called failed, GLE %d"), GetLastError());
    }

exit:

    CmFree(pszCaption);

    return iReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  OnProcessDunEntriesAdd
//
// Synopsis:  This function is called when the Add button on the DUN entries
//            page is pressed.  It's job is to create a new CDunSetting
//            structure and a new ListBox record and then launch the networking
//            entries property page with this newly created DUN entry.  If the
//            user hits OK on the property sheet then this newly created entry
//            is added to the DUN entry linked list.  If the user hits cancel
//            the entry is freed and never added to the list.
//
// Arguments: HINSTANCE hInstance - instance handle to load resources
//            HWND hDlg - window handle of the DUN entries wizard page
//            UINT uListCtrlId - control ID of the list containing the DUN entries
//            ListBxStruct** pHeadDns - head of the dun entry list
//            ListBxStruct** pTailDns - tail of the dun entry list
//            BOOL bCreateTunnelEntry - whether we are adding a tunnel entry or not
//            LPCTSTR pszLongServiceName - the long service name of the profile
//            LPCTSTR pszCmsFile - CMS file to get the default/VPN DUN entry names from
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void OnProcessDunEntriesAdd(HINSTANCE hInstance, HWND hDlg, UINT uListCtrlId, ListBxStruct** pHeadDns, ListBxStruct** pTailDns, 
                            BOOL bCreateTunnelEntry, LPCTSTR pszLongServiceName, LPCTSTR pszCmsFile)
{
    //
    //  Check the input params, make sure that *pHeadDns / *pTailDns are both NULL or both non-NULL
    //
    if (hInstance && hDlg && pHeadDns && pTailDns && (FALSE == ((NULL == *pHeadDns) ^ (NULL == *pTailDns))))
    {
        //
        //  We want to create an empty ListBxStruct and an new CDunSetting.  This keeps all of the initialization
        //  logic in the CDunSetting constructor and keeps the dialog procedures very simple.
        //
        ListBxStruct* pLinkedListItem = (ListBxStruct*)CmMalloc(sizeof(ListBxStruct));
        CDunSetting* pDunSetting = new CDunSetting(bCreateTunnelEntry);
        INT_PTR iPropSheetReturnValue = -1;

        if ((NULL == pDunSetting) || (NULL == pLinkedListItem))
        {
            CMASSERTMSG(FALSE, TEXT("OnProcessDunEntriesAdd -- CmMalloc and/or new failed."));
            CmFree(pDunSetting);
            CmFree(pLinkedListItem);
            return;
        }

        //
        //  Now call the property sheet
        //
        BOOL bExitLoop = FALSE;

        do
        {
            pLinkedListItem->ListBxData = (void*)pDunSetting;
            iPropSheetReturnValue = CreateNetworkingEntryPropertySheet(hInstance, hDlg, (LPARAM)pLinkedListItem, FALSE, pDunSetting->bTunnelDunSetting); // bEdit == FALSE

            if (IDOK == iPropSheetReturnValue)
            {
                //
                //  Search the list to make sure that the user didn't give us the name of an existing
                //  DUN entry.  If they did, then we should prompt them for overwrite.
                //
                ListBxStruct* pCurrent = *pHeadDns;

                while (pCurrent)
                {
                    if (0 == lstrcmpi(pCurrent->szName, pLinkedListItem->szName))
                    {
                        //
                        //  Then we have a dup, lets prompt the user
                        //
                        LPTSTR pszMsg = CmFmtMsg(hInstance, IDS_DUN_NAME_EXISTS, pLinkedListItem->szName);

                        //
                        //  Make sure to blank out the name.  Two things can happen here.  Either, the name
                        //  wasn't what the user wanted and they want to change it.  In that case, we blank the
                        //  name so that when the dialog comes back up to edit, we won't gray out the name control
                        //  as we normally do for an edit.  Since the name was invalid this is an additional clue
                        //  to the user as to what was wrong.  If the name was valid and the user means to do a rename,
                        //  then we are going to free pLinkedListItem anyway and blanking the name means nothing.  However,
                        //  if we fail to allocate pszMsg, then blanking the name will at least allow the dialog to come back
                        //  up with a edittable name and the user may be able to fix the problem ... unlikely 
                        //  if mem allocs are failing but better than leaving the user truly hosed.
                        //
                        pLinkedListItem->szName[0] = TEXT('\0');                                


                        if (pszMsg)
                        {
                            int iResult = MessageBox(hDlg, pszMsg, g_szAppTitle, MB_YESNO);
                            CmFree(pszMsg);

                            //
                            //  If the user said yes, lets replace the existing entry and get out of here, otherwise
                            //  we want to loop again.
                            //
                            if (IDYES == iResult)
                            {
                                CDunSetting* pOldDunSetting = (CDunSetting*)pCurrent->ListBxData;
                                delete pOldDunSetting;

                                pCurrent->ListBxData = pDunSetting;
                                CmFree(pLinkedListItem);                                
                                
                                RefreshDnsList(hInstance, hDlg, uListCtrlId, *pHeadDns, pszLongServiceName, pszCmsFile, pCurrent->szName);
                                bExitLoop = TRUE;
                            }

                            break;
                        }
                    }

                    pCurrent = pCurrent->next;
                }

                //
                //  If we didn't find a duplicate, then add the item to the list as usual,
                //  making sure that pLinkedListItem->next is NULL so that the list is terminated.
                //
                if (NULL == pCurrent)
                {
                    pLinkedListItem->next = NULL;   // make sure our list is terminated

                    if (*pHeadDns)
                    {
                        (*pTailDns)->next = pLinkedListItem;
                    }
                    else
                    {
                        *pHeadDns = pLinkedListItem;
                    }

                    *pTailDns = pLinkedListItem;

                    RefreshDnsList(hInstance, hDlg, uListCtrlId, *pHeadDns, pszLongServiceName, pszCmsFile, pLinkedListItem->szName);
                    bExitLoop = TRUE;
                }
            }
            else
            {
                bExitLoop = TRUE;
                CmFree(pLinkedListItem);
                delete pDunSetting;
            }

        } while (!bExitLoop);
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("OnProcessDunEntriesAdd -- Invalid parameter passed."));
    }
}

//+----------------------------------------------------------------------------
//
// Function:  OnProcessDunEntriesEdit
//
// Synopsis:  This function is called when the Edit button on the DUN entries
//            page is pressed.  It's job is to find the ListBox and CDunSetting
//            structures for the item currently selected in the listbox and then
//            launch the networking entries property page with this DUN entry.
//            The property sheet itself takes care of only changing the Dun Entry
//            if Okay is pressed.  Canceling should leave the entry unchanged.
//
// Arguments: HINSTANCE hInstance - instance handle to load resources
//            HWND hDlg - window handle of the DUN entries wizard page
//            UINT uListCtrlId - control ID of the list containing the DUN entries
//            ListBxStruct** pHeadDns - head of the dun entry list
//            ListBxStruct** pTailDns - tail of the dun entry list
//            LPCTSTR pszLongServiceName - the long service name of the profile
//            LPCTSTR pszCmsFile - CMS file to get the default/VPN DUN entry names from
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void OnProcessDunEntriesEdit(HINSTANCE hInstance, HWND hDlg, UINT uListCtrlId, ListBxStruct** pHeadDns, 
                             ListBxStruct** pTailDns, LPCTSTR pszLongServiceName, LPCTSTR pszCmsFile)
{
    LPTSTR pszTunnelDunDisplayString = NULL;
    LPTSTR pszDefaultDunDisplayString = NULL;
    TCHAR szTunnelDunName[MAX_PATH+1] = TEXT("");
    TCHAR szDefaultDunName[MAX_PATH+1] = TEXT("");
    LPTSTR pszNameOfItemToEdit = NULL;

    //
    //  Check the input params, make sure that *pHeadDns / *pTailDns are both NULL or both non-NULL
    //

    if (hInstance && hDlg && pHeadDns && pTailDns && (FALSE == ((NULL == *pHeadDns) ^ (NULL == *pTailDns))))
    {
        INT_PTR iPropSheetReturnValue = -1;
        TCHAR szNameOfItemToEdit[MAX_PATH+1];
        ListBxStruct* pItemToEdit = NULL;

        //
        //  Lets get the current selection from the listbox
        //
        INT_PTR nResult = SendDlgItemMessage(hDlg, uListCtrlId, LB_GETCURSEL, 0, (LPARAM)0);

        if (LB_ERR == nResult)
        {
            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOSELECTION, MB_OK));
        }
        else
        {        
            if (LB_ERR != SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETTEXT, (WPARAM)nResult, (LPARAM)szNameOfItemToEdit))
            {
                //
                //  Get the name of the Tunnel Dun setting
                //
                MYVERIFY(0 != GetTunnelDunSettingName(pszCmsFile, pszLongServiceName, szTunnelDunName, CELEMS(szTunnelDunName)));

                //
                //  Get the name of the default Dun setting
                //
                MYVERIFY(0 != GetDefaultDunSettingName(pszCmsFile, pszLongServiceName, szDefaultDunName, CELEMS(szDefaultDunName)));

                //
                //  If we have the default DUN entry text or the default VPN entry text then we want
                //  to use the real item names for these instead of the text we inserted for
                //  the user to read.
                //
                pszTunnelDunDisplayString = CmFmtMsg(hInstance, IDS_DEFAULT_FMT_STR, szTunnelDunName);
                pszDefaultDunDisplayString = CmFmtMsg(hInstance, IDS_DEFAULT_FMT_STR, szDefaultDunName);

                MYDBGASSERT(pszTunnelDunDisplayString && pszDefaultDunDisplayString);

                if (pszTunnelDunDisplayString && pszDefaultDunDisplayString)
                {
                    if (0 == lstrcmpi(pszTunnelDunDisplayString, szNameOfItemToEdit))
                    {
                        pszNameOfItemToEdit = szTunnelDunName;
                    }
                    else if (0 == lstrcmpi(pszDefaultDunDisplayString, szNameOfItemToEdit))
                    {
                        pszNameOfItemToEdit = szDefaultDunName;
                    }
                    else
                    {
                        pszNameOfItemToEdit = szNameOfItemToEdit;
                    }

                    //
                    //  Now find the entry in the list
                    //
                    if (FindListItemByName(pszNameOfItemToEdit, *pHeadDns, &pItemToEdit))
                    {
                        //
                        //  Finally call the property sheet
                        //

                        CDunSetting* pDunSetting = ((CDunSetting*)(pItemToEdit->ListBxData));
                        BOOL bTunnelSetting = FALSE;

                        if (pDunSetting)
                        {
                            bTunnelSetting = pDunSetting->bTunnelDunSetting;
                        }

                        iPropSheetReturnValue = CreateNetworkingEntryPropertySheet(hInstance, hDlg, (LPARAM)pItemToEdit, TRUE, bTunnelSetting); // bEdit == TRUE

                        if (IDOK == iPropSheetReturnValue)
                        {
                            RefreshDnsList(hInstance, hDlg, uListCtrlId, *pHeadDns, pszLongServiceName, pszCmsFile, pItemToEdit->szName);
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("OnProcessDunEntriesEdit -- FindListItemByName couldn't find the item in the list."));            
                    }
                }
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("OnProcessDunEntriesEdit -- LB_GETTEXT returned an error."));           
            }
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("OnProcessDunEntriesEdit -- Invalid parameter passed."));
    }

    CmFree(pszDefaultDunDisplayString);
    CmFree(pszTunnelDunDisplayString);
}

//+----------------------------------------------------------------------------
//
// Function:  OnProcessDunEntriesDelete
//
// Synopsis:  This function is called when the Delete button on the DUN entries
//            page is pressed.  It's job is to find the ListBox and CDunSetting
//            structures for the item currently selected in the listbox and then
//            remove this item from the DUN entries linked list.
//
// Arguments: HINSTANCE hInstance - instance handle to load resources
//            HWND hDlg - window handle of the DUN entries wizard page
//            UINT uListCtrlId - control ID of the list containing the DUN entries
//            ListBxStruct** pHeadDns - head of the dun entry list
//            ListBxStruct** pTailDns - tail of the dun entry list
//            LPCTSTR pszLongServiceName - the long service name of the profile
//            LPCTSTR pszCmsFile - CMS file to get the default/VPN DUN entry names from
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void OnProcessDunEntriesDelete(HINSTANCE hInstance, HWND hDlg, UINT uListCtrlId, ListBxStruct** pHeadDns, 
                               ListBxStruct** pTailDns, LPCTSTR pszLongServiceName, LPCTSTR pszCmsFile)
{
    //
    //  Check the input params, make sure that *pHeadDns / *pTailDns are both NULL or both non-NULL
    //
    if (hInstance && hDlg && pHeadDns && pTailDns && (FALSE == ((NULL == *pHeadDns) ^ (NULL == *pTailDns))))
    {
        TCHAR szNameOfItemToDelete[MAX_PATH+1];

        //
        //  Lets get the current selection from the listbox
        //
        INT_PTR nResult = SendDlgItemMessage(hDlg, uListCtrlId, LB_GETCURSEL, 0, (LPARAM)0);

        if (LB_ERR == nResult)
        {
            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOSELECTION, MB_OK));
        }
        else
        {
            if (LB_ERR != SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETTEXT, (WPARAM)nResult, (LPARAM)szNameOfItemToDelete))
            {
                //
                //  Now find the entry in the list
                //
                ListBxStruct* pCurrent = *pHeadDns;
                ListBxStruct* pFollower = NULL;

                while (pCurrent)
                {
                    if (0 == lstrcmpi(szNameOfItemToDelete, pCurrent->szName))
                    {
                        //
                        //  We found the item to delete
                        //
                        if (pFollower)
                        {
                            pFollower->next = pCurrent->next;
                            CDunSetting* pDunSetting = (CDunSetting*)pCurrent->ListBxData;
                            CmFree(pDunSetting);
                            CmFree(pCurrent);
                            

                            //
                            //  We want to continue to the end of the list so that
                            //  we can set the tail pointer appropriately.  Thus
                            //  leave pFollower on the item it was on and update
                            //  pCurrent to the next item in the list, if it is NULL
                            //  then we will stop here.
                            //
                            pCurrent = pFollower->next;
                        }
                        else
                        {
                            //
                            //  It is the first item in the list
                            //
                            *pHeadDns = (*pHeadDns)->next;
                            CDunSetting* pDunSetting = (CDunSetting*)pCurrent->ListBxData;
                            CmFree(pDunSetting);
                            CmFree(pCurrent);

                            //
                            //  We want to go to the end of the list to find the tail pointer
                            //  so reset pCurrent to the beginning of the list.
                            //
                            pCurrent = *pHeadDns;
                        }

                        //
                        //  Don't forget to delete it from the CMS file itself
                        //
                        EraseNetworkingSections(szNameOfItemToDelete, pszCmsFile);

                        //
                        //  Refresh the Dns list
                        //
                        RefreshDnsList(hInstance, hDlg, uListCtrlId, *pHeadDns, pszLongServiceName, pszCmsFile, NULL);                        
                    }
                    else
                    {
                        pFollower = pCurrent;
                        pCurrent = pCurrent->next;                    
                    }
                }

                //
                //  Reset the tail pointer to the last item in the list
                //
                *pTailDns = pFollower;
            }
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("OnProcessDunEntriesDelete -- Invalid parameter passed."));
    }
}

//+----------------------------------------------------------------------------
//
// Function:  EnableDisableIpAddressControls
//
// Synopsis:  This function enables or disables the IP address controls for
//            the static IP address and for the Wins and DNS server addresses
//            depending on the state of the enable/disable radio buttons.
//
// Arguments: HWND hDlg - window handle of the TCP/IP settings dialog
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void EnableDisableIpAddressControls(HWND hDlg)
{
    //
    //  Next Enable/Disable the Wins and DNS address controls
    //
    BOOL bCheckedState = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO2));

    EnableWindow(GetDlgItem(hDlg, IDC_PRIMARY_DNS), bCheckedState);
    EnableWindow(GetDlgItem(hDlg, IDC_LABEL_DNS), bCheckedState);

    EnableWindow(GetDlgItem(hDlg, IDC_SECONDARY_DNS), bCheckedState);
    EnableWindow(GetDlgItem(hDlg, IDC_LABEL_DNS2), bCheckedState);

    EnableWindow(GetDlgItem(hDlg, IDC_PRIMARY_WINS), bCheckedState);
    EnableWindow(GetDlgItem(hDlg, IDC_LABEL_WINS), bCheckedState);

    EnableWindow(GetDlgItem(hDlg, IDC_SECONDARY_WINS), bCheckedState);
    EnableWindow(GetDlgItem(hDlg, IDC_LABEL_WINS2), bCheckedState);
}

//+----------------------------------------------------------------------------
//
// Function:  TcpIpPropSheetProc
//
// Synopsis:  This function processes messages for TCP/IP Settings property sheet.
//
// Arguments: HWND hDlg - window handle to the dialog
//            UINT message - the current message to process
//            WPARAM wParam - wParam see individual message type for details
//            LPARAM lParam - lParam see individual message type for details
//
// Returns:   INT_PTR - TRUE if the message was completely handled
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY TcpIpPropSheetProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR* pnmHeader = (NMHDR*)lParam;
    DWORD_PTR HelpId;
    static ListBxList* pListEntry = NULL;
    static CDunSetting* pDunSetting = NULL;

    HelpId = ((pDunSetting && pDunSetting->bTunnelDunSetting) ? IDH_VENTRY : IDH_DENTRY);
    if (ProcessHelp(hDlg, message, wParam, lParam, HelpId)) return TRUE;
    
    switch (message)
    {
        case WM_INITDIALOG:

            if (lParam)
            {
                PROPSHEETPAGE* pPropSheetPage = (PROPSHEETPAGE*)lParam;

                if (pPropSheetPage->lParam)
                {
                    pListEntry = (ListBxList*)pPropSheetPage->lParam;
                    pDunSetting = (CDunSetting*)pListEntry->ListBxData;

                    UINT uCrtlToSet;

                    if (pListEntry && pDunSetting)
                    {
                        //
                        //  Init the WINS and DNS IP address controls and the radio buttons specifying
                        //  whether the user chose to give us addresses or not.
                        //
                        if (pDunSetting->dwPrimaryDns || pDunSetting->dwSecondaryDns || pDunSetting->dwPrimaryWins || pDunSetting->dwSecondaryWins)
                        {
                            uCrtlToSet = IDC_RADIO2;
                            SendDlgItemMessage(hDlg, IDC_PRIMARY_DNS, IPM_SETADDRESS, (WPARAM)0, (LPARAM)(pDunSetting->dwPrimaryDns));
                            SendDlgItemMessage(hDlg, IDC_SECONDARY_DNS, IPM_SETADDRESS, (WPARAM)0, (LPARAM)(pDunSetting->dwSecondaryDns));
                            SendDlgItemMessage(hDlg, IDC_PRIMARY_WINS, IPM_SETADDRESS, (WPARAM)0, (LPARAM)(pDunSetting->dwPrimaryWins));
                            SendDlgItemMessage(hDlg, IDC_SECONDARY_WINS, IPM_SETADDRESS, (WPARAM)0, (LPARAM)(pDunSetting->dwSecondaryWins));
                        }
                        else
                        {
                            uCrtlToSet = IDC_RADIO1;
                            SendDlgItemMessage(hDlg, IDC_PRIMARY_DNS, IPM_CLEARADDRESS, (WPARAM)0, (LPARAM)0);
                            SendDlgItemMessage(hDlg, IDC_SECONDARY_DNS, IPM_CLEARADDRESS, (WPARAM)0, (LPARAM)0);
                            SendDlgItemMessage(hDlg, IDC_PRIMARY_WINS, IPM_CLEARADDRESS, (WPARAM)0, (LPARAM)0);
                            SendDlgItemMessage(hDlg, IDC_SECONDARY_WINS, IPM_CLEARADDRESS, (WPARAM)0, (LPARAM)0);
                        }

                        MYVERIFY(0 != CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, uCrtlToSet));

                        //
                        //  Finally set the checkboxes for IP header compression and whether to use
                        //  the remote gateway or not.
                        //
                        MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK1, pDunSetting->bGatewayOnRemote));
                        MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK2, pDunSetting->bIpHeaderCompression));

                        EnableDisableIpAddressControls(hDlg);
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("TcpIpPropSheetProc -- pListEntry or pDunSetting are NULL"));
                    }
                }
                else
                {
                    pListEntry = NULL;
                    pDunSetting = NULL;
                    CMASSERTMSG(FALSE, TEXT("TcpIpPropSheetProc -- NULL lParam passed to InitDialog.  Dialog controls will all be set to off."));
                }
            }
            else
            {
                pListEntry = NULL;
                pDunSetting = NULL;
                CMASSERTMSG(FALSE, TEXT("TcpIpPropSheetProc -- NULL PropSheetPage pointer passed for lParam."));
            }

            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {
                case PSN_APPLY:
                    if (pListEntry && pDunSetting)
                    {
                        //
                        //  Okay, lets read in the settings and save them to the passed
                        //  in CDunSetting pointer.
                        //
                        if (IsDlgButtonChecked(hDlg, IDC_RADIO2))
                        {
                            SendDlgItemMessage(hDlg, IDC_PRIMARY_DNS, IPM_GETADDRESS, (WPARAM)0, (LPARAM)&(pDunSetting->dwPrimaryDns));
                            SendDlgItemMessage(hDlg, IDC_SECONDARY_DNS, IPM_GETADDRESS, (WPARAM)0, (LPARAM)&(pDunSetting->dwSecondaryDns));
                            SendDlgItemMessage(hDlg, IDC_PRIMARY_WINS, IPM_GETADDRESS, (WPARAM)0, (LPARAM)&(pDunSetting->dwPrimaryWins));
                            SendDlgItemMessage(hDlg, IDC_SECONDARY_WINS, IPM_GETADDRESS, (WPARAM)0, (LPARAM)&(pDunSetting->dwSecondaryWins));
                        }
                        else
                        {
                            pDunSetting->dwPrimaryDns = 0;
                            pDunSetting->dwSecondaryDns = 0;
                            pDunSetting->dwPrimaryWins = 0;
                            pDunSetting->dwSecondaryWins = 0;
                        }

                        pDunSetting->bGatewayOnRemote = IsDlgButtonChecked(hDlg, IDC_CHECK1);
                        pDunSetting->bIpHeaderCompression = IsDlgButtonChecked(hDlg, IDC_CHECK2);

                    }
                    break;
                default:
                    break;
            }

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_RADIO1:
                case IDC_RADIO2:
                    EnableDisableIpAddressControls(hDlg);
                    break;

                default:
                    break;
            }
            break;

        default:
            return FALSE;
    }
    return FALSE;   
}   //lint !e715 we don't reference lParam

//+----------------------------------------------------------------------------
//
// Function:  RefreshDnsList
//
// Synopsis:  This function clears the contents of the listbox specified by
//            hDlg and uCrtlId.  Then it adds each of the items in the DUN
//            entries linked list specified by pHead to the listbox.  The
//            passed in CMS file is used to figure out which entries to special
//            with the default entry and VPN entry text.
//
// Arguments: HINSTANCE hInstance - instance handle for loading resources
//            HWND hDlg - window handle for the DUN entries dialog
//            UINT uCtrlId - control ID of the Listbox to write the entries to
//            ListBxList * pHead - head of the linked list of DUN entries
//            LPCTSTR pszLongServiceName - long service name of the profile
//            LPCTSTR pszCmsFile - CMS file to get the DUN and TunnelDUN entries from
//            LPTSTR pszItemToSelect - Item in the list to select after the refresh, 
//                                     NULL chooses the first in the list
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void RefreshDnsList(HINSTANCE hInstance, HWND hDlg, UINT uCtrlId, ListBxList * pHead,
                    LPCTSTR pszLongServiceName, LPCTSTR pszCmsFile, LPTSTR pszItemToSelect)
{
    if (hDlg && pHead)
    {    
        TCHAR szTunnelSettingName[MAX_PATH+1] = TEXT("");
        TCHAR szDefaultSettingName[MAX_PATH+1] = TEXT("");

        //
        //  Get the name of the Tunnel Dun setting
        //
        MYVERIFY(0 != GetTunnelDunSettingName(pszCmsFile, pszLongServiceName, szTunnelSettingName, CELEMS(szTunnelSettingName)));

        //
        //  Get the name of the default Dun setting
        //
        MYVERIFY(0 != GetDefaultDunSettingName(pszCmsFile, pszLongServiceName, szDefaultSettingName, CELEMS(szDefaultSettingName)));

        //
        //  Reset the listbox contents
        //
        SendDlgItemMessage(hDlg, uCtrlId, LB_RESETCONTENT, 0, (LPARAM)0); //lint !e534 LB_RESETCONTENT doesn't return anything
        
        //
        //  Now loop through the Network settings, adding them to the listbox
        //
        ListBxList * pCurrent = pHead;
        LPTSTR pszDisplayString;
        BOOL bFreeString;
    
        while(pCurrent)
        {
            if (0 == lstrcmpi(szTunnelSettingName, pCurrent->szName))
            {
                pszDisplayString = CmFmtMsg(hInstance, IDS_DEFAULT_FMT_STR, pCurrent->szName);
                MYDBGASSERT(pszDisplayString);
                bFreeString = TRUE;
            }
            else if (0 == lstrcmpi(szDefaultSettingName, pCurrent->szName))
            {
                pszDisplayString = CmFmtMsg(hInstance, IDS_DEFAULT_FMT_STR, pCurrent->szName);
                MYDBGASSERT(pszDisplayString);
                bFreeString = TRUE;
            }
            else
            {
                pszDisplayString = pCurrent->szName;
                bFreeString = FALSE;
            }

            if (pszDisplayString)
            {
                MYVERIFY(LB_ERR != SendDlgItemMessage(hDlg, uCtrlId, LB_ADDSTRING, 0, (LPARAM)pszDisplayString));

                if (bFreeString)
                {
                    CmFree(pszDisplayString);
                }
            }

            pCurrent = pCurrent->next;
        }

        //
        //  Now Select the requested item in the list.  If the requested name is NULL, just select the
        //  first item in the list.
        //
        LRESULT lResult = 0;

        if (pszItemToSelect)
        {
            LPTSTR pszSearchString;

            if (0 == lstrcmpi(szTunnelSettingName, pszItemToSelect))
            {
                pszSearchString = CmFmtMsg(hInstance, IDS_DEFAULT_FMT_STR, pszItemToSelect);
            }
            else if (0 == lstrcmpi(szDefaultSettingName, pszItemToSelect))
            {
                pszSearchString = CmFmtMsg(hInstance, IDS_DEFAULT_FMT_STR, pszItemToSelect);
            }
            else
            {
                pszSearchString = CmStrCpyAlloc(pszItemToSelect);
            }

            if (pszSearchString)
            {
                lResult = SendDlgItemMessage(hDlg, uCtrlId, LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pszSearchString);

                if (LB_ERR == lResult)
                {
                    lResult = 0;
                }

                CmFree(pszSearchString);
            }
        }
        
        SendDlgItemMessage(hDlg, uCtrlId, LB_SETCURSEL, (WPARAM)lResult, (LPARAM)0); // don't assert we may not have any items
        EnableDisableDunEntryButtons(hInstance, hDlg, pszCmsFile, pszLongServiceName);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  SelectAppropriateEAP
//
// Synopsis:  This functions walks through the list of EAPData structures held
//            by the item data pointers of the EAP names in the combobox specified
//            by hDlg and uCtrlId.  For each EAPData structure it compares
//            the dwCustomAuthKey field with that of the pDunSetting->dwCustomAuthKey.
//            When it finds a match it selects that item in the list.  Note there
//            is a special case for pDunSetting->dwCustomAuthKey == 0, in that
//            since the dun setting doesn't specify and EAP we pick the first
//            one in the list.  If the EAP specified in pDunSetting isn't found
//            then nothing is selected.  However, this should never happen because
//            if the profile specifies an EAP type not found on the machine it will
//            add a special entry for it.
//
// Arguments: HWND hDlg - window handle of the win2k security dialog
//            UINT uCtrlId - control ID of the combo containing the EAP types
//            CDunSetting* pDunSetting - dun setting for which to locate the EAP
//                                       for, contains the dwCustomAuthKey to try
//                                       to match.
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void SelectAppropriateEAP(HWND hDlg, UINT uCtrlId, CDunSetting* pDunSetting)
{
    MYDBGASSERT(hDlg && uCtrlId && pDunSetting);

    if (hDlg && uCtrlId && pDunSetting)
    {
        WPARAM wpIndex = 0;
        INT_PTR nResult;
        BOOL bEapSelected = FALSE;

        if (0 == pDunSetting->dwCustomAuthKey)
        {
            //
            //  Select the first EAP in the list
            //
            SendDlgItemMessage(hDlg, uCtrlId, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);
        }
        else
        {
            do
            {
                nResult = SendDlgItemMessage(hDlg, uCtrlId, CB_GETITEMDATA, wpIndex, (LPARAM)0);

                if (CB_ERR != nResult)
                {
                    EAPData* pEapData = (EAPData*)nResult;

                    if (pEapData && (pEapData->dwCustomAuthKey == pDunSetting->dwCustomAuthKey))
                    {
                        SendDlgItemMessage(hDlg, uCtrlId, CB_SETCURSEL, wpIndex, (LPARAM)0);
                        bEapSelected = TRUE;
                        break;
                    }

                    wpIndex++;
                }

            } while (CB_ERR != nResult);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  FreeEapData
//
// Synopsis:  This functions walks through the list of EAPData structures held
//            by the item data pointers of the EAP names in the combobox specified
//            by hDlg and uCtrlId.  For each EAPData structure it releases the
//            memory held by the EAPData structure, including the pszFriendlyName,
//            the config dll path, and any custom auth data blobs that exist.
//
// Arguments: HWND hDlg - window handle of the win2k security dialog
//            UINT uCtrlId - control ID of the combo containing the EAP types
//
// Returns:   Nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void FreeEapData(HWND hDlg, UINT uCtrlId)
{
    MYDBGASSERT(hDlg && uCtrlId);

    if (hDlg && uCtrlId)
    {
        WPARAM wpIndex = 0;
        INT_PTR nResult;
        EAPData* pEapData;
    
        do
        {
            nResult = SendDlgItemMessage(hDlg, uCtrlId, CB_GETITEMDATA, wpIndex, (LPARAM)0);

            if (CB_ERR != nResult)
            {
                pEapData = (EAPData*)nResult;

                if (pEapData)
                {
                    CmFree(pEapData->pszFriendlyName);
                    CmFree(pEapData->pszConfigDllPath);
                    CmFree(pEapData->pCustomAuthData);
                    CmFree(pEapData);
                }

                wpIndex++;
            }

        } while (CB_ERR != nResult);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  HrQueryRegStringWithAlloc
//
// Synopsis:  This functions retrieves the string value specified by hKey and
//            pszValueName.  Note that the function queries the value to find
//            out how much memory is needed to retrieve the data and then
//            allocates the correct amount and retrieves the data itself.  The
//            returned buffer must be freed by the caller.
//
// Arguments: HKEY hKey - open handle to the regkey to get the value from
//            LPCTSTR pszValueName - name of the value to retrieve data for
//            TCHAR** ppszReturnString - pointer to hold the allocated string
//                                       data retrieved from the registry value.
//
// Returns:   HRESULT - standard COM style return codes
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
HRESULT HrQueryRegStringWithAlloc(HKEY hKey, LPCTSTR pszValueName, TCHAR** ppszReturnString)
{
    if ((NULL == hKey) || (NULL == pszValueName) || (NULL == ppszReturnString) || (TEXT('\0') == pszValueName[0]))
    {
        CMASSERTMSG(FALSE, TEXT("HrQueryRegStringWithAlloc -- invalid parameter"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    DWORD dwType;
    DWORD dwSize = 2;
    TCHAR szTwo[2];
    LPTSTR pszTemp = NULL;

    LONG lReturn = RegQueryValueEx(hKey, pszValueName, NULL, &dwType, (LPBYTE)szTwo, &dwSize);

    if (ERROR_MORE_DATA == lReturn)
    {
        *ppszReturnString = (LPTSTR)CmMalloc(dwSize);

        if (*ppszReturnString)
        {
            lReturn = RegQueryValueEx(hKey, pszValueName, NULL, &dwType, (LPBYTE)*ppszReturnString, &dwSize);

            hr = HRESULT_FROM_WIN32(lReturn);

            if (SUCCEEDED(hr))
            {
                if (REG_EXPAND_SZ == dwType)
                {
                    DWORD dwExpandedSize = sizeof(TCHAR)*(ExpandEnvironmentStrings(*ppszReturnString, NULL, 0));

                    if (dwExpandedSize && (dwSize != dwExpandedSize))
                    {
                        pszTemp = *ppszReturnString;
                        *ppszReturnString = (LPTSTR)CmMalloc(dwExpandedSize);

                        if (*ppszReturnString)
                        {
                            ExpandEnvironmentStrings(pszTemp, *ppszReturnString, dwExpandedSize);
                        }
                        else
                        {
                            CMASSERTMSG(FALSE, TEXT("HrQueryRegStringWithAlloc -- CmMalloc returned a NULL pointer."));
                            hr = E_OUTOFMEMORY;
                        }

                        CmFree(pszTemp);
                    }
                }
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("HrQueryRegStringWithAlloc -- CmMalloc returned a NULL pointer."));
            hr = E_OUTOFMEMORY;        
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  HrAddAvailableEAPsToCombo
//
// Synopsis:  This functions enumerates the EAP types listed in the registry
//            and adds them to the EAP types combo.  For each type of EAP the
//            dwCustomAuthKey (numerical type of the EAP), the description string,
//            the configuration UI dll path, and whether configuration is
//            required is recorded in an EAPData structure and stored in the
//            item data pointer of the combobox item.  The passed in CDunSetting
//            structure is used for two purposes.  First this function checks to
//            make sure that the EAP of the type that is specified in the
//            CDunSetting structure is actually installed on the machine.  If it
//            isn't the user is presented with a warning message and the type is
//            added as "EAP Type %d <not installed>".  This is a choice in the UI
//            but the user is unable to configure it unless they install the EAP.
//            Also, if the EAP of the type specified in the CDunSetting is installed
//            then the dwCustomAuthData and dwCustomAuthDataSize elements of the
//            CDunSetting are copied over.  Thus maintains the simplicity of letting
//            the user configure any EAP they wish and then only picking up that
//            data in the DUN setting when they hit okay.  Thus allowing Cancel
//            to work as one would expect.
//
// Arguments: HWND hDlg - window handle to the win2k security dialog
//            UINT uCtrlId - EAP types combo box ID
//            CDunSetting* pDunSetting - DUN setting data that we are currently
//                                       adding/editing
//
// Returns:   HRESULT - standard COM style return codes
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
HRESULT HrAddAvailableEAPsToCombo(HWND hDlg, UINT uCtrlId, CDunSetting* pDunSetting)
{
    if ((NULL == hDlg) || (0 == uCtrlId) || (NULL == pDunSetting))
    {
        CMASSERTMSG(FALSE, TEXT("HrAddAvailableEAPsToCombo -- Invalid parameter passed."));
        return E_INVALIDARG;
    }
    

    HKEY hKey;
    HRESULT hr = S_OK;
    LONG lReturn;
    LPTSTR pszPath;
    BOOL bEapTypeFound = FALSE;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, RAS_EAP_REGISTRY_LOCATION, 0, KEY_READ, &hKey))
    {
        TCHAR szSubKeyName[MAX_PATH+1]; // the key names are numbers representing the type of EAP, thus MAX_PATH is probably overkill
        DWORD dwIndex = 0;
        HKEY hTempKey;

        do
        {
            lReturn = RegEnumKey(hKey, dwIndex, szSubKeyName, CELEMS(szSubKeyName));

            if (ERROR_SUCCESS == lReturn)
            {
                //
                //  We potentially have an EAP reg key.  Thus lets open a handle to this
                //  key and see if it has the values we are looking for.
                //
                if (ERROR_SUCCESS == RegOpenKeyEx(hKey, szSubKeyName, 0, KEY_READ, &hTempKey))
                {
                    //
                    //  Get the path value, if we don't have a path value then just ignore the entry and move on
                    //
                    hr = HrQueryRegStringWithAlloc(hTempKey, RAS_EAP_VALUENAME_PATH, &pszPath);

                    if (SUCCEEDED(hr))
                    {
                        //
                        //  Free the path, we don't really need to keep this value.
                        //
                        CmFree(pszPath);
                        EAPData* pEapData = (EAPData*)CmMalloc(sizeof(EAPData));

                        if (pEapData)
                        {
                            //
                            //  Now get the Friendly name of the EAP to add to the combobox
                            //
                            HrQueryRegStringWithAlloc(hTempKey, RAS_EAP_VALUENAME_FRIENDLY_NAME, &(pEapData->pszFriendlyName));
                        
                            //
                            //  Next check to see if we have configuration UI for this EAP, thus requiring we store the 
                            //
                            HrQueryRegStringWithAlloc(hTempKey, RAS_EAP_VALUENAME_CONFIGUI, &(pEapData->pszConfigDllPath));
                           
                            //
                            //  We also need to save the type value
                            //
                            pEapData->dwCustomAuthKey = _ttoi(szSubKeyName);

                            //
                            //  If the pDunSetting has pCustomAuthData and it is the same type as the current EAP we are
                            //  processing then we need to add the copy the EAP blob to the EAPData structure.
                            //
                            if (pDunSetting->dwCustomAuthKey == pEapData->dwCustomAuthKey)
                            {
                                if (pDunSetting->pCustomAuthData && pDunSetting->dwCustomAuthDataSize)
                                {
                                     pEapData->pCustomAuthData = (LPBYTE)CmMalloc(pDunSetting->dwCustomAuthDataSize);
                                     if (pEapData->pCustomAuthData)
                                     {
                                         pEapData->dwCustomAuthDataSize = pDunSetting->dwCustomAuthDataSize;
                                         CopyMemory(pEapData->pCustomAuthData, pDunSetting->pCustomAuthData, pEapData->dwCustomAuthDataSize);
                                     }
                                }
                                
                                bEapTypeFound = TRUE;
                            }

                            //
                            //  Get whether we must require configuration or not
                            //
                            DWORD dwType;
                            DWORD dwSize = sizeof(pEapData->bMustConfig);
                            
                            if (ERROR_SUCCESS != RegQueryValueEx(hTempKey, RAS_EAP_VALUENAME_REQUIRE_CONFIGUI, NULL, &dwType, (LPBYTE)&(pEapData->bMustConfig), &dwSize))
                            {
                                pEapData->bMustConfig = FALSE;
                            }

                            dwSize = sizeof(pEapData->bSupportsEncryption);
                            
                            if (ERROR_SUCCESS != RegQueryValueEx(hTempKey, RAS_EAP_VALUENAME_ENCRYPTION, NULL, &dwType, (LPBYTE)&(pEapData->bSupportsEncryption), &dwSize))
                            {
                                pEapData->bSupportsEncryption = FALSE;
                            }

                            //
                            //  Finally add the EAP to the combobox
                            //
                            LPTSTR pszDisplayString = NULL;
                            TCHAR szDisplayString[MAX_PATH+1];

                            if (pEapData->bSupportsEncryption)
                            {
                                LPTSTR pszSuffix = CmLoadString(g_hInstance, IDS_SUPPORTS_ENCRYPT);

                                if (pszSuffix)
                                {
                                    wsprintf(szDisplayString, TEXT("%s %s"), pEapData->pszFriendlyName, pszSuffix);
                                    pszDisplayString = szDisplayString;
                                    CmFree(pszSuffix);
                                }
                            }

                            if (NULL == pszDisplayString)
                            {
                                pszDisplayString = pEapData->pszFriendlyName;
                            }

                            INT_PTR nResult = SendDlgItemMessage(hDlg, uCtrlId, CB_ADDSTRING, (WPARAM)0, (LPARAM)pszDisplayString);
                            if (CB_ERR != nResult)
                            {
                                SendDlgItemMessage(hDlg, uCtrlId, CB_SETITEMDATA, (WPARAM)nResult, (LPARAM)pEapData);
                            }
                            else
                            {
                                CMASSERTMSG(FALSE, TEXT("HrAddAvailableEAPsToCombo -- unable to set item data."));
                                hr = HRESULT_FROM_WIN32(GetLastError());
                            }
                        }
                        else
                        {
                            CMASSERTMSG(FALSE, TEXT("HrAddAvailableEAPsToCombo -- CmMalloc returned a NULL pointer."));
                            hr = E_OUTOFMEMORY;                        
                        }
                    }
                    else
                    {
                        CMTRACE2(TEXT("HrAddAvailableEAPsToCombo -- Unable to find Path value for EAP regkey %s, hr %d"), szSubKeyName, hr);
                    }
                }
                else
                {
                    CMTRACE2(TEXT("HrAddAvailableEAPsToCombo -- Unable to Open EAP regkey %s, GLE %d"), szSubKeyName, GetLastError());
                }
            }

            dwIndex++;
            
        } while (ERROR_SUCCESS == lReturn);

        //
        //  If the Dun setting contains an EAP that isn't on the system
        //  we need to prompt the user.
        //
        if (pDunSetting->dwCustomAuthKey && (FALSE == bEapTypeFound))
        {
            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_EAP_NOT_FOUND, MB_OK | MB_ICONINFORMATION));

            EAPData* pEapData = (EAPData*)CmMalloc(sizeof(EAPData));
            if (pEapData)
            {
                pEapData->pszFriendlyName = CmFmtMsg(g_hInstance, IDS_EAP_NOT_FOUND_TYPE, pDunSetting->dwCustomAuthKey);
                pEapData->dwCustomAuthKey = pDunSetting->dwCustomAuthKey;
                pEapData->bNotInstalled = TRUE;
                
                INT_PTR nResult = SendDlgItemMessage(hDlg, uCtrlId, CB_ADDSTRING, (WPARAM)0, (LPARAM)(pEapData->pszFriendlyName));
                
                if (CB_ERR != nResult)
                {
                    SendDlgItemMessage(hDlg, uCtrlId, CB_SETITEMDATA, (WPARAM)nResult, (LPARAM)pEapData);
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("HrAddAvailableEAPsToCombo -- CmMalloc returned a NULL pointer."));
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  FreeDnsList
//
// Synopsis:  Since the ListBxData in the list box items of the DNS
//            list are actually CDunSetting class pointers we must
//            properly cast the pointer so that they are destructed
//            corretly.
//
// Arguments: ListBxList ** HeadPtr - head of the DUN setting list
//
// Returns:   nothing
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
void FreeDnsList(ListBxList ** pHeadPtr, ListBxList ** pTailPtr)
{
    CDunSetting* pDunSetting;
    ListBxList* pCurrent = *pHeadPtr;
    ListBxList* pTemp;

    while (NULL != pCurrent)
    {
        pTemp = pCurrent;

        //
        //  Free the DunSetting
        //
        pDunSetting = (CDunSetting*)pCurrent->ListBxData;
        delete pDunSetting;

        pCurrent = pCurrent->next;

        CmFree(pTemp);
    }

    *pHeadPtr = NULL;
    *pTailPtr = NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  EnableDisableDunEntryButtons
//
// Synopsis:  This function enables or disables the Add and Edit buttons on
//            the Dun entries screen.  It also enables or disables the delete
//            button depending on whether the current selection is a built in
//            entry or not.
//
// Arguments: HINSTANCE hInstance - instance handle to load resources with
//            HWND hDlg - window handle to the dun entries dialog
//            LPCTSTR pszCmsFile - full path to the cms file
//            LPCTSTR pszLongServiceName - long service name of the profile
//
// Returns:   Nothing
//
// History:   quintinb Created    9/11/98
//
//+----------------------------------------------------------------------------
void EnableDisableDunEntryButtons(HINSTANCE hInstance, HWND hDlg, LPCTSTR pszCmsFile, LPCTSTR pszLongServiceName)
{
    
    LRESULT lResult;
    HWND hControl;
    BOOL bEnableEdit = FALSE;
    BOOL bEnableDelete = FALSE;

    lResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETCOUNT, 0, 0);
    
    if (LB_ERR != lResult)
    {
        if (0 == lResult)
        {
            //
            //  Zero Items, set focus to the Add Button
            //
            SetFocus(GetDlgItem(hDlg, IDC_BUTTON1));            
        }
        else
        {
            //
            //  Enable the Edit Button because we have at least 1 item.
            //
            bEnableEdit = TRUE;

            //
            //  Now lets figure out if the delete button should be enabled or not.
            //  If we have at least one item then we normally want to enable the
            //  delete button.  However, if the current selection is on the VPN
            //  connection or the default connection then we don't want the user to
            //  delete these and we will have to disable the delete button (note that
            //  even if the user hit the delete button on one of these items we wouldn't
            //  delete it).  So, lets get the Cursor selection to see if we need to 
            //  disable the delete button.
            //
            LRESULT lCurrentIndex = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

            if (LB_ERR == lCurrentIndex)
            {
                MYVERIFY(LB_ERR != SendDlgItemMessage(hDlg, IDC_LIST1, LB_SETCURSEL, 0, (LPARAM)0));
                lCurrentIndex = 0;
            }

            TCHAR szTunnelDunName[MAX_PATH+1] = TEXT("");
            TCHAR szDefaultDunName[MAX_PATH+1] = TEXT("");
            //
            //  Get the name of the Tunnel Dun setting
            //
            MYVERIFY(0 != GetTunnelDunSettingName(pszCmsFile, pszLongServiceName, szTunnelDunName, CELEMS(szTunnelDunName)));

            //
            //  Get the name of the default Dun setting
            //
            MYVERIFY(0 != GetDefaultDunSettingName(pszCmsFile, pszLongServiceName, szDefaultDunName, CELEMS(szDefaultDunName)));

            //
            //  If we have the default entry text or the tunnel entry text then we want
            //  to use the real item names for these instead of the text we inserted for
            //  the user to read.
            //
            LPTSTR pszTunnelDunDisplayString = CmFmtMsg(hInstance, IDS_DEFAULT_FMT_STR, szTunnelDunName);
            LPTSTR pszDefaultDunDisplayString = CmFmtMsg(hInstance, IDS_DEFAULT_FMT_STR, szDefaultDunName);
            LPTSTR pszCurrentSelection = NULL;

            MYDBGASSERT(pszTunnelDunDisplayString && pszDefaultDunDisplayString);

            if (pszTunnelDunDisplayString && pszDefaultDunDisplayString)
            {           
                lResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETTEXTLEN, lCurrentIndex, (LPARAM)0);

                if (LB_ERR != lResult)
                {
                    pszCurrentSelection = (LPTSTR)CmMalloc((lResult + 1) * sizeof(TCHAR));

                    if (pszCurrentSelection)
                    {
                        lResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETTEXT, lCurrentIndex, (LPARAM)pszCurrentSelection);

                        if ((0 != lstrcmpi(pszCurrentSelection, pszTunnelDunDisplayString)) && 
                            (0 != lstrcmpi(pszCurrentSelection, pszDefaultDunDisplayString)))
                        {
                           bEnableDelete = TRUE; 
                        }
                    }
                }

                CmFree(pszTunnelDunDisplayString);
                CmFree(pszDefaultDunDisplayString);
                CmFree(pszCurrentSelection);
            }            
        }
    }

    HWND hDeleteButton = GetDlgItem(hDlg, IDC_BUTTON3);
    HWND hCurrentFocus = GetFocus();

    if (hControl = GetDlgItem(hDlg, IDC_BUTTON2))   // Edit
    {
        EnableWindow(hControl, bEnableEdit);
    }            

    if (hDeleteButton)   // Delete
    {
        EnableWindow(hDeleteButton, bEnableDelete);
    }

    if (FALSE == IsWindowEnabled(hCurrentFocus))
    {
        if (hDeleteButton == hCurrentFocus)
        {
            //
            //  If delete is disabled and contained the focus, shift it to the Add button
            //
            SendMessage(hDlg, DM_SETDEFID, IDC_BUTTON1, (LPARAM)0L); //lint !e534 DM_SETDEFID doesn't return error info
            hControl = GetDlgItem(hDlg, IDC_BUTTON1);
            SetFocus(hControl);
        }
        else
        {
            //
            //  If all else fails set the focus to the list control
            //
            hControl = GetDlgItem(hDlg, IDC_LIST1);
            SetFocus(hControl);
        }    
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CheckForDUNversusVPNNameConflicts
//
// Synopsis:  This function checks the names of all of the entries in the DUN
//            entry list to make sure that no entries of the same name exist
//            on the VPN list since the namespace that the two types of entries
//            share (ie the cms file) is a flat namespace.  If an identical entry
//            name exists in both lists then one will overwrite the over in the cms.
//
// Arguments: HWND hDlg - window handle of the parent window
//            ListBxList * pHeadDunEntry - head of the DUN settings list
//            ListBxList * pHeadVpnEntry - head of the VPN settings list
//
// Returns:   BOOL - TRUE if no collision was detected, FALSE if a collision was detected
//
// History:   quintinb Created     11/01/00
//
//+----------------------------------------------------------------------------
BOOL CheckForDUNversusVPNNameConflicts(HWND hDlg, ListBxList * pHeadDunEntry, ListBxList * pHeadVpnEntry)
{
    if (pHeadDunEntry && pHeadVpnEntry)
    {
        ListBxList * pCurrentDUN = pHeadDunEntry;

        while (pCurrentDUN)
        {
            ListBxList * pCurrentVPN = pHeadVpnEntry;
    
            while (pCurrentVPN)
            {
                CMTRACE2(TEXT("Comparing %s with %s"), pCurrentVPN->szName, pCurrentDUN->szName);
                if (0 == lstrcmpi(pCurrentVPN->szName, pCurrentDUN->szName))
                {
                    //
                    //  Collision detected
                    //
                    LPTSTR pszMsg = CmFmtMsg(g_hInstance, IDS_DUN_NAME_CONFLICT, pCurrentDUN->szName);

                    if (pszMsg)
                    {
                        MessageBox(hDlg, pszMsg, g_szAppTitle, MB_OK);
                        CmFree (pszMsg);
                    }

                    return FALSE;
                }
                pCurrentVPN = pCurrentVPN->next;
            }

            pCurrentDUN = pCurrentDUN->next;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\profwiz\profwiz.cpp ===
//+----------------------------------------------------------------------------
//
// File:     profwiz.cpp
//
// Module:   CMAK.EXE
//
// Synopsis: Main code for CMAK
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   a-frankh   Created                         05/15/97
//           quintinb   Updated header and made a       08/07/98  
//                      few other changes
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "cmsecure.h"

// linkdll is needed because of cmsecure
#include "linkdll.h" // LinkToDll and BindLinkage
#include "linkdll.cpp" // LinkToDll and BindLinkage

//
//  Include HasSpecifiedAccessToFileOrDir
//
#ifndef CreateFileU
    #ifdef UNICODE
    #define CreateFileU CreateFileW
    #else
    #define CreateFileU CreateFileA
    #endif
#endif

#include "hasfileaccess.cpp"
#include "gppswithalloc.cpp"

//
//  Globals
//

//
//  This global specifies what the return value of CMAK should be.  Note that if the user
//  cancels the wizard this value isn't used and FALSE (0) is returned by the wizard code.
//
int g_iCMAKReturnVal = CMAK_RETURN_CANCEL;

//
//  This was added for shipping with IEAK.  If the /o command line switch is specified this
//  bool is set to true and we don't show the finish dialog (either one).
//
BOOL g_bIEAKBuild = FALSE;
const TCHAR* const g_szBadFilenameChars = TEXT("!@#$%^&*(){}[]+=,;:?/\\'\"`~|<>. ");
const TCHAR* const g_szBadLongServiceNameChars = TEXT("*/\\:?\"<>|[]");
const TCHAR* const c_pszDoNotShowLcidMisMatchDialog = TEXT("DoNotShowLcidMisMatchDialog");


TCHAR g_szInfFile[MAX_PATH+1]; // full path/filename of working inf file
TCHAR g_szCmakdir[MAX_PATH+1]; // full path of working inf file (includes ending slash)
TCHAR g_szOsdir[MAX_PATH+1]; // full path of platform branch (includes ending slash)
TCHAR g_szSedFile[MAX_PATH+1]; // full path of working sed file
TCHAR g_szCmsFile[MAX_PATH+1];
TCHAR g_szCmpFile[MAX_PATH+1];
TCHAR g_szSupportDir[MAX_PATH+1]; // full path of support files are located
TCHAR g_szTempDir[MAX_PATH+1];
TCHAR g_szLastBrowsePath[MAX_PATH+1] = {0};

TCHAR g_szShortServiceName[MAX_PATH+1];
TCHAR g_szLongServiceName[MAX_PATH+1];
TCHAR g_szBrandBmp[MAX_PATH+1];
TCHAR g_szPhoneBmp[MAX_PATH+1];
TCHAR g_szLargeIco[MAX_PATH+1];
TCHAR g_szSmallIco[MAX_PATH+1];
TCHAR g_szTrayIco[MAX_PATH+1];
TCHAR g_szPhonebk[MAX_PATH+1];
TCHAR g_szRegion[MAX_PATH+1];
TCHAR g_szHelp[MAX_PATH+1];
TCHAR g_szOutdir[MAX_PATH+1];
TCHAR g_szUrl[MAX_PATH+1];
TCHAR g_szOutExe[MAX_PATH+1];
TCHAR g_szSvcMsg[MAX_PATH+1];
TCHAR g_szPrefix[MAX_PATH+1];
TCHAR g_szSuffix[MAX_PATH+1];
TCHAR g_szLicense[MAX_PATH+1];
TCHAR g_szPhoneName[MAX_PATH+1];
TCHAR g_szAppTitle[MAX_PATH+1];
TCHAR g_szCmProxyFile[MAX_PATH+1];
TCHAR g_szCmRouteFile[MAX_PATH+1];
TCHAR g_szVpnFile[MAX_PATH+1];

BOOL g_bNewProfile = TRUE;
BOOL g_bUseTunneling = FALSE;
BOOL g_bUseSamePwd = FALSE;
BOOL g_bUpdatePhonebook = FALSE;
BOOL g_bPresharedKeyNeeded = FALSE;

#ifdef _WIN64
BOOL g_bIncludeCmCode = FALSE; // don't include CM code on IA64
#else
TCHAR g_szCmBinsTempDir[MAX_PATH+1] = {0};
BOOL g_bIncludeCmCode = TRUE;
#endif

HINSTANCE g_hInstance;

ListBxList * g_pHeadDunEntry=NULL;
ListBxList * g_pTailDunEntry=NULL;

ListBxList * g_pHeadVpnEntry=NULL;
ListBxList * g_pTailVpnEntry=NULL;


ListBxList * g_pHeadProfile=NULL;
ListBxList * g_pTailProfile=NULL;
ListBxList * g_pHeadExtra=NULL;
ListBxList * g_pTailExtra=NULL;
ListBxList * g_pHeadMerge=NULL;
ListBxList * g_pTailMerge=NULL;
ListBxList * g_pHeadRefs=NULL;
ListBxList * g_pTailRefs=NULL;
ListBxList * g_pHeadRename=NULL;
ListBxList * g_pTailRename=NULL;

CustomActionList* g_pCustomActionList = NULL;

IconMenu * g_pHeadIcon;
IconMenu * g_pTailIcon;

IconMenu DlgEditItem; //global used to pass info to/from dialogs

//+----------------------------------------------------------------------------
//
// Function:  TextIsRoundTripable
//
// Synopsis:  Tests to see if the passed in text is convertables from Unicode
//            to ANSI and then back to Unicode again.  If so returns TRUE,
//            else FALSE.
//
// Arguments: LPCTSTR pszCharBuffer - string to test
//            BOOL bDisplayError - whether to display an error message or not
//                                 if the text isn't roundtripable
//
// Returns:   BOOL - TRUE if the roundtrip was success
//
// History:   quintinb Created Header    6/16/99
//
//+----------------------------------------------------------------------------
BOOL TextIsRoundTripable(LPCTSTR pszCharBuffer, BOOL bDisplayError)
{

    LPWSTR pszUnicodeBuffer = NULL;
    BOOL bRoundTrip = FALSE;

    MYDBGASSERT(pszCharBuffer);

    if (pszCharBuffer)
    {
        LPSTR pszAnsiBuffer = WzToSzWithAlloc(pszCharBuffer);

        if (pszAnsiBuffer)
        {
            pszUnicodeBuffer = SzToWzWithAlloc(pszAnsiBuffer);
            if (pszUnicodeBuffer && (0 == lstrcmp(pszCharBuffer, pszUnicodeBuffer)))
            {
                //
                //  Then we were able to round trip the strings successfully
                //  Set bRoundTrip to TRUE so that we don't throw an error.
                //
                bRoundTrip = TRUE;
            }

            CmFree(pszUnicodeBuffer);
            CmFree(pszAnsiBuffer);
        }

        if (!bRoundTrip && bDisplayError)
        {
            //
            //  Throw an error message.
            //

            LPTSTR pszTmp = CmLoadString(g_hInstance, IDS_CANNOT_ROUNDTRIP);

            if (pszTmp)
            {
                DWORD dwSize = lstrlen(pszTmp) + lstrlen(pszCharBuffer) + 1;
                LPTSTR pszMsg = (LPTSTR)CmMalloc(dwSize*sizeof(TCHAR));

                if (pszMsg)
                {
                    wsprintf(pszMsg, pszTmp, pszCharBuffer);
                    MessageBox(NULL, pszMsg, g_szAppTitle, MB_OK | MB_ICONERROR | MB_TASKMODAL);
                    CmFree(pszMsg);
                }

                CmFree(pszTmp);
            }
        }
    }

    return bRoundTrip;
}

//+----------------------------------------------------------------------------
//
// Function:  GetTextFromControl
//
// Synopsis:  This is a wrapper function that sends a WM_GETTEXT message to 
//            the control specified by the input parameters.  Once the text
//            is retrieved from the control, we convert it to ANSI and then
//            back to UNICODE so that we can compare the original Unicode 
//            string to the round-tripped string.  If these are not equal we 
//            throw an error message, if bDisplayError is TRUE, and return
//            a failure value (-1).  It is up to the caller to take appropriate
//            behavior (preventing the user from continuing, etc.)
//
// Arguments: IN HWND hDlg - HWND of the dialog the control is on
//            IN int nCtrlId - ID of the control to get text from
//            OUT LPTSTR pszCharBuffer - out buffer to hold the returned TEXT
//            IN DWORD dwCharInBuffer - numbers of chars in out buffer
//            BOOL bDisplayError - if TRUE display an error message if 
//                                 the text isn't roundtripable
//
// Returns:   LONG - the number of chars copied to the output buffer or -1 on error
//
// History:   quintinb Created     6/15/99
//
//+----------------------------------------------------------------------------
LRESULT GetTextFromControl(IN HWND hDlg, IN int nCtrlId, OUT LPTSTR pszCharBuffer, IN DWORD dwCharInBuffer, BOOL bDisplayError)
{
    LRESULT lResult = 0;

    if (hDlg && nCtrlId && pszCharBuffer && dwCharInBuffer)
    {
        lResult = SendDlgItemMessage(hDlg, nCtrlId, WM_GETTEXT, (WPARAM)dwCharInBuffer, (LPARAM)pszCharBuffer);
#ifdef UNICODE
        //
        //  We want to make sure that we can convert the strings to MBCS.  If we cannot then we are not
        //  going to be able to store the string in the our ANSI data files (.cms, .cmp, .inf, etc.).
        //  Thus we need to convert the string to MBCS and then back to UNICODE.  We will then compare the original
        //  string to the resultant string and see if they match.
        //
        
        if (TEXT('\0') != pszCharBuffer[0])
        {
            if (!TextIsRoundTripable(pszCharBuffer, bDisplayError))
            {
                //
                //  Set the return code to an error value.
                //

                lResult = -1;
            }
        }
#endif
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("Bad Parameter passed to GetTextFromControl!"));
    }

    return lResult;
}

//+----------------------------------------------------------------------------
//
// Function:  FreeIconMenu
//
// Synopsis:  This function frees the linked list of status area menu icons.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    05/09/00
//
//+----------------------------------------------------------------------------
void FreeIconMenu()
{
    IconMenu * LoopPtr;
    IconMenu * TmpPtr;

    if (g_pHeadIcon == NULL)
    {
        return;
    }
    LoopPtr = g_pHeadIcon;
    while( LoopPtr != NULL)
    {
        TmpPtr = LoopPtr;
    
        LoopPtr = LoopPtr->next;

        CmFree(TmpPtr);
    }
    g_pHeadIcon = NULL;
    g_pTailIcon = NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  ReferencedDownLoad
//
// Synopsis:  This function opens each referenced cms file to check and see if it has a
//            PBURL.  If so, then this files is considered to do PB downloads and should
//            cause the top level profile to run the cmdl connect action. 
//
// Arguments: None
//
// Returns:   BOOL - returns whether referenced profiles need cmdl
//
// History:   quintinb Created    2/2/98
//
//+----------------------------------------------------------------------------
BOOL ReferencedDownLoad()
{
    ListBxList * ptrMergeProfile = NULL;
    TCHAR szRefCmsFile[MAX_PATH+1];
    TCHAR szPbUrl[MAX_PATH+1];
    
    if (NULL == g_pHeadMerge)
    {
        return FALSE;
    }
    else
    {
        //
        //  Enumerate the referenced profiles to try to find one that has a PBURL field.
        //

        ptrMergeProfile = g_pHeadMerge;
        
        while (NULL != ptrMergeProfile)
        {
            //
            //  Let's try the profile directory for the merged profile in order to get the most up to date version.  This
            //  is where CMAK will pull it from if available.  If not, we will fall back to the one in the temp directory.
            //
            MYVERIFY(CELEMS(szRefCmsFile) > (UINT)wsprintf(szRefCmsFile, TEXT("%s%s\\%s.cms"), g_szOsdir, ptrMergeProfile->szName, ptrMergeProfile->szName));

            if (!FileExists(szRefCmsFile))
            {
                //
                //  Next check to see if the merged cms file exists in the temp dir
                //
                MYVERIFY(CELEMS(szRefCmsFile) > (UINT)wsprintf(szRefCmsFile, TEXT("%s\\%s.cms"), g_szTempDir, ptrMergeProfile->szName));
            }

            GetPrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspUrl, TEXT(""), szPbUrl, MAX_PATH, szRefCmsFile);     //lint !e534

            if (TEXT('\0') != szPbUrl[0])
            {
                //
                //  Only takes one phonebook with a URL to enable referenced downloads
                //

                return TRUE;
            }

            ptrMergeProfile = ptrMergeProfile->next;
        }

    }

    return FALSE;
}


//+----------------------------------------------------------------------------
//
// Function:  SetWindowLongWrapper
//
// Synopsis:  This function is an error checking wrapper for the Windows API
//            SetWindowLong.  This function returns the value that is being 
//            overwritten by this call (if you set a the window long to a value
//            you are overwriting the previous value that it contained.  This
//            previous value is the value returned by the API).  If there is an
//            error then this function returns 0.  However, the previous value
//            could have been 0.  The only way to distinguish the two cases (an 
//            actual error and the previous value being zero) is to call SetLastError
//            with a zero value.  Then you can call GetLastError after the call and if
//            the returned error code isn't zero then we know we have an error.  All
//            of this functionality is combined in this function.
//
// Arguments: HWND hWnd - handle of window to set the long var in
//            int nIndex - offset of value to set
//            LONG dwNewLong - new value 
//
// Returns:   BOOL - Returns TRUE if the call succeeded
//
// History:   quintinb Created    1/7/98
//
//+----------------------------------------------------------------------------
BOOL SetWindowLongWrapper(HWND hWnd, int nIndex, LONG dwNewLong )
{
    DWORD dwError;

    SetLastError(0);
    SetWindowLongPtr(hWnd, nIndex, (LONG_PTR)dwNewLong); //lint !e534
    dwError = GetLastError();

    return (0 == dwError);

}
 
//+---------------------------------------------------------------------------
//
//  Function:       CopyFileWrapper
//
//  Synopsis:       Bundles disk full Error Handling with standard CopyFile functionality
//          
//  Arguments:      lpExistingFileName -- source file of copy
//                  lpNewFileName -- destination file of copy
//                  bFailIfExists -- flag to tell copy to fail if file already exists
//  
//  Assumptions:    This function assumes that the two filename parameters contain the
//                  fully qualified path to the source and destination files.
//                      
//  Returns:        TRUE if copy was sucessful, FALSE on an error
//
//  History:        quintinb    created     11/7/97
//
//----------------------------------------------------------------------------

BOOL CopyFileWrapper(LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, BOOL bFailIfExists)
{

    DWORD dwError;
    int nMessageReturn = 0;
    TCHAR szMsg[2*MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szPath[MAX_PATH+1];

    do {

        if (!CopyFile(lpExistingFileName, lpNewFileName, bFailIfExists))
        {
            //
            //  The CopyFile failed, best check error codes
            //

            dwError = GetLastError();

            switch(dwError)
            {

            case ERROR_HANDLE_DISK_FULL:
            case ERROR_DISK_FULL:

                if (0 == GetFilePath(lpNewFileName, szPath))
                {
                    _tcscpy(szPath, lpNewFileName);
                }

                MYVERIFY(0 != LoadString(g_hInstance, IDS_DISKFULL, szTemp, MAX_PATH));
                MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szTemp, szPath));

                nMessageReturn = MessageBox(NULL, szMsg, g_szAppTitle, MB_RETRYCANCEL | MB_ICONERROR 
                    | MB_TASKMODAL);
                if (nMessageReturn != IDRETRY)
                {
                    return FALSE;
                }
                break;

            default:
                //
                //  Replaces the functionality of the FileAccessErr function so all the file
                //  errors are trapped in one place.  This function still exits for special 
                //  cases.
                //
                MYVERIFY(0 != LoadString(g_hInstance, IDS_NOACCESS, szTemp, MAX_PATH));
                
                MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szTemp, lpNewFileName));

                MessageBox(NULL ,szMsg, g_szAppTitle, MB_OK | MB_ICONERROR | MB_TASKMODAL 
                    | MB_TOPMOST );

                return FALSE;
            }
        } else {
            nMessageReturn = 0;
        }

    } while (IDRETRY == nMessageReturn);

    return TRUE;

}

//+---------------------------------------------------------------------------
//
//  Function:       CheckDiskSpaceForCompression
//
//  Synopsis:       Checks to see if there is sufficient disk space for compressing
//                  the files listed in the passed in sed file.  To do this, uses a simplistic
//                  algorithm of adding up the disk space used by all the files listed in the 
//                  strings section of the SED file, under the FILE<num> entries.  If there is 
//                  at least dwBytes (space taken up by all the files in the SED) of space left 
//                  on the partition containing the SED file, then the function returns true.
//                  Otherwise false is returned, indicating that there may not be enough space left.
//          
//  Arguments:      szSed -- the full path to the SED file to look for filenames in
//                          
//  Returns:        TRUE if sufficient space to continue, FALSE if not sure or probably
//                  not enough
//
//  Assumptions:    That the partition we are checking for diskspace on is the partition of
//                  the current directory.
//
//  History:        quintinb    created     11/10/97
//
//----------------------------------------------------------------------------
BOOL CheckDiskSpaceForCompression (LPCTSTR szSed)
{
    TCHAR szKey[MAX_PATH+1];
    TCHAR szFileName[MAX_PATH+1];
    DWORD dwBytes = 0;
    DWORD dwChars;
   
    //
    //  Calculate the amount of space taken up by the files listed in the SED
    //
    int nCount = 0;
    
    do 
    {       
        MYVERIFY(CELEMS(szKey) > (UINT)wsprintf(szKey, TEXT("FILE%d"), nCount));

        dwChars = GetPrivateProfileString(c_pszInfSectionStrings, szKey, TEXT(""), 
                                                szFileName, MAX_PATH, szSed);
        
        if (0 != dwChars)
        {
            HANDLE hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, 
                                      NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

            if (INVALID_HANDLE_VALUE != hFile)
            {
                dwBytes += GetFileSize(hFile, NULL);
                MYVERIFY(0 != CloseHandle(hFile));
            }
        }

        nCount++;
    } while (0 != dwChars); 

    //
    // Now that we know how much space the files in the SED take up, we should see how much space is on
    // the partition.
    //
    DWORD dwFreeClusters;
    DWORD dwBytesPerSector;
    DWORD dwSectorsPerCluster;
    DWORD dwTotalClusters;
    DWORD dwModulus;
    if (GetDiskFreeSpace(NULL, &dwSectorsPerCluster, &dwBytesPerSector, 
                         &dwFreeClusters, &dwTotalClusters))
    {
        //
        // Because dwSectorsPerCluster*dwBytesPerSector*dwFreeClusters could very easily
        // overflow a 32 bit value, we will calculate the total size of the files to compress
        // in clusters (dwBytes/(dwSectorsPerCluster*dwBytesPerSector)) and compare 
        // against the dwFreeClusters value.
        //
        DWORD dwSizeInSectors = dwBytes / dwBytesPerSector;
        dwModulus = dwBytes % dwBytesPerSector;

        if (dwModulus)
        {
            dwSizeInSectors++; //  we want to round up if it didn't divide evenly
        }

        DWORD dwSizeInClusters = dwSizeInSectors / dwSectorsPerCluster;
        dwModulus = dwSizeInSectors % dwSectorsPerCluster;

        if (dwModulus)
        {
            dwSizeInClusters++; //  we want to round up if it didn't divide evenly
        }

        if (dwFreeClusters > dwSizeInClusters)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

}

//+----------------------------------------------------------------------------
//
// Function:  ProcessBold
//
// Synopsis:  This function makes the IDC_LBLTITLE static text control bold
//            on the WM_INITDIALOG message and releases the bold on WM_DESTROY.
//            This function is usually placed at the top of a window procedure
//            so that these messages are handled automatically.  Note that the
//            function doesn't otherwise affect the processing of these messages
//            by the original window procedure.
//
// Arguments: HWND hDlg - dialog window handle to process messages for
//            UINT message - message to handle
//
// Returns:   Nothing
//
// History:   quintinb Created Header    05/09/00
//
//+----------------------------------------------------------------------------
void ProcessBold(HWND hDlg, UINT message)
{
    switch (message)
    {
        case WM_INITDIALOG: 
            MYVERIFY(ERROR_SUCCESS == MakeBold(GetDlgItem(hDlg, IDC_LBLTITLE), TRUE));
            break;

        case WM_DESTROY:
            MYVERIFY(ERROR_SUCCESS == ReleaseBold(GetDlgItem(hDlg, IDC_LBLTITLE)));
            break;
        default:
            break;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SetDefaultGUIFont
//
//  Synopsis:   Sets the font of the control to be the Default GUI Font.
//
//  Arguments:  hwnd - Window handle of the dialog
//              message - message from the dialog box procedure
//              cltID - ID of the control you want changed.
//
//  Returns:    ERROR_SUCCESS
// 
//  History:    4/31/97 a-frankh    Created
//              quintinb  Renamed from ProcessDBCS and cleaned up 
//----------------------------------------------------------------------------
void SetDefaultGUIFont(HWND hDlg, UINT message, int ctlID)
{
    HFONT hFont = NULL;

    switch (message)
    {
        case WM_INITDIALOG:
            hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);

            if (hFont == NULL)
            {
                hFont = (HFONT) GetStockObject(SYSTEM_FONT);
            }

            if (hFont != NULL)
            {
                SendMessage(GetDlgItem(hDlg, ctlID), WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0)); //lint !e534 WM_SETFONT doesn't return anything
            }

            break;
        default:
            break;
    }

}

//+----------------------------------------------------------------------------
//
// Function:  IsAlpha
//
// Synopsis:  Determines if the current platform is Alpha.
//
// Arguments: None
//
// Returns:   static BOOL - TRUE if the current platform is Alpha
//
// History:   nickball    Created    10/11/97
//
//+----------------------------------------------------------------------------
static BOOL IsAlpha()
{
    SYSTEM_INFO sysinfo;

    ZeroMemory(&sysinfo, sizeof(sysinfo));
    GetSystemInfo(&sysinfo);

    return (sysinfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA);
}

//+----------------------------------------------------------------------------
//
// Function:  ShowMessage
//
// Synopsis:  Simple helper function to handle message display
//
// Arguments: HWND hDlg - Parent window handle
//            int strID - Resource ID of the string to be displayed
//            int mbtype - The type of messagebox (MB_OK, etc.)
//
// Returns:   static int - User response to message box
//
// History:   nickball    Created Header    10/11/97
//            quintinb    Changed strID and mbtype to UINTs for LINT 1-5-98
//            quintinb    Change to use CmLoadString  6/17/99 
//
//+----------------------------------------------------------------------------
int ShowMessage(HWND hDlg, UINT strID, UINT mbtype)
{
    int iReturn = 0;

    LPTSTR pszMsg = CmLoadString(g_hInstance, strID);
    
    if (pszMsg)
    {
        iReturn = MessageBox(hDlg, pszMsg, g_szAppTitle, mbtype);
    }

    CmFree(pszMsg);

    return iReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetFileName
//
// Synopsis:  Get just the filename from a full path and filename
//
// Arguments: LPCTSTR lpPath    - Ptr to the full name and path
//            LPTSTR lpFileName - Ptr to the buffer the hold the extracted name
//
// Returns:   Nothing
//
// History:   nickball    Created Header    10/11/97
//            quintinb    modified to fix bug with URL's  7-15-98
//
//+----------------------------------------------------------------------------
void GetFileName(LPCTSTR lpPath, LPTSTR lpFileName)
{
    LPTSTR pch;

    pch = _tcsrchr(lpPath, _T('\\'));
    if (NULL == pch)
    {
        //
        //  Catch paths like c:temp.inf
        //
        if (_istalpha(lpPath[0]) && (_T(':') == lpPath[1])) //lint !e732
        {
            pch = (TCHAR*)&(lpPath[1]);
        }
    }

    if (NULL == pch)
    {
        _tcscpy(lpFileName, lpPath);
    }
    else
    {
        pch = CharNext(pch);
        _tcscpy(lpFileName, pch);
    }
}
//+----------------------------------------------------------------------------
//
// Function:  GetFilePath
//
// Synopsis:  Get just the full path from a full path and filename
//
// Arguments: LPCTSTR lpFullPath    - Ptr to the full name and path
//            LPTSTR lpPath - Ptr to the buffer the hold the extracted path
//
// Returns:   either 0 or the number of chars copied into the return buffer
//
// History:   quintinb   Created        11/11/97    
//
//+----------------------------------------------------------------------------
int GetFilePath(LPCTSTR lpFullPath, LPTSTR lpPath)
{
    LPTSTR pch;

    _tcscpy(lpPath, lpFullPath);

    // first find the last \ char in the
    // string

    pch = _tcsrchr(lpPath,_T('\\'));

    // if this is null, look for a path similar to
    // c:junk

    if (pch == NULL)
    {
        pch = _tcsrchr(lpPath,_T(':'));
        if (NULL != pch)
        {
            pch = CharNext(pch);
            _tcscpy(pch, TEXT("\\"));
            pch = CharNext(pch);
            *pch = TEXT('\0');
            return _tcslen(lpPath);
        } else {
            lpPath[0] = TEXT('\0');
            return 0;
        }
    } else {
        *pch = TEXT('\0');
        return _tcslen(lpPath);

    }
}

//+----------------------------------------------------------------------------
//
// Function:  GetName
//
// Synopsis:  Extracts filename from a full path and file name and returns a p
//            tointer to the result.
//
// Arguments: LPCTSTR lpPath - Ptr to the full name and path
//
// Returns:   LPTSTR - Ptr to the static buffer containing the result of the extraction.
//
// History:   nickball    Created Header    10/11/97
//
//+----------------------------------------------------------------------------
LPTSTR GetName(LPCTSTR lpPath) 
{
    static TCHAR szStr[MAX_PATH+1];
    GetFileName(lpPath,szStr);
    return szStr;
}

BOOL GetShortFileName(LPTSTR lpFile, LPTSTR lpShortName)
{
    HANDLE hFile;
    WIN32_FIND_DATA FindData;
    TCHAR szPath[MAX_PATH+1];

    GetFileName(lpFile,lpShortName);
    hFile = FindFirstFile(lpFile,&FindData);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        //
        // Not found, try looking from OS dir as the root, because 
        // the filename may be a relative path from a CMS file entry.
        //
        
        MYVERIFY(0 != GetCurrentDirectory(MAX_PATH,szPath));
        MYVERIFY(0 != SetCurrentDirectory(g_szOsdir));

        hFile = FindFirstFile(lpFile,&FindData);
        MYVERIFY(0 != SetCurrentDirectory(szPath));
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if (*FindData.cAlternateFileName)
        {
            if (_tcsicmp(lpShortName,FindData.cAlternateFileName) != 0)
            {
                _tcscpy(lpShortName,FindData.cAlternateFileName);
            }
        }
        MYVERIFY(0 != FindClose(hFile));
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  GetBaseName
//
// Synopsis:  Extracts the base filename (no extension) from a full filename 
//            and path
//
// Arguments: LPTSTR lpPath - The full path and filename
//            LPTSTR lpFileName - The buffer to receive the extracted base name.
//
// Returns:   Nothing
//
// History:   nickball    Created Header    10/11/97
//
//+----------------------------------------------------------------------------
void GetBaseName(LPTSTR lpPath,LPTSTR lpFileName)
{
    LPTSTR pch;

    GetFileName(lpPath, lpFileName);

    pch = _tcsrchr(lpFileName, _T('.'));

    if (pch)
    {
        *pch = TEXT('\0');
    }
}

//+----------------------------------------------------------------------------
//
// Function:  FileAccessErr
//
// Synopsis:  Helper function that handles notification of a file access error
//
// Arguments: HWND hDlg - Parent window handle
//            LPTSTR lpFile - The file that caused the access error.
//
// Returns:   static void - Nothing
//
// History:   nickball    Created Header    10/11/97
//
//+----------------------------------------------------------------------------
static void FileAccessErr(HWND hDlg,LPCTSTR lpFile)
{
    TCHAR szMsg[MAX_PATH+1];
    TCHAR szTemp2[2*MAX_PATH+1];

    MYVERIFY(0 != LoadString(g_hInstance,IDS_NOACCESS,szMsg,MAX_PATH));                 
    MYVERIFY(CELEMS(szTemp2) > (UINT)wsprintf(szTemp2,szMsg,lpFile));
    MessageBox(hDlg, szTemp2, g_szAppTitle, MB_OK);
}

//+----------------------------------------------------------------------------
//
// Function:  VerifyFile
//
// Synopsis:    Given the ID of a dialog box edit control in ctrlID
//              Check if user entered in something different than what is contained in lpFile
//              If it is different, get the entire path and verify it exists.
//              If it doesn't exist and ShowErr = TRUE, display an error message
//              Copy the full path to lpFile if exists
//
// Arguments: HWND hDlg - Window handle of the dialog containing the edit control
//            DWORD ctrlID - edit control containing the file to check
//            LPTSTR lpFile - Filename to verify (checked against that contained in the control)
//            BOOL ShowErr - Whether to show an error message or not
//
// Returns:   BOOL - Return TRUE if the file was verified to exist
//
// History:   quintinb Created Header    1/8/98
//
//+----------------------------------------------------------------------------
BOOL VerifyFile(HWND hDlg, DWORD ctrlID, LPTSTR lpFile, BOOL ShowErr)
{
    TCHAR szMsg[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szTemp2[2*MAX_PATH+1];
    TCHAR szPath[MAX_PATH+1];
    int nResult;
    LPTSTR lpfilename;
    HANDLE hInf;
    LRESULT lrNumChars;

    lrNumChars = GetTextFromControl(hDlg, ctrlID, szTemp, MAX_PATH, ShowErr); // bDisplayError == ShowErr

    //
    // don't check blank entry
    //
    if (0 == lrNumChars || 0 == szTemp[0]) 
    {
        lpFile[0] = TEXT('\0');
        return TRUE;
    }
    
    //
    //  Also check to make sure that we were able to convert the text to ANSI
    //
    if (-1 == lrNumChars)
    {
        SetFocus(GetDlgItem(hDlg, ctrlID));
        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
        return FALSE;
    }

    //
    // if filename is still the same, ignore entry box
    //
    CheckNameChange(lpFile, szTemp);

    MYVERIFY(0 != GetCurrentDirectory(MAX_PATH, szPath));

    //
    // Check current directory, if not found, check OS directory as root.
    // This handles relative paths from the CMS
    //

    nResult = SearchPath(NULL, lpFile, NULL, MAX_PATH, szTemp2, &lpfilename);
    if (!nResult)
    {
        MYVERIFY(0 != SetCurrentDirectory(g_szOsdir));
        nResult = SearchPath(NULL, lpFile, NULL, MAX_PATH, szTemp2, &lpfilename);

        if (!nResult)
        {
            goto Error;
        }
    }

    hInf = CreateFile(szTemp2, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    MYVERIFY(0 != SetCurrentDirectory(szPath));

    if (hInf == INVALID_HANDLE_VALUE)
    {
        goto Error;
    }
    else
    {
        MYVERIFY(0 != CloseHandle(hInf));
    }
    _tcscpy(lpFile,szTemp2);

    return TRUE;

Error:
    _tcscpy(lpFile,szTemp);
    MYVERIFY(0 != SetCurrentDirectory(szPath));

    if (ShowErr)
    {
        MYVERIFY(0 != LoadString(g_hInstance, IDS_NOEXIST, szMsg, MAX_PATH));                  
        MYVERIFY(CELEMS(szTemp2) > (UINT)wsprintf(szTemp2, szMsg, szTemp));
        MessageBox(hDlg, szTemp2, g_szAppTitle, MB_OK);
        SetFocus(GetDlgItem(hDlg, ctrlID));

        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
    }
    return FALSE;

}

// If has entry but file doesn't exist, blank out entry.
BOOL VerifyPhonebk(HWND hDlg,DWORD ctrlID,LPTSTR lpFile)
{
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szTemp2[MAX_PATH+1];
    TCHAR szPath[MAX_PATH+1];
    int nResult;
    LPTSTR lpfilename;
    HANDLE hInf;
    LRESULT lrNumChars;

    //
    //  If the text is not convertable to ANSI then we will catch it on the Next/Back.  Thus
    //  don't try to catch it here, would throw too many error messages at the user.
    //
    lrNumChars = GetTextFromControl(hDlg, ctrlID, szTemp, MAX_PATH, FALSE); // bDisplayError == FALSE

    // don't check blank entry
    if (0 == lrNumChars || 0 == szTemp[0]) 
    {
        lpFile[0] = 0;
        return TRUE;
    }

    // if filename is still the same, don't check
    CheckNameChange(lpFile,szTemp);

    MYVERIFY(0 != GetCurrentDirectory(MAX_PATH,szPath));

    MYVERIFY(0 != SetCurrentDirectory(g_szOsdir));

    nResult = SearchPath(NULL,lpFile,NULL,MAX_PATH,szTemp2,&lpfilename);
    
    if (!nResult)
    {
        goto Error;
    }

    hInf = CreateFile(szTemp2,GENERIC_READ,0,NULL,OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,NULL);

    MYVERIFY(0 != SetCurrentDirectory(szPath));

    if (hInf == INVALID_HANDLE_VALUE)
    {
        goto Error;
    }
    else
    {
        MYVERIFY(0 != CloseHandle(hInf));
    }
    _tcscpy(lpFile,szTemp2);
//  SendMessage(GetDlgItem(hDlg, ctrlID), WM_SETTEXT, 0, (LPARAM)lpFile);
    return TRUE;
Error:

    lpFile[0] = TEXT('\0');
    MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, ctrlID), WM_SETTEXT, 0, (LPARAM)lpFile));
    return FALSE;

}

// If user entered in a new filename, copy it to lpnew

void CheckNameChange(LPTSTR lpold, LPTSTR lpnew)
{
    //
    // if filename changed or if new name contains directories, copy new to old
    //
    if ((_tcsicmp(GetName(lpold), lpnew) != 0) || (_tcschr(lpnew, TEXT('\\')) != NULL))
    {
        _tcscpy(lpold, lpnew);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  WriteRegStringValue
//
// Synopsis:  Wrapper function to encapsulate opening a key for write access and
//            then setting a string value.  Assumes the string is NULL terminated.
//
// Arguments: HKEY hBaseKey - base key, HKCU/HKLM/etc.
//            LPCTSTR pszKeyName - subkey name
//            LPCTSTR pszValueName - Value name to write
//            LPCTSTR pszValueToWrite - Value data string to write
//
// Returns:   BOOL - TRUE if successful
//
// History:   quintinb Created    6/15/99
//
//+----------------------------------------------------------------------------
BOOL WriteRegStringValue(HKEY hBaseKey, LPCTSTR pszKeyName, LPCTSTR pszValueName, LPCTSTR pszValueToWrite) 
{
    HKEY hKey;
    DWORD dwSize;
    BOOL bReturn = FALSE;

    if (hBaseKey && pszKeyName && pszValueName && pszValueToWrite &&
        TEXT('\0') != pszKeyName[0] && TEXT('\0') != pszValueName[0]) // pszValueToWrite could be empty
    {

        LONG lReturn = RegOpenKeyEx(hBaseKey, pszKeyName, 0, KEY_WRITE, &hKey);

        if (ERROR_SUCCESS == lReturn) 
        {
            dwSize = (lstrlen(pszValueToWrite) +1)*sizeof(TCHAR);

            lReturn = RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (LPBYTE)pszValueToWrite, dwSize);
            if (ERROR_SUCCESS == lReturn)
            {
                bReturn = TRUE;
            }

            RegCloseKey(hKey);
        }
    }

    return bReturn;
}


// check to see if the original CMAK installtion directory exists and
// contains the language directories.

//+----------------------------------------------------------------------------
//
// Function:  EraseTempDir
//
// Synopsis:  This function deletes all the files in the tempdir (stored in the global g_szTempDir)
//            then changes directories to the CMAK dir (stored in the global g_szCmakdir).  From
//            there the temp dir is deleted.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the temp dir was deleted
//
// History:   quintinb Created Header    1/5/98
//            quintinb changed return type to a BOOL
//
//+----------------------------------------------------------------------------
BOOL EraseTempDir()
{
    SHFILEOPSTRUCT FileOp;
    ZeroMemory(&FileOp, sizeof(SHFILEOPSTRUCT));

    //
    //  First save a copy of the file
    //
    FileOp.wFunc = FO_DELETE;
    FileOp.pFrom = g_szTempDir;
    FileOp.fFlags = FOF_NOERRORUI | FOF_SILENT | FOF_NOCONFIRMATION;

    int iRet = SHFileOperation (&FileOp); // return 0 on success

    return (iRet ? FALSE : TRUE); 
}

// copies service profile information from the CMAK directory to the 
// temporary directory

static BOOL CopyToTempDir(LPTSTR szName)
{
    HANDLE hCopyFileSearch;
    WIN32_FIND_DATA FindData;
    BOOL bCopyResult;
    TCHAR szTemp[MAX_PATH+1];

    MYVERIFY(0 != SetCurrentDirectory(g_szCmakdir));
    if (!CreateDirectory(g_szTempDir,NULL))
    {
        return FALSE;
    }
    
    if (TEXT('\0') == szName[0])
    {
        return TRUE;
    }

    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s%s"), g_szOsdir, szName));

    if (!SetCurrentDirectory(szTemp))
    {
        return FALSE;
    }

    hCopyFileSearch = FindFirstFile(c_pszWildCard,&FindData);
    if (hCopyFileSearch != INVALID_HANDLE_VALUE)
    {
        do
        {
            if ((FindData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s"), g_szTempDir, FindData.cFileName));
                
                //
                // CLEAN OUT ANY READ ONLY ATTRIBUTES
                //
                MYVERIFY(0 != SetFileAttributes(FindData.cFileName,FILE_ATTRIBUTE_NORMAL));
                
                if (!CopyFileWrapper(FindData.cFileName,szTemp,FALSE))
                {
                    return FALSE;
                }

            }

            bCopyResult = FindNextFile(hCopyFileSearch,&FindData);

        } while (TRUE == bCopyResult);
    }

    MYVERIFY(0 != FindClose(hCopyFileSearch));
    
    return TRUE;
}



//+----------------------------------------------------------------------------
//
// Function:  GetInfVersion
//
// Synopsis:  Opens the inf file and tries to get the InfVersion key from the CMAK Status
//            section.  If the inf file doesn't contain a version stamp then we know it is 
//            version 0 (1.0 and 1.1 releases).
//
// Arguments: LPTSTR szFullPathToInfFile - the full path the the inf file to get the version of
//
// Returns:   int - returns the version value or zero if one wasn't found.
//
// History:   quintinb Created    3/4/98
//
//+----------------------------------------------------------------------------
int GetInfVersion(LPTSTR szFullPathToInfFile)
{
    if ((NULL == szFullPathToInfFile) || (TEXT('\0') == szFullPathToInfFile[0]))
    {
        CMASSERTMSG(FALSE, TEXT("GetInfVersion -- Invalid InfPath Input."));
        return FALSE;
    }

    return ((int)GetPrivateProfileInt(c_pszCmakStatus, c_pszInfVersion, 0, szFullPathToInfFile));
}

//+----------------------------------------------------------------------------
//
// Function:  WriteInfVersion
//
// Synopsis:  Opens the inf file and writes the current INF file version to the Cmak Status section.
//
// Arguments: LPTSTR szFullPathToInfFile - the full path the the inf file to get the version of
//
// Returns:   Returns TRUE if able to write the value
//
// History:   quintinb Created    3/4/98
//
//+----------------------------------------------------------------------------
BOOL WriteInfVersion(LPTSTR szFullPathToInfFile, int iVersion)
{
    TCHAR szTemp[MAX_PATH+1];

    if ((NULL == szFullPathToInfFile) || (TEXT('\0') == szFullPathToInfFile[0]))
    {
        CMASSERTMSG(FALSE, TEXT("WriteInfVersion -- Invalid InfPath Input."));
        return FALSE;
    }

    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%d"), iVersion));

    return (0 != WritePrivateProfileString(c_pszCmakStatus, c_pszInfVersion, szTemp, szFullPathToInfFile));
}



//+----------------------------------------------------------------------------
//
// Function:  UpgradeInf
//
// Synopsis:  This function upgrades and INF from an older version to the current
//            version.
//
// Arguments: LPCTSTR szRenamedInfFile - Filename to save the old INF to
//            LPCTSTR szFullPathToInfFile - Profile INF file
//
// Returns:   BOOL - TRUE if successful
//
// History:   quintinb Created Header    7/31/98
//
//+----------------------------------------------------------------------------
BOOL UpgradeInf(LPCTSTR szRenamedInfFile, LPCTSTR szFullPathToInfFile)
{
    SHFILEOPSTRUCT FileOp;
    TCHAR szTemp[MAX_PATH+1];
    DWORD dwSize;
    TCHAR* pszBuffer = NULL;
    
    const int NUMSECTIONS = 3;
    const TCHAR* const aszSectionName[NUMSECTIONS] = 
    {
        c_pszCmakStatus,
        c_pszExtraFiles,
        c_pszMergeProfiles
    };
    
    const int NUMKEYS = 4;
    const TCHAR* const aszKeyName[NUMKEYS] = 
    {
        c_pszCmEntryServiceName,
        c_pszShortSvcName,
        c_pszUninstallAppTitle,
        c_pszDesktopIcon
    };


    ZeroMemory(&FileOp, sizeof(SHFILEOPSTRUCT));

    //
    //  First save a copy of the file
    //
    FileOp.wFunc = FO_COPY;
    FileOp.pFrom = szFullPathToInfFile;
    FileOp.pTo = szRenamedInfFile;
    FileOp.fFlags = FOF_NOERRORUI | FOF_SILENT | FOF_NOCONFIRMATION;

    if (0 != SHFileOperation (&FileOp))
    {
        return FALSE;
    }
    
    //
    //  First Copy the template.inf from the lang dir so that we have something to work from
    //

    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s"), g_szSupportDir, c_pszTemplateInf));
    MYVERIFY(FALSE != CopyFileWrapper(szTemp, szFullPathToInfFile, FALSE));
    MYVERIFY(0 != SetFileAttributes(szFullPathToInfFile, FILE_ATTRIBUTE_NORMAL));

    //
    //  now migrate the [CMAK Status], [Extra Files], [Merge Profiles] sections
    //

    for (int i=0; i < NUMSECTIONS; i++)
    {
        pszBuffer = GetPrivateProfileSectionWithAlloc(aszSectionName[i], szRenamedInfFile);
        
        if (pszBuffer)
        {
            MYVERIFY(0 != WritePrivateProfileSection(aszSectionName[i], pszBuffer, szFullPathToInfFile));
        }
    }

    //
    //  Free the allocated Buffer
    //
    CmFree(pszBuffer);
    pszBuffer = NULL;

    //
    //  Migrate the ServiceName, ShortSvcName, DesktopGUID, UninstallAppTitle, DesktopIcon values
    //  from the strings section.
    //

    for (i=0; i < NUMKEYS; i++)
    {
    
        dwSize = GetPrivateProfileString(c_pszInfSectionStrings, aszKeyName[i], TEXT(""), szTemp, MAX_PATH, szRenamedInfFile);
        
        if (0 != dwSize)
        {
            MYVERIFY(0 != WritePrivateProfileString(c_pszInfSectionStrings, aszKeyName[i], szTemp, szFullPathToInfFile));
        }
    }

    //
    //  Special Case for the Desktop GUID.  We always write Quotes around the GUID and these get 
    //  stripped by the reading routine.  Thus we need to add them back.
    //
    dwSize = GetPrivateProfileString(c_pszInfSectionStrings, c_pszDesktopGuid, TEXT(""), szTemp, MAX_PATH, szRenamedInfFile);
        
    if (0 != dwSize)
    {
        QS_WritePrivateProfileString(c_pszInfSectionStrings, c_pszDesktopGuid, szTemp, szFullPathToInfFile);
    }

    //  The follwing sections should get rewritten and won't need to be migrated.
    //  [Xnstall.AddReg.Icon]
    //  [RegisterOCXSection], [Xnstall.CopyFiles], [Xnstall.CopyFiles.SingleUser],  [Xnstall.CopyFiles.ICM], 
    //  [Remove.DelFiles.ICM], [SourceDisksFiles], [Xnstall.RenameReg],
    //  [Remove.DelFiles]

    return TRUE;

}

//+----------------------------------------------------------------------------
//
// Function:  EnsureInfIsCurrent
//
// Synopsis:  This function does whatever processing is necessary to upgrade the inf from
//            its current version to the current version of CMAK itself.
//
// Arguments: HWND hDlg - window handle of the dialog box for modal messagebox purposes.
//            LPTSTR szFullPathToInfFile - the full path the the inf file to get the version of
//
// Returns:   BOOL - return TRUE if the inf was successfully upgraded, otherwise FALSE
//
// History:   quintinb Created   3/4/98
//
//+----------------------------------------------------------------------------
BOOL EnsureInfIsCurrent(HWND hDlg, LPTSTR szFullPathToInfFile)
{

    int iInfVersion;
    TCHAR szRenamedInfFile[2*MAX_PATH+1];
    TCHAR szTitle[2*MAX_PATH+1];
    TCHAR szMsg[2*MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    BOOL bUpgradeProfile = FALSE;

    if ((NULL == szFullPathToInfFile) || (TEXT('\0') == szFullPathToInfFile[0]))
    {
        CMASSERTMSG(FALSE, TEXT("EnsureInfIsCurrent -- Invalid InfPath Input."));
        return FALSE;
    }

    iInfVersion = GetInfVersion(szFullPathToInfFile);

    ZeroMemory(szRenamedInfFile, sizeof(szRenamedInfFile));

    MYVERIFY(CELEMS(szRenamedInfFile) > (UINT)wsprintf(szRenamedInfFile, TEXT("%s.bak"), 
        szFullPathToInfFile));

    //
    //  We want to upgrade the inf if the Profile versions don't match.  We also have
    //  a special case to handle upgrading NT5 Beta3 (and IEAK) profiles to NT5 RTM
    //  profiles.  In order to fix NTRAID 323721 and 331446, the inf format had to change
    //  slightly thus we need to make sure to upgrade these profiles.  We will use any
    //  cmdial32.dll build prior to 2055 as needing this fix.  If version == 4 and the BuildNumber
    //  doesn't exist we assume it is a new profile.  Thus don't upgrade.
    //
    const DWORD c_dwBuild2080 = ((2080 << c_iShiftAmount) + VER_PRODUCTBUILD_QFE);
    DWORD dwProfileBuildNumber = (DWORD)GetPrivateProfileInt(c_pszSectionCmDial32, c_pszVerBuild, 
                                                             (c_dwBuild2080 + 1), szFullPathToInfFile);

    bUpgradeProfile = (iInfVersion != PROFILEVERSION) || 
                      ((4 == iInfVersion) && (c_dwBuild2080 > dwProfileBuildNumber));

    //
    //  Always grab most of the information out of the template so that we get the correct language
    //  info.
    //
    if (bUpgradeProfile)
    {
        MYVERIFY(0 != LoadString(g_hInstance, IDS_MUST_UPGRADE_INF, szTitle, 2*MAX_PATH));  // temporarily use szTitle
        GetFileName(szRenamedInfFile, szTemp);
        MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szTitle, szTemp));

        MYVERIFY(IDOK == MessageBox(hDlg, szMsg, g_szAppTitle, MB_OK | MB_APPLMODAL));
        return UpgradeInf(szRenamedInfFile, szFullPathToInfFile);
    }

    return TRUE;
}


BOOL CopyFromTempDir(LPTSTR szName)
{
    HANDLE hCopyFileSearch;
    WIN32_FIND_DATA FindData;
    BOOL bCopyResult;
    TCHAR szSource[MAX_PATH+1];
    TCHAR szDest[MAX_PATH+1];    
    TCHAR szOut[MAX_PATH+1];

    //
    // Create profile directory
    // 

    MYVERIFY(CELEMS(szOut) > (UINT)wsprintf(szOut, TEXT("%s%s"), g_szOsdir, szName));

    if (0 == SetCurrentDirectory(szOut))
    {
        MYVERIFY(0 != CreateDirectory(szOut,NULL));
    }

    MYVERIFY(0 != SetCurrentDirectory(g_szTempDir));

    hCopyFileSearch = FindFirstFile(c_pszWildCard, &FindData);

    if (hCopyFileSearch != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (0 == (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s\\%s"), szOut, FindData.cFileName));

                MYVERIFY(CELEMS(szSource) > (UINT)wsprintf(szSource, TEXT("%s\\%s"), g_szTempDir, FindData.cFileName));
            
                if (!CopyFileWrapper(szSource, szDest, FALSE))
                {
                    return FALSE;
                }
            }
            
            bCopyResult = FindNextFile(hCopyFileSearch, &FindData);

        } while (bCopyResult == TRUE);
    }

    MYVERIFY(0 != FindClose(hCopyFileSearch));

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  LoadServiceProfiles
//
// Synopsis:  This function loads all the service profiles in the subdirectories
//            of the current directory (thus you set this to c:\program files\cmak\profiles-32
//            to have it load the normal profiles).  The profiles are loaded into
//            CMAK's internal linked list of available profiles to edit.
//
// Arguments: None
//
// Returns:   Nothing 
//
// History:   quintinb Created Header    6/24/98
//            quintinb removed two boolean arguments    6/24/98
//
//+----------------------------------------------------------------------------
void LoadServiceProfiles()
{
    WIN32_FIND_DATA FindData;
    HANDLE hFileSearch;
    HANDLE hCms;
    BOOL bResult;
    TCHAR szTemp[MAX_PATH+1];

    hFileSearch = FindFirstFile(c_pszWildCard,&FindData);
    if (hFileSearch != INVALID_HANDLE_VALUE)
    {
        do
        {
            if ((FindData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY) != 0)
            {
                MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s.cms"), 
                    FindData.cFileName, FindData.cFileName));
                //
                // If we can open the file, add a record to our profile list
                //
                
                hCms = CreateFile(szTemp,GENERIC_READ,0,NULL,OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,NULL);
                if (hCms != INVALID_HANDLE_VALUE)
                {
                    MYVERIFY(0 != CloseHandle(hCms));                
                    MYVERIFY(FALSE != createListBxRecord(&g_pHeadProfile, &g_pTailProfile, (void *)NULL, 0, FindData.cFileName));
                }
            }

            bResult = FindNextFile(hFileSearch, &FindData);

        } while (TRUE == bResult);

        MYVERIFY(0 != FindClose(hFileSearch));
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CopyNonLocalProfile
//
//  Synopsis:   Helper function to handle details of copying an external profile
//              to the local CMAK layout. 
//
//  Arguments:  pszName - The name of the profile to be copied
//                          
//  Returns:    Nothing
//
//  History:    nickball - created - 11/16/97
//              quintinb - modified to not change directory -- 6/24/98
//
//----------------------------------------------------------------------------

void CopyNonLocalProfile(LPCTSTR pszName, LPCTSTR pszExistingProfileDir)
{
    WIN32_FIND_DATA FindData;
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szProfileDestDir[MAX_PATH+1];
    TCHAR szOldInf[MAX_PATH+1];
    TCHAR szFindFilePath[MAX_PATH+1];
    TCHAR szTempDest[MAX_PATH+1];
    BOOL bCopyResult;
    HANDLE hCopyFileSearch;
    
    //
    // First determine if it exists already, we don't want to overwrite
    //

    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s%s\\%s\\%s.cms"), g_szCmakdir, 
        c_pszProfiles, pszName, pszName));

    if (!FileExists(szTemp))
    {
        //  
        // Profile does not exist locally, create profile and platform sub-dirs
        //

        MYVERIFY(CELEMS(szProfileDestDir) > (UINT)wsprintf(szProfileDestDir, 
            TEXT("%s%s\\%s"), g_szCmakdir, c_pszProfiles, pszName));

        MYVERIFY(0 != CreateDirectory(szProfileDestDir, NULL));

        //
        //  First try to copy the inf from the system directory.  This is the old location.
        //  If it doesn't exist here, then we will pick it up when we copy the profile directory, so
        //  don't report an error on failure.
        //      

        MYVERIFY(0 != GetSystemDirectory(szTemp, CELEMS(szTemp)));
        MYVERIFY(CELEMS(szOldInf) > (UINT)wsprintf(szOldInf, TEXT("%s\\%s.inf"), 
            szTemp, pszName));
        
        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s.inf"), 
            szProfileDestDir, pszName));

        
        if (FileExists(szOldInf))
        {
            MYVERIFY(0 != CopyFile(szOldInf, szTemp, FALSE));
        }

        //
        // Start copying files
        //

        MYVERIFY (CELEMS(szFindFilePath) > (UINT)wsprintf(szFindFilePath, TEXT("%s\\*.*"), 
            pszExistingProfileDir));

        hCopyFileSearch = FindFirstFile(szFindFilePath, &FindData);
        if (hCopyFileSearch != INVALID_HANDLE_VALUE)
        {
            do
            {
                if ((FindData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY) == 0)
                {
                    MYVERIFY (CELEMS(szTempDest) > (UINT)wsprintf(szTempDest, TEXT("%s\\%s"), szProfileDestDir, FindData.cFileName));

                    MYVERIFY (CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s"), pszExistingProfileDir, FindData.cFileName));

                    MYVERIFY(0 != CopyFile(szTemp, szTempDest, FALSE));
                    MYVERIFY(0 != SetFileAttributes(szTempDest, FILE_ATTRIBUTE_NORMAL));
                }

                bCopyResult = FindNextFile(hCopyFileSearch,&FindData);

            } while (TRUE == bCopyResult);

            MYVERIFY(0 != FindClose(hCopyFileSearch));
        }

        //4404 - don't copy .cmp with user information in it. always create new.
    }
}




//+----------------------------------------------------------------------------
//
// Function:  GetProfileDirAndShortSvcNameFromCmpFilePath
//
// Synopsis:  
//
// Arguments: IN LPCTSTR szCmpFileLocation - Cmp File location of the profile
//            OUT LPTSTR pszShortServiceName - returns the ShortServiceName of the profile
//            OUT LPTSTR pszProfileDirLocation - returns the Full path to the profile dir
//            IN UINT uiStrLen - Length of the buffer pointed to by pszProfileDirLocation
//                               in characters.
//
// Returns:   TRUE if successful
//
// History:   quintinb Created    6/24/98
//
//+----------------------------------------------------------------------------
BOOL GetProfileDirAndShortSvcNameFromCmpFilePath(IN LPCTSTR pszCmpFileLocation, 
                                                 OUT LPTSTR pszShortServiceName, 
                                                 OUT LPTSTR pszProfileDirLocation, 
                                                 IN UINT uiStrLen)
{
    //
    //  Check Inputs
    //
    MYDBGASSERT(pszCmpFileLocation);
    MYDBGASSERT(pszProfileDirLocation);
    MYDBGASSERT(pszShortServiceName);
    MYDBGASSERT(0 != uiStrLen);
    MYDBGASSERT(TEXT('\0') != pszCmpFileLocation[0]);

    if ((NULL == pszCmpFileLocation) || 
        (TEXT('\0') == pszCmpFileLocation[0]) ||
        (NULL == pszProfileDirLocation) ||
        (NULL == pszShortServiceName) ||
        (0 == uiStrLen)
        )
    {
        return FALSE;
    }

    //
    //  Split the input cmp path
    //
    CFileNameParts FileParts(pszCmpFileLocation);

    //
    //  Construct the cms path from the cmp path parts
    //
    MYVERIFY(uiStrLen > (UINT)wsprintf(pszProfileDirLocation, TEXT("%s%s%s"), FileParts.m_Drive, FileParts.m_Dir, FileParts.m_FileName));

    //
    //  Short Service Names are 8.3
    //
    MYVERIFY(9 > (UINT)wsprintf(pszShortServiceName, TEXT("%s"), FileParts.m_FileName));

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CopyInstalledProfilesForCmakToEdit
//
// Synopsis:  This function finds all the installed profiles that a user has
//            access to and copies them to the CMAK\Profiles-32 directory so
//            the user may edit them in CMAK.  To do this it enumerates both
//            the HKLM and the current HKCU Connection Manager Mappings keys
//            and calls CopyNonLocalProfile on each found profile.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created  6/24/98
//
//+----------------------------------------------------------------------------
void CopyInstalledProfilesForCmakToEdit()
{
    HKEY hKey;
    HKEY hBaseKey;
    DWORD dwType;
    LPTSTR pszCurrentValue = NULL;
    LPTSTR pszCurrentData = NULL;
    TCHAR szShortServiceName[MAX_PATH+1];
    TCHAR szCurrentProfileDirPath[MAX_PATH+1];
    LPTSTR pszExpandedPath = NULL;

    for (int i=0; i < 2; i++)
    {
        //
        //  First Load the Single User Profiles (we want to give preference to loading these if
        //  they happen to have it installed both all user and single user)
        //        
        if (0 == i)
        {
             hBaseKey = HKEY_CURRENT_USER;
        }
        else
        {
             hBaseKey = HKEY_LOCAL_MACHINE;        
        }

        if (ERROR_SUCCESS == RegOpenKeyEx(hBaseKey, c_pszRegCmMappings, 0, KEY_ALL_ACCESS, &hKey))
        {
            DWORD dwValueBufSize = 0;
            DWORD dwDataBufSize = 0;

            //
            //  figure out how big the buffers need to be
            //
            if (ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &dwValueBufSize, &dwDataBufSize, NULL, NULL))
            {

                //
                //  Increment the count we got back to include the terminating NULL char
                //
                dwValueBufSize++;
                dwDataBufSize += 2; // this is in bytes

                //
                //  allocate the space we need
                //
                pszCurrentValue = (LPTSTR) CmMalloc(dwValueBufSize * sizeof(TCHAR));
                pszCurrentData  = (LPTSTR) CmMalloc(dwDataBufSize);

                CMASSERTMSG(pszCurrentValue && pszCurrentData, TEXT("CopyInstalledProfilesForCmakToEdit -- CmMalloc failed allocating value and data buffers."));
                if (pszCurrentValue && pszCurrentData)
                {
                    DWORD dwIndex = 0;
                    DWORD dwValueSize = dwValueBufSize;     // only used for the in/out param
                    DWORD dwDataSize = dwDataBufSize;       // only used for the in/out param
                    
                    while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, pszCurrentValue, &dwValueSize, NULL, &dwType, (LPBYTE)pszCurrentData, &dwDataSize))
                    {
                        if (REG_SZ == dwType)
                        {
                            MYDBGASSERT(0 != pszCurrentValue[0]);
                            MYDBGASSERT(0 != pszCurrentData[0]);
                            
                            //
                            //  Expand environment strings if necessary (single user profiles contain the 
                            //  %USERPROFILE% environment var).
                            //
                            DWORD dwDataSizeExpanded = ExpandEnvironmentStrings(pszCurrentData, NULL, 0);

                            CMASSERTMSG((dwDataSizeExpanded != 0),
                                TEXT("CopyInstalledProfilesForCmakToEdit -- Error expanding environment vars."));

                            if (dwDataSizeExpanded)
                            {
                                pszExpandedPath = (LPTSTR) CmMalloc(dwDataSizeExpanded * sizeof(TCHAR));

                                if (NULL != pszExpandedPath)
                                {
                                    DWORD dwTmp = ExpandEnvironmentStrings(pszCurrentData, pszExpandedPath, dwDataSizeExpanded);
                                    MYDBGASSERT(dwTmp == dwDataSizeExpanded);

                                    if (dwTmp)
                                    {
                                        MYVERIFY(0 != GetProfileDirAndShortSvcNameFromCmpFilePath(pszExpandedPath, 
                                            szShortServiceName, szCurrentProfileDirPath,
                                            CELEMS(szCurrentProfileDirPath)));

                                        MYDBGASSERT(0 != szCurrentProfileDirPath[0]);
                                        MYDBGASSERT(0 != szShortServiceName[0]);

                                        CopyNonLocalProfile(szShortServiceName, szCurrentProfileDirPath);
                                    }

                                    CmFree(pszExpandedPath);
                                }
                            }
                        }

                        dwValueSize = dwValueBufSize;
                        dwDataSize = dwDataBufSize;
                        dwIndex++;
                    }

                    CmFree(pszCurrentValue);
                    CmFree(pszCurrentData);
                }
            }
            MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
        }
    }
}




//+----------------------------------------------------------------------------
//
// Function:  GetLangFromInfTemplate
//
// Synopsis:  Wrote to replace GetLangFromDir.  This function gets the LCID value
//            from an inf and then calls GetLocaleInfo to get the Language Display
//            name.
//
// Arguments: LPCTSTR szFullInfPath - full path to the inf file
//            OUT LPTSTR pszLanguageDisplayName - out param to hold the display name of the LCID value
//            IN int iCharsInBuffer - number of chars in the out buffer
//
// Returns:   BOOL - TRUE if successful
//
// History:   quintinb  Created Header    8/8/98
//
//+----------------------------------------------------------------------------
BOOL GetLangFromInfTemplate(LPCTSTR szFullInfPath, OUT LPTSTR pszLanguageDisplayName, IN int iCharsInBuffer)
{
    TCHAR szTemp[MAX_PATH+1] = TEXT("");

    MYDBGASSERT(NULL != szFullInfPath);
    MYDBGASSERT(TEXT('\0') != szFullInfPath[0]);
    MYDBGASSERT(NULL != pszLanguageDisplayName);
    MYDBGASSERT(0 < iCharsInBuffer);

    if (FileExists(szFullInfPath))
    {
        //
        //  First check for the new LCID location under strings, we shouldn't need to
        //  check both places because it is template.inf but we will anyway just for
        //  completeness.
        //
        if (0 == GetPrivateProfileString(c_pszInfSectionStrings, c_pszCmLCID, 
                                         TEXT(""), szTemp, CELEMS(szTemp), szFullInfPath))
        {        
            //
            //  If the new key didn't exist, then try the old [Intl] section and
            //  display key.  The change was made during the CMAK Unicode changes to
            //  make the inf template easier to localize.
            //
            MYVERIFY(0 != GetPrivateProfileString(c_pszIntl, c_pszDisplay, 
                TEXT(""), szTemp, CELEMS(szTemp), szFullInfPath));
        }

        //
        //  Now try to extract the LCID from the string if we have one.
        //
        if (TEXT('\0') != szTemp[0])
        {
            //
            // This value should be an LCID so a negative value is invalid anyway
            //
            DWORD dwLang = (DWORD)_ttol(szTemp);
            
            int nResult = GetLocaleInfo(dwLang, LOCALE_SLANGUAGE | LOCALE_USE_CP_ACP, 
                pszLanguageDisplayName, iCharsInBuffer);

            if (0 == nResult)
            {
                ZeroMemory(pszLanguageDisplayName, sizeof(TCHAR)*iCharsInBuffer);
                return FALSE;
            }
            else
            {
                return TRUE;
            }
        }    
    }
    else
    {
        CMTRACE1(TEXT("GetLangFromInfTemplate can't find %s"), szFullInfPath);
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  GetLocalizedLanguageNameFromLCID
//
// Synopsis:  This function returns the language name of the given LCID in the
//            language of the current system default language.
//
// Arguments: DWORD dwLCID - Locale Identifier to get the language for
//
// Returns:   LPTSTR - returns NULL if unsuccessful, a pointer to the string
//                     otherwise.  The Caller is responsible for CmFree-ing it.
//
// History:   quintinb Created     6/17/99
//
//+----------------------------------------------------------------------------
LPTSTR GetLocalizedLanguageNameFromLCID(DWORD dwLCID)
{
    LPTSTR pszReturnString = NULL;
    LPTSTR pszTmp = NULL;

    if (dwLCID)
    {
        int nCharsNeeded = GetLocaleInfo(dwLCID, LOCALE_SLANGUAGE, NULL, 0);
        pszTmp = (LPTSTR)CmMalloc(nCharsNeeded*sizeof(TCHAR) + sizeof(TCHAR)); // one extra for the NULL

        if (pszTmp)
        {
            nCharsNeeded = GetLocaleInfo(dwLCID, LOCALE_SLANGUAGE, pszTmp, nCharsNeeded);
            if (0 != nCharsNeeded)
            {
                pszReturnString = pszTmp;        
            }
        }
    }

    return pszReturnString;
}

  
//+----------------------------------------------------------------------------
//
// Function:  GetDoNotShowLcidMisMatchDialogRegValue
//
// Synopsis:  This function gets the registry key value which stores whether
//            the user has checked the box on the Lcids don't match dialog
//            displayed by CMAK which says, "Don't show this dialog again".
//
//
// Arguments: None
//
// Returns:   BOOL - TRUE if cmak should NOT show the dialog or FALSE if it should
//
// History:   quintinb Created     03/22/2001
//
//+----------------------------------------------------------------------------
BOOL GetDoNotShowLcidMisMatchDialogRegValue()
{
    BOOL bReturn = FALSE;
    HKEY hKey;

    LONG lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmak, 0, KEY_READ, &hKey);

    if (ERROR_SUCCESS == lResult)
    {
        DWORD dwType = 0;
        DWORD dwDoNotShowDialog = 0;
        DWORD dwSize = sizeof(DWORD);

        lResult = RegQueryValueEx(hKey, c_pszDoNotShowLcidMisMatchDialog, NULL, &dwType, 
                                  (LPBYTE)&dwDoNotShowDialog, &dwSize);
                
        if (ERROR_SUCCESS == lResult)
        {
            bReturn = (BOOL)dwDoNotShowDialog;
        }

        RegCloseKey(hKey);
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  SetDoNotShowLcidMisMatchDialogRegValue
//
// Synopsis:  This function sets the registry key value which stores whether
//            the user has checked the box on the Lcids don't match dialog
//            displayed by CMAK which says, "Don't show this dialog again".
//
//
// Arguments: DWORD dwValueToSet - TRUE or FALSE value that should be set in reg
//
// Returns:   BOOL - TRUE if the value was set successfully, FALSE otherwise
//
// History:   quintinb Created     03/22/2001
//
//+----------------------------------------------------------------------------
BOOL SetDoNotShowLcidMisMatchDialogRegValue(DWORD dwValueToSet)
{
    HKEY hKey;
    BOOL bReturn = FALSE;

    LONG lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmak, 0, KEY_WRITE, &hKey);

    if (ERROR_SUCCESS == lResult)
    {
        lResult = RegSetValueEx(hKey, c_pszDoNotShowLcidMisMatchDialog, NULL, REG_DWORD, 
                                  (LPBYTE)&dwValueToSet, sizeof(DWORD));
                
        if (ERROR_SUCCESS == lResult)
        {
            bReturn = TRUE;
        }

        RegCloseKey(hKey);
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessLCIDsDontMatchPopup
//
// Synopsis:  Processes windows messages for the dialog which tells the user they
//            have a mismatch between the system locale and the language of CMAK
//            itself.  Note that we pass in a pointer to the message string containing
//            the language names through the lParam parameter.
//
// Arguments: WND hDlg - dialog window handle
//            UINT message - message identifier
//            WPARAM wParam - wParam Value 
//            LPARAM lParam - lParam Value
//
//
// History:   quintinb  Created     03/22/01
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessLCIDsDontMatchPopup(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    DWORD dwChecked = 0;
    SetDefaultGUIFont(hDlg, message, IDC_MSG);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_LCID_POPUP)) return TRUE;

    switch (message)
    {
        case WM_INITDIALOG:

            //
            //  We need to set the text passed through the lParam parameter
            //  to the IDC_MSG control.
            //
            if (lParam)
            {
                LPTSTR pszMsg = (LPTSTR)lParam;
                MYVERIFY(TRUE == SendDlgItemMessage (hDlg, IDC_MSG, WM_SETTEXT, (WPARAM)0, (LPARAM)pszMsg));
            }

            break;
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK: // Continue

                    //
                    //  Get the value of the "Do not show me this dialog again", checkbox
                    //  and save it to the registry
                    //
                    dwChecked = IsDlgButtonChecked(hDlg, IDC_CHECK1);
                    MYVERIFY(FALSE != SetDoNotShowLcidMisMatchDialogRegValue(dwChecked));

                    MYVERIFY(0 != EndDialog(hDlg, IDOK));
                    return TRUE;
                    break;

                case IDCANCEL: // Cancel
                    MYVERIFY(0 != EndDialog(hDlg, IDCANCEL));
                    return TRUE;
                    break;

                default:
                    break;
            }
            break;

        default:
            return FALSE;
    }
    return FALSE;   
}

//+----------------------------------------------------------------------------
//
// Function:  DisplayLcidsDoNotMatchDialog
//
// Synopsis:  This function handles the details of displaying the Lcids don't
//            match dialog.  Including such details as checking the registry
//            key to see if the user has already seen the message and asked
//            not to see it again, loading the proper string resources, displaying
//            the dialog, and processing the user's answer.
//
//
// Arguments: HINSTANCE hInstance - Instance handle for resources
//            DWORD dwCmakNativeLCID - LCID of CMAK itself
//            DWORD dwSystemDefaultLCID - current system LCID
//
// Returns:   BOOL - TRUE if cmak should continue, FALSE if it should exit
//
// History:   quintinb Created     03/26/2001
//
//+----------------------------------------------------------------------------
BOOL DisplayLcidsDoNotMatchDialog(HINSTANCE hInstance, DWORD dwCmakNativeLCID, DWORD dwSystemDefaultLCID)
{
    //
    //  If we are in here, then the CMAK LCID and the Default System LCID
    //  have a different Primary language (Japanese vs English for instance).
    //  Thus we want to warn the user that they can continue but that the
    //  language version of CM is potentially going to be different than the
    //  language version of the text that they are typing into the profile.
    //  It would probably be a better user experience to use the native version 
    //  of CMAK that makes the language you have set as your default locale.
    //  First, however, we need to check to see if a registry value exists which
    //  tells us the user has already seen the dialog and asked not to see it again...
    //

    BOOL bReturn = TRUE;

    if (FALSE == GetDoNotShowLcidMisMatchDialogRegValue())
    {
        //
        //  Get the Language Names of the Two LCIDs (sys default and CMAK lang)
        //
        LPTSTR pszSystemLanguage = GetLocalizedLanguageNameFromLCID(dwSystemDefaultLCID);
        LPTSTR pszCmakLanguage = GetLocalizedLanguageNameFromLCID(dwCmakNativeLCID);
        LPTSTR pszFmtString = CmLoadString(hInstance, IDS_LCIDS_DONT_MATCH);

        if (pszSystemLanguage && pszCmakLanguage && pszFmtString)
        {
            LPTSTR pszMsg = (LPTSTR)CmMalloc(sizeof(TCHAR)*(lstrlen(pszSystemLanguage) + 
                                             lstrlen(pszCmakLanguage) + lstrlen(pszFmtString) + 1));

            if (pszMsg)
            {
                wsprintf(pszMsg, pszFmtString, pszSystemLanguage, pszCmakLanguage);

                INT_PTR nResult = DialogBoxParam(NULL, MAKEINTRESOURCE(IDD_LCIDS_DONT_MATCH_POPUP), NULL, 
                                                 (DLGPROC)ProcessLCIDsDontMatchPopup,(LPARAM)pszMsg);

                if (IDCANCEL == nResult)
                {
                    bReturn = FALSE;
                }

                CmFree(pszMsg);
            }
        }

        CmFree(pszSystemLanguage);
        CmFree(pszCmakLanguage);
        CmFree(pszFmtString);
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  CheckLocalization
//
// Synopsis:  This function checks to make sure that the current default 
//            system language has a default ANSI code page and that the
//            CMAK Native language (what it is localized to) and the current
//            default system language are in the same language family.  If there
//            is no default ANSI code page or the LCIDs of CMAK and the system
//            don't match, then we throw an error message.
//
//
// Arguments: HINSTANCE hInstance - Instance handle for resources
//
// Returns:   BOOL - TRUE if cmak should continue, FALSE if it should exit
//
// History:   quintinb Created     6/25/99
//
//+----------------------------------------------------------------------------
BOOL CheckLocalization(HINSTANCE hInstance)
{
    TCHAR szTemp[MAX_PATH+1];
    BOOL bReturn = TRUE;

    //
    //  Check localization requirements.  We want to make sure that the current system 
    //  default language has an ANSI code page, otherwise we are not going to be
    //  able to convert the Unicode text that the user types in to anything that we
    //  can store in our ANSI text data store (ini files).
    //  

    DWORD dwSystemDefaultLCID = GetSystemDefaultLCID();
    CMTRACE1(TEXT("CheckLocalization -- System Default LCID is %u"), dwSystemDefaultLCID);

    GetLocaleInfo(dwSystemDefaultLCID, LOCALE_IDEFAULTANSICODEPAGE, szTemp, CELEMS(szTemp));
    DWORD dwAnsiCodePage = CmAtol(szTemp);

    if (0 == dwAnsiCodePage)
    {
        //
        //  Then this LCID has no ANSI code page and we need to throw an error.  The user
        //  will not be able to create a profile without an ANSI codepage of some sort.
        //        
        int iReturn = ShowMessage(NULL, IDS_NO_ANSI_CODEPAGE, MB_YESNO);

        if (IDNO == iReturn)
        {
            return FALSE;
        }
    }
    else
    {
        //
        //  We have an ANSI codepage, very good.  We want to check and see if the current language the
        //  user is using is different from that of CMAK itself.  If so, then we need to tell the user
        //  that the language they are entering and the language of the CM bits are different.  While this
        //  is okay, it may not provide the experience they are looking for.
        //
        
        //
        //  Get the CMAK Native LCID
        //
        CmakVersion CmakVer;
        DWORD dwCmakNativeLCID = CmakVer.GetNativeCmakLCID();
        BOOL bSeenDialog = FALSE;

        //
        //  Compare the Primary Lang IDs of the language that CMAK is in and the language
        //  the system locale is set to (this tells us what code page is loaded.
        //
        if (!ArePrimaryLangIDsEqual(dwCmakNativeLCID, dwSystemDefaultLCID))
        {
            bReturn = DisplayLcidsDoNotMatchDialog(hInstance, dwCmakNativeLCID, dwSystemDefaultLCID);
            bSeenDialog = TRUE;
        }

        //
        //  Now load the Native CMAK LCID from the CMAK resources.  If this doesn't match
        //  what we got from above we know MUI is involved and we still could have a problem
        //  as the user may be entering text in a different language then what we are expecting.
        //
        if (!bSeenDialog)
        {
            MYVERIFY(0 != LoadString(hInstance, IDS_NATIVE_LCID, szTemp, CELEMS(szTemp)));
            dwCmakNativeLCID = CmAtol(szTemp);

            if (!ArePrimaryLangIDsEqual(dwCmakNativeLCID, dwSystemDefaultLCID))
            {
                bReturn = DisplayLcidsDoNotMatchDialog(hInstance, dwCmakNativeLCID, dwSystemDefaultLCID);
            }
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  WinMain
//
// Synopsis:  Main function for CMAK.  Basically does some initialization and
//            then launches the wizard.
//
//
// History: quintinb on 8/26/97:  made changes to fix bug 10406, see below  
//          quintinb  Created new style Header    3/29/98
//
//+----------------------------------------------------------------------------
int APIENTRY WinMain(
    HINSTANCE, //hInstance
    HINSTANCE, //hPrevInstance
    LPSTR, //lpCmdLine
    int nCmdShow
    )
{
    LPTSTR lpfilename;
    int nresult;
    TCHAR szSaveDir[MAX_PATH+1];
    TCHAR szTemp[2*MAX_PATH+1];
    HWND hwndPrev;
    HWND hwndChild;
    BOOL bTempDirExists; // added by quintinb, please see comment below
    HINSTANCE hInstance = GetModuleHandle(NULL);
    LPTSTR lpCmdLine = GetCommandLine();
    DWORD dwFlags;
    INITCOMMONCONTROLSEX InitCommonControlsExStruct = {0};

    g_hInstance = hInstance;

    //
    //  Process Command Line Arguments
    //
    ZeroMemory(szTemp, sizeof(szTemp));
    const DWORD c_dwIeakBuild = 0x1;
    ArgStruct Args;

    Args.pszArgString = TEXT("/o");
    Args.dwFlagModifier = c_dwIeakBuild;

    {   // Make sure ArgProcessor gets destructed properly and we don't leak mem

        CProcessCmdLn ArgProcessor(1, (ArgStruct*)&Args, TRUE, 
            TRUE); //bSkipFirstToken == TRUE, bBlankCmdLnOkay == TRUE

        if (ArgProcessor.GetCmdLineArgs(lpCmdLine, &dwFlags, szTemp, 2*MAX_PATH))
        {
            g_bIEAKBuild = dwFlags & c_dwIeakBuild;
        }
    }

    //
    // Get the name product name from resource, now we're just a lowly component.
    //

    MYVERIFY(0 != LoadString(g_hInstance, IDS_APP_TITLE, g_szAppTitle, MAX_PATH));

    // Check if already executing program by trying to set Mutex
    MYVERIFY(NULL != CreateMutex(NULL, TRUE, TEXT("spwmutex")));
    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        // if error, then must already be in use by first instance
        hwndPrev = FindWindow(NULL, c_pszAppCaption);
        if (!hwndPrev) 
        {
            // check for error message box
            hwndPrev = FindWindow(NULL, g_szAppTitle);
            if (!hwndPrev)
            {
                return CMAK_RETURN_ERROR;
            }
        }

        // Bring up previous executing copy to the top.
        ShowWindow(hwndPrev,SW_SHOWNORMAL);
        hwndChild = GetLastActivePopup(hwndPrev);
        MYVERIFY(0 != BringWindowToTop(hwndPrev));
        if (IsIconic(hwndPrev)) 
        {
            ShowWindow(hwndPrev,SW_RESTORE);
        }
        if (hwndChild != hwndPrev) 
        {
            MYVERIFY(0 != BringWindowToTop(hwndChild));
        }

        MYVERIFY(0 != SetForegroundWindow(hwndChild));

        return CMAK_RETURN_ERROR;
    }

    // save off the current instance
    g_szPhonebk[0] = TEXT('\0');
    g_szRegion[0] = TEXT('\0');
    g_szHelp[0] = TEXT('\0');
    g_szLicense[0] = TEXT('\0');
    g_szPhoneName[0] = TEXT('\0');
    g_szCmProxyFile[0] = TEXT('\0');
    g_szCmRouteFile[0] = TEXT('\0');
    g_szVpnFile[0] = TEXT('\0');


    // SearchPath will return only the ugly filename format of the path.
    // On NT, it works
    // On 95, it returns upper case form.

    nresult = SearchPath(NULL, c_pszCmakExe, NULL, CELEMS(g_szCmakdir), g_szCmakdir, &lpfilename);
    if (nresult == 0)
    {
        FileAccessErr(NULL, c_pszCmakExe);
        return CMAK_RETURN_ERROR;
    }

    // delete the file name to leave the exe directory
    *lpfilename = TEXT('\0');

    if (ERROR_SUCCESS != RegisterBitmapClass(hInstance))
    {
        return CMAK_RETURN_ERROR;
    }

    //
    //  Make sure we have a temp directory and then create %TEMP%\cmaktemp
    //

    MYVERIFY(0 != GetCurrentDirectory(MAX_PATH, szSaveDir));

    MYVERIFY(0 != GetTempPath(CELEMS(g_szTempDir), g_szTempDir));
    // begin changes by quintinb on 8/26/97
    // added to handle bug 10406
    bTempDirExists = SetCurrentDirectory(g_szTempDir);
    if (!bTempDirExists)
    {
        // temp dir doesn't exist even though the system thinks it does,
        // so create it and everybody is happy
        MYVERIFY(0 != CreateDirectory(g_szTempDir, NULL));
    }
    // end changes by quintinb on 8/26/97
    _tcscat(g_szTempDir,TEXT("cmaktemp"));

    MYDBGASSERT(_tcslen(g_szTempDir) <= CELEMS(g_szTempDir));
    
    MYVERIFY(0 != CreateDirectory(g_szTempDir,NULL));

    //
    //  Fill in the path for the support directory, we will need it below
    //
    MYVERIFY(CELEMS(g_szSupportDir) > (UINT)wsprintf(g_szSupportDir, 
        TEXT("%s%s"), g_szCmakdir, c_pszSupport));

    //
    //  Now we need to check that we have compatible versions of cmak.exe and cmbins.exe.
    //  In the win64 case, we have no cmbins.exe so we use the native cmdial32.dll in
    //  system32.  On x86, we need to open the CM binaries cab and check the version of cmdial32.dll
    //  to ensure that they are compatible.  For instance different versions (5.0 vs 5.1)
    //  shouldn't work together.  We also don't want CMAK to work with
    //  a cmdial that is of the same version but the cmdial has a lower build number.
    //

#ifdef _WIN64
    //
    //  On Win64 we are using the native cmdial32.dll in system32
    //
    CmVersion CmDialVer;
#else
    //
    //  Extract the CM binaries from the cmbins.exe so that we can get
    //  the version number from cmdial32.dll and can get the correct version
    //  of cmstp.exe to put in the cab.
    //
    wsprintf(g_szCmBinsTempDir, TEXT("%s\\cmbins"), g_szTempDir);
    if (FAILED(ExtractCmBinsFromExe(g_szSupportDir, g_szCmBinsTempDir)))
    {
        CMASSERTMSG(FALSE, TEXT("WinMain -- ExtractCmBinsFromExe Failed."));
        return CMAK_RETURN_ERROR;
    }

    wsprintf(szTemp, TEXT("%s\\cmdial32.dll"), g_szCmBinsTempDir);

    CVersion CmDialVer(szTemp);
#endif

    CmakVersion CmakVer;

    if (CmDialVer.IsPresent())
    {
        const DWORD c_dwCmakBuildNumber = VER_PRODUCTBUILD;
        
        if ((c_dwCurrentCmakVersionNumber < CmDialVer.GetVersionNumber()))
        {
            //
            //  Then we have a newer version of CM then we know how to handle,
            //  throw an error and exit
            //
            MYVERIFY(IDOK == ShowMessage(NULL, IDS_CM_TOO_NEW, MB_OK));
            g_iCMAKReturnVal = CMAK_RETURN_ERROR;
            goto exit;
        }
        else if ((c_dwCurrentCmakVersionNumber > CmDialVer.GetVersionNumber()) || 
                ((c_dwCurrentCmakVersionNumber == CmDialVer.GetVersionNumber()) && 
                 (c_dwCmakBuildNumber > CmDialVer.GetBuildNumber())))
        {
            //
            //  Then we have a older version of CM then we need,
            //  throw an error and exit
            //
            MYVERIFY(IDOK == ShowMessage(NULL, IDS_CM_TOO_OLD, MB_OK));
            g_iCMAKReturnVal = CMAK_RETURN_ERROR;
            goto exit;
        }
    }
    else
    {
        //
        //  Then we have no CM bits, lets throw an error
        //
        MYVERIFY(IDOK == ShowMessage(NULL, IDS_NO_CM_BITS, MB_OK));
        g_iCMAKReturnVal = CMAK_RETURN_ERROR;
        goto exit;
    }

    //
    //  Setup the profiles path in Temp
    //
    g_szShortServiceName[0] = TEXT('\0');
    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s%s"), g_szCmakdir, c_pszProfiles));
    
    if (0 == SetCurrentDirectory(szTemp))
    {
        MYVERIFY(0 != CreateDirectory(szTemp, NULL));
        MYVERIFY(0 != SetCurrentDirectory(szTemp));
    }

    //
    //  We need to make sure that the user has Read/Write
    //  permissions to the Profiles directory.  Otherwise they can
    //  get themselves into the situation where they would build a
    //  whole profile and lose all of the work because they couldn't
    //  save it to the output directory (since we work out of the temp
    //  dir until we actually build the cab itself).  NTRAID 372081
    //  Also note that since this function is shared by cmdial we use
    //  function pointers (here just the function names themselves)
    //  for items that cmdial32.dll doesn't statically link to so that
    //  it can dynamically link to them but still use the same code while
    //  allowing cmak not to have to do the dynamic link.  Quirky but it
    //  works.
    //

    if (!HasSpecifiedAccessToFileOrDir(szTemp, FILE_GENERIC_READ | FILE_GENERIC_WRITE))
    {
        //
        //  Then we need to throw an error to the user and exit.
        //
        
        LPTSTR pszTmp = CmLoadString(g_hInstance, IDS_INSUFF_PERMS);

        if (pszTmp)
        {
            DWORD dwSize = lstrlen(pszTmp) + lstrlen(szTemp) + 1;
            LPTSTR pszMsg = (LPTSTR)CmMalloc(dwSize*sizeof(TCHAR));

            if (pszMsg)
            {
                wsprintf(pszMsg, pszTmp, szTemp);
                MessageBox(NULL, pszMsg, g_szAppTitle, MB_OK | MB_ICONERROR | MB_TASKMODAL);
                CmFree(pszMsg);
            }

            CmFree(pszTmp);
        }

        g_iCMAKReturnVal = CMAK_RETURN_ERROR;
        goto exit;
    }

    //
    //  Grab all the installed CM profiles and copy them
    //  to the CMAK dir so that they can be edited.
    //
    CopyInstalledProfilesForCmakToEdit();

    LoadServiceProfiles();

    //
    //  Ensure that the directory CMAK\Support exists
    //
    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s%s"), g_szCmakdir, c_pszSupport));
    
    if (0 == SetCurrentDirectory(szTemp))
    {
        MYVERIFY(IDOK == ShowMessage(NULL, IDS_NOLANGRES, MB_OK));
        g_iCMAKReturnVal = CMAK_RETURN_ERROR;
        goto exit;
    }

    MYVERIFY(0 != SetCurrentDirectory(szSaveDir));

    if (!CheckLocalization(g_hInstance))
    {
        g_iCMAKReturnVal = CMAK_RETURN_CANCEL;
        goto exit;
    }

    //
    //  Initialize the common controls
    //
    InitCommonControlsExStruct.dwSize = sizeof(InitCommonControlsExStruct);
    InitCommonControlsExStruct.dwICC = ICC_INTERNET_CLASSES | ICC_LISTVIEW_CLASSES;
    
    if (FALSE == InitCommonControlsEx(&InitCommonControlsExStruct))
    {
        g_iCMAKReturnVal = CMAK_RETURN_ERROR;
        goto exit;
    }

    g_pCustomActionList = new CustomActionList();

    MYVERIFY(-1 != CreateWizard(NULL));

    //
    //  Make sure to delete the CustomActionList Class, it is
    //  allocated on the custom action screen.
    //
    delete g_pCustomActionList;

exit:

    EraseTempDir();
    ExitProcess((UINT)g_iCMAKReturnVal);
    return g_iCMAKReturnVal;
                                                 
}   //lint !e715 we don't use nCmdShow, lpCmdLine, nor hPrevInstance


//+----------------------------------------------------------------------------
//
// Function:  DoBrowse
//
// Synopsis:  This function does the necessary work to pop up a Browse Common Dialog (either for
//            saving files or for opening files depending on the SaveAs flag).
//
// Arguments: WND hDlg - handle of current dialog
//            UINT IDS_FILTER - ID for display filter description
//            LPTSTR lpMask - file filter (*.ext)
//            int IDC_EDIT - ID of edit field
//            LPCTSTR lpDefExt - file filter extension (ext)
//            LPTSTR lpFile - path/filename currently selected file on input and output
//
// Returns:   Returns 1 if successful, -1 if the user hit cancel, and 0 if there was an error.
//
// History:     quintinb    8-26-97
//              Reorganized and rewrote most of this function to resolve bug # 13159.
//              Tried to keep the original variable names and style as much as possible 
//              to keep the code style the same. 
//
// 
//              quintinb    01/22/1998     changed the return value to int so that we could
//                                         return -1 on cancel and 0 on error and distinguish the
//                                         two cases.
//              quintinb    07/13/1998     changed the function prototype so that more than one filter/mask
//                                         pair could be specified.
//              quintinb    01/14/2000     Remove SaveAs functionality as it was no longer used
//
//+----------------------------------------------------------------------------
int DoBrowse(HWND hDlg, UINT* pFilterArray, LPTSTR* pMaskArray, UINT uNumFilters, int IDC_EDIT, LPCTSTR lpDefExt, LPTSTR lpFile)
{
    OPENFILENAME filedef;
    TCHAR szMsg[MAX_PATH+1];
    TCHAR szFile[MAX_PATH+1];
    TCHAR* pszFilter = NULL;
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szDir[MAX_PATH+1];
    TCHAR szFileTitle[MAX_PATH+1];
    int nResult;
    LPTSTR lpfilename;
    int iReturnValue;

    //
    //  Check Inputs
    //

    MYDBGASSERT(uNumFilters);
    MYDBGASSERT(pFilterArray);
    MYDBGASSERT(pMaskArray);

    if ((NULL == pFilterArray) ||
        (NULL == pMaskArray) ||
        (0 == uNumFilters))
    {
        return FALSE;
    }

    ZeroMemory(&filedef, sizeof(OPENFILENAME));

    szFile[0] = TEXT('\0');
    szDir[0] = TEXT('\0');

    //
    //  Allocate Memory for the Filter string
    //

    pszFilter = (TCHAR*)CmMalloc(sizeof(TCHAR)*MAX_PATH*uNumFilters);
    
    if (pszFilter)
    {
        ZeroMemory(pszFilter, sizeof(TCHAR)*MAX_PATH*uNumFilters);// REVIEW: This really isn't necessary since CmMalloc always zeros
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("DoBrowse -- CmMalloc returned a NULL pointer"));
        return FALSE;
    }

    //
    // Initialize the OPENFILENAME data structure
    //

    filedef.lStructSize = sizeof(OPENFILENAME); 
    filedef.hwndOwner = hDlg; 
    filedef.hInstance = g_hInstance;
    filedef.lpstrFilter = pszFilter;
    filedef.lpstrCustomFilter = NULL; 
    filedef.nMaxCustFilter = 0; 
    filedef.nFilterIndex = 0; 
    filedef.lpstrFile = szFile;
    filedef.nMaxFile = MAX_PATH;
    filedef.lpstrFileTitle = szFileTitle;
    filedef.nMaxFileTitle = MAX_PATH;
    filedef.lpstrInitialDir = szDir;
    filedef.lpstrTitle = szMsg;
    filedef.Flags = OFN_FILEMUSTEXIST|OFN_LONGNAMES|OFN_PATHMUSTEXIST; 
    filedef.lpstrDefExt = lpDefExt; 

    //
    // create filter string - separated by 0 and ends with 2 0's
    //

    UINT uCurrentCharInBuffer=0;
    UINT uTempChars;

    for (UINT i = 0; i < uNumFilters; i++)
    {
        uTempChars = (UINT)LoadString(g_hInstance, pFilterArray[i], szTemp, MAX_PATH);
        
        if ((MAX_PATH*uNumFilters) <= (uCurrentCharInBuffer + uTempChars))
        {   
            //
            //  We don't want to overrun the buffer
            //
            break;
        }

        _tcscpy(&(pszFilter[uCurrentCharInBuffer]), szTemp);
        uCurrentCharInBuffer += uTempChars;

        uTempChars = (UINT)_tcslen(pMaskArray[i]);

        if ((MAX_PATH*uNumFilters) <= (uCurrentCharInBuffer + uTempChars))
        {   
            //
            //  We don't want to overrun the buffer
            //
            break;
        }

        _tcscpy(&(pszFilter[uCurrentCharInBuffer + 1]), pMaskArray[i]);

        //
        //  Add 2 chars so that we get a \0 between strings.
        //
        uCurrentCharInBuffer = (uCurrentCharInBuffer + uTempChars + 2);
    }


    //
    // if a path/file passed in, find its directory and make it szDir
    //

    if (TEXT('\0') != lpFile[0])
    {
        nResult = GetFullPathName(lpFile, CELEMS(szDir), szDir, &lpfilename);

        if (nResult != 0)
        {
            if (lpfilename) // 13062
            {
                _tcscpy(szFile,lpfilename);
                *lpfilename = TEXT('\0');
            }
        }
    }

    MYVERIFY(0 != LoadString(g_hInstance, IDS_BROWSETITLE, szMsg, MAX_PATH));
        
    //
    // pop up the open dialog
    //
        
    if (GetOpenFileName((OPENFILENAME*)&filedef))
    {
        MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDIT), WM_SETTEXT, 0, (LPARAM)szFileTitle));
        _tcscpy(lpFile, szFile);

        iReturnValue = 1;
    }
    else
    {
        //
        //  If we are in this state than the user could have hit cancel or there could have
        //  been an error.  If the CommDlgExtendedError function returns 0 then we know it was
        //  just a cancel, otherwise we have an error.
        //

        if (0 == CommDlgExtendedError())
        {
           iReturnValue = -1;
        }
        else
        {
            iReturnValue = 0;
        }
    }

    CmFree(pszFilter);
    
    return iReturnValue;
}

INT_PTR APIENTRY ProcessCancel(HWND hDlg, UINT message, LPARAM lParam)
{
    int iRes;
    NMHDR* pnmHeader = (NMHDR*)lParam;

    switch (message)
    {

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {
                case PSN_QUERYCANCEL:
                    
                    iRes = ShowMessage(hDlg, IDS_CANCELWIZ, MB_YESNO);

                    if (iRes==IDYES) 
                    {
                        //
                        //  Free Up the memory we used
                        //

                        ClearCmakGlobals();
                        FreeList(&g_pHeadProfile, &g_pTailProfile);

                        EraseTempDir();
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT,FALSE));
                    }
                    else 
                    {
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT,TRUE));
                    }
                    return TRUE;

                default:
                    return FALSE;
            }
        default:
            return FALSE;
    }
}



//+----------------------------------------------------------------------------
//
// Function:  ProcessHelp
//
// Synopsis:  Processes messages that have to do with the Help button.
//
// Arguments: WND hDlg - dialog handle
//            UINT message - Message ID to process
//            LPARAM lParam - the lParam of the message
//            DWORD_PTR dwHelpId - The Help ID of the page in question 
//                                 (this is the ID that will be launched 
//                                  for a help request from this page).
//
// Returns:   BOOL - TRUE if the message was handled
//
// History:   quintinb Created Header    10/15/98
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessHelp(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, DWORD_PTR dwHelpId)
{
    NMHDR* pnmHeader = (NMHDR*)lParam;

    switch (message)
    {
        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {
                case PSN_HELP:
                    HtmlHelp(hDlg, c_pszCmakOpsChm, HH_HELP_CONTEXT, dwHelpId);   //lint !e534 we don't care about the htmlhelp HWND
                    return TRUE;

                default:
                    return FALSE;
            }
            break;

        case WM_HELP:
            HtmlHelp(hDlg, c_pszCmakOpsChm, HH_HELP_CONTEXT, dwHelpId);   //lint !e534 we don't care about the htmlhelp HWND
            return TRUE;
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_HELPBUTTON:
                    HtmlHelp(hDlg, c_pszCmakOpsChm, HH_HELP_CONTEXT, dwHelpId);   //lint !e534 we don't care about the htmlhelp HWND
                    return TRUE;
                    break;
            }

        default:
            return FALSE;
    }
}



//+----------------------------------------------------------------------------
//
// Function:  ProcessWelcome
//
// Synopsis:  Welcome to the Connection Manager Administration Kit.
//
//
// History:   quintinb Created Header and renamed from ProcessPage1    8/6/98
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessWelcome(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{

    NMHDR* pnmHeader = (NMHDR*)lParam;
    RECT rDlg;
    RECT rWorkArea;
    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_WELCOME)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;

    switch (message)
    {
        case WM_INITDIALOG:
            if (GetWindowRect(GetParent(hDlg),&rDlg) && SystemParametersInfoA(SPI_GETWORKAREA,0,&rWorkArea,0)) 
            {
                MoveWindow(GetParent(hDlg),
                   rWorkArea.left + ((rWorkArea.right-rWorkArea.left)-(rDlg.right-rDlg.left))/2,
                   rWorkArea.top + ((rWorkArea.bottom-rWorkArea.top)-(rDlg.bottom-rDlg.top))/2,
                   rDlg.right-rDlg.left,
                   rDlg.bottom-rDlg.top,
                   FALSE);
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    break;

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                    break;

                case PSN_WIZBACK:
                    break;

                case PSN_WIZNEXT:
                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

void ClearCmakGlobals(void)
{

    //
    //  Free the connect action class
    //
    delete(g_pCustomActionList);
    g_pCustomActionList = NULL;

    FreeDnsList(&g_pHeadDunEntry, &g_pTailDunEntry);
    FreeDnsList(&g_pHeadVpnEntry, &g_pTailVpnEntry);
    FreeList(&g_pHeadExtra, &g_pTailExtra);
    FreeList(&g_pHeadMerge, &g_pTailMerge);
    FreeList(&g_pHeadRefs, &g_pTailRefs);
    FreeList(&g_pHeadRename, &g_pTailRename);
    FreeIconMenu();

    g_szOutExe[0] = TEXT('\0');
    g_szCmsFile[0] = TEXT('\0');
    g_szInfFile[0] = TEXT('\0');
    g_szCmpFile[0] = TEXT('\0');
    g_szSedFile[0] = TEXT('\0');

    EraseTempDir();
    _tcscpy(g_szOutdir, g_szTempDir);

    //
    //  Reset Connect Action Intro Screen
    //
    g_bUseTunneling = FALSE;
}


BOOL EnsureProfileFileExists(LPTSTR pszOutFile, LPCTSTR szTemplateFileName, LPCTSTR szExtension, UINT uCharsInBuffer)
{
    TCHAR szTemp[MAX_PATH+1];

    MYVERIFY(uCharsInBuffer > (UINT)wsprintf(pszOutFile, TEXT("%s\\%s%s"), g_szOutdir, 
        g_szShortServiceName, szExtension));

    if (!FileExists(pszOutFile))
    {        
        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s"), 
            g_szSupportDir, szTemplateFileName));

        if (!CopyFileWrapper(szTemp, pszOutFile, FALSE))
        {
            return FALSE;
        }

        MYVERIFY(0 != SetFileAttributes(pszOutFile, FILE_ATTRIBUTE_NORMAL));

    }

    return TRUE;
}

BOOL IsNativeLCID(LPCTSTR szFullPathToInf)
{
    HANDLE hFile;
    TCHAR szName[MAX_PATH+1] = TEXT("");
    TCHAR szNativeLCID[MAX_PATH+1] = TEXT("");

    hFile = CreateFile(szFullPathToInf, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        MYVERIFY(0 != CloseHandle(hFile));

        //
        //  First check for the new LCID location under strings
        //
        if (0 == GetPrivateProfileString(c_pszInfSectionStrings, c_pszCmLCID, 
                                         TEXT(""), szName, CELEMS(szName), szFullPathToInf))
        {        
            //
            //  If the new key didn't exist, then try the old [Intl] section and
            //  display key.  The change was made during the CMAK Unicode changes to
            //  make the inf template easier to localize.
            //
            MYVERIFY(0 != GetPrivateProfileString(c_pszIntl, c_pszDisplay, 
                TEXT(""), szName, CELEMS(szName), szFullPathToInf));
        }
        
        if (TEXT('\0') != szName[0])
        {
            //
            // This value should be an LCID so a negative value is invalid anyway
            //
            DWORD dwLang = (DWORD)_ttol(szName);
            MYDBGASSERT((long)dwLang >= 0);

            CmakVersion CmakVer;
            DWORD dwNative = CmakVer.GetNativeCmakLCID();

            MYDBGASSERT((long)dwNative >= 0);

            if (dwLang == dwNative)
            {
                return TRUE;
            }
        }
    }
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessAddEditProfile
//
// Synopsis:  Choose whether to create a new profile or edit an existing one.
//
//
// History:   quintinb  Created Header and renamed from ProcessPage1A    8/6/98
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessAddEditProfile(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    INT_PTR nResult;
    INT_PTR lCount;
    TCHAR szName[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szMsg[MAX_PATH+1];
    TCHAR szLanguageDisplayName[MAX_PATH+1];
    NMHDR* pnmHeader = (NMHDR*)lParam;
    static LONG_PTR iCBSel = 0;

    BOOL bNameChanged;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_STARTCUST)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_COMBO1);

    switch (message)
    {
        case WM_INITDIALOG:
        RefreshComboList(hDlg, g_pHeadProfile);
        EnableWindow(GetDlgItem(hDlg, IDC_COMBO1), FALSE);

        lCount = SendDlgItemMessage(hDlg, IDC_COMBO1, CB_GETCOUNT, (WPARAM)0, (LPARAM)0);
        if ((CB_ERR != lCount) && (lCount > 0))
        {
            MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, IDC_COMBO1, CB_SETCURSEL, (WPARAM)0, (LPARAM)0));
        }

        MYVERIFY(0 != CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1));
        g_bNewProfile = TRUE;

        break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_RADIO1:    //Build a new service profile
                    g_szShortServiceName[0] = TEXT('\0');
                    EnableWindow(GetDlgItem(hDlg,IDC_COMBO1),FALSE);
                    g_bNewProfile = TRUE;
                    break;

                case IDC_RADIO2:    //Edit an existing service profile
                
                    EnableWindow(GetDlgItem(hDlg,IDC_COMBO1),TRUE);

                    lCount = SendDlgItemMessage(hDlg, IDC_COMBO1, CB_GETCOUNT, 0, (LPARAM)0);
                    
                    if ((CB_ERR != lCount) && (lCount > 0))
                    {
                        if (iCBSel > lCount)
                        {
                            iCBSel = 0;
                        }

                        MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, IDC_COMBO1, CB_SETCURSEL,
                                                              (WPARAM)iCBSel, (LPARAM)0));                       
                    }
                    g_bNewProfile = FALSE;

                    break;


                case IDC_COMBO1:
                    MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2));

                    nResult = SendDlgItemMessage(hDlg, IDC_COMBO1, CB_GETCURSEL, 0, (LPARAM)0);

                    if (nResult != LB_ERR)
                    {
                        iCBSel = nResult;
                        MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, IDC_COMBO1, CB_GETLBTEXT, 
                            (WPARAM)iCBSel, (LPARAM)szName));
                    }
                    else
                    {
                        SendDlgItemMessage(hDlg, IDC_COMBO1, CB_SETCURSEL, 0, (LPARAM)0);   //lint !e534 this will error if no items in combo
                        nResult = SendDlgItemMessage(hDlg,IDC_COMBO1,CB_GETCURSEL,0,(LPARAM)0);
                        if (nResult != LB_ERR)
                        {
                            iCBSel = nResult;
                            MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, IDC_COMBO1, CB_GETLBTEXT, 
                                (WPARAM)nResult, (LPARAM)szName));
                        }
                        else
                        {
                            return 1;
                        }
                    }

                    EnableWindow(GetDlgItem(hDlg,IDC_COMBO1),TRUE);
                    break;

                default:
                    break;
            }
            break;


        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));


                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    //
                    // Establish global platform path
                    //
                    MYVERIFY(CELEMS(g_szOsdir) > (UINT)wsprintf(g_szOsdir, TEXT("%s%s\\"), 
                        g_szCmakdir, c_pszProfiles));            

                    //
                    //  Create the support dir path  and get the Name of its Language
                    //
                    
                    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s%s\\%s"), 
                        g_szCmakdir, c_pszSupport, c_pszTemplateInf));
                    
                    MYVERIFY(FALSE != GetLangFromInfTemplate(szTemp, szLanguageDisplayName, 
                        CELEMS(szLanguageDisplayName)));

                    //
                    // Determine if its a new or existing profile
                    //
                    
                    if (IsDlgButtonChecked(hDlg, IDC_RADIO2) == BST_CHECKED)
                    {
                        //
                        //  Editing an existing profile
                        //

                        nResult = SendDlgItemMessage(hDlg,IDC_COMBO1,CB_GETCURSEL,0,(LPARAM)0);
                        if (nResult != LB_ERR)
                        {
                            MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, IDC_COMBO1, CB_GETLBTEXT, 
                                (WPARAM)nResult, (LPARAM)szName));
                        }
                        else
                        {
                            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NEEDPROF, MB_OK));
                            SetFocus(GetDlgItem(hDlg, IDC_COMBO1));
                            
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));

                            return 1;
                        }
                        
                        //
                        // if already editing a profile, don't reset everything
                        // if didn't switch to another profile.
                        //
                        bNameChanged = (_tcsicmp(szName,g_szShortServiceName) != 0);
                        
                        if (bNameChanged)
                        {
                            _tcscpy(g_szShortServiceName, szName);
                            ClearCmakGlobals();
    
                            //
                            //  Okay, copy the profile files to the temp dir
                            //
                            if (!CopyToTempDir(g_szShortServiceName))
                            {                       
                                MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                                return 1;
                            }
                        }

                        //
                        //  We need to make sure that the user has Read/Write
                        //  permissions to the Profiles\<g_szShortServiceName> directory.  Otherwise 
                        //  they can get themselves into the situation where they would build a
                        //  whole profile and lose all of the work because they couldn't
                        //  save it to the output directory (since we work out of the temp
                        //  dir until we actually build the cab itself).  NTRAID 372081
                        //
                        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s%s\\%s"), g_szCmakdir, c_pszProfiles, g_szShortServiceName));
                        if (!HasSpecifiedAccessToFileOrDir(szTemp, FILE_GENERIC_READ | FILE_GENERIC_WRITE))
                        {
                            //
                            //  Then we need to throw an error to the user and exit.
                            //

                            LPTSTR pszTmp = CmLoadString(g_hInstance, IDS_INSUFF_PERMS);

                            if (pszTmp)
                            {
                                DWORD dwSize = lstrlen(pszTmp) + lstrlen(szTemp) + 1;
                                LPTSTR pszMsg = (LPTSTR)CmMalloc(dwSize*sizeof(TCHAR));

                                if (pszMsg)
                                {
                                    wsprintf(pszMsg, pszTmp, szTemp);
                                    MessageBox(NULL, pszMsg, g_szAppTitle, MB_OK | MB_ICONERROR | MB_TASKMODAL);
                                    CmFree(pszMsg);
                                }

                                CmFree(pszTmp);
                            }

                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }
                    }
                    else
                    {
                        //
                        //  Building a new profile
                        //
                        if (TEXT('\0') == g_szShortServiceName[0])
                        {
                            ClearCmakGlobals();
                            
                            if (FileExists(g_szTempDir))
                            {
                                EraseTempDir();
                            }
                            
                            MYVERIFY(0 != CreateDirectory(g_szTempDir, NULL));

                        }
                    }
                            
                    // CHECK IF .CMS .CMP .INF .SED FILES EXIST, CREATE FROM TEMPLATE IF NOT EXIST
                    // Don't do this if in the special case where we have not verified the short name.
                    
                    GetFileName(g_szCmsFile, szTemp);
                    
                    if (_tcsicmp(szTemp, TEXT(".cms")) != 0)
                    {
                        if (!EnsureProfileFileExists(g_szCmsFile, c_pszTemplateCms, TEXT(".cms"), MAX_PATH))
                        {
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }

                        if (!EnsureProfileFileExists(g_szCmpFile, c_pszTemplateCmp, c_pszCmpExt, MAX_PATH))
                        {
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }

                        if (!EnsureProfileFileExists(g_szSedFile, c_pszTemplateSed, TEXT(".sed"), MAX_PATH))
                        {
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }

                        if (!EnsureProfileFileExists(g_szInfFile, c_pszTemplateInf, TEXT(".inf"), MAX_PATH))
                        {
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }                        

                        //
                        //  Since we removed multi-language support from CMAK (NTRAID 177515),
                        //  we need to check to make sure they aren't trying to edit a foriegn
                        //  language profile.  If so then we need to force an upgrade.
                        //
                        if (!IsNativeLCID(g_szInfFile))
                        {
                            MYVERIFY(0 != LoadString(g_hInstance, IDS_NONNATIVELCID, szTemp, MAX_PATH));
                            MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szTemp, g_szShortServiceName, szLanguageDisplayName));
                            
                            if (IDYES == MessageBox(hDlg, szMsg, g_szAppTitle, MB_YESNO | MB_APPLMODAL | MB_DEFBUTTON2 | MB_ICONEXCLAMATION))
                            {
                                //
                                //  They want to continue in the current language so upgrade the
                                //  inf so that it uses the native language template.
                                //
                                MYVERIFY(CELEMS(szTemp) > (UINT) wsprintf(szTemp, TEXT("%s.bak"), g_szInfFile));
                                MYVERIFY(TRUE == UpgradeInf(szTemp, g_szInfFile));
                            }
                            else
                            {
                                MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                                return 1;                                
                            }
                        }

                        //
                        //  Since the Unicode changes to CMAK and the multi-language capabilities of NT5, it is
                        //  possible to create many different language profiles inside CMAK.  Thus we need to check that
                        //  the Current System Default language and the language of the profile the user is editing have
                        //  the same primary language ID, otherwise display problems may arise.  For instance, a use
                        //  with an English version of the OS and CMAK, could set their default system locale to Japanese
                        //  and create a Japanese profile for a client.  Then if they change their system default language
                        //  back to English and try to edit the profile the Japanese characters in the profile will not
                        //  display correctly.  Thus, we should detect the situation where the display language of the profile
                        //  and the current system default language are not the same and throw a warning.
                        //
                        DWORD dwSystemDefaultLCID = GetSystemDefaultLCID();
                        DWORD dwProfileDisplayLanguage = 0;

                        if (0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszDisplayLCID, 
                                 TEXT(""), szTemp, CELEMS(szTemp), g_szInfFile))
                        {        
                           dwProfileDisplayLanguage = (DWORD)_ttol(szTemp);
                            
                            if (!ArePrimaryLangIDsEqual(dwProfileDisplayLanguage, dwSystemDefaultLCID))
                            {
                                //
                                //  If we are in here, then the default system LCID that the profile was
                                //  last editted in and the current Default System LCID
                                //  have a different Primary language (Japanese vs English for instance).
                                //  Thus we want to warn the user that they can continue but certain characters
                                //  may not display properly.  They should probably change their system default
                                //  locale back to the setting that it was originally editted in.
                                //

                                //
                                //  Get the Language Names of the Two LCIDs (sys default and CMAK lang)
                                //
                                LPTSTR pszSystemLanguage = GetLocalizedLanguageNameFromLCID(dwSystemDefaultLCID);
                                LPTSTR pszProfileDisplayLanguage = GetLocalizedLanguageNameFromLCID(dwProfileDisplayLanguage);
                                LPTSTR pszFmtString = CmLoadString(g_hInstance, IDS_DIFF_DISPLAY_LCID);

                                if (pszSystemLanguage && pszProfileDisplayLanguage && pszFmtString)
                                {
                                    LPTSTR pszMsg = (LPTSTR)CmMalloc(sizeof(TCHAR)*(lstrlen(pszSystemLanguage) + 
                                                                     lstrlen(pszProfileDisplayLanguage) + lstrlen(pszFmtString) + 1));
                                    if (pszMsg)
                                    {
                                        wsprintf(pszMsg, pszFmtString, pszSystemLanguage, pszProfileDisplayLanguage);
                                        MessageBox(hDlg, pszMsg, g_szAppTitle, MB_OK | MB_ICONINFORMATION);
                                        CmFree(pszMsg);
                                    }
                                }

                                CmFree(pszSystemLanguage);
                                CmFree(pszProfileDisplayLanguage);
                                CmFree(pszFmtString);
                            }
                        }

                        //
                        //  We have the possiblity that the inf will be of an old format.  Call
                        //  Upgrade Inf to see if it needs to be upgraded.
                        //

                        MYVERIFY (TRUE == EnsureInfIsCurrent(hDlg, g_szInfFile));
                        WriteInfVersion(g_szInfFile); //lint !e534
                    }

                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}


//
// Write out profile strings with quotes around the entry
// Takes string const as second param
//
void QS_WritePrivateProfileString(LPCTSTR pszSection, LPCTSTR pszItem, LPTSTR entry, LPCTSTR inifile)
{
    TCHAR szTemp[2*MAX_PATH+1] = TEXT("");

    if (NULL != entry)
    {
        MYDBGASSERT(_tcslen(entry) <= ((2 * MAX_PATH) - 2));
        _tcscpy(szTemp,TEXT("\""));
        _tcscat(szTemp,entry);
        _tcscat(szTemp,TEXT("\""));
    }

    MYDBGASSERT(_tcslen(szTemp) <= sizeof(szTemp));

    MYVERIFY(0 != WritePrivateProfileString(pszSection, pszItem, szTemp, inifile));
}



//+----------------------------------------------------------------------------
//
// Function:  ValidateServiceName
//
// Synopsis:  This function makes sure that a long service name is valid.
//            For a long service name to be valid it must contain at least
//            one alpha-numeric character, not start with a period (.), and
//            not contain any of the following characters : */\\:?\"<>|[]
//
// Arguments: LPCTSTR pszLongServiceName - the service name to check
//
// Returns:   BOOL returns TRUE if the name is valid.
//                  
//
// History:   quintinb Created     10/29/98
//
//+----------------------------------------------------------------------------
int ValidateServiceName(HWND hDlg, LPTSTR pszLongServiceName)
{
    BOOL bBadServiceNameCharFound = FALSE;
    BOOL bFoundAlphaNumeric = FALSE;
    LPTSTR pch;
    int iLen;


    if ((NULL == pszLongServiceName) || (TEXT('\0') == pszLongServiceName[0]))
    {
        //
        //  Cannot have an empty service name
        //
        MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOSERVICE, MB_OK));
        return FALSE;
    }
    else if (MAX_LONG_SERVICE_NAME_LENGTH < _tcslen(pszLongServiceName))
    {
        //
        //  Too Long
        //
        TCHAR* pszMsg = CmFmtMsg(g_hInstance, IDS_SERVICENAMETOBIG, MAX_LONG_SERVICE_NAME_LENGTH);

        if (pszMsg)
        {
            MessageBox(hDlg, pszMsg, g_szAppTitle, MB_OK);
            CmFree(pszMsg);
        }

        return FALSE;
    }
    else
    {
        iLen = lstrlen(g_szBadLongServiceNameChars); 
        pch = pszLongServiceName;

        //
        //  Check that the service name doesn't start with a period
        //
        if (TEXT('.') == pszLongServiceName[0])
        {
            bBadServiceNameCharFound = TRUE;
        }

        //
        //  Check that it doesn't contain any bad characters
        //
        while (!bBadServiceNameCharFound && (*pch != _T('\0')))
        {
            for (int j = 0; j < iLen; ++j)
            {
                if (*pch == g_szBadLongServiceNameChars[j])
                {
                    bBadServiceNameCharFound = TRUE;
                    break;
                }
            }

            pch = CharNext(pch);
        }

        //
        //  Check that it contains at least one alphanumeric character
        //
        iLen = lstrlen(pszLongServiceName);
        WORD *pwCharTypeArray = (WORD*)CmMalloc(sizeof(WORD)*(iLen + 1));

        if (pwCharTypeArray)
        {
            if (GetStringTypeEx(LOCALE_SYSTEM_DEFAULT, CT_CTYPE1, pszLongServiceName, -1, pwCharTypeArray))
            {
                for (int i = 0; i < iLen; i++)
                {
                    if (pwCharTypeArray[i] & (C1_ALPHA | C1_DIGIT)) 
                    {
                        bFoundAlphaNumeric = TRUE;
                        break;  // only need one alpha numeric char.
                    }
                }
            }

            CmFree(pwCharTypeArray);
        }

        if (bBadServiceNameCharFound || !bFoundAlphaNumeric)
        {
            //
            //  Contains bad chars.
            //
            LPTSTR pszMsg = CmFmtMsg(g_hInstance, IDS_BADLONGNAME, g_szBadLongServiceNameChars);

            if (pszMsg)
            {
                MessageBox(hDlg, pszMsg, g_szAppTitle, MB_OK);
                CmFree(pszMsg);
            }
            return FALSE;
        }
        else
        {
            //
            //  A good long service name
            //
            return TRUE;
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  ValidateShortServiceName
//
// Synopsis:  This function checks to see if a given short service name is valid.
//            To be valid, a short service name must be less than 8 bytes long
//            (but not empty) and must not contain any characters found in
//            g_szBadFilenameChars ... basically we only allow letters and
//            numbers.
//
// Arguments: LPTSTR pszShortServiceName - the short service name to verify
//
// Returns:   BOOL - TRUE if the short service name passed in is valid
//
// History:   quintinb Created    10/29/98
//
//+----------------------------------------------------------------------------
BOOL ValidateShortServiceName(HWND hDlg, LPTSTR pszShortServiceName)
{
    LPTSTR pch;

    if ((NULL == pszShortServiceName) || (TEXT('\0') == pszShortServiceName[0]))
    {                   
        MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOSHORTNAME, MB_OK));
        return FALSE;
    }

    //
    //  Notice that 8.3 filenames are 8 bytes not 8 characters.  Thus we can only have
    //  4 DBCS chars.
    //
#ifdef UNICODE

    LPSTR pszAnsiShortServiceName = WzToSzWithAlloc(pszShortServiceName);

    if (MAX_SHORT_SERVICE_NAME_LENGTH < lstrlenA(pszAnsiShortServiceName))
#else
    if (MAX_SHORT_SERVICE_NAME_LENGTH < strlen(pszShortServiceName))
#endif
    {
        MYVERIFY(IDOK == ShowMessage(hDlg, IDS_TOOLONG, MB_OK));
        return FALSE;
    }
    else
    {
        // check for valid file name

        int iLen = lstrlen(g_szBadFilenameChars); 
        pch = pszShortServiceName;

        while(*pch != _T('\0'))
        {
            for (int j = 0; j < iLen; ++j)
            {
                if (*pch == g_szBadFilenameChars[j])
                {
                    LPTSTR pszMsg = CmFmtMsg(g_hInstance, IDS_BADNAME, g_szBadFilenameChars);

                    if (pszMsg)
                    {
                        MessageBox(hDlg, pszMsg, g_szAppTitle, MB_OK);
                        CmFree(pszMsg);
                    }

                    return FALSE;
                }
            }
            pch = CharNext(pch);
        }
    }

#ifdef UNICODE
    CmFree(pszAnsiShortServiceName);
#endif

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrStrI
//
// Synopsis:  Simple replacement for StrStr from C runtime, but case-insensitive
//
// Arguments: LPCTSTR pszString - The string to search in
//            LPCTSTR pszSubString - The string to search for
//
// Returns:   LPTSTR - Ptr to the first occurence of pszSubString in pszString. 
//                    NULL if pszSubString does not occur in pszString
//
//
// History:   SumitC      copied from CmStrStrW    15-Mar-2001
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmStrStrI(LPCWSTR pszString, LPCWSTR pszSubString)
{

    //
    //  Check the inputs
    //
    MYDBGASSERT(pszString);
    MYDBGASSERT(pszSubString);

    if (NULL == pszSubString || NULL == pszString)
    {
        return NULL;
    }

    //
    //  Check to make sure we have something to look for
    //
    if (TEXT('\0') == pszSubString[0])
    {
        return((LPWSTR)pszString);
    }

    //
    //  Okay, start looking for the string
    //
    LPWSTR pszCurrent = (LPWSTR)pszString;
    LPWSTR pszTmp1;
    LPWSTR pszTmp2;

    while (*pszCurrent)
    {
        pszTmp1 = pszCurrent;
        pszTmp2 = (LPWSTR) pszSubString;

        while (*pszTmp1 && *pszTmp2 && (tolower(*pszTmp1) == tolower(*pszTmp2)))
        {
            pszTmp1 = CharNext(pszTmp1);
            pszTmp2 = CharNext(pszTmp2);
        }

        if (TEXT('\0') == *pszTmp2)
        {        
            return pszCurrent;
        }

        pszCurrent = CharNext(pszCurrent);
    }

    return NULL;
}




//+----------------------------------------------------------------------------
//
// Func:    FixupCMSFileForClonedProfile
//
// Desc:    Parses the CMS file and replaces references to the old shortname
//
// Args:    [pszCMSFile] - name of the CMS file
//          [pszOld]     - old short service name
//          [pszNew]     - new short service name
//
// Return:  HRESULT
//
// Notes:   
//
// History: 16-Feb-2001   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
FixupCMSFileForClonedProfile(LPTSTR pszCMSFile, LPTSTR pszOld, LPTSTR pszNew)
{
    HRESULT hr = S_OK;
    LPTSTR pszCurrentSection = NULL;

    MYDBGASSERT(pszCMSFile);
    MYDBGASSERT(pszOld);
    MYDBGASSERT(pszNew);
    MYDBGASSERT(lstrlen(pszOld) <= MAX_SHORT_SERVICE_NAME_LENGTH);

    if (NULL == pszCMSFile || NULL == pszOld || NULL == pszNew ||
        (lstrlen(pszOld) > MAX_SHORT_SERVICE_NAME_LENGTH))
    {
        return E_INVALIDARG;
    }

    //
    //  Set up the string we're going to look for in the Values
    //
    TCHAR szOldNamePlusSlash[MAX_SHORT_SERVICE_NAME_LENGTH + 1 + 1];

    lstrcpy(szOldNamePlusSlash, pszOld);
    lstrcat(szOldNamePlusSlash, TEXT("\\"));

    //
    //  read in all the sections from the CMS file
    //
    LPTSTR pszAllSections = GetPrivateProfileStringWithAlloc(NULL, NULL, TEXT(""), pszCMSFile);

    //
    //  iterate over all the sections
    //
    for (pszCurrentSection = pszAllSections;
         pszCurrentSection && (TEXT('\0') != pszCurrentSection[0]);
         pszCurrentSection += (lstrlen(pszCurrentSection) + 1))
    {
        //
        //  Skip the [Connection Manager] section.  The entries here are image files,
        //  and are dealt with in a later CMAK page.
        //
        if (0 == lstrcmpi(c_pszCmSection, pszCurrentSection))
        {
            continue;
        }
        
        //
        // for each section, get all the keys
        //
        LPTSTR pszKeysInThisSection = GetPrivateProfileStringWithAlloc(pszCurrentSection, NULL, TEXT(""), pszCMSFile);
        LPTSTR pszCurrentKey = NULL;
        
        //
        //  iterate over all the keys
        //
        for (pszCurrentKey = pszKeysInThisSection;
             pszCurrentKey && (TEXT('\0') != pszCurrentKey[0]);
             pszCurrentKey += (lstrlen(pszCurrentKey) + 1)) // alternate is CmEndOfStr(pszCurrentKeyName) & pszCurrentKeyName++
        {
            //
            //  Get the value for this key
            //
            LPTSTR pszValue = GetPrivateProfileStringWithAlloc(pszCurrentSection, pszCurrentKey, TEXT(""), pszCMSFile);

            if (pszValue)
            {
                //
                //  Search for "pszOld\", and replace with "pszNew\" (the \ is
                //  to ensure that it is part of a path)
                //
                if (CmStrStrI(pszValue, szOldNamePlusSlash) == pszValue)
                {
                    UINT cLen = lstrlen(pszValue) - lstrlen(pszOld) + lstrlen(pszNew) + 1;

                    LPTSTR pszNewValue = (LPTSTR) CmMalloc(cLen * sizeof(TCHAR));
                    if (pszNewValue)
                    {
                        lstrcpy(pszNewValue, pszNew);
                        lstrcat(pszNewValue, TEXT("\\"));
                        lstrcat(pszNewValue, pszValue + lstrlen(szOldNamePlusSlash));

                        //
                        //  Write back the value (this doesn't affect the list
                        //  of keys, so it is safe to do.)
                        //
                        MYDBGASSERT(0 != WritePrivateProfileString(pszCurrentSection, pszCurrentKey, pszNewValue, pszCMSFile));

                        CmFree(pszNewValue);
                    }
                }

                CmFree(pszValue);
            }
        }
        CmFree(pszKeysInThisSection);
    }

    CmFree(pszAllSections);

    return hr;
}

//+----------------------------------------------------------------------------
//
// Func:    CloneProfile
//
// Desc:    Does the gruntwork to clone a given profile
//
// Args:    [pszShortServiceName] - new short service name
//          [pszLongServiceName] -  new long service name
//
// Return:  HRESULT
//
// Notes:   
//
// History: 16-Feb-2001   SumitC      Created (most code copied from ProcessServiceName)
//
//-----------------------------------------------------------------------------
HRESULT
CloneProfile(IN LPTSTR pszShortServiceName, IN LPTSTR pszLongServiceName)
{
    HRESULT hr = S_OK;
    TCHAR szMsg[MAX_PATH+1];

    MYDBGASSERT(pszShortServiceName);
    MYDBGASSERT(pszLongServiceName);

    if ((_tcsicmp(g_szShortServiceName, pszShortServiceName) != 0))
    {
        //
        //  If this is a cloned profile, we want to delete the 
        //  old executable file and the old .inf.bak file so that 
        //  we don't leave it around.
        //
        if (TEXT('\0') != g_szShortServiceName[0])
        {
            MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, 
                TEXT("%s\\%s.exe"), g_szOutdir, g_szShortServiceName));

            DeleteFile(szMsg);

            MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, 
                TEXT("%s\\%s.inf.bak"), g_szOutdir, g_szShortServiceName));

            DeleteFile(szMsg);

        }

        MYVERIFY(0 != WritePrivateProfileString(c_pszInfSectionStrings, 
            c_pszDesktopGuid,TEXT(""), g_szInfFile));

        //
        //  By calling WritePrivateProfileString with all NULL's we flush the file cache 
        //  (win95 only).  This call will return 0.
        //

        WritePrivateProfileString(NULL, NULL, NULL, g_szInfFile); //lint !e534 this call will return 0

        MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, TEXT("%s\\%s.inf"), 
            g_szOutdir, pszShortServiceName));
        MYVERIFY(0 != MoveFile(g_szInfFile, szMsg));
        _tcscpy(g_szInfFile, szMsg);

        MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, TEXT("%s\\%s.sed"), 
            g_szOutdir, pszShortServiceName));
        MYVERIFY(0 != MoveFile(g_szSedFile, szMsg));
        _tcscpy(g_szSedFile, szMsg);

        MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, TEXT("%s\\%s.cms"), 
            g_szOutdir, pszShortServiceName));
        MYVERIFY(0 != MoveFile(g_szCmsFile, szMsg));
        _tcscpy(g_szCmsFile, szMsg);

        MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, TEXT("%s\\%s.cmp"), 
            g_szOutdir, pszShortServiceName));                        
        MYVERIFY(0 != MoveFile(g_szCmpFile, szMsg));
        _tcscpy(g_szCmpFile, szMsg);

        //
        //  Fix up any entries that are pointing to the old path
        //
        (void) FixupCMSFileForClonedProfile(g_szCmsFile, g_szShortServiceName, pszShortServiceName);
        
    }
    _tcscpy(g_szShortServiceName, pszShortServiceName);

    //
    //  Check to see if the user changed the long service name
    //
    if ((0 != lstrcmpi(pszLongServiceName, g_szLongServiceName)) && (TEXT('\0') != g_szLongServiceName[0]))
    {
        const int c_iNumDunSubSections = 4;
        TCHAR szCurrentSectionName[MAX_PATH+1];
        TCHAR szNewSectionName[MAX_PATH+1];
        const TCHAR* const ArrayOfSubSections[c_iNumDunSubSections] = 
        {
            c_pszCmSectionDunServer, 
            c_pszCmSectionDunNetworking, 
            c_pszCmSectionDunTcpIp, 
            c_pszCmSectionDunScripting
        };

        //
        //  Free the DNS list so that we will re-read it later.  This ensures that
        //  we will get rid of any default entries we added that don't really exist
        //  and will add new defaults if we need them.
        //
        FreeDnsList(&g_pHeadDunEntry, &g_pTailDunEntry);
        FreeDnsList(&g_pHeadVpnEntry, &g_pTailVpnEntry);

        //
        //  The user cloned the long service name.  Update the DUN key and rename the 
        //  default DUN entry if the long service name and the DUN name match.  If they
        //  don't match we don't want to rename them as a phonebook may be referencing them
        //  by their original name.
        //
        GetDefaultDunSettingName(g_szCmsFile, g_szLongServiceName, pszShortServiceName, MAX_PATH + 1);

        if (0 == lstrcmpi(g_szLongServiceName, pszShortServiceName))
        {
            for (int i = 0; i < c_iNumDunSubSections; i++)
            {
                wsprintf(szCurrentSectionName, TEXT("%s&%s"), ArrayOfSubSections[i], g_szLongServiceName);
                wsprintf(szNewSectionName, TEXT("%s&%s"), ArrayOfSubSections[i], pszLongServiceName);

                RenameSection(szCurrentSectionName, szNewSectionName, g_szCmsFile);
            }

            MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryDun, pszLongServiceName, g_szCmsFile));
        }

        //
        //  Now update the TunnelDUN key and rename the Tunnel DUN entry if Tunnel DUN name is based on the original
        //  long service name.  If they aren't related then we don't want to rename them.
        //
        GetTunnelDunSettingName(g_szCmsFile, g_szLongServiceName, pszShortServiceName, MAX_PATH + 1);
        wsprintf(szMsg, TEXT("%s %s"), g_szLongServiceName, c_pszCmEntryTunnelPrimary);

        if (0 == lstrcmpi(szMsg, pszShortServiceName))
        {
            for (int i = 0; i < c_iNumDunSubSections; i++)
            {
                wsprintf(szCurrentSectionName, TEXT("%s&%s %s"), ArrayOfSubSections[i], g_szLongServiceName, c_pszCmEntryTunnelPrimary);
                wsprintf(szNewSectionName, TEXT("%s&%s %s"), ArrayOfSubSections[i], pszLongServiceName, c_pszCmEntryTunnelPrimary);

                RenameSection(szCurrentSectionName, szNewSectionName, g_szCmsFile);
            }

            MYVERIFY(CELEMS(szNewSectionName) > (UINT)wsprintf(szNewSectionName, TEXT("%s %s"), pszLongServiceName, c_pszCmEntryTunnelPrimary));
            MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryTunnelDun, szNewSectionName, g_szCmsFile));
        }
    }

    CMTRACEHR("CloneProfile", hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Function:  ProcessServiceName
//
// Synopsis:  Setup service and File Names
//
//
// History:   quintinb Created Header and renamed from ProcessPage2    8/6/98
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessServiceName(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szTemp2[MAX_PATH+1];
    TCHAR szMsg[MAX_PATH+1];
    LONG lLongServiceReturn;
    LONG lShortServiceReturn;
    int nResult;
    NMHDR* pnmHeader = (NMHDR*)lParam;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_NAMES)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_SERVICE);
    SetDefaultGUIFont(hDlg,message,IDC_SSERVICE);

    switch (message)
    {
        case WM_INITDIALOG:
            // this init's the focus, otherwise Setfocus won't work 1st time
            SetFocus(GetDlgItem(hDlg, IDC_SERVICE));
            // bug fix 6234, quintinb 9-8-97
            SendDlgItemMessage(hDlg, IDC_SERVICE, EM_SETLIMITTEXT, (WPARAM)MAX_LONG_SERVICE_NAME_LENGTH, (LPARAM)0);//lint !e534 EM_SETLIMITTEXT doesn't return anything useful
            // end bug fix 6234, quintinb
            break;

        case WM_NOTIFY:


            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:

                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));
                    
                    return 1;

                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));
                    if (*g_szShortServiceName)
                    {
                        MYVERIFY(TRUE == SendDlgItemMessage(hDlg, IDC_SSERVICE, WM_SETTEXT, 
                            (WPARAM)0, (LPARAM) g_szShortServiceName));

                        GetFileName(g_szCmsFile,szTemp);
                        
                        if (_tcsicmp(szTemp,TEXT(".cms")) != 0)
                        {
                            MYVERIFY(0 != GetPrivateProfileString(c_pszCmSection, c_pszCmEntryServiceName,
                                TEXT(""), g_szLongServiceName, CELEMS(g_szLongServiceName), g_szCmsFile));
                        }

                        MYVERIFY(TRUE == SendDlgItemMessage(hDlg, IDC_SERVICE, WM_SETTEXT, (WPARAM)0, 
                            (LPARAM) g_szLongServiceName));
                    }
                    else
                    {
                        MYVERIFY(TRUE == SendDlgItemMessage(hDlg, IDC_SERVICE, WM_SETTEXT, 
                            (WPARAM)0, (LPARAM) NULL));
                        MYVERIFY(TRUE == SendDlgItemMessage(hDlg, IDC_SSERVICE, WM_SETTEXT, 
                            (WPARAM)0, (LPARAM) NULL));
                    }

                    break;

                case PSN_WIZBACK: // fall through to Next
                case PSN_WIZNEXT:
                    // the Next button was pressed
                    if (-1 == GetTextFromControl(hDlg, IDC_SERVICE, szTemp2, MAX_PATH, (PSN_WIZNEXT == pnmHeader->code))) // bDisplayError == (PSN_WIZBACK == pnmHeader->code)
                    {
                        //
                        //  Let the user go back if there is a problem with retrieving their text so that
                        //  they can choose another profile.
                        //
                        if (PSN_WIZBACK == pnmHeader->code)
                        {
                            return FALSE;
                        }
                        else
                        {
                            goto ServiceNameError;
                        }
                    }

                    CmStrTrim(szTemp2);

                    if (-1 == GetTextFromControl(hDlg, IDC_SSERVICE, szTemp, MAX_PATH, (PSN_WIZNEXT == pnmHeader->code))) // bDisplayError == (PSN_WIZBACK == pnmHeader->code)
                    {
                        //
                        //  Let the user go back if there is a problem with retrieving their text so that
                        //  they can choose another profile.
                        //
                        if (PSN_WIZBACK == pnmHeader->code)
                        {
                            return FALSE;
                        }
                        else
                        {
                            goto ServiceNameError;
                        }
                    }

                    //
                    //  If both the servicename and the short servicename are blank and the user
                    //  is navigating back, then allow them to continue.  Otherwise go through all
                    //  the normal checks.
                    //

                    if ((pnmHeader && (PSN_WIZBACK == pnmHeader->code))) 
                    {
                        if ((szTemp[0] == TEXT('\0')) && (szTemp2[0] == TEXT('\0')))
                        {
                            return 0;
                        }
                    }
                    
                    //
                    //  Validate the Long Service Name
                    //

                    if (!ValidateServiceName(hDlg, szTemp2))
                    {
                        goto ServiceNameError;                
                    }

                    //
                    //  Now lets validate the short service name
                    //

                    if (!ValidateShortServiceName(hDlg, szTemp))
                    {
                        goto ShortServiceNameError;                 
                    }

                    //
                    //  Changing one of the service names without changing the
                    //  other can cause problems when installing the profile
                    //  later.  Warn the user if this is the case.
                    //
                    { // scoping braces
                        BOOL bShortServiceNameChanged = !!lstrcmpi(g_szShortServiceName, szTemp);
                        BOOL bLongServiceNameChanged = !!lstrcmpi(g_szLongServiceName, szTemp2);

                        if ((FALSE == g_bNewProfile) && (bShortServiceNameChanged != bLongServiceNameChanged))
                        {
                            nResult = ShowMessage(hDlg, IDS_CHANGED_ONLY_SS_OR_LS, MB_YESNO);
                            if (nResult == IDYES)
                            {
                                if (bShortServiceNameChanged)
                                {
                                    goto ServiceNameError;
                                }
                                if (bLongServiceNameChanged)
                                {
                                    goto ShortServiceNameError;
                                }
                            }
                        }
                    }

                    //
                    //  Create a default output directory based on the short name.
                    //
                    //  NTRAID 159367 -- quintinb
                    //  Must leave the comparison between the ShortName and szTemp, otherwise the
                    //  user can change the shortname and we won't rename the files.  This allows
                    //  profile cloning.
                    //
                    if ((_tcsicmp(g_szShortServiceName, szTemp) != 0))
                    {
                        BOOL bFound;
                        
                        bFound = FindListItemByName(szTemp, g_pHeadProfile, NULL); // NULL passed because we don't need a pointer to the item returned
                        
                        if (bFound)
                        {
                            nResult = ShowMessage(hDlg,IDS_PROFEXISTS,MB_YESNO);
                            if (nResult == IDNO)
                            {
                                goto ShortServiceNameError;
                            }
                        }

                        MYVERIFY(S_OK == CloneProfile(szTemp, szTemp2));
                    }
                    
                    //
                    //  The Long Service Name is valid, lets keep it.
                    //
                    _tcscpy(g_szLongServiceName, szTemp2);                    

                    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryServiceName, g_szLongServiceName, g_szCmsFile));

                    QS_WritePrivateProfileString(c_pszInfSectionStrings, c_pszCmEntryServiceName, g_szLongServiceName, g_szInfFile);

                    QS_WritePrivateProfileString(c_pszInfSectionStrings, c_pszUninstallAppTitle, g_szLongServiceName, g_szInfFile);

                    QS_WritePrivateProfileString(c_pszInfSectionStrings, c_pszShortSvcName, g_szShortServiceName, g_szInfFile);

                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;

ServiceNameError:
    
    SetFocus(GetDlgItem(hDlg, IDC_SERVICE));
    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
    return 1;

ShortServiceNameError:
    
    SetFocus(GetDlgItem(hDlg, IDC_SSERVICE));
    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
    return 1;
}


//+----------------------------------------------------------------------------
//
// Function:  ProcessSupportInfo
//
// Synopsis:  Customize Support Information
//
//
// History:   quintinb  Created Header and renamed from ProcessPage2_A    8/6/98
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessSupportInfo(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szTemp[MAX_PATH+1];
    NMHDR* pnmHeader = (NMHDR*)lParam;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_SUPPINFO)) return TRUE;
    if (ProcessCancel(hDlg, message, lParam)) return TRUE;
    SetDefaultGUIFont(hDlg, message, IDC_SUPPORT);

    switch (message)
    {
        case WM_INITDIALOG:

           // Fix for Whistler bug 9156
            SendDlgItemMessage(hDlg, IDC_SUPPORT, EM_SETLIMITTEXT, (WPARAM) 50, 0);

            // this init's the focus, otherwise Setfocus won't work 1st time
            SetFocus(GetDlgItem(hDlg, IDC_SUPPORT));
            break;

        case WM_NOTIFY:


            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));

                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));

                    //
                    //  this call to GetPrivateProfileString may retreive a blank string, thus don't use the MYVERIFY macro
                    //
                    GetPrivateProfileString(c_pszCmSection, c_pszCmEntryServiceMessage, TEXT(""), 
                        g_szSvcMsg, CELEMS(g_szSvcMsg), g_szCmsFile);    //lint !e534

                    MYVERIFY(TRUE == SendDlgItemMessage(hDlg, IDC_SUPPORT, WM_SETTEXT, 
                        (WPARAM)0, (LPARAM) g_szSvcMsg));

                    break;
                case PSN_WIZBACK:

                case PSN_WIZNEXT:
                    // the Next button was pressed

                    if (-1 == GetTextFromControl(hDlg, IDC_SUPPORT, szTemp, MAX_PATH, TRUE)) // bDisplayError == TRUE
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_SUPPORT));
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                        return 1;
                    }

                    CmStrTrim(szTemp);
                    MYVERIFY(TRUE == SendDlgItemMessage(hDlg, IDC_SUPPORT, WM_SETTEXT, (WPARAM)0, (LPARAM) szTemp));
                    _tcscpy(g_szSvcMsg,szTemp);
                    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection,c_pszCmEntryServiceMessage,g_szSvcMsg,g_szCmsFile));

#ifdef _WIN64
                    //
                    //  If we are going forward, skip the Include CM binaries page if this is IA64
                    //
                    if (pnmHeader && (PSN_WIZNEXT == pnmHeader->code))
                    {
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, IDD_LICENSE));
                    }
#endif
                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessIncludeCm
//
// Synopsis:  Include CM bits
//
//
// History:   quintinb  Created Header and renamed from ProcessPage2A    8/6/98
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessIncludeCm(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szTemp[MAX_PATH+1];
    NMHDR* pnmHeader = (NMHDR*)lParam;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_CMSW)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;

    switch (message)
    {
        case WM_INITDIALOG:

            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));

                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:

                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));
                    
                    MYVERIFY(0 != GetPrivateProfileString(c_pszCmakStatus, c_pszIncludeCmCode, 
                        c_pszOne, szTemp, CELEMS(szTemp), g_szInfFile));
                    
                    if (*szTemp == TEXT('1'))
                    {
                        g_bIncludeCmCode = TRUE;
                        MYVERIFY(0 != CheckDlgButton(hDlg,IDC_CHECK1,TRUE));
                    }
                    else
                    {
                        g_bIncludeCmCode = FALSE;
                        MYVERIFY(0 != CheckDlgButton(hDlg,IDC_CHECK1,FALSE));
                    }

                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    g_bIncludeCmCode = IsDlgButtonChecked(hDlg,IDC_CHECK1);
                    if (g_bIncludeCmCode)
                    {
                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmakStatus,c_pszIncludeCmCode,c_pszOne,g_szInfFile));
                    }
                    else
                    {
                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmakStatus,c_pszIncludeCmCode,c_pszZero,g_szInfFile));
                    }

                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

void EnableDisableCmProxyControls(HWND hDlg)
{
    BOOL bCmProxyEnabled = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO2));
    
    HWND hControl = GetDlgItem(hDlg, IDC_EDIT1);
    EnableWindow(hControl, bCmProxyEnabled);

    hControl = GetDlgItem(hDlg, IDC_CHECK1);
    EnableWindow(hControl, bCmProxyEnabled);

    hControl = GetDlgItem(hDlg, IDC_PROXYLABEL);
    EnableWindow(hControl, bCmProxyEnabled);    
}

BOOL FillInCustomActionStructWithCmProxy(BOOL bRestorePrevProxySettings, CustomActionListItem* pCustomAction, 
                                         BOOL bDisconnectAction, LPCTSTR pszProxyFile)
{
    BOOL bReturn = FALSE;
    
    MYDBGASSERT(pCustomAction && pszProxyFile && (TEXT('\0') != pszProxyFile[0]));
    
    if (pCustomAction && pszProxyFile && (TEXT('\0') != pszProxyFile[0]))
    {
        const TCHAR* const c_pszBackupFileName = TEXT("proxy.bak");
        const TCHAR* const c_pszDialRasEntry = TEXT("%DIALRASENTRY%");
        const TCHAR* const c_pszProfile = TEXT("%PROFILE%");
        const TCHAR* const c_pszTunnelRasEntry = TEXT("%TUNNELRASENTRY%");
        const TCHAR* const c_pszSetProxyFunction = TEXT("SetProxy");

        UINT uDescription;

        LPTSTR aArrayOfStrings[10];
        UINT uCount = 0;

        if (bDisconnectAction)
        {
            aArrayOfStrings[uCount] = (LPTSTR)c_pszSourceFileNameSwitch;
            uCount++;

            aArrayOfStrings[uCount] = (LPTSTR)c_pszBackupFileName;
            uCount++;

            aArrayOfStrings[uCount] = (LPTSTR)c_pszDialRasEntrySwitch;
            uCount++;

            aArrayOfStrings[uCount] = (LPTSTR)c_pszDialRasEntry;
            uCount++;

            aArrayOfStrings[uCount] = (LPTSTR)c_pszTunnelRasEntrySwitch;
            uCount++;

            aArrayOfStrings[uCount] = (LPTSTR)c_pszTunnelRasEntry;
            uCount++;

            aArrayOfStrings[uCount] = (LPTSTR)c_pszProfileSwitch;
            uCount++;

            aArrayOfStrings[uCount] = (LPTSTR)c_pszProfile;
            uCount++;

            uDescription = IDS_CMPROXY_DIS_DESC;
        }
        else
        {
            aArrayOfStrings[uCount] = (LPTSTR)c_pszSourceFileNameSwitch;
            uCount++;

            aArrayOfStrings[uCount] = (LPTSTR)pszProxyFile;
            uCount++;

            if (bRestorePrevProxySettings)
            {
                aArrayOfStrings[uCount] = (LPTSTR)c_pszBackupFileNameSwitch;
                uCount++;

                aArrayOfStrings[uCount] = (LPTSTR)c_pszBackupFileName;
                uCount++;            
            }

            aArrayOfStrings[uCount] = (LPTSTR)c_pszDialRasEntrySwitch;
            uCount++;

            aArrayOfStrings[uCount] = (LPTSTR)c_pszDialRasEntry;
            uCount++;

            aArrayOfStrings[uCount] = (LPTSTR)c_pszTunnelRasEntrySwitch;
            uCount++;

            aArrayOfStrings[uCount] = (LPTSTR)c_pszTunnelRasEntry;
            uCount++;

            aArrayOfStrings[uCount] = (LPTSTR)c_pszProfileSwitch;
            uCount++;

            aArrayOfStrings[uCount] = (LPTSTR)c_pszProfile;
            uCount++;

            uDescription = IDS_CMPROXY_CON_DESC;
        }
        
        MYVERIFY(0 != LoadString(g_hInstance, uDescription, pCustomAction->szDescription, CELEMS(pCustomAction->szDescription)));
        pCustomAction->Type = bDisconnectAction ? ONDISCONNECT : ONCONNECT;

        wsprintf(pCustomAction->szProgram, TEXT("%s\\cmproxy.dll"), g_szSupportDir);
    
        lstrcpy(pCustomAction->szFunctionName, c_pszSetProxyFunction);
    
        pCustomAction->bIncludeBinary = TRUE;
        pCustomAction->bBuiltInAction = TRUE;
        pCustomAction->bTempDescription = FALSE;
        pCustomAction->dwFlags = ALL_CONNECTIONS;

        HRESULT hr = BuildCustomActionParamString(&(aArrayOfStrings[0]), uCount, &(pCustomAction->pszParameters));

        bReturn = (SUCCEEDED(hr) && pCustomAction->pszParameters);
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessCmProxy
//
// Synopsis:  Automatic IE proxy configuration
//
// History:   quintinb  Created     03/23/00
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessCmProxy(

    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    NMHDR* pnmHeader = (NMHDR*)lParam;
    BOOL bEnableCmProxy;
    BOOL bRestorePrevProxySettings;
    TCHAR szTemp[MAX_PATH+1];

    HRESULT hr;

    CustomActionListItem* pCmProxyCustomAction = NULL;
    CustomActionListItem UpdatedCmProxyAction;

    ProcessBold(hDlg, message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_APCONFIG)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_EDIT1);


    switch (message)
    {
        case WM_INITDIALOG:
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_RADIO1:
                case IDC_RADIO2:
                    EnableDisableCmProxyControls(hDlg);
                    break;

                case IDC_BUTTON1: // browse 
                    {
                        //
                        //  If the user clicked the browse button without clicking the Proxy radio button,
                        //  then we need to set the radio and make sure the other Proxy controls are
                        //  enabled.
                        //
                        MYVERIFY(0 != CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2));
                        EnableDisableCmProxyControls(hDlg);

                        UINT uFilter = IDS_TXTFILTER;
                        TCHAR* pszMask = TEXT("*.txt");
                                          
                        int iTemp = DoBrowse(hDlg, &uFilter, &pszMask, 1, IDC_EDIT1, TEXT("txt"), g_szLastBrowsePath);

                        MYDBGASSERT(0 != iTemp);

                        if (0 < iTemp) // -1 means the user cancelled
                        {
                            //
                            //  We want to copy the full path to the filename into g_szCmProxyFile so
                            //  that we have it for later in case the user wants to include it in the profile.
                            //
                            lstrcpy (g_szCmProxyFile, g_szLastBrowsePath);

                            //
                            //  We also want to save the last browse path so that when the user next
                            //  opens the browse dialog they will be in the same place they last
                            //  browsed from.
                            //
                            LPTSTR pszLastSlash = CmStrrchr(g_szLastBrowsePath, TEXT('\\'));

                            if (pszLastSlash)
                            {
                                pszLastSlash = CharNext(pszLastSlash);
                                *pszLastSlash = TEXT('\0');
                            }
                            else
                            {
                                g_szLastBrowsePath[0] = TEXT('\0');                        
                            }        
                        }
                    }
                    break;
                default:
                    break;
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));

                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:

                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));

                    //
                    //  Ensure we have a custom action list
                    //
                    if (NULL == g_pCustomActionList)
                    {
                        g_pCustomActionList = new CustomActionList;

                        MYDBGASSERT(g_pCustomActionList);

                        if (NULL == g_pCustomActionList)
                        {
                            return FALSE;
                        }

                        //
                        //  Read in the custom actions from the Cms File
                        //

                        hr = g_pCustomActionList->ReadCustomActionsFromCms(g_hInstance, g_szCmsFile, g_szShortServiceName);
                        CMASSERTMSG(SUCCEEDED(hr), TEXT("ProcessCmProxy -- Loading custom actions failed."));
                    }

                    //
                    //  Init the static variables to no proxy settings
                    //
                    bEnableCmProxy = FALSE;
                    bRestorePrevProxySettings = FALSE;
                    g_szCmProxyFile[0] = TEXT('\0');

                    //
                    //  Now lets search the custom action list for cmproxy
                    //
                    MYVERIFY(0 != LoadString(g_hInstance, IDS_CMPROXY_CON_DESC, szTemp, CELEMS(szTemp)));

                    hr = g_pCustomActionList->GetExistingActionData(g_hInstance, szTemp, ONCONNECT, &pCmProxyCustomAction);

                    if (SUCCEEDED(hr) && pCmProxyCustomAction)
                    {
                        //
                        //  Get the filename that the user specified and add it to the UI
                        //
                        if (FindSwitchInString(pCmProxyCustomAction->pszParameters, c_pszSourceFileNameSwitch, TRUE, szTemp)) // bReturnNextToken == TRUE
                        {
                            //
                            //  Figure out if we have the disconnect action too, ensuring to free the existing action first
                            //
                            CmFree(pCmProxyCustomAction->pszParameters);
                            CmFree(pCmProxyCustomAction);

                            wsprintf(g_szCmProxyFile, TEXT("%s\\%s"), g_szTempDir, szTemp);
                            bEnableCmProxy = TRUE;
                        
                            MYVERIFY(0 != LoadString(g_hInstance, IDS_CMPROXY_DIS_DESC, szTemp, CELEMS(szTemp)));

                            hr = g_pCustomActionList->GetExistingActionData(g_hInstance, szTemp, ONDISCONNECT, &pCmProxyCustomAction);

                            if (SUCCEEDED(hr) && pCmProxyCustomAction)
                            {
                                bRestorePrevProxySettings = TRUE;
                                CmFree(pCmProxyCustomAction->pszParameters);
                                CmFree(pCmProxyCustomAction);
                            }
                        }
                        else
                        {
                            CmFree(pCmProxyCustomAction->pszParameters);
                            CmFree(pCmProxyCustomAction);
                            CMASSERTMSG(FALSE, TEXT("ProcessCmProxy -- parameter string format incorrect"));
                        }
                    }
                    
                    MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK1, bRestorePrevProxySettings));
                    MYVERIFY(0 != CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, (bEnableCmProxy ? IDC_RADIO2 : IDC_RADIO1)));
                    MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDIT1), WM_SETTEXT, 0, (LPARAM)GetName(g_szCmProxyFile)));

                    //
                    //  Now make sure the correct set of controls is enabled.
                    //
                    EnableDisableCmProxyControls(hDlg);

                    break;

                case PSN_WIZBACK:

                case PSN_WIZNEXT:

                    //
                    //  Get the checkbox and radio button state
                    //
                    bEnableCmProxy = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO2));
                    bRestorePrevProxySettings = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_CHECK1));

                    if (bEnableCmProxy)
                    {
                        //
                        //  Lets get the proxy file and verify that they gave us a file and that
                        //  the file actually exists.
                        //
                        if (-1 == GetTextFromControl(hDlg, IDC_EDIT1, szTemp, MAX_PATH, TRUE)) // bDisplayError == TRUE
                        {
                            SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }

                        CmStrTrim(szTemp);

                        if (TEXT('\0') == szTemp[0])
                        {
                            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NEED_PROXY_FILE, MB_OK));
 
                            SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
 
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;                        
                        }

                        if (!VerifyFile(hDlg, IDC_EDIT1, g_szCmProxyFile, TRUE))
                        {
                            SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                            return TRUE;
                        }

                        //
                        //  Lets copy the proxy file to the temp dir
                        //
                        wsprintf(szTemp, TEXT("%s\\%s"), g_szTempDir, GetName(g_szCmProxyFile));

                        if (0 != lstrcmpi(szTemp, g_szCmProxyFile))
                        {
                            MYVERIFY(TRUE == CopyFileWrapper(g_szCmProxyFile, szTemp, FALSE));
                            MYVERIFY(0 != SetFileAttributes(szTemp, FILE_ATTRIBUTE_NORMAL));
                        }

                        //
                        //  Now we have all of the data we need, lets build the custom action struct and then
                        //  either edit it or add it depending on whether it already exists or not.
                        //
                        MYVERIFY(LoadString(g_hInstance, IDS_CMPROXY_CON_DESC, szTemp, CELEMS(szTemp)));

                        if (szTemp[0])
                        {
                            hr = g_pCustomActionList->GetExistingActionData(g_hInstance, szTemp, ONCONNECT, &pCmProxyCustomAction);

                            if (SUCCEEDED(hr))
                            {
                                FillInCustomActionStructWithCmProxy(bRestorePrevProxySettings, &UpdatedCmProxyAction, 
                                                                    FALSE, GetName(g_szCmProxyFile)); // bDisconnectAction == FALSE

                                hr = g_pCustomActionList->Edit(g_hInstance, pCmProxyCustomAction, &UpdatedCmProxyAction, g_szShortServiceName);
                                MYVERIFY(SUCCEEDED(hr));

                                CmFree(UpdatedCmProxyAction.pszParameters);
                                UpdatedCmProxyAction.pszParameters = NULL;

                                CmFree(pCmProxyCustomAction->pszParameters);
                                CmFree(pCmProxyCustomAction);
                            }
                            else
                            {
                                FillInCustomActionStructWithCmProxy(bRestorePrevProxySettings, &UpdatedCmProxyAction, 
                                                                    FALSE, GetName(g_szCmProxyFile)); // bDisconnectAction == FALSE

                                hr = g_pCustomActionList->Add(g_hInstance, &UpdatedCmProxyAction, g_szShortServiceName);
                                CmFree(UpdatedCmProxyAction.pszParameters);
                                UpdatedCmProxyAction.pszParameters = NULL;

                                MYVERIFY(SUCCEEDED(hr));
                            }
                        }
                    }
                    else
                    {
                        //
                        //  Clear out the global proxy file path
                        //
                        g_szCmProxyFile[0] = TEXT('\0');

                        //
                        //  The user doesn't want cmproxy.  Delete it from the connect action list.
                        //
                        MYVERIFY(LoadString(g_hInstance, IDS_CMPROXY_CON_DESC, szTemp, CELEMS(szTemp)));

                        g_pCustomActionList->Delete(g_hInstance, szTemp, ONCONNECT);
                    }

                    //
                    //  Now do the same for the disconnect cmproxy action if needed
                    //
                    if (bEnableCmProxy && bRestorePrevProxySettings)
                    {
                        MYVERIFY(LoadString(g_hInstance, IDS_CMPROXY_DIS_DESC, szTemp, CELEMS(szTemp)));

                        if (szTemp[0])
                        {
                            hr = g_pCustomActionList->GetExistingActionData(g_hInstance, szTemp, ONDISCONNECT, &pCmProxyCustomAction);

                            if (S_OK == hr)
                            {
                                FillInCustomActionStructWithCmProxy(bRestorePrevProxySettings, &UpdatedCmProxyAction, 
                                                                    TRUE, GetName(g_szCmProxyFile)); // bDisconnectAction == TRUE

                                hr = g_pCustomActionList->Edit(g_hInstance, pCmProxyCustomAction, &UpdatedCmProxyAction, g_szShortServiceName);
                                MYVERIFY(SUCCEEDED(hr));

                                CmFree(UpdatedCmProxyAction.pszParameters);
                                UpdatedCmProxyAction.pszParameters = NULL;

                                CmFree(pCmProxyCustomAction->pszParameters);
                                CmFree(pCmProxyCustomAction);
                            }
                            else
                            {
                                FillInCustomActionStructWithCmProxy(bRestorePrevProxySettings, &UpdatedCmProxyAction, 
                                                                    TRUE, GetName(g_szCmProxyFile)); // bDisconnectAction == TRUE

                                hr = g_pCustomActionList->Add(g_hInstance, &UpdatedCmProxyAction, g_szShortServiceName);
                                MYVERIFY(SUCCEEDED(hr));

                                CmFree(UpdatedCmProxyAction.pszParameters);
                                UpdatedCmProxyAction.pszParameters = NULL;
                            }
                        }
                    }
                    else
                    {
                        //
                        //  Now try to delete the disconnect action
                        //
                        MYVERIFY(LoadString(g_hInstance, IDS_CMPROXY_DIS_DESC, szTemp, CELEMS(szTemp)));

                        if (szTemp[0])
                        {
                            g_pCustomActionList->Delete(g_hInstance, szTemp, ONDISCONNECT);
                        }
                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

void EnableDisableCmRouteControls(HWND hDlg)
{
    BOOL bCmRouteEnabled = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO2));
    
    HWND hControl = GetDlgItem(hDlg, IDC_ROUTE_FILE);
    EnableWindow(hControl, bCmRouteEnabled);

    hControl = GetDlgItem(hDlg, IDC_ROUTE_FILE_LABEL);
    EnableWindow(hControl, bCmRouteEnabled);

    hControl = GetDlgItem(hDlg, IDC_ROUTE_URL);
    EnableWindow(hControl, bCmRouteEnabled);

    hControl = GetDlgItem(hDlg, IDC_ROUTE_URL_LABEL);
    EnableWindow(hControl, bCmRouteEnabled);

    //
    //  We only want to enable the require URL checkbox if there is text in the URL field.
    //
    LRESULT lResult = SendDlgItemMessage(hDlg, IDC_ROUTE_URL, WM_GETTEXTLENGTH, 0, 0);

    hControl = GetDlgItem(hDlg, IDC_CHECK1);
    EnableWindow(hControl, bCmRouteEnabled && lResult);    

    hControl = GetDlgItem(hDlg, IDC_CHECK2);
    EnableWindow(hControl, bCmRouteEnabled);
}

BOOL FindSwitchInString(LPCTSTR pszStringToSearch, LPCTSTR pszSwitchToFind, BOOL bReturnNextToken, LPTSTR pszToken)
{
    if ((NULL == pszStringToSearch) || (NULL == pszSwitchToFind) || (bReturnNextToken && (NULL == pszToken)))
    {
        CMASSERTMSG(FALSE, TEXT("FindSwitchInString -- invalid parameter"));
        return FALSE;
    }

    BOOL bReturn = FALSE;
    BOOL bLongFileName = FALSE;
    LPTSTR pszSourceFileName = CmStrStr(pszStringToSearch, pszSwitchToFind);
    
    if (pszSourceFileName)
    {
        if (bReturnNextToken)
        {
            pszSourceFileName = pszSourceFileName + lstrlen(pszSwitchToFind);

            while (CmIsSpace(pszSourceFileName))
            {
                pszSourceFileName = CharNext(pszSourceFileName);
            }

            if (TEXT('"') == *pszSourceFileName)
            {
                bLongFileName = TRUE;
                pszSourceFileName = CharNext(pszSourceFileName);
            }
            
            LPTSTR pszCurrent = pszSourceFileName;
            while (pszCurrent && (TEXT('\0') != *pszCurrent))
            {
                if (bLongFileName && (TEXT('"') == *pszCurrent))
                {
                    break;
                }
                else if ((FALSE == bLongFileName) && (CmIsSpace(pszCurrent)))
                {
                    break;
                }

                pszCurrent = CharNext(pszCurrent);
            }

            if (pszCurrent)
            {
                lstrcpyn(pszToken, pszSourceFileName, (int)(pszCurrent - pszSourceFileName + 1));
                bReturn = TRUE;
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("FindSwitchInString -- unable to find next token to return"));
            }
        }
        else
        {
            bReturn = TRUE;
        }
    }

    return bReturn;
}

HRESULT BuildCustomActionParamString(LPTSTR* aArrayOfStrings, UINT uCountOfStrings, LPTSTR* ppszParamsOutput)
{
    if ((NULL == aArrayOfStrings) || (0 == uCountOfStrings) || (NULL == ppszParamsOutput))
    {
        CMASSERTMSG(FALSE, TEXT("BuildCustomActionParamString -- Invalid Parameter"));
        return E_INVALIDARG;
    }

    UINT uMemoryNeeded = 0;
    LPTSTR pszCurrent;
    BOOL bNeedQuotes;
    
    //
    //  First lets figure out how much memory we need to allocate
    //
    for (UINT i = 0; i < uCountOfStrings; i++)
    {
        if (aArrayOfStrings[i] && (TEXT('\0') != aArrayOfStrings[i]))
        {
            uMemoryNeeded = uMemoryNeeded + lstrlen(aArrayOfStrings[i]);

            //
            //  Next check to see if we need double quotes around the item because it contains spaces
            //
            pszCurrent = (LPTSTR)aArrayOfStrings[i];
            bNeedQuotes = FALSE;

            while (pszCurrent && (TEXT('\0') != *pszCurrent))
            {
                if (CmIsSpace(pszCurrent))
                {
                    bNeedQuotes = TRUE;
                    break;
                }

                pszCurrent = CharNext(pszCurrent);
            }

            //
            //  Add the item to the string, making sure to add a space if this isn't the last
            //  item in the list
            //
            if (bNeedQuotes)
            {
                uMemoryNeeded = uMemoryNeeded + 2;
            }

            //
            //  Add a space unless this is the last item in the list
            //
            if (i < (uCountOfStrings - 1))
            {
                uMemoryNeeded++;
            }
        }
    }

    //
    //  Make sure to add one for the null terminator and multiply by the size of a character
    //
    uMemoryNeeded = (uMemoryNeeded + 1)*sizeof(TCHAR);

    //
    //  Now allocate the memory we need
    //

    *ppszParamsOutput = (LPTSTR)CmMalloc(uMemoryNeeded);

    //
    //  Finally copy over the data
    //
    if (*ppszParamsOutput)
    {

        for (UINT i = 0; i < uCountOfStrings; i++)
        {
            if (aArrayOfStrings[i] && (TEXT('\0') != aArrayOfStrings[i]))
            {
                //
                //  Next check to see if we need double quotes around the item because it contains spaces
                //
                pszCurrent = (LPTSTR)aArrayOfStrings[i];
                bNeedQuotes = FALSE;

                while (pszCurrent && (TEXT('\0') != *pszCurrent))
                {
                    if (CmIsSpace(pszCurrent))
                    {
                        bNeedQuotes = TRUE;
                        break;
                    }

                    pszCurrent = CharNext(pszCurrent);
                }

                //
                //  Add the item to the string, making sure to add a space if this isn't the last
                //  item in the list
                //
                if (bNeedQuotes)
                {
                    lstrcat(*ppszParamsOutput, TEXT("\""));
                }
            
                lstrcat(*ppszParamsOutput, aArrayOfStrings[i]);

                if (bNeedQuotes)
                {
                    lstrcat(*ppszParamsOutput, TEXT("\""));
                }

                //
                //  Add a space unless this is the last item in the list
                //
                if (i < (uCountOfStrings - 1))
                {
                    lstrcat(*ppszParamsOutput, TEXT(" "));
                }
            }
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

BOOL FillInCustomActionStructWithCmRoute(CustomActionListItem* pCustomAction,
                                         BOOL bDisconnectIfUrlUnavailable, LPCTSTR pszUrlPath, LPCTSTR pszRouteFile)
{
    BOOL bReturn = FALSE;

    MYDBGASSERT(pCustomAction && pszUrlPath && pszRouteFile && ((TEXT('\0') != pszRouteFile[0]) || (TEXT('\0') != pszUrlPath[0])));

    if (pCustomAction && pszUrlPath && pszRouteFile && ((TEXT('\0') != pszRouteFile[0]) || (TEXT('\0') != pszUrlPath[0])))
    {
        const TCHAR* const c_pszCmRouteFunction = TEXT("SetRoutes");
        const TCHAR* const c_pszProfileMacro = TEXT("%PROFILE%");

        MYVERIFY(LoadString(g_hInstance, IDS_CMROUTE_DESC, pCustomAction->szDescription, CELEMS(pCustomAction->szDescription)));
        pCustomAction->Type = ONCONNECT;
        wsprintf(pCustomAction->szProgram, TEXT("%s\\cmroute.dll"), g_szSupportDir);

        LPTSTR aArrayOfStrings[8] = {0};
        UINT uIndex = 0;

        if (TEXT('\0') != pszRouteFile[0])
        {
            aArrayOfStrings[uIndex] = (LPTSTR)c_pszProfileSwitch;
            uIndex++;

            aArrayOfStrings[uIndex] = (LPTSTR)c_pszProfileMacro;
            uIndex++;

            aArrayOfStrings[uIndex] = (LPTSTR)c_pszStaticFileNameSwitch;
            uIndex++;

            aArrayOfStrings[uIndex] = (LPTSTR)pszRouteFile;
            uIndex++;
        }

        if (TEXT('\0') != pszUrlPath[0])
        {
            aArrayOfStrings[uIndex] = (LPTSTR)c_pszUrlPathSwitch;
            uIndex++;

            aArrayOfStrings[uIndex] = (LPTSTR)pszUrlPath;
            uIndex++;
        }

        if ((FALSE == bDisconnectIfUrlUnavailable) && (TEXT('\0') != pszUrlPath[0]))
        {
            aArrayOfStrings[uIndex] = (LPTSTR)c_pszDontRequireUrlSwitch;
            uIndex++;
        }

        HRESULT hr = BuildCustomActionParamString(&(aArrayOfStrings[0]), uIndex, &(pCustomAction->pszParameters));
        MYDBGASSERT(SUCCEEDED(hr));
        
        lstrcpy(pCustomAction->szFunctionName, c_pszCmRouteFunction);
 
        pCustomAction->bIncludeBinary = TRUE;
        pCustomAction->bBuiltInAction = TRUE;
        pCustomAction->bTempDescription = FALSE;
        pCustomAction->dwFlags = ALL_CONNECTIONS;

        bReturn = (NULL != pCustomAction->pszParameters);
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessRoutePlumbing
//
// Synopsis:  Add Route Plumbing information
//
// History:   quintinb  Created     03/23/00
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessRoutePlumbing(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    NMHDR* pnmHeader = (NMHDR*)lParam;    

    BOOL bEnableRoutePlumbing;
    BOOL bDisconnectIfUrlUnavailable;
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szUrlPath[MAX_PATH+1];

    HRESULT hr;
    CustomActionListItem UpdatedCmRouteAction;
    CustomActionListItem* pCmRouteCustomAction = NULL;

    ProcessBold(hDlg, message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_RTPLUMB)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_ROUTE_FILE);
    SetDefaultGUIFont(hDlg,message,IDC_ROUTE_URL);


    switch (message)
    {
        case WM_INITDIALOG:
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_ROUTE_URL:

                    if (HIWORD(wParam) == EN_CHANGE) 
                    {
                        EnableDisableCmRouteControls(hDlg);
                        return (TRUE);
                    }
                    break;

                case IDC_RADIO1:
                case IDC_RADIO2:
                    EnableDisableCmRouteControls(hDlg);
                    break;

                case IDC_BUTTON1: // browse 
                    {
                        //
                        //  If the user clicked the browse button without clicking the CmRoute radio button,
                        //  then we need to set the radio and make sure the other CmRoute controls are
                        //  enabled.
                        //
                        MYVERIFY(0 != CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2));
                        EnableDisableCmRouteControls(hDlg);

                        UINT uFilter = IDS_TXTFILTER;
                        TCHAR* pszMask = TEXT("*.txt");
                                          
                        int iTemp = DoBrowse(hDlg, &uFilter, &pszMask, 1, IDC_ROUTE_FILE, TEXT("txt"), g_szLastBrowsePath);

                        MYDBGASSERT(0 != iTemp);

                        if (0 < iTemp) // -1 means the user cancelled
                        {
                            //
                            //  We want to copy the full path to the filename into g_szCmRouteFile so
                            //  that we have it for later in case the user wants to include it in the profile.
                            //
                            lstrcpy (g_szCmRouteFile, g_szLastBrowsePath);

                            //
                            //  We also want to save the last browse path so that when the user next
                            //  opens the browse dialog they will be in the same place they last
                            //  browsed from.
                            //
                            LPTSTR pszLastSlash = CmStrrchr(g_szLastBrowsePath, TEXT('\\'));

                            if (pszLastSlash)
                            {
                                pszLastSlash = CharNext(pszLastSlash);
                                *pszLastSlash = TEXT('\0');
                            }
                            else
                            {
                                g_szLastBrowsePath[0] = TEXT('\0');                        
                            }        
                        }
                    }
                    break;
                default:
                    break;
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));

                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:

                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));

                    //
                    //  Ensure we have a custom action list
                    //
                    if (NULL == g_pCustomActionList)
                    {
                        g_pCustomActionList = new CustomActionList;

                        MYDBGASSERT(g_pCustomActionList);

                        if (NULL == g_pCustomActionList)
                        {
                            return FALSE;
                        }

                        //
                        //  Read in the custom actions from the Cms File
                        //

                        hr = g_pCustomActionList->ReadCustomActionsFromCms(g_hInstance, g_szCmsFile, g_szShortServiceName);
                        CMASSERTMSG(SUCCEEDED(hr), TEXT("ProcessRoutePlumbing -- Loading custom actions failed."));
                    }

                    //
                    //  Init the static variables to no route plumbing
                    //
                    bEnableRoutePlumbing = FALSE;
                    bDisconnectIfUrlUnavailable = TRUE; // default behavior is to disconnect if URL is unreachable
                    g_szCmRouteFile[0] = TEXT('\0');
                    szUrlPath[0] = TEXT('\0');

                    //
                    //  Now lets search the custom action list for cmproxy
                    //
                    MYVERIFY(0 != LoadString(g_hInstance, IDS_CMROUTE_DESC, szTemp, CELEMS(szTemp)));

                    hr = g_pCustomActionList->GetExistingActionData(g_hInstance, szTemp, ONCONNECT, &pCmRouteCustomAction);

                    if (SUCCEEDED(hr))
                    {
                        //
                        //  Enable Route plumbing
                        //
                        bEnableRoutePlumbing = TRUE;

                        //
                        //  Get the name of the static text file specified for cmroute.dll
                        //
                        if (FindSwitchInString(pCmRouteCustomAction->pszParameters, c_pszStaticFileNameSwitch, TRUE, szTemp)) //bReturnNextToken == TRUE
                        {
                            wsprintf(g_szCmRouteFile, TEXT("%s\\%s"), g_szTempDir, szTemp);
                        }

                        //
                        //  Get the name of the URL to a route file
                        //
                        if (FindSwitchInString(pCmRouteCustomAction->pszParameters, c_pszUrlPathSwitch, TRUE, szUrlPath)) //bReturnNextToken == TRUE
                        {
                            bDisconnectIfUrlUnavailable = (FALSE == FindSwitchInString(pCmRouteCustomAction->pszParameters, 
                                                                                       c_pszDontRequireUrlSwitch, FALSE, NULL)); //bReturnNextToken == FALSE
                        }

                        CmFree(pCmRouteCustomAction->pszParameters);
                        CmFree(pCmRouteCustomAction);
                    }

                    MYVERIFY(0 != CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, (bEnableRoutePlumbing ? IDC_RADIO2 : IDC_RADIO1)));
                    MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_ROUTE_FILE), WM_SETTEXT, 0, (LPARAM)GetName(g_szCmRouteFile)));
                    MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_ROUTE_URL), WM_SETTEXT, 0, (LPARAM)szUrlPath));

                    MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK1, bDisconnectIfUrlUnavailable));

                    //
                    //  Now make sure the correct set of controls is enabled.
                    //
                    EnableDisableCmRouteControls(hDlg);

                    break;

                case PSN_WIZBACK:

                case PSN_WIZNEXT:
                    //
                    //  Lets figure out if Route plumbing should be enabled or not.
                    //

                    bEnableRoutePlumbing = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO2));

                    if (bEnableRoutePlumbing)
                    {
                        //
                        //  First try to get the static route file.  If we don't have one that is okay
                        //  as long as they gave us a route URL.
                        //
                        if (-1 == GetTextFromControl(hDlg, IDC_ROUTE_FILE, szTemp, MAX_PATH, TRUE)) // bDisplayError == TRUE
                        {
                            SetFocus(GetDlgItem(hDlg, IDC_ROUTE_FILE));
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }

                        CmStrTrim(szTemp);

                        if (-1 == GetTextFromControl(hDlg, IDC_ROUTE_URL, szUrlPath, MAX_PATH, TRUE)) // bDisplayError == TRUE
                        {
                            SetFocus(GetDlgItem(hDlg, IDC_ROUTE_URL));
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }

                        CmStrTrim(szUrlPath);

                        if ((TEXT('\0') == szTemp[0]) && (TEXT('\0') == szUrlPath[0]))
                        {
                            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NEED_ROUTE_FILE, MB_OK));
 
                            SetFocus(GetDlgItem(hDlg, IDC_ROUTE_FILE));
 
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;                        
                        }

                        //
                        //  If they gave us a static route file then we need to verify it
                        //
                        if (TEXT('\0') != szTemp[0])
                        {
                            if (!VerifyFile(hDlg, IDC_ROUTE_FILE, g_szCmRouteFile, TRUE))
                            {
                                SetFocus(GetDlgItem(hDlg, IDC_ROUTE_FILE));
                                return TRUE;
                            }
                            else
                            {
                                //
                                //  Lets copy the route file to the temp dir
                                //
                                wsprintf(szTemp, TEXT("%s\\%s"), g_szTempDir, GetName(g_szCmRouteFile));

                                if (0 != lstrcmpi(szTemp, g_szCmRouteFile))
                                {
                                    MYVERIFY(TRUE == CopyFileWrapper(g_szCmRouteFile, szTemp, FALSE));
                                    MYVERIFY(0 != SetFileAttributes(szTemp, FILE_ATTRIBUTE_NORMAL));
                                }
                            }
                        }
                        else
                        {
                            g_szCmRouteFile[0] = TEXT('\0');
                        }

                        //
                        //  If they gave us a route URL then we need to make sure it starts with
                        //  http:// or https:// or file://, basically that it contains ://.  Note we
                        //  really don't do any validation here under the assumption that they will discover
                        //  it doesn't work when they test it if the URL is invalid.
                        //
                        if ((szUrlPath[0]) && (NULL == CmStrStr(szUrlPath, TEXT("://"))))
                        {
                            lstrcpy (szTemp, szUrlPath);
                            wsprintf (szUrlPath, TEXT("http://%s"), szTemp);
                        }

                        bDisconnectIfUrlUnavailable = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_CHECK1)); // note we don't write this if we don't have a URL path

                        //
                        //  Now we have all of the data we need, lets build the custom action struct and then
                        //  either edit it or add it depending on whether it already exists or not.
                        //
                        MYVERIFY(0 != LoadString(g_hInstance, IDS_CMROUTE_DESC, szTemp, CELEMS(szTemp)));

                        hr = g_pCustomActionList->GetExistingActionData(g_hInstance, szTemp, ONCONNECT, &pCmRouteCustomAction);

                        if (SUCCEEDED(hr))
                        {
                            FillInCustomActionStructWithCmRoute(&UpdatedCmRouteAction,
                                                                bDisconnectIfUrlUnavailable, szUrlPath, GetName(g_szCmRouteFile));

                            hr = g_pCustomActionList->Edit(g_hInstance, pCmRouteCustomAction, &UpdatedCmRouteAction, g_szShortServiceName);
                            MYVERIFY(SUCCEEDED(hr));

                            CmFree(UpdatedCmRouteAction.pszParameters);
                            UpdatedCmRouteAction.pszParameters = NULL;
                            CmFree(pCmRouteCustomAction->pszParameters);
                            CmFree(pCmRouteCustomAction);
                        }
                        else
                        {
                            FillInCustomActionStructWithCmRoute(&UpdatedCmRouteAction,
                                                                bDisconnectIfUrlUnavailable, szUrlPath, GetName(g_szCmRouteFile));

                            hr = g_pCustomActionList->Add(g_hInstance, &UpdatedCmRouteAction, g_szShortServiceName);
                            MYVERIFY(SUCCEEDED(hr));

                            CmFree(UpdatedCmRouteAction.pszParameters);
                            UpdatedCmRouteAction.pszParameters = NULL;
                        }
                    }
                    else
                    {
                        //
                        //  Clear out the global route file path
                        //
                        g_szCmRouteFile[0] = TEXT('\0');

                        //
                        //  The user doesn't want cmroute.  Delete it from the connect action list.
                        //

                        MYVERIFY(0 != LoadString(g_hInstance, IDS_CMROUTE_DESC, szTemp, CELEMS(szTemp)));

                        if (szTemp[0])
                        {
                            hr = g_pCustomActionList->Delete(g_hInstance, szTemp, ONCONNECT);
                        }                    
                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

void EnableDisableRealmControls(HWND hDlg)
{
    BOOL bRealmControlsEnabled = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO2));
    HWND hControl;

    hControl = GetDlgItem(hDlg, IDC_EDIT1);
    if (hControl)
    {
        EnableWindow(hControl, bRealmControlsEnabled);
    }

    hControl = GetDlgItem(hDlg, IDC_REALMNAME);
    if (hControl)
    {
        EnableWindow(hControl, bRealmControlsEnabled);
    }
    
    hControl = GetDlgItem(hDlg, IDC_RADIO3);
    if (hControl)
    {
        EnableWindow(hControl, bRealmControlsEnabled);
    }

    hControl = GetDlgItem(hDlg, IDC_RADIO4);
    if (hControl)
    {
        EnableWindow(hControl, bRealmControlsEnabled);
    }

    hControl = GetDlgItem(hDlg, IDC_REALM_SEP);
    if (hControl)
    {
        EnableWindow(hControl, bRealmControlsEnabled);
    }    
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessRealmInfo
//
// Synopsis:  Add a Realm Name
//
// History:   quintinb  Created Header and renamed from ProcessPage2B    8/6/98
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessRealmInfo(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szTemp[MAX_PATH+1];
    NMHDR* pnmHeader = (NMHDR*)lParam;
    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_REALM)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_EDIT1);

    switch (message)
    {
        case WM_INITDIALOG:
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_RADIO1:  //  Do not Add a Realm Name
                case IDC_RADIO2:  //  Add a Realm Name

                    EnableDisableRealmControls(hDlg);
                    break;

                default:
                    break;
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));

                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:

                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));
                    
                    //
                    //  The next two calls to GetPrivateProfileString could return empty strings, thus don't use MYVERIFY macro
                    //

                    ZeroMemory(g_szPrefix, sizeof(g_szPrefix));
                    GetPrivateProfileString(c_pszCmSection, c_pszCmEntryUserPrefix, TEXT(""), 
                        g_szPrefix, CELEMS(g_szPrefix), g_szCmsFile);  //lint !e534
                    
                    ZeroMemory(g_szSuffix, sizeof(g_szSuffix));
                    GetPrivateProfileString(c_pszCmSection, c_pszCmEntryUserSuffix, TEXT(""), 
                        g_szSuffix, CELEMS(g_szSuffix), g_szCmsFile);  //lint !e534
                    
                    if (*g_szSuffix)
                    {
                        MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO1, IDC_RADIO2, IDC_RADIO2));
                        MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO3, IDC_RADIO4, IDC_RADIO4));

                        MYVERIFY(TRUE == SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)MAX_PATH, (LPARAM) g_szSuffix));
                    }
                    else if (*g_szPrefix)
                    {                            
                        MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO1, IDC_RADIO2, IDC_RADIO2));
                        MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO3, IDC_RADIO4, IDC_RADIO3));

                        MYVERIFY(TRUE == SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)MAX_PATH, (LPARAM) g_szPrefix));
                    }
                    else
                    {
                        MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO1, IDC_RADIO2, IDC_RADIO1));
                        MYVERIFY(TRUE == SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)MAX_PATH, (LPARAM)TEXT("")));

                        //
                        //  Suffix is the default, set this just in case the user adds a suffix or prefix
                        //
                        MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO3, IDC_RADIO4, IDC_RADIO4));
                    }

                    EnableDisableRealmControls(hDlg);

                    break;

                case PSN_WIZBACK:

                case PSN_WIZNEXT:

                    //
                    //  First check if IDC_RADIO1 is checked, if so that means that the user
                    //  doesn't want Realm info
                    //

                    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO1))
                    {
                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection,c_pszCmEntryUserPrefix,TEXT(""),g_szCmsFile));
                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection,c_pszCmEntryUserSuffix,TEXT(""),g_szCmsFile));
                        g_szSuffix[0] = TEXT('\0');
                        g_szPrefix[0] = TEXT('\0');                    
                    }
                    else if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO2))
                    {
                        //
                        //  If Radio2 is checked then they do want Realm info and we need to 
                        //  see if the string exists and if it is convertable to ANSI form.
                        //
                        if (-1 == GetTextFromControl(hDlg, IDC_EDIT1, szTemp, MAX_PATH, TRUE)) // bDisplayError == TRUE
                        {
                            SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }

                        CmStrTrim(szTemp);

                        if (TEXT('\0') == szTemp[0])
                        {
                            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOREALM, MB_OK));
 
                            SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
 
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;                        
                        }
                    
                        //
                        //  Now check to see if this is a Prefix or a Suffix
                        //
                        if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO3)) // Prefix
                        {
                            _tcscpy(g_szPrefix, szTemp);
                            g_szSuffix[0] = TEXT('\0');

                            MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryUserPrefix, g_szPrefix, g_szCmsFile));
                            MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryUserSuffix, TEXT(""), g_szCmsFile));                            
                        }
                        else if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO4)) // Suffix
                        {
                            _tcscpy(g_szSuffix, szTemp);
                            g_szPrefix[0] = TEXT('\0');

                            MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryUserSuffix, g_szSuffix, g_szCmsFile));
                            MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryUserPrefix, TEXT(""), g_szCmsFile));
                        }
                        else
                        {
                            CMASSERTMSG(FALSE, TEXT("ProcessRealmInfo -- Unknown State, bailing"));
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;                        
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("ProcessRealmInfo -- Unknown State, bailing"));
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                        return 1;
                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

void RefreshList(HWND hwndDlg, UINT uCrtlId, ListBxList * HeadPtr)
{
    ListBxList * LoopPtr;

    SendDlgItemMessage(hwndDlg, IDC_LIST1, LB_RESETCONTENT, 0, (LPARAM)0); //lint !e534 LB_RESETCONTENT doesn't return anything
    
    if (HeadPtr == NULL)
    {
        return;
    }

    LoopPtr = HeadPtr;

    while( LoopPtr != NULL)
    {
        MYVERIFY(LB_ERR != SendDlgItemMessage(hwndDlg, uCrtlId, LB_ADDSTRING, 0, 
            (LPARAM)LoopPtr->szName));

        LoopPtr = LoopPtr->next;
    }
}

void RefreshComboList(HWND hwndDlg, ListBxList * HeadPtr)
{
    ListBxList * LoopPtr;

    SendDlgItemMessage(hwndDlg,IDC_COMBO1,CB_RESETCONTENT,0,(LPARAM)0); //lint !e534 CB_RESETCONTENT doesn't return anything useful
    if (HeadPtr == NULL)
    {
        return;
    }
    LoopPtr = HeadPtr;
    while( LoopPtr != NULL)
    {
        MYVERIFY(CB_ERR != SendDlgItemMessage(hwndDlg, IDC_COMBO1, CB_ADDSTRING, 0, 
            (LPARAM)LoopPtr->szName));

        LoopPtr = LoopPtr->next;
    }
}

void FreeList(ListBxList ** pHeadPtr, ListBxList ** pTailPtr)
{
    ListBxList * pTmpPtr;
    ListBxList * pLoopPtr = *pHeadPtr;

    while(NULL != pLoopPtr)
    {
        CmFree(pLoopPtr->ListBxData);
        pTmpPtr = pLoopPtr;
    
        pLoopPtr = pLoopPtr->next;

        CmFree(pTmpPtr);
    }

    *pHeadPtr = NULL;
    *pTailPtr = NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  MoveCmsFile
//
// Synopsis:  This function checks a referenced CMS file to see if it contains
//            script files.  If the CMS file contains script files, then it
//            copies them to the temporary directory and adds a referenced
//            file entry to the g_pHeadRefs linked list.
//
// Arguments: LPTSTR szFile - name of the cms file to move
//
// Returns:   BOOL - returns TRUE on Success
//
// History:   quintinb Created Header                           01/09/98
//            quintinb rewrote for the Unicode Converversion    06/14/99
//            quintinb updated for rewrite of DUN settings      03/21/00
//
//+----------------------------------------------------------------------------
BOOL MoveCmsFile(LPCTSTR pszCmsFile, LPCTSTR pszShortServiceName)
{
    BOOL bReturn = TRUE;
    ListBxList* pTmpHeadDns = NULL;
    ListBxList*  pTmpTailDns = NULL;
    ListBxList* pTmpCurrentDns = NULL;
    CDunSetting* pTmpDunSetting = NULL;
    TCHAR szFileName[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szDest[MAX_PATH+1];

    if ((NULL == pszCmsFile) || (NULL == pszShortServiceName) || 
        (TEXT('\0') == pszCmsFile[0]) || (TEXT('\0') == pszShortServiceName[0]))
    {
        return FALSE;    
    }

    //
    //  Get the Long Service Name from the profile just in case we need a default entry.  
    //
    GetPrivateProfileString(c_pszCmSection, c_pszCmEntryServiceName, 
    TEXT(""), szTemp, CELEMS(szTemp), pszCmsFile);   //lint !e534

    if (ReadNetworkSettings(pszCmsFile, szTemp, TEXT(""),  &pTmpHeadDns, &pTmpTailDns, g_szOsdir, FALSE)) // FALSE == bLookingForVpnEntries
    {
        if (NULL != pTmpHeadDns) // just return TRUE if no entries
        {
            pTmpCurrentDns = pTmpHeadDns;
            
            while (pTmpCurrentDns && pTmpCurrentDns->ListBxData)
            {
                pTmpDunSetting = (CDunSetting*)pTmpCurrentDns->ListBxData;

                if (TEXT('\0') != pTmpDunSetting->szScript[0])
                {
                    //
                    //  Then we have a script, lets copy it and then add it to the g_pHeadRefs List
                    //
                    GetFileName(pTmpDunSetting->szScript, szFileName);

                    MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s\\%s"), 
                                                             g_szOutdir, szFileName));
                    //
                    // Copy the Script File
                    //
                    if (CopyFileWrapper(pTmpDunSetting->szScript, szDest, FALSE))
                    {
                        MYVERIFY(0 != SetFileAttributes(szDest, FILE_ATTRIBUTE_NORMAL));
            
                        //
                        //  Add the file to the Referenced files list
                        //
                        bReturn = bReturn && createListBxRecord(&g_pHeadRefs, &g_pTailRefs, 
                                                                (void *)NULL, 0, szFileName);
            
                        //
                        //  Update the script section in the existing cms to point 
                        //  to the new directory.
                        //  Originally: [Scripting&Merge Profile Name]
                        //              Name=merge\script.scp
                        //  Becomes:    [Scripting&Merge Profile Name]
                        //              Name=toplvl\script.scp
                        //
                        //  Note the change in directory name so that the script file 
                        //  can be found.
                        //
                        TCHAR szSection[MAX_PATH+1];
                        MYVERIFY(CELEMS(szSection) > (UINT)wsprintf(szSection, TEXT("%s&%s"), 
                                                                    c_pszCmSectionDunScripting, 
                                                                    pTmpCurrentDns->szName));

                        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s"), 
                                                                 pszShortServiceName, szFileName));

                        MYVERIFY(0 != WritePrivateProfileString(szSection, 
                                                                c_pszCmEntryDunScriptingName, 
                                                                szTemp, pszCmsFile));
                    }
                }

                pTmpCurrentDns = pTmpCurrentDns->next;
            }
        }
    }
    else
    {
        CMTRACE1(TEXT("MoveCmsFile -- ReadDnsList Failed.  GetLastError Returns %d"), GetLastError());
        bReturn = FALSE;
        goto exit;
    }


exit:
    //
    //  Free the DNS List
    //

    FreeDnsList(&pTmpHeadDns, &pTmpTailDns);
    return (bReturn);
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessDunEntries
//
// Synopsis:  Set up Dial-up networking
//
// History:   quintinb  Created Header and renamed from ProcessPage2C  8/6/98
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessDunEntries(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    //
    //  We have a static Memory buffer and a static pointer
    //  so that we can know when the user has changed the phonebook
    //  on us (meaning we need to reread the Networking settings).
    //  Note that we use the static pointer to tell us if we have read
    //  the settings at least once.
    //
    static TCHAR szCachedPhoneBook[MAX_PATH+1] = {0};
    static TCHAR* pszCachedPhoneBook = NULL;
    NMHDR* pnmHeader = (NMHDR*)lParam;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_DENTRY)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_LIST1);

    switch (message)
    {
        case WM_INITDIALOG:
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_BUTTON1: //add
                    OnProcessDunEntriesAdd(g_hInstance, hDlg, IDC_LIST1, &g_pHeadDunEntry, &g_pTailDunEntry, FALSE, g_szLongServiceName, g_szCmsFile); // FALSE == bCreateTunnelEntry
                    return TRUE;

                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case IDC_BUTTON2: //edit
                    OnProcessDunEntriesEdit(g_hInstance, hDlg, IDC_LIST1, &g_pHeadDunEntry, &g_pTailDunEntry, g_szLongServiceName, g_szCmsFile);

                    return TRUE;

                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case IDC_BUTTON3: //delete
                    OnProcessDunEntriesDelete(g_hInstance, hDlg, IDC_LIST1, &g_pHeadDunEntry, &g_pTailDunEntry, g_szLongServiceName, g_szCmsFile);
                    return TRUE;

                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case IDC_LIST1:
                    if (LBN_SELCHANGE == HIWORD(wParam))
                    {
                        //
                        //  The selection in the listbox changed, lets figure out if we need to
                        //  enable/disable the delete button
                        //
                        EnableDisableDunEntryButtons(g_hInstance, hDlg, g_szCmsFile, g_szLongServiceName);
                    }
                    else if (LBN_DBLCLK == HIWORD(wParam))
                    {
                        OnProcessDunEntriesEdit(g_hInstance, hDlg, IDC_LIST1, &g_pHeadDunEntry, &g_pTailDunEntry, g_szLongServiceName, g_szCmsFile);                    
                    }
                    break;

                default:
                    break;
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));
                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));

                    //
                    //  To avoid reading the network settings more than we have to, we only want to
                    //  read the networking settings the first time the users hits this page or any
                    //  time the user changes the phonebook (if they clone the profile or edit a different
                    //  one, clearing this will be taken care of elsewhere).
                    //
                    if ((NULL == g_pHeadDunEntry) || (NULL == pszCachedPhoneBook) || lstrcmpi(g_szPhonebk, pszCachedPhoneBook))
                    {

                        FreeDnsList(&g_pHeadDunEntry, &g_pTailDunEntry);

                        MYVERIFY(ReadNetworkSettings(g_szCmsFile, g_szLongServiceName, g_szPhonebk, &g_pHeadDunEntry, &g_pTailDunEntry, g_szOsdir, FALSE)); //FALSE == bLookingForVpnEntries

                        pszCachedPhoneBook = szCachedPhoneBook;
                        lstrcpy(pszCachedPhoneBook, g_szPhonebk);
                    }

                    RefreshDnsList(g_hInstance, hDlg, IDC_LIST1, g_pHeadDunEntry, g_szLongServiceName, g_szCmsFile, NULL);
                    SetFocus(GetDlgItem(hDlg, IDC_BUTTON1));
                    EnableDisableDunEntryButtons(g_hInstance, hDlg, g_szCmsFile, g_szLongServiceName);

                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:

                    //
                    //  Before writing out the entries we must make sure that we don't have a name collision with entries
                    //  from the VPN list.  Thus we will check each name in the DUN entries list for a matching name in the
                    //  VPN entries list.  If we detect a collision, then we will throw an error message to the user and
                    //  let them deal with the problem.
                    //
                    if (!CheckForDUNversusVPNNameConflicts(hDlg, g_pHeadDunEntry, g_pHeadVpnEntry))
                    {
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                        return 1;
                    }

                    //
                    //  Now it is okay to write out the networking entries
                    //
                    WriteNetworkingEntries(g_szCmsFile, g_szLongServiceName, g_szShortServiceName, g_pHeadDunEntry);

                    //
                    //  If we aren't updating the phonebook then we need to go right back to the phonebook page
                    //  and skip the pbk update page
                    //
                    if (pnmHeader && (PSN_WIZBACK == pnmHeader->code) && !g_bUpdatePhonebook) 
                    {                        
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, IDD_PHONEBOOK));
                    }
                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}


//+----------------------------------------------------------------------------
//
// Function:  DoesSomeVPNsettingUsePresharedKey
//
// Synopsis:  Checks VPN DUN settings to see if any chose to use a preshared key
//
// Returns:   BOOL (TRUE if some VPN setting does use a pre-shared key)
//
// History:   25-Apr-2001   SumitC    Created
//
//+----------------------------------------------------------------------------
BOOL DoesSomeVPNsettingUsePresharedKey()
{
    BOOL         bReturn = FALSE;
    ListBxList * ptr = g_pHeadVpnEntry;

    if (g_bUseTunneling)
    {
        while (ptr != NULL)
        {
            CDunSetting * pDunSetting = (CDunSetting*)(ptr->ListBxData);

            if (pDunSetting && pDunSetting->bUsePresharedKey)
            {
                bReturn = TRUE;
                break;
            }
            ptr = ptr->next;
        }
    }

    return bReturn;
}


INT_PTR APIENTRY ProcessVpnEntries(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    //
    //  We have a static Memory buffer and a static pointer
    //  so that we can know when the user has changed the phonebook
    //  on us (meaning we need to reread the Networking settings).
    //  Note that we use the static pointer to tell us if we have read
    //  the settings at least once.
    //
    BOOL bFreeDunList = FALSE;
    static TCHAR szCachedPhoneBook[MAX_PATH+1] = {0};
    static TCHAR* pszCachedPhoneBook = NULL;
    NMHDR* pnmHeader = (NMHDR*)lParam;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_VENTRY)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_LIST1);

    switch (message)
    {
        case WM_INITDIALOG:
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDC_BUTTON1: //add
                    OnProcessDunEntriesAdd(g_hInstance, hDlg, IDC_LIST1, &g_pHeadVpnEntry, &g_pTailVpnEntry, TRUE, g_szLongServiceName, g_szCmsFile); // TRUE == bCreateTunnelEntry
                    return TRUE;

                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case IDC_BUTTON2: //edit
                    OnProcessDunEntriesEdit(g_hInstance, hDlg, IDC_LIST1, &g_pHeadVpnEntry, &g_pTailVpnEntry, g_szLongServiceName, g_szCmsFile);

                    return TRUE;

                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case IDC_BUTTON3: //delete
                    OnProcessDunEntriesDelete(g_hInstance, hDlg, IDC_LIST1, &g_pHeadVpnEntry, &g_pTailVpnEntry, g_szLongServiceName, g_szCmsFile);
                    return TRUE;

                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case IDC_LIST1:
                    if (LBN_SELCHANGE == HIWORD(wParam))
                    {
                        //
                        //  The selection in the listbox changed, lets figure out if we need to
                        //  enable/disable the delete button
                        //
                        EnableDisableDunEntryButtons(g_hInstance, hDlg, g_szCmsFile, g_szLongServiceName);
                    }
                    else if (LBN_DBLCLK == HIWORD(wParam))
                    {
                        OnProcessDunEntriesEdit(g_hInstance, hDlg, IDC_LIST1, &g_pHeadVpnEntry, &g_pTailVpnEntry, g_szLongServiceName, g_szCmsFile);                    
                    }
                    break;

                default:
                    break;
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));
                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));

                    //
                    //  To avoid reading the network settings more than we have to, we only want to
                    //  read the networking settings the first time the users hits this page or any
                    //  time the user changes the VPN File (if they clone the profile or edit a different
                    //  one, clearing this will be taken care of elsewhere).
                    //
                    if ((NULL == g_pHeadVpnEntry) || (NULL == pszCachedPhoneBook) || lstrcmpi(g_szVpnFile, pszCachedPhoneBook))
                    {
                        FreeDnsList(&g_pHeadVpnEntry, &g_pTailVpnEntry);

                        MYVERIFY(ReadNetworkSettings(g_szCmsFile, g_szLongServiceName, g_szVpnFile, &g_pHeadVpnEntry, &g_pTailVpnEntry, g_szOsdir, TRUE)); //TRUE == bLookingForVpnEntries

                        pszCachedPhoneBook = szCachedPhoneBook;
                        lstrcpy(pszCachedPhoneBook, g_szVpnFile);
                    }

                    RefreshDnsList(g_hInstance, hDlg, IDC_LIST1, g_pHeadVpnEntry, g_szLongServiceName, g_szCmsFile, NULL);
                    SetFocus(GetDlgItem(hDlg, IDC_BUTTON1));
                    EnableDisableDunEntryButtons(g_hInstance, hDlg, g_szCmsFile, g_szLongServiceName);

                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:

                    //
                    //  Before writing out the entries we must make sure that we don't have a name collision with entries
                    //  from the DUN list.  Thus we will check each name in the VPN entries list for a matching name in the
                    //  DUN entries list.  If we detect a collision, then we will throw an error message to the user and
                    //  let them deal with the problem.  One further complication here is that the DUN entries list may not be
                    //  read in yet and we can't read it in permanently in that case since the phonebook may not have been
                    //  given yet or may change.  Thus we will read in a temp copy to compare against if the list pointer is NULL.
                    //

                    if (NULL == g_pHeadDunEntry)
                    {
                        bFreeDunList = TRUE;
                        MYVERIFY(ReadNetworkSettings(g_szCmsFile, g_szLongServiceName, g_szPhonebk, &g_pHeadDunEntry, &g_pTailDunEntry, g_szOsdir, FALSE)); //FALSE == bLookingForVpnEntries
                    }

                    if (!CheckForDUNversusVPNNameConflicts(hDlg, g_pHeadDunEntry, g_pHeadVpnEntry))
                    {
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                        return 1;
                    }

                    if (bFreeDunList)
                    {
                        FreeDnsList(&g_pHeadDunEntry, &g_pTailDunEntry);
                    }

                    //
                    //  Okay, now it's safe to write out the entries
                    //
                    WriteNetworkingEntries(g_szCmsFile, g_szLongServiceName, g_szShortServiceName, g_pHeadVpnEntry);

                    //
                    //  If any of the VPN dun settings has Pre-shared key enabled, go to the Pre-Shared key page
                    //
                    if (g_pHeadVpnEntry)
                    {
                        //
                        //  If we are going forward, skip the Pre-shared key page if
                        //  no DUN entries have Preshared key enabled.
                        //
                        g_bPresharedKeyNeeded = DoesSomeVPNsettingUsePresharedKey();
                        if (pnmHeader && (PSN_WIZNEXT == pnmHeader->code) && !g_bPresharedKeyNeeded)
                        {
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, IDD_PHONEBOOK));
                        }
                    }
                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

void EnableDisableTunnelAddressControls(HWND hDlg)
{
    BOOL bEnabledTunnelControls = IsDlgButtonChecked(hDlg, IDC_CHECK1) || IsDlgButtonChecked(hDlg, IDC_CHECK2);
    BOOL bUseVpnFile = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO2));

    //
    //  Enable/Disable the single VPN Server Edit control
    //
    HWND hControl = GetDlgItem(hDlg, IDC_RADIO1);
    EnableWindow(hControl, bEnabledTunnelControls);

    hControl = GetDlgItem(hDlg, IDC_EDIT1);
    EnableWindow(hControl, (bEnabledTunnelControls && !bUseVpnFile));

    //
    //  Enable/Disable the VPN File edit control, and browse button
    //
    hControl = GetDlgItem(hDlg, IDC_RADIO2);
    EnableWindow(hControl, bEnabledTunnelControls);

    hControl = GetDlgItem(hDlg, IDC_EDIT2);
    EnableWindow(hControl, (bEnabledTunnelControls && bUseVpnFile));

    hControl = GetDlgItem(hDlg, IDC_BUTTON1);
    EnableWindow(hControl, bEnabledTunnelControls);

    //
    //  Enable/Disable the use same username checkbox
    //
    hControl = GetDlgItem(hDlg, IDC_CHECK3);
    EnableWindow(hControl, bEnabledTunnelControls);
}


//+----------------------------------------------------------------------------
//
// Function:  ProcessTunneling
//
// Synopsis:  Setup Tunneling
//
//
// History:   quintinb  Created Header and renamed from ProcessPage2E    8/6/98
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessTunneling(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    UINT uEditControl = 0;
    UINT uRadioButton = 0;
    UINT uMissingMsgId = 0;
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szTempVpnFile[MAX_PATH+1];
    NMHDR* pnmHeader = (NMHDR*)lParam;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_SECURE)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;

    switch (message)
    {

    case WM_INITDIALOG:

            SetFocus(GetDlgItem(hDlg, IDC_CHECK1));
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_RADIO1:
                case IDC_RADIO2:
                case IDC_CHECK1:
                case IDC_CHECK2:
                    EnableDisableTunnelAddressControls(hDlg);                    
                    break;

                case IDC_BUTTON1: // Browse button
                    {

                        //
                        //  If the user clicked the browse button without clicking the VPN File radio button,
                        //  then we need to set the radio and make sure the other controls are
                        //  enabled.
                        //
                        MYVERIFY(0 != CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2));
                        EnableDisableTunnelAddressControls(hDlg);

                        UINT uFilter = IDS_TXTFILTER;
                        TCHAR* pszMask = TEXT("*.txt");
                                          
                        int iTemp = DoBrowse(hDlg, &uFilter, &pszMask, 1, IDC_EDIT2, TEXT("txt"), g_szLastBrowsePath);

                        MYDBGASSERT(0 != iTemp);

                        if (0 < iTemp) // -1 means the user cancelled
                        {
                            //
                            //  We want to copy the full path to the filename into g_szVpnFile so
                            //  that we have it for later in case the user wants to include it in the profile.
                            //
                            lstrcpy (g_szVpnFile, g_szLastBrowsePath);

                            //
                            //  We also want to save the last browse path so that when the user next
                            //  opens the browse dialog they will be in the same place they last
                            //  browsed from.
                            //
                            LPTSTR pszLastSlash = CmStrrchr(g_szLastBrowsePath, TEXT('\\'));

                            if (pszLastSlash)
                            {
                                pszLastSlash = CharNext(pszLastSlash);
                                *pszLastSlash = TEXT('\0');
                            }
                            else
                            {
                                g_szLastBrowsePath[0] = TEXT('\0');                        
                            }        
                        }
                    }
                    break;

                default:
                    break;
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {
                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));
                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:
                                        
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));
                    
                    //
                    //  Is this a tunneling profile?  If so, check the tunnel this profile checkbox
                    //
                    MYVERIFY(0 != GetPrivateProfileString(c_pszCmSection, 
                        c_pszCmEntryTunnelPrimary, c_pszZero, szTemp, CELEMS(szTemp), g_szCmsFile));
                    
                    MYVERIFY(0 != CheckDlgButton(hDlg,IDC_CHECK1,(*szTemp == TEXT('1'))));

                    //
                    //  If we have merged profiles and the profile has tunnel references turned on then
                    //  we want to check the tunnel references checkbox.
                    //
                    if (g_pHeadMerge == NULL)
                    {
                        MYVERIFY(0 != CheckDlgButton(hDlg,IDC_CHECK2,FALSE));
                        EnableWindow(GetDlgItem(hDlg,IDC_CHECK2),FALSE);
                    }
                    else
                    {
                        EnableWindow(GetDlgItem(hDlg,IDC_CHECK2),TRUE);
                        MYVERIFY(0 != GetPrivateProfileString(c_pszCmSection, c_pszCmEntryTunnelReferences, 
                            c_pszZero, szTemp, CELEMS(szTemp), g_szCmsFile));
                        MYVERIFY(0 != CheckDlgButton(hDlg,IDC_CHECK2,(*szTemp == TEXT('1'))));
                    }

                    //
                    //  Now we need to decide if we have a VPN File for this profile or just a single
                    //  Tunnel Address.  First try the TunnelFile entry.
                    //
                    szTemp[0] = TEXT('\0');
                    szTempVpnFile[0] = TEXT('\0');

                    GetPrivateProfileString(c_pszCmSection, c_pszCmEntryTunnelFile, TEXT(""), 
                        szTempVpnFile, CELEMS(szTempVpnFile), g_szCmsFile);    //lint !e534

                    if (TEXT('\0') != szTempVpnFile[0])
                    {
                        //
                        //  The VpnFile text should be a relative path (corpras\vpn.txt) and
                        //  thus we will want to add the path to the profile dir in front of it.
                        //
                        wsprintf(g_szVpnFile, TEXT("%s%s"), g_szOsdir, szTempVpnFile);

                        //
                        //  Now verify that this exists
                        //
                        if (FileExists(g_szVpnFile))
                        {
                            LPTSTR pszSlash = CmStrrchr(g_szVpnFile, TEXT('\\'));

                            if (pszSlash)
                            {
                                pszSlash = CharNext(pszSlash);
                                lstrcpy(szTempVpnFile, pszSlash);                        
                            }                        
                        }
                        else
                        {
                            //
                            //  This might just mean that the file is in the temp dir and we haven't
                            //  created a dir under profiles yet ... Lets try looking for the file
                            //  in the temp dir instead.
                            //
                            LPTSTR pszSlash = CmStrrchr(g_szVpnFile, TEXT('\\'));

                            if (pszSlash)
                            {
                                pszSlash = CharNext(pszSlash);
                                lstrcpy(szTempVpnFile, pszSlash);                        
                            }
                            
                            wsprintf(g_szVpnFile, TEXT("%s\\%s"), g_szTempDir, szTempVpnFile);
                            
                            if (!FileExists(g_szVpnFile))
                            {
                                //
                                //  Well, we still didn't find it.  Looks like the user has us baffled at this point.
                                //  Clear out the buffers and the user will be forced to fill in the correct
                                //  file path before continuing.
                                //
                                g_szVpnFile[0] = TEXT('\0');
                                szTempVpnFile[0] = TEXT('\0');                            
                            }
                        }

                        uRadioButton = IDC_RADIO2;
                    }
                    else
                    {
                        //
                        //  We didn't get a VPN file so lets try for a Tunnel Address
                        //
                        GetPrivateProfileString(c_pszCmSection, c_pszCmEntryTunnelAddress, TEXT(""), 
                            szTemp, CELEMS(szTemp), g_szCmsFile);    //lint !e534

                        uRadioButton = IDC_RADIO1;
                    }

                    //
                    //  Now fill in one of the edit controls and set a Radio Button
                    //
                    MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDIT1), WM_SETTEXT, 0, (LPARAM)szTemp));
                    MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDIT2), WM_SETTEXT, 0, (LPARAM)szTempVpnFile));

                    MYVERIFY(0 != CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, uRadioButton));
                    
                    //
                    //  Now get the UseSameUserName value and set that as appropriate
                    //
                    MYVERIFY(0 != GetPrivateProfileString(c_pszCmSection, 
                        c_pszCmEntryUseSameUserName, c_pszZero, szTemp, CELEMS(szTemp), g_szCmsFile));
                    
                    g_bUseSamePwd = (*szTemp == TEXT('1'));
                    
                    MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK3, (UINT)g_bUseSamePwd));

                    EnableDisableTunnelAddressControls(hDlg);
                    break;

                case PSN_WIZBACK:

                case PSN_WIZNEXT:

                    //
                    //  Read the checkboxes to figure out if we are tunneling or not
                    //
                    if (IsDlgButtonChecked(hDlg,IDC_CHECK1))
                    {
                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryTunnelPrimary, c_pszOne, g_szCmsFile));
                    }
                    else
                    {
                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryTunnelPrimary, c_pszZero, g_szCmsFile));
                    }

                    if (IsDlgButtonChecked(hDlg,IDC_CHECK2))
                    {
                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryTunnelReferences, c_pszOne, g_szCmsFile));
                    }
                    else
                    {
                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryTunnelReferences, c_pszZero, g_szCmsFile));
                    }

                    //
                    //  If we are tunneling then set the tunnel settings
                    //
                    if (IsDlgButtonChecked(hDlg,IDC_CHECK2) || IsDlgButtonChecked(hDlg,IDC_CHECK1))
                    {
                        g_bUseTunneling = TRUE;

                        //
                        //  Figure out if we are looking for a single tunnel address or a VPN file
                        //
                        if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO1))
                        {
                            uEditControl = IDC_EDIT1;
                            uMissingMsgId = IDS_NOTUNNEL;
                            g_szVpnFile[0] = TEXT('\0');
                        }
                        else
                        {
                            uEditControl = IDC_EDIT2;
                            uMissingMsgId = IDS_NOTUNNELFILE;
                        }

                        //
                        //  Get the tunnel server address or VPN file
                        //
                        LRESULT lResult = GetTextFromControl(hDlg, uEditControl, szTemp, MAX_PATH, TRUE); // bDisplayError == TRUE
                        if (-1 == lResult)
                        {
                            SetFocus(GetDlgItem(hDlg, uEditControl));
                        
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));

                            return 1;
                        }
                        else if (0 == lResult)
                        {
                            szTemp[0] = TEXT('\0');
                        }
                        
                        //
                        //  Trim the string
                        //
                        CmStrTrim(szTemp);

                        //
                        //  Check to make sure that they actually gave us text
                        //
                        if (TEXT('\0') == szTemp[0])
                        {
                            MYVERIFY(IDOK == ShowMessage(hDlg, uMissingMsgId, MB_OK));

                            SetFocus(GetDlgItem(hDlg, uEditControl));
                        
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));

                            return 1;
                        }

                        //
                        //  If we have a VPN file, we need to verify it
                        //
                        if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO2))
                        {
                            if (!VerifyFile(hDlg, IDC_EDIT2, g_szVpnFile, TRUE))
                            {
                                SetFocus(GetDlgItem(hDlg, IDC_EDIT2));
                                MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                                return TRUE;
                            }
                            else
                            {
                                //
                                //  We have now verified that we can find the file, but since
                                //  the user cannot enter their own tunnel address we need to
                                //  go one step further and make sure that there is at least one
                                //  tunnel address in the file.
                                //
                                if (!VerifyVpnFile(g_szVpnFile))
                                {
                                    MYVERIFY(IDOK == ShowMessage(hDlg, IDS_BADVPNFORMAT, MB_OK));
                                    SetFocus(GetDlgItem(hDlg, IDC_EDIT2));
                                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                                    return TRUE;
                                }

                                //
                                //  Lets copy the VPN file to the temp dir
                                //
                                wsprintf(szTemp, TEXT("%s\\%s"), g_szTempDir, GetName(g_szVpnFile));

                                if (0 != lstrcmpi(szTemp, g_szVpnFile))
                                {
                                    MYVERIFY(TRUE == CopyFileWrapper(g_szVpnFile, szTemp, FALSE));
                                    MYVERIFY(0 != SetFileAttributes(szTemp, FILE_ATTRIBUTE_NORMAL));
                                }
                            }
                        }

                        //
                        //  Write out the vpn file and tunnel address entries
                        //
                        if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RADIO1))
                        {
                            //
                            //  szTemp contains the tunnel address already, so just
                            //  clear the vpn file variable.
                            //
                            szTempVpnFile[0] = TEXT('\0');
                        }
                        else
                        {
                            //
                            // clear the tunnel address and set the vpn file
                            //
                            szTemp[0] = TEXT('\0');
                            wsprintf(szTempVpnFile, TEXT("%s\\%s"), g_szShortServiceName, GetName(g_szVpnFile));                     
                        }

                        //
                        //  Write out the tunnel address
                        //
                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryTunnelAddress, szTemp, g_szCmsFile));

                        //
                        //  Write out the tunnel file
                        //
                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryTunnelFile, szTempVpnFile, g_szCmsFile));


                        //
                        //  Set the name of the Tunnel Dun setting
                        //
                        MYVERIFY(0 != GetTunnelDunSettingName(g_szCmsFile, g_szLongServiceName, szTemp, CELEMS(szTemp)));
                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryTunnelDun, szTemp, g_szCmsFile));
                        
                        //
                        //  Write out the use same user name value
                        //
                        g_bUseSamePwd = IsDlgButtonChecked(hDlg,IDC_CHECK3);

                        if (g_bUseSamePwd)
                        {
                            MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryUseSameUserName, c_pszOne, g_szCmsFile));
                        }
                        else
                        {
                            MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryUseSameUserName, c_pszZero, g_szCmsFile));
                        }
                    }
                    else
                    {
                        //
                        //  Set g_bUseTunneling to False but don't clear out the tunnel settings until the
                        //  user hits the finish button.  That way if they change their mind part way through
                        //  building the profile we don't throw away their settings.
                        //

                        g_bUseTunneling = FALSE;
                    }

                    //
                    //  Skip the VPN entries dialog if we don't have tunneling enabled.
                    //
                    if (pnmHeader && (PSN_WIZNEXT == pnmHeader->code) && !g_bUseTunneling) 
                    {                        
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, IDD_PHONEBOOK));
                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}


//+----------------------------------------------------------------------------
//
// Function:  ValidatePresharedKey
//
// Synopsis:  Checks the given pre-shared key for validity
//
// Arguments: pszPresharedKey - string to check
//
// Returns:   BOOL - TRUE => key is good, FALSE => bad
//
// History:   sumitc  Created     03/27/01
//
//+----------------------------------------------------------------------------
BOOL ValidatePresharedKey(LPTSTR pszPresharedKey)
{
    BOOL bReturn = FALSE;

    MYDBGASSERT(pszPresharedKey);

    if (pszPresharedKey && (TEXT('\0') != pszPresharedKey[0]) &&
        (lstrlen(pszPresharedKey) <= c_dwMaxPresharedKey))
    {
        bReturn = TRUE;
    }
    
    return bReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  ValidatePresharedKeyPIN
//
// Synopsis:  Checks the given PIN for validity
//
// Arguments: pszPresharedKey - string to check
//
// Returns:   BOOL - TRUE => PIN is good, FALSE => bad
//
// History:   sumitc  Created     03/27/01
//
//+----------------------------------------------------------------------------
BOOL ValidatePresharedKeyPIN(LPTSTR pszPresharedKeyPIN)
{
    BOOL bReturn = FALSE;

    MYDBGASSERT(pszPresharedKeyPIN);

    if (pszPresharedKeyPIN && (TEXT('\0') != pszPresharedKeyPIN[0]) &&
        (lstrlen(pszPresharedKeyPIN) >= c_dwMinPresharedKeyPIN) &&
        (lstrlen(pszPresharedKeyPIN) <= c_dwMaxPresharedKeyPIN))
    {
        bReturn = TRUE;
    }
    
    return bReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  EncryptPresharedKey
//
// Synopsis:  Encrypts the given key into a form that can be serialized.
//
// Arguments: szKey - key to encrypt
//            szPIN - pin to use as seed
//            ppszEncrypted - resultant string
//
// Returns:   BOOL - TRUE => successfully encrypted key, FALSE => failed
//
// History:   sumitc  Created     03/27/01
//
//+----------------------------------------------------------------------------
BOOL EncryptPresharedKey(IN  LPTSTR szKey,
                         IN  LPTSTR szPIN,
                         OUT LPTSTR * ppszEncrypted)
{
    BOOL bReturn = FALSE;
    DWORD dwLenEncrypted = 0;
    LPSTR pszAnsiEncrypted = NULL;

    MYDBGASSERT(ppszEncrypted);
    
    LPSTR pszAnsiKey = WzToSzWithAlloc(szKey);
    LPSTR pszAnsiPIN = WzToSzWithAlloc(szPIN);

    MYDBGASSERT(pszAnsiKey && pszAnsiPIN);
    if (ppszEncrypted && pszAnsiKey && pszAnsiPIN)
    {
        //
        //  Initialize
        //  
        InitSecure(FALSE);      // use secure, not fast encryption

        //
        //  Encrypt it
        //
        if (EncryptString(pszAnsiKey,
                          pszAnsiPIN,
                          (PBYTE*) &pszAnsiEncrypted,
                          &dwLenEncrypted,
#if defined(DEBUG) && defined(DEBUG_MEM)
                          (PFN_CMSECUREALLOC)AllocDebugMem, // Give the DEBUG_MEM version of alloc/free
                          (PFN_CMSECUREFREE)FreeDebugMem))  // Not quit right, AllocDebugMem takes 3 param
#else
                          (PFN_CMSECUREALLOC)CmMalloc,    // mem allocator
                          (PFN_CMSECUREFREE)CmFree))      // mem deallocator
#endif
        {
            bReturn = TRUE;
        }

        //
        //  Uninitialize
        //  
        DeInitSecure();

        if (bReturn)
        {
            *ppszEncrypted = SzToWzWithAlloc(pszAnsiEncrypted);
            ZeroMemory(pszAnsiEncrypted, lstrlenA(pszAnsiEncrypted) * sizeof(CHAR));
#if defined(DEBUG) && defined(DEBUG_MEM)
            FreeDebugMem(pszAnsiEncrypted);
#else
            CmFree(pszAnsiEncrypted);
#endif
        }
    }

    CmFree(pszAnsiKey);
    CmFree(pszAnsiPIN);

    return bReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  EnableDisablePresharedKeyControls
//
// Synopsis:  Based on whether we have a key, set enabled/disabled state of UI
//
// History:   27-Mar-2001   SumitC    Created
//
//+----------------------------------------------------------------------------
void EnableDisablePresharedKeyControls(HWND hDlg, BOOL bEnable)
{
    //
    //  Enable edit controls and checkboxes
    //
    EnableWindow(GetDlgItem(hDlg, IDC_PRESHARED_KEY), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_USEENCRYPTION), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_PRESHARED_KEY_PIN), bEnable);
    if (bEnable)
    {
        CheckDlgButton(hDlg, IDC_USEENCRYPTION, TRUE);
    }

    //
    //  Either clear edit control or fill with info text
    //
    if (bEnable)
    {
        SendDlgItemMessage(hDlg, IDC_PRESHARED_KEY, WM_SETTEXT, 0, (LPARAM)TEXT(""));
        SetFocus(GetDlgItem(hDlg, IDC_PRESHARED_KEY));
    }
    else
    {
        LPTSTR pszTmp = CmLoadString(g_hInstance, IDS_PRESHAREDKEY_ALREADY);
        if (pszTmp)
        {
            SendDlgItemMessage(hDlg, IDC_PRESHARED_KEY, WM_SETTEXT, 0, (LPARAM)pszTmp);
        }
        CmFree(pszTmp);
    }

    //
    //  Show or hide the "Replace Key" button
    //
    ShowWindow(GetDlgItem(hDlg, IDC_REPLACE_PSK), !bEnable);
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessPresharedKey
//
// Synopsis:  Setup Pre-shared key usage for this profile
//
// History:   27-Mar-2001   SumitC    Created
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessPresharedKey(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    NMHDR* pnmHeader = (NMHDR*)lParam;
    static LPTSTR pszPresharedKey = NULL;
    static BOOL   bEncryptPresharedKey = FALSE;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_PRESHARED)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;

    switch (message)
    {
        case WM_INITDIALOG:
            //
            //  Set max text lengths for the edit controls
            //
            SendDlgItemMessage(hDlg, IDC_PRESHARED_KEY, EM_SETLIMITTEXT, (WPARAM)c_dwMaxPresharedKey, (LPARAM)0); //lint !e534 EM_SETLIMITTEXT doesn't return anything useful
            SendDlgItemMessage(hDlg, IDC_PRESHARED_KEY_PIN, EM_SETLIMITTEXT, (WPARAM)c_dwMaxPresharedKeyPIN, (LPARAM)0); //lint !e534 EM_SETLIMITTEXT doesn't return anything useful
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_REPLACE_PSK:
                    if (IDYES == ShowMessage(hDlg, IDS_REALLY_REPLACE_PSK, MB_YESNO | MB_ICONWARNING))
                    {
                        CmFree(pszPresharedKey);
                        pszPresharedKey = NULL;
                        EnableDisablePresharedKeyControls(hDlg, TRUE);
                    }
                    break;

                case IDC_USEENCRYPTION:
                    EnableWindow(GetDlgItem(hDlg, IDC_PRESHARED_KEY_PIN), IsDlgButtonChecked(hDlg, IDC_USEENCRYPTION));
                    break;

                default:
                    break;
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {
                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));
                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:

                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));

                    CMASSERTMSG(g_bPresharedKeyNeeded, TEXT("we shouldn't get to this page otherwise."));

                    //
                    //  Read in the Pre-shared key and the flag that says if it's encrypted
                    //
                    pszPresharedKey = GetPrivateProfileStringWithAlloc(c_pszCmSection, c_pszCmEntryPresharedKey,
                                                                       TEXT(""), g_szCmpFile);    //lint !e534
                    bEncryptPresharedKey = (BOOL)GetPrivateProfileInt(c_pszCmSection, c_pszCmEntryKeyIsEncrypted,
                                                                      FALSE, g_szCmpFile);    //lint !e534

                    //
                    //  If we don't have a pre-shared key, hide the Replace button, and enable all
                    //  the other controls.  If we already have a pre-shared key, disable all the
                    //  controls and enable the Replace button.
                    //
                    EnableDisablePresharedKeyControls(hDlg, !pszPresharedKey);
                    break;

                case PSN_WIZBACK:
                    g_bPresharedKeyNeeded = FALSE;    // force this to be recomputed, since it can change if we go back

                    // fall through and verify pre-shared key as well

                case PSN_WIZNEXT:

                    if (NULL == pszPresharedKey)
                    {
                        TCHAR szPresharedKey[c_dwMaxPresharedKey + 1];
                        TCHAR szPresharedKeyPIN[c_dwMaxPresharedKeyPIN + 1];

                        //
                        //  verify Pre-shared Key
                        //
                        GetTextFromControl(hDlg, IDC_PRESHARED_KEY, szPresharedKey, c_dwMaxPresharedKey, TRUE);

                        if (FALSE == ValidatePresharedKey(szPresharedKey))
                        {
                            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_PRESHAREDKEY_BAD, MB_OK | MB_ICONSTOP));
                            SetFocus(GetDlgItem(hDlg, IDC_PRESHARED_KEY));
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }

                        //
                        //  if key is being encrypted, verify the PIN and use to encrypt key
                        //
                        if (IsDlgButtonChecked(hDlg, IDC_USEENCRYPTION))
                        {
                            GetTextFromControl(hDlg, IDC_PRESHARED_KEY_PIN, szPresharedKeyPIN, c_dwMaxPresharedKeyPIN, TRUE);
                            if (FALSE == ValidatePresharedKeyPIN(szPresharedKeyPIN))
                            {
                                MYVERIFY(IDOK == ShowMessage(hDlg, IDS_PRESHAREDKEY_PIN_BAD, MB_OK | MB_ICONSTOP));
                                SetFocus(GetDlgItem(hDlg, IDC_PRESHARED_KEY_PIN));
                                MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                                return 1;
                            }

                            //
                            //  Encrypt Pre-shared Key
                            //
                            if (FALSE == EncryptPresharedKey(szPresharedKey, szPresharedKeyPIN, &pszPresharedKey))
                            {
                                MYVERIFY(IDOK == ShowMessage(hDlg, IDS_PSK_ENCRYPT_FAILED, MB_OK | MB_ICONSTOP));
                                SetFocus(GetDlgItem(hDlg, IDC_PRESHARED_KEY_PIN));
                                MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                                return 1;
                            }

                            MYDBGASSERT(pszPresharedKey);
                            bEncryptPresharedKey = TRUE;
                        }
                        else
                        {
                            pszPresharedKey = CmStrCpyAlloc(szPresharedKey);
                        }

                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryPresharedKey,
                                                                pszPresharedKey,
                                                                g_szCmpFile));
                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryKeyIsEncrypted,
                                                                (bEncryptPresharedKey ? c_pszOne : c_pszZero),
                                                                g_szCmpFile));

                        ZeroMemory(szPresharedKey, c_dwMaxPresharedKey * sizeof(TCHAR));
                        ZeroMemory(szPresharedKeyPIN, c_dwMaxPresharedKeyPIN * sizeof(TCHAR));
                    }
                    CmFree(pszPresharedKey);
                    pszPresharedKey = NULL;
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}



//+----------------------------------------------------------------------------
//
// Function:  RenameSection
//
// Synopsis:  This function renames an INI file section from the current name to
//            the new name.
//
// Arguments: LPCTSTR szCurrentSectionName - Current name that you want renamed
//            LPCTSTR szNewSectionName - name you want the above renamed to
//            LPCTSTR szFile - INI file to rename the section in
//
// Returns:   BOOL - Returns TRUE unless a malloc error occurred
//
// History:   quintinb Created     9/11/98
//
//+----------------------------------------------------------------------------
BOOL RenameSection(LPCTSTR szCurrentSectionName, LPCTSTR szNewSectionName, LPCTSTR szFile)
{
    //
    //  Get the existing section
    //
    LPTSTR pszBuffer = GetPrivateProfileSectionWithAlloc(szCurrentSectionName, szFile);

    if (NULL == pszBuffer)
    {
        return FALSE;
    }
    else
    {
        //
        //  Erase the old section
        //
        MYVERIFY(0 != WritePrivateProfileString(szCurrentSectionName, NULL, NULL, szFile));

        //
        //  Write out the renamed section
        //

        MYVERIFY(0 != WritePrivateProfileSection(szNewSectionName, pszBuffer, szFile));    
    }

    CmFree(pszBuffer);
    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessCustomActionPopup
//
// Synopsis:  Processes windows messages for the dialog which allows CMAK to add
//            or edit custom actions.  Note that we pass in a pointer to a
//            CustomActionListItem struct on WM_INITDIALOG through the lParam.
//            If the user hits OK, we copy the data that they gave us into this
//            structure.  Note that we only do this to communicate the data back to
//            the caller as we update the custom action list ourselves.
//
// Arguments: WND hDlg - dialog window handle
//            UINT message - message identifier
//            WPARAM wParam - wParam Value 
//            LPARAM lParam - lParam Value
//
//
// History:   quintinb  Created     02/25/00
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessCustomActionPopup(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szTemp[MAX_PATH+1];
    HRESULT hr;
    int iTemp;
    LRESULT lResult;
    LPTSTR pszTypeString = NULL;
    CustomActionTypes Type;
    CustomActionExecutionStates ExecutionIndex;
    static CustomActionListItem* pItem;
    CustomActionListItem* pTempItem = NULL;
    CustomActionListItem NewItem;

    static TCHAR szFullPathToProgram[MAX_PATH+1] = {0};

    HWND hControl;
    LPTSTR pszTemp;

    SetDefaultGUIFont(hDlg, message, IDC_EDIT1);
    SetDefaultGUIFont(hDlg, message, IDC_EDIT2);
    SetDefaultGUIFont(hDlg, message, IDC_EDIT3);
    SetDefaultGUIFont(hDlg, message, IDC_COMBO1);
    SetDefaultGUIFont(hDlg, message, IDC_COMBO2);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_CONNECT)) return TRUE;

    switch (message)
    {

        case WM_INITDIALOG:

            MYDBGASSERT(g_pCustomActionList);
            if (NULL == g_pCustomActionList)
            {
                return TRUE;
            }

            //
            //  We keep the full path to the program in this static string.
            //
            ZeroMemory(szFullPathToProgram, sizeof(szFullPathToProgram));

            //
            //  Check to see if we got an initialization parameter
            //
            if (lParam)
            {
                //
                //  Thus we were passed a CustomActionListItem structure.  It either contains a
                //  type and a description, meaning that this is an edit and we should lookup the
                //  data, or we got just a type and we just need to pre-set the type combo to the
                //  type the user was currently viewing in the listbox.
                //

                pItem = (CustomActionListItem*)lParam;

                if (pItem->szDescription[0])
                {
                    hr = g_pCustomActionList->GetExistingActionData(g_hInstance, pItem->szDescription, pItem->Type, &pTempItem);

                    if (SUCCEEDED(hr))
                    {
                        //
                        //  Let's set the dialog title to say that we are editing an entry.  If we fail to retrive
                        //  the string the dialog may look a little funny but should still be functional so we
                        //  won't try to bail out.
                        //
                        pszTemp = CmLoadString(g_hInstance, IDS_CA_EDIT_TITLE);

                        if (pszTemp)
                        {
                            MYVERIFY(SendMessage (hDlg, WM_SETTEXT, 0, (LPARAM)pszTemp));
                            CmFree(pszTemp);
                        }

                        //
                        //  Okay, we have data so lets set the item fields.  Don't set the description if it
                        //  is only the temporary description that we concatenated from the program and the
                        //  arguments.
                        //
                        if (FALSE == pTempItem->bTempDescription)
                        {
                            MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDIT3), WM_SETTEXT, 0, (LPARAM)pTempItem->szDescription));
                        }

                        //
                        //  Set the program edit control, note we only show the filename if the user is including the
                        //  binary in the package.  Also note that we save the full path in szFullPathToProgram so that
                        //  we have it for later.
                        //
                        if (pTempItem->bIncludeBinary)
                        {
                            GetFileName(pTempItem->szProgram, szTemp);
                            lstrcpyn(szFullPathToProgram, pTempItem->szProgram, CELEMS(szFullPathToProgram));
                        }
                        else
                        {                        
                            lstrcpyn(szTemp, pTempItem->szProgram, CELEMS(szTemp));
                        }

                        MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDIT1), WM_SETTEXT, 0, (LPARAM)szTemp));                        

                        //
                        //  Set the include program checkbox
                        //
                        
                        MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK1, pTempItem->bIncludeBinary));

                        //
                        //  Set the parameters edit control.  Note that we put the function name and the parameters
                        //  back together if necessary.
                        //
                        if (NULL != pTempItem->pszParameters)
                        {
                            LPTSTR pszParamToDisplay = NULL;

                            if (pTempItem->szFunctionName[0])
                            {
                                pszParamToDisplay = CmStrCpyAlloc(pTempItem->szFunctionName);
                                MYDBGASSERT(pszParamToDisplay);

                                if (pszParamToDisplay && pTempItem->pszParameters[0])
                                {
                                    pszParamToDisplay = CmStrCatAlloc(&pszParamToDisplay, TEXT(" "));
                                    MYDBGASSERT(pszParamToDisplay);

                                    if (pszParamToDisplay)
                                    {
                                        pszParamToDisplay = CmStrCatAlloc(&pszParamToDisplay, pTempItem->pszParameters);
                                        MYDBGASSERT(pszParamToDisplay);
                                    }
                                }
                            }
                            else
                            {
                                pszParamToDisplay = CmStrCpyAlloc(pTempItem->pszParameters);
                                MYDBGASSERT(pszParamToDisplay);
                            }

                            if (pszParamToDisplay)
                            {
                                MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDIT2), WM_SETTEXT, 0, (LPARAM)pszParamToDisplay));
                                CmFree(pszParamToDisplay);
                            }
                        }
                        else
                        {
                            CMASSERTMSG(FALSE, TEXT("pTempItem->pszParameters is NULL"));
                        }
                    }
                }

                //
                //  Figure out what type of custom action we are editing or trying to add (we pre-seed the add type with
                //  the type the user was viewing.  If they were viewing all we set it to the first in the combo).
                //
                Type = pItem->Type;
                
                hr = g_pCustomActionList->MapFlagsToIndex((pTempItem ? pTempItem->dwFlags : 0), (int*)&ExecutionIndex);

                if (FAILED(hr))
                {
                    CMASSERTMSG(FALSE, TEXT("ProcessCustomActionPopup -- MapFlagsToIndex failed, setting execution state to Always."));
                    ExecutionIndex = (CustomActionExecutionStates)0; // set it to the first item in the enum
                }
            }
            else
            {
                pItem = NULL;
                Type = (CustomActionTypes)0; // set it to the first item in the enum
                ExecutionIndex = (CustomActionExecutionStates)0; // set it to the first item in the enum
            }

            if (pTempItem)
            {
                CmFree(pTempItem->pszParameters);
                CmFree(pTempItem);
                pTempItem = NULL;
            }

            //
            //  Setup the custom action types combobox, note that we set bAddAll to FALSE so that we don't add the
            //  All connect action type used for viewing the connect actions on the main dialog.
            //
            hr = g_pCustomActionList->AddCustomActionTypesToComboBox(hDlg, IDC_COMBO1, g_hInstance, g_bUseTunneling, FALSE);

            //
            //  Pick a connect action type
            //
            hr = g_pCustomActionList->GetTypeStringFromType(g_hInstance, Type, &pszTypeString);

            if (SUCCEEDED(hr))
            {
                lResult = SendDlgItemMessage(hDlg, IDC_COMBO1, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pszTypeString);

                if (CB_ERR != lResult)
                {
                    MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, IDC_COMBO1, CB_SETCURSEL, (WPARAM)lResult, (LPARAM)0));
                }

                CmFree(pszTypeString);
            }

            //
            //  Next initialize the the combo that tells us when to run a connect action.  If we are tunneling
            //  then the user can pick to run the connection for direct connections only, dialup connections only,
            //  all connections that involve dialup, all connections that involve a tunnel, or all connections.
            //
            hr = g_pCustomActionList->AddExecutionTypesToComboBox(hDlg, IDC_COMBO2, g_hInstance, g_bUseTunneling);

            //
            //  Pick when the connect action will execute if it is enabled
            //
            if (g_bUseTunneling)
            {
                lResult = SendDlgItemMessage(hDlg, IDC_COMBO2, CB_GETCOUNT, (WPARAM)0, (LPARAM)0);
                if ((CB_ERR != lResult) && (lResult > 0))
                {
                    MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, IDC_COMBO2, CB_SETCURSEL, (WPARAM)ExecutionIndex, (LPARAM)0));
                }
            }

            break;
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_BUTTON1: // Browse
                    {
                        UINT uFilterArray[2] = {IDS_CONACTFILTER, IDS_ALLFILTER};
                        TCHAR* pszMaskArray[2] = {TEXT("*.exe;*.com;*.bat;*.dll"), TEXT("*.*")};
                                          
                        iTemp = DoBrowse(hDlg, uFilterArray, pszMaskArray, 2, IDC_EDIT1, TEXT("exe"), g_szLastBrowsePath);

                        MYDBGASSERT(0 != iTemp);

                        if (0 < iTemp) // -1 means the user cancelled
                        {
                            //
                            //  Check the include binary button for the user
                            //
                            MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK1, TRUE));

                            //
                            //  We want to copy the full path to the filename into szFullPathToProgram so
                            //  that we have it for later in case the user wants to include it in the profile.
                            //
                            lstrcpyn(szFullPathToProgram, g_szLastBrowsePath, CELEMS(szFullPathToProgram));

                            //
                            //  We also want to save the last browse path so that when the user next
                            //  opens the browse dialog they will be in the same place they last
                            //  browsed from.
                            //
                            LPTSTR pszLastSlash = CmStrrchr(g_szLastBrowsePath, TEXT('\\'));

                            if (pszLastSlash)
                            {
                                pszLastSlash = CharNext(pszLastSlash);
                                *pszLastSlash = TEXT('\0');
                            }
                            else
                            {
                                g_szLastBrowsePath[0] = TEXT('\0');                        
                            }        
                        }
                    }
                    break;

                case IDOK:

                    //
                    //  Make sure we have a valid custom action list
                    //
                    MYDBGASSERT(g_pCustomActionList);
                    if (NULL == g_pCustomActionList)
                    {
                        return TRUE;
                    }

                    //
                    //  Get the text from the Program Edit Control, verifying
                    //  we can convert it to something ANSI
                    //
                    if (-1 == GetTextFromControl(hDlg, IDC_EDIT1, szTemp, MAX_PATH, TRUE)) // bDisplayError == TRUE
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                        return TRUE;
                    }

                    //
                    //  Check to make sure the program field isn't blank.
                    //
                    if (TEXT('\0') == szTemp[0])
                    {
                        MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NEEDPROG, MB_OK));
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                        return TRUE;
                    }

                    //
                    //  Make sure that the program doesn't have a comma or a plus
                    //  sign in it as that will mess up our parsing routines.  There
                    //  is no need to allow users to use such odd ball file names.
                    //
                    if (CmStrchr(szTemp, TEXT('+')) || CmStrchr(szTemp, TEXT(',')))
                    {
                        MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOPLUSORCOMMAINPROG, MB_OK));
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                        return TRUE;                        
                    }

                    //
                    //  Now check to see if we need to verify that the file exists.
                    //  We only want to do that if they have the include program files
                    //  checkbox checked.
                    //
                    ZeroMemory(&NewItem, sizeof(CustomActionListItem));
                    NewItem.bIncludeBinary = IsDlgButtonChecked(hDlg, IDC_CHECK1);

                    if (NewItem.bIncludeBinary)
                    {
                        if (!VerifyFile(hDlg, IDC_EDIT1, szFullPathToProgram, TRUE)) 
                        {
                            return TRUE;
                        }  
                        else
                        {
                            lstrcpyn(NewItem.szProgram, szFullPathToProgram, CELEMS(NewItem.szProgram));
                        }
                    }
                    else
                    {
                        //
                        //  Copy the file as is, but warn the user if they have
                        //  a string with a path but doesn't start with a environment
                        //  variable.
                        //
                        iTemp = IDNO;

                        CmStrTrim(szTemp);

                        LPTSTR pszSlash = CmStrchr(szTemp, TEXT('\\'));
                        
                        if (pszSlash && (TEXT('%') != szTemp[0]))
                        {
                            iTemp = ShowMessage(hDlg, IDS_PATH_WITH_NO_ENV, MB_YESNO | MB_ICONWARNING);
                        }

                        if (IDNO == iTemp)
                        {
                            lstrcpyn(NewItem.szProgram, szTemp, CELEMS(NewItem.szProgram));                                            
                        }
                        else
                        {
                            return TRUE;
                        }
                    }

                    //
                    //  Get the Text from the Params edit control, make sure to validate
                    //  that we can convert it to ANSI
                    //
                    hControl = GetDlgItem(hDlg, IDC_EDIT2);
                    MYDBGASSERT(hControl);
                    pszTemp = NULL;

                    if (hControl)
                    {
                        iTemp = GetCurrentEditControlTextAlloc(hControl, &pszTemp);

                        if (-1 == iTemp)
                        {
                            SetFocus(GetDlgItem(hDlg, IDC_EDIT2));
                            return TRUE;
                        }
                    }

                    //
                    //  Check to see if we have a dll for a program.  If so, the first parameter is the function name.
                    //
                    if (pszTemp)
                    {
                        CmStrTrim(pszTemp);

                        iTemp = lstrlen(NewItem.szProgram) - 4; // 4 == lstrlen (TEXT(".dll"));

                        if (0 == lstrcmpi(TEXT(".dll"), (NewItem.szProgram + iTemp)))
                        {
                            //
                            //  Make sure that we have a parameter string
                            //
                            if (pszTemp && pszTemp[0])
                            {
                                LPTSTR pszEndOfFunctionName = CmStrchr(pszTemp, TEXT(' '));

                                if (pszEndOfFunctionName)
                                {                                   
                                    LPTSTR pszParams = CharNext(pszEndOfFunctionName);
                                    *pszEndOfFunctionName = TEXT('\0');

                                    lstrcpyn(NewItem.szFunctionName, pszTemp, CELEMS(NewItem.szFunctionName));
                                    NewItem.pszParameters = CmStrCpyAlloc(pszParams);
                                }
                                else
                                {
                                    lstrcpyn(NewItem.szFunctionName, pszTemp, CELEMS(NewItem.szFunctionName));
                                }
                            }
                            else
                            {
                                MYVERIFY (IDOK == ShowMessage(hDlg, IDS_DLLMUSTHAVEPARAM, MB_OK));
                                SetFocus(GetDlgItem(hDlg, IDC_EDIT2));
                                return TRUE;
                            }

                            CmFree(pszTemp);
                        }
                        else
                        {
                            NewItem.pszParameters = pszTemp;
                            pszTemp = NULL;
                        }
                    }
                    else
                    {
                        NewItem.pszParameters = CmStrCpyAlloc(TEXT(""));
                        MYDBGASSERT(NewItem.pszParameters);
                    }

                    //
                    //  Get the Text from the Description edit control
                    //
                    if (-1 == GetTextFromControl(hDlg, IDC_EDIT3, NewItem.szDescription, CELEMS(NewItem.szDescription), TRUE)) // bDisplayError == TRUE
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT3));
                        return TRUE;
                    }

                    //
                    //  If the description was empty, then fill it in from the program and the parameters.  Also
                    //  remember to keep track of the fact that this is only a temporary description.
                    //
                    if (TEXT('\0') == NewItem.szDescription[0])
                    {
                        hr = g_pCustomActionList->FillInTempDescription(&NewItem);
                        MYDBGASSERT(SUCCEEDED(hr));
                    }

                    //
                    //  Figure out the type of custom action
                    //
                    hr = MapComboSelectionToType(hDlg, IDC_COMBO1, FALSE, g_bUseTunneling, &(NewItem.Type)); // bIncludesAll == FALSE

                    if ((ONINTCONNECT == NewItem.Type) && NewItem.szFunctionName[0])
                    {
                        MYVERIFY (IDOK == ShowMessage(hDlg, IDS_NODLLAUTOAPP, MB_OK));
                        return TRUE;
                    }

                    //
                    //  Now build the flags section
                    //
                    lResult = SendDlgItemMessage(hDlg, IDC_COMBO2, CB_GETCURSEL, 0, (LPARAM)0);

                    if (lResult != LB_ERR)
                    {
                        hr = g_pCustomActionList->MapIndexToFlags((int)lResult, &(NewItem.dwFlags));

                        if (FAILED(hr))
                        {
                            MYDBGASSERT(FALSE);
                            NewItem.dwFlags = 0;
                        }
                    }
                    else
                    {
                        MYDBGASSERT(FALSE);
                        NewItem.dwFlags = 0;                    
                    }

                    //
                    //  Now, lets try to add the New or Edited entry.  If we have a description
                    //  in pItem->szDescription then we need to call edit, otherwise add.
                    //                    
                    if (pItem && pItem->szDescription[0])
                    {
                        hr = g_pCustomActionList->Edit(g_hInstance, pItem, &NewItem, g_szShortServiceName);
                    }
                    else
                    {
                        hr = g_pCustomActionList->Add(g_hInstance, &NewItem, g_szShortServiceName);
                    }

                    //
                    //  Check to see if we failed because a duplicate exists
                    //
                    if (HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr)
                    {
                        //
                        //  The user has tried to add an entry which already exists.  Inform the
                        //  user and see if they want to overwrite.
                        //
                        pszTypeString = NULL;
                        hr = g_pCustomActionList->GetTypeStringFromType(g_hInstance, NewItem.Type, &pszTypeString);

                        MYDBGASSERT(pszTypeString);

                        if (pszTypeString)
                        {
                            LPTSTR pszMsg = CmFmtMsg(g_hInstance, IDS_CANAMEEXISTS, NewItem.szDescription, pszTypeString);

                            MYDBGASSERT(pszMsg);
                            if (pszMsg)
                            {
                                iTemp = MessageBox(hDlg, pszMsg, g_szAppTitle, MB_YESNO | MB_APPLMODAL | MB_DEFBUTTON2 | MB_ICONEXCLAMATION);

                                if (IDYES == iTemp)
                                {                                
                                    //
                                    //  Okay, they want to replace it.  Note that the old item is only 
                                    //  used to get the szDescription and the Type thus
                                    //  it is safe to call Edit with NewItem as both Old and New.
                                    //

                                    if (pItem && pItem->szDescription[0])
                                    {
                                        hr = g_pCustomActionList->Delete (g_hInstance, pItem->szDescription, pItem->Type);
                                        MYDBGASSERT(SUCCEEDED(hr));
                                    }

                                    hr = g_pCustomActionList->Edit(g_hInstance, &NewItem, &NewItem, g_szShortServiceName);

                                    MYDBGASSERT(SUCCEEDED(hr));

                                    if (SUCCEEDED(hr))
                                    {
                                        MYVERIFY(0 != EndDialog(hDlg, IDOK));
                                        
                                        if (pItem)
                                        {
                                            //
                                            //  Make sure the type and description are up to date in pItem if we have one
                                            //
                                            lstrcpyn(pItem->szDescription, NewItem.szDescription, CELEMS(pItem->szDescription));
                                            pItem->Type = NewItem.Type;
                                        }
                                    }
                                }
                                else
                                {
                                    //
                                    //  Let's put the user back to the description field if it has text in it, otherwise
                                    //  we want to put the user in the program field.
                                    //
                                    LRESULT lTextLen = SendDlgItemMessage(hDlg, IDC_EDIT3, WM_GETTEXTLENGTH, (WPARAM)0, (LPARAM)0);

                                    SetFocus(GetDlgItem(hDlg, lTextLen ? IDC_EDIT3 : IDC_EDIT1));
                                }

                                CmFree(pszMsg);
                            }

                            CmFree(pszTypeString);
                        }
                    }
                    else if (FAILED(hr))
                    {
                        CMASSERTMSG(FALSE, TEXT("ProcessCustomActionPopUp -- unknown failure when trying to add or edit a connect action."));
                    }
                    else
                    {
                        if (pItem)
                        {
                            //
                            //  Make sure the type and description are up to date in pItem if we have one
                            //
                            lstrcpyn(pItem->szDescription, NewItem.szDescription, CELEMS(pItem->szDescription));
                            pItem->Type = NewItem.Type;
                        }

                        MYVERIFY(0 != EndDialog(hDlg, IDOK));
                    }

                    CmFree(NewItem.pszParameters);
                    NewItem.pszParameters = NULL;
                    return (TRUE);

                case IDCANCEL:
                    MYVERIFY(0 != EndDialog(hDlg, IDCANCEL));
                    return (TRUE);

                default:
                    break;
            }
            break;

        default:
            return FALSE;
    }
    return FALSE;   
}


// Read files under the [Extra Files] section in the .inf
static void ReadExtraList()
{
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szTemp2[MAX_PATH+1];
    TCHAR szNum[MAX_PATH+1];
    ExtraData TmpExtraData;
    int ConnectCnt = 0;
    HANDLE hInf;

    _itot(ConnectCnt,szNum,10); //lint !e534 itoa doesn't return anything useful for error handling
    
    
    // 
    // The following call to GetPrivateProfileString could return an empty string
    // so we don't want to use the MYVERIFY macro on it.
    // 

    ZeroMemory(szTemp, sizeof(szTemp));
    GetPrivateProfileString(c_pszExtraFiles, szNum, TEXT(""), szTemp, CELEMS(szTemp), g_szInfFile);    //lint !e534
    
    while (*szTemp)
    {
        _tcscpy(TmpExtraData.szPathname, szTemp);
        GetFileName(TmpExtraData.szPathname, TmpExtraData.szName);

        MYVERIFY(CELEMS(szTemp2) > (UINT)wsprintf(szTemp2, TEXT("%s\\%s"), g_szOutdir, TmpExtraData.szName));

        hInf = CreateFile(szTemp2,GENERIC_READ,0,NULL,OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,NULL);

        if (hInf != INVALID_HANDLE_VALUE)
        {
            _tcscpy(TmpExtraData.szPathname,szTemp2);
            MYVERIFY(0 != CloseHandle(hInf));
        }

        MYVERIFY(FALSE != createListBxRecord(&g_pHeadExtra,&g_pTailExtra,(void *)&TmpExtraData,sizeof(TmpExtraData),TmpExtraData.szName));

        ++ConnectCnt;
        _itot(ConnectCnt,szNum,10); //lint !e534 itoa doesn't return anything useful for error handling

        // 
        // The following call to GetPrivateProfileString could return an empty string
        // so we don't want to use the MYVERIFY macro on it.
        // 

        ZeroMemory(szTemp, sizeof(szTemp));
        
        GetPrivateProfileString(c_pszExtraFiles, szNum, TEXT(""), szTemp, CELEMS(szTemp), g_szInfFile);    //lint !e534

    }           
}



//+----------------------------------------------------------------------------
//
// Function:  ReadMergeList
//
// Synopsis:  This function reads entries from the [Merge Profiles] section of the inf file.
//            Any entries found are added to the g_pHeadMerge Linked list.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Quintinb Created Header and restructured to use dwNumChars    1/7/98
//
//+----------------------------------------------------------------------------
static void ReadMergeList()
{
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szNum[MAX_PATH+1];
    int filenum = 0;
    DWORD dwNumChars;

    //
    //  Convert the number zero to the string "0"
    //

    _itot(filenum,szNum,10);    //lint !e534 itoa doesn't return anything useful for error handling
    
    //
    //  Try to get a merged profile entry from the INF
    //
    
    dwNumChars = GetPrivateProfileString(c_pszMergeProfiles, szNum,TEXT(""), szTemp, 
        CELEMS(szTemp), g_szInfFile);
    
    while ((dwNumChars > 0) &&  (TEXT('\0') != szTemp[0]))
    {
        //
        //  If we are in this loop then we have a profile entry
        //

        MYVERIFY(FALSE != createListBxRecord(&g_pHeadMerge,&g_pTailMerge,(void *)NULL,0,szTemp));
        
        //
        //  Increment the filenumber to look for the next entry
        //

        ++filenum;
        
        //
        //  Convert the filenumber to a string
        //

        _itot(filenum,szNum,10);    //lint !e534 itoa doesn't return anything useful for error handling
        
        //
        //  Try to read in the next merge entry
        //

        dwNumChars = GetPrivateProfileString(c_pszMergeProfiles, szNum, TEXT(""), szTemp, 
            CELEMS(szTemp), g_szInfFile);

    }           
}


static void WriteExtraList()
{
    ExtraData * pExtraData;
    ListBxList * LoopPtr;
    TCHAR szNum[MAX_PATH+1];
    TCHAR szName[MAX_PATH+1];
    int filenum = 0;

    MYVERIFY(0 != WritePrivateProfileSection(c_pszExtraFiles, TEXT("\0\0"), g_szInfFile));

    if (g_pHeadExtra == NULL)
    {
        return;
    }
    LoopPtr = g_pHeadExtra;

    // WRITE IN ALL ENTRIES
    while( LoopPtr != NULL)
    {
        pExtraData = (ExtraData *)LoopPtr->ListBxData;
        {
            _itot(filenum,szNum,10);    //lint !e534 itoa doesn't return anything useful for error handling

            GetFileName(pExtraData->szPathname,szName);
            MYVERIFY(0 != WritePrivateProfileString(c_pszExtraFiles, szNum, szName, g_szInfFile));
            filenum = filenum+1;
        }

        LoopPtr = LoopPtr->next;
    }

    //
    //  By calling WritePrivateProfileString with all NULL's we flush the file cache 
    //  (win95 only).  This call will return 0.
    //

    WritePrivateProfileString(NULL, NULL, NULL, g_szInfFile); //lint !e534 this call will always return 0

}

static void WriteMergeList()
{
    ListBxList * LoopPtr;
    TCHAR szNum[MAX_PATH+1];
    int filenum = 0;

    MYVERIFY(0 != WritePrivateProfileSection(c_pszMergeProfiles,TEXT("\0\0"),g_szInfFile));

    if (g_pHeadMerge == NULL)
    {
        return;
    }
    LoopPtr = g_pHeadMerge;

    // WRITE IN ALL ENTRIES
    while( LoopPtr != NULL)
    {
        _itot(filenum,szNum,10);    //lint !e534 itoa doesn't return anything useful for error handling
        MYVERIFY(0 != WritePrivateProfileString(c_pszMergeProfiles, szNum,LoopPtr->szName, g_szInfFile));
        filenum = filenum+1;
        LoopPtr = LoopPtr->next;
    }

    //
    //  By calling WritePrivateProfileString with all NULL's we flush the file cache (win95 only).  This call will
    //  return 0.
    //

    WritePrivateProfileString(NULL, NULL, NULL, g_szInfFile); //lint !e534 this call will always return 0.
}

//+----------------------------------------------------------------------------
//
// Function:  IsFile8dot3
//
// Synopsis:  Returns TRUE if the filename is in the 8.3 dos filename format
//
// Arguments: LPTSTR pszFileName - just the filename of the file to be checked (no path)
//
// Returns:   BOOL - TRUE or FALSE if the file is 8.3
//
// History:   quintinb created    11/26/97
//
//+----------------------------------------------------------------------------
BOOL IsFile8dot3(LPTSTR pszFileName)
{

    TCHAR szTemp[MAX_PATH+1];
    TCHAR * pszPtr;

    if (!pszFileName)
    {
        return FALSE;
    }

    if (TEXT('\0') == pszFileName[0])
    {
        return TRUE;
    }

    _tcscpy(szTemp, pszFileName);

    pszPtr = _tcsrchr(szTemp, TEXT('.'));

    //
    // If there is an extension check the length
    //

    if (pszPtr)
    {
        if (_tcslen(pszPtr) > 4)
        {
            return FALSE;
        }

        //
        // Extension is ok check name part
        //

        *pszPtr = 0;
    }
        
    if (_tcslen(szTemp) > 8)
    {
        return FALSE;
    }   

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessCustomActions
//
// Synopsis:  Processes windows messages for the page in CMAK that allows users
//            to manipulate custom actions (add, edit, delete, move, etc.)
//
// Arguments: WND hDlg - dialog window handle
//            UINT message - message identifier
//            WPARAM wParam - wParam Value 
//            LPARAM lParam - lParam Value
//
//
// History:   quintinb  Created     02/25/00
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessCustomActions(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szTemp[MAX_PATH+1];
    INT_PTR nResult;
    int iTemp;
    HRESULT hr;
    static HWND hListView;
    NMHDR* pnmHeader = (NMHDR*)lParam;
    LPNMLISTVIEW pNMListView;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_CONNECT)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_LISTVIEW);
    SetDefaultGUIFont(hDlg,message,IDC_COMBO1);

    switch (message)
    {
        case WM_INITDIALOG:
        {
            if (NULL == g_pCustomActionList)
            {
                g_pCustomActionList = new CustomActionList;

                MYDBGASSERT(g_pCustomActionList);

                if (NULL == g_pCustomActionList)
                {
                    return FALSE;
                }

                //
                //  Read in the custom actions from the Cms File
                //

                hr = g_pCustomActionList->ReadCustomActionsFromCms(g_hInstance, g_szCmsFile, g_szShortServiceName);
                CMASSERTMSG(SUCCEEDED(hr), TEXT("ProcessCustomActions -- Loading custom actions failed."));
            }

            //
            //  Cache the List View window handle
            //
            hListView = GetDlgItem(hDlg, IDC_LISTVIEW);

            //
            //  Load the arrow images for the move up and move down buttons
            //
            HICON hUpArrow = (HICON)LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_UP_ARROW), IMAGE_ICON, 0, 0, 0);
            HICON hDownArrow = (HICON)LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_DOWN_ARROW), IMAGE_ICON, 0, 0, 0);

            //
            //  Set the arrow button bit maps
            //
            SendMessage(GetDlgItem(hDlg, IDC_BUTTON4), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hUpArrow);
            SendMessage(GetDlgItem(hDlg, IDC_BUTTON5), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hDownArrow);

            //
            //  Set the Column headings
            //
            AddListViewColumnHeadings(g_hInstance, hListView);

           break;
        }
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_BUTTON1: //add

                    OnProcessCustomActionsAdd(g_hInstance, hDlg, hListView, g_bUseTunneling);
                    break;

                case IDC_BUTTON2: //edit

                    OnProcessCustomActionsEdit(g_hInstance, hDlg, hListView, g_bUseTunneling);
                    break;

                case IDC_BUTTON3: //delete

                    OnProcessCustomActionsDelete(g_hInstance, hDlg, hListView, g_bUseTunneling);
                    break;

                case IDC_BUTTON4: //UP
                    OnProcessCustomActionsMoveUp(g_hInstance, hDlg, hListView, g_bUseTunneling);
                    break;

                case IDC_BUTTON5: //down
                    OnProcessCustomActionsMoveDown(g_hInstance, hDlg, hListView, g_bUseTunneling);
                    break;

                case IDC_COMBO1: // type of connect action to display
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        UINT uStringId;
                        CustomActionTypes Type;

                        hr = MapComboSelectionToType(hDlg, IDC_COMBO1, TRUE, g_bUseTunneling, &Type); // TRUE == bIncludesAll

                        MYDBGASSERT(SUCCEEDED(hr));
                        if (SUCCEEDED(hr))
                        {
                            if (ALL == Type)
                            {
                                uStringId = IDS_TYPE_COL_TITLE;
                            }
                            else
                            {
                                uStringId = IDS_PROGRAM_COL_TITLE;                            
                            }

                            UpdateListViewColumnHeadings(g_hInstance, hListView, uStringId, 1); // 1 == second column
                            RefreshListView(g_hInstance, hDlg, IDC_COMBO1, hListView, 0, g_bUseTunneling);
                        }
                    }

                    break;

                default:
                    break;
            }

            break;

        case WM_NOTIFY:


            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {
                case LVN_ITEMCHANGED:

                    //
                    //  We want to process item changed messages for when the selection changes.  This
                    //  way when the user selects an item in the list (either using the arrow keys or
                    //  the mouse) we will accurately update the arrow keys.  In order to cut down on the
                    //  number of calls we filter out the unselected messages.
                    //
                    pNMListView = (LPNMLISTVIEW) lParam;


                    if ((LVIF_STATE & pNMListView->uChanged) && (LVIS_SELECTED & pNMListView->uNewState))
                    {
                        int iTempItem = pNMListView->iItem;
                        RefreshEditDeleteMoveButtonStates(g_hInstance, hDlg, hListView, IDC_COMBO1, &iTempItem, g_bUseTunneling);
                    }

                    break;

                case NM_DBLCLK:
                case NM_RETURN:
                    if (ListView_GetItemCount(hListView))
                    {
                        OnProcessCustomActionsEdit(g_hInstance, hDlg, hListView, g_bUseTunneling);                    
                    }

                    break;

                case LVN_KEYDOWN:
                    {
                        //
                        //  User hit the right click key or typed Shift+F10
                        //
                        NMLVKEYDOWN* pKeyDown = (NMLVKEYDOWN*)lParam;
                        if (((VK_F10 == pKeyDown->wVKey) && (0 > GetKeyState(VK_SHIFT))) || (VK_APPS == pKeyDown->wVKey))
                        {
                            //
                            //  Figure out what item is currently selected and gets its position
                            //
                            iTemp = ListView_GetSelectionMark(hListView);
                            NMITEMACTIVATE ItemActivate = {0};

                            if (-1 != iTemp)
                            {
                                POINT ptPoint = {0};
                                if (ListView_GetItemPosition(hListView, iTemp, &ptPoint))
                                {
                                    RECT ItemRect;

                                    if (ListView_GetItemRect(hListView, iTemp, &ItemRect, LVIR_LABEL))
                                    {
                                        LONG lIndent = (ItemRect.bottom - ItemRect.top) / 2;
                                        ItemActivate.ptAction.x = ptPoint.x + lIndent;
                                        ItemActivate.ptAction.y = ptPoint.y + lIndent;
                                        ItemActivate.iItem = iTemp;
                                        OnProcessCustomActionsContextMenu(g_hInstance, hDlg, hListView, &ItemActivate, g_bUseTunneling, IDC_COMBO1);
                                    }
                                }
                            }
                        }
                    }
                    break;

                case NM_RCLICK:
                    OnProcessCustomActionsContextMenu(g_hInstance, hDlg, hListView, (NMITEMACTIVATE*)lParam, g_bUseTunneling, IDC_COMBO1);
                    break;

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));

                    //
                    //  Make sure we have a custom action class to work with
                    //
                    if (NULL == g_pCustomActionList)
                    {
                        g_pCustomActionList = new CustomActionList;

                        MYDBGASSERT(g_pCustomActionList);

                        if (NULL == g_pCustomActionList)
                        {
                            return FALSE;
                        }

                        //
                        //  Read in the custom actions from the Cms File
                        //

                        hr = g_pCustomActionList->ReadCustomActionsFromCms(g_hInstance, g_szCmsFile, g_szShortServiceName);
                        CMASSERTMSG(SUCCEEDED(hr), TEXT("ProcessCustomActions -- Loading custom actions failed."));
                    }

                    //
                    //  Setup the ListView control and the corresponding Combo box, note that we set bAddAll to TRUE so
                    //  that the All option is added.
                    //
                    hr = g_pCustomActionList->AddCustomActionTypesToComboBox(hDlg, IDC_COMBO1, g_hInstance, g_bUseTunneling, TRUE);

                    nResult = SendDlgItemMessage(hDlg, IDC_COMBO1, CB_GETCOUNT, (WPARAM)0, (LPARAM)0);
                    if ((CB_ERR != nResult) && (nResult > 0))
                    {
                        MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, IDC_COMBO1, CB_SETCURSEL, (WPARAM)0, (LPARAM)0));
                    }

                    //
                    //  Add built in custom actions
                    //
                    { // adding scope

                        BOOL bAddCmdlForVpn = FALSE;

                        if (g_szVpnFile[0])
                        {
                            //
                            //  We have a VPN file so let's check and see if they defined an UpdateUrl
                            //
                            GetPrivateProfileString(c_pszCmSectionSettings, c_pszCmEntryVpnUpdateUrl, TEXT(""), szTemp, MAX_PATH, g_szVpnFile);

                            if (szTemp[0])
                            {
                                bAddCmdlForVpn = TRUE;
                            }
                        }

                        hr = g_pCustomActionList->AddOrRemoveCmdl(g_hInstance, bAddCmdlForVpn, TRUE); // TRUE == bForVpn
                        MYDBGASSERT(SUCCEEDED(hr));

                        hr = g_pCustomActionList->AddOrRemoveCmdl(g_hInstance, (g_bUpdatePhonebook || ReferencedDownLoad()), FALSE); // FALSE == bForVpn
                        MYDBGASSERT(SUCCEEDED(hr));
                    }
                    //
                    //  Add the items to the list view control
                    //
                    RefreshListView(g_hInstance, hDlg, IDC_COMBO1, hListView, 0, g_bUseTunneling);

                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    
                    //
                    //  Set bUseTunneling == TRUE even though we may not be tunneling.  The reason for this is that
                    //  the user may have had a tunneling profile and then turned off tunneling.  If they turn
                    //  it back on again we don't want to lose all of their Pre-Tunnel actions nor do we want to
                    //  lose all of the flag settings that they have added to each action.  We will make sure
                    //  to use the actual g_bUseTunneling value when we write the actions to the cms file in 
                    //  WriteCMSFile.
                    //
                    MYDBGASSERT(g_pCustomActionList);
                    if (g_pCustomActionList)
                    {
                        hr = g_pCustomActionList->WriteCustomActionsToCms(g_szCmsFile, g_szShortServiceName, TRUE);
                        CMASSERTMSG(SUCCEEDED(hr), TEXT("ProcessCustomActions -- Failed to write out connect actions"));
                    }

                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessStatusMenuPopup
//
// Synopsis:  Processes Messages for the Popup dialog for Adding/Editing Status
//            Area Icon Menu items
//
// History:   quintinb Created Header and renamed from ProcessPage2G1    8/6/98
//
//+----------------------------------------------------------------------------
// USES GLOBAL VARIABLE DLGEDITITEM as input and output to the page
// You must sent DlgEditItem to the initial value of this page.
//

INT_PTR APIENTRY ProcessStatusMenuPopup(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szMsg[MAX_PATH+1];

    BOOL bChecked;
    static TCHAR szOld[MAX_PATH+1];
    IconMenu TempEditItem;
    SetDefaultGUIFont(hDlg,message,IDC_EDIT1);
    SetDefaultGUIFont(hDlg,message,IDC_EDIT2);
    SetDefaultGUIFont(hDlg,message,IDC_EDIT3);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_MENU)) return TRUE;

    switch (message)
    {

        case WM_INITDIALOG:

            //
            //  If we are editing we need to change the title
            //
            if (TEXT('\0') != DlgEditItem.szProgram[0])
            {
                LPTSTR pszTemp = CmLoadString(g_hInstance, IDS_EDIT_SHORTCUT_TITLE);

                if (pszTemp)
                {
                    MYVERIFY(SendMessage (hDlg, WM_SETTEXT, 0, (LPARAM)pszTemp));
                    CmFree(pszTemp);
                }
            }

            _tcscpy (szOld, DlgEditItem.szName);
            MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDIT1), WM_SETTEXT, 0, (LPARAM)DlgEditItem.szName));
            MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDIT2), WM_SETTEXT, 0, (LPARAM)GetName(DlgEditItem.szProgram)));
            MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDIT3), WM_SETTEXT, 0, (LPARAM)DlgEditItem.szParams));
            MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK1, (UINT)DlgEditItem.bDoCopy));

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_BUTTON1:
                    {
                        UINT uFilter = IDS_PROGFILTER;
                        TCHAR* szMask = TEXT("*.exe;*.com;*.bat");

                        int iReturn = DoBrowse(hDlg, &uFilter, &szMask, 1, IDC_EDIT2, TEXT("exe"), DlgEditItem.szProgram);

                        MYDBGASSERT(0 != iReturn);
                        if (iReturn && (-1 != iReturn))
                        {
                            //
                            //  Check the include binary button for the user
                            //
                            MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK1, TRUE));
                        }
                    }
                    break;

                case IDOK:
                    if (-1 == GetTextFromControl(hDlg, IDC_EDIT1, DlgEditItem.szName, MAX_PATH, TRUE)) // bDisplayError == TRUE
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                        return TRUE;
                    }

                    if (-1 == GetTextFromControl(hDlg, IDC_EDIT2, szTemp, MAX_PATH, TRUE)) // bDisplayError == TRUE
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT2));
                        return TRUE;
                    }
                    
                    if (szTemp[0] == TEXT('\0'))
                    {
                        MYVERIFY(IDOK == ShowMessage(hDlg,IDS_NEEDPROG,MB_OK));
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT2));
                        return TRUE;
                    }

                    CheckNameChange(DlgEditItem.szProgram,szTemp);

                    if (NULL != _tcschr(DlgEditItem.szProgram, TEXT('=')))
                    {
                        MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOEQUALSINMENU, MB_OK));
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT2));
                        return TRUE;
                    }

                    if (-1 == GetTextFromControl(hDlg, IDC_EDIT3, DlgEditItem.szParams, MAX_PATH, TRUE)) // bDisplayError == TRUE
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT3));
                        return TRUE;
                    }
                    
                    if (DlgEditItem.szName[0] == TEXT('\0'))
                    {
                        GetFileName(DlgEditItem.szProgram,DlgEditItem.szName);
                    }

                    if (_tcschr(DlgEditItem.szName, TEXT('=')))
                    {
                        MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOEQUALSINMENU, MB_OK));
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                        return TRUE;
                    }

                    bChecked = IsDlgButtonChecked(hDlg,IDC_CHECK1);
                    if (bChecked)
                    {
                        if (!VerifyFile(hDlg,IDC_EDIT2,DlgEditItem.szProgram,TRUE)) 
                        {
                            DlgEditItem.bDoCopy = FALSE;
                            return TRUE;
                        }
                        else
                        {
                            DlgEditItem.bDoCopy = TRUE;
                        }
                    }
                    else
                    {
                        DlgEditItem.bDoCopy = FALSE;
                    }

                    if ((0 != _tcscmp(szOld, DlgEditItem.szName)) && 
                        (GetIconMenuItem(DlgEditItem.szName, &TempEditItem)))
                    {
                        //
                        //  We have a duplicate entry, prompt the user to replace or try
                        //  again.
                        //

                        MYVERIFY(0 != LoadString(g_hInstance, IDS_MENUITEMEXISTS, szTemp, MAX_PATH));
                        //
                        // write the previously used name in the string
                        //
                        wsprintf(szMsg, szTemp, DlgEditItem.szName);
                        
                        //
                        //  If the user doesn't want to replace the duplicate item then we should set the focus to the description
                        //  edit control if it has text in it, otherwise we should set it to the program edit control.
                        //
                        if (IDNO == MessageBox(hDlg, szMsg, g_szAppTitle, MB_YESNO | MB_APPLMODAL | MB_DEFBUTTON2 | MB_ICONEXCLAMATION))
                        {
                            LRESULT lTextLen = SendDlgItemMessage(hDlg, IDC_EDIT1, WM_GETTEXTLENGTH, (WPARAM)0, (LPARAM)0);

                            SetFocus(GetDlgItem(hDlg, lTextLen ? IDC_EDIT1 : IDC_EDIT2));

                            return TRUE;
                        }
                    }

                    MYVERIFY(0 != EndDialog(hDlg,IDOK));
                    return (TRUE);

                case IDCANCEL:
                    MYVERIFY(0 != EndDialog(hDlg,IDCANCEL));
                    return (TRUE);

                default:
                    break;
            }
            break;

        default:
            return FALSE;
    }
    return FALSE;   
}   //lint !e715 we don't reference lParam

BOOL createListBxRecord(ListBxList ** HeadPtrListBx, ListBxList ** TailPtrListBx, void * pData, DWORD dwSize, LPCTSTR lpName)
{
    ListBxList * ptr;
    void * dataptr;
    unsigned int n;
    // check for same named record and update
    if ( *HeadPtrListBx != NULL )
    {
        ptr = *HeadPtrListBx;
        while (ptr != NULL)
        {
            if (_tcsicmp(lpName, ptr->szName) == 0)
            {
                memcpy(ptr->ListBxData,pData,dwSize);
                return (TRUE);
            }
            ptr = ptr->next;
        }
    }
            
    n = sizeof( struct ListBxStruct );
    ptr = (ListBxList *) CmMalloc(n);
    if (ptr == NULL )
    {
        return FALSE;
    }

    _tcscpy(ptr->szName, lpName);

    if (pData)
    {
        dataptr = CmMalloc(dwSize);    

        if (dataptr)
        {
            memcpy(dataptr, pData, dwSize);
            ptr->ListBxData = dataptr;
        }
        else
        {
            CmFree(ptr);
            return FALSE;
        }
    }

    ptr->next = NULL;
    if ( *HeadPtrListBx == NULL )     // If this is the first record in the linked list
    {
        *HeadPtrListBx = ptr;
    }
    else
    {
        (*TailPtrListBx)->next = ptr;
    }

    *TailPtrListBx = ptr;

    return TRUE;
}

// delete named IconMenu item from linked list

void DeleteListBxRecord(ListBxList ** HeadPtrListBx,ListBxList ** TailPtrListBx, LPTSTR lpName)
{
    ListBxList * ptr;
    ListBxList * prevptr;

    if ( HeadPtrListBx != NULL )
    {
        ptr = *HeadPtrListBx;
        prevptr = NULL;
        while (ptr != NULL)
        {
            if (_tcsicmp(lpName,ptr->szName) == 0)
            {
                if (prevptr == NULL)
                {
                    *HeadPtrListBx = ptr->next;
                    if (*HeadPtrListBx == NULL)
                    {
                        *TailPtrListBx = NULL;
                    }
                    else 
                    {
                        if ((*HeadPtrListBx)->next == NULL)
                        {
                            *TailPtrListBx = *HeadPtrListBx;
                        }
                    }
                }
                else
                {
                    prevptr->next = ptr->next;
                    if (prevptr->next == NULL)
                    {
                        *TailPtrListBx = prevptr;
                    }
                }
                CmFree(ptr->ListBxData);
                CmFree(ptr);
                return;
            }
            prevptr = ptr;
            ptr = ptr->next;
        }
    }
                
}

BOOL FindListItemByName(LPTSTR pszName, ListBxList* pHeadOfList, ListBxList** pFoundItem)
{
    if (NULL == pszName)
    {
        CMASSERTMSG(FALSE, TEXT("FindListItemByName -- Invalid parameter"));
        return FALSE;
    }
    
    if (NULL != pHeadOfList)
    {
        ListBxList * pCurrent = pHeadOfList;

        while (NULL != pCurrent)
        {
            if (0 == lstrcmpi(pszName, pCurrent->szName))
            {
                //
                //  Return the pointer to pCurrent if the caller asked for it
                //
                if (pFoundItem)
                {
                    *pFoundItem = pCurrent;
                }

                return TRUE;
            }

            pCurrent = pCurrent->next;
        }
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  updateRecord
//
// Synopsis:    Function updates an entry in the list of tray icon data structures
//              thus the entry is not added and then deleted when the user edits an
//              entry.  This takes away the putting the entry at the bottom of the list
//              problem cited in the bug.
//
// Arguments: PTSTR szName - New name of the entry
//            LPTSTR szProgram - Program string to add to the Tray Icon Entry
//            LPTSTR szParams - Parameter string to add to the Tray Icon Entry
//            BOOL bDoCopy - Value of whether this program should be included with the profile data item
//            LPTSTR szOld - Name of the entry to update
//
// Returns:   BOOL - TRUE if able to update the record
//                   FALSE if not able to find it
//
// Side Effects:    Replaces the entry named by szOld with the entry data and name for
//                  entry called szName.

// History:   quintinb  Created for bugfix 14399      9-9-97
//
//+----------------------------------------------------------------------------
static BOOL updateRecord(LPTSTR szName, LPTSTR szProgram, LPTSTR szParams, BOOL bDoCopy, LPTSTR szOld)
{
   IconMenu * ptr;

    // check for same named record and update
    if ( g_pHeadIcon != NULL )
    {
        ptr = g_pHeadIcon;
        while (ptr != NULL)
        {
            if (_tcsicmp(szOld,ptr->szName) == 0)
            {
                _tcscpy(ptr->szProgram,szProgram);
                _tcscpy(ptr->szParams,szParams);
                ptr->bDoCopy = bDoCopy;
                _tcscpy(ptr->szName, szName);
                return (TRUE);
            }
            ptr = ptr->next;
        }
    }
    return (FALSE);

}
// note, as of bug 14399 updating should be done with the above function
BOOL createRecord(LPCTSTR szName, LPCTSTR szProgram, LPCTSTR szParams, BOOL bDoCopy)
{
   IconMenu * ptr;
   unsigned int n;
    // check for same named record and update
    if ( g_pHeadIcon != NULL )
    {
        ptr = g_pHeadIcon;
        while (ptr != NULL)
        {
            if (_tcsicmp(szName,ptr->szName) == 0)
            {
                _tcscpy(ptr->szProgram,szProgram);
                _tcscpy(ptr->szParams,szParams);
                ptr->bDoCopy = bDoCopy;
                return (TRUE);
            }
            ptr = ptr->next;
        }
    }
                
   // 
   n = sizeof( struct IconMenuStruct );
   ptr = (IconMenu *) CmMalloc(n);
   if ( ptr == NULL )
   {
       return FALSE;
   }
   _tcscpy(ptr->szName,szName);
   _tcscpy(ptr->szProgram,szProgram);
   _tcscpy(ptr->szParams,szParams);
   ptr->bDoCopy = bDoCopy;

   ptr->next = NULL;
   if ( g_pHeadIcon == NULL )     // If this is the first record in the linked list
   {
       g_pHeadIcon = ptr;
   }
   else
   {
       g_pTailIcon->next = ptr;
   }
   g_pTailIcon = ptr;

   return TRUE;
}


// delete named IconMenu item from linked list

static void DeleteRecord(LPTSTR lpName)
{
    IconMenu * ptr;
    IconMenu * prevptr;

    if ( g_pHeadIcon != NULL )
    {
        ptr = g_pHeadIcon;
        prevptr = NULL;
        while (ptr != NULL)
        {
            if (_tcsicmp(lpName,ptr->szName) == 0)
            {
                if (prevptr == NULL)
                {
                    g_pHeadIcon = ptr->next;
                    if (g_pHeadIcon == NULL)
                    {
                        g_pTailIcon = NULL;
                    }
                    else 
                    {
                        if (g_pHeadIcon->next == NULL)
                        {
                            g_pTailIcon = g_pHeadIcon;
                        }
                    }
                }
                else
                {
                    prevptr->next = ptr->next;
                    if (prevptr->next == NULL)
                    {
                        g_pTailIcon = prevptr;
                    }
                }
                
                CmFree(ptr);
                return;
            }
            prevptr = ptr;
            ptr = ptr->next;
        }
    }
                
}

static BOOL MoveRecord(LPTSTR lpName, int direction)
{
    IconMenu * ptr;
    IconMenu * prevptr;
    IconMenu * nextptr;
    IconMenu TempIconMenu;

    if ( g_pHeadIcon != NULL )
    {
        ptr = g_pHeadIcon;
        prevptr = NULL;
        while (ptr != NULL)
        {
            if (_tcsicmp(lpName,ptr->szName) == 0)
            {
                if (((direction > 0)&&(ptr->next == NULL))||
                   ((direction < 0)&&(prevptr == NULL)))
                   return FALSE;

                if ((direction > 0)&&(ptr->next != NULL))
                {
                    //swap contents with next element
                    nextptr = ptr->next;
                    _tcscpy(TempIconMenu.szName,ptr->szName);
                    _tcscpy(TempIconMenu.szProgram,ptr->szProgram);
                    _tcscpy(TempIconMenu.szParams,ptr->szParams);
                    TempIconMenu.bDoCopy = ptr->bDoCopy;

                    _tcscpy(ptr->szName,nextptr->szName);
                    _tcscpy(ptr->szProgram,nextptr->szProgram);
                    _tcscpy(ptr->szParams,nextptr->szParams);
                    ptr->bDoCopy = nextptr->bDoCopy;

                    _tcscpy(nextptr->szName,TempIconMenu.szName);
                    _tcscpy(nextptr->szProgram,TempIconMenu.szProgram);
                    _tcscpy(nextptr->szParams,TempIconMenu.szParams);
                    nextptr->bDoCopy = TempIconMenu.bDoCopy;

                }
                else 
                {
                    if ((direction < 0)&&(prevptr != NULL))
                    {
                        _tcscpy(TempIconMenu.szName,ptr->szName);
                        _tcscpy(TempIconMenu.szProgram,ptr->szProgram);
                        _tcscpy(TempIconMenu.szParams,ptr->szParams);
                        TempIconMenu.bDoCopy = ptr->bDoCopy;

                        _tcscpy(ptr->szName,prevptr->szName);
                        _tcscpy(ptr->szProgram,prevptr->szProgram);
                        _tcscpy(ptr->szParams,prevptr->szParams);
                        ptr->bDoCopy = prevptr->bDoCopy;

                        _tcscpy(prevptr->szName,TempIconMenu.szName);
                        _tcscpy(prevptr->szProgram,TempIconMenu.szProgram);
                        _tcscpy(prevptr->szParams,TempIconMenu.szParams);
                        prevptr->bDoCopy = TempIconMenu.bDoCopy;
                    }
                }
                return TRUE;
            }
            prevptr = ptr;
            ptr = ptr->next;
        }
    }
    return TRUE;                
}

// retrieve named IconMenu item from linked list

BOOL GetIconMenuItem(LPTSTR lpName, IconMenu * EditItem)
{
    IconMenu * ptr;
    if ( g_pHeadIcon != NULL )
    {
        ptr = g_pHeadIcon;
        while (ptr != NULL)
        {
            if (_tcsicmp(lpName,ptr->szName) == 0)
            {
                _tcscpy(EditItem->szName,ptr->szName);
                _tcscpy(EditItem->szProgram,ptr->szProgram);
                _tcscpy(EditItem->szParams,ptr->szParams);
                EditItem->bDoCopy = ptr->bDoCopy;
                return TRUE;
            }
            ptr = ptr->next;
        }
    }
    return FALSE;
                
}

static BOOL WriteCopyMenuItemFiles(HANDLE hInf,LPTSTR pszFailFile, BOOL bWriteShortName)
{
    IconMenu * ptr;

    if (g_pHeadIcon != NULL)
    {
        ptr = g_pHeadIcon;
        while (ptr != NULL)
        {
            if (ptr->bDoCopy)
            {               
                if (!WriteCopy(hInf, ptr->szProgram, bWriteShortName))
                {
                    _tcscpy(pszFailFile, ptr->szProgram);
                    return FALSE;
                }
            }

            ptr = ptr->next;
        }
    }
    return TRUE;
}

static BOOL WriteCopyConActFiles(HANDLE hInf, LPTSTR pszFailFile, BOOL bWriteShortName)
{
    TCHAR szTemp[MAX_PATH+1];
    HRESULT hr = E_INVALIDARG;

    MYDBGASSERT(INVALID_HANDLE_VALUE != hInf);
    MYDBGASSERT(pszFailFile);
    MYDBGASSERT(g_pCustomActionList);

    if ((INVALID_HANDLE_VALUE != hInf) && pszFailFile && g_pCustomActionList)
    {
        CustomActionListEnumerator EnumPrograms(g_pCustomActionList);

        do
        {
            hr = EnumPrograms.GetNextIncludedProgram(szTemp, MAX_PATH);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                if (!WriteCopy(hInf, szTemp, bWriteShortName))
                {
                    _tcscpy(pszFailFile, szTemp);

                    hr = E_UNEXPECTED;
                }
            }

        } while (SUCCEEDED(hr) && (S_FALSE != hr));
    }

    return SUCCEEDED(hr);
}


static BOOL WriteCopyExtraFiles(HANDLE hInf,LPTSTR pszFailFile, BOOL bWriteShortName)
{
    ListBxList * ptr;
    ExtraData * pExtraData;

    if (g_pHeadExtra != NULL)
    {
        ptr = g_pHeadExtra;
        while (ptr != NULL)
        {
            pExtraData = (ExtraData *)(ptr->ListBxData);

            if (!WriteCopy(hInf, pExtraData->szPathname, bWriteShortName))
            {
                _tcscpy(pszFailFile, pExtraData->szPathname);
                return FALSE;
            }
            ptr = ptr->next;
        }
    }
    return TRUE;
}

static BOOL WriteCopyDnsFiles(HANDLE hInf, LPTSTR pszFailFile, BOOL bWriteShortName)
{
    ListBxList * ptr;
    CDunSetting* pDunSetting;

    if (g_pHeadDunEntry != NULL)
    {
        ptr = g_pHeadDunEntry;
        while (ptr != NULL)
        {
            pDunSetting = (CDunSetting*)(ptr->ListBxData);
            if (!WriteCopy(hInf, pDunSetting->szScript, bWriteShortName))
            {
                _tcscpy(pszFailFile, pDunSetting->szScript);
                return FALSE;
            }
            ptr = ptr->next;
        }
    }
    return TRUE;
}

void WriteDelMenuItemFiles(HANDLE hInf)
{
    IconMenu * ptr;

    if ( g_pHeadIcon != NULL )
    {
        ptr = g_pHeadIcon;
        while (ptr != NULL)
        {
            if (ptr->bDoCopy)
            {
                MYVERIFY(FALSE != WriteInfLine(hInf,ptr->szProgram));
            }
        
            ptr = ptr->next;
        }
    }
}

static BOOL WriteRefsFiles(HANDLE hInf,BOOL WriteCM)
{
    ListBxList * ptr;
    TCHAR szTemp[MAX_PATH+1];

    if ( g_pHeadRefs != NULL )
    {
        ptr = g_pHeadRefs;
        while (ptr != NULL)
        {
            if ((_tcsstr(ptr->szName,c_pszCmpExt) == NULL) && (!WriteCM))
            {
                MYVERIFY(FALSE != WriteInfLine(hInf,ptr->szName));
            }
            else 
            {
                if ((_tcsstr(ptr->szName,c_pszCmpExt) != NULL) && (WriteCM))
                {
                    _tcscpy(szTemp,ptr->szName);
                    _tcscat(szTemp, TEXT(",,,16")); // set to not overwrite existing file
                    MYVERIFY(FALSE != WriteInfLine(hInf,szTemp));
                }
            }

            ptr = ptr->next;
        }
    }
    return TRUE;
}

static BOOL WriteShortRefsFiles(HANDLE hInf,BOOL WriteCM)
{
    ListBxList * ptr;
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szShort[MAX_PATH + 1];
    RenameData TmpRenameData;
    TCHAR szCurrentDir[MAX_PATH+1];

    if (g_pHeadRefs != NULL)
    {
        ptr = g_pHeadRefs;
        // hack to fix short filename resolution
        // change dir to cmaktemp dir and use getshortpathname

        MYVERIFY(0 != GetCurrentDirectory(MAX_PATH, szCurrentDir));
        MYVERIFY(0 != SetCurrentDirectory(g_szTempDir));
        while (ptr != NULL)
        {
            if ((_tcsstr(ptr->szName,c_pszCmpExt) == NULL) && (!WriteCM))
            {
                // writing non-cmp files so I want to make sure that I use
                // the short file name if it is actually a long filename.
                
                if (GetShortPathName(ptr->szName, szShort, MAX_PATH))
                {
                    _tcscpy(szTemp, szShort);

                    if (_tcsicmp(szShort,ptr->szName) != 0)
                    {
                        _tcscpy(TmpRenameData.szShortName,szShort);
                        _tcscpy(TmpRenameData.szLongName,ptr->szName);
                        MYVERIFY(FALSE != createListBxRecord(&g_pHeadRename,&g_pTailRename,(void *)&TmpRenameData,sizeof(TmpRenameData),TmpRenameData.szShortName));
                    }
                } 
                else 
                {
                    _tcscpy(szTemp, ptr->szName);
                }

                MYVERIFY(FALSE != WriteInfLine(hInf,szTemp));
            } 
            else 
            {
                if ((_tcsstr(ptr->szName,c_pszCmpExt) != NULL) && (WriteCM)) 
                {
                    _tcscpy(szTemp,ptr->szName);
                    _tcscat(szTemp, TEXT(",,,16")); // set to not overwrite existing file
                    MYVERIFY(FALSE != WriteInfLine(hInf,szTemp));
                }
            }

            ptr = ptr->next;
        }

        MYVERIFY(0 != SetCurrentDirectory(szCurrentDir));
    }
    return TRUE;
}

static BOOL WriteLongRefsFiles(HANDLE hInf)
{
    ListBxList * ptr;
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szShort[MAX_PATH + 1];
    RenameData TmpRenameData;
    TCHAR szCurrentDir[MAX_PATH+1];

    if (g_pHeadRefs != NULL)
    {
        ptr = g_pHeadRefs;

        while (ptr != NULL)
        {
            GetFileName(ptr->szName, szTemp);

            MYVERIFY(FALSE != WriteInfLine(hInf, szTemp));
            
            ptr = ptr->next;
        }
    }
    return TRUE;
}

BOOL WriteDelConActFiles(HANDLE hInf)
{
    TCHAR szTemp[MAX_PATH+1];
    HRESULT hr = E_INVALIDARG;

    MYDBGASSERT(INVALID_HANDLE_VALUE != hInf);
    MYDBGASSERT(g_pCustomActionList);

    if ((INVALID_HANDLE_VALUE != hInf) && g_pCustomActionList)
    {

        CustomActionListEnumerator EnumPrograms(g_pCustomActionList);

        do
        {
            hr = EnumPrograms.GetNextIncludedProgram(szTemp, MAX_PATH);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                if (FALSE == WriteInfLine(hInf, szTemp))
                {
                    hr = E_UNEXPECTED;
                }
            }

        } while (SUCCEEDED(hr) && (S_FALSE != hr));
    }

    MYDBGASSERT(SUCCEEDED(hr));

    return SUCCEEDED(hr);
}


void WriteDelExtraFiles(HANDLE hInf)
{
    ListBxList * ptr;
    ExtraData * pExtraData;

    if ( g_pHeadExtra != NULL )
    {
        ptr = g_pHeadExtra;
        while (ptr != NULL)
        {
            pExtraData = (ExtraData *)(ptr->ListBxData);
            MYVERIFY(FALSE != WriteInfLine(hInf,pExtraData->szPathname));
            ptr = ptr->next;
        }
    }
}

void WriteDelDnsFiles(HANDLE hInf)
{

    ListBxList * ptr;
    CDunSetting * pDunSetting;

    if (NULL != g_pHeadDunEntry)
    {
        ptr = g_pHeadDunEntry;
        while (ptr != NULL)
        {
            pDunSetting = (CDunSetting*)(ptr->ListBxData);

            MYVERIFY(FALSE != WriteInfLine(hInf, pDunSetting->szScript));
            
            ptr = ptr->next;
        }
    }
}

void WriteSrcMenuItemFiles(HANDLE hInf)
{
    IconMenu * ptr;

    if ( g_pHeadIcon != NULL )
    {
        ptr = g_pHeadIcon;
        while (ptr != NULL)
        {
            if (ptr->bDoCopy)
            {
                MYVERIFY(FALSE != WriteSrcInfLine(hInf,ptr->szProgram));
            }
            
            ptr = ptr->next;
        }
    }
}

BOOL WriteSrcConActFiles(HANDLE hInf)
{
    TCHAR szTemp[MAX_PATH+1];
    HRESULT hr = E_INVALIDARG;

    MYDBGASSERT(INVALID_HANDLE_VALUE != hInf);
    MYDBGASSERT(g_pCustomActionList);

    if ((INVALID_HANDLE_VALUE != hInf) && g_pCustomActionList)
    {

        CustomActionListEnumerator EnumPrograms(g_pCustomActionList);

        do
        {
            hr = EnumPrograms.GetNextIncludedProgram(szTemp, MAX_PATH);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                if (FALSE == WriteSrcInfLine(hInf, szTemp))
                {
                    hr = E_UNEXPECTED;
                }
            }

        } while (SUCCEEDED(hr) && (S_FALSE != hr));
    }

    return SUCCEEDED(hr);
}
//+----------------------------------------------------------------------------
//
// Function:  WriteSrcRefsFiles
//
// Synopsis:  This function writes all the files on the HeadRef list to the 
//            [SourceDisksFiles] section of the INF.  Note that it has to change 
//            directory to the temp dir so that the WriteSrcInfLine won't fail
//            (it needs to locate the file to see if a short name should be used).
//
// Arguments: HANDLE hInf - Handle to the open inf file to pass to WriteSrcInfLine
//
// Returns:   Returns TRUE if all the files were written out successfully
//
// History:   quintinb  Created Header and added hack to fix failure of WriteSrcInfLine
//                      because it couldn't find the file to find its short name 1/22/98
//
//+----------------------------------------------------------------------------

BOOL WriteSrcRefsFiles(HANDLE hInf)
{
    ListBxList * ptr;
    BOOL bSuccess = TRUE;
    TCHAR szSavedDir[MAX_PATH+1];

    //
    //  Save the current directory and then set the current dir to
    //  the temp dir so that WriteSrcInfLine can find the shortfilename
    //  of the referenced files.
    //

    if ( g_pHeadRefs != NULL )
    {

        if (0 == GetCurrentDirectory(MAX_PATH, szSavedDir))
        {
            return FALSE;
        }
        
        if (0 == SetCurrentDirectory(g_szTempDir))
        {
            return FALSE;
        }

        ptr = g_pHeadRefs;
        while (ptr != NULL)
        {
            bSuccess = (bSuccess && WriteSrcInfLine(hInf,ptr->szName));
            ptr = ptr->next;
        }

        MYVERIFY(0 != SetCurrentDirectory(szSavedDir));
    }


    return bSuccess;
}

void WriteSrcExtraFiles(HANDLE hInf)
{
    ListBxList * ptr;
    ExtraData * pExtraData;
    
    if ( g_pHeadExtra != NULL )
    {
        ptr = g_pHeadExtra;
        while (ptr != NULL)
        {
            pExtraData = (ExtraData *)(ptr->ListBxData);
            MYVERIFY(FALSE != WriteSrcInfLine(hInf,pExtraData->szPathname));
            ptr = ptr->next;
        }
    }
}

void WriteSrcDnsFiles(HANDLE hInf)
{
    ListBxList * ptr;
    CDunSetting* pDunSetting;

    if (NULL != g_pHeadDunEntry)
    {
        ptr = g_pHeadDunEntry;

        while (NULL != ptr)
        {
            pDunSetting = (CDunSetting*)(ptr->ListBxData);

            MYVERIFY(FALSE != WriteSrcInfLine(hInf, pDunSetting->szScript));
            
            ptr = ptr->next;
        }
    }
}

BOOL WriteSEDConActFiles(HWND hDlg, int* pFileNum, LPCTSTR szSed)
{
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szFileName[MAX_PATH+1];
    HRESULT hr = E_INVALIDARG;

    MYDBGASSERT(hDlg);
    MYDBGASSERT(pFileNum);
    MYDBGASSERT(szSed);
    MYDBGASSERT(g_pCustomActionList);

    if (hDlg && pFileNum && szSed && g_pCustomActionList)
    {
        CustomActionListEnumerator EnumPrograms(g_pCustomActionList);

        do
        {
            hr = EnumPrograms.GetNextIncludedProgram(szTemp, MAX_PATH);

            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                GetFileName(szTemp, szFileName);

                if (FALSE == WriteSED(hDlg, szFileName, pFileNum, szSed))
                {
                    hr = E_UNEXPECTED;
                }
            }

        } while (SUCCEEDED(hr) && (S_FALSE != hr));
    }

    return SUCCEEDED(hr);
}

BOOL WriteSEDExtraFiles(HWND hDlg, int* pFileNum, LPCTSTR szSed)
{
    ListBxList * ptr;
    ExtraData * pExtraData;
    BOOL bReturn = TRUE;

    if ( g_pHeadExtra != NULL )
    {
        ptr = g_pHeadExtra;
        while (ptr != NULL)
        {
            pExtraData = (ExtraData *)(ptr->ListBxData);
            bReturn &= WriteSED(hDlg, pExtraData->szPathname, pFileNum, szSed);
            ptr = ptr->next;
        }
    }

    return bReturn;
}

BOOL WriteSEDDnsFiles(HWND hDlg, int* pFileNum, LPCTSTR szSed)
{
    BOOL bReturn = TRUE;
    ListBxList * ptr;
    CDunSetting* pDunSetting;
    
    if (NULL !=  g_pHeadDunEntry)
    {
        ptr = g_pHeadDunEntry;

        while (NULL != ptr)
        {
            pDunSetting = (CDunSetting*)(ptr->ListBxData);

            bReturn &= WriteSED(hDlg, pDunSetting->szScript, pFileNum, szSed);
            
            ptr = ptr->next;
        }
    }

    return bReturn;
}

BOOL WriteSEDRefsFiles(HWND hDlg, int* pFileNum, LPCTSTR szSed)
{
    ListBxList * ptr;
    BOOL bReturn = TRUE;

    if ( g_pHeadRefs != NULL )
    {
        ptr = g_pHeadRefs;
        while (ptr != NULL)
        {
            bReturn &= WriteSED(hDlg, ptr->szName, pFileNum, szSed);
            ptr = ptr->next;
        }
    }
    return bReturn;
}

BOOL WriteSEDMenuItemFiles(HWND hDlg, int* pFileNum, LPCTSTR szSed)
{
    IconMenu * ptr;
    BOOL bReturn = TRUE;

    if ( g_pHeadIcon != NULL )
    {
        ptr = g_pHeadIcon;
        while (ptr != NULL)
        {
            if (ptr->bDoCopy)
            {
                bReturn &= WriteSED(hDlg, ptr->szProgram, pFileNum, szSed);
            }
            ptr = ptr->next;
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteRenameSection
//
// Synopsis:  This function verifies that the name used in the rename data structure
//            is correct (the files name in the temp directory could be different
//            if the file was moved from a directory with multiple similarly named files) and then
//            writes the rename section to the inf.
//
// Arguments: HANDLE hInf - handle to the inf to add the rename section to.
//
// Returns:   Nothing
//
// History:   quintinb Created Header and added checking functionality   2/22/98
//
//+----------------------------------------------------------------------------
void WriteRenameSection(HANDLE hInf)
{
    ListBxList * ptr;
    TCHAR szOut[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szPathToFileInTempDir[MAX_PATH+1];

    RenameData * pRenameData;

    if ( g_pHeadRename != NULL )
    {
        ptr = g_pHeadRename;
        MYVERIFY(FALSE != WriteInf(hInf,TEXT("\r\n")));
        MYVERIFY(FALSE != WriteInf(hInf,TEXT("[Xnstall.RenameReg]\r\n")));
        WriteInf(hInf, TEXT("HKLM,%KEY_RENAME%\\CMRENAME,,,\"%49001%\\%ShortSvcName%\"\r\n"));//lint !e534 compile doesn't like the MYVERIFY macro and big strings

        while (ptr != NULL)
        {
            pRenameData = (RenameData *)(ptr->ListBxData);

            //
            //  Get the current ShortName for the File
            //

            GetFileName(pRenameData->szLongName, szTemp);            
            MYVERIFY(CELEMS(szPathToFileInTempDir) > (UINT)wsprintf(szPathToFileInTempDir, 
                TEXT("%s\\%s"), g_szTempDir, szTemp));

            MYVERIFY(0 != GetShortPathName(szPathToFileInTempDir, szTemp, MAX_PATH));

            GetFileName(szTemp, pRenameData->szShortName);

            //
            //  Now Write out the files
            //
            _tcscpy(szOut,TEXT("HKLM,%KEY_RENAME%\\CMRENAME,"));
            _tcscat(szOut,pRenameData->szShortName);
            _tcscat(szOut,TEXT(",,\""));
            _tcscat(szOut,pRenameData->szLongName);
            _tcscat(szOut,TEXT("\"\r\n"));
            MYDBGASSERT(_tcslen(szOut) <= sizeof(szOut));
            MYVERIFY(FALSE != WriteInf(hInf,szOut));
            ptr = ptr->next;
        }
    }
}

void WriteEraseLongName(HANDLE hInf)
{
    ListBxList * ptr;
    TCHAR szOut[MAX_PATH+1];
    RenameData * pRenameData;

    if ( g_pHeadRename != NULL )
    {
        ptr = g_pHeadRename;
        while (ptr != NULL)
        {
            pRenameData = (RenameData *)(ptr->ListBxData);
            pRenameData->szShortName[7] = pRenameData->szShortName[7]+1;
            _tcscpy(szOut,pRenameData->szShortName);
            _tcscat(szOut,TEXT("\r\n"));
            MYVERIFY(FALSE != WriteInf(hInf,szOut));
            ptr = ptr->next;
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessMenuItem
//
// Synopsis:  This function retrieves the data associated with the given keyname
//            under the [Menu Options] section of the given cms file.  It then
//            processes the data line into a program part and a parameters part.
//            Then using the keyname, the program string, and the params string
//            it adds an entry to the Status Area Menu Item linked list.
//
// Arguments: LPCTSTR pszKeyName - Name of the Menu Item
//            LPCTSTR pszCmsFile - CMS file containing the menu items
//            LPCTSTR pszProfilesDir - directory containing the profiles dir 
//                                     (to help determine if the file was included or not)
//
// Returns:   BOOL - TRUE if successful
//
// History:   quintinb Created     6/14/99
//
//+----------------------------------------------------------------------------
BOOL ProcessMenuItem(LPCTSTR pszKeyName, LPCTSTR pszCmsFile, LPCTSTR pszProfilesDir)
{

    //
    //  Check parameters
    //
    if ((NULL == pszKeyName) || (NULL == pszCmsFile) || 
        (TEXT('\0') == pszKeyName[0]) || (TEXT('\0') == pszCmsFile[0]))
    {
        CMTRACE(TEXT("ProcessMenuItem -- bad parameter passed."));
        return FALSE;
    }

    BOOL bFileIncluded = FALSE;
    BOOL bLongFileName = FALSE;
    BOOL bReturn = FALSE;
    LPTSTR pszParams = NULL;
    LPTSTR pszProgram = NULL;
    TCHAR szProgram[MAX_PATH+1];
    TCHAR SeperatorChar = TEXT('\0');

    //
    //  Get the Menu Item specified by pszKeyName
    //
    LPTSTR pszLine = GetPrivateProfileStringWithAlloc(c_pszCmSectionMenuOptions, pszKeyName, TEXT(""), pszCmsFile);

    if ((NULL == pszLine) || (TEXT('\0') == pszLine[0]))
    {
        CMTRACE(TEXT("ProcessMenuItem -- GetPrivateProfileStringWithAlloc failed"));
        goto exit;
    }

    //
    //  Now that we have a menu item, begin processing.  Since we have the keyname, we already
    //  have the name of the menu item.  We now could have any of the following strings:
    //
    //  +Program Name+ Params
    //  +Program Name+
    //  ProgName Params
    //  ProgName
    //
    //  Note that we surround long filenames with the '+' char.
    //

    CmStrTrim(pszLine);
    if (TEXT('+') == pszLine[0])
    {
        bLongFileName = TRUE;
        SeperatorChar = TEXT('+');

        pszProgram = CharNext(pszLine); // move past the initial +
    }
    else
    {
        bLongFileName = FALSE;
        SeperatorChar = TEXT(' ');

        pszProgram = pszLine;
    }

    pszParams = CmStrchr(pszProgram, SeperatorChar);

    if (pszParams)
    {
        LPTSTR pszTemp = pszParams;
        pszParams = CharNext(pszParams); // pszParams is either a NULL string or it is the parameters with a space.

        *pszTemp = TEXT('\0');
    }
    else
    {
        if (bLongFileName)
        {
            CMTRACE1(TEXT("ProcessMenuItem -- Unexpected Menu Item format: %s"), pszLine);
            goto exit;        
        }
        else
        {
            //
            //  Then we don't have any parameters, just a Program
            //
            pszParams = CmEndOfStr(pszProgram);
        }
    }

    CmStrTrim(pszParams);
    CmStrTrim(pszProgram);

    //
    //  Now check to see if the file exists in the profile or not
    //
    MYVERIFY(CELEMS(szProgram) > (UINT)wsprintf(szProgram, TEXT("%s%s"), pszProfilesDir, pszProgram));
    
    bFileIncluded = FileExists(szProgram);
    if (bFileIncluded)
    {
        //
        //  If we are in this if block then we have an edited profile that contains menu items.
        //  Use the full path to add to the record list.
        //
        pszProgram = szProgram; // memory will be cleaned up below because we only had one 
                                // allocation that we split up into several pieces.
    }

    bReturn = createRecord(pszKeyName, pszProgram, pszParams, bFileIncluded);

exit:

    CmFree(pszLine);
    return bReturn;
}



//+----------------------------------------------------------------------------
//
// Function:  ReadIconMenu
//
// Synopsis:  This function converts the Menu Options section of the given CMS
//            into the Status Area Menu Items linked list that internally 
//            represents it.
//
// Arguments: LPCTSTR pszCmsFile - Cms File to read the menu items from
//            LPCTSTR pszProfilesDir - full path to the Profiles directory 
//                                     (c:\program files\cmak\profiles usually)
//
// Returns:   BOOL - Returns TRUE if Successful
//
// History:   Created Header    6/14/99
//            quintinb Rewrote for Unicode Conversion   6/14/99
//
//+----------------------------------------------------------------------------
BOOL ReadIconMenu(LPCTSTR pszCmsFile, LPCTSTR pszProfilesDir)
{
    BOOL bReturn = TRUE;
    LPTSTR pszCurrentKeyName = NULL;

    //
    //  By calling WritePrivateProfileString with all NULL's we flush the file cache 
    //  (win95 only).  This call will return 0.
    //

    WritePrivateProfileString(NULL, NULL, NULL, g_szCmsFile); //lint !e534 this call will always return 0

    //
    //  First we want to get all of the keynames in the Menu Options section
    //
    LPTSTR pszKeyNames = GetPrivateProfileStringWithAlloc(c_pszCmSectionMenuOptions, NULL, TEXT(""), pszCmsFile);

    if (NULL == pszKeyNames)
    {
        //
        //  Nothing to process
        //
        goto exit;
    }

    pszCurrentKeyName = pszKeyNames;

    while (TEXT('\0') != (*pszCurrentKeyName))
    {        
        //
        //  Process the command line
        //
        bReturn = bReturn && ProcessMenuItem(pszCurrentKeyName, pszCmsFile, pszProfilesDir);
        
        //
        //  Find the next string by going to the end of the string
        //  and then going one more char.  Note that we cannot use
        //  CharNext here but must use just ++.
        //
        pszCurrentKeyName = CmEndOfStr(pszCurrentKeyName);
        pszCurrentKeyName++;
    }

exit:
    CmFree(pszKeyNames);

    return bReturn;
}

static void WriteIconMenu()
{
    IconMenu * LoopPtr;
    TCHAR szTemp[2*MAX_PATH+1];
    TCHAR szName[MAX_PATH+1];
    BOOL longname;

    // CLEAR OUT SECTION
    MYVERIFY(0 != WritePrivateProfileSection(c_pszCmSectionMenuOptions,TEXT("\0\0"),g_szCmsFile));

    if (g_pHeadIcon == NULL)
    {
        return;
    }
    LoopPtr = g_pHeadIcon;

    // WRITE IN ALL ENTRIES
    while( LoopPtr != NULL)
    {
        GetFileName(LoopPtr->szProgram,szName);

        if (IsFile8dot3(szName))
        {
            longname = FALSE;
        }
        else
        {
            longname = TRUE;            
        }

        // surround long file names with plus signs - quotes won't work cause 
        // they get stripped by the reading routines
        if (longname)
        {
            _tcscpy(szTemp,TEXT("+"));
        }
        else
        {
            szTemp[0] = TEXT('\0');
        }

        if (LoopPtr->bDoCopy)
        {
            _tcscat(szTemp,g_szShortServiceName);
            _tcscat(szTemp,TEXT("\\"));
        }

        _tcscat(szTemp,szName);

        if (longname)
        {
            _tcscat(szTemp,TEXT("+"));
        }

        _tcscat(szTemp,TEXT(" "));
        _tcscat(szTemp,LoopPtr->szParams);
        MYDBGASSERT(_tcslen(szTemp) <= CELEMS(szTemp));
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionMenuOptions,LoopPtr->szName,szTemp,g_szCmsFile));
        LoopPtr = LoopPtr->next;
    }
    
    //
    //  By calling WritePrivateProfileString with all NULL's we flush the file cache 
    //  (win95 only).  This call will return 0.
    //

    WritePrivateProfileString(NULL, NULL, NULL, g_szCmsFile); //lint !e534 this call will always return 0

}

static void RefreshIconMenu(HWND hwndDlg)
{
    IconMenu * LoopPtr;

    SendDlgItemMessage(hwndDlg,IDC_LIST1,LB_RESETCONTENT,0,(LPARAM)0); //lint !e534 LB_RESETCONTENT doesn't return anything
    if (g_pHeadIcon == NULL)
    {
        return;
    }
    LoopPtr = g_pHeadIcon;
    while( LoopPtr != NULL)
    {
        MYVERIFY(LB_ERR != SendDlgItemMessage(hwndDlg, IDC_LIST1, LB_ADDSTRING, 0,
            (LPARAM) LoopPtr->szName));

        LoopPtr = LoopPtr->next;
    }
}

void UpdateEditDeleteMoveButtons(HWND hDlg, IconMenu* pHeadIcon)
{
    
    LRESULT lResult;
    BOOL bEnableDeleteAndEdit = FALSE;
    BOOL bEnableMoveUp = FALSE;
    BOOL bEnableMoveDown = FALSE;

    lResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETCOUNT, 0, 0);
    
    if (LB_ERR != lResult)
    {
        //
        //  Enable the Delete and Edit Buttons because we have at least 1 item.
        //
        bEnableDeleteAndEdit = (0 < lResult);

        //
        //  If we have more than 1 item, then we need to enable the moveup and movedown
        //  buttons, depending on which item is selected.
        //
        if (1 < lResult)
        {

            bEnableMoveUp = TRUE;
            bEnableMoveDown = TRUE;

            //
            //  Get the name of the currently selected item
            //
            TCHAR szCurrentItem[MAX_PATH+1];
            lResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

            if (LB_ERR != lResult)
            {
                lResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETTEXT, lResult, (LPARAM)szCurrentItem);

                if (LB_ERR != lResult)
                {
                    IconMenu* pFollower = NULL;
                    IconMenu* pCurrent = pHeadIcon;

                    while (pCurrent)
                    {
                        if (0 == lstrcmpi(szCurrentItem, pCurrent->szName))
                        {
                            if (NULL == pFollower)
                            {
                                //
                                //  First item in the list, disable move up
                                //
                                bEnableMoveUp = FALSE;
                            }
                            else if (NULL == pCurrent->next)
                            {
                                //
                                //  Last item in the list, disable move down
                                //
                                bEnableMoveDown = FALSE;
                            }

                            break;
                        }

                        pFollower = pCurrent;
                        pCurrent = pCurrent->next;
                    }
                }
            }
        }
    }

    HWND hCurrentFocus = GetFocus();
    HWND hEditButton = GetDlgItem(hDlg, IDC_BUTTON2);
    HWND hDeleteButton = GetDlgItem(hDlg, IDC_BUTTON3);
    HWND hMoveUpButton = GetDlgItem(hDlg, IDC_BUTTON4);
    HWND hMoveDownButton = GetDlgItem(hDlg, IDC_BUTTON5);
    HWND hControl;

    if (hEditButton)
    {
        EnableWindow(hEditButton, bEnableDeleteAndEdit);
    }            

    if (hDeleteButton)
    {
        EnableWindow(hDeleteButton, bEnableDeleteAndEdit);
    }            

    if (hMoveUpButton)
    {
        EnableWindow(hMoveUpButton, bEnableMoveUp);
    }            

    if (hMoveDownButton)
    {
        EnableWindow(hMoveDownButton, bEnableMoveDown);
    }
    
    if (FALSE == IsWindowEnabled(hCurrentFocus))
    {
        if (hDeleteButton == hCurrentFocus)
        {
            //
            //  If delete is disabled and contained the focus, shift it to the Add button
            //
            hControl = GetDlgItem(hDlg, IDC_BUTTON1);
            SendMessage(hDlg, DM_SETDEFID, IDC_BUTTON1, (LPARAM)0L); //lint !e534 DM_SETDEFID doesn't return error info
            SetFocus(hControl);
        }
        else if ((hMoveUpButton == hCurrentFocus) && IsWindowEnabled(hMoveDownButton))
        {
            SetFocus(hMoveDownButton);
            SendMessage(hDlg, DM_SETDEFID, IDC_BUTTON5, (LPARAM)0L); //lint !e534 DM_SETDEFID doesn't return error info
        }
        else if ((hMoveDownButton == hCurrentFocus) && IsWindowEnabled(hMoveUpButton))
        {
            SetFocus(hMoveUpButton);
            SendMessage(hDlg, DM_SETDEFID, IDC_BUTTON4, (LPARAM)0L); //lint !e534 DM_SETDEFID doesn't return error info
        }
        else
        {
            //
            //  If all else fails set the focus to the list control
            //
            hControl = GetDlgItem(hDlg, IDC_LIST1);
            SetFocus(hControl);
        }    
    }
}

BOOL OnProcessStatusMenuIconsEdit(HWND hDlg)
{
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szOld[MAX_PATH+1];
    INT_PTR nResult;

    nResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETCURSEL, 0, (LPARAM)0);

    if (nResult == LB_ERR)
    {
        MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOSELECTION, MB_OK));
        return TRUE;
    }

    MYVERIFY(LB_ERR != SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETTEXT, (WPARAM)nResult, (LPARAM)szTemp));

    MYVERIFY(FALSE != GetIconMenuItem(szTemp, &DlgEditItem));

    _tcscpy(szOld, szTemp);
    
    nResult = DialogBoxParam(NULL, MAKEINTRESOURCE(IDD_MENU_ITEM_POPUP), hDlg, ProcessStatusMenuPopup, (LPARAM)0);
    
    if ((IDOK == nResult) && (TEXT('\0') != DlgEditItem.szName[0]))
    {
        if (0 == lstrcmpi(szOld, DlgEditItem.szName))
        {
            MYVERIFY(FALSE != updateRecord(DlgEditItem.szName, DlgEditItem.szProgram, 
                DlgEditItem.szParams, DlgEditItem.bDoCopy, szOld));                 
        }
        else
        {
            DeleteRecord(szOld);
            MYVERIFY(TRUE == createRecord(DlgEditItem.szName, DlgEditItem.szProgram, 
                DlgEditItem.szParams, DlgEditItem.bDoCopy));
        }
    
        RefreshIconMenu(hDlg);
        
        WriteIconMenu();
        
        nResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)DlgEditItem.szName);
        
        if (LB_ERR != nResult)
        {
            MYVERIFY(LB_ERR != SendDlgItemMessage(hDlg,IDC_LIST1,LB_SETCURSEL,(WPARAM)nResult,(LPARAM)0));
        }

        UpdateEditDeleteMoveButtons(hDlg, g_pHeadIcon);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessStatusMenuIcons
//
// Synopsis:  Customize the status area icon menu
//
//
// History:   quintinb  Created Header and renamed from ProcessPage2F1    8/6/98
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessStatusMenuIcons(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szOld[MAX_PATH+1];
    INT_PTR nResult;
    int direction;
    NMHDR* pnmHeader = (NMHDR*)lParam;
    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_MENU)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_LIST1);

    switch (message)
    {
        case WM_INITDIALOG:
            {
                //
                //  Load the arrow images for the move up and move down buttons
                //
                HICON hUpArrow = (HICON)LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_UP_ARROW), IMAGE_ICON, 0, 0, 0);
                HICON hDownArrow = (HICON)LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_DOWN_ARROW), IMAGE_ICON, 0, 0, 0);

                //
                //  Set the arrow button bit maps
                //
                SendMessage(GetDlgItem(hDlg, IDC_BUTTON4), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hUpArrow);
                SendMessage(GetDlgItem(hDlg, IDC_BUTTON5), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hDownArrow);
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_BUTTON1: //add
                    
                    ZeroMemory(&DlgEditItem,sizeof(DlgEditItem));
                    
                    nResult = DialogBoxParam(NULL, MAKEINTRESOURCE(IDD_MENU_ITEM_POPUP), hDlg, ProcessStatusMenuPopup, (LPARAM)0);

                    if ((nResult == IDOK) && (DlgEditItem.szName[0] != 0))
                    {
                        MYVERIFY(FALSE != createRecord(DlgEditItem.szName, DlgEditItem.szProgram, DlgEditItem.szParams, DlgEditItem.bDoCopy));
                        RefreshIconMenu(hDlg);
                        WriteIconMenu();

                        nResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)DlgEditItem.szName);                     
                        
                        if (LB_ERR != nResult)
                        {
                            MYVERIFY(LB_ERR != SendDlgItemMessage(hDlg,IDC_LIST1,LB_SETCURSEL,(WPARAM)nResult,(LPARAM)0));
                        }

                        UpdateEditDeleteMoveButtons(hDlg, g_pHeadIcon);
                    }
                    return (TRUE);
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case IDC_BUTTON2: //edit
                    OnProcessStatusMenuIconsEdit(hDlg);

                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case IDC_BUTTON3: //delete
                    nResult = SendDlgItemMessage(hDlg,IDC_LIST1,LB_GETCURSEL,0,(LPARAM)0);
                    if (nResult == LB_ERR)
                    {
                        MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOSELECTION, MB_OK));
                        return TRUE;
                    }
                    
                    MYVERIFY(LB_ERR != SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETTEXT, (WPARAM)nResult, 
                        (LPARAM)szTemp));

                    DeleteRecord(szTemp);

                    RefreshIconMenu(hDlg);

                    //
                    //  Reset the cursor selection to the first in the list, unless the list is empty.
                    //
                    nResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETCOUNT, (WPARAM)0, (LPARAM)0);

                    if (nResult)
                    {
                        MYVERIFY(LB_ERR != SendDlgItemMessage(hDlg, IDC_LIST1, LB_SETCURSEL, (WPARAM)0, (LPARAM)0));
                    }
                    
                    UpdateEditDeleteMoveButtons(hDlg, g_pHeadIcon);
                    
                    WriteIconMenu();
                    return (TRUE);

                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case IDC_BUTTON4: //UP
                case IDC_BUTTON5: //down
                    if (LOWORD(wParam) == IDC_BUTTON4)
                    {
                        direction = -1;
                    }
                    else
                    {
                        direction = 1;
                    }

                    nResult = SendDlgItemMessage(hDlg,IDC_LIST1,LB_GETCURSEL,0,(LPARAM)0);

                    if (nResult == LB_ERR)
                    {
                        MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOSELECTION, MB_OK));
                        return TRUE;
                    }

                    MYVERIFY(LB_ERR != SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETTEXT,
                        (WPARAM)nResult, (LPARAM)szTemp));

                    if (MoveRecord(szTemp,direction))
                    {
                        RefreshIconMenu(hDlg);
                        
                        MYVERIFY(LB_ERR != SendDlgItemMessage(hDlg, IDC_LIST1, LB_SETCURSEL, 
                            (WPARAM)(nResult + direction), (LPARAM)0));
                        
                        UpdateEditDeleteMoveButtons(hDlg, g_pHeadIcon);
                    }

                    WriteIconMenu();
                    
                    return (TRUE);

                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case IDC_LIST1:
                    if (LBN_DBLCLK == HIWORD(wParam))
                    {
                        OnProcessStatusMenuIconsEdit(hDlg);
                    }
                    else if (LBN_SELCHANGE == HIWORD(wParam))
                    {
                        //
                        //  The selection in the list box changed, update the move buttons if needed
                        //
                        UpdateEditDeleteMoveButtons(hDlg, g_pHeadIcon);
                    }
                    break;
                default:
                    break;
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {
                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));
                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));

                    if (g_pHeadIcon == NULL)
                    {
                        MYVERIFY(FALSE != ReadIconMenu(g_szCmsFile, g_szOsdir));
                    }
                    
                    RefreshIconMenu(hDlg);

                    //
                    //  Reset the cursor selection to the first in the list, unless the list is empty.
                    //  Then we should set focus on the Add button
                    //
                    nResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETCOUNT, (WPARAM)0, (LPARAM)0);

                    if (nResult)
                    {
                        MYVERIFY(LB_ERR != SendDlgItemMessage(hDlg, IDC_LIST1, LB_SETCURSEL, (WPARAM)0, (LPARAM)0));
                    }
                    else
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_BUTTON1));
                    }

                    UpdateEditDeleteMoveButtons(hDlg, g_pHeadIcon);
                    break;

                case PSN_WIZBACK:
                    WriteIconMenu();

                    break;
                case PSN_WIZNEXT:
                    WriteIconMenu();
                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

//+----------------------------------------------------------------------------
//
// Function:  DisplayBitmap
//
// Synopsis:  This function takes a BMPDATA structure with a valid HDIBitmap data
//            (device Independent bitmap data) and creates a device dependent bitmap
//            and displays it on the specified bitmap window control.
//
// Arguments: HWND hDlg - Window handle of the dialog containing the Bitmap control
//            int iBitmapControl - Resource ID of the bitmap window control
//            HPALETTE* phMasterPalette - pointer to the master palette
//            BMPDATA* pBmpData - pointer to the BMPDATA to display
//
// Returns:   Nothing
//
// History:   quintinb Created   8/6/98
//
//+----------------------------------------------------------------------------
void DisplayBitmap(HWND hDlg, int iBitmapControl, HPALETTE* phMasterPalette, BMPDATA* pBmpData)
{
    MYDBGASSERT(NULL != pBmpData);
    MYDBGASSERT(pBmpData->hDIBitmap);
    MYDBGASSERT(NULL != phMasterPalette);
    if ((NULL != pBmpData) && (pBmpData->hDIBitmap) && (NULL != phMasterPalette))
    {       
        pBmpData->phMasterPalette = phMasterPalette;
        pBmpData->bForceBackground = FALSE; // Paint as a Foreground App

        if (CreateBitmapData(pBmpData->hDIBitmap, pBmpData, hDlg, TRUE))
        {
            SendDlgItemMessage(hDlg, iBitmapControl, STM_SETIMAGE, 
                IMAGE_BITMAP, 
                (LPARAM) pBmpData); //lint !e534 STM_SETIMAGE doesn't return error info
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  ProcesssSigninBitmap
//
// Synopsis:  Customize the sign-in bitmap -- this function processes the
//            messages for the page in CMAK that handles customizing the 
//            sign-in dialog bitmap.
//
//
// History:   quintinb   Created Header    8/6/98
//            quintinb   Rewrote to use new shared bitmap handling code  8/6/98
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessSigninBitmap(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szTemp[MAX_PATH+1];
    TCHAR* pszBitmap;
    NMHDR* pnmHeader = (NMHDR*)lParam;
    static TCHAR szDisplay[MAX_PATH+1]; // keeps unselected custom entry
    static BMPDATA BmpData;
    static HPALETTE hMasterPalette;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_BITMAPS)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_EDITSPLASH);

    switch (message)
    {

        case WM_INITDIALOG:
            SetFocus(GetDlgItem(hDlg, IDC_EDITSPLASH));
            break;

        case WM_PALETTEISCHANGING:
            break;

        case WM_PALETTECHANGED:
            
            if ((wParam != (WPARAM) hDlg) && (BmpData.hDIBitmap))
            {
                //
                // Handle the palette change.
                //              
                CMTRACE2(TEXT("ProcessSigninBitmap handling WM_PALETTECHANGED message, wParam=0x%x, hDlg=0x%x."), wParam, hDlg);
                PaletteChanged(&BmpData, hDlg, IDC_DEFAULTBRAND); 
            }
            
            return TRUE;
            break;  //lint !e527 Unreachable but please keep in case someone removes the return

        case WM_QUERYNEWPALETTE:

            QueryNewPalette(&BmpData, hDlg, IDC_DEFAULTBRAND);

            return TRUE;
            
            break;  //lint !e527 Unreachable but please keep in case someone removes the return

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_RADIO1:

                    //
                    //  Display the Default Bitmap
                    //

                    EnableWindow(GetDlgItem(hDlg,IDC_EDITSPLASH),FALSE);
                    _tcscpy(szDisplay, g_szBrandBmp);
                    
                    //
                    //  Load the default Bitmap
                    //
                    ReleaseBitmapData(&BmpData);
                    BmpData.hDIBitmap = CmLoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_CM_DEFAULT));
                    
                    //
                    //  Display it
                    //
                    DisplayBitmap(hDlg, IDC_DEFAULTBRAND, &hMasterPalette, &BmpData);

                    break;

                case IDC_RADIO2:
                    //
                    //  Display a custom Bitmap
                    //
                    EnableWindow(GetDlgItem(hDlg, IDC_EDITSPLASH), TRUE);
                    
                    if (TEXT('\0') != g_szBrandBmp[0])
                    {
                        pszBitmap = g_szBrandBmp;
                    }
                    else if (TEXT('\0') != szDisplay[0])
                    {
                        pszBitmap = szDisplay;
                    }
                    else
                    {
                        break;
                    }

                    //
                    //  Load the Custom Bitmap
                    //
                    ReleaseBitmapData(&BmpData);
                    BmpData.hDIBitmap = CmLoadBitmap(g_hInstance, pszBitmap);
                
                    //
                    //  Display it
                    //
                    DisplayBitmap(hDlg, IDC_DEFAULTBRAND, &hMasterPalette, &BmpData);

                    break;

                case IDC_BROWSEBMP1:
                    EnableWindow(GetDlgItem(hDlg, IDC_EDITSPLASH), TRUE);

                    MYVERIFY(0 != CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2));

                    {
                        UINT uFilter = IDS_BMPFILTER;
                        TCHAR* szMask = TEXT("*.bmp");

                        MYVERIFY(0 != DoBrowse(hDlg, &uFilter, &szMask, 1,
                            IDC_EDITSPLASH, TEXT("bmp"), g_szBrandBmp));
                    }

                    //
                    //  If we have a custom bitmap name, load and display it
                    //
                    
                    if (TEXT('\0') != g_szBrandBmp[0])
                    {
                        ReleaseBitmapData(&BmpData);
                        BmpData.hDIBitmap = CmLoadBitmap(g_hInstance, g_szBrandBmp);
                
                        //
                        //  Display it
                        //
                        DisplayBitmap(hDlg, IDC_DEFAULTBRAND, &hMasterPalette, &BmpData);
                    }
                        
                    break;

                case IDC_EDITSPLASH:

                    if (HIWORD(wParam) == EN_KILLFOCUS) 
                    {
                        //
                        //  Notice that we do not do a file check on the text retrieved from the control.
                        //  We do this because, changing focus is an awkward time to do this check and brings
                        //  up the error dialog way to often.  We will catch this on Back or Next anyway so let
                        //  it go by here.
                        //
                        GetTextFromControl(hDlg, IDC_EDITSPLASH, szTemp, MAX_PATH, FALSE); // bDisplayError == FALSE
                  
                        CheckNameChange(g_szBrandBmp, szTemp);

                        if (TEXT('\0') != g_szBrandBmp[0])
                        {
                            //
                            //  Load the Custom Bitmap
                            //
                            ReleaseBitmapData(&BmpData);
                            BmpData.hDIBitmap = CmLoadBitmap(g_hInstance, g_szBrandBmp);
            
                            //
                            //  Display it
                            //
                            DisplayBitmap(hDlg, IDC_DEFAULTBRAND, &hMasterPalette, &BmpData);
                        }
                        return TRUE;
                    }
                    break;

                default:
                    break;
            }
            break;

            case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));
                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));

                    //
                    //  Get the bitmap string from the CMS and verify that the file
                    //  exists.
                    //
                    
                    ZeroMemory(g_szBrandBmp, sizeof(g_szBrandBmp));
                    ZeroMemory(&BmpData, sizeof(BMPDATA));

                    GetPrivateProfileString(c_pszCmSection, c_pszCmEntryLogo, TEXT(""), 
                        g_szBrandBmp, CELEMS(g_szBrandBmp), g_szCmsFile);   //lint !e534
                    
                    if (TEXT('\0') == g_szBrandBmp[0])
                    {
                        //
                        //  Then we use the default CM bitmap, disable edit control
                        //
                        MYVERIFY(0 != CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1));
                        EnableWindow(GetDlgItem(hDlg, IDC_EDITSPLASH), FALSE);
                        //
                        //  Note that we  use szDisplay here just in case the use selects a
                        //  bitmap and then switches back to default.
                        //
                        MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDITSPLASH), 
                            WM_SETTEXT, 0, (LPARAM)GetName(szDisplay)));

                        //
                        //  Load the default Bitmap
                        //
                        ReleaseBitmapData(&BmpData);
                        BmpData.hDIBitmap = CmLoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_CM_DEFAULT));
                    }
                    else
                    {
                        //
                        //  Use whatever bitmap is specified in the CMS.
                        //
                        MYVERIFY(0 != CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2));
                        EnableWindow(GetDlgItem(hDlg, IDC_EDITSPLASH), TRUE);
                        
                        MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDITSPLASH), 
                            WM_SETTEXT, 0, (LPARAM)GetName(g_szBrandBmp)));
                        
                        MYVERIFY(FALSE != VerifyFile(hDlg, IDC_EDITSPLASH, g_szBrandBmp, FALSE));

                        //
                        //  Load the specified Bitmap
                        //

                        if (!FileExists(g_szBrandBmp))
                        {
                            TCHAR szFile[MAX_PATH+1];

                            // LOOK UP THE FILE IN THE PROFILE DIRECTORY
                            GetFileName(g_szBrandBmp, szFile);
                            MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s%s\\%s"), 
                                g_szOsdir, g_szShortServiceName, szFile));
                            
                            if (!FileExists(szTemp))
                            {
                                return FALSE; //GIVE UP;
                            }
                            else
                            {
                                _tcscpy(g_szBrandBmp, szTemp);
                            }
                        }
                        
                        if (TEXT('\0') != g_szBrandBmp[0])
                        {
                            //
                            //  Load the custom Bitmap
                            //
                            ReleaseBitmapData(&BmpData);
                            BmpData.hDIBitmap = CmLoadBitmap(g_hInstance, g_szBrandBmp);
                        }
                    }

                    //
                    // If we have a handle, create a new Device Dependent bitmap 
                    // and display it.
                    //
                    DisplayBitmap(hDlg, IDC_DEFAULTBRAND, &hMasterPalette, &BmpData);

                    break;

                case PSN_WIZBACK:

                case PSN_WIZNEXT:

                    //
                    //  Make sure that the user typed in a Bitmap name if they selected
                    //  to have a custom bitmap.
                    //
                    if (IsDlgButtonChecked(hDlg, IDC_RADIO2) == BST_CHECKED)
                    {
                        if (-1 == GetTextFromControl(hDlg, IDC_EDITSPLASH, szTemp, MAX_PATH, TRUE)) // bDisplayError == TRUE
                        {
                            SetFocus(GetDlgItem(hDlg, IDC_EDITSPLASH));
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }

                        if (!VerifyFile(hDlg, IDC_EDITSPLASH, g_szBrandBmp, TRUE))
                        {
                            return 1;
                        }
                        else if (TEXT('\0') == g_szBrandBmp[0])
                        {
                            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOBMP, MB_OK));

                            SetFocus(GetDlgItem(hDlg, IDC_EDITSPLASH));
                            
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }
                        else
                        {
                            //
                            //  Try to Load the bitmap to make sure it is valid
                            //

                            TCHAR szTemp1[MAX_PATH+1];

                            ReleaseBitmapData(&BmpData);
                            BmpData.hDIBitmap = CmLoadBitmap(g_hInstance, g_szBrandBmp);
                            
                            if (NULL == BmpData.hDIBitmap)
                            {
                                //
                                //  Use szTemp1 to hold the format string
                                //
                                MYVERIFY(0 != LoadString(g_hInstance, IDS_INVALIDBMP, szTemp1, MAX_PATH));
                                MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, szTemp1, g_szBrandBmp));

                                MessageBox(hDlg, szTemp, g_szAppTitle, MB_OK);
                                
                                SetFocus(GetDlgItem(hDlg, IDC_EDITSPLASH));
                            
                                MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                                return 1;
                            }                        
                        }
                    }
                    else
                    {
                        g_szBrandBmp[0] = TEXT('\0');
                    }


                    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryLogo,
                                                               g_szBrandBmp, g_szCmsFile));
                    
                    //
                    //  By calling WritePrivateProfileString with all NULL's we flush the file cache 
                    //  (win95 only).  This call will return 0.
                    //

                    WritePrivateProfileString(NULL, NULL, NULL, g_szCmpFile); //lint !e534 this call will always return 0

                    //
                    // Fall through to cleanup code in RESET handler
                    //

                case PSN_RESET: 
                    
                    //
                    //  Cleanup the Graphics Objects
                    //
                    ReleaseBitmapData(&BmpData);

                    if (NULL != hMasterPalette)
                    {
                        DeleteObject(hMasterPalette);
                        hMasterPalette = NULL;
                    }

                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessPhoneBookBitmap
//
// Synopsis:  Customize the Phone Book bitmap -- this function processes the
//            messages for the page in CMAK that handles customizing the 
//            pb dialog bitmap.
//
//
// History:   quintinb   Created Header    8/6/98
//            quintinb   Rewrote to use new shared bitmap handling code  8/6/98
//            quintinb   Renamed from ProcessPage4
//
//+----------------------------------------------------------------------------

INT_PTR APIENTRY ProcessPhoneBookBitmap(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szFile[MAX_PATH+1];
    TCHAR* pszBitmap;
    NMHDR* pnmHeader = (NMHDR*)lParam;
    static TCHAR szDisplay[MAX_PATH+1]; // keeps unselected custom entry
    static BMPDATA BmpData;
    static HPALETTE hMasterPalette;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_BITMAPS)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_EDITSPLASH);

    switch (message)
    {

        case WM_INITDIALOG:
            SetFocus(GetDlgItem(hDlg, IDC_EDITSPLASH));
            break;

        case WM_PALETTEISCHANGING:
            break;

        case WM_PALETTECHANGED: 
            if ((wParam != (WPARAM) hDlg) && (BmpData.hDIBitmap))
            {
                //
                // Handle the palette change.
                //              
                CMTRACE2(TEXT("ProcessSigninBitmap handling WM_PALETTECHANGED message, wParam=0x%x, hDlg=0x%x."), wParam, hDlg);
                PaletteChanged(&BmpData, hDlg, IDC_PDEFAULTBRAND); 
            }
            
            return TRUE;
            break;  //lint !e527 Unreachable but please keep in case someone removes the return

        case WM_QUERYNEWPALETTE:
            QueryNewPalette(&BmpData, hDlg, IDC_PDEFAULTBRAND);

            return TRUE;
            
            break;  //lint !e527 Unreachable but please keep in case someone removes the return

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_RADIO1:
                    //
                    //  Display the Default Bitmap
                    //

                    EnableWindow(GetDlgItem(hDlg,IDC_EDITSPLASH),FALSE);
                    _tcscpy(szDisplay, g_szPhoneBmp);
                    
                    //
                    //  Load the default Bitmap
                    //
                    ReleaseBitmapData(&BmpData);
                    BmpData.hDIBitmap = CmLoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_CM_PB_DEFAULT));
                    
                    //
                    //  Display it
                    //
                    DisplayBitmap(hDlg, IDC_PDEFAULTBRAND, &hMasterPalette, &BmpData);

                    break;

                case IDC_RADIO2:
                    //
                    //  Display a custom Bitmap
                    //
                    EnableWindow(GetDlgItem(hDlg, IDC_EDITSPLASH), TRUE);
                    
                    if (TEXT('\0') != g_szPhoneBmp[0])
                    {
                        pszBitmap = g_szPhoneBmp;
                    }
                    else if (TEXT('\0') != szDisplay[0])
                    {
                        pszBitmap = szDisplay;
                    }
                    else
                    {
                        //
                        //  Nothing has been specified yet
                        //
                        break;
                    }

                    //
                    //  Load the Custom Bitmap
                    //
                    ReleaseBitmapData(&BmpData);
                    BmpData.hDIBitmap = CmLoadBitmap(g_hInstance, pszBitmap);
                
                    //
                    //  Display it
                    //
                    DisplayBitmap(hDlg, IDC_PDEFAULTBRAND, &hMasterPalette, &BmpData);

                    break;

                case IDC_BROWSEBMP2:
                    EnableWindow(GetDlgItem(hDlg,IDC_EDITSPLASH),TRUE);

                    MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2));

                    {
                        UINT uFilter = IDS_BMPFILTER;
                        TCHAR* szMask = TEXT("*.bmp");
                        MYVERIFY(0 != DoBrowse(hDlg, &uFilter, &szMask, 1,
                            IDC_EDITSPLASH, TEXT("bmp"), g_szPhoneBmp));
                    }

                    //
                    //  If we have a custom bitmap name, load and display it
                    //
                    
                    if (TEXT('\0') != g_szPhoneBmp[0])
                    {
                        //
                        //  Load the Custom Bitmap
                        //
                        ReleaseBitmapData(&BmpData);
                        BmpData.hDIBitmap = CmLoadBitmap(g_hInstance, g_szPhoneBmp);
            
                        //
                        //  Display it
                        //
                        DisplayBitmap(hDlg, IDC_PDEFAULTBRAND, &hMasterPalette, &BmpData);
                    }
                    
                    break;

                case IDC_EDITSPLASH:
                    if (HIWORD(wParam) == EN_KILLFOCUS)
                    {
                        //
                        //  Note that we do not check whether we can convert the files to ANSI on Change of Focus
                        //  the reason is because the user would get too many error messages and they would be somewhat
                        //  confusing.  Instead we will catch this on Next/Back and ignore it here.
                        //
                        GetTextFromControl(hDlg, IDC_EDITSPLASH, szTemp, MAX_PATH, FALSE); // bDisplayError == FALSE

                        CheckNameChange(g_szPhoneBmp, szTemp);
                        
                        if (TEXT('\0') != g_szPhoneBmp[0])
                        {
                            //
                            //  Load the Custom Bitmap
                            //
                            ReleaseBitmapData(&BmpData);
                            BmpData.hDIBitmap = CmLoadBitmap(g_hInstance, g_szPhoneBmp);
        
                            //
                            //  Display it
                            //
                            DisplayBitmap(hDlg, IDC_PDEFAULTBRAND, &hMasterPalette, &BmpData);
                        }
                        
                        return TRUE;
                    }

                    break;

                default:
                    break;
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));
                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));
                    
                    ZeroMemory(g_szPhoneBmp, sizeof(g_szPhoneBmp));
                    ZeroMemory(&BmpData, sizeof(BMPDATA));
                    
                    GetPrivateProfileString(c_pszCmSection, c_pszCmEntryPbLogo, TEXT(""), 
                        g_szPhoneBmp, CELEMS(g_szPhoneBmp), g_szCmsFile); //lint !e534
                    
                    if (TEXT('\0') != g_szPhoneBmp[0])
                    {
                        //
                        //  We want to Display a Custom Bitmap
                        //
                        MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2));

                        EnableWindow(GetDlgItem(hDlg, IDC_EDITSPLASH), TRUE);
                        
                        MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDITSPLASH), WM_SETTEXT, 
                            0, (LPARAM)GetName(g_szPhoneBmp)));

                        MYVERIFY(FALSE != VerifyFile(hDlg, IDC_EDITSPLASH, g_szPhoneBmp, FALSE));
                        
                        if (!FileExists(g_szPhoneBmp)) 
                        {
                            //
                            //  We couldn't find it the first time so build the path to the profile
                            //  directory and try again.
                            //
                            GetFileName(g_szPhoneBmp, szFile);
                            MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s%s\\%s"), 
                                g_szOsdir, g_szShortServiceName, szFile));
    
                            if (!FileExists(szTemp)) 
                            {
                                //
                                //  We can't find it so give up.
                                //
                                return FALSE;
                            }
                            else
                            {
                                _tcscpy(g_szPhoneBmp, szTemp);
                            }
                        }
                        
                        //
                        //  Load the Custom Bitmap
                        //
                        ReleaseBitmapData(&BmpData);
                        BmpData.hDIBitmap = CmLoadBitmap(g_hInstance, g_szPhoneBmp);

                    }
                    else
                    {
                        //
                        //  We want to Display the Default Bitmap
                        //
                        MYVERIFY(0 != CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1));

                        EnableWindow(GetDlgItem(hDlg, IDC_EDITSPLASH), FALSE);
                        
                        MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDITSPLASH), WM_SETTEXT, 
                            0, (LPARAM)GetName(szDisplay)));

                        //
                        //  Load the default Bitmap
                        //
                        ReleaseBitmapData(&BmpData);
                        BmpData.hDIBitmap = CmLoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_CM_PB_DEFAULT));

                    }

                    //
                    //  Display it
                    //
                    DisplayBitmap(hDlg, IDC_PDEFAULTBRAND, &hMasterPalette, &BmpData);
                    
                    break;

                case PSN_WIZBACK:

                case PSN_WIZNEXT:
                    
                    //
                    // First check to see if the user entered a bmp file if they
                    // selected that they wanted to display a custom bitmap.
                    //
                    if (IsDlgButtonChecked(hDlg, IDC_RADIO2) == BST_CHECKED)
                    {
                        if (-1 == GetTextFromControl(hDlg, IDC_EDITSPLASH, szTemp, MAX_PATH, TRUE)) // bDisplayError == TRUE
                        {
                            SetFocus(GetDlgItem(hDlg, IDC_EDITSPLASH));
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }
                        
                        if (!VerifyFile(hDlg, IDC_EDITSPLASH, g_szPhoneBmp, TRUE)) 
                        {
                            return 1;
                        }
                        else if (TEXT('\0') == g_szPhoneBmp[0])
                        {
                            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOBMP, MB_OK));

                            SetFocus(GetDlgItem(hDlg, IDC_EDITSPLASH));
                            
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }
                        else
                        {
                            ReleaseBitmapData(&BmpData);
                            BmpData.hDIBitmap = CmLoadBitmap(g_hInstance, g_szPhoneBmp);

                            if (NULL == BmpData.hDIBitmap)
                            {
                                TCHAR szTemp1[MAX_PATH+1];

                                //
                                //  Then we have an invalid bitmap file.  Inform the user.
                                //  Using szTemp1 as a temp var for the format string.
                                //
                                MYVERIFY(0 != LoadString(g_hInstance, IDS_INVALIDBMP, szTemp1, MAX_PATH));                   
                                MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, szTemp1, g_szPhoneBmp));
                               
                                MessageBox(hDlg, szTemp, g_szAppTitle, MB_OK);

                                SetFocus(GetDlgItem(hDlg, IDC_EDITSPLASH));
                            
                                MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                                return 1;
                            }
                        }
                    }
                    else
                    {
                        g_szPhoneBmp[0] = TEXT('\0');
                    }

                    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection,c_pszCmEntryPbLogo,g_szPhoneBmp,g_szCmsFile));
                                        //
                    //  By calling WritePrivateProfileString with all NULL's we flush the file cache 
                    //  (win95 only).  This call will return 0.
                    //

                    WritePrivateProfileString(NULL, NULL, NULL, g_szCmpFile); //lint !e534 this call will always return 0

                    //
                    // Fall through to cleanup code in RESET handler
                    //

                case PSN_RESET: 

                    //
                    //  Cleanup the Graphics Objects
                    //
                    ReleaseBitmapData(&BmpData);

                    if (NULL != hMasterPalette)
                    {
                        DeleteObject(hMasterPalette);
                        hMasterPalette = NULL;
                    }

                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}


BOOL UpdateIcon(HWND hDlg,DWORD ctrlID,LPTSTR lpFile,BOOL issmall)
{
    HANDLE hRes = NULL;
    DWORD nResult;
    LPTSTR lpfilename;
    TCHAR szTemp[MAX_PATH+1] = TEXT("");
    BOOL bReturn = FALSE;

    //
    //  Don't do the ANSI conversion check on the Icons here because this function
    //  is only called from the Kill Focus windows message.  Thus we don't want to
    //  put up an error message here.  It will be caught by the Next/Back messages
    //  anyway so ignore it here.
    //
    GetTextFromControl(hDlg, ctrlID, szTemp, MAX_PATH, FALSE); // bDisplayError == FALSE

    CheckNameChange(lpFile, szTemp);

    lstrcpy(szTemp, lpFile); // we need a temp to hold lpFile so that it can be modified by Search Path as necessary.
    nResult = SearchPath(NULL, szTemp, NULL, MAX_PATH, lpFile, &lpfilename);
    if (nResult != 0)
    {
        if (issmall)
        {
            hRes = LoadImage(NULL, lpFile, IMAGE_ICON, 16, 16, LR_LOADFROMFILE);
        }
        else
        {
            hRes = LoadImage(NULL, lpFile, IMAGE_ICON, 32, 32, LR_LOADFROMFILE);
        }
    }

    return (NULL != hRes);
}

BOOL VerifyIcon(HWND hDlg,DWORD ctrlID,LPTSTR lpFile,DWORD iconID,BOOL issmall,LPTSTR lpDispFile)
{
    TCHAR szTemp2[MAX_PATH+1];
    TCHAR szMsg[MAX_PATH+1];
    HANDLE hRes;

    if ((lpFile[0] == TEXT('\0')) && (lpDispFile[0] != TEXT('\0')))
    {
        _tcscpy(lpFile,lpDispFile);
    }

    if (!VerifyFile(hDlg,ctrlID,lpFile,TRUE)) 
    {
        return FALSE;
    }
    else
    {
        //check for blank entry
        if (lpFile[0] == TEXT('\0'))
            return TRUE;

        if (issmall)
        {
            hRes = LoadImage(NULL,lpFile,IMAGE_ICON,16,16,LR_LOADFROMFILE);
        }
        else
        {
            hRes = LoadImage(NULL,lpFile,IMAGE_ICON,32,32,LR_LOADFROMFILE);
        }

        if (hRes == 0)
        {
            MYVERIFY(0 != LoadString(g_hInstance,IDS_INVALIDICO,szMsg,MAX_PATH));
            MYVERIFY(CELEMS(szTemp2) > (UINT)wsprintf(szTemp2,szMsg,lpFile));
            MessageBox(hDlg, szTemp2, g_szAppTitle, MB_OK);
            SetFocus(GetDlgItem(hDlg, ctrlID));
            
            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
            return FALSE;
        }
        else
        {
            SendDlgItemMessage(hDlg,iconID,STM_SETIMAGE,IMAGE_ICON,(LPARAM) hRes); //lint !e534 STM_SETIMAGE doesn't return error info
        }
        return TRUE;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  InitIconEntry
//
// Synopsis:  This function takes a resource ID of a key under the Connection Manager
//            section and retrives the value and stores it in lpFile.  It then sets the text
//            in the passed in edit control and verifies that the file exists.  Should the
//            not exist, then the string will be set to the empty string.
//
// Arguments: HWND hDlg - Window handle of the icon dialog
//            LPCTSTR pszKey - the flag string of the Icon to retrieve
//            LPTSTR lpFile - String buffer to write the icon path in
//            UINT CtrlId - Edit Control that is supposed to receive the icon string
//
// Returns:   Nothing
//
// History:   quintinb  Created Header    8/4/98
//
//+----------------------------------------------------------------------------
void InitIconEntry(HWND hDlg, LPCTSTR pszKey, LPTSTR lpFile, UINT CtrlId)
{
    //
    //  The following call to GetPrivateProfileString could return a blank string, thus don't
    //  use the MYVERIFY macro on it.
    //

    ZeroMemory(lpFile, sizeof(lpFile));
    GetPrivateProfileString(c_pszCmSection, pszKey, TEXT(""), lpFile, 
        MAX_PATH, g_szCmsFile);  //lint !e534

    //
    //  Both of the following functions will correctly handle a blank string.
    //

    MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, CtrlId), WM_SETTEXT, 0, 
        (LPARAM)GetName(lpFile)));

    MYVERIFY(FALSE != VerifyFile(hDlg, CtrlId, lpFile, FALSE));

}

//+----------------------------------------------------------------------------
//
// Function:  RefreshIconDisplay
//
// Synopsis:  This fucntion is used to refresh the icons shown on the icons page.
//            It takes a path to an Icon and tries to load it.  If the load fails
//            or if the boolean SetDefault is set, then it loads the default icon
//            specified by the Instance handle and the integer resource ID (iDefault).
//            The icon is displayed to the dwControlID passed into the function.
//
// Arguments: HWND hDlg - 
//            HINSTANCE hInstance - 
//            LPTSTR szIconFile - 
//            int iDefault - 
//            int xSize - 
//            int ySize - 
//            DWORD dwControlID - 
//            BOOL SetDefault - 
//
// Returns:   Nothing
//
// History:   quintinb Created Header    8/4/98
//            quintinb Changed Default setting to take a resource ID instead of
//                     a string.  Thus we won't have to ship the icon files.
//
//+----------------------------------------------------------------------------
void RefreshIconDisplay(HWND hDlg, HINSTANCE hInstance, LPTSTR szIconFile, int iDefault, int xSize, int ySize, DWORD dwControlID, BOOL SetDefault)
{    
    HANDLE hRes;
    
    if (SetDefault) 
    {
        hRes = NULL;
    }
    else
    {
        hRes = LoadImage(NULL, szIconFile, IMAGE_ICON, xSize, ySize, LR_LOADFROMFILE);
    }
    
    if (NULL == hRes)
    {   
        //
        // IF ICON IS NOT VALID OR WE WERE ASKED FOR THE DEFAULT, SO LOAD THE DEFAULT
        //
        
        hRes = LoadImage(hInstance, MAKEINTRESOURCE(iDefault), IMAGE_ICON, xSize, ySize, 
            LR_DEFAULTCOLOR);
    }

    if (NULL != hRes)
    {
        SendDlgItemMessage(hDlg, dwControlID, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hRes); //lint !e534 STM_SETIMAGE doesn't return error info
    }
}
//+----------------------------------------------------------------------------
//
// Function:  EnableCustomIconControls
//
// Synopsis:  Function to enable or disable all of the controls associated with
//            the custom icons.  If the bEnabled value is TRUE the controls are
//            enabled, otherwise the controls are disabled.
//
// Arguments: WND hDlg - window handle of the icon dialog
//            BOOL bEnabled - whether the controls are enabled or disabled
//
// History:   quintinb Created     11/12/99
//
//+----------------------------------------------------------------------------
void EnableCustomIconControls(HWND hDlg, BOOL bEnabled)
{
    EnableWindow(GetDlgItem(hDlg, IDC_EDITLARGE), bEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_LABEL1), bEnabled);    


    EnableWindow(GetDlgItem(hDlg, IDC_EDITSMALL), bEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_LABEL2), bEnabled);


    EnableWindow(GetDlgItem(hDlg, IDC_EDITTRAY), bEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_LABEL3), bEnabled);

    //
    //  Comment about using defaults for unspecified icons
    //
    EnableWindow(GetDlgItem(hDlg,IDC_LABEL4), bEnabled);

}

//+----------------------------------------------------------------------------
//
// Function:  ProcessIcons
//
// Synopsis:  Function that processes messages for the page in CMAK that allows
//            the user to add custom icons to their profile.
//
// Arguments: WND hDlg - window handle of the dialog
//            UINT message - message ID
//            WPARAM wParam - wParam of the message
//            LPARAM lParam - lParma of the message
//
//
// History:   quintinb Created Header    12/5/97
//            quintinb modified to handle both w16 and w32 dialogs
//            quintinb added fix for 35622, custom large icon not displaying on page load
//            quintinb removed 16 bit support 7-8-98
//            quintinb Renamed from ProcessPage5   8-6-98
//            quintinb Added EnableCustomIconControls and changed browse button
//                     behavior for consistency 367112  11-12-99
//
//+----------------------------------------------------------------------------
//  Customize icons

INT_PTR APIENTRY ProcessIcons(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szTemp[MAX_PATH+1];
    static TCHAR szDispLargeIco[MAX_PATH+1];
    static TCHAR szDispSmallIco[MAX_PATH+1];
    static TCHAR szDispTrayIco[MAX_PATH+1];
    NMHDR* pnmHeader = (NMHDR*)lParam;
    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_ICONS)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_EDITLARGE);
    SetDefaultGUIFont(hDlg,message,IDC_EDITSMALL);
    SetDefaultGUIFont(hDlg,message,IDC_EDITTRAY);

    switch (message)
    {
        case WM_INITDIALOG:
            
            SetFocus(GetDlgItem(hDlg, IDC_EDITLARGE));

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_RADIO1:
                    EnableCustomIconControls (hDlg, FALSE);

                    RefreshIconDisplay(hDlg, g_hInstance, g_szLargeIco, IDI_CM_ICON, 32, 32, IDC_ICONLARGE, TRUE);
                    RefreshIconDisplay(hDlg, g_hInstance, g_szSmallIco, IDI_CM_ICON, 16, 16, IDC_ICONSMALL, TRUE);
                    RefreshIconDisplay(hDlg, g_hInstance, g_szTrayIco, IDI_CM_ICON, 16, 16, IDC_ICONTRAY, TRUE);
                    
                    _tcscpy(szDispTrayIco,g_szTrayIco);
                    _tcscpy(szDispLargeIco,g_szLargeIco);
                    _tcscpy(szDispSmallIco,g_szSmallIco);

                    break;

                case IDC_RADIO2:
                    EnableCustomIconControls (hDlg, TRUE);
                    
                    if (!VerifyIcon(hDlg,IDC_EDITLARGE,g_szLargeIco,IDC_ICONLARGE,FALSE,szDispLargeIco)) 
                    {
                        return 1;
                    }
                    if (!VerifyIcon(hDlg,IDC_EDITSMALL,g_szSmallIco,IDC_ICONSMALL,TRUE,szDispSmallIco))
                    {
                        return 1;
                    }
                    if (!VerifyIcon(hDlg,IDC_EDITTRAY,g_szTrayIco,IDC_ICONTRAY,TRUE,szDispTrayIco))
                    {
                        return 1;
                    }
                    break;

                case IDC_EDITLARGE:
                    if (HIWORD(wParam) == EN_KILLFOCUS)
                    {                        
                        BOOL bIconUpdated = UpdateIcon(hDlg, IDC_EDITLARGE, g_szLargeIco, FALSE);
                        
                        //
                        //  If icon wasn't updated than load the defaults
                        //

                        RefreshIconDisplay(hDlg, g_hInstance, g_szLargeIco, IDI_CM_ICON, 32, 32, IDC_ICONLARGE, !bIconUpdated);

                        return TRUE;
                    }   
                    break;

                case IDC_EDITSMALL:
                    if (HIWORD(wParam) == EN_KILLFOCUS)
                    {
                        BOOL bIconUpdated = UpdateIcon(hDlg,IDC_EDITSMALL,g_szSmallIco,TRUE);
                        
                        //
                        //  If icon wasn't updated than load the defaults
                        //

                        RefreshIconDisplay(hDlg, g_hInstance, g_szSmallIco, IDI_CM_ICON, 16, 16, IDC_ICONSMALL, !bIconUpdated);
                        
                        return TRUE;
                    }
                    break;

                case IDC_EDITTRAY:
                    
                    if (HIWORD(wParam) == EN_KILLFOCUS)
                    {
                        BOOL bIconUpdated = UpdateIcon(hDlg,IDC_EDITTRAY,g_szTrayIco,TRUE);

                        //
                        //  If icon wasn't updated than load the defaults
                        //

                        RefreshIconDisplay(hDlg, g_hInstance, g_szTrayIco, IDI_CM_ICON, 16, 16, IDC_ICONTRAY, !bIconUpdated);
                        
                        return TRUE;
                    }
                    break;

                case IDC_BROWSE1:
                    {
                        UINT uFilter = IDS_ICOFILTER;
                        TCHAR* szMask = TEXT("*.ico");
                        MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2));
                        EnableCustomIconControls (hDlg, TRUE);

                        if (DoBrowse(hDlg, &uFilter, &szMask, 1, IDC_EDITLARGE, TEXT("ico"), g_szLargeIco))
                        {
                            RefreshIconDisplay(hDlg, g_hInstance, g_szLargeIco, IDI_CM_ICON, 32, 32, IDC_ICONLARGE, FALSE);
                        }
                    }

                    break;

                case IDC_BROWSE2:
                    {
                        UINT uFilter = IDS_ICOFILTER;
                        TCHAR* szMask = TEXT("*.ico");
                        MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2));
                        EnableCustomIconControls (hDlg, TRUE);

                        if (DoBrowse(hDlg, &uFilter, &szMask, 1, IDC_EDITSMALL, TEXT("ico"), g_szSmallIco))
                        {
                            RefreshIconDisplay(hDlg, g_hInstance, g_szSmallIco, IDI_CM_ICON, 16, 16, IDC_ICONSMALL, FALSE);
                        }
                    }

                    break;

                case IDC_BROWSE3:
                    {
                        UINT uFilter = IDS_ICOFILTER;
                        TCHAR* szMask = TEXT("*.ico");
                        MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2));
                        EnableCustomIconControls (hDlg, TRUE);

                        if (DoBrowse(hDlg, &uFilter, &szMask, 1, IDC_EDITTRAY, TEXT("ico"), g_szTrayIco))
                        {
                            RefreshIconDisplay(hDlg, g_hInstance, g_szTrayIco, IDI_CM_ICON, 16, 16, IDC_ICONTRAY, FALSE);
                        }
                    }

                    break;

                default:
                    break;
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));
                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));
                    
                    InitIconEntry(hDlg, c_pszCmEntryBigIcon, g_szLargeIco, IDC_EDITLARGE);                    
                    InitIconEntry(hDlg, c_pszCmEntrySmallIcon, g_szSmallIco, IDC_EDITSMALL);
                    InitIconEntry(hDlg, c_pszCmEntryTrayIcon, g_szTrayIco, IDC_EDITTRAY);
                    
                    if ((g_szTrayIco[0] == TEXT('\0'))&&(g_szLargeIco[0] == TEXT('\0'))&&(g_szSmallIco[0] == TEXT('\0')))
                    {
                        MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1));
                        EnableCustomIconControls (hDlg, FALSE);

                        MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDITLARGE), WM_SETTEXT, 0, (LPARAM)GetName(szDispLargeIco)));
                    
                        MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDITSMALL), WM_SETTEXT, 0, (LPARAM)GetName(szDispSmallIco)));

                        MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDITTRAY), WM_SETTEXT, 0, (LPARAM)GetName(szDispTrayIco)));                        

                    }
                    else
                    {
                        MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2));
                        EnableCustomIconControls (hDlg, TRUE);
                    }

                    RefreshIconDisplay(hDlg, g_hInstance, g_szLargeIco, IDI_CM_ICON, 32, 32, IDC_ICONLARGE, FALSE);
                    RefreshIconDisplay(hDlg, g_hInstance, g_szSmallIco, IDI_CM_ICON, 16, 16, IDC_ICONSMALL, FALSE);
                    RefreshIconDisplay(hDlg, g_hInstance, g_szTrayIco, IDI_CM_ICON, 16, 16, IDC_ICONTRAY, FALSE);

                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    
                    if (IsDlgButtonChecked(hDlg, IDC_RADIO1)!=BST_CHECKED) 
                    {
                        if (!VerifyIcon(hDlg,IDC_EDITLARGE,g_szLargeIco,IDC_ICONLARGE,FALSE,TEXT(""))) 
                        {
                            return 1;
                        }
                        if (!VerifyIcon(hDlg,IDC_EDITSMALL,g_szSmallIco,IDC_ICONSMALL,TRUE,TEXT("")))
                        {
                            return 1;
                        }
                        if (!VerifyIcon(hDlg,IDC_EDITTRAY,g_szTrayIco,IDC_ICONTRAY,TRUE,TEXT("")))
                        {
                            return 1;
                        }
                    }
                    else
                    {

                        g_szTrayIco[0] = TEXT('\0');
                        g_szLargeIco[0] = TEXT('\0');
                        g_szSmallIco[0] = TEXT('\0');
                    }

                    // USE ICON IN CM AS ICON FOR DESKTOP IF NOT LARGE ICON SPECIFIED
                    if (TEXT('\0') != g_szLargeIco[0])
                    {
                        // SPECIFY ICON NAME FOR THE DESKTOP
                        GetFileName(g_szLargeIco,szTemp);
                        QS_WritePrivateProfileString(c_pszInfSectionStrings, c_pszDesktopIcon, szTemp, g_szInfFile);
                    }

                    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryBigIcon, g_szLargeIco, g_szCmsFile));
                    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryTrayIcon, g_szTrayIco, g_szCmsFile));
                    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntrySmallIcon, g_szSmallIco, g_szCmsFile));
                    
                    //
                    //  By calling WritePrivateProfileString with all NULL's we flush the file cache 
                    //  (win95 only).  This call will return 0.
                    //
                    WritePrivateProfileString(NULL, NULL, NULL, g_szCmsFile); //lint !e534 this call will always return 0
                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessPhoneBook
//
// Synopsis:  Setup the phone book
//
//
// History:     quintinb hid pbr browse button and edit control.  Rewrote pbr/pbk logic for bug 
//                  fix 14188 on 9-9-97
//              quintinb added VerifyFileFormat check on .pbk file for bug fix 28416
//              quintinb (11-18-97 29954) removed hidden pbr button and edit control from the dialog.  Removed
//                  old verification code.  Updated code to remove references to IDC_EDITREGION.
//              quintinb (7-2-98)   removed verifyfileformat call mentioned above because cm16 was pulled
//              quintinb (8-6-98)   Renamed from ProcessPage6
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessPhoneBook(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szMsg[2*MAX_PATH+1];
    TCHAR* pzTmp;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    static TCHAR szMorePhone[MAX_PATH+1];
    NMHDR* pnmHeader = (NMHDR*)lParam;


    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_PHONEBK)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_EDITPHONE);
    SetDefaultGUIFont(hDlg,message,IDC_EDIT1);

    switch (message)
    {
        case WM_INITDIALOG:
            SetFocus(GetDlgItem(hDlg, IDC_EDITPHONE));
            SendDlgItemMessage(hDlg, IDC_EDIT1, EM_SETLIMITTEXT, (WPARAM)MAX_PATH, (LPARAM)0); //lint !e534 EM_SETLIMITTEXT doesn't return anything useful

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {

                case IDC_BROWSE1:
                    {
                        UINT uFilter = IDS_PBKFILTER;
                        TCHAR* szMask = TEXT("*.pbk");

                        MYVERIFY(0 != DoBrowse(hDlg,  &uFilter, &szMask, 1,
                            IDC_EDITPHONE, c_pszPbk, g_szPhonebk));
                    }

                    break;

                case IDC_CHECK1:

                    g_bUpdatePhonebook = IsDlgButtonChecked(hDlg,IDC_CHECK1);
                    
                    if (g_bUpdatePhonebook)
                    {
                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmakStatus, c_pszUpdatePhonebook, c_pszOne, g_szInfFile));
                    }
                    else
                    {
                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmakStatus, c_pszUpdatePhonebook, c_pszZero, g_szInfFile));
                    }

                    break;

                default:
                    break;
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));
                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:

                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));
                    
                    //
                    //  The following two calls to GetPrivateProfileString could return blank 
                    //  strings, thus we won't check the return with the MYVERIFY macro.
                    //

                    ZeroMemory(szMorePhone, sizeof(szMorePhone));
                    GetPrivateProfileString(c_pszCmSection, c_pszCmEntryPbMessage, TEXT(""), 
                        szMorePhone, CELEMS(szMorePhone), g_szCmsFile);    //lint !e534
                    MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDIT1), WM_SETTEXT, 0, 
                        (LPARAM)szMorePhone));

                    ZeroMemory(g_szPhonebk, sizeof(g_szPhonebk));
                    
                    GetPrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspPbFile, TEXT(""), 
                        g_szPhonebk, CELEMS(g_szPhonebk), g_szCmsFile); //lint !e534            
                    
                    MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDITPHONE), WM_SETTEXT, 0, 
                        (LPARAM)GetName(g_szPhonebk)));
                    
                    //
                    //  The following call will handle a blank g_szPhonebk by returning FALSE and setting
                    //  the control on the dialog to blank.  Don't use MYVERIFY.
                    //

                    VerifyPhonebk(hDlg, IDC_EDITPHONE, g_szPhonebk);    //lint !e534

                    MYVERIFY(0 != GetPrivateProfileString(c_pszCmakStatus, c_pszUpdatePhonebook, 
                        c_pszOne, szTemp, CELEMS(szTemp), g_szInfFile));

                    if (TEXT('1') == szTemp[0])
                    {
                        g_bUpdatePhonebook = TRUE;
                        MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK1, TRUE));
                    }
                    else
                    {
                        g_bUpdatePhonebook = FALSE;
                        MYVERIFY(0 != CheckDlgButton(hDlg, IDC_CHECK1, FALSE));
                    }

                    break;

                case PSN_WIZBACK:

                    // fall through for further processing

                case PSN_WIZNEXT:
                                
                    //
                    // quintinb, 9-9-97 for bug fix 14188
                    // cases:   use browse button: both up to date, shortname(g_szPhonebk) == szTemp
                    //          type unc into edit control:  szTemp up to date, g_szPhonebk = szTemp must be done
                    //          type filename into edit control:  szTemp up to date, g_szPhonebk = getcurrentdir + \\ + szTemp must be done
                    //          unc left over from previous, both same
                    //
                    
                    //
                    // get text in the edit control and put in szTemp
                    //
                    if (-1 == GetTextFromControl(hDlg, IDC_EDITPHONE, szTemp, MAX_PATH, TRUE)) // bDisplayError == TRUE
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_EDITPHONE));
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                        return 1;
                    }
                    
                    //
                    // first get szTemp and g_szPhonebk consistent
                    //
                    
                    if (szTemp[0] != TEXT('\0'))
                    {                   
                        //
                        // if in here then we know that we have some text to work with
                        // first test if the two strings are exactly equal or the shortname of g_szPhonebk 
                        // equals szTemp
                        //

                        if (0 != _tcscmp(szTemp, g_szPhonebk)) 
                        {
                            if (0 != _tcscmp(szTemp, GetName(g_szPhonebk)))
                            {
                                //
                                // if not then g_szPhonebk and szTemp are out of sync, must update g_szPhonebk
                                // szTemp contains a backslash so it is probably a full path
                                //
                                if ( _tcsstr(szTemp, TEXT("\\")) )
                                {
                                    // probably contains a unc
                                    _tcscpy(g_szPhonebk, szTemp);
                                } 
                                else 
                                {
                                    // use GetFullPathName to return a name
                                    MYVERIFY(0 != GetFullPathName(szTemp, MAX_PATH, g_szPhonebk, &pzTmp));
                                }
                            }
                        }

                        //
                        // Okay, check that we can open the file now. We need 
                        // to change the current dir to the cmak dir since 
                        // g_szPhonebk can be a relative path from a CMS file
                        //

                        MYVERIFY(0 != GetCurrentDirectory(MAX_PATH+1, szTemp));
                        MYVERIFY(0 != SetCurrentDirectory(g_szOsdir));

                        hFile = CreateFile(g_szPhonebk,GENERIC_READ,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);

                        //
                        // Restore the cur dir
                        //

                        MYVERIFY(0 != SetCurrentDirectory(szTemp));
                        
                        if (INVALID_HANDLE_VALUE == hFile)
                        {
                            // then we have an error and have exhausted our possibilities
                            //

                            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_BADOUTEXE, MB_OK));
                            
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }

                        MYVERIFY(0 != CloseHandle(hFile));

                        //
                        // if we got here then everything is sync-ed, make sure that the file is a pbk file
                        //
                        pzTmp = g_szPhonebk + _tcslen(g_szPhonebk) - _tcslen(c_pszPbk);
                        if (_tcsicmp(pzTmp, c_pszPbk) != 0)
                        {
                            MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOTPBK, MB_OK));
                            
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }

                        //
                        // now update the pbr file entry
                        //
                        _tcscpy(g_szRegion, g_szPhonebk);
                        pzTmp = g_szRegion + _tcslen(g_szPhonebk) - _tcslen(c_pszPbk);
                        _tcscpy(pzTmp, TEXT("pbr"));
                        // removed for 29954
                        //SendMessage(GetDlgItem(hDlg, IDC_EDITREGION), WM_SETTEXT, 0, (LPARAM)GetName(g_szRegion));
                        
                        //
                        // Now open the pbr file to see that it exists. We need
                        // to change the current dir to the cmak dir since 
                        // g_szPhonebk can be a relative path from a CMS file.
                        //

                        MYVERIFY(0 != GetCurrentDirectory(MAX_PATH+1, szTemp));
                        MYVERIFY(0 != SetCurrentDirectory(g_szOsdir));

                        hFile = CreateFile(g_szRegion,GENERIC_READ,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);

                        //
                        // Restore the current directory
                        //

                        MYVERIFY(0 != SetCurrentDirectory(szTemp));
                        
                        if (INVALID_HANDLE_VALUE == hFile)
                        {
                            //
                            // then we can't find the pbr file
                            //
                            MYVERIFY(0 != LoadString(g_hInstance,IDS_NEEDSPBR,szTemp,MAX_PATH));
                            MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szTemp, GetName(g_szRegion), g_szPhonebk, GetName(g_szRegion)));
                            MessageBox(hDlg, szMsg, g_szAppTitle, MB_OK);
                            SetFocus(GetDlgItem(hDlg, IDC_EDITPHONE));
                            
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }
                        MYVERIFY(0 != CloseHandle(hFile));

                    } 
                    else 
                    {
                        //
                        // just in case user wants to clear out the phonebk edit control
                        //
                        g_szPhonebk[0] = TEXT('\0');
                        g_szRegion[0] = TEXT('\0');

                    }

                    // end bugfix for 14188

                    if (g_bUpdatePhonebook)
                    {
                        GetFileName(g_szPhonebk, szTemp);

                        if (FALSE == IsFile8dot3(szTemp))
                        {
                            LPTSTR pszMsg = CmFmtMsg(g_hInstance, IDS_BADPBNAME, szTemp);

                            if (pszMsg)
                            {
                                MessageBox(hDlg, pszMsg, g_szAppTitle, MB_OK);
                                CmFree(pszMsg);
                            }
                            
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }
                    }
                    // end of changes for 28416
                    if (-1 == GetTextFromControl(hDlg, IDC_EDIT1, szTemp, MAX_PATH, TRUE)) // bDisplayError == TRUE
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                        return 1;
                    }
                    
                    CmStrTrim(szTemp);
                    MYVERIFY(TRUE == SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)0, (LPARAM) szTemp));
                    _tcscpy(szMorePhone,szTemp);
                    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryPbMessage, szMorePhone, g_szCmsFile));
                    
                    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspPbFile, g_szPhonebk, g_szCmsFile));
                    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspRegionFile, g_szRegion, g_szCmsFile));


                    if (pnmHeader && (PSN_WIZBACK == pnmHeader->code)) 
                    {
                        if (g_bUseTunneling)
                        {
                            //
                            //  If we are going back, skip the Pre-shared key page if
                            //  no DUN entries have Preshared key enabled.
                            //
                            //  Note: g_bPresharedKeyNeeded should be current here, no need
                            //        to call DoesSomeVPNsettingUsePresharedKey()
                            //
                            if (!g_bPresharedKeyNeeded)
                            {
                                MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, IDD_VPN_ENTRIES));
                            }
                        }
                        else
                        {
                            //
                            //  If we are going back, skip the VPN entries dialog if we don't have any tunneling enabled.
                            //
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, IDD_TUNNELING));
                        }
                    }

                    //
                    //  If we are going forward, skip the phonebook update page unless we are doing the PB download
                    //
                    if (pnmHeader && (PSN_WIZNEXT == pnmHeader->code) && !g_bUpdatePhonebook)
                    {
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, IDD_DUN_ENTRIES));
                    }
                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessPhoneBookUpdate
//
// Synopsis:  Specify Phone Book Files and Updates
//
//
// History:   Created Header    8/6/98
//            quintinb  Renamed from ProcessPage6A  8/6/98
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessPhoneBookUpdate(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{

    TCHAR szTemp[MAX_PATH+1];
    int j, iLen;
    LPTSTR pUrl,pch;
    BOOL showerr;
    NMHDR* pnmHeader = (NMHDR*)lParam;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_PHONEBK)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_EDIT1);
    SetDefaultGUIFont(hDlg,message,IDC_EDITURL);

    switch (message)
    {
        case WM_INITDIALOG:

            SendDlgItemMessage(hDlg, IDC_EDITURL, EM_SETLIMITTEXT, (WPARAM)(MAX_PATH - 50), (LPARAM)0);//lint !e534 EM_SETLIMITTEXT doesn't return anything useful

            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));
                    
                    //
                    //  The following two calls to GetPrivateProfileString could return an empty
                    //  string.  We shouldn't use MYVERIFY on the return code.
                    //
                    ZeroMemory(g_szPhoneName, sizeof(g_szPhoneName));
                    ZeroMemory(g_szUrl,sizeof(g_szUrl));

                    GetPrivateProfileString(c_pszCmakStatus, c_pszPhoneName, TEXT(""), 
                        g_szPhoneName, CELEMS(g_szPhoneName), g_szInfFile);  //lint !e534
                    
                    GetPrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspUrl, TEXT(""), g_szUrl, 
                        CELEMS(g_szUrl), g_szCmsFile);   //lint !e534
                                        
                    // skip past initial http://
                    if (*g_szUrl)
                    {
                        pUrl = _tcsstr(g_szUrl, c_pszCpsUrl);
                        if (pUrl)
                        {
                            *pUrl = 0; //chop off dll filename
                        }

                        MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDITURL), WM_SETTEXT, 0, (LPARAM)&g_szUrl[7]));

                    }
                    else
                    {
                        MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDITURL), WM_SETTEXT, 0, (LPARAM)TEXT("")));
                    }

                    if (*g_szPhonebk)
                    {
                        GetBaseName(g_szPhonebk,szTemp);
                        MYVERIFY(TRUE == SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)0, (LPARAM) szTemp));
                        EnableWindow(GetDlgItem(hDlg,IDC_EDIT1),FALSE);
                    }
                    else
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), TRUE);
                        if (*g_szPhoneName)
                        {
                            MYVERIFY(TRUE == SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)0, (LPARAM) g_szPhoneName));
                        }
                        else
                        {
                            MYVERIFY(TRUE == SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)0, (LPARAM) TEXT("")));
                        }
                    }

                    break;

                case PSN_WIZBACK:

                case PSN_WIZNEXT:

                    showerr = (pnmHeader && (PSN_WIZNEXT == pnmHeader->code));

                    if (-1 == GetTextFromControl(hDlg, IDC_EDIT1, g_szPhoneName, MAX_PATH, TRUE)) // bDisplayError == TRUE
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                        return 1;
                    }

//                  if ((g_szPhoneName[0] == TEXT('\0')) && (g_pHeadMerge == NULL) && showerr) - 20094
                    if ((g_szPhoneName[0] == TEXT('\0')) && showerr)
                    {
                        MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NEEDPHONENAME, MB_OK));
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                        
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                        return 1;
                    }

                    iLen = lstrlen(g_szBadFilenameChars); 
                    pch = g_szPhoneName;
                    while(*pch != _T('\0'))
                    {
                        for (j = 0; j < iLen; ++j)
                        {
                            if ((*pch == g_szBadFilenameChars[j]) && showerr)
                            {
                                LPTSTR pszMsg = CmFmtMsg(g_hInstance, IDS_PHONENAMEERR, g_szBadFilenameChars);

                                if (pszMsg)
                                {
                                    MessageBox(hDlg, pszMsg, g_szAppTitle, MB_OK);
                                    CmFree(pszMsg);
                                }

                                SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                                
                                MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                                return 1;
                            }
                        }
                        pch = CharNext(pch);
                    }

                    //
                    //  Note that 8.3 means 8 bytes not 8 Characters.  Thus we have a limit of 4 DBCS
                    //  characters.
                    //
#ifdef UNICODE
                    LPSTR pszAnsiPhoneName;

                    pszAnsiPhoneName = WzToSzWithAlloc(g_szPhoneName);

                    if ((lstrlenA(pszAnsiPhoneName) > 8) && showerr)
#else
                    if ((strlen(g_szPhoneName) > 8) && showerr)
#endif
                    {
                        LPTSTR pszMsg = CmFmtMsg(g_hInstance, IDS_PHONENAMEERR, g_szBadFilenameChars);

                        if (pszMsg)
                        {
                            MessageBox(hDlg, pszMsg, g_szAppTitle, MB_OK);
                            CmFree(pszMsg);
                        }

                        SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                        
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                        return 1;
                    }

#ifdef UNICODE
                    CmFree(pszAnsiPhoneName);
#endif

                    if (-1 == GetTextFromControl(hDlg, IDC_EDITURL, szTemp, MAX_PATH, TRUE)) // bDisplayError == TRUE
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_EDITURL));
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                        return 1;
                    }

                    if (szTemp[0] != TEXT('\0'))
                    {
                        MYVERIFY(CELEMS(g_szUrl) > (UINT)wsprintf(g_szUrl, TEXT("http://%s%s"), szTemp, c_pszCpsUrl));
                    }
                    else
                    {
                        g_szUrl[0] = TEXT('\0');
                    }
                    
                    if ((g_szUrl[0] == TEXT('\0')) && showerr)
                    {
                        MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOURL, MB_OK));

                        SetFocus(GetDlgItem(hDlg, IDC_EDITURL));
                        
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                        return 1;
                    }
                    
                    MYVERIFY(0 != WritePrivateProfileString(c_pszCmakStatus, c_pszPhoneName, g_szPhoneName, g_szInfFile));

                    if (TEXT('\0') != g_szUrl[0]) 
                    {
                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionIsp,c_pszCmEntryIspUrl,g_szUrl,g_szCmsFile));
                    }
                    else
                    {
                        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionIsp,c_pszCmEntryIspUrl,TEXT(""),g_szCmsFile));
                    }

                    // the Next button was pressed or the back button was pressed
                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

//+----------------------------------------------------------------------------
//
// Function:  RemoveReferencesFromCMS
//
// Synopsis:    This function searches for any previous References line in
//              the ISP section of the cms file.  If it finds a References
//              line, then it parses it to find what other profiles are
//              mentioned in the CMS.  Then it will search for and remove
//              any of the following lines in the ISP section that correspond
//              to these references:
//                  CMSFile&test2=test3\test2.cms
//                  FilterA&test2=NosurchargeSignon
//                  FilterB&test2=SurchargeSignon
// 
// note the function removes the reference line itself too.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb  created for bug fix 10537   8/28/97
//
//+----------------------------------------------------------------------------
void RemoveReferencesFromCMS()
{
    TCHAR szKey[MAX_PATH+1];
    TCHAR szReferences[MAX_PATH+1];
    TCHAR* pszToken;
    DWORD dwNumChars;

    dwNumChars = GetPrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspReferences, TEXT(""), 
        szReferences,MAX_PATH, g_szCmsFile);

    if ((dwNumChars >0) && (TEXT('\0') != szReferences[0]))
    {
        // I have references, so we must parse them out and delete them
        
        pszToken = _tcstok( szReferences, TEXT(" "));   
        while( pszToken != NULL )
        {
            MYVERIFY(CELEMS(szKey) > (UINT)wsprintf(szKey, TEXT("%s%s"), 
                c_pszCmEntryIspCmsFile, pszToken));
            MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionIsp, szKey, NULL, 
                g_szCmsFile));

            MYVERIFY(CELEMS(szKey) > (UINT)wsprintf(szKey, TEXT("%s%s"), 
                c_pszCmEntryIspFilterA, pszToken));
            MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionIsp, szKey, NULL, 
                g_szCmsFile));
            
            MYVERIFY(CELEMS(szKey) > (UINT)wsprintf(szKey, TEXT("%s%s"), 
                c_pszCmEntryIspFilterB, pszToken));
            MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionIsp, szKey, NULL, 
                g_szCmsFile));

            pszToken = _tcstok( NULL, TEXT(" ") );   
        }
        // after deleting the individual keys, must delete the references line itself
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspReferences, NULL, g_szCmsFile));
        
    }

}

//+----------------------------------------------------------------------------
//
// Function:  RefreshDualingListBoxes
//
// Synopsis:  This function refreshes two listboxes from the given two linked
//            lists.  The destination listbox is filled from the destination
//            linked list and then the source listbox is filled with all of the
//            items in the source linked list that don't appear in the destination
//            linked list and that aren't the name of the current profile to edit.
//            Thus you effectively have one list where the items either show up
//            in the source listbox or the destination listbox.  Please note that
//            there is one exception with the merged profile lists that this
//            code was created for (items can exist in the merged list that we
//            don't have profile source from, see the Delete/Remove code in
//            ProcessMergedProfiles for more details).  Also note that we
//            enable/disable the corresponding Add and Remove buttons depending
//            on the state of the lists.
// 
//
// Arguments: HWND hDlg - window handle of the dialog containing all of the controls
//            UINT uSourceListControlId - control id of the source listbox
//            UINT uDestListControlId - control id of the dest listbox
//            ListBxList* pSourceList - linked list to fill the source listbox from
//            ListBxList* pDestList - linked list to fill the dest listbox from
//            LPCTSTR pszShortName - short service name of the current profile
//            UINT uAddCtrlId - control id of the Add button (add from source to dest)
//            UINT uRemoveCtrlId - control id of the remove button (remove from dest to source)
//
// Returns:   BOOL - TRUE if successful
//
// History:   quintinb  created     03/09/00
//
//+----------------------------------------------------------------------------
BOOL RefreshDualingListBoxes(HWND hDlg, UINT uSourceListControlId, UINT uDestListControlId, ListBxList* pSourceList, ListBxList* pDestList, LPCTSTR pszShortName, UINT uAddCtrlId, UINT uRemoveCtrlId)
{
    if ((NULL == hDlg) || (0 == uSourceListControlId) || (0 == uDestListControlId))
    {
        CMASSERTMSG(FALSE, TEXT("RefreshDualingListBoxes -- Invalid argument passed"));
        return FALSE;
    }

    //
    //  Reset both of the listboxes
    //
    LRESULT lResult = SendDlgItemMessage(hDlg, uSourceListControlId, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0);

    MYDBGASSERT(LB_ERR != lResult);

    lResult = SendDlgItemMessage(hDlg, uDestListControlId, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0);

    MYDBGASSERT(LB_ERR != lResult);


    //
    //  Add the destination items to the destination listbox
    //
    ListBxList* pCurrent = pDestList;

    while (pCurrent)
    {
        lResult = SendDlgItemMessage(hDlg, uDestListControlId, LB_ADDSTRING, (WPARAM)0, (LPARAM)pCurrent->szName);

        MYDBGASSERT(LB_ERR != lResult);

        pCurrent = pCurrent->next;
    }

    //
    //  Add the source items to the source listbox, making sure to filter out items that are already
    //  in the destination list
    //
    pCurrent = pSourceList;

    while (pCurrent)
    {
        if ((FALSE == FindListItemByName(pCurrent->szName, pDestList, NULL)) && (0 != lstrcmpi(pCurrent->szName, pszShortName)))
        {
            lResult = SendDlgItemMessage(hDlg, uSourceListControlId, LB_ADDSTRING, (WPARAM)0, (LPARAM)pCurrent->szName);

            MYDBGASSERT(LB_ERR != lResult);
        }

        pCurrent = pCurrent->next;
    }
    
    //
    //  Now that we have refreshed the list, we need to update the button and selection status.
    //  If the source list is empty, then we cannot do any Adds.  On the other
    //  hand if the dest list is empty, then we cannot do any deletes.
    //

    HWND hAddControl = GetDlgItem(hDlg, uAddCtrlId);
    HWND hRemoveControl = GetDlgItem(hDlg, uRemoveCtrlId);
    HWND hCurrentFocus = GetFocus();

    lResult = SendDlgItemMessage(hDlg, uSourceListControlId, LB_GETCOUNT, 0, (LPARAM)0);

    BOOL bListNotEmpty = ((LB_ERR != lResult) && (0 != lResult));

    EnableWindow(hAddControl, bListNotEmpty);

    if (bListNotEmpty)
    {
        MYVERIFY(LB_ERR != SendDlgItemMessage(hDlg, uSourceListControlId, LB_SETCURSEL, 0, (LPARAM)0));
    }

    //
    //  Now check the destination list and the Remove button
    //
    lResult = SendDlgItemMessage(hDlg, uDestListControlId, LB_GETCOUNT, 0, (LPARAM)0);

    bListNotEmpty = ((LB_ERR != lResult) && (0 != lResult));

    EnableWindow(hRemoveControl, bListNotEmpty);

    if (bListNotEmpty)
    {
        MYVERIFY(LB_ERR != SendDlgItemMessage(hDlg, uDestListControlId, LB_SETCURSEL, 0, (LPARAM)0));
    }

    //
    //  Figure out if we need to shift the focus because we just disabled the control that had it.
    //
    if (FALSE == IsWindowEnabled(hCurrentFocus))
    {
        if ((hAddControl == hCurrentFocus) && IsWindowEnabled(hRemoveControl))
        {
            SendMessage(hDlg, DM_SETDEFID, uRemoveCtrlId, (LPARAM)0L); //lint !e534 DM_SETDEFID doesn't return error info
            SetFocus(hRemoveControl);
        }
        else if ((hRemoveControl == hCurrentFocus) && IsWindowEnabled(hAddControl))
        {
            SendMessage(hDlg, DM_SETDEFID, uAddCtrlId, (LPARAM)0L); //lint !e534 DM_SETDEFID doesn't return error info
            SetFocus(hAddControl);        
        }
        else
        {
            SetFocus(GetDlgItem(hDlg, uSourceListControlId));
        }    
    }

    return TRUE;
}

void OnProcessMergedProfilesAdd(HWND hDlg)
{
    TCHAR szTemp[MAX_PATH+1];
    LRESULT lResult;

    //
    //  Get the current selection from the listbox containing the items
    //  to merge.
    //
    lResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETCURSEL, 0, (LPARAM)0);

    if (lResult != LB_ERR)
    {
        lResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETTEXT, 
                                     (WPARAM)lResult, (LPARAM)szTemp);

        if (lResult != LB_ERR)
        {
            MYVERIFY(FALSE != createListBxRecord(&g_pHeadMerge, &g_pTailMerge, NULL, 0, szTemp));

            MYVERIFY(RefreshDualingListBoxes(hDlg, IDC_LIST1, IDC_LIST2, g_pHeadProfile, 
                                             g_pHeadMerge, g_szShortServiceName, IDC_BUTTON1, IDC_BUTTON2));
        }
    }
}

void OnProcessMergedProfilesRemove(HWND hDlg)
{
    TCHAR szTemp[MAX_PATH+1];
    LRESULT lResult;
    //
    //  Get the listbox selection from the already merged in list
    //
    lResult = SendDlgItemMessage(hDlg, IDC_LIST2, LB_GETCURSEL, 0, (LPARAM)0);
    
    if (LB_ERR == lResult)
    {
        MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOSELECTION, MB_OK));
    }
    else
    {
        //
        //  Get the name of the profile to remove from the merge list
        //
        lResult = SendDlgItemMessage(hDlg, IDC_LIST2, LB_GETTEXT, (WPARAM)lResult, (LPARAM)szTemp);
    
        if (LB_ERR != lResult)
        {
            //
            //  Check to see if this is an item in the Profile list.  If not, the user
            //  will not be able to add it back.
            //
            int iReturnValue = IDYES;

            if (FALSE == FindListItemByName(szTemp, g_pHeadProfile, NULL)) // NULL because we don't need a pointer to the list item returned
            {
                LPTSTR pszMsg = CmFmtMsg(g_hInstance, IDS_NOTINPROFILELIST, szTemp, szTemp, szTemp);

                if (pszMsg)
                {
                    iReturnValue = MessageBox(hDlg, pszMsg, g_szAppTitle, MB_YESNO);
                    CmFree(pszMsg);
                }
            }

            if (IDYES == iReturnValue)
            {
                //
                //  Delete it from the merged profile linked list
                //
                DeleteListBxRecord(&g_pHeadMerge, &g_pTailMerge, szTemp);
    
                //
                //  Remove it from the UI
                //
                MYVERIFY(RefreshDualingListBoxes(hDlg, IDC_LIST1, IDC_LIST2, g_pHeadProfile, 
                                                 g_pHeadMerge, g_szShortServiceName, IDC_BUTTON1, IDC_BUTTON2));
            }
        }
    }
}
//+----------------------------------------------------------------------------
//
// Function:  ProcessMergedProfiles
//
// Synopsis:  Merge Profiles
//
// History:   quintinb  Created Header and renamed from ProcessPage6B   8/6/98
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessMergedProfiles(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    NMHDR* pnmHeader = (NMHDR*)lParam;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_MERGE)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_LIST1);
    SetDefaultGUIFont(hDlg,message,IDC_LIST2);

    switch (message)
    {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_BUTTON1: //add
                    OnProcessMergedProfilesAdd(hDlg);
                    return TRUE;

                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case IDC_BUTTON2: //remove
                    OnProcessMergedProfilesRemove(hDlg);
                    return TRUE;
                    
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed
                case IDC_LIST1:
                    if (LBN_DBLCLK == HIWORD(wParam))
                    {
                        OnProcessMergedProfilesAdd(hDlg);
                        return TRUE;                    
                    }

                    break;

                case IDC_LIST2:
                    if (LBN_DBLCLK == HIWORD(wParam))
                    {
                        OnProcessMergedProfilesRemove(hDlg);
                        return TRUE;                    
                    }
                    
                    break;
                    
                default:
                    break;
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));
                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));

                    //
                    //  First lets setup the list of profiles that are actually merged into the
                    //  profile.  First step is to read in the merged profile list from the profile.
                    //

                    ReadMergeList();

                    //
                    //  Now delete the merged profile list and any filter/cms references from the profile.
                    //
                    RemoveReferencesFromCMS();

                    //
                    //  Refresh the two list boxes
                    //
                    MYVERIFY(RefreshDualingListBoxes(hDlg, IDC_LIST1, IDC_LIST2, g_pHeadProfile, 
                                                     g_pHeadMerge, g_szShortServiceName, IDC_BUTTON1, IDC_BUTTON2));

                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    WriteMergeList();
                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

BOOL CreateMergedProfile()
{
    ListBxList * LoopPtr;
    TCHAR szReferences[MAX_PATH+1];
    LPTSTR pszName;
    TCHAR szEntry[MAX_PATH+1];
    TCHAR szFile[MAX_PATH+1];
    TCHAR szKey[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szDest[MAX_PATH+1];

    szReferences[0] = TEXT('\0');

    if (g_pHeadMerge == NULL)
    {
        return TRUE;
    }
    LoopPtr = g_pHeadMerge;

    while( LoopPtr != NULL)
    {
        pszName = LoopPtr->szName;

        _tcscat(szReferences, pszName);
        _tcscat(szReferences, TEXT(" "));
        MYDBGASSERT(_tcslen(szReferences) <= CELEMS(szReferences));

        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s%s\\%s.cms"), g_szOsdir, pszName, pszName));

        MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s\\%s.cms"), g_szOutdir, pszName));

        // COPY CMS FILE
        
        //
        //  First check to see if the profile exists in profile directory
        //

        if (!FileExists(szTemp)) 
        {
            //
            //  Couldn't open it in the profile dir, lets try in the temp dir
            //
            
            if (!FileExists(szDest))
            {
                FileAccessErr(NULL, szDest);
                return FALSE;
            }
        }
        else
        {
            if (!CopyFileWrapper(szTemp, szDest, FALSE))
            {
                return FALSE;
            }
        }
        
        MYVERIFY(0 != SetFileAttributes(szDest,FILE_ATTRIBUTE_NORMAL));

        MYVERIFY(FALSE != MoveCmsFile(szDest, g_szShortServiceName));
        
        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s.cms"), pszName));
        MYVERIFY(FALSE != createListBxRecord(&g_pHeadRefs,&g_pTailRefs,(void *)NULL,0,szTemp));

        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s.cms"), g_szShortServiceName, pszName));
        MYVERIFY(CELEMS(szKey) > (UINT)wsprintf(szKey, TEXT("%s%s"), c_pszCmEntryIspCmsFile, pszName));

        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionIsp,szKey,szTemp,g_szCmsFile));

        MYVERIFY(CELEMS(szKey) > (UINT)wsprintf(szKey, TEXT("%s%s"), c_pszCmEntryIspFilterA, 
            pszName));

        // only write if it doesn't exist

        //
        //  The following call to GetPrivateProfileString could return a blank string, thus we don't
        //  use the MYVERIFY macro on it.
        //

        ZeroMemory(szTemp, sizeof(szTemp));
        GetPrivateProfileString(c_pszCmSectionIsp, szKey, TEXT(""), szTemp, CELEMS(szTemp),
            g_szCmsFile); //lint !e534
        
        if (TEXT('\0') == szTemp[0])
        {
            MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionIsp, szKey, TEXT("NosurchargeSignon"),
                g_szCmsFile));
        }

        MYVERIFY(CELEMS(szKey) > (UINT)wsprintf(szKey, TEXT("%s%s"), c_pszCmEntryIspFilterB, 
            pszName));

        //
        //  The following call to GetPrivateProfileString could return a blank string, thus we shouldn't
        //  check its return code with MYVERIFY.
        //

        GetPrivateProfileString(c_pszCmSectionIsp, szKey, TEXT(""), szTemp, CELEMS(szTemp),
            g_szCmsFile); //lint !e534
        
        if (TEXT('\0') == szTemp[0])
        {
            MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionIsp, szKey, TEXT("SurchargeSignon"), 
                g_szCmsFile));
        }

        MYVERIFY(0 != SetCurrentDirectory(g_szOsdir));

        // COPY PHONEBOOK

        GetPrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspPbFile, TEXT(""), szEntry, 
            CELEMS(szEntry), szDest);    //lint !e534 could return EMPTY string

        GetFileName(szEntry,szFile);
        
        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s"), g_szOutdir, szFile));
        
        if (CopyFile(szEntry,szTemp,FALSE))
        {
            MYVERIFY(FALSE != createListBxRecord(&g_pHeadRefs, &g_pTailRefs, (void *)NULL, 0, szFile));
            MYVERIFY(0 != SetFileAttributes(szTemp, FILE_ATTRIBUTE_NORMAL));
        }
        
        //
        // DO NOT REPORT AN ERROR IF COULDN'T FIND PHONEBOOK, IT IS OPTIONAL
        //
        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s"), g_szShortServiceName, szFile));

        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspPbFile, szTemp, 
            szDest));

        // COPY REGIONS

        GetPrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspRegionFile, TEXT(""), szEntry, 
            CELEMS(szEntry), szDest);  //lint !e534

        GetFileName(szEntry,szFile);
        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s"), g_szOutdir, szFile));
        if (CopyFile(szEntry,szTemp,FALSE))
        {
            MYVERIFY(FALSE != createListBxRecord(&g_pHeadRefs,&g_pTailRefs,(void *)NULL,0,szFile));
            MYVERIFY(0 != SetFileAttributes(szTemp,FILE_ATTRIBUTE_NORMAL));
        }

        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s"), g_szShortServiceName, szFile));
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspRegionFile, szTemp, szDest));
        LoopPtr = LoopPtr->next;
    }

    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspReferences, szReferences, g_szCmsFile));
    return TRUE;

}

//+----------------------------------------------------------------------------
//
// Function:  ProcessCustomHelp
//
// Synopsis:  Set up windows help
//
//
// History:   quintinb Created Header and renamed from ProcessPage7    8/6/98
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessCustomHelp(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szTemp[MAX_PATH+1];
    static TCHAR szDisplay[MAX_PATH+1]; // keeps unselected custom entry
    NMHDR* pnmHeader = (NMHDR*)lParam;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_CMHELP)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_EDITHELP);

    switch (message)
    {

        case WM_INITDIALOG:
            SetFocus(GetDlgItem(hDlg, IDC_EDITHELP));

            break;
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_RADIO1:
                    EnableWindow(GetDlgItem(hDlg,IDC_EDITHELP),FALSE);
                    _tcscpy(szDisplay,g_szHelp);
                    break;

                case IDC_RADIO2:
                    EnableWindow(GetDlgItem(hDlg,IDC_EDITHELP),TRUE);
                    
                    if (!(*g_szHelp) && (*szDisplay))
                    {
                        _tcscpy(g_szHelp,szDisplay);
                    }

                    break;

                case IDC_BROWSE1:
                    {
                        EnableWindow(GetDlgItem(hDlg,IDC_EDITHELP),TRUE);
                        MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2));

                        UINT uFilter = IDS_HLPFILTER;
                        TCHAR* szMask = TEXT("*.hlp");

                        MYVERIFY(0 != DoBrowse(hDlg, &uFilter, &szMask, 1,
                            IDC_EDITHELP, TEXT("hlp"), g_szHelp));
                    }

                    break;

                default:
                    break;
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));
                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));
                    
                    //
                    //  The following call to GetPrivateProfileString could return an empty string
                    //  thus we shouldn't check the return code with MYVERIFY.
                    //

                    ZeroMemory(g_szHelp, sizeof(g_szHelp));
                    GetPrivateProfileString(c_pszCmSection, c_pszCmEntryHelpFile, TEXT(""), 
                        g_szHelp, CELEMS(g_szHelp), g_szCmsFile);   //lint !e534
                    
                    if (TEXT('\0') == g_szHelp[0])
                    {
                        MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO1));
                        EnableWindow(GetDlgItem(hDlg,IDC_EDITHELP),FALSE);
                        MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDITHELP), WM_SETTEXT, 0, (LPARAM)GetName(szDisplay)));
                    }
                    else
                    {
                        MYVERIFY(0 != CheckRadioButton(hDlg,IDC_RADIO1,IDC_RADIO2,IDC_RADIO2));
                        EnableWindow(GetDlgItem(hDlg,IDC_EDITHELP),TRUE);
                        MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDITHELP), WM_SETTEXT, 0, (LPARAM)GetName(g_szHelp)));
                        MYVERIFY(FALSE != VerifyFile(hDlg,IDC_EDITHELP,g_szHelp,FALSE));
                    }
                    break;

                case PSN_WIZBACK:

                case PSN_WIZNEXT:
                    // the Next button was pressed
                    if (IsDlgButtonChecked(hDlg, IDC_RADIO2)==BST_CHECKED)
                    {
                        if (-1 == GetTextFromControl(hDlg, IDC_EDITHELP, szTemp, MAX_PATH, TRUE)) // bDisplayError == TRUE
                        {
                            SetFocus(GetDlgItem(hDlg, IDC_EDITHELP));
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }
                        
                        if (!VerifyFile(hDlg,IDC_EDITHELP,g_szHelp,TRUE))
                        {
                            if (g_szHelp[0] != TEXT('\0'))
                            {
                                return 1;
                            }
                        }

                        if (g_szHelp[0] == TEXT('\0'))
                        {
                            MYVERIFY(IDOK == ShowMessage(hDlg,IDS_NOHELP,MB_OK));
                            SetFocus(GetDlgItem(hDlg, IDC_EDITHELP));
                            
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }
                    }
                    else
                    {
                        g_szHelp[0] = TEXT('\0');
                    }

                    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryHelpFile, g_szHelp, g_szCmsFile));

                    //
                    //  By calling WritePrivateProfileString with all NULL's we flush the file cache 
                    //  (win95 only).  This call will return 0.
                    //

                    WritePrivateProfileString(NULL, NULL, NULL, g_szCmsFile); //lint !e534 this call will always return 0
                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessLicense
//
// Synopsis:  Add a license agreement
//
//
// History:   quintinb  Created Header and renamed from ProcessPage7A    8/6/98
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessLicense(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szTemp[MAX_PATH+1];
    NMHDR* pnmHeader = (NMHDR*)lParam;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_LICENSE)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_EDIT1);

    switch (message)
    {

        case WM_INITDIALOG:
            SetFocus(GetDlgItem(hDlg, IDC_EDIT1));

            break;
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_BROWSE1:
                    {
                        UINT uFilter = IDS_TXTFILTER;
                        TCHAR* szMask = TEXT("*.txt");

                        MYVERIFY(0 != DoBrowse(hDlg, &uFilter, &szMask, 1, IDC_EDIT1, TEXT("txt"), 
                            g_szLicense));
                    
                    }
                    break;

                default:
                    break;
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));
                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));

                    // 
                    //  The following call to GetPrivateProfileString could return an empty string,
                    //  thus we shouldn't use MYVERIFY on it.
                    //
                    ZeroMemory(g_szLicense, sizeof(g_szLicense));
                    GetPrivateProfileString(c_pszCmakStatus, c_pszLicenseFile, TEXT(""), g_szLicense, 
                        CELEMS(g_szLicense), g_szInfFile);   //lint !e534
                    
                    MYVERIFY(TRUE == SendMessage(GetDlgItem(hDlg, IDC_EDIT1), WM_SETTEXT, 0, (LPARAM)GetName(g_szLicense)));
                    MYVERIFY(FALSE != VerifyFile(hDlg,IDC_EDIT1,g_szLicense,FALSE));
                    break;

                case PSN_WIZBACK:

                case PSN_WIZNEXT:
                    // the Next button was pressed
                    
                    if (-1 == GetTextFromControl(hDlg, IDC_EDIT1, szTemp, MAX_PATH, TRUE)) // bDisplayError == TRUE
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                        return 1;
                    }

                    if (!VerifyFile(hDlg,IDC_EDIT1,g_szLicense,TRUE))
                    {
                        if (g_szLicense[0] != TEXT('\0'))
                        {
                            return 1;
                        }
                    }
    
                    MYVERIFY(0 != WritePrivateProfileString(c_pszCmakStatus,c_pszLicenseFile,g_szLicense,g_szInfFile));

#ifdef _WIN64
                    //
                    //  If we are going back, skip the Include CM binaries page if this is IA64
                    //
                    if (pnmHeader && (PSN_WIZBACK == pnmHeader->code)) 
                    {                        
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, IDD_SUPPORT_INFO));
                    }
#endif
                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

//+----------------------------------------------------------------------------
//
// Function:  MultiSelectOpenFileName
//
// Synopsis:  This function is called to allow the user to select multiple items
//            to add to cmak.  It is currently only used in the Additional Files
//            dialog of CMAK.  Note that *pszStringBuffer should be NULL when passed
//            in.  The caller is responsible for calling CmFree on pszStringBuffer
//            when finished.
//
// Arguments: HWND hDlg - HWND of the current dialog
//            TCHAR** pszStringBuffer - pointer to the buffer to hold the results
//
// Returns:   BOOL - Returns True if successful, -1 on cancel and 0 on error.
//
// History:   quintinb Created    9/16/98
//
//+----------------------------------------------------------------------------
BOOL MultiSelectOpenFileName(HWND hDlg, TCHAR** pszStringBuffer)
{
    OPENFILENAME filedef;
    TCHAR szTitle[MAX_PATH+1];
    TCHAR szFile[MAX_PATH+1];
    TCHAR szFilter[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szFileTitle[MAX_PATH+1];
    LPTSTR lpfilename;
    int iReturnValue;

    //
    //  Check Inputs
    //

    MYDBGASSERT(pszStringBuffer);

    if (NULL == pszStringBuffer)
    {
        return FALSE;
    }

    ZeroMemory(&filedef, sizeof(OPENFILENAME));
    ZeroMemory(szFilter, sizeof(szFilter));


    szFile[0] = TEXT('\0');

    MYVERIFY(0 != LoadString(g_hInstance, IDS_BROWSETITLE, szTitle, MAX_PATH));
    MYVERIFY(0 != LoadString(g_hInstance, IDS_ALLFILTER, szFilter, MAX_PATH));
    TCHAR * pszTemp = &(szFilter[_tcslen(szFilter) + 1]);
    MYVERIFY(0!= wsprintf(pszTemp, c_pszWildCard));

    //
    //  Allocate memory for the multiple file selection return
    //

    DWORD dwSize = 10*1024;
    *pszStringBuffer = (TCHAR*)CmMalloc(dwSize*sizeof(TCHAR));
    if (NULL == *pszStringBuffer)
    {
        return FALSE;
    }
    ZeroMemory(*pszStringBuffer, dwSize*sizeof(TCHAR));

    //
    // Initialize the OPENFILENAME data structure
    //

    filedef.lStructSize = sizeof(OPENFILENAME); 
    filedef.hwndOwner = hDlg;    
    filedef.lpstrFilter = szFilter;
    filedef.lpstrFile = *pszStringBuffer;
    filedef.nMaxFile = dwSize;
    filedef.lpstrTitle = szTitle;
    filedef.Flags = OFN_FILEMUSTEXIST | OFN_LONGNAMES | OFN_PATHMUSTEXIST 
        | OFN_ALLOWMULTISELECT | OFN_EXPLORER; 
    
    //
    // pop up the open dialog
    //

    BOOL bExit;

    do
    {
        bExit = TRUE;

        BOOL bRet = GetOpenFileName((OPENFILENAME*)&filedef);
        
        if (bRet)
        {
            iReturnValue = 1;
        }
        else
        {
            //
            //  If we are in this state than the user could have hit cancel or there could have
            //  been an error.  If the CommDlgExtendedError function returns 0 then we know it was
            //  just a cancel, otherwise we have an error.
            //
            DWORD dwError = CommDlgExtendedError();

            if (0 == dwError)
            {
                //
                //  The user hit cancel
                //
                iReturnValue = -1;
            }
            else if (FNERR_BUFFERTOOSMALL == dwError)
            {
                //
                //  Not enough memory in the buffer.  The user is picking a whole bunch
                //  of files.  Lets warn them.
                //
                MYVERIFY(IDOK == ShowMessage(hDlg, IDS_SELECTION_TOO_LARGE, MB_OK | MB_ICONWARNING));

                bExit = FALSE;        
            }
            else
            {
                //
                //  An actual error occured, fail.
                //
                iReturnValue = 0;
            }
        }

    } while(!bExit);

    return iReturnValue;

}



//+----------------------------------------------------------------------------
//
// Function:  ParseAdditionalFiles
//
// Synopsis:  This function is used to parse the output from MultiSelectOpenFileName.
//            It takes a Null seperated list generated by OpenFileName (either one
//            full file path, or a directory path, NULL, and then NULL seperated 
//            filenames.)  From this list of filenames it adds them to the passed in
//            list of Extra file structures.
//
// Arguments: ListBxList **g_pHeadExtra - pointer to the head of the Extra struct list
//            ListBxList **g_pTailExtra - pointer to the tail of the Extra struct list
//            TCHAR* pszStringBuffer - string buffer of filenames to process
//
// Returns:   BOOL - TRUE on Success
//
// History:   quintinb Created      9/16/98
//
//+----------------------------------------------------------------------------
BOOL ParseAdditionalFiles(ListBxList **g_pHeadExtra, ListBxList **g_pTailExtra, TCHAR* pszStringBuffer)
{
    UINT uCurrentCharInBuffer=0;
    UINT uTempChars;
    TCHAR szPath[MAX_PATH+1];
    ExtraData DlgExtraEdit;

    MYDBGASSERT(NULL != g_pHeadExtra);
    MYDBGASSERT(NULL != g_pTailExtra);
    MYDBGASSERT(NULL != pszStringBuffer);
    MYDBGASSERT(TEXT('\0') != pszStringBuffer[0]);

    TCHAR* pStr = pszStringBuffer;

    _tcscpy (szPath, pszStringBuffer);
    pStr = pStr + (_tcslen(pStr) + 1);
    
    if (TEXT('\0') == *pStr)
    {
        //
        //  If the user only selected one file, then we just need to copy it to a buffer
        //
        _tcscpy(DlgExtraEdit.szPathname, szPath);
        GetFileName(DlgExtraEdit.szPathname, DlgExtraEdit.szName);

        MYVERIFY(FALSE != createListBxRecord(g_pHeadExtra, g_pTailExtra,(void *)&DlgExtraEdit, 
            sizeof(DlgExtraEdit), DlgExtraEdit.szName));
        return TRUE;
    }
    else
    {
        while (TEXT('\0') != *pStr)
        {
            //
            //  Fill the DlgExtra Struct with data
            //
            TCHAR szTemp[MAX_PATH+1];
            MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s"), szPath, pStr));
            _tcscpy(DlgExtraEdit.szPathname, szTemp);
            _tcscpy(DlgExtraEdit.szName, pStr);

            //
            //  Create the List box entry
            //
            MYVERIFY(FALSE != createListBxRecord(g_pHeadExtra, g_pTailExtra,(void *)&DlgExtraEdit, 
                                                 sizeof(DlgExtraEdit), DlgExtraEdit.szName));
            //
            //  Increment
            //
            pStr = pStr + (_tcslen(pStr) + 1);
        }

        return TRUE;
    }

    return FALSE;
}

void EnableDisableDeleteButton(HWND hDlg)
{
    //
    //  Enable the delete button if we have move than one item
    //
    LRESULT lResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETCOUNT, 0, 0);

    HWND hDeleteButton = GetDlgItem(hDlg, IDC_BUTTON2);
    HWND hCurrentFocus = GetFocus();
    HWND hControl;

    if (hDeleteButton)
    {
        EnableWindow(hDeleteButton, (1 <= lResult));
    }

    if (1 <= lResult)
    {
        SendDlgItemMessage(hDlg, IDC_LIST1, LB_SETCURSEL, 0, 0);    
    }

    if (FALSE == IsWindowEnabled(hCurrentFocus))
    {
        if (hDeleteButton == hCurrentFocus)
        {
            //
            //  If delete is disabled and contained the focus, shift it to the Add button
            //
            hControl = GetDlgItem(hDlg, IDC_BUTTON1);
            SendMessage(hDlg, DM_SETDEFID, IDC_BUTTON1, (LPARAM)0L); //lint !e534 DM_SETDEFID doesn't return error info
            SetFocus(hControl);
        }
        else
        {
            //
            //  If all else fails set the focus to the list control
            //
            hControl = GetDlgItem(hDlg, IDC_LIST1);
            SetFocus(hControl);
        }    
    }


}

//+----------------------------------------------------------------------------
//
// Function:  ProcessAdditionalFiles
//
// Synopsis:  Add additional files to the profile
//
//
// History:   quintinb Created Header and renamed from ProcessPage7B   8/6/98
//            quintinb Added Multi-Select capability and removed intermediate dialog 9/16/98
//                      (NTRAID 210849)
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessAdditionalFiles(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szTemp[MAX_PATH+1];
    INT_PTR nResult;
    TCHAR* pszStringBuffer = NULL;
    BOOL bRet;
    NMHDR* pnmHeader = (NMHDR*)lParam;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_ADDITION)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_LIST1);

    switch (message)
    {
        case WM_INITDIALOG:
            SetFocus(GetDlgItem(hDlg, IDC_BUTTON1));
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_BUTTON1: //add
                    bRet = MultiSelectOpenFileName(hDlg, &pszStringBuffer);
                    if ((-1 != bRet) && (0 != bRet))
                    {
                        ParseAdditionalFiles(&g_pHeadExtra, &g_pTailExtra, pszStringBuffer);

                        RefreshList(hDlg, IDC_LIST1, g_pHeadExtra);
                        WriteExtraList();
                        SetFocus(GetDlgItem(hDlg, IDC_BUTTON1));
                        
                        EnableDisableDeleteButton(hDlg);
                    }
                    CmFree(pszStringBuffer);
                    return (TRUE);
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case IDC_BUTTON2: //delete
                    nResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETCURSEL, 0, (LPARAM)0);
                    if (nResult == LB_ERR)
                    {
                        MYVERIFY(IDOK == ShowMessage(hDlg, IDS_NOSELECTION, MB_OK));
                        return TRUE;
                    }

                    MYVERIFY(LB_ERR != SendDlgItemMessage(hDlg, IDC_LIST1, LB_GETTEXT, (WPARAM)nResult, 
                        (LPARAM)szTemp));
                    
                    DeleteListBxRecord(&g_pHeadExtra, &g_pTailExtra, szTemp);
                    RefreshList(hDlg, IDC_LIST1, g_pHeadExtra);
                    EnableDisableDeleteButton(hDlg);
                    WriteExtraList();
                    return (TRUE);
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                default:
                    break;
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));
                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_NEXT | PSWIZB_BACK));
                    
                    if (g_pHeadExtra == NULL)
                    {
                        ReadExtraList();
                    }

                    RefreshList(hDlg, IDC_LIST1, g_pHeadExtra);

                    EnableDisableDeleteButton(hDlg);

                   break;

                case PSN_WIZBACK:

                case PSN_WIZNEXT:
                    
                    //
                    //  Before allowing the user to finish we need to check the extra files
                    //  list and make sure that each file on it has a filename that is convertable
                    //  to ANSI.  If not then we need to make sure that we tell them so that they
                    //  can delete the file or rename it.  Checking this in ParseAdditional files
                    //  seemed odd because they may have selected a bunch of files where only
                    //  one of them was wrong.  Thus we would be failing their browse and there was
                    //  nothing they could do about it.  Doing it here allows them to keep all of the
                    //  good files that pass the roundtrip test and allows them to delete offending files
                    //  at a spot where they can actually do so.
                    //
                    
                    ExtraData * pExtraData;
                    ListBxList * LoopPtr;
                    if (NULL != g_pHeadExtra)
                    {
                        LoopPtr = g_pHeadExtra;

                        while( LoopPtr != NULL)
                        {
                            pExtraData = (ExtraData *)LoopPtr->ListBxData;
                            {
                                GetFileName(pExtraData->szPathname, szTemp);
                                if (!TextIsRoundTripable(szTemp, TRUE)) // TRUE == bDisplayError
                                {
                                    //
                                    //  Set the Cursor on the offending item in the list
                                    //
                                    nResult = SendDlgItemMessage(hDlg, IDC_LIST1, LB_FINDSTRINGEXACT, 
                                                                (WPARAM)-1, (LPARAM)szTemp);                      
                                    if (LB_ERR != nResult)
                                    {
                                        MYVERIFY(LB_ERR != SendDlgItemMessage(hDlg, IDC_LIST1, LB_SETCURSEL, (WPARAM)nResult, (LPARAM)0));
                                    }

                                    //
                                    //  Set focus on the delete button
                                    //
                                    SetFocus(GetDlgItem(hDlg, IDC_BUTTON2));
                                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                                    return 1;
                                }
                            }

                            LoopPtr = LoopPtr->next;
                        }
                    }

                    WriteExtraList();
                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}

BOOL WriteInf(HANDLE hInf, LPCTSTR str)
{
    DWORD written;

#ifdef UNICODE
    BOOL bReturn = FALSE;
    LPSTR pszAnsiString = WzToSzWithAlloc(str);
    
    if (pszAnsiString)
    {
        bReturn = WriteFile(hInf, pszAnsiString, (lstrlenA(pszAnsiString))*sizeof(CHAR), &written, NULL);
        CmFree(pszAnsiString);
    }

    return bReturn;
#else
    return (WriteFile(hInf, str, (lstrlen(str))*sizeof(TCHAR), &written, NULL));
#endif
}


//+----------------------------------------------------------------------------
//
// Function:  WriteCopy
//
// Synopsis:  This function writes an INF entry and copies the file to the temp
//            directory.  Note that the function expects a fully qualified path
//            in lpFile or <shortservicename>\filename.ext.
//
// Arguments: HANDLE hInf - handle to the open inf file to write to
//            LPTSTR lpFile - fully qualified path and filename of file to copy
//            BOOL bWriteShortName -- should the filename be converted to the shortname
//
// Returns:   BOOL - TRUE if the INF entry is written properly and the file is
//            copied properly.
//
//  NOTE:   This code is written such that filenames passed in should reference the
//          copy of the file in the temp directory (thus the user is editing the profile
//          and hasn't changed it) or the file is a new file and the path is to its original
//          location.  Unfortunately, we usually pass in the path to the file in the Profile
//          directory instead of in the temp dir.  This works fine, but makes an additional copy
//          operation necessary (since we copy all files to the temp dir in the beginning when 
//          editting anyway).
//
// History:   quintinb  Created Header    1/30/98
//
//+----------------------------------------------------------------------------
BOOL WriteCopy(HANDLE hInf, LPTSTR lpFile, BOOL bWriteShortName)
{
    TCHAR szDest[MAX_PATH+1];
    TCHAR szSrc[MAX_PATH+1];

    if (NULL != lpFile && lpFile[0] != TEXT('\0'))
    {
        //
        //  Prepare the destination in szDest
        //
        GetFileName(lpFile, szSrc);
        
        MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s\\%s"), g_szOutdir, szSrc));

        //
        //  Prepare the source in szSrc.  If we have <shortservicename>\filename.ext, then
        //  we need to prepend the path to the profiles dir, otherwise use as is.
        //
        wsprintf(szSrc, TEXT("%s\\"), g_szShortServiceName);
        CmStrTrim(lpFile);

        if (lpFile == CmStrStr(lpFile, szSrc))
        {
           MYVERIFY(CELEMS(szSrc) > (UINT)wsprintf(szSrc, TEXT("%s%s\\%s"), g_szCmakdir, c_pszProfiles, lpFile));        
        }
        else
        {
            lstrcpy(szSrc, lpFile);
        }

        //
        //  Copy the file
        //
        if (_tcsicmp(szSrc, szDest) != 0)
        {
            if (!CopyFileWrapper(szSrc, szDest, FALSE))
            {
                return FALSE;
            }
        }

        MYVERIFY(0 != SetFileAttributes(szDest, FILE_ATTRIBUTE_NORMAL));

        //
        //  If WriteShortName is set, then we want to write the short name of the file
        //  in the inf section.  Otherwise we want to write the long name.
        //
        if (bWriteShortName)
        {
            if (!GetShortFileName(szDest, szSrc))
            {
                return FALSE;
            }
        }
        else
        {
            GetFileName(szDest, szSrc);
        }

        MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s\r\n"), szSrc));

        return WriteInf(hInf, szDest);
    }
    return TRUE;
}


BOOL WriteInfLine(HANDLE hInf,LPTSTR lpFile)
{
    TCHAR szTemp[MAX_PATH+1];

    if (lpFile[0] != TEXT('\0'))
    {
        GetFileName(lpFile,szTemp);
        _tcscat(szTemp,TEXT("\r\n"));
        return WriteInf(hInf,szTemp);
    }
    else
    {
        //
        //  If blank then nothing to write
        //
        return TRUE;
    }
}

BOOL WriteSrcInfLine(HANDLE hInf,LPTSTR lpFile)
{
    TCHAR szShort[MAX_PATH+1];
    TCHAR szLong[MAX_PATH+1];
    RenameData TmpRenameData;

    if (lpFile[0] != TEXT('\0'))
    {
        if (!GetShortFileName(lpFile,szShort))
        {
            return FALSE;
        }

        GetFileName(lpFile,szLong);
        
        if (_tcsicmp(szShort,szLong) != 0)
        {
            _tcscpy(TmpRenameData.szShortName,szShort);
            _tcscpy(TmpRenameData.szLongName,szLong);
            MYVERIFY(FALSE != createListBxRecord(&g_pHeadRename,&g_pTailRename,(void *)&TmpRenameData,sizeof(TmpRenameData),TmpRenameData.szShortName));
        }
        _tcscat(szLong,TEXT("= 55\r\n"));
        return WriteInf(hInf,szLong);
    }
    else
    {
        //
        //  Nothing to write
        //
        return TRUE;
    }
}

BOOL WriteFileSections(HWND hDlg)
{
    HANDLE hInf;
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szTempName[MAX_PATH+1];
    TCHAR ch;
    int i;
    DWORD dwRead;
    BOOL bWriteShortName;

    hInf = CreateFile(g_szInfFile,GENERIC_WRITE|GENERIC_READ,0,NULL,OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,NULL);
    if (hInf == INVALID_HANDLE_VALUE)
    {
        _tcscpy(szTemp,g_szInfFile);
        FileAccessErr(hDlg,szTemp);
        goto error;
    }

    // MOVE TO END OF FILE TO BEGIN WRITING CUSTOM SECTIONS
    // SKIP ANY BLANK SPACE AT THE END OF THE FILE
    i = GetFileSize(hInf,NULL);
    do
    {
        --i;
        MYVERIFY(INVALID_SET_FILE_POINTER != SetFilePointer(hInf,i,NULL,FILE_BEGIN));
        MYVERIFY(0 != ReadFile(hInf,&ch,1,&dwRead,NULL));
    }
    while ((ch == TEXT('\r'))||(ch == TEXT('\n'))||(ch == TEXT(' ')));

    MYVERIFY(FALSE != WriteInf(hInf,TEXT("\r\n")));
    MYVERIFY(FALSE != WriteInf(hInf,TEXT("\r\n")));
    // USE ICON IN CM AS ICON FOR DESKTOP IF NOT LARGE ICON SPECIFIED
    MYVERIFY(FALSE != WriteInf(hInf,TEXT("[Xnstall.AddReg.Icon]\r\n")));
    if (g_szLargeIco[0]==TEXT('\0'))
    {
        WriteInf(hInf,TEXT("HKCR,\"CLSID\\%DesktopGUID%\\DefaultIcon\",,,\"%11%\\CMMGR32.EXE,0\"\r\n"));//lint !e534 compile doesn't like the MYVERIFY macro and big strings
    }
    else
    {
        WriteInf(hInf,TEXT("HKCR,\"CLSID\\%DesktopGUID%\\DefaultIcon\",,,\"%49000%\\%ShortSvcName%\\%DesktopIcon%\"\r\n"));//lint !e534 compile doesn't like the MYVERIFY macro and big strings
    }

    MYVERIFY(FALSE != WriteInf(hInf,TEXT("\r\n")));
    // WRITE OUT FILES INTO PROFILE DIRECTORY

    //
    //  We need to write a CopyFiles section with Long File Names (for NT5 Single User installs) 
    //  and one with Short Files Names (for win9x and All user NT).  This is to help fix
    //  NTRAID 323721 -- CM: User level accounts cannot install profiles on W2K Server
    //  The problem is that single users on NT5 do not have permission to write the
    //  Rename key (HKLM\Software\Microsoft\Windows\CurrentVersion\RenameFiles) and
    //  NT doesn't really need it anyway since the NT setup api's deal with long file
    //  names better than those of win95.
    //  

    for (bWriteShortName = 0; bWriteShortName < 2; bWriteShortName++)
    {
        if (!bWriteShortName)
        {
            //
            //  Write out the Single User Version of Xnstall.CopyFiles -- Set bWriteShortName == FALSE
            //
            MYVERIFY(FALSE != WriteInf(hInf, TEXT("[Xnstall.CopyFiles.SingleUser]\r\n")));
        }
        else
        {
            //
            //  Write out the All User Version of Xnstall.CopyFiles -- set bWriteShortName == TRUE
            //
            MYVERIFY(FALSE != WriteInf(hInf,TEXT("[Xnstall.CopyFiles]\r\n")));
        }

        if (!WriteCopy(hInf, g_szPhonebk, bWriteShortName)) {_tcscpy(szTemp,g_szPhonebk);goto error;}
        if (!WriteCopy(hInf, g_szRegion, bWriteShortName)) {_tcscpy(szTemp,g_szRegion);goto error;}
        if (!WriteCopy(hInf, g_szBrandBmp, bWriteShortName)) {_tcscpy(szTemp,g_szBrandBmp);goto error;}
        if (!WriteCopy(hInf, g_szPhoneBmp, bWriteShortName)) {_tcscpy(szTemp,g_szPhoneBmp);goto error;}
        if (!WriteCopy(hInf, g_szLargeIco, bWriteShortName)) {_tcscpy(szTemp,g_szLargeIco);goto error;}
        if (!WriteCopy(hInf, g_szSmallIco, bWriteShortName)) {_tcscpy(szTemp,g_szSmallIco);goto error;}
        if (!WriteCopy(hInf, g_szTrayIco, bWriteShortName)) {_tcscpy(szTemp,g_szTrayIco);goto error;}
        if (!WriteCopy(hInf, g_szHelp, bWriteShortName)) {_tcscpy(szTemp,g_szHelp);goto error;}
        if (!WriteCopy(hInf, g_szLicense, bWriteShortName)) {_tcscpy(szTemp,g_szLicense);goto error;}
        if (!WriteCopy(hInf, g_szCmProxyFile, bWriteShortName)) {_tcscpy(szTemp,g_szCmProxyFile);goto error;}
        if (!WriteCopy(hInf, g_szCmRouteFile, bWriteShortName)) {_tcscpy(szTemp,g_szCmRouteFile);goto error;}
        if (!WriteCopy(hInf, g_szVpnFile, bWriteShortName)) {_tcscpy(szTemp,g_szCmRouteFile);goto error;}

        if (g_bIncludeCmCode)
        {
            MYVERIFY(0 != LoadString(g_hInstance, IDS_READMETXT, szTemp, MAX_PATH));
            _tcscat(szTemp,TEXT("\r\n"));
            if (!WriteInf(hInf, szTemp)) {goto error;}
        }

        //
        // Write out tray icon command files
        //

        if (!WriteCopyMenuItemFiles(hInf, szTemp, bWriteShortName)) {goto error;}

        // Write out connect action command files
        if (!WriteCopyConActFiles(hInf,szTemp, bWriteShortName)) {goto error;}
        if (!WriteCopyExtraFiles(hInf,szTemp, bWriteShortName)) {goto error;}
        if (!WriteCopyDnsFiles(hInf,szTemp, bWriteShortName)) {goto error;}

        if (bWriteShortName)
        {
            MYVERIFY(FALSE != WriteShortRefsFiles(hInf, FALSE));
        }
        else
        {
            MYVERIFY(FALSE != WriteLongRefsFiles (hInf));
        }

        _tcscpy(szTemp,g_szShortServiceName);

        _tcscat(szTemp,TEXT(".cms,,,4\r\n")); // the 4 makes sure there is no version checking on the cms
        MYVERIFY(FALSE != WriteInf(hInf,szTemp));

        _tcscpy(szTemp,g_szShortServiceName);
        _tcscat(szTemp,TEXT(".inf\r\n"));
        MYVERIFY(FALSE != WriteInf(hInf,szTemp));

        MYVERIFY(FALSE != WriteInf(hInf,TEXT("\r\n")));
    }

    //
    //  End of quintinb fix for 323721
    //

    //WRITE OUT FILES TO COPY TO ICM DIRECTORY
    MYVERIFY(FALSE != WriteInf(hInf,TEXT("[Xnstall.CopyFiles.ICM]\r\n")));
    _tcscpy(szTemp,g_szShortServiceName);
    _tcscat(szTemp,TEXT(".cmp\r\n"));
    MYVERIFY(FALSE != WriteInf(hInf,szTemp));
    MYVERIFY(FALSE != WriteRefsFiles(hInf,TRUE));// doesn't do anything because no cmp files in HeadRef list, call just writes the CMP file under [Xnstall.CopyFiles.ICM]
    MYVERIFY(FALSE != WriteInf(hInf,TEXT("\r\n")));

    // WRITE OUT FILES TO DELETE FROM ROOT ICM DIRECTORY
    MYVERIFY(FALSE != WriteInf(hInf,TEXT("[Remove.DelFiles.ICM]\r\n")));
    _tcscpy(szTemp,g_szShortServiceName);
    _tcscat(szTemp,TEXT(".cmp\r\n"));
    MYVERIFY(FALSE != WriteInf(hInf,szTemp));
    MYVERIFY(FALSE != WriteRefsFiles(hInf,TRUE));// doesn't anything because no cmp files in HeadRef list, call just writes the CMP file under [Remove.DelFiles.ICM]


    // WRITE LIST OF ALL FILES IN PRODUCT
    MYVERIFY(FALSE != WriteInf(hInf,TEXT("\r\n")));
    MYVERIFY(FALSE != WriteInf(hInf,TEXT("[SourceDisksFiles]\r\n")));
    _tcscpy(szTemp,TEXT("%ShortSvcname%"));
    MYVERIFY(FALSE != WriteSrcInfLine(hInf,g_szPhonebk));
    MYVERIFY(FALSE != WriteSrcInfLine(hInf,g_szRegion));
    MYVERIFY(FALSE != WriteSrcInfLine(hInf,g_szBrandBmp));
    MYVERIFY(FALSE != WriteSrcInfLine(hInf,g_szPhoneBmp));
    MYVERIFY(FALSE != WriteSrcInfLine(hInf,g_szLargeIco));
    MYVERIFY(FALSE != WriteSrcInfLine(hInf,g_szSmallIco));
    MYVERIFY(FALSE != WriteSrcInfLine(hInf,g_szTrayIco));
    MYVERIFY(FALSE != WriteSrcInfLine(hInf,g_szHelp));
    MYVERIFY(FALSE != WriteSrcInfLine(hInf,g_szLicense));
    MYVERIFY(FALSE != WriteSrcInfLine(hInf,g_szCmProxyFile));
    MYVERIFY(FALSE != WriteSrcInfLine(hInf,g_szCmRouteFile));
    MYVERIFY(FALSE != WriteSrcInfLine(hInf,g_szVpnFile));    

    _tcscpy(szTemp,g_szShortServiceName);
    _tcscat(szTemp,TEXT(".inf = 55\r\n"));
    MYVERIFY(FALSE != WriteInf(hInf,szTemp));

    _tcscpy(szTemp,g_szShortServiceName);
    _tcscat(szTemp,TEXT(".cmp = 55\r\n"));
    MYVERIFY(FALSE != WriteInf(hInf,szTemp));
    
    _tcscpy(szTemp,g_szShortServiceName);
    _tcscat(szTemp,TEXT(".cms = 55\r\n"));
    MYVERIFY(FALSE != WriteInf(hInf,szTemp));

    WriteSrcMenuItemFiles(hInf);
    WriteSrcConActFiles(hInf);
    WriteSrcExtraFiles(hInf);
    MYVERIFY(FALSE != WriteSrcRefsFiles(hInf)); // This call writes out the refs files to [Remove.DelFiles]
    WriteSrcDnsFiles(hInf);
    WriteRenameSection(hInf);

    MYVERIFY(FALSE != WriteInf(hInf,TEXT("\r\n")));
    MYVERIFY(FALSE != WriteInf(hInf,TEXT("[Remove.DelFiles]\r\n")));
    
    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s.cms\r\n"), g_szShortServiceName));
    MYVERIFY(FALSE != WriteInf(hInf,szTemp));

    if (g_bIncludeCmCode)
    {
        MYVERIFY(0 != LoadString(g_hInstance, IDS_READMETXT, szTemp, MAX_PATH));
        _tcscat(szTemp,TEXT("\r\n"));
        MYVERIFY(0 != WriteInf(hInf,szTemp));
    }

    MYVERIFY(FALSE != WriteInfLine(hInf,g_szPhonebk));
    MYVERIFY(FALSE != WriteInfLine(hInf,g_szRegion));
    MYVERIFY(FALSE != WriteInfLine(hInf,g_szBrandBmp));
    MYVERIFY(FALSE != WriteInfLine(hInf,g_szPhoneBmp));
    MYVERIFY(FALSE != WriteInfLine(hInf,g_szLargeIco));
    MYVERIFY(FALSE != WriteInfLine(hInf,g_szSmallIco));
    MYVERIFY(FALSE != WriteInfLine(hInf,g_szTrayIco));
    MYVERIFY(FALSE != WriteInfLine(hInf,g_szHelp));
    MYVERIFY(FALSE != WriteInfLine(hInf,g_szLicense));
    MYVERIFY(FALSE != WriteInfLine(hInf,g_szCmProxyFile));
    MYVERIFY(FALSE != WriteInfLine(hInf,g_szCmRouteFile));
    MYVERIFY(FALSE != WriteInfLine(hInf,g_szVpnFile));    

    WriteDelMenuItemFiles(hInf);
    WriteDelConActFiles(hInf);
    WriteDelExtraFiles(hInf);
    MYVERIFY(FALSE != WriteRefsFiles(hInf,FALSE));
    WriteDelDnsFiles(hInf);
    WriteEraseLongName(hInf);
    MYVERIFY(FALSE != WriteInf(hInf,TEXT("\r\n")));

    MYVERIFY(0 != CloseHandle(hInf));
    
    MYVERIFY(0 != SetCurrentDirectory(g_szCmakdir));

    return (TRUE);
error:
    {
        //FileAccessErr(hDlg,szTemp);
        MYVERIFY(0 != CloseHandle(hInf));
        return (FALSE); 
    }
}

void EraseSEDFiles(LPCTSTR szSed)
{
    int i = 0;

    TCHAR szTemp[MAX_PATH+1];
    TCHAR szFileNum[MAX_PATH+1];
    TCHAR szSourceFilesSection[MAX_PATH+1];

    _tcscpy(szSourceFilesSection, TEXT("SourceFiles0"));

    do 
    {
        MYVERIFY(CELEMS(szFileNum) > (UINT)wsprintf(szFileNum, TEXT("FILE%d"), i));

        //
        //  The following call to GetPrivateProfileString could return an empty string, thus don't
        //  use the MYVERIFY macro on it.
        //

        GetPrivateProfileString(c_pszInfSectionStrings, szFileNum, TEXT(""), szTemp, 
            MAX_PATH, szSed);   //lint !e534
        
        if (*szTemp)
        {
            MYVERIFY(0 != WritePrivateProfileString(c_pszInfSectionStrings, szFileNum, NULL, szSed));
            MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%%%s%%"), szFileNum));
            MYVERIFY(0 != WritePrivateProfileString(szSourceFilesSection, szTemp, NULL, szSed));
        }
        else
        {
            break;
        }

        ++i;    // increment the file number
    }
    while(*szTemp);

    //
    //  Erase the finish message key from the Sed.  This will avoid double finish messages
    //  (since cmstp is now supposed to take care of finish message but older profiles had
    //  the message from here).
    //

    MYVERIFY(0 != WritePrivateProfileString(c_pszOptions, TEXT("FinishMessage"), TEXT(""), szSed));

    //
    //  Write out the word <None> into the post install command so that showicon isn't a problem
    //  on an upgrade.
    //
    MYVERIFY(0 != WritePrivateProfileString(c_pszInfSectionStrings, TEXT("PostInstallCmd"), TEXT("<None>"), szSed));

    //
    //  By calling WritePrivateProfileString with all NULL's we flush the file cache 
    //  (win95 only).  This call will return 0.
    //

    WritePrivateProfileString(NULL, NULL, NULL, szSed); //lint !e534 this call will always return 0

}

//+----------------------------------------------------------------------------
//
// Function:  WriteSED
//
// Synopsis:  This function takes a fullpath to a file and the current file
//            number entry to write it to and writes the file entry in the SED
//            passed in.  Before writing the entry, the functions enumerates all
//            other files in the sed to check for duplicates.  If it finds a
//            file with the sme filename, it will not write the entry because
//            since we are using a flat directory structure two files of the same
//            name will overwrite each other anyway.  Note that if the file is
//            written, *pFileNum is incremented.
//
// Arguments: HWND hDlg - Window handle for FileAccessErr Messages
//            LPTSTR szFullFilePath - Full path of the file to write
//            LPINT pFileNum - Current File entry number
//            LPCTSTR szSed - Full path to the sed file to write the entry to
//
// Returns:   Nothing
//
// History:   quintinb  Created Header, Removed UseLangDir, Changed to take a full path,
//                      and generally cleaned up.    8/7/98
//
//+----------------------------------------------------------------------------
BOOL WriteSED(HWND hDlg, LPTSTR szFullFilePath, LPINT pFileNum, LPCTSTR szSed)
{
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szFileName[MAX_PATH+1];
    TCHAR szFileNumber[MAX_PATH+1];

    if (TEXT('\0') != szFullFilePath[0])
    {

        //
        //  First Check to see if the file exists.  If we write a file in the SED that
        //  IExpress can't find, then it will throw an error.  We should definitely try
        //  to throw an error earlier and try to give the user a chance to fix it.
        //
        if (!FileExists(szFullFilePath))
        {
            CFileNameParts FileParts(szFullFilePath);
            if ((TEXT('\0') == FileParts.m_Drive[0]) && 
                (TEXT('\0') == FileParts.m_Dir[0]) &&
                (TEXT('\0') != FileParts.m_FileName[0]) &&
                (TEXT('\0') != FileParts.m_Extension[0]))
            {
                //
                //  The user only passed in the filename and extension.  Lets look in
                //  the profile directory.  If it isn't here then throw an error.
                //
                MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s%s\\%s%s"), 
                    g_szOsdir, g_szShortServiceName, FileParts.m_FileName, FileParts.m_Extension));
                if (!FileExists(szTemp))
                {
                    FileAccessErr(hDlg, szFullFilePath);
                    return FALSE;
                }
                else
                {
                    MYVERIFY(CELEMS(szFullFilePath) > (UINT)wsprintf(szFullFilePath, szTemp));
                }
            }
            else
            {
                FileAccessErr(hDlg, szFullFilePath);
                return FALSE;
            }
        }

        //
        //  Get just the file name from the full path.  We use this
        //  later to determine if the file already exists in the SED
        //  file.
        //
        GetFileName(szFullFilePath, szFileName);

        //
        //  Construct the next FileNumber Entry
        //
        MYVERIFY(CELEMS(szFileNumber) > (UINT)wsprintf(szFileNumber, TEXT("FILE%d"), *pFileNum));

        //
        //  Check to make sure that we already don't have the file in the cab.  If
        //  so then just ignore the entry.
        //
        for (int i=0; i<*pFileNum; ++i)
        {
            //
            //  Write the FILEX entry into a string to read in the file name for the
            //  current i.
            //
            MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("FILE%d"), i));
            
            TCHAR szTempFileName[MAX_PATH+1];

            GetPrivateProfileString(c_pszInfSectionStrings, szTemp, 
                TEXT(""), szTempFileName, CELEMS(szTempFileName), szSed);   //lint !e534

            if (TEXT('\0') != szTempFileName[0])
            {
                //
                //  Get the filenames of both files since we are using a flat directory space.
                //  Two files of the same name will collide anyway.
                //
                GetFileName(szTempFileName, szTemp);
                if (0 == _tcsicmp(szTemp, szFileName))
                {
                    //
                    //  don't add it because it already exists
                    //
                    CMASSERTMSG(0 == _tcsicmp(szFullFilePath, szTempFileName), TEXT("WriteSed -- We have two files that have the same FileName but different paths."));
                    return TRUE;
                }
            }
        }

        MYVERIFY(0 != WritePrivateProfileString(c_pszInfSectionStrings, 
            szFileNumber, szFullFilePath, szSed));

        *pFileNum = (*pFileNum) + 1;

        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%%%s%%"), szFileNumber));

        MYVERIFY(0 != WritePrivateProfileString(TEXT("SourceFiles0"), szTemp, TEXT(""), szSed));
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteCMPFile
//
// Synopsis:  This function is a wrapper file to write out the version to the CMP.
//
// Arguments: None
//
// History:   nickball      Created Header    07/22/98
//
//+----------------------------------------------------------------------------
void WriteCMPFile()
{
    TCHAR szTemp[MAX_PATH+1];
    
    //
    //  Ensure that the version number is up to date in the .CMP
    //

    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%d"), PROFILEVERSION));
    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionProfileFormat, c_pszVersion, szTemp, g_szCmpFile));

    //
    //  Write the CMS entry to the CMP File
    //

    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s.cms"), g_szShortServiceName, g_szShortServiceName));

    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryCmsFile, szTemp, g_szCmpFile));
}

//+----------------------------------------------------------------------------
//
// Function:  WriteOutRelativeFilePathOrNull
//
// Synopsis:  This helper routine was written to shorten WriteCMSFile().  It tests
//            to see if the inputted pszFile parameter is an empty string.  If it
//            is then it writes an empty string to the File entry specified by
//            pszSection, pszEntryName, and pszFileToWriteTo.  Otherwise it concats
//            just the file name from pszFile with the parameter specified in
//            pszShortName, seperating them with a '\' character.  This is useful
//            for CMS parameters that are either empty or a relative path from the
//            cmp file location.
//
// Arguments: LPCTSTR pszFile - file entry to write
//            LPCTSTR pszShortName - shortname of the profile
//            LPCTSTR pszSection - string name of the section string
//            LPCTSTR pszEntryName - string name of the entry name string
//            LPCTSTR pszFileToWriteTo - full path of the file to write the entry to
//
// Returns:   Nothing
//
// History:   quintinb Created    8/8/98
//
//+----------------------------------------------------------------------------
void WriteOutRelativeFilePathOrNull(LPCTSTR pszFile, LPCTSTR pszShortName, LPCTSTR pszSection, LPCTSTR pszEntryName, LPCTSTR pszFileToWriteTo)
{
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szName[MAX_PATH+1];

    //
    //  Check Inputs
    //
    if ((NULL == pszFile) ||
        (NULL == pszShortName) || (TEXT('\0') == pszShortName[0]) ||
        (NULL == pszFileToWriteTo) || (TEXT('\0') == pszFileToWriteTo[0]) ||
        (NULL == pszSection) || (TEXT('\0') == pszSection[0]) ||
        (NULL == pszEntryName) || (TEXT('\0') == pszEntryName[0]))
    {
        CMASSERTMSG(FALSE, TEXT("WriteoutRelativeFilePathOrNull -- Bad Parameter"));
        return;
    }

    if (TEXT('\0') != pszFile[0])
    {
        GetFileName(pszFile, szName);
        
        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s"), 
            pszShortName, szName));
    }
    else
    {
        szTemp[0] = TEXT('\0');        
    }

    MYVERIFY(0 != WritePrivateProfileString(pszSection, pszEntryName, szTemp, pszFileToWriteTo));
}


//+----------------------------------------------------------------------------
//
// Function:  WriteCMSFile
//
// Synopsis:  This function is a wrapper file to write out the CMS file.  Note
//            that the cms is modified throughout CMAK, but this should be the
//            last place where it is modified.
//
// Arguments: None
//
// History:   quintinb Created Header    12/4/97
//
//+----------------------------------------------------------------------------
BOOL WriteCMSFile()
{
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szName[MAX_PATH+1];

    //
    //  Ensure that the Profile Format version number is up to date
    //

    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%d"), PROFILEVERSION));
    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionProfileFormat, c_pszVersion, szTemp, g_szCmsFile));

    //
    // erase name of phone book to be loaded if not doing download.
    //
    if (!g_bUpdatePhonebook)
    {
        g_szPhoneName[0] = TEXT('\0');
    }

    //
    //  Write out the Phonebook Name
    //

    if (TEXT('\0') != g_szPhonebk[0])
    {
        GetFileName(g_szPhonebk, szName);
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszVersion, c_pszOne, 
            g_szCmsFile));
    }
    else
    {   
        //
        // if no phone number, then set version to zero
        //
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszVersion, c_pszZero,
            g_szCmsFile));
        
        if (TEXT('\0') != g_szPhoneName[0])
        {
            MYVERIFY(CELEMS(szName) > (UINT)wsprintf(szName, TEXT("%s.pbk"), g_szPhoneName));
        }
        else
        {
            //
            // no phone book entered or set for download
            //
            szName[0] = TEXT('\0');
        }
    }

    WriteOutRelativeFilePathOrNull(szName, g_szShortServiceName, c_pszCmSectionIsp, 
        c_pszCmEntryIspPbFile, g_szCmsFile);

    //
    //  Write out the Phonebook Name
    //

    if (TEXT('\0') != g_szRegion[0])
    {
        GetFileName(g_szRegion, szName);
    }
    else
    {
        if (TEXT('\0') != g_szPhoneName[0])
        {
            MYVERIFY(CELEMS(szName) > (UINT)wsprintf(szName, TEXT("%s.pbr"), g_szPhoneName));
        }
        else
        {
            szName[0] = TEXT('\0');
        }
    }

    WriteOutRelativeFilePathOrNull(szName, g_szShortServiceName, c_pszCmSectionIsp, 
        c_pszCmEntryIspRegionFile, g_szCmsFile);

    //
    //  Write out the Large Icon
    //
    WriteOutRelativeFilePathOrNull(g_szLargeIco, g_szShortServiceName, c_pszCmSection, 
        c_pszCmEntryBigIcon, g_szCmsFile);

    //
    //  Write out the Small Icon
    //
    WriteOutRelativeFilePathOrNull(g_szSmallIco, g_szShortServiceName, c_pszCmSection, 
        c_pszCmEntrySmallIcon, g_szCmsFile);

    //
    //  Write out the Tray Icon
    //
    WriteOutRelativeFilePathOrNull(g_szTrayIco, g_szShortServiceName, c_pszCmSection, 
        c_pszCmEntryTrayIcon, g_szCmsFile);
    
    //
    //  Write out the custom help file
    //
    WriteOutRelativeFilePathOrNull(g_szHelp, g_szShortServiceName, c_pszCmSection, 
        c_pszCmEntryHelpFile, g_szCmsFile);

    //
    //  Write out the License File to the INF, thus we can easily redisplay
    //  it if they edit the profile again.  (basically stash the license file
    //  name in the CMAK Status section of the inf)
    //
    WriteOutRelativeFilePathOrNull(g_szLicense, g_szShortServiceName, c_pszCmakStatus, 
        c_pszLicenseFile, g_szInfFile);

    //
    //  Write out the Main Screen Bitmap
    //
    WriteOutRelativeFilePathOrNull(g_szBrandBmp, g_szShortServiceName, c_pszCmSection, 
        c_pszCmEntryLogo, g_szCmsFile);
    
    //
    //  Write out the Phone Bitmap
    //
    WriteOutRelativeFilePathOrNull(g_szPhoneBmp, g_szShortServiceName, c_pszCmSection, 
        c_pszCmEntryPbLogo, g_szCmsFile);

    //
    //  Write the HideDomain flag
    //

    GetPrivateProfileString(c_pszCmSection, c_pszCmEntryHideDomain, TEXT(""), 
        szTemp, MAX_PATH, g_szCmsFile);   //lint !e534
    
    //
    //  If using tunneling and the HideDomain entry doesn't previously exist, then write
    //  zero for the entry.  Otherwise nothing should be written for this entry.
    //
    if (!(_tcscmp(TEXT(""), szTemp) ) && g_bUseTunneling)
    {
        //
        //  Don't want to overwrite a 1 if it exists.
        //
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryHideDomain, 
            c_pszZero, g_szCmsFile));
    }

    //
    //  If we aren't tunneling, make sure to delete the tunnel settings
    //
    if (FALSE == g_bUseTunneling)
    {
        //
        //  First delete all of the Tunnel DUN Settings
        //
        ListBxList * pCurrent = g_pHeadVpnEntry;

        while (NULL != pCurrent)
        {
            EraseNetworkingSections(pCurrent->szName, g_szCmsFile);
            pCurrent = pCurrent->next;
        }

        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryTunnelDun, NULL, g_szCmsFile));
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryTunnelAddress, NULL, g_szCmsFile));
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryTunnelFile, NULL, g_szCmsFile));
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryUseSameUserName, NULL, g_szCmsFile));
    }
    
    //
    //  Write out the rest of the CMS entries (service name, support message, etc.)
    //
    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryServiceName, 
        g_szLongServiceName,g_szCmsFile));
    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryServiceMessage, 
        g_szSvcMsg, g_szCmsFile));
    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryUserPrefix, 
        g_szPrefix, g_szCmsFile));
    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryUserSuffix, 
        g_szSuffix, g_szCmsFile));

    //
    //  Set the name of the default Dun setting
    //
    MYVERIFY(0 != GetDefaultDunSettingName(g_szCmsFile, g_szLongServiceName, szTemp, CELEMS(szTemp)));

    MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryDun, szTemp, g_szCmsFile));

    //
    //  Write out the custom actions, make sure to set the bUseTunneling flag with the actual
    //  value to erase the PreTunnel section and set all of the flag values to zero if necessary
    //  (if for instance the user editted a tunneling profile and decided to make it non-Tunneling).
    //
    MYDBGASSERT(g_pCustomActionList);
    if (g_pCustomActionList)
    {
        HRESULT hr = g_pCustomActionList->WriteCustomActionsToCms(g_szCmsFile, g_szShortServiceName, g_bUseTunneling);
        CMASSERTMSG(SUCCEEDED(hr), TEXT("ProcessCustomActions -- Failed to write out connect actions"));
    }

    //
    //  Delete mbslgn32.dll special handling in the INF, it is no longer supported.
    //
    MYVERIFY(0 != WritePrivateProfileString(c_pszCmakStatus, c_pszUsePwdCache, NULL, g_szInfFile));

    if (g_bUpdatePhonebook)
    {
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmakStatus, c_pszUpdatePhonebook, c_pszOne, g_szInfFile));
    }
    else
    {
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmakStatus, c_pszUpdatePhonebook, c_pszZero, g_szInfFile));
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmakStatus, c_pszPhoneName, TEXT(""), g_szInfFile));
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspUrl, TEXT(""), g_szCmsFile));
    }

    //
    //  By calling WritePrivateProfileString with all NULL's we flush the file cache 
    //  (win95 only).  This call will return 0.
    //

    WritePrivateProfileString(NULL, NULL, NULL, g_szCmpFile); //lint !e534 this call will always return 0

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Function:  IncludeOptionalCode
//
// Synopsis:  This function writes the flags to CMAK to tell the profile installer
//            whether or not CM bits and Support dll's should be installed.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header and rewrote    5/23/98
//            quintinb NTRAID 162321, CM bits should not be installed on NT5 - 5/23/98
//            quintinb NTRAID 192500, Support Dll's now always included with CM bits - 9-2-98
//            quintinb we no longer ship the support dlls, removed support for them 4-19-2001
//
//+----------------------------------------------------------------------------
void IncludeOptionalCode()
{
    if (g_bIncludeCmCode)
    {
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmakStatus, c_pszIncludeCmCode, c_pszOne, g_szInfFile));
    }
    else
    {
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmakStatus, c_pszIncludeCmCode, c_pszZero, g_szInfFile));
    }

    //
    //  We no longer ship the support files, erase the entry from the inf  
    //
    MYVERIFY(0 != WritePrivateProfileString(c_pszCmakStatus, c_pszIncludeSupportDll, NULL, g_szInfFile));
}





//+----------------------------------------------------------------------------
//
// Function:  HandleWindowMessagesWhileCompressing
//
// Synopsis:  This function pumps messages while iexpress is running.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created      7/29/98
//
//+----------------------------------------------------------------------------
void HandleWindowMessagesWhileCompressing()
{
    MSG msg;

    while (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);//lint !e534 ignore dispatchmessage return values
    }
}

//+----------------------------------------------------------------------------
//
// Function:  DisableWizardButtons
//
// Synopsis:  This function disables the four wizard buttons at the bottom
//            of the wizard page.  Since these buttons aren't really ours we
//            need to get the window handle of the parent dialog and then get
//            the window handle of the individual button controls that we want to
//            disable (Help, Cancel, Back, and Finish/Next).  When we have the
//            window handle of each button we call EnableWindow on the button
//            to disable it.  This function also disables the geek pane controls
//            and the advanced checkbox on the build profile page if they exist.
//
// Arguments: HWND hDlg - Wizard page window handle (handle to our template page)
//
// Returns:   Nothing
//
// History:   quintinb Created     7/29/98
//
//+----------------------------------------------------------------------------
void DisableWizardButtons(HWND hDlg)
{
    #define IDBACK 12323
    #define IDNEXT 12324
    #define IDFINISH 12325

    HWND hCurrentPage = GetParent(hDlg);
    if (hCurrentPage)
    {   
        const int c_NumButtons = 5;
        int iArrayOfButtonsToDisable[c_NumButtons] = {IDCANCEL, IDHELP, IDBACK, IDNEXT, IDFINISH};
        //
        //  Disable the Cancel Button
        //
        for (int i = 0; i < c_NumButtons; i++)
        {
            HWND hButton = GetDlgItem(hCurrentPage, iArrayOfButtonsToDisable[i]);

            if (hButton)
            {
                EnableWindow(hButton, FALSE);
            }
        }
    }

    //
    //  Disable the advanced button and the geek pane controls if they exist.
    //
    int iArrayOfItemsToDisable[] = {IDC_ADVANCED, IDC_COMBO1, IDC_COMBO2, IDC_COMBO3, IDC_EDIT1, IDC_BUTTON1};
    const int c_NumItems = CELEMS(iArrayOfItemsToDisable);

    for (int i = 0; i < c_NumItems; i++)
    {
        HWND hControl = GetDlgItem(hDlg, iArrayOfItemsToDisable[i]);

        if (hControl)
        {
            EnableWindow(hControl, FALSE);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  WriteInfBeginAndEndPrompts
//
// Synopsis:  This function writes the Begin and End Prompt strings to the
//            inf file.  These are written dynamically because they need to
//            contain the Service Name.
//
// Arguments: HINSTANCE hInstance - Instance Handle to get string resources with
//            LPTSTR szInf - Inf file to write the prompts too
//            LPTSTR szServiceName - Long Service name of the profile
//
// Returns:   Nothing
//
// History:   Created Header    7/31/98
//
//+----------------------------------------------------------------------------
void WriteInfBeginAndEndPrompts(HINSTANCE hInstance, LPCTSTR szInf, LPCTSTR szServiceName)
{
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szPrompt[MAX_PATH+1];

    MYVERIFY(0 != LoadString(hInstance, IDS_BeginPromptText, szTemp, MAX_PATH));
    MYDBGASSERT(TEXT('\0') != szTemp[0]);

    MYVERIFY(CELEMS(szPrompt) > (UINT)wsprintf(szPrompt, szTemp, szServiceName));
    QS_WritePrivateProfileString(c_pszInfSectionStrings, c_pszInfBeginPrompt, szPrompt, szInf);
    

    MYVERIFY(0 != LoadString(hInstance, IDS_EndPromptText, szTemp, MAX_PATH));
    MYDBGASSERT(TEXT('\0') != szTemp[0]);

    MYVERIFY(CELEMS(szPrompt) > (UINT)wsprintf(szPrompt, szTemp, szServiceName));
    QS_WritePrivateProfileString(c_pszInfSectionStrings, c_pszInfEndPrompt, szPrompt, szInf);
}



//+----------------------------------------------------------------------------
//
// Function:  WriteInfFile
//
// Synopsis:  This function encapsulates all the code needed to write an inf file.
//
// Arguments: HINSTANCE hInstance - Instance handle to get string resources from
//            LPCTSTR szInf - Name of the Inf to write to
//            LPCTSTR szLongServiceName - Long Service Name of the Profile
//
// Returns:   BOOL - returns TRUE if succeeded
//
// History:   quintinb  created   8/10/98
//
//+----------------------------------------------------------------------------
BOOL WriteInfFile(HINSTANCE hInstance, HWND hDlg, LPCTSTR szInf, LPCTSTR szLongServiceName)
{
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szMsg[MAX_PATH+1];

    GUID vGUID;

    //
    //  Write out the version number of cmdial32.dll to the INF.  This tells the installer
    //  what version of cmdial32.dll that this profile was built to use.  We do this
    //  because if CM bits aren't bundled then we don't have cmdial32.dll to directly compare
    //  with.  Note that we now get the version of cmdial32.dll from the cm binaries cab, not
    //  the version in system32.
    //
#ifdef _WIN64
    CmVersion CmdialVersion;
#else
    wsprintf(szTemp, TEXT("%s\\cmdial32.dll"), g_szCmBinsTempDir);

    if (!FileExists(szTemp))
    {
        if (FAILED(ExtractCmBinsFromExe(g_szSupportDir, g_szCmBinsTempDir)))
        {
            CMASSERTMSG(FALSE, TEXT("WriteInfFile -- ExtractCmBinsFromExe Failed."));
            return FALSE;
        }
    }

    CVersion CmdialVersion(szTemp);
#endif

    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%d"), CmdialVersion.GetVersionNumber()));
    MYVERIFY(0 != WritePrivateProfileString(c_pszSectionCmDial32, c_pszVersion, szTemp, szInf));

    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%d"), CmdialVersion.GetBuildAndQfeNumber()));
    MYVERIFY(0 != WritePrivateProfileString(c_pszSectionCmDial32, c_pszVerBuild, szTemp, szInf));

    //
    //  Create a Desktop GUID if one doesn't already exist (a new profile instead of
    //  an editted one).
    //

    ZeroMemory(szTemp, sizeof(szTemp));
    GetPrivateProfileString(c_pszInfSectionStrings, c_pszDesktopGuid, 
        TEXT(""), szTemp, CELEMS(szTemp), szInf);   //lint !e534
    
    if (TEXT('\0') == szTemp[0])
    {
        MYVERIFY(S_OK == CoCreateGuid(&vGUID));
        MYVERIFY(0 != StringFromGUID2(vGUID, szTemp, MAX_PATH));

        QS_WritePrivateProfileString(c_pszInfSectionStrings, c_pszDesktopGuid, 
            szTemp, szInf);
    }

    //
    //  Write out the Display LCID of the profile
    //
    wsprintf(szTemp, TEXT("%d"), GetSystemDefaultLCID());
    MYVERIFY(0 != WritePrivateProfileString(c_pszInfSectionStrings, c_pszDisplayLCID, szTemp, szInf));

    //
    // Erase the existing File sections
    //
    MYVERIFY(0 != WritePrivateProfileString(TEXT("Xnstall.CopyFiles"), NULL, NULL, szInf));
    MYVERIFY(0 != WritePrivateProfileString(TEXT("Xnstall.CopyFiles.SingleUser"), NULL, NULL, szInf));
    MYVERIFY(0 != WritePrivateProfileString(TEXT("Xnstall.CopyFiles.ICM"),NULL, NULL, szInf));
    MYVERIFY(0 != WritePrivateProfileString(TEXT("Remove.DelFiles"),NULL, NULL, szInf));
    MYVERIFY(0 != WritePrivateProfileString(TEXT("Remove.DelFiles.ICM"),NULL, NULL, szInf));
    MYVERIFY(0 != WritePrivateProfileString(TEXT("SourceDisksFiles"),NULL, NULL, szInf));
    MYVERIFY(0 != WritePrivateProfileString(TEXT("Xnstall.AddReg.Icon"),NULL, NULL, szInf));
    MYVERIFY(0 != WritePrivateProfileString(TEXT("RegisterOCXSection"),NULL, NULL, szInf));
    MYVERIFY(0 != WritePrivateProfileString(TEXT("Xnstall.RenameReg"),NULL, NULL, szInf));

    if (!CreateMergedProfile())
    {
        return FALSE;
    }

    IncludeOptionalCode();

    //
    //  By calling WritePrivateProfileString with all NULL's we flush the file cache 
    //  (win95 only).  This call will return 0.
    //

    WritePrivateProfileString(NULL, NULL, NULL, szInf); //lint !e534 this call will always return 0

    //
    // Add the dynamic file sections to the install
    //
    if (WriteFileSections(hDlg) == FALSE)
    {
        return FALSE;
    }

    //
    //  Write the Begin and End Prompts
    //
    WriteInfBeginAndEndPrompts(hInstance, szInf, szLongServiceName);

    return TRUE;
}



//+----------------------------------------------------------------------------
//
// Function:  ConCatPathAndWriteToSed
//
// Synopsis:  This function is a wrapper for WriteSed that concats two paths
//            together before calling WriteSed.  This allows the caller to
//            store a common path (such as the system directory) and call
//            WriteSed with a bunch of different files all in the same directory
//            without having to individually concatenate the common path and the
//            filenames.
//
// Arguments: HWND hDlg - windows handle of the current dialog, needed for error messages
//            LPCTSTR pszFileName - Name of the file
//            LPCTSTR pszPath - Name of the path to prepend to the filename
//            int* pFileNum - the number of the file in the SED file
//            LPCTSTR szSed - the SED file to write to
//
// Returns:   BOOL - Returns TRUE if succeeded
//
// History:   quintinb Created    8/10/98
//
//+----------------------------------------------------------------------------
BOOL ConCatPathAndWriteToSed(HWND hDlg, LPCTSTR pszFileName, LPCTSTR pszPath, 
                             int* pFileNum, LPCTSTR szSed)
{
    TCHAR szTemp[MAX_PATH+1];

    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s"), pszPath, pszFileName));
    return WriteSED(hDlg, szTemp, pFileNum, szSed);
}




//+----------------------------------------------------------------------------
//
// Function:  ConstructSedFile
//
// Synopsis:  This function encapsulates all the work of creating an SED file.
//
// Arguments: HWND hDlg - window handle of the current dialog for error messages
//            LPCTSTR szSed - filename of the sed file to write
//            LPCTSTR szExe - executable filename for the SED to compress to
//
// Returns:   BOOL - Returns TRUE if successful
//
// History:   quintinb  Created     8/10/98
//
//+----------------------------------------------------------------------------
BOOL ConstructSedFile(HWND hDlg, LPCTSTR szSed, LPCTSTR szExe)
{
    int iFileNum=0;
    TCHAR szTemp[MAX_PATH+1];
    BOOL bReturn = TRUE;
    CPlatform cmplat;

    // 
    // Clear the SED and begin writing new settings
    // 

    EraseSEDFiles(szSed);

    //
    //  Write the Installer Package Exe Name
    //
    MYVERIFY(0 != WritePrivateProfileString(c_pszInfSectionStrings, 
        c_pszTargetName, szExe, szSed));


    //
    //  Write the Long Service Name as the FriendlyName
    //
    if (!WritePrivateProfileString(c_pszInfSectionStrings, c_pszFriendlyName, 
        g_szLongServiceName, szSed))
    {
        FileAccessErr(hDlg, szSed);
        return FALSE;
    }
    

    //
    // Load up IDS_INSTALL_PROMPT from the resources
    // Format the string using the g_szLongServiceName
    //
    LPTSTR pszInstallPromptTmp = CmFmtMsg(g_hInstance, IDS_INSTALL_PROMPT, g_szLongServiceName);

    if (pszInstallPromptTmp)
    {
        //
        // Write the Install Prompt string
        //
        if (!WritePrivateProfileString(c_pszInfSectionStrings, c_pszInstallPrompt, 
            pszInstallPromptTmp, szSed))
        {
            FileAccessErr(hDlg, szSed);
            return FALSE;
        }
   
        CmFree(pszInstallPromptTmp);
        pszInstallPromptTmp = NULL;
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("ConstructSedFile -- CmFmtMsg returned NULL."));
        FileAccessErr(hDlg, szSed);
        return FALSE;
    }



    //
    //  Clear the Target File Version Key
    //
    MYVERIFY(0 != WritePrivateProfileString(c_pszOptions, c_pszTargetFileVersion, 
        TEXT(""), szSed));
    
    //
    //  Set the Reboot Mode
    //
    MYVERIFY(0 != WritePrivateProfileString(c_pszOptions, TEXT("RebootMode"), TEXT("N"), 
        g_szSedFile));


    //
    //  Write the License text file into the SED.  Otherwise make sure to clear it.
    //
    
    if (TEXT('\0') != g_szLicense[0])
    {
        //
        //  We write the license text file into the SED in two places.  Once as a regular
        //  file and again using the c_pszDisplayLicense entry.  Thus we copy it to the 
        //  users profile dir and display it at install time.  We want to make sure that
        //  we use the full file name in the SED files section, but the short file name
        //  in the part of the SED that actually lauches the license at install time 
        /// (aka the strings section).
        //

        TCHAR szTempName[MAX_PATH+1];
        MYVERIFY (FALSE != GetShortFileName(g_szLicense, szTempName));

        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s%s\\%s"), g_szOsdir, 
            g_szShortServiceName, szTempName));

        bReturn &= WriteSED(hDlg, g_szLicense, &iFileNum, szSed);
    }
    else
    {
        szTemp[0] = TEXT('\0');
    }

    MYVERIFY(0 != WritePrivateProfileString(c_pszInfSectionStrings, c_pszDisplayLicense, 
        szTemp, szSed));


    //
    //  Add the install command to the SED file
    //
    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT(".\\cmstp.exe %s.inf"), g_szShortServiceName));
    MYVERIFY(0 != WritePrivateProfileString(c_pszInfSectionStrings, c_pszAppLaunched, 
        szTemp, szSed));


    //
    //  Get the System Directory path to concat to IEXPRESS and CM Files
    //
    TCHAR szSystemDir[MAX_PATH+1];
    MYVERIFY(0 != GetSystemDirectory(szSystemDir, MAX_PATH));

    //
    //  Begin Adding Files to the SED File.  Note that all 32-bit profiles
    //  must include IExpress file(s)
    //
    
    bReturn &= ConCatPathAndWriteToSed(hDlg, TEXT("advpack.dll"), szSystemDir, &iFileNum, szSed);

#ifndef _WIN64
    bReturn &= ConCatPathAndWriteToSed(hDlg, TEXT("w95inf16.dll"), g_szSupportDir, &iFileNum, szSed);
    bReturn &= ConCatPathAndWriteToSed(hDlg, TEXT("w95inf32.dll"), g_szSupportDir, &iFileNum, szSed);

    //
    //  Always include cmstp.exe.  Note that on x86 it comes from the binaries CAB.
    //
    bReturn &= ConCatPathAndWriteToSed(hDlg, TEXT("cmstp.exe"), g_szCmBinsTempDir, &iFileNum, szSed);
#else

    //
    //  Always include cmstp.exe.  Note that on IA64 we get it from the system directory.
    //
    bReturn &= ConCatPathAndWriteToSed(hDlg, TEXT("cmstp.exe"), szSystemDir, &iFileNum, szSed);
#endif
    
    if (g_bIncludeCmCode)
    {
        //
        //  Readme.txt is a special case since it is a localizable filename.
        //
        MYVERIFY(0 != LoadString(g_hInstance, IDS_READMETXT, szTemp, MAX_PATH));
        bReturn &= ConCatPathAndWriteToSed(hDlg, szTemp, g_szSupportDir, &iFileNum, szSed);    
        bReturn &= ConCatPathAndWriteToSed(hDlg, TEXT("instcm.inf"), g_szSupportDir, &iFileNum, szSed);    
        bReturn &= ConCatPathAndWriteToSed(hDlg, TEXT("cmbins.exe"), g_szSupportDir, &iFileNum, szSed);    

#ifndef _WIN64

        if (!(IsAlpha()))
        {
            //
            //  Add the win95 config files
            //
            bReturn &= ConCatPathAndWriteToSed(hDlg, TEXT("ccfg95.dll"), g_szSupportDir, &iFileNum, szSed);    
            bReturn &= ConCatPathAndWriteToSed(hDlg, TEXT("cnet16.dll"), g_szSupportDir, &iFileNum, szSed);

            //
            //  Add the Unicode to Ansi Conversion layer 
            //
            bReturn &= ConCatPathAndWriteToSed(hDlg, TEXT("cmutoa.dll"), g_szSupportDir, &iFileNum, szSed);
        }
#endif
    }

    //
    // Write entry for Inf in SED
    //
    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s%s\\%s.inf"), g_szOsdir, g_szShortServiceName, g_szShortServiceName));
    bReturn &= WriteSED(hDlg, szTemp, &iFileNum, szSed);

    //
    //  Write the Cmp to the Sed
    //
    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s%s\\%s.cmp"), g_szOsdir, g_szShortServiceName, g_szShortServiceName));
    bReturn &= WriteSED(hDlg, szTemp, &iFileNum, szSed);

    //
    //  Write the Cms to the Sed
    //
    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s%s\\%s.cms"), g_szOsdir, g_szShortServiceName, g_szShortServiceName));
    bReturn &= WriteSED(hDlg, szTemp, &iFileNum, szSed);

    //
    //  Now include the Custom Added Files
    //

    bReturn &= WriteSED(hDlg, g_szPhonebk, &iFileNum, szSed);
    bReturn &= WriteSED(hDlg, g_szRegion, &iFileNum, szSed);
    bReturn &= WriteSED(hDlg, g_szBrandBmp, &iFileNum, szSed);
    bReturn &= WriteSED(hDlg, g_szPhoneBmp, &iFileNum, szSed);
    bReturn &= WriteSED(hDlg, g_szLargeIco, &iFileNum, szSed);
    bReturn &= WriteSED(hDlg, g_szSmallIco, &iFileNum, szSed);
    bReturn &= WriteSED(hDlg, g_szTrayIco, &iFileNum, szSed);
    bReturn &= WriteSED(hDlg, g_szHelp, &iFileNum, szSed);
    bReturn &= WriteSED(hDlg, g_szCmProxyFile, &iFileNum, szSed);
    bReturn &= WriteSED(hDlg, g_szCmRouteFile, &iFileNum, szSed);
    bReturn &= WriteSED(hDlg, g_szVpnFile, &iFileNum, szSed);

    bReturn &=WriteSEDMenuItemFiles(hDlg, &iFileNum, szSed);
    bReturn &=WriteSEDConActFiles(hDlg, &iFileNum, szSed);
    bReturn &=WriteSEDExtraFiles(hDlg, &iFileNum, szSed);
    bReturn &=WriteSEDRefsFiles(hDlg, &iFileNum, szSed);
    bReturn &=WriteSEDDnsFiles(hDlg, &iFileNum, szSed);

    //
    //  By calling WritePrivateProfileString with all NULL's we flush the file cache 
    //  (win95 only).  This call will return 0.
    //

    WritePrivateProfileString(NULL, NULL, NULL, g_szSedFile); //lint !e534 this call will always return 0

    return bReturn;
}

void AddAllSectionsInCurrentFileToCombo(HWND hDlg, UINT uComboId, LPCTSTR pszFile)
{
    if ((NULL == hDlg) || (0 == uComboId) || (NULL == pszFile))
    {
        CMASSERTMSG(FALSE, TEXT("AddAllKeysInCurrentSectionToCombo -- Invalid Parameter passed."));
        return;
    }

    //
    //  Reset the combobox contents
    //
    SendDlgItemMessage(hDlg, uComboId, CB_RESETCONTENT, 0, 0); //lint !e534 CB_RESETCONTENT doesn't return anything useful

    //
    //  First lets get all of the sections from the existing cmp
    //
    LPTSTR pszAllSections = GetPrivateProfileStringWithAlloc(NULL, NULL, TEXT(""), pszFile);

    //
    //  Okay, now we have all of the sections in a buffer, lets add them to the combo
    //
    
    LPTSTR pszCurrentSection = pszAllSections;

    while (pszCurrentSection && TEXT('\0') != pszCurrentSection[0])
    {
        //
        //  Okay, lets add all of the sections that we found
        //

        MYVERIFY(CB_ERR!= SendDlgItemMessage(hDlg, uComboId, CB_ADDSTRING, 0, (LPARAM)pszCurrentSection));

        //
        //  Now advance to the next string in pszAllSections 
        //
        pszCurrentSection = pszCurrentSection + lstrlen(pszCurrentSection) + 1;
    }

    CmFree(pszAllSections);
}

void AddFilesToCombo(HWND hDlg, UINT uComboId)
{
    //
    //  Reset the combobox contents
    //
    SendDlgItemMessage(hDlg, uComboId, CB_RESETCONTENT, 0, 0); //lint !e534 CB_RESETCONTENT doesn't return anything useful

    //
    //  Add the profile cmp
    //
    LRESULT lResult = SendDlgItemMessage(hDlg, uComboId, CB_ADDSTRING, (WPARAM)0, (LPARAM)GetName(g_szCmpFile));
    if (CB_ERR != lResult)
    {
        SendDlgItemMessage(hDlg, uComboId, CB_SETITEMDATA, (WPARAM)lResult, (LPARAM)g_szCmpFile);
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("AddFilesToCombo -- unable to set item data"));
    }

    //
    //  Add the profile cms
    //
    lResult = SendDlgItemMessage(hDlg, uComboId, CB_ADDSTRING, (WPARAM)0, (LPARAM)GetName(g_szCmsFile));
    if (CB_ERR != lResult)
    {
        SendDlgItemMessage(hDlg, uComboId, CB_SETITEMDATA, (WPARAM)lResult, (LPARAM)g_szCmsFile);
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("AddFilesToCombo -- unable to set item data"));
    }
}

BOOL GetCurrentComboSelectionAlloc(HWND hDlg, UINT uComboId, LPTSTR* ppszText)
{
    if ((NULL == hDlg) || (0 == uComboId) || (NULL == ppszText))
    {
        CMASSERTMSG(FALSE, TEXT("GetCurrentComboSelectionAlloc -- invalid parameter"));
        return FALSE;
    }

    *ppszText = NULL;
    LRESULT lTextLen;
    BOOL bReturn = FALSE;
    LRESULT lResult = SendDlgItemMessage(hDlg, uComboId, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);

    if (CB_ERR != lResult)
    {
        lTextLen = SendDlgItemMessage(hDlg, uComboId, CB_GETLBTEXTLEN, (WPARAM)lResult, (LPARAM)0);

        if (0 != lTextLen)
        {
            lTextLen++; // NULL char
            *ppszText = (LPTSTR)CmMalloc(sizeof(TCHAR)*lTextLen);

            if (*ppszText)
            {
                lResult = SendDlgItemMessage(hDlg, uComboId, CB_GETLBTEXT, (WPARAM)lResult, (LPARAM)(*ppszText));

                if (0 == lResult)
                {
                    goto exit;
                }
                else
                {
                    bReturn = TRUE;
                }
            }
            else
            {
                goto exit;
            }
        }
        else
        {
            goto exit;
        }
    }
    else
    {
        goto exit;
    }
    
exit:
    if (FALSE == bReturn)
    {
        CmFree(*ppszText);
    }

    return bReturn;

}

//+----------------------------------------------------------------------------
//
// Function:  GetCurrentEditControlTextAlloc
//
// Synopsis:  Figures out the length of the text in the edit control specified
//            by the given window handle, allocates a buffer large enough to
//            hold the text and then retrieves the text and stores it in the
//            allocated buffer.  The buffer is the caller's responsibility to
//            free.  Note that we ensure the data is roundtripable.
//
// Arguments: HWND hEditText - window handle of the edit control to get the text from
//            LPTSTR* ppszText - pointer to a string pointer to recieve the output buffer
//
// Returns:   int - Returns the number of characters copied to *ppszText
//                  0 could be an error value but often means the control is empty
//                  -1 means that the text failed MBCS conversion and should not be used
//
// History:   quintinb  Created     04/07/00
//
//+----------------------------------------------------------------------------
int GetCurrentEditControlTextAlloc(HWND hEditText, LPTSTR* ppszText)
{
    if ((NULL == hEditText) || (NULL == ppszText))
    {
        CMASSERTMSG(FALSE, TEXT("GetCurrentEditControlTextAlloc -- invalid parameter"));
        return 0;
    }

    *ppszText = NULL;
    int iReturn = 0;
    LRESULT lResult;
    LRESULT lTextLen = SendMessage(hEditText, WM_GETTEXTLENGTH, (WPARAM)0, (LPARAM)0);

    if (0 != lTextLen)
    {
        lTextLen++; // NULL char
        *ppszText = (LPTSTR)CmMalloc(sizeof(TCHAR)*lTextLen);

        if (*ppszText)
        {
            lResult = SendMessage(hEditText, WM_GETTEXT, (WPARAM)lTextLen, (LPARAM)(*ppszText));

            if (0 == lResult)
            {
                goto exit;
            }
            else
            {
#ifdef UNICODE
                //
                //  We want to make sure that we can convert the strings to MBCS.  If we cannot then we are not
                //  going to be able to store the string in the our ANSI data files (.cms, .cmp, .inf, etc.).
                //  Thus we need to convert the string to MBCS and then back to UNICODE.  We will then compare the original
                //  string to the resultant string and see if they match.
                //
        
                if (!TextIsRoundTripable(*ppszText, TRUE))
                {
                    //
                    //  Set the return code to an error value.
                    //
                    iReturn = -1;
                    goto exit;
                }
#endif
                iReturn = (int)lResult;
            }
        }
        else
        {
            goto exit;
        }
    }
    else
    {
        goto exit;
    }

exit:
    if ((0 == iReturn) || (-1 == iReturn))
    {
        CmFree(*ppszText);
        *ppszText = NULL;
    }

    return iReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RemoveBracketsFromSectionString
//
// Synopsis:  Removes brackets from section string. If a string is
//            invalid, this function returns a newly allocated
//            valid string without brackets and deleted the old invalid one.
//            If there are no valid characters in the string this function
//            return NULL in ppszSection. It is the caller's responibility to 
//            free the string. 
//            This function was created to fix Bug 189379 for Whistler.
//
// Arguments: LPTSTR *ppszSection - pointer to the address of the string
//
// History:   tomkel    Created     11/15/2000
//
//+----------------------------------------------------------------------------
BOOL RemoveBracketsFromSectionString(LPTSTR *ppszSection)
{
    BOOL bReturn = FALSE;
    LPTSTR pszSection = NULL;
    const TCHAR* const c_szBadSectionChars = TEXT("[]");
    const TCHAR* const c_szLeftBracket = TEXT("[");
    const TCHAR* const c_szRightBracket = TEXT("]");
    
    if (NULL == ppszSection)
    {
        return bReturn;
    }

    pszSection = *ppszSection;

    if (NULL != pszSection)
    {
        LPTSTR pszValidSection = NULL;
        LPTSTR pszToken = NULL;
        //
        // We have a string so try to find an occurence of a bracket []. 
        //
        if (CmStrStr(pszSection, c_szLeftBracket) || CmStrStr(pszSection, c_szRightBracket))
        {
            //
            // The pszSection string contains brackets.
            // This treats brackets [] as delimiters. The loop concatenates the newly
            // valid string.
            //
            pszToken = CmStrtok(pszSection, c_szBadSectionChars);
            
            if (NULL != pszToken)
            {
                // 
                // Found at least one valid token
                //
                while (NULL != pszToken)
                {
                    if (NULL == pszValidSection)
                    {
                        pszValidSection = CmStrCpyAlloc(pszToken);
                    }
                    else
                    {
                        pszValidSection = CmStrCatAlloc(&pszValidSection, pszToken);
                    }

                    //
                    // Find the next valid token
                    //
                    pszToken = CmStrtok(NULL, c_szBadSectionChars);
                }

                if ( pszValidSection )
                {
                    // 
                    // We encountered brackets []. Lets copy the valid string back to 
                    // pszSection string so that the code below this section doesn't 
                    // need to be modified.
                    //
                    CmFree(pszSection);
                    pszSection = CmStrCpyAlloc(pszValidSection);
                    CmFree(pszValidSection);
                    pszValidSection = NULL;
                }
            }
            else
            {
                //
                // There are no valid tokens. Delete the string and set it to NULL.
                //
                CmFree(pszSection);
                pszSection = NULL;
                
            }

            *ppszSection = pszSection;
            bReturn = TRUE;
        }
        else
        {
            //
            // Nothing to parse, which is ok.
            //
            bReturn = TRUE;
        }
    }
    else
    {
        //
        // Nothing to parse, which is ok.
        //
        bReturn = TRUE;
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessGeekPane
//
// Synopsis:  Processes windows messages for the dialog which allows user to
//            edit the cms/cmp files directly for features not exposed in CMAK
//            directly.
//
// Arguments: WND hDlg - dialog window handle
//            UINT message - message identifier
//            WPARAM wParam - wParam Value 
//            LPARAM lParam - lParam Value
//
//
// History:   quintinb  Created     03/26/00
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessGeekPane(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    SetDefaultGUIFont(hDlg, message, IDC_EDIT1);
    SetDefaultGUIFont(hDlg, message, IDC_COMBO1);
    SetDefaultGUIFont(hDlg, message, IDC_COMBO2);
    SetDefaultGUIFont(hDlg, message, IDC_COMBO3);

    LRESULT lResult;
    static LPTSTR pszFile = NULL;
    static LPTSTR pszSection = NULL;
    static LPTSTR pszKey = NULL;
    LPTSTR pszValue = NULL;
    HWND hControl;
    static HWND hwndSectionEditControl = NULL;
    static HWND hwndKeyEditControl = NULL;
    COMBOBOXINFO cbInfo;
    NMHDR* pnmHeader = (NMHDR*)lParam;
    DWORD dwFinishPage;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_ADVANCED)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam))
    {
        if (0 == GetWindowLongPtr(hDlg, DWLP_MSGRESULT))
        {
            //
            //  If the user accepted the cancel then the DWLP_MSGRESULT value will be FALSE.  If
            //  they chose to deny the cancel it will be TRUE.  Thus if we need to, let's free
            //  up any allocated resources.  If you change the free code, make sure to change
            //  it below in the kill active state too.
            //
            CmFree(pszSection);
            pszSection = NULL;
            CmFree(pszKey);
            pszKey = NULL;
        }
        return TRUE;
    }

    switch (message)
    {

        case WM_INITDIALOG:
            //
            //  Fill in the files combo
            //
            AddFilesToCombo(hDlg, IDC_COMBO1);

            //
            //  Choose the Cms File because it is the one they are most likely to edit
            //
            lResult = SendDlgItemMessage(hDlg, IDC_COMBO1, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)GetName(g_szCmsFile));
            if (CB_ERR != lResult)
            {
                MYVERIFY(CB_ERR != SendDlgItemMessage(hDlg, IDC_COMBO1, CB_SETCURSEL, (WPARAM)lResult, (LPARAM)0));
            }

            pszFile = g_szCmsFile;
            AddAllSectionsInCurrentFileToCombo(hDlg, IDC_COMBO2, (LPCTSTR)pszFile);    

            //
            //  Choose the first section in the list, don't assert because there may not be any
            //
            SendDlgItemMessage(hDlg, IDC_COMBO2, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);

            if (GetCurrentComboSelectionAlloc(hDlg, IDC_COMBO2, &pszSection))
            {
                AddAllKeysInCurrentSectionToCombo(hDlg, IDC_COMBO3, pszSection, pszFile);

                //
                //  Choose the first key in the list, don't assert because there may not be any
                //
                SendDlgItemMessage(hDlg, IDC_COMBO3, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);

                GetCurrentComboSelectionAlloc(hDlg, IDC_COMBO3, &pszKey);

                //
                //  Finally fill in the edit control
                //
                pszValue = GetPrivateProfileStringWithAlloc(pszSection, pszKey, TEXT(""), pszFile);

                if (pszValue)
                {
                    SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)0, (LPARAM)pszValue);
                    CmFree(pszValue);
                }
                else
                {
                    SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)0, (LPARAM)TEXT(""));
                }
            }

            //
            //  Now lets get the window handles to the edit control portion of the section and key combobox controls
            //
            ZeroMemory(&cbInfo, sizeof(cbInfo));
            cbInfo.cbSize = sizeof(cbInfo);
            hControl = GetDlgItem(hDlg, IDC_COMBO2);
            if (hControl)
            {
                if (GetComboBoxInfo (hControl, &cbInfo))
                {
                    hwndSectionEditControl = cbInfo.hwndItem;
                }
            }

            ZeroMemory(&cbInfo, sizeof(cbInfo));
            cbInfo.cbSize = sizeof(cbInfo);
            hControl = GetDlgItem(hDlg, IDC_COMBO3);
            if (hControl)
            {
                if (GetComboBoxInfo (hControl, &cbInfo))
                {
                    hwndKeyEditControl = cbInfo.hwndItem;
                }
            }

            break;
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_COMBO1:
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lResult = SendDlgItemMessage(hDlg, IDC_COMBO1, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);

                        if (CB_ERR != lResult)
                        {
                            pszFile = (LPTSTR)SendDlgItemMessage(hDlg, IDC_COMBO1, CB_GETITEMDATA, (WPARAM)lResult, (LPARAM)0);

                            if (NULL != pszFile)
                            {
                                AddAllSectionsInCurrentFileToCombo(hDlg, IDC_COMBO2, (LPCTSTR)pszFile);    

                                //
                                //  Choose the first section in the list, don't assert because there may not be any
                                //
                                SendDlgItemMessage(hDlg, IDC_COMBO2, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);
                            }
                        }

                        //
                        //  Note that we don't break here, we fail through to pick up changes for the
                        //  section and keys combo boxes
                        //
                    }
                    else
                    {
                        break;
                    }

                case IDC_COMBO2:
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        CmFree(pszSection);
                        GetCurrentComboSelectionAlloc(hDlg, IDC_COMBO2, &pszSection);

                        AddAllKeysInCurrentSectionToCombo(hDlg, IDC_COMBO3, pszSection, pszFile);

                        //
                        //  Choose the first key in the list, don't assert because there may not be any
                        //
                        SendDlgItemMessage(hDlg, IDC_COMBO3, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);

                    }
                    else if (HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        CmFree(pszSection);
                        if (-1 != GetCurrentEditControlTextAlloc(hwndSectionEditControl, &pszSection))
                        {
                            AddAllKeysInCurrentSectionToCombo(hDlg, IDC_COMBO3, pszSection, pszFile);

                            //
                            //  Choose the first key in the list, don't assert because there may not be any
                            //
                            SendDlgItemMessage(hDlg, IDC_COMBO3, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);
                        }
                        else
                        {
                            break;
                        }
                    }
                    else
                    {
                        //
                        //  Note we don't break if the message is CBN_SELCHANGE or CBN_EDITCHANGE because
                        //  we want to execute the code for the key combo changing
                        //
                        break;
                    }

                case IDC_COMBO3:
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        CmFree(pszKey);
                        GetCurrentComboSelectionAlloc(hDlg, IDC_COMBO3, &pszKey);

                        //
                        //  Fill in the edit control
                        //
                        if (pszKey)
                        {
                            pszValue = GetPrivateProfileStringWithAlloc(pszSection, pszKey, TEXT(""), pszFile);

                            if (pszValue)
                            {
                                SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)0, (LPARAM)pszValue);
                                CmFree(pszValue);
                            }
                            else
                            {
                                SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)0, (LPARAM)TEXT(""));
                            }
                        }
                        else
                        {
                            SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)0, (LPARAM)TEXT(""));
                        }
                    }
                    else if (HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        CmFree(pszKey);
                        if (-1 != GetCurrentEditControlTextAlloc(hwndKeyEditControl, &pszKey))
                        {
                            //
                            //  Fill in the edit control
                            //
                            if (pszKey)
                            {
                                pszValue = GetPrivateProfileStringWithAlloc(pszSection, pszKey, TEXT(""), pszFile);

                                if (pszValue)
                                {
                                    SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)0, (LPARAM)pszValue);
                                    CmFree(pszValue);
                                }
                                else
                                {
                                    SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)0, (LPARAM)TEXT(""));
                                }
                            }
                            else
                            {
                                SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)0, (LPARAM)TEXT(""));
                            }
                        }
                        else
                        {
                            break;
                        }
                    }

                    break;

                case IDC_BUTTON1: // Update Value                    
                    
                    if (RemoveBracketsFromSectionString(&pszSection))
                    {
                        //
                        // Successfully removed brackets. Check if the valid string is empty. If so clear
                        // the fields
                        //
                        if (NULL == pszSection)
                        {
                            //
                            // The section string contained all invalid characters, so clear the combobox
                            //
                            lResult = SendDlgItemMessage(hDlg, IDC_COMBO2, WM_SETTEXT, (WPARAM)0, (LPARAM)TEXT(""));

                            //
                            // Clear the other edit boxes by sending a CBN_EDITCHANGE notification 
                            //
                            lResult= SendMessage(hDlg, WM_COMMAND, (WPARAM)MAKEWPARAM((WORD)IDC_COMBO2,(WORD)CBN_EDITCHANGE), (LPARAM)GetDlgItem(hDlg,IDC_COMBO2));
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("ProcessGeekPane -- Trying to remove brackets from invalid section string."));
                        return 1;
                    }

                    hControl = GetDlgItem(hDlg, IDC_EDIT1);

                    if (hControl)
                    {
                        int iReturn = GetCurrentEditControlTextAlloc(hControl, &pszValue);

                        if (0 == iReturn)
                        {
                            pszValue = NULL; // delete the value
                        }
                        else if (-1 == iReturn)
                        {
                            return 1;
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("ProcessGeekPane -- Unable to get the window handle for the text control."));
                        return 1;
                    }

                    if (NULL == pszSection)
                    {
                        ShowMessage(hDlg, IDS_NEED_SECTION, MB_OK);
                        return 1;
                    }
                    else if (NULL == pszKey)
                    {
                        int iReturn = IDNO;
                        LPTSTR pszMsg = CmFmtMsg(g_hInstance, IDS_DELETE_SECTION, pszSection);
                        
                        if (pszMsg)
                        {
                            iReturn = MessageBox(hDlg, pszMsg, g_szAppTitle, MB_YESNO);

                            CmFree(pszMsg);
                        }

                        if (IDNO == iReturn)
                        {
                            return 1;
                        }

                        //
                        // Need to clear the value in case the section is NULL and the value isn't
                        // even though the WritePrivateProfileString handles it correctly
                        //
                        CmFree(pszValue);
                        pszValue = NULL;
                    }
                    else if (NULL == pszValue)
                    {
                        //
                        // This else if needs to be the last one
                        // The following message should only be displayed 
                        // if NULL != pszKey && NULL != pszSection && NULL == pszValue
                        // Prompt user to ask to delete this key.
                        //
                        int iReturn = IDNO;
                        LPTSTR pszMsg = CmFmtMsg(g_hInstance, IDS_DELETE_KEY, pszKey);
                        
                        if (pszMsg)
                        {
                            iReturn = MessageBox(hDlg, pszMsg, g_szAppTitle, MB_YESNO);

                            CmFree(pszMsg);
                        }

                        if (IDNO == iReturn)
                        {
                            return 1;
                        }
                    }


                    MYVERIFY(0 != WritePrivateProfileString(pszSection, pszKey, pszValue, pszFile));
                    CmFree(pszValue);

                    //
                    //  Make sure to reselect the section and key the user had before (especially important
                    //  if the user just added a new section or file).  First add all of the sections
                    //
                    AddAllSectionsInCurrentFileToCombo(hDlg, IDC_COMBO2, (LPCTSTR)pszFile);    

                    //
                    //  Select the correct section
                    //
                    lResult = SendDlgItemMessage(hDlg, IDC_COMBO2, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pszSection);

                    if (CB_ERR == lResult)
                    {
                        //
                        //  Then the user deleted the value, lets select the first in the list
                        //
                        CmFree(pszSection);
                        SendDlgItemMessage(hDlg, IDC_COMBO2, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);
                        GetCurrentComboSelectionAlloc(hDlg, IDC_COMBO2, &pszSection);
                    }
                    else
                    {
                        SendDlgItemMessage(hDlg, IDC_COMBO2, CB_SETCURSEL, (WPARAM)lResult, (LPARAM)0);
                    }

                    //
                    //  Now add all of the keys in that section
                    //
                    AddAllKeysInCurrentSectionToCombo(hDlg, IDC_COMBO3, pszSection, pszFile);

                    //
                    //  Select the correct key
                    //
                    lResult = SendDlgItemMessage(hDlg, IDC_COMBO3, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pszKey);

                    if (CB_ERR == lResult)
                    {
                        //
                        //  Then the user deleted the value, lets select the first in the list
                        //
                        CmFree(pszKey);
                        SendDlgItemMessage(hDlg, IDC_COMBO3, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);
                        GetCurrentComboSelectionAlloc(hDlg, IDC_COMBO3, &pszKey);

                        lResult = 0;
                    }
                    else
                    {
                        SendDlgItemMessage(hDlg, IDC_COMBO3, CB_SETCURSEL, (WPARAM)lResult, (LPARAM)0);
                    }

                    //
                    //  Fill in the edit control, since the user may have deleted the last selection
                    //
                    pszValue = GetPrivateProfileStringWithAlloc(pszSection, pszKey, TEXT(""), pszFile);

                    if (pszValue)
                    {
                        SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)0, (LPARAM)pszValue);
                        CmFree(pszValue);
                    }
                    else
                    {
                        SendDlgItemMessage(hDlg, IDC_EDIT1, WM_SETTEXT, (WPARAM)0, (LPARAM)TEXT(""));
                    }

                    break;

                default:
                    break;
            }
            break;

        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    //
                    //  Free up any allocated values.  If you add new values to free here, also
                    //  make sure to add them in the cancel case.
                    //
                    CmFree(pszSection);
                    pszSection = NULL;
                    CmFree(pszKey);
                    pszKey = NULL;

                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));
                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                    break;

                case PSN_WIZBACK:
                    CMASSERTMSG(FALSE, TEXT("There shouldn't be a back button on the Geek Pane, why are we getting PSN_WIZBACK?"));
                    break;

                case PSN_WIZNEXT:

                    if (BuildProfileExecutable(hDlg))
                    {
                        dwFinishPage = g_bIEAKBuild ? IDD_IEAK_FINISH_GOOD_BUILD : IDD_FINISH_GOOD_BUILD;
                    }
                    else
                    {
                        dwFinishPage = IDD_FINISH_BAD_BUILD;
                    }

                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, dwFinishPage));                        
                    return 1;

                    break;
            }

            break;

        default:
            return FALSE;
    }
    return FALSE;   
}

//+----------------------------------------------------------------------------
//
// Function:  BuildProfileExecutable
//
// Synopsis:  This function takes care of all of the details of turning the 
//            CMAK files in the temp dir into a profile executable.
//
// Arguments: HWND hDlg - window handle of the calling dialog
//
// Returns:   BOOL - TRUE if the profile built successfully, FALSE otherwise
//
// History:   quintinb  Created     05/17/00
//
//+----------------------------------------------------------------------------
BOOL BuildProfileExecutable(HWND hDlg)
{
    DWORD dwExitCode = 0;
    DWORD dwWaitCode = 0;
    BOOL bExitLoop = FALSE;
    BOOL bEnoughSpaceToCompress;
    SHELLEXECUTEINFO seiInfo;
    static HANDLE hProcess = NULL;
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szMsg[MAX_PATH+1];
    TCHAR pszArgs[MAX_PATH+1];
    BOOL bRes;

    //
    //  The user may have unchecked UsePresharedKey for all VPN settings, in
    //  which case we need to remove the pre-shared key.
    //
    g_bPresharedKeyNeeded = DoesSomeVPNsettingUsePresharedKey();
    if (FALSE == g_bPresharedKeyNeeded)
    {
        // remove the Pre-shared key values from the CMP
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryPresharedKey, NULL, g_szCmpFile));
        MYVERIFY(0 != WritePrivateProfileString(c_pszCmSection, c_pszCmEntryKeyIsEncrypted, NULL, g_szCmpFile));
    }

    if (!CopyFromTempDir(g_szShortServiceName))
    {
        return FALSE;
    }

    //
    //  Write the SED File.
    //  Note that the SED file has been moved from the temp dir to
    //  the profile dir.  We now want to write the SED file entries
    //  in place before compressing them.  This way we can verify the
    //  files exist right before compressing them.
    //

    MYVERIFY(CELEMS(g_szSedFile) > (UINT)wsprintf(g_szSedFile, TEXT("%s%s\\%s.sed"), 
        g_szOsdir, g_szShortServiceName, g_szShortServiceName));
    if (!ConstructSedFile(hDlg, g_szSedFile, g_szOutExe))
    {
        return FALSE;                    
    }

    _tcscpy(g_szOutdir, g_szOsdir);
    _tcscat(g_szOutdir, g_szShortServiceName);

    //
    // Setup IExpress to build in the output directory. 
    //
    
    MYVERIFY(0 != SetCurrentDirectory(g_szOutdir));

    //
    //  Check to make sure there is enough disk space
    //

    do
    {
        bEnoughSpaceToCompress = CheckDiskSpaceForCompression(g_szSedFile);
        if (!bEnoughSpaceToCompress)
        {

            MYVERIFY(0 != LoadString(g_hInstance, IDS_DISKFULL, szTemp, MAX_PATH));
            MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szTemp, g_szOutdir));

            int iMessageReturn = MessageBox(hDlg, szMsg, g_szAppTitle, MB_RETRYCANCEL | MB_ICONERROR 
                | MB_APPLMODAL );

            if (iMessageReturn == IDCANCEL)
            {
                return FALSE;
            }
        }
    
    } while(!bEnoughSpaceToCompress);
    
    MYVERIFY(CELEMS(pszArgs) > (UINT)wsprintf(pszArgs, TEXT("/N %s.sed"), 
        g_szShortServiceName));

    _tcscpy(szTemp, TEXT("iexpress.exe"));

    ZeroMemory(&seiInfo,sizeof(seiInfo));
    seiInfo.cbSize = sizeof(seiInfo);
    seiInfo.fMask |= SEE_MASK_FLAG_NO_UI | SEE_MASK_NOCLOSEPROCESS;
    seiInfo.lpFile = szTemp;
    seiInfo.lpDirectory = g_szOutdir;
    seiInfo.lpParameters = pszArgs;
    seiInfo.nShow = SW_HIDE;

    //
    //  Okay, we are finally ready to execute IExpress, lets disable all the
    //  wizard buttons.
    //
    DisableWizardButtons(hDlg);

    //
    // Execute IExpress
    //

    bRes = ShellExecuteEx(&seiInfo);

    //
    //  Wait for the shellexecute to finish.  Thus our cleanup code doesn't
    //  execute till IEpress is done.
    //
    
    if (bRes)
    {
        //
        //  hProcess contains the handle to the process
        //
        hProcess = seiInfo.hProcess;

        do
        {
            dwWaitCode = MsgWaitForMultipleObjects(1, &hProcess, FALSE, INFINITE, QS_ALLINPUT);
            
            //
            //  Check to see if we returned because of a message, process termination,
            //  or an error.
            //
            switch(dwWaitCode)
            {

            case 0:

                //
                //  Normal termination case, we were signaled that the process ended
                //
                
                bExitLoop = TRUE;
                break;

            case 1:

                HandleWindowMessagesWhileCompressing();
                                             
                break;

            case -1:

                //
                //  MsgWait returned an error
                //

                MYVERIFY(0 != GetExitCodeProcess(seiInfo.hProcess, &dwExitCode));

                if (dwExitCode == STILL_ACTIVE)
                {
                    continue;
                }
                else
                {
                    bExitLoop = TRUE;
                }

                break;

            default:
                //
                //  Do nothing
                //
                break;
            }

        } while (!bExitLoop);
    }

    //
    //  now need to send the user to the finish page.  If their profile
    //  build successfully then we send them to the success page, otherwise
    //  we send them to the bad build page.
    //

    MYVERIFY(0 != GetExitCodeProcess(seiInfo.hProcess, &dwExitCode));

    if (dwExitCode)
    {
        g_iCMAKReturnVal = CMAK_RETURN_ERROR;

        //
        //  We encountered an error, clear the out exe val
        //  so that we write nothing to the output key.
        //
        ZeroMemory(g_szOutExe, sizeof(g_szOutExe));
    }
    else
    {
        g_iCMAKReturnVal = CMAK_RETURN_SUCCESS;
    }

    CloseHandle(seiInfo.hProcess);

    //
    // Create a registry entry for IEAK to retrieve 
    // the path of the output profile.
    //

    MYVERIFY(FALSE != WriteRegStringValue(HKEY_LOCAL_MACHINE, c_pszRegCmak, c_pszRegOutput, g_szOutExe));

    //
    //  CMAK_RETURN_ERROR is -1, so return TRUE if g_iCMAKReturnVal is a positive integer
    //
    return (g_iCMAKReturnVal > 0);
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessBuildProfile
//
// Synopsis:  Processes windows messages for the page in CMAK that allows the
//            user to build their profile or advance to the Advanced Customization
//            page to make final edits before building the profile.
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//
//  Specify the installation package location
//
// Arguments: WND hDlg - 
//            UINT message - 
//            WPARAM wParam - 
//            LPARAM lParam - 
//
// Returns:   INT_PTR APIENTRY - 
//
// History:   a-anasj restructured the function and Created Header    1/7/98
//          note: the function does not allow the user to choose a location for 
//          their profile anylonger. It only informs them of where it will be
//          created.
//            quintinb      Renamed from the feared ProcessPage8   8-6-98
//            quintinb      restructured for Whistler 108269       05/17/00
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessBuildProfile(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szTemp[MAX_PATH+1];
    int iMessageReturn;
    NMHDR* pnmHeader = (NMHDR*)lParam;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_CREATE)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;

    switch (message)
    {
        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_KILLACTIVE:
                    
                    MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, FALSE));
                    return 1;
                    break;  //lint !e527 this line isn't reachable but 
                            //  keep it in case the return is removed

                case PSN_SETACTIVE:
                    //
                    // Build default path of final executable 
                    //
                    MYVERIFY(CELEMS(g_szOutExe) > (UINT)wsprintf(g_szOutExe, TEXT("%s%s\\%s.exe"), 
                        g_szOsdir, g_szShortServiceName, g_szShortServiceName));

                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_BACK | PSWIZB_NEXT));
                    break;

                case PSN_WIZBACK:
                    break;

                case PSN_WIZNEXT:

                    //
                    // Ensure that profile directory exists
                    //
                    _tcscpy(szTemp,g_szOsdir);
                    _tcscat(szTemp,g_szShortServiceName);
                    
                    if (0 == SetCurrentDirectory(szTemp))
                    {
                        MYVERIFY(0 != CreateDirectory(szTemp,NULL));
                    }
                    
                    //
                    //  Prompt the user to overwrite the existing Executable
                    //
                    if (FileExists(g_szOutExe))
                    {
                        iMessageReturn = ShowMessage(hDlg, IDS_OVERWRITE, MB_YESNO);

                        if (iMessageReturn == IDNO)
                        {   
                            MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                            return 1;
                        }
                    }

                    //
                    //  Write out the Inf File
                    //
                    if (!WriteInfFile(g_hInstance, hDlg, g_szInfFile, g_szLongServiceName))
                    {
                        CMASSERTMSG(FALSE, TEXT("ProcessBuildProfile -- WriteInfFile Failed."));
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                        return 1;
                    }
                    
                    //
                    // Update version in CMP and party on the CMS 
                    //

                    WriteCMPFile();

                    if (!WriteCMSFile())
                    {
                        FileAccessErr(hDlg, g_szCmsFile);
                        
                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, -1));
                        return 1;
                    }

                    //
                    //  If the user wants to do advanced customization, delay building the profile executable
                    //  until after they have done their final edits.  Otherwise, it is time to build the profile!
                    //
                    if (BST_UNCHECKED == IsDlgButtonChecked(hDlg, IDC_ADVANCED))
                    {
                        //
                        //  The user is finished now, lets build the profile and skip over the advanced customization
                        //  page to either the bad build page or the successful build page.
                        //
                        DWORD dwFinishPage;

                        if (BuildProfileExecutable(hDlg))
                        {
                            dwFinishPage = g_bIEAKBuild ? IDD_IEAK_FINISH_GOOD_BUILD : IDD_FINISH_GOOD_BUILD;
                        }
                        else
                        {
                            dwFinishPage = IDD_FINISH_BAD_BUILD;
                        }

                        MYVERIFY(FALSE != SetWindowLongWrapper(hDlg, DWLP_MSGRESULT, dwFinishPage));
                        return 1;
                    }

                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}





//+----------------------------------------------------------------------------
//
// Function:  ProcessFinishPage
//
// Synopsis:  Handles the finish page
//
// Arguments: WND hDlg - 
//            UINT message - 
//            WPARAM wParam - 
//            LPARAM lParam - 
//
// Returns:   INT_PTR APIENTRY - 
//
// History:   quintinb created    6/25/98
//
//+----------------------------------------------------------------------------
INT_PTR APIENTRY ProcessFinishPage(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{   
    HWND hDirEditControl;
    HWND hCurrentPage;
    NMHDR* pnmHeader = (NMHDR*)lParam;

    ProcessBold(hDlg,message);
    if (ProcessHelp(hDlg, message, wParam, lParam, IDH_FINISH)) return TRUE;
    if (ProcessCancel(hDlg,message,lParam)) return TRUE;
    SetDefaultGUIFont(hDlg,message,IDC_EDITDIR);
    
    switch (message)
    {
        case WM_NOTIFY:

            if (NULL == pnmHeader)
            {
                return FALSE;
            }

            switch (pnmHeader->code)
            {

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_FINISH));
                    
                    //
                    //  Disable the cancel button since it doesn't make a whole lot of
                    //  sense on the last dialog.
                    //
                    
                    hCurrentPage = GetParent(hDlg);
                    if (hCurrentPage)
                    {
                        HWND hCancelButton = GetDlgItem(hCurrentPage, IDCANCEL);
                    
                        if (hCancelButton)
                        {
                            EnableWindow(hCancelButton, FALSE);
                        }
                    }
                    
                    //
                    //  Fill in the path edit control.  Note that this control doesn't exist if
                    //  this is an IEAK build.
                    //
                    if (hDirEditControl = GetDlgItem(hDlg, IDC_EDITDIR))
                    {
                        MYVERIFY(TRUE == SendMessage(hDirEditControl, WM_SETTEXT, 0, 
                            (LPARAM)g_szOutExe));                    
                    }

                    break;

                case PSN_WIZFINISH:
            
                    //
                    // Now that we know we aren't returning, we can release 
                    // the temp dir and cleanup our files lists
                    //
                        ClearCmakGlobals();
                        FreeList(&g_pHeadProfile, &g_pTailProfile);
            
                    break;

                default:
                    return FALSE;

            }
            break;

        default:
            return FALSE;
    }
    return TRUE;   
}


//
//
//  FUNCTION: FillInPropertyPage(PROPSHEETPAGE *, int, LPTSTR, LPFN) 
//
//  PURPOSE: Fills in the given PROPSHEETPAGE structure 
//
//  COMMENTS:
//
//      This function fills in a PROPSHEETPAGE structure with the
//      information the system needs to create the page.
// 
void FillInPropertyPage( PROPSHEETPAGE* psp, int idDlg, DLGPROC pfnDlgProc)
{
    psp->dwSize = sizeof(PROPSHEETPAGE);
    psp->dwFlags = PSP_HASHELP;
    psp->hInstance = g_hInstance;
    psp->pszTemplate = MAKEINTRESOURCE(idDlg);
    psp->pszIcon = NULL;
    psp->pfnDlgProc = pfnDlgProc;
    psp->pszTitle = TEXT("");
    psp->lParam = 0;

}

//+----------------------------------------------------------------------------
//
// Function:  CreateWizard
//
// Synopsis:  This function creates the wizard pages that make up CMAK.
//
// Arguments: HWND hwndOwner - window handle of the owner of this wizard
//
// Returns:   int - A positive value if successful, -1 otherwise
//
// History:   quintinb Created Header    1/5/98
//            quintinb removed hInst from prototype, not used 1/5/98
//
//+----------------------------------------------------------------------------
INT_PTR CreateWizard(HWND hwndOwner)
{
    PROPSHEETPAGE psp[28]; 
    PROPSHEETHEADER psh;

    FillInPropertyPage( &psp[0], IDD_WELCOME, ProcessWelcome);
    FillInPropertyPage( &psp[1], IDD_ADD_EDIT_PROFILE, ProcessAddEditProfile);
    FillInPropertyPage( &psp[2], IDD_SERVICENAME, ProcessServiceName);
    FillInPropertyPage( &psp[3], IDD_REALM_INFO, ProcessRealmInfo);
    FillInPropertyPage( &psp[4], IDD_MERGEDPROFILES, ProcessMergedProfiles);
    FillInPropertyPage( &psp[5], IDD_TUNNELING, ProcessTunneling);
    FillInPropertyPage( &psp[6], IDD_VPN_ENTRIES, ProcessVpnEntries);
    FillInPropertyPage( &psp[7], IDD_PRESHARED_KEY, ProcessPresharedKey);
    FillInPropertyPage( &psp[8], IDD_PHONEBOOK, ProcessPhoneBook);        // Phonebook Setup
    FillInPropertyPage( &psp[9], IDD_PBK_UPDATE, ProcessPhoneBookUpdate);  // Phonebook Updates
    FillInPropertyPage( &psp[10], IDD_DUN_ENTRIES, ProcessDunEntries);
    FillInPropertyPage( &psp[11], IDD_ROUTE_PLUMBING, ProcessRoutePlumbing);
    FillInPropertyPage( &psp[12], IDD_CMPROXY, ProcessCmProxy);
    FillInPropertyPage( &psp[13], IDD_CUSTOM_ACTIONS , ProcessCustomActions);    // Setup Connect Actions
    FillInPropertyPage( &psp[14], IDD_SIGNIN_BITMAP, ProcessSigninBitmap);        // Sign-in Bitmap
    FillInPropertyPage( &psp[15], IDD_PBK_BITMAP, ProcessPhoneBookBitmap);        // Phonebook Bitmap
    FillInPropertyPage( &psp[16], IDD_ICONS, ProcessIcons);        // Icons  
    FillInPropertyPage( &psp[17], IDD_STATUS_MENU, ProcessStatusMenuIcons);    // Status area menu items   
    FillInPropertyPage( &psp[18], IDD_CUSTOM_HELP, ProcessCustomHelp);        // Help
    FillInPropertyPage( &psp[19], IDD_SUPPORT_INFO, ProcessSupportInfo);    
    FillInPropertyPage( &psp[20], IDD_INCLUDE_CM, ProcessIncludeCm);  // Include CM, note this doesn't show on IA64
    FillInPropertyPage( &psp[21], IDD_LICENSE, ProcessLicense);  // License agreement
    FillInPropertyPage( &psp[22], IDD_ADDITIONAL, ProcessAdditionalFiles);  // Additional files
    FillInPropertyPage( &psp[23], IDD_BUILDPROFILE, ProcessBuildProfile);        // Build the profile
    FillInPropertyPage( &psp[24], IDD_GEEK_PANE, ProcessGeekPane);        // Advance customization
    FillInPropertyPage( &psp[25], IDD_FINISH_GOOD_BUILD, ProcessFinishPage);        // Finish Page -- Good Build
    FillInPropertyPage( &psp[26], IDD_IEAK_FINISH_GOOD_BUILD, ProcessFinishPage);        // Finish Page -- Good Build
    FillInPropertyPage( &psp[27], IDD_FINISH_BAD_BUILD, ProcessFinishPage);        // Finish Page -- Bad Build

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.pszCaption = (LPTSTR) TEXT("");
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.nStartPage = 0;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp; //lint !e545  Disables line error 545 for this line only

    return (PropertySheet(&psh));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\profwiz\profwiz.h ===
//+----------------------------------------------------------------------------
//
// File:     profwiz.h
//
// Module:   CMAK.EXE
//
// Synopsis: Main include file for CMAK
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   quintinb   Created      08/06/98
//
//+----------------------------------------------------------------------------
#ifndef _CMAK_H
#define _CMAK_H

//
//  System Includes
//
#include <windows.h>    // includes basic windows functionality
#include <commdlg.h>
#include "commctrl.h"
#include <cderr.h>
#include <shellapi.h>
#include <objbase.h>
#include <string.h>     // includes the string functions
#include <prsht.h>      // includes the property sheet functionality
#include <stdio.h>
#include <mbstring.h>
#include <tchar.h>
#include <htmlhelp.h>

#include <ras.h>
#include <raseapif.h>

//
//  Constants for CMAK return Codes
//
const int CMAK_RETURN_ERROR = -1;
const int CMAK_RETURN_SUCCESS = 1;
const int CMAK_RETURN_CANCEL = 0;
const DWORD MAX_LONG_SERVICE_NAME_LENGTH = 63;
const DWORD MAX_SHORT_SERVICE_NAME_LENGTH = 8;
const TCHAR* const c_pszCmakOpsChm = TEXT("cmak_ops.chm");

//
//  Types
//

typedef struct IconMenuStruct {
    TCHAR szName[MAX_PATH+1];
    TCHAR szProgram[MAX_PATH+1];
    TCHAR szParams[MAX_PATH+1];
    struct IconMenuStruct * next;
    BOOL bDoCopy;
}IconMenu;

typedef struct ExtraDataStruct {
    TCHAR szName[MAX_PATH+1];
    TCHAR szPathname[MAX_PATH+1];
}ExtraData;

typedef struct RenameDataStruct {
    TCHAR szShortName[MAX_PATH+1];
    TCHAR szLongName[MAX_PATH+1];
}RenameData;

typedef struct ListBxStruct {
    TCHAR szName[MAX_PATH+1];
    void * ListBxData;
    struct ListBxStruct * next;
}ListBxList;

//
//  Our includes
//
#include "util.h"
#include "customaction.h" // Custom action List class
#include "netsettings.h" // network (DUN) settings functions
#include "listview.h" // code to help with the custom action list view control
#include "resource.h"   // includes the definitions for the resources

#include "base_str.h" 
#include "dl_str.h" 
#include "mgr_str.h" 
#include "pbk_str.h" 
#include "mon_str.h" 
#include "stp_str.h" 
#include "inf_str.h"
#include "tunl_str.h"
#include "profile_str.h"
#include "conact_str.h"
#include "dun_str.h"
#include "reg_str.h"
#include "ver_str.h"
#include "wiz_str.h"
#include "pwd_str.h"

#include "cmdebug.h"
#include "cmsetup.h"
#include "cmakui.h"     // HELP context IDs for the HTML help topics.
#include "bmpimage.h"
#include "cmakreg.h"

//
// Function Headers
//
DWORD RegisterBitmapClass(HINSTANCE hInst);
void QS_WritePrivateProfileString(LPCTSTR pszSection, LPCTSTR pszItem, LPTSTR entry, LPCTSTR inifile);
BOOL ReferencedDownLoad(void);  // function to tell if referenced profiles contain download info
void CopyNonLocalProfile(LPCTSTR pszName, LPCTSTR pszExistingProfileDir);
void GetFileName(LPCTSTR lpPath,LPTSTR lpFileName);
LPTSTR GetName(LPCTSTR lpPath); // get filename and return in static string
BOOL GetShortFileName(LPTSTR lpFile,LPTSTR lpShortName);
BOOL WriteCopy(HANDLE hInf, LPTSTR lpFile, BOOL bWriteShortName);
BOOL WriteInfLine(HANDLE hInf,LPTSTR lpFile);
BOOL WriteSrcInfLine(HANDLE hInf,LPTSTR lpFile);
BOOL WriteSED(HWND hDlg, LPTSTR szFullFilePath, LPINT pFileNum, LPCTSTR szSed);
BOOL createListBxRecord(ListBxList ** HeadPtrListBx,ListBxList ** TailPtrListBx,void * pDnsData, DWORD dwSize, LPCTSTR lpName);
void DeleteListBxRecord(ListBxList ** HeadPtrListBx,ListBxList ** TailPtrListBx, LPTSTR lpName);

BOOL IsFile8dot3(LPTSTR pszFileName);
LRESULT GetTextFromControl(IN HWND hDlg, IN int nCtrlId, OUT LPTSTR pszCharBuffer, IN DWORD dwCharInBuffer, BOOL bDisplayError);
BOOL VerifyFile(HWND hDlg, DWORD ctrlID, LPTSTR lpFile, BOOL ShowErr);

void RefreshComboList(HWND hwndDlg, ListBxList * HeadPtr);
int DoBrowse(HWND hDlg, UINT* pFilterArray, LPTSTR* pMaskArray, UINT uNumFilters, int IDC_EDIT, LPCTSTR lpDefExt, LPTSTR lpFile);
BOOL GetLangFromInfTemplate(LPCTSTR szFullInfPath, OUT LPTSTR pszLanguageDisplayName, IN int iCharsInBuffer);
BOOL CreateMergedProfile(void);
void FreeList(ListBxList ** pHeadPtr, ListBxList ** pTailPtr);
void CheckNameChange(LPTSTR lpold, LPTSTR lpnew);
BOOL FindListItemByName(LPTSTR lpName, ListBxList * pHeadOfList, ListBxList** pFoundItem);
void RefreshList(HWND hwndDlg, UINT uCrtlId, ListBxList * HeadPtr);
BOOL WriteInf(HANDLE hInf,LPCTSTR str);
void FreeIconMenu();
BOOL ReadIconMenu(LPCTSTR pszCmsFile, LPCTSTR pszProfilesDir);

BOOL SetWindowLongWrapper(HWND hWnd, int nIndex, LONG dwNewLong);
BOOL CopyFileWrapper(LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, BOOL bFailIfExists);
BOOL CheckDiskSpaceForCompression (LPCTSTR szSedFile);
int GetFilePath(LPCTSTR lpFullPath, LPTSTR lpPath);

BOOL GetIconMenuItem(LPTSTR lpName,IconMenu * EditItem);
void ClearCmakGlobals(void);
BOOL RenameSection(LPCTSTR szCurrentSectionName, LPCTSTR szNewSectionName, LPCTSTR szFile);
BOOL WriteRegStringValue(HKEY hBaseKey, LPCTSTR pszKeyName, LPCTSTR pszValueName, LPCTSTR pszValueToWrite);
int ShowMessage(HWND hDlg, UINT strID, UINT mbtype);
INT_PTR APIENTRY ProcessCustomActionPopup(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CreateWizard(HWND);
void FillInPropertyPage(PROPSHEETPAGE* , int, DLGPROC);
INT_PTR APIENTRY ProcessHelp(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, DWORD_PTR dwHelpId);
void SetDefaultGUIFont(HWND hDlg, UINT message, int ctlID);
BOOL FindSwitchInString(LPCTSTR pszStringToSearch, LPCTSTR pszSwitchToFind, BOOL bReturnNextToken, LPTSTR pszToken);
HRESULT BuildCustomActionParamString(LPTSTR* aArrayOfStrings, UINT uCountOfStrings, LPTSTR* ppszParamsOutput);
LPTSTR GetPrivateProfileStringWithAlloc(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszDefault, LPCTSTR pszFile);
int GetCurrentEditControlTextAlloc(HWND hEditText, LPTSTR* ppszText);
BOOL BuildProfileExecutable(HWND hDlg);
BOOL RemoveBracketsFromSectionString(LPTSTR *ppszSection);

//
//  Routines written to upgrade an inf.  Called from CopyToTempDir
//

int GetInfVersion(LPTSTR szFullPathToInfFile);
BOOL UpgradeInf(LPCTSTR szRenamedInfFile, LPCTSTR szFullPathToInfFile);
BOOL WriteInfVersion(LPTSTR szFullPathToInfFile, int iVersion = PROFILEVERSION);

//
//  externs
//
extern CustomActionList* g_pCustomActionList;
extern HINSTANCE g_hInstance;
extern TCHAR g_szAppTitle[MAX_PATH+1];
extern TCHAR g_szOsdir[MAX_PATH+1];

#endif //_CMAK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\profwiz\util.h ===
//+----------------------------------------------------------------------------
//
// File:     util.h
//
// Module:   CMAK.EXE
//
// Synopsis: CMAK Utility function definitions
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   quintinb   Created     03/27/00
//
//+----------------------------------------------------------------------------

int GetTunnelDunSettingName(LPCTSTR pszCmsFile, LPCTSTR pszLongServiceName, LPTSTR pszTunnelDunName, UINT uNumChars);
int GetDefaultDunSettingName(LPCTSTR pszCmsFile, LPCTSTR pszLongServiceName, LPTSTR pszDefaultDunName, UINT uNumChars);
LPTSTR GetPrivateProfileSectionWithAlloc(LPCTSTR pszSection, LPCTSTR pszFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\profwiz\util.cpp ===
//+----------------------------------------------------------------------------
//
// File:     util.cpp
//
// Module:   CMAK.EXE
//
// Synopsis: CMAK Utility functions
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   quintinb   Created     03/27/00
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//+----------------------------------------------------------------------------
//
// Function:  GetTunnelDunSettingName
//
// Synopsis:  This function retrieves the name of the Tunnel DUN setting.  If
//            the tunnel dun setting key isn't set then the name of the default
//            tunnel DUN setting is returned.
//
// Arguments: LPCTSTR pszCmsFile - full path to the cms file to get the name from
//            LPCTSTR pszLongServiceName - long service name of the profile
//            LPTSTR pszTunnelDunName - buffer to return the tunnel dun name in
//            UINT uNumChars - number of characters in the output buffer
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
int GetTunnelDunSettingName(LPCTSTR pszCmsFile, LPCTSTR pszLongServiceName, LPTSTR pszTunnelDunName, UINT uNumChars)
{
    int iReturn;

    if (pszCmsFile && pszLongServiceName && pszTunnelDunName && uNumChars)
    {
        pszTunnelDunName[0] = TEXT('\0');

        iReturn = GetPrivateProfileString(c_pszCmSection, c_pszCmEntryTunnelDun, TEXT(""), pszTunnelDunName, uNumChars, pszCmsFile); //lint !e534

        if (TEXT('\0') == pszTunnelDunName[0])
        {
            MYVERIFY(uNumChars > (UINT)wsprintf(pszTunnelDunName, TEXT("%s %s"), pszLongServiceName, c_pszCmEntryTunnelPrimary));
            iReturn = lstrlen(pszTunnelDunName);
        }
    }
    else
    {
        iReturn = 0;
        CMASSERTMSG(FALSE, TEXT("GetTunnelDunSettingName -- invalid parameter."));
    }

    return iReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetDefaultDunSettingName
//
// Synopsis:  This function retrieves the name of the default DUN setting.  If
//            the default dun setting key isn't set then the default name of the
//            default DUN setting is returned.
//
// Arguments: LPCTSTR pszCmsFile - full path to the cms file to get the name from
//            LPCTSTR pszLongServiceName - long service name of the profile
//            LPTSTR pszDefaultDunName - buffer to return the default dun name in
//            UINT uNumChars - number of characters in the output buffer
//
// History:   quintinb Created     03/27/00
//
//+----------------------------------------------------------------------------
int GetDefaultDunSettingName(LPCTSTR pszCmsFile, LPCTSTR pszLongServiceName, LPTSTR pszDefaultDunName, UINT uNumChars)
{
    int iReturn;

    if (pszCmsFile && pszLongServiceName && pszDefaultDunName && uNumChars)
    {
        pszDefaultDunName[0] = TEXT('\0');

        iReturn = GetPrivateProfileString(c_pszCmSection, c_pszCmEntryDun, TEXT(""), pszDefaultDunName, uNumChars, pszCmsFile); //lint !e534

        if (TEXT('\0') == pszDefaultDunName[0])
        {
            lstrcpyn(pszDefaultDunName, pszLongServiceName, uNumChars);
            iReturn = lstrlen(pszDefaultDunName);
        }
    }
    else
    {
        iReturn = 0;
        CMASSERTMSG(FALSE, TEXT("GetDefaultDunSettingName -- invalid parameter."));
    }

    return iReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetPrivateProfileSectionWithAlloc
//
// Synopsis:  This function returns the section requested just as 
//            GetPrivateProfileSection does, but it automatically sizes the buffer
//            and allocates it for the caller.  The caller is responsible for
//            freeing the returned buffer.
//
// Arguments: LPCTSTR pszSection - section to get
//            LPCTSTR pszFile - file to get it from
//
// Returns:   LPTSTR -- requested section or NULL on an error
//
//
// History:   quintinb Created     10/28/00
//
//+----------------------------------------------------------------------------
LPTSTR GetPrivateProfileSectionWithAlloc(LPCTSTR pszSection, LPCTSTR pszFile)
{
    if ((NULL == pszSection) || (NULL == pszFile))
    {
        CMASSERTMSG(FALSE, TEXT("GetPrivateProfileSectionWithAlloc -- NULL pszSection or pszFile passed"));
        return NULL;
    }

    BOOL bExitLoop = FALSE;
    DWORD dwSize = MAX_PATH;
    DWORD dwReturnedSize;
    LPTSTR pszStringToReturn = (TCHAR*)CmMalloc(dwSize*sizeof(TCHAR));

    do
    {
        MYDBGASSERT(pszStringToReturn);

        if (pszStringToReturn)
        {
            dwReturnedSize = GetPrivateProfileSection(pszSection, pszStringToReturn, dwSize, pszFile);

            if (dwReturnedSize == (dwSize - 2))
            {
                //
                //  The buffer is too small, lets allocate a bigger one
                //
                dwSize = 2*dwSize;
                if (dwSize > 1024*1024)
                {
                    CMASSERTMSG(FALSE, TEXT("GetPrivateProfileSectionWithAlloc -- Allocation above 1MB, bailing out."));
                    CmFree(pszStringToReturn);
                    pszStringToReturn = NULL;
                    goto exit;
                }

                pszStringToReturn = (TCHAR*)CmRealloc(pszStringToReturn, dwSize*sizeof(TCHAR));

            }
            else if (0 == dwReturnedSize)
            {
                //
                //  Either we got an error, or more likely there was no data to get
                //
                CmFree(pszStringToReturn);
                pszStringToReturn = NULL;
                goto exit;
            }
            else
            {
                bExitLoop = TRUE;
            }
        }
        else
        {
           goto exit; 
        }

    } while (!bExitLoop);

exit:
    return pszStringToReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\profwiz\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by profwiz.rc
//
#define EXE_ICON                        101
#define IDI_WARNING_ICON                104
#define IDI_CRITSTOP_ICON               105
#define IDI_UP_ARROW                    106
#define IDI_UP_ARROW_DIS                107
#define IDD_WELCOME                     108
#define IDD_SERVICENAME                 109
#define IDD_SIGNIN_BITMAP               110
#define IDD_PBK_BITMAP                  111
#define IDI_DOWN_ARROW                  112
#define IDD_ICONS                       113
#define IDI_DOWN_ARROW_DIS              114
#define IDD_PHONEBOOK                   115
#define IDD_CUSTOM_HELP                 116
#define IDD_BUILDPROFILE                118
#define IDD_INCLUDE_CM                  121
#define IDD_REALM_INFO                  122
#define IDD_DUN_ENTRIES                 123
#define IDD_VPN_ENTRIES                 124
#define IDD_TUNNELING                   125
#define IDD_LCIDS_DONT_MATCH_POPUP      126
#define IDD_PRESHARED_KEY               127
#define IDD_CUSTOM_ACTIONS_POPUP        128
#define IDD_PBK_UPDATE                  129
#define IDD_MERGEDPROFILES              130
#define IDD_STATUS_MENU                 131
#define IDD_MENU_ITEM_POPUP             132
#define IDD_LICENSE                     134
#define IDD_ADDITIONAL                  135
#define IDD_SUPPORT_INFO                137
//#define                                 138
//#define                                 139
#define IDD_FINISH_GOOD_BUILD           143
#define IDD_FINISH_BAD_BUILD            144
#define IDD_IEAK_FINISH_GOOD_BUILD      145
//#define                               146
//#define                               147
//#define                               148
#define IDD_EULA                        149
//#define                               150
//#define                               151
//#define                               152
//#define                               153
//#define                               154
//#define                               155
//#define                               156
#define IDD_ADD_EDIT_PROFILE            157

#define IDM_CA_ADD                      200
#define IDM_CA_EDIT                     201
#define IDM_CA_DELETE                   202
#define IDM_CA_MOVE_UP                  203
#define IDM_CA_MOVE_DOWN                204

#define IDM_CA_FULL                     205
#define IDM_CA_NO_UP                    206
#define IDM_CA_NO_DOWN                  207
#define IDM_CA_NO_MOVE                  208
#define IDM_CA_ADD_ONLY                 209
#define IDM_CA_ADD_MOVEUP               210
#define IDM_CA_ADD_MOVEDOWN             211
#define IDM_CA_ADD_MOVEUPORDOWN         212

#define IDS_ALLCONACT                   499
#define BASE_ACTION_STRING_ID           500
#define IDS_PREINIT                     (BASE_ACTION_STRING_ID + 0)
#define IDS_PRECONNECT                  (BASE_ACTION_STRING_ID + 1)
#define IDS_PREDIAL                     (BASE_ACTION_STRING_ID + 2)
#define IDS_PRETUNNEL                   (BASE_ACTION_STRING_ID + 3)
#define IDS_ONCONNECT                   (BASE_ACTION_STRING_ID + 4)
#define IDS_ONINTCONNECT                (BASE_ACTION_STRING_ID + 5)
#define IDS_ONDISCONNECT                (BASE_ACTION_STRING_ID + 6)
#define IDS_ONCANCEL                    (BASE_ACTION_STRING_ID + 7)
#define IDS_ONERROR                     (BASE_ACTION_STRING_ID + 8)

#define BASE_EXECUTION_STRING_ID        550
#define IDS_ALL_CONNECTIONS             (BASE_EXECUTION_STRING_ID + 0)
#define IDS_ALL_DIALUP                  (BASE_EXECUTION_STRING_ID + 1)
#define IDS_ALL_TUNNEL                  (BASE_EXECUTION_STRING_ID + 2)
#define IDS_DIRECT_ONLY                 (BASE_EXECUTION_STRING_ID + 3)
#define IDS_DIALUP_ONLY                 (BASE_EXECUTION_STRING_ID + 4)

#define IDS_DESC_COL_TITLE              560
#define IDS_TYPE_COL_TITLE              561
#define IDS_PROGRAM_COL_TITLE           562

#define BASE_SECURITY_SCENARIO_ID       570
#define NUM_SECURITY_SCENARIOS          3
#define IDS_SAME_SEC_SETTINGS           (BASE_SECURITY_SCENARIO_ID + 0)
#define IDS_SEPARATE_SEC_SET            (BASE_SECURITY_SCENARIO_ID + 1)
#define IDS_FORCE_WIN2K_SEC             (BASE_SECURITY_SCENARIO_ID + 2)

#define BASE_ENCRYPT_TYPE_ID            580
#define NUM_ENCRYPT_TYPES               3
#define IDS_NO_ENCRYPT                  (BASE_ENCRYPT_TYPE_ID + 0)
#define IDS_REQUIRE_ENCRYPT             (BASE_ENCRYPT_TYPE_ID + 1)
#define IDS_OPTIONAL_ENCRYPT            (BASE_ENCRYPT_TYPE_ID + 2)

#define BASE_VPN_TYPE_ID                591 // this used to be 590 and we also had automatic, now we make the user pick their strategy explicitly
#define NUM_VPN_TYPES                   4
#define IDS_PPTP_ONLY                   (BASE_VPN_TYPE_ID + 0)
#define IDS_PPTP_FIRST                  (BASE_VPN_TYPE_ID + 1)
#define IDS_L2TP_ONLY                   (BASE_VPN_TYPE_ID + 2)
#define IDS_L2TP_FIRST                  (BASE_VPN_TYPE_ID + 3)

#define IDC_USE_EAP                     598
#define IDC_ALLOWED_PROTOCOLS           599
#define BASE_AUTH_CONTROL_ID            600
#define NUM_AUTH_TYPES                  6
#define IDC_ALLOW_PAP                   (BASE_AUTH_CONTROL_ID + 0)
#define IDC_ALLOW_SPAP                  (BASE_AUTH_CONTROL_ID + 1)
#define IDC_ALLOW_CHAP                  (BASE_AUTH_CONTROL_ID + 2)
#define IDC_ALLOW_MSCHAP                (BASE_AUTH_CONTROL_ID + 3)
#define IDC_ALLOW_W95CHAP               (BASE_AUTH_CONTROL_ID + 4)
#define IDC_ALLOW_MSCHAP2               (BASE_AUTH_CONTROL_ID + 5)

#define BASE_VPN_ENTRY_TITLE            650
#define BASE_DUN_ENTRY_TITLE            660
#define NEW_INCREMENT                   0
#define EDIT_INCREMENT                  1
#define IDS_VPN_PROP_TITLE_NEW          (BASE_VPN_ENTRY_TITLE + NEW_INCREMENT)
#define IDS_VPN_PROP_TITLE_EDIT         (BASE_VPN_ENTRY_TITLE + EDIT_INCREMENT)
#define IDS_NET_PROP_TITLE_NEW          (BASE_DUN_ENTRY_TITLE + NEW_INCREMENT)
#define IDS_NET_PROP_TITLE_EDIT         (BASE_DUN_ENTRY_TITLE + EDIT_INCREMENT)

#define IDS_APP_TITLE                   1020
#define IDS_NOSERVICE                   1021
#define IDS_INFO_TIP                    1022
#define IDS_TOOLONG                     1023
#define IDS_BMPFILTER                   1024
#define IDC_EDITDIR                     1025

#define IDS_HLPFILTER                   1029

#define IDC_EDITLARGE                   1031
#define IDS_NOSHORTNAME                 1032
#define IDS_NOACCESS                    1034

#define IDC_MSG                         1039
#define IDS_BADNAME                     1040
#define IDS_BADOUTEXE                   1041
#define IDS_NOEXIST                     1042
#define IDS_NOBMP                       1043
#define IDS_INVALIDBMP                  1044
#define IDC_BROWSEBMP2                  1045
#define IDC_EDITPHONE                   1046
#define IDC_EDITREGION                  1047
#define IDC_EDITURL                     1048
#define IDC_EDITHELP                    1049
#define IDC_RADIO1                      1051
#define IDC_RADIO2                      1052
#define IDC_RADIO3                      1053
#define IDC_RADIO4                      1054
#define IDS_PROGFILTER                  1056
#define IDS_CONACTFILTER                1057
#define IDS_NOTUNNEL                    1060
#define IDS_NOTUNNELFILE                1061
//#define                                 1062
#define IDS_NOSELECTION                 1064
#define IDS_SCPFILTER                   1065
#define IDS_TXTFILTER                   1067
#define IDS_ALLFILTER                   1068
#define IDS_NEEDSPBR                    1070
#define IDS_NOTPBK                      1071
#define IDOK1                           1072
#define IDCANCEL1                       1073
#define IDC_LABEL_DNS                   1074
#define IDC_LABEL_DNS2                  1075
#define IDC_LABEL_WINS                  1076
#define IDC_LABEL_WINS2                 1077
#define IDC_REALMNAME                   1078
#define IDC_STATIC_CHECK3               1081
#define IDS_AddReg                      1089
#define IDS_CANCELWIZ                   1107
#define IDS_NOURL                       1111
#define IDS_NOREALM                     1118
#define IDS_NOLANGRES                   1121
#define IDS_NEEDPHONENAME               1122
#define IDS_PHONENAMEERR                1123
#define IDS_NEEDPROF                    1127
#define IDS_NEEDPROG                    1128
//#define                                 1129
#define IDS_PROFEXISTS                  1132
#define IDS_NOHELP                      1135
#define IDC_LABEL1                      1136
#define IDC_LABEL2                      1137
#define IDC_LABEL3                      1138
#define IDB_INTRO                       1141
#define IDS_BROWSETITLE                 1144
#define IDS_ICOFILTER                   1145
#define IDS_PBKFILTER                   1147
#define IDC_BROWSE2                     1148
#define IDC_BROWSE3                     1149
#define IDC_EDITSMALL                   1152
#define IDC_EDITTRAY                    1153
#define IDC_BROWSE1                     1154
#define IDC_ICONLARGE                   1155
#define IDC_ICONSMALL                   1157
#define IDC_ICONTRAY                    1158
#define IDC_SERVICE                     1159
#define IDC_SSERVICE                    1160
#define IDC_SUPPORT                     1161
#define IDC_BROWSEBMP1                  1162
#define IDC_EDITSPLASH                  1163
#define IDC_DEFAULTBRAND                1164
#define IDS_INVALIDICO                  1167
#define IDC_PDEFAULTBRAND               1171
#define IDS_OVERWRITE                   1172
#define IDS_BADLONGNAME                 1174
#define IDC_CHECK1                      1175
#define IDC_CHECK2                      1176
#define IDC_CHECK3                      1177
#define IDC_LIST1                       1178
#define IDC_COMBO1                      1180
#define IDC_COMBO2                      1181
#define IDC_BUTTON1                     1182
#define IDC_BUTTON2                     1183
#define IDC_BUTTON3                     1184
#define IDC_BUTTON4                     1185
#define IDC_BUTTON5                     1186
#define IDC_EDIT1                       1192
#define IDC_EDIT2                       1193
#define IDC_EDIT3                       1194
#define IDC_EDIT4                       1195
#define IDC_EDIT5                       1196
#define IDC_EDIT6                       1197
#define IDS_SERVICENAMETOBIG            1205
#define IDS_DISKFULL                    1209
#define IDS_READMETXT                   1210
#define IDC_GROUP                       1217
#define IDC_CHECK4                      1218
#define IDC_LABEL4                      1219
#define IDS_BADPBNAME                   1220
#define IDS_SUPPORTS_ENCRYPT            1221
#define IDS_CANAMEEXISTS                1222
#define IDS_NOEQUALSINMENU              1223
#define IDS_MUST_UPGRADE_INF            1224
#define IDS_NEED_DUN_NAME               1225
#define IDS_DUN_NAME_EXISTS             1226
#define IDS_MENUITEMEXISTS              1227
#define IDS_NODLLAUTOAPP                1228
#define IDS_DLLMUSTHAVEPARAM            1229

#define IDS_NATIVE_LCID                 1232

#define IDS_NONNATIVELCID               1234
#define IDB_HEADER                      1235
#define IDC_HELPBUTTON                  1236
// #define                                1237
#define IDC_NORMALTEXT                  1238
#define IDC_IEAKTEXT                    1239
#define IDS_BeginPromptText             1242
#define IDS_EndPromptText               1243
#define IDI_CM_ICON                     1244
#define IDB_CM_DEFAULT                  1245
#define IDB_CM_PB_DEFAULT               1246
#define IDS_SELECTION_TOO_LARGE         1247
#define IDS_CM_TOO_NEW                  1248
#define IDS_NO_CM_BITS                  1249
#define IDS_CMDL_VPN_DESC               1250
#define IDS_CM_TOO_OLD                  1251
#define IDS_CHANGED_ONLY_SS_OR_LS       1253
#define IDS_CANNOT_ROUNDTRIP            1254
#define IDS_NO_ANSI_CODEPAGE            1255
#define IDS_LCIDS_DONT_MATCH            1256
#define IDS_DIFF_DISPLAY_LCID           1257
#define IDS_INSUFF_PERMS                1258
#define IDD_CUSTOM_ACTIONS              1259
#define IDC_LISTVIEW                    1260
#define IDS_PATH_WITH_NO_ENV            1261
#define IDS_CMDL_DESC                   1262
#define IDS_NOPLUSORCOMMAINPROG         1263
#define IDC_LIST2                       1264
#define IDS_NOTINPROFILELIST            1265
#define IDD_DUN_SECURITY_POPUP          1266
#define IDC_ENCRYPTION_TYPE             1267
#define IDC_EAP_TYPES                   1268
#define IDC_EAP_PROPERTIES              1269
#define IDC_SCRIPT_LABEL                1270
#define IDS_EAP_NOT_FOUND               1271
#define IDS_EAP_NEEDS_CONFIG            1272
#define IDS_EAP_NOT_FOUND_TYPE          1273
#define IDD_CMPROXY                     1274
#define IDD_ROUTE_PLUMBING              1275
#define IDC_ROUTE_FILE_LABEL            1276
#define IDC_ROUTE_FILE                  1277
#define IDC_ROUTE_URL_LABEL             1278
#define IDC_ROUTE_URL                   1279
#define IDC_CHECK5                      1280
#define IDC_CHECK6                      1281
#define IDC_PRIMARY_DNS                 1282
#define IDC_SECONDARY_DNS               1283
#define IDC_PRIMARY_WINS                1284
#define IDC_SECONDARY_WINS              1285
#define IDC_STATIC_IP                   1286
//#define                                 1287
//#define                                 1288
#define IDS_DEFAULT_FMT_STR             1289
#define IDD_GENERAL                     1290
#define IDD_TCPIP_SETTINGS              1291
#define IDD_SECURITY                    1292
#define IDC_ADVANCED                    1293
#define IDC_VPN_TYPE                    1294
#define IDC_ANY_AUTH                    1295
#define IDC_ENCRYPTED_AUTH              1296
#define IDC_CONFIG_ALL                  1297
#define IDC_CONFIG_WIN2K                1298
#define IDC_MS_ENCRYPTED_AUTH           1299
#define IDD_WIN2K_SECURITY_POPUP        1300
#define IDS_PRESHAREDKEY_BAD            1301
#define IDC_SECURE_LOCALFILES           1302
#define IDD_WIN2K_SECURITY_TUNNEL_POPUP 1303
#define IDS_NEED_EAP_OR_MSCHAP          1304
#define IDS_NEED_AUTH_PROTOCOL          1305
#define IDS_PRESHAREDKEY_PIN_BAD        1306
#define IDS_CMROUTE_DESC                1307
#define IDS_CMPROXY_CON_DESC            1308
#define IDS_CMPROXY_DIS_DESC            1309
#define IDS_NEED_PROXY_FILE             1310
#define IDS_BUILT_IN                    1311
#define IDS_NEED_ROUTE_FILE             1312
#define IDD_GEEK_PANE                   1313
#define IDC_COMBO3                      1314
#define IDS_NEED_SECTION                1315
#define IDS_DELETE_SECTION              1316
#define IDC_PROXYLABEL                  1317
#define IDC_REALM_SEP                   1318
#define IDS_CA_EDIT_TITLE               1319
#define IDS_EDIT_SHORTCUT_TITLE         1320
#define IDS_BADVPNFORMAT                1321
#define IDS_DUN_NAME_CONFLICT           1322
#define IDS_DELETE_KEY                  1323
#define IDS_INSTALL_PROMPT              1324

#define IDC_PRESHARED_KEY               1325
#define IDC_USEENCRYPTION               1326
#define IDC_PRESHARED_KEY_PIN           1327
#define IDC_REPLACE_PSK                 1328
#define IDS_REALLY_REPLACE_PSK          1329
#define IDS_PSK_ENCRYPT_FAILED          1330
#define IDC_CERT_PSK_GROUPBOX           1331
#define IDC_USE_CERT                    1332
#define IDC_USE_PRESHARED_KEY           1333
#define IDS_PRESHAREDKEY_ALREADY        1334

#define IDC_LBLTITLE                    2000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        159
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1335
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\api_w.c ===
#include "unicode.h"
#include "api.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\mprcommn\creds.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    creds.c
//
// Description: Routines for storing and retrieving user Lsa secret
//              dial parameters.
//
//
// History:     11/02/95        Anthony Discolo     created     
//              May 11,1995	    NarenG		        modified for router.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <llinfo.h>
#include <rasman.h>
#include <raserror.h>
#include <mprerror.h>
#include <stdlib.h>
#include <string.h>

#define MPR_CREDENTIALS_KEY         TEXT("MprCredentials%d")

#define MAX_REGISTRY_VALUE_LENGTH   ((64*1024) - 1)

typedef struct _MPRPARAMSENTRY 
{
    LIST_ENTRY  ListEntry;
    WCHAR       szPhoneBookEntryName[MAX_INTERFACE_NAME_LEN + 1];
    WCHAR       szUserName[UNLEN + 1];
    WCHAR       szPassword[PWLEN + 1];
    WCHAR       szDomain[DNLEN + 1];

} MPRPARAMSENTRY, *PMPRPARAMSENTRY;

//**
//
// Call:        ReadDialParamsBlob
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
ReadDialParamsBlob(
    IN  LPWSTR  lpwsServer,
    OUT PVOID   *ppvData,
    OUT LPDWORD lpdwSize
)
{
    NTSTATUS            status;
    DWORD               dwRetCode = NO_ERROR;
    DWORD               dwIndex;
    DWORD               dwSize = 0;
    PVOID               pvData = NULL;
    PVOID               pvNewData = NULL;
    UNICODE_STRING      unicodeKey;
    UNICODE_STRING      unicodeServer;
    PUNICODE_STRING     punicodeValue = NULL;
    OBJECT_ATTRIBUTES   objectAttributes;
    LSA_HANDLE          hPolicy;
    WCHAR               wchKey[sizeof(MPR_CREDENTIALS_KEY) + 10 ];

    //
    // Initialize return value.
    //

    *ppvData = NULL;
    *lpdwSize = 0;

    //
    // Open the LSA secret space for reading.
    //

    InitializeObjectAttributes( &objectAttributes, NULL, 0L, NULL, NULL );

    RtlInitUnicodeString( &unicodeServer, lpwsServer );

    status = LsaOpenPolicy( &unicodeServer,
                            &objectAttributes,  
                            POLICY_READ, 
                            &hPolicy );

    if ( status != STATUS_SUCCESS )
    {
        return( LsaNtStatusToWinError( status ) );
    }

    for( dwIndex = 0; TRUE; dwIndex++ ) 
    {
        //
        // Format the key string.
        //

        wsprintf( wchKey, MPR_CREDENTIALS_KEY, dwIndex );

        RtlInitUnicodeString( &unicodeKey, wchKey );

        //
        // Get the value.
        //

        status = LsaRetrievePrivateData( hPolicy, &unicodeKey, &punicodeValue );

        if ( status != STATUS_SUCCESS ) 
        {
            dwRetCode = LsaNtStatusToWinError( status );

            if ( dwRetCode == ERROR_FILE_NOT_FOUND )
            {
                dwRetCode = NO_ERROR;
            } 

            break;
        }
        if ( punicodeValue == NULL )
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Concatenate the strings.
        //

        pvNewData = LocalAlloc( LPTR, dwSize + punicodeValue->Length );

        if ( pvNewData == NULL ) 
        {
            dwRetCode = GetLastError();
            break;
        }

        if ( pvData != NULL )
        {
            RtlCopyMemory( pvNewData, pvData, dwSize );
            ZeroMemory( pvData, dwSize );
            LocalFree( pvData );
            pvData = NULL;
        }

        RtlCopyMemory( (PBYTE)pvNewData + dwSize, 
                        punicodeValue->Buffer, 
                        punicodeValue->Length );

        pvData = pvNewData;
        dwSize += punicodeValue->Length;
        LsaFreeMemory( punicodeValue );
        punicodeValue = NULL;
    }

    LsaClose( hPolicy );

    if ( dwRetCode != NO_ERROR )
    {
        if ( pvData != NULL )
        {
            ZeroMemory( pvData, dwSize );
            LocalFree( pvData );
        }

        pvData = NULL;
        dwSize = 0;
    }

    if ( punicodeValue != NULL )
    {
        LsaFreeMemory( punicodeValue );
    }

    *ppvData  = pvData;
    *lpdwSize = dwSize;

    return( dwRetCode );
}

//**
//
// Call:        WriteDialParamsBlob
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
WriteDialParamsBlob(
    IN  LPWSTR  lpwsServer,
    IN  PVOID   pvData,
    IN  DWORD   dwcbData
)
{
    NTSTATUS            status;
    DWORD               dwIndex = 0;
    DWORD               dwRetCode = NO_ERROR;
    DWORD               dwcb = 0;
    UNICODE_STRING      unicodeKey, unicodeValue;
    UNICODE_STRING      unicodeServer;
    OBJECT_ATTRIBUTES   objectAttributes;
    LSA_HANDLE          hPolicy;
    WCHAR               wchKey[sizeof(MPR_CREDENTIALS_KEY) + 10 ];

    //
    // Open the LSA secret space for writing.
    //

    InitializeObjectAttributes( &objectAttributes, NULL, 0L, NULL, NULL );

    RtlInitUnicodeString( &unicodeServer, lpwsServer );

    status = LsaOpenPolicy( &unicodeServer, 
                            &objectAttributes, 
                            POLICY_WRITE, 
                            &hPolicy);

    if (status != STATUS_SUCCESS)
    {
        return LsaNtStatusToWinError(status);
    }

    while( dwcbData ) 
    {
        //
        // Format the key string.
        //

        wsprintf( wchKey, MPR_CREDENTIALS_KEY, dwIndex++ );

        RtlInitUnicodeString( &unicodeKey, wchKey );

        //
        // Write some of the key.
        //

        dwcb = ( dwcbData > MAX_REGISTRY_VALUE_LENGTH )
                    ? MAX_REGISTRY_VALUE_LENGTH 
                    : dwcbData;

        unicodeValue.Length = unicodeValue.MaximumLength = (USHORT)dwcb;

        unicodeValue.Buffer = pvData;

        status = LsaStorePrivateData( hPolicy, &unicodeKey, &unicodeValue );

        if ( status != STATUS_SUCCESS ) 
        {
            dwRetCode = LsaNtStatusToWinError(status);
            break;
        }

        //
        // Move the pointer to the unwritten part
        // of the value.
        //

        pvData = (PBYTE)pvData + dwcb;

        dwcbData -= dwcb;
    }

    if ( dwRetCode != NO_ERROR )
    {
        LsaClose( hPolicy );

        return( dwRetCode );
    }

    //
    // Delete any extra keys.
    //

    for (;;) 
    {
        //
        // Format the key string.
        //

        wsprintf( wchKey, MPR_CREDENTIALS_KEY, dwIndex++ );

        RtlInitUnicodeString( &unicodeKey, wchKey );

        //
        // Delete the key.
        //

        status = LsaStorePrivateData( hPolicy, &unicodeKey, NULL );

        if ( status != STATUS_SUCCESS )
        {
            break;
        }
    }

    LsaClose( hPolicy );

    return( NO_ERROR );
}

//**
//
// Call:        DialParamsBlobToList
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Take a string read from the user's registry key and produce 
//              a list of MPRPARAMSENTRY structures. If one of the structures 
//              has the same dwUID field as the dwUID passed in, then this 
//              function returns a pointer to this structure.
//
//              This string encodes the data for multiple MPRPARAMSENTRY 
//              structures.  The format of an encoded MPRPARAMSENTRY is as 
//              follows:
//
//              <szPhoneBookEntryName>\0<szUserName>\0<szPassword>\0<szDomain>\0
//
PMPRPARAMSENTRY
DialParamsBlobToList(
    IN  PVOID       pvData,
    IN  LPWSTR      lpwsPhoneBookEntryName,
    OUT PLIST_ENTRY pHead
)
{
    PWCHAR p;
    PMPRPARAMSENTRY pParams, pFoundParams;

    p = (PWCHAR)pvData;

    pFoundParams = NULL;

    for (;;) 
    {
        pParams = LocalAlloc(LPTR, sizeof (MPRPARAMSENTRY));

        if ( pParams == NULL ) 
        {
            break;
        }

        wcscpy( pParams->szPhoneBookEntryName, p );

        if (_wcsicmp(pParams->szPhoneBookEntryName,lpwsPhoneBookEntryName) == 0)
        {
            pFoundParams = pParams;
        }
        while (*p) p++; p++;

        wcscpy(pParams->szUserName, p);
        while (*p) p++; p++;

        wcscpy(pParams->szPassword, p);
        while (*p) p++; p++;

        wcscpy(pParams->szDomain, p);
        while (*p) p++; p++;

        InsertTailList(pHead, &pParams->ListEntry);

        if (*p == L'\0') break;
    }

    return( pFoundParams );
}

//**
//
// Call:        DialParamsListToBlob
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
PVOID
DialParamsListToBlob(
    IN  PLIST_ENTRY pHead,
    OUT LPDWORD     lpcb
)
{
    DWORD dwcb, dwSize;
    PVOID pvData;
    PWCHAR p;
    PLIST_ENTRY pEntry;
    PMPRPARAMSENTRY pParams;

    //
    // Estimate a buffer size large enough to hold the new entry.
    //

    dwSize = *lpcb + sizeof (MPRPARAMSENTRY) + 32;

    if ( ( pvData = LocalAlloc(LPTR, dwSize) ) == NULL )
    {
        return( NULL );
    }

    //
    // Enumerate the list and convert each entry  back to a string.
    //

    dwSize = 0;

    p = (PWCHAR)pvData;

    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink )
    {
        pParams = CONTAINING_RECORD(pEntry, MPRPARAMSENTRY, ListEntry);

        wcscpy(p, pParams->szPhoneBookEntryName);
        dwcb = wcslen(pParams->szPhoneBookEntryName) + 1;
        p += dwcb; dwSize += dwcb;

        wcscpy(p, pParams->szUserName);
        dwcb = wcslen(pParams->szUserName) + 1;
        p += dwcb; dwSize += dwcb;

        wcscpy(p, pParams->szPassword);
        dwcb = wcslen(pParams->szPassword) + 1;
        p += dwcb; dwSize += dwcb;

        wcscpy(p, pParams->szDomain);
        dwcb = wcslen(pParams->szDomain) + 1;
        p += dwcb; dwSize += dwcb;
    }

    *p = L'\0';
    dwSize++;
    dwSize *= sizeof (WCHAR);

    //
    // Set the exact length here.
    //

    *lpcb = dwSize;

    return( pvData );
}

//**
//
// Call:        FreeParamsList
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will free the list of structures.
//
VOID
FreeParamsList(
    IN PLIST_ENTRY pHead
)
{
    PLIST_ENTRY pEntry;
    PMPRPARAMSENTRY pParams;

    while( !IsListEmpty(pHead) ) 
    {
        pEntry = RemoveHeadList(pHead);
        pParams = CONTAINING_RECORD(pEntry, MPRPARAMSENTRY, ListEntry);
        ZeroMemory( pParams, sizeof( MPRPARAMSENTRY ) );
        LocalFree(pParams);
    }
}

//**
//
// Call:        RemoveCredentials
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
RemoveCredentials( 
    IN      LPWSTR   lpwsInterfaceName, 
    IN      LPVOID   pvData, 
    IN OUT  LPDWORD  lpdwSize 
)    
{
    PWCHAR  pWalker  = (PWCHAR)pvData;
    DWORD   dwIndex;

    //
    // There is no list to remove from.
    //

    if ( pvData == NULL )
    {
        return( ERROR_NO_SUCH_INTERFACE );
    }

    for (;;)
    {
        //
        // If we found the interface we want to remove, we jump past it
        //

        if ( _wcsicmp( (LPWSTR)pWalker, lpwsInterfaceName ) == 0 )
        {
            PWCHAR  pInterface  = pWalker;
            DWORD   dwEntrySize = 0;

            //
            // Jump past the 4 fields.
            //

            for ( dwIndex = 0; dwIndex < 4; dwIndex++ )
            {
                while (*pWalker) pWalker++, dwEntrySize++; 

                pWalker++, dwEntrySize++;
            }

            //
            // If this was the last entry in the list
            //

            if (*pWalker == L'\0')
            {
                ZeroMemory( pInterface, dwEntrySize );
            } 
            else
            {
                CopyMemory( pInterface, 
                            pWalker, 
                            *lpdwSize - ( (PBYTE)pWalker - (PBYTE)pvData ) );
            }

            *lpdwSize -= dwEntrySize;

            return( NO_ERROR );
        }
        else
        {
            //
            // Not found so skip over this entry
            //

            for ( dwIndex = 0; dwIndex < 4; dwIndex++ )
            {
                while (*pWalker) pWalker++; pWalker++;
            }
        }

        if (*pWalker == L'\0') break;
    }

    return( ERROR_NO_SUCH_INTERFACE );
}

//**
//
// Call:        MprAdminInterfaceSetCredentials
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//
// Description: 
//
DWORD APIENTRY
MprAdminInterfaceSetCredentialsInternal(
    IN      LPWSTR                  lpwsServer          OPTIONAL,
    IN      LPWSTR                  lpwsInterfaceName,
    IN      LPWSTR                  lpwsUserName        OPTIONAL,
    IN      LPWSTR                  lpwsDomainName      OPTIONAL,
    IN      LPWSTR                  lpwsPassword        OPTIONAL
)
{
    DWORD           dwRetCode;
    DWORD           dwSize;
    PVOID           pvData;
    LIST_ENTRY      paramList;
    PMPRPARAMSENTRY pParams = NULL;

    if ( lpwsInterfaceName == NULL )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    if ( wcslen( lpwsInterfaceName ) > MAX_INTERFACE_NAME_LEN )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    if ( lpwsUserName != NULL )
    {
        if ( wcslen( lpwsUserName ) > UNLEN )
        {
            return( ERROR_INVALID_PARAMETER );
        }
    }

    if ( lpwsPassword != NULL ) 
    {
        if ( wcslen( lpwsPassword ) > PWLEN )
        {
            return( ERROR_INVALID_PARAMETER );
        }
    }

    if ( lpwsDomainName != NULL )
    {
        if ( wcslen( lpwsDomainName ) > DNLEN )
        {
            return( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // Read the existing dial params string from the registry.
    //

    dwRetCode = ReadDialParamsBlob( lpwsServer, &pvData, &dwSize );

    if ( dwRetCode != NO_ERROR ) 
    {
        return( dwRetCode );
    }

    //
    // If everything was NULL, we want to delete credentials for this interface
    //

    if ( ( lpwsUserName    == NULL ) &&
         ( lpwsDomainName  == NULL ) &&
         ( lpwsPassword    == NULL ) )
    {
        dwRetCode = RemoveCredentials( lpwsInterfaceName, pvData, &dwSize );    

        if ( dwRetCode != NO_ERROR )
        {
            ZeroMemory ( pvData, dwSize );
            LocalFree( pvData );

            return( dwRetCode );
        }
    }
    else
    {
        //
        // Parse the string into a list, and search for the phonebook entry.
        //

        InitializeListHead( &paramList );

        if ( pvData != NULL ) 
        {
            pParams = DialParamsBlobToList(pvData,lpwsInterfaceName,&paramList);

            //
            // We're done with pvData, so free it.
            //

            ZeroMemory ( pvData, dwSize );

            LocalFree( pvData );

            pvData = NULL;
        }

        //
        // If there is no existing information for this entry, create a new one.
        //

        if ( pParams == NULL ) 
        {
            pParams = LocalAlloc(LPTR, sizeof (MPRPARAMSENTRY) );

            if (pParams == NULL) 
            {
                FreeParamsList( &paramList );

                return( ERROR_NOT_ENOUGH_MEMORY );
            }

            InsertTailList( &paramList, &pParams->ListEntry );
        }

        //
        // Set the new uid for the entry.
        //

        wcscpy( pParams->szPhoneBookEntryName, lpwsInterfaceName );

        if ( lpwsUserName != NULL )
        {
            wcscpy( pParams->szUserName, lpwsUserName );
        }

        if ( lpwsPassword != NULL )
        {
            wcscpy( pParams->szPassword, lpwsPassword );
        }

        if ( lpwsDomainName != NULL )
        {
            wcscpy( pParams->szDomain, lpwsDomainName );
        }

        //
        // Convert the new list back to a string, so we can store it back into 
        // the registry.
        //

        pvData = DialParamsListToBlob( &paramList, &dwSize );

        FreeParamsList( &paramList );

        if ( pvData == NULL )
        {
            return( GetLastError() );
        }
    }

    //
    // Write it back to the registry.
    //

    dwRetCode = WriteDialParamsBlob( lpwsServer, pvData, dwSize );

    if ( pvData != NULL )
    {
        ZeroMemory( pvData, dwSize );
        LocalFree( pvData );
    }

    return( dwRetCode );
}

//**
//
// Call:        MprAdminInterfaceGetCredentials
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//
// Description:
//
DWORD APIENTRY
MprAdminInterfaceGetCredentialsInternal(
    IN      LPWSTR                  lpwsServer          OPTIONAL,
    IN      LPWSTR                  lpwsInterfaceName,
    IN      LPWSTR                  lpwsUserName        OPTIONAL,
    IN      LPWSTR                  lpwsPassword        OPTIONAL,
    IN      LPWSTR                  lpwsDomainName      OPTIONAL
)
{
    DWORD           dwRetCode;
    DWORD           dwSize;
    PVOID           pvData;
    LIST_ENTRY      paramList;
    PMPRPARAMSENTRY pParams = NULL;

    if ( lpwsInterfaceName == NULL )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    if ( ( lpwsUserName == NULL )       && 
         ( lpwsDomainName == NULL )     &&
         ( lpwsPassword == NULL ) ) 
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Read the existing dial params string from the registry.
    //

    dwRetCode = ReadDialParamsBlob( lpwsServer, &pvData, &dwSize );

    if ( dwRetCode != NO_ERROR ) 
    {
        return( dwRetCode );
    }

    //
    // Parse the string into a list, and search for the lpwsInterfaceName entry.
    //

    InitializeListHead( &paramList );

    if ( pvData != NULL ) 
    {
        pParams = DialParamsBlobToList( pvData, lpwsInterfaceName, &paramList );

        //
        // We're done with pvData, so free it.
        //

        ZeroMemory( pvData, dwSize );
        LocalFree( pvData );
    }

    //
    // If the entry doesn't have any  saved parameters, then return.
    //
    if ( pParams == NULL ) 
    {
        FreeParamsList( &paramList );

        return( ERROR_CANNOT_FIND_PHONEBOOK_ENTRY );
    }

    //
    // Otherwise, copy the fields to the caller's buffer.
    //

    if ( lpwsUserName != NULL )
    {
        wcscpy( lpwsUserName, pParams->szUserName );
    }

    if ( lpwsPassword != NULL )
    {
        wcscpy( lpwsPassword, pParams->szPassword );
    }

    if ( lpwsDomainName != NULL )
    {
        wcscpy( lpwsDomainName, pParams->szDomain );
    }

    FreeParamsList( &paramList );

    return( NO_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\uapi\cmutoa\cmutoa.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmutoa.cpp
//
// Module:   CMUTOA.DLL
//
// Synopsis: This dll is a Unicode to Ansi wrapper that exports AU functions
//           that have the function header of the W version of a windows API
//           but internally do all the conversions necessary so that the Ansi
//           version of the API (A version) can be called.  This dll was implemented
//           so that a Unicode CM could still run on win9x.  The idea was borrowed
//           from F. Avery Bishop's April 1999 MSJ article "Design a Single Unicode
//           App that Runs on Both Windows 98 and Windows 2000"
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb      Created    04/25/99
//
//+----------------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <shlobj.h>
#include <ras.h>
#include <raserror.h>
#include <shellapi.h>

#include "cmutoa.h"
#include "cmdebug.h"
#include "cm_def.h"
#include "cmutil.h"

#include "cmras.h"
#include "raslink.h"

// raslink text constants
#define _CMUTOA_MODULE
#include "raslink.cpp"


//
//  Globals
//
DWORD  g_dwTlsIndex;

//
//  Function Headers
//
LRESULT WINAPI SendMessageAU(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
int WINAPI wvsprintfAU(OUT LPWSTR pszwDest, IN LPCWSTR pszwFmt, IN va_list arglist);
int WINAPI lstrlenAU(IN LPCWSTR lpString);

//+----------------------------------------------------------------------------
//
// Function:  DllMain
//
// Synopsis:  Main Entry point for the DLL, notice that we use thread local
//            storage and initialize it here.
//
// Arguments: HANDLE hDll - instance handle to the dll
//            DWORD dwReason - reason the function was called
//            LPVOID lpReserved - 
//
// Returns:   BOOL - TRUE on success
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL APIENTRY DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        CMTRACE(TEXT("====================================================="));
        CMTRACE1(TEXT(" CMUTOA.DLL - LOADING - Process ID is 0x%x "), GetCurrentProcessId());
        CMTRACE(TEXT("====================================================="));

        g_dwTlsIndex = TlsAlloc();
        if (g_dwTlsIndex == TLS_OUT_OF_INDEXES)
        {
            return FALSE;
        }

        DisableThreadLibraryCalls((HMODULE) hDll);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        CMTRACE(TEXT("====================================================="));
        CMTRACE1(TEXT(" CMUTOA.DLL - UNLOADING - Process ID is 0x%x "), GetCurrentProcessId());
        CMTRACE(TEXT("====================================================="));

        //
        // free the tls index
        //
        if (g_dwTlsIndex != TLS_OUT_OF_INDEXES)
        {
            TlsFree(g_dwTlsIndex);
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CharNextAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 CharNext API.
//
// Arguments: LPCWSTR lpsz - The string to return the next character of
//
// Returns:   LPWSTR -- the Next character in the string, unless the current
//                      char is a NULL terminator and then the input param
//                      is returned.
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
LPWSTR WINAPI CharNextAU(IN LPCWSTR lpsz)
{
    LPWSTR pszReturn = (LPWSTR)lpsz;

    if (lpsz && (L'\0' != *lpsz))
    {
        pszReturn++;  // this is what _wcsinc does
    }

    return pszReturn;

}

//+----------------------------------------------------------------------------
//
// Function:  CharPrevAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 CharPrev API.
//
// Arguments: LPCWSTR lpszStart - start of the string
//            LPCWSTR lpsz - The current position in the string for which we
//                           want the previous char of
//            
//
// Returns:   LPWSTR -- the Previous character in the string, unless the current
//                      char is less than or equal to the Start of the string or
//                      a NULL string is passed to the function, then lpszStart
//                      is returned.
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
LPWSTR WINAPI CharPrevAU(IN LPCWSTR lpszStart, IN LPCWSTR lpszCurrent)
{
    LPWSTR pszReturn = (LPWSTR)lpszCurrent;

    if (lpszStart && lpszCurrent && (lpszCurrent > lpszStart))
    {
        pszReturn--;       // this is what _wcsdec does
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("NULL String passed to CharPrevAU"));
        pszReturn = (LPWSTR)lpszStart;
    }

    return pszReturn;
}

typedef WINUSERAPI LPSTR (WINAPI *CharLowerOrUpperA)(LPSTR);

//+----------------------------------------------------------------------------
//
// Function:  LowerOrUpperHelper
//
// Synopsis:  Helper function called by either CharLowerAU or CharUpperAU which have
//           basically the same functionality except for the calling of CharLowerA or 
//           CharUpperA, respectively.
//
// Arguments: LPWSTR lpsz -- either a pointer to a string to convert to its
//                           lower/upper character version or a single character stored
//                           in the low word of the pointer to find the lowercase/uppercase
//                           character for.            
//
// Returns:   LPWSTR -- lower/upper case version of the string passed in (same as lpsz
//                      because it is converted in place) or lower/upper case version
//                      of the character stored in the Low word of lpsz.
//
// History:   quintinb Created    01/03/2000
//
//+----------------------------------------------------------------------------
LPWSTR WINAPI LowerOrUpperHelper(IN OUT LPWSTR lpsz, CharLowerOrUpperA pfnLowerOrUpper)
{
    LPWSTR pszwReturn = lpsz;
    LPSTR pszAnsiTmp = NULL;

    if (lpsz)
    {
        //
        //  CharLower/CharUpper can be used in two ways.  There is a Character mode where the Loword of the
        //  pointer passed in actually stores the numeric value of the character to get the lowercase/uppercase
        //  value of.  There is also the traditional use, where the whole string is passed in.  Thus
        //  we have to detect which mode we are in and handle it accordingly.
        //
        if (0 == HIWORD(lpsz))
        {
            //
            //  Character Mode
            //
            CHAR szAnsiTmp[2];
            WCHAR szwWideTmp[2];

            szwWideTmp[0] = (WCHAR)LOWORD(lpsz);
            szwWideTmp[1] = L'\0';

            int iChars = WzToSz(szwWideTmp, szAnsiTmp, 2);

            if (iChars && (iChars <= 2))
            {
                pfnLowerOrUpper(szAnsiTmp);

                iChars = SzToWz(szAnsiTmp, szwWideTmp, 2);
            
                if (iChars && (iChars <= 2))
                {
                    lpsz = (LPWSTR) ((WORD)szwWideTmp[0]);
                    pszwReturn = lpsz;
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("LowerOrUpperHelper-- Failed to convert szAnsiTmp back to szwWideTmp."));
                }
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("LowerOrUpperHelper -- Failed to convert szwWideTmp to szAnsiTmp."));
            }
        }
        else
        {
            //
            //  String Mode
            //
            pszAnsiTmp = WzToSzWithAlloc(lpsz);

            if (!pszAnsiTmp)
            {
                goto exit;
            }

            pfnLowerOrUpper(pszAnsiTmp);

            //
            //  Convert back into UNICODE chars in lpsz
            //
            int iCharCount = (lstrlenAU(lpsz) + 1); // include NULL
            int iChars = SzToWz(pszAnsiTmp, lpsz, iCharCount);

            if (!iChars || (iChars > iCharCount))
            {
                CMASSERTMSG(FALSE, TEXT("LowerOrUpperHelper -- Failed to convert pszAnsiTmp to lpsz."));
                goto exit;
            }
        }        
    }

exit:

    CmFree(pszAnsiTmp);

    return pszwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  CharLowerAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 CharLower API.  Notice that
//            we support both the string input parameter and the single character
//            input method.
//
// Arguments: LPWSTR lpsz -- either a pointer to a string to convert to its
//                           lower character version or a single character stored
//                           in the low word of the pointer to find the lowercase
//                           character for.            
//
// Returns:   LPWSTR -- lower case version of the string passed in (same as lpsz
//                      because it is converted in place) or lower case version
//                      of the character stored in the Low word of lpsz.
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
LPWSTR WINAPI CharLowerAU(IN OUT LPWSTR lpsz)
{
    return LowerOrUpperHelper(lpsz, CharLowerA);
}

//+----------------------------------------------------------------------------
//
// Function:  CharUpperAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 CharUpper API.  Notice that
//            we support both the string input parameter and the single character
//            input method.
//
// Arguments: LPWSTR lpsz -- either a pointer to a string to convert to its
//                           upper character version or a single character stored
//                           in the low word of the pointer to find the uppercase
//                           character for.            
//
// Returns:   LPWSTR -- upper case version of the string passed in (same as lpsz
//                      because it is converted in place) or upper case version
//                      of the character stored in the Low word of lpsz.
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
LPWSTR WINAPI CharUpperAU(IN OUT LPWSTR lpsz)
{
    return LowerOrUpperHelper(lpsz, CharUpperA);
}

//+----------------------------------------------------------------------------
//
// Function:  CreateDialogParamAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 CreateDialogParam API.  Notice that
//            we support both a full string for the lpTemplateName param or only
//            a int from MAKEINTRESOURCE (a resource identifier stored in the string
//            pointer var).
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
HWND WINAPI CreateDialogParamAU(IN HINSTANCE hInstance, IN LPCWSTR lpTemplateName, IN HWND hWndParent,
                                IN DLGPROC lpDialogFunc, IN LPARAM dwInitParam)
{
    HWND hWndReturn = NULL;
    CHAR szAnsiTemplateName[MAX_PATH+1];
    LPSTR pszAnsiTemplateName;

    MYDBGASSERT(hInstance);
    MYDBGASSERT(lpTemplateName);
    MYDBGASSERT(lpDialogFunc);

    if (hInstance && lpTemplateName && lpDialogFunc)
    {
        if (HIWORD(lpTemplateName))
        {
            //
            //  We have a full template name that we must convert
            //
            pszAnsiTemplateName = szAnsiTemplateName;
            int iChars = WzToSz(lpTemplateName, pszAnsiTemplateName, MAX_PATH);

            if (!iChars || (MAX_PATH < iChars))
            {
                goto exit;
            }
        }
        else
        {
            //
            //  All we need is a cast
            //
            pszAnsiTemplateName = (LPSTR)lpTemplateName;
        }

        hWndReturn = CreateDialogParamA(hInstance, pszAnsiTemplateName, hWndParent, 
                                        lpDialogFunc, dwInitParam);
    }

exit:

    return hWndReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  CreateDirectoryAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 CreateDirectory API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL WINAPI CreateDirectoryAU(IN LPCWSTR lpPathName, IN LPSECURITY_ATTRIBUTES lpSecurityAttributes) 
{
    BOOL bRet = FALSE;

    LPSTR pszPathName = WzToSzWithAlloc(lpPathName);
    
    if (pszPathName)
    {
        bRet = CreateDirectoryA(pszPathName, lpSecurityAttributes);

        CmFree(pszPathName);
    }

    return bRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CreateEventAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 CreateEvent API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
HANDLE WINAPI CreateEventAU(IN LPSECURITY_ATTRIBUTES lpEventAttributes, IN BOOL bManualReset, 
                            IN BOOL bInitialState, IN LPCWSTR lpName)
{
    CHAR szAnsiName[MAX_PATH+1]; // lpName is limited to MAX_PATH chars according to the docs.
    HANDLE hReturn = NULL;
    LPSTR pszAnsiName = NULL;

    if (lpName) // lpName could be NULL
    {
        pszAnsiName = szAnsiName;
        int uNumChars = WzToSz(lpName, pszAnsiName, MAX_PATH);

        if (!uNumChars || (MAX_PATH < uNumChars))
        {
            CMTRACE(TEXT("CreateEventAU -- Unable to convert lpName"));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
    }

    hReturn = CreateEventA(lpEventAttributes, bManualReset, bInitialState, pszAnsiName);

exit:

    return hReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  CreateFileMappingAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 CreateFileMapping API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
HANDLE WINAPI CreateFileMappingAU(IN HANDLE hFile, IN LPSECURITY_ATTRIBUTES lpFileMappingAttributes, 
                                  IN DWORD flProtect, IN DWORD dwMaximumSizeHigh, 
                                  IN DWORD dwMaximumSizeLow, IN LPCWSTR lpName)
{
    HANDLE hHandle = NULL;
    LPSTR pszName = NULL;

    if (lpName) // could be NULL
    {
        pszName = WzToSzWithAlloc(lpName);
    }

    if (pszName || (NULL == lpName))
    {
        hHandle = CreateFileMappingA(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, 
                                     dwMaximumSizeLow, pszName);

        CmFree(pszName);
    }

    return hHandle;
}

//+----------------------------------------------------------------------------
//
// Function:  CreateFileAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 CreateFile API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
HANDLE WINAPI CreateFileAU(IN LPCWSTR lpFileName, IN DWORD dwDesiredAccess, IN DWORD dwShareMode, 
                           IN LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                           IN DWORD dwCreationDisposition, IN DWORD dwFlagsAndAttributes, 
                           IN HANDLE hTemplateFile)
{
    HANDLE hHandle = INVALID_HANDLE_VALUE;

    LPSTR pszFileName = WzToSzWithAlloc(lpFileName);
    
    if (pszFileName)
    {
        hHandle = CreateFileA(pszFileName, dwDesiredAccess, dwShareMode, 
                              lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, 
                              hTemplateFile);

        CmFree(pszFileName);
    }

    return hHandle;
}

//+----------------------------------------------------------------------------
//
// Function:  CreateMutexAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 CreateMutex API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
HANDLE WINAPI CreateMutexAU(IN LPSECURITY_ATTRIBUTES lpMutexAttributes, IN BOOL bInitialOwner, 
                            IN LPCWSTR lpName)
{
    HANDLE hHandle = NULL;
    LPSTR pszName = NULL;

    if (lpName) // lpName can be NULL, creates an unnamed mutex
    {
        pszName = WzToSzWithAlloc(lpName);
    }
    
    if (pszName || (NULL == lpName))
    {
        hHandle = CreateMutexA(lpMutexAttributes, bInitialOwner, pszName);

        CmFree(pszName);
    }

    return hHandle;
}

//+----------------------------------------------------------------------------
//
// Function:  CreateProcessAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 CreateProcess API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL WINAPI CreateProcessAU(IN LPCWSTR lpApplicationName, IN LPWSTR lpCommandLine, 
                            IN LPSECURITY_ATTRIBUTES lpProcessAttributes, 
                            IN LPSECURITY_ATTRIBUTES lpThreadAttributes, 
                            IN BOOL bInheritHandles, IN DWORD dwCreationFlags, 
                            IN LPVOID lpEnvironment, IN LPCWSTR lpCurrentDirectory, 
                            IN LPSTARTUPINFOW lpStartupInfo, 
                            OUT LPPROCESS_INFORMATION lpProcessInformation)
{
    BOOL bSuccess = FALSE;

    //
    //  Convert the string parameters.  Since the environment block is controlled by
    //  a flag (whether it is Ansi or Unicode) we shouldn't have to touch it here.
    //

    LPSTR pszAppName = WzToSzWithAlloc(lpApplicationName); // WzToSzWithAlloc will return NULL if the input is NULL
    LPSTR pszCmdLine = WzToSzWithAlloc(lpCommandLine);
    LPSTR pszCurrentDir = WzToSzWithAlloc(lpCurrentDirectory);

    //
    //  Set up the StartUp Info struct.  Note that we don't convert it but pass a blank
    //  structure.  If someone needs startupinfo then they will have to write the conversion
    //  code.  We currently don't use it anywhere.
    //
    STARTUPINFOA StartUpInfoA;

    ZeroMemory(&StartUpInfoA, sizeof(STARTUPINFOA));
    StartUpInfoA.cb = sizeof(STARTUPINFOA);

#ifdef DEBUG
    STARTUPINFOW CompareStartupInfoWStruct;
    ZeroMemory(&CompareStartupInfoWStruct, sizeof(STARTUPINFOW));
    CompareStartupInfoWStruct.cb = sizeof(STARTUPINFOW);
    CMASSERTMSG((0 == memcmp(lpStartupInfo, &CompareStartupInfoWStruct, sizeof(STARTUPINFOW))), TEXT("CreateProcessAU -- Non-NULL STARTUPINFOW struct passed.  Conversion code needs to be written."));
#endif

    //
    //  If we have the Command Line or an App Name go ahead
    //
    if (pszAppName || pszCmdLine) 
    {
        bSuccess = CreateProcessA(pszAppName, pszCmdLine, 
                                  lpProcessAttributes, lpThreadAttributes, 
                                  bInheritHandles, dwCreationFlags, 
                                  lpEnvironment, pszCurrentDir, 
                                  &StartUpInfoA, lpProcessInformation);

    }

    //
    //  Cleanup
    //

    CmFree(pszAppName);
    CmFree(pszCmdLine);
    CmFree(pszCurrentDir);

    return bSuccess;
}

//+----------------------------------------------------------------------------
//
// Function:  CreateWindowExAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 CreateWindowEx API.  Note that
//            we only allow MAX_PATH chars for the ClassName and the WindowName
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
HWND WINAPI CreateWindowExAU(DWORD dwExStyle, LPCWSTR lpClassNameW, LPCWSTR lpWindowNameW, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
{
    CHAR szClassNameA [MAX_PATH+1];
    CHAR szWindowNameA[MAX_PATH+1];
    HWND hReturn = NULL;

    if (lpClassNameW && lpWindowNameW)
    {
        MYDBGASSERT(MAX_PATH >= lstrlenAU(lpClassNameW));
        MYDBGASSERT(MAX_PATH >= lstrlenAU(lpWindowNameW));

        if (WzToSz(lpClassNameW, szClassNameA, MAX_PATH))
        {
            if (WzToSz(lpWindowNameW, szWindowNameA, MAX_PATH))
            {
                hReturn = CreateWindowExA(dwExStyle, szClassNameA, szWindowNameA, dwStyle, x, y, 
                                          nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);  
            }
        }
    }

    return hReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  DeleteFileAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 DeleteFile API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL WINAPI DeleteFileAU(IN LPCWSTR lpFileName)
{
    BOOL bReturn = FALSE;
    LPSTR pszAnsiFileName = WzToSzWithAlloc(lpFileName); // WzToSzWithAlloc will return NULL if lpFileName is NULL

    if (pszAnsiFileName)
    {
        DeleteFileA(pszAnsiFileName);
        CmFree(pszAnsiFileName);
    }

    return bReturn;   
}

//+----------------------------------------------------------------------------
//
// Function:  DialogBoxParamAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 DialogBoxParam API.  Note that
//            we don't support the use of a full string name, only ints for the 
//            lpTemplateName param.  We will assert if one is used.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
INT_PTR WINAPI DialogBoxParamAU(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    MYDBGASSERT(0 == HIWORD(lpTemplateName)); // we don't support or use the full string name
    return DialogBoxParamA(hInstance, (LPCSTR) lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
}

//+----------------------------------------------------------------------------
//
// Function:  ExpandEnvironmentStringsAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 ExpandEnvironmentStrings API.
//            We support allowing the user to size the string by passing in the
//            following Str, NULL, 0 just as the API reference mentions.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
DWORD WINAPI ExpandEnvironmentStringsAU(IN LPCWSTR lpSrc, OUT LPWSTR lpDst, IN DWORD nSize)
{
    DWORD dwReturn = 0;

    if (lpSrc)
    {
        //
        //
        //  Since the user could pass in 0 for the size and a NULL pszAnsiDst because they
        //  want to size the destination string, we want to handle that case.  However, 
        //  Win98 and Win95 machines (not counting WinME) don't honor sizing the buffer
        //  using a NULL lpDst.  We will "fool" these machines by using a buffer of size 1.
        //  Thus they could call it with Str, NULL, 0 and then allocate the correct size and 
        //  call again.  Note that we will return an error if the user passes Str, NULL, x
        //  because we have no buffer to copy the data returned from ExpandEnvironmentStringsA
        //  into.
        //

        LPSTR pszAnsiSrc = WzToSzWithAlloc(lpSrc);
        LPSTR pszAnsiDst = (LPSTR)CmMalloc((nSize+1)*sizeof(CHAR));

        if (pszAnsiSrc && pszAnsiDst)
        {
            dwReturn = ExpandEnvironmentStringsA(pszAnsiSrc, pszAnsiDst, nSize);

            if (dwReturn && (dwReturn <= nSize))
            {
                //
                //  Then the function succeeded and there was sufficient buffer space to hold
                //  the expanded string.  Thus we should convert the results and store it back
                //  in lpDst.

                if (lpDst)
                {
                    if (!SzToWz(pszAnsiDst, lpDst, nSize))
                    {
                        CMTRACE(TEXT("ExpandEnvironmentStringsAU -- SzToWz conversion of output param failed."));
                        dwReturn = 0;
                    }
                }
                else
                {
                    CMTRACE(TEXT("ExpandEnvironmentStringsAU -- NULL pointer passed for lpDst"));
                    dwReturn = 0;
                    SetLastError(ERROR_INVALID_PARAMETER);
                }
            }
        }
        else
        {
            CMTRACE(TEXT("ExpandEnvironmentStringsAU -- NULL pointer returned for pszAnsiSrc or pszAnsiDst"));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }

        CmFree(pszAnsiSrc);
        CmFree(pszAnsiDst);
    }
    else
    {
        CMTRACE(TEXT("ExpandEnvironmentStringsAU -- NULL pointer passed for lpSrc"));
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  FindResourceExAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 FindResourceEx API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
HRSRC WINAPI FindResourceExAU(IN HMODULE hModule, IN LPCWSTR lpType, IN LPCWSTR lpName, IN WORD wLanguage)
{
    HRSRC hReturn = NULL;
    LPSTR pszType = NULL;
    LPSTR pszName = NULL;

    //
    //  Check the input parameters
    //
    if (lpType && lpName)
    {
        //
        //  Two cases for the lpType and the lpName params.  These could just be identifiers.  We will know
        //  if the high word is zero.  In that case we just need to do a cast and pass it through.  If not
        //  then we need to actually convert the strings.
        //

        if (0 == HIWORD(lpType))
        {
            pszType = (LPSTR)lpType;
        }
        else
        {
            pszType = WzToSzWithAlloc(lpType);
        }

        if (0 == HIWORD(lpName))
        {
            pszName = (LPSTR)lpName;
        }
        else
        {
            pszName = WzToSzWithAlloc(lpName);
        }

        //
        //  Finally call FindResourceEx
        //
        if (pszName && pszType)
        {
            hReturn = FindResourceExA(hModule, pszType, pszName, wLanguage);
        }
        else
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);        
        }
    }
    else
    {
         SetLastError(ERROR_INVALID_PARAMETER);   
    }


    //
    //  Clean up
    //

    if (0 != HIWORD(pszType))
    {
        CmFree(pszType);
    }

    if (0 != HIWORD(pszName))
    {
        CmFree(pszName);
    }

    return hReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  FindWindowExAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 FindWindowEx API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
HWND WINAPI FindWindowExAU(IN HWND hwndParent, IN HWND hwndChildAfter, IN LPCWSTR pszClass, IN LPCWSTR pszWindow)
{
    HWND hReturn = NULL;
    LPSTR pszAnsiWindow = NULL;
    LPSTR pszAnsiClass = NULL;

    if (pszClass)
    {
        //
        //  We have two cases for pszClass.  It can either be a resource ID (high word zero,
        //  low word contains the ID) in which case we just need to do a cast or
        //  it could be a NULL terminated string.
        //
        if (0 == HIWORD(pszClass))
        {
            pszAnsiClass = (LPSTR)pszClass;
        }
        else
        {
            pszAnsiClass = WzToSzWithAlloc(pszClass);
        }

        //
        //  pszWindow could be NULL.  That will match all Window titles.
        //
        if (pszWindow)
        {
            pszAnsiWindow = WzToSzWithAlloc(pszWindow);
        }
        
        //
        //  Check our allocations and call FindWindowExA
        //
        if (pszAnsiClass && (!pszWindow || pszAnsiWindow))
        {
            hReturn = FindWindowExA(hwndParent, hwndChildAfter, pszAnsiClass, pszAnsiWindow);
        }
        else
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);           
    }

    //
    //  Cleanup
    //
    if (0 != HIWORD(pszAnsiClass))
    {
        CmFree(pszAnsiClass);
    }

    CmFree(pszAnsiWindow);

    return hReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  GetDateFormatAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 GetDateFormat API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   sumitc Created    11/20/00
//
//+----------------------------------------------------------------------------
int WINAPI GetDateFormatAU(IN LCID Locale, IN DWORD dwFlags,
                                IN CONST SYSTEMTIME *lpDate, IN LPCWSTR lpFormat,
                                OUT LPWSTR lpDateStr, IN int cchDate)
{
    int iReturn = 0;
    LPSTR pszAnsiFormat = NULL;
    LPSTR pszAnsiBuffer = NULL;

    if (lpFormat)
    {
        pszAnsiFormat = WzToSzWithAlloc(lpFormat);
        if (!pszAnsiFormat)
        {
            CMASSERTMSG(FALSE, TEXT("GetDateFormatAU -- Conversion of lpFormat Failed."));
            goto exit;
        }
    }
    else
    {
        pszAnsiFormat = (LPSTR)lpFormat; // Could be NULL
    }

    if (lpDateStr && cchDate)
    {
        pszAnsiBuffer = (LPSTR) CmMalloc(cchDate * sizeof(CHAR));
    }

    iReturn = GetDateFormatA(Locale, dwFlags, lpDate, pszAnsiFormat, pszAnsiBuffer, cchDate);

    if (iReturn && lpDateStr && cchDate && pszAnsiBuffer) 
    {
        SzToWz(pszAnsiBuffer, lpDateStr, cchDate);
    }

exit:

    CmFree(pszAnsiFormat);
    CmFree(pszAnsiBuffer);

    return iReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  GetDlgItemTextAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 GetDlgItemText API.  Note that
//            this function makes a WM_GETTEXT window message call using GetDlgItem
//            and SendMessageAU.  This is how the win32 API function is implemented.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
UINT WINAPI GetDlgItemTextAU(IN HWND hDlg, IN int nIDDlgItem, OUT LPWSTR pszwString, IN int nMaxCount)
{
    return (int) SendMessageAU(GetDlgItem(hDlg, nIDDlgItem), WM_GETTEXT, (WPARAM) nMaxCount, (LPARAM) pszwString);
}


//+----------------------------------------------------------------------------
//
// Function:  GetFileAttributesAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 GetFileAttributes API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   sumitc Created    11/08/00
//
//+----------------------------------------------------------------------------
DWORD WINAPI GetFileAttributesAU(LPCWSTR lpFileName)
{
    DWORD dwReturn = -1;
    LPSTR pszAnsiFileName = WzToSzWithAlloc(lpFileName);
    
    if (pszAnsiFileName)
    {
        dwReturn = GetFileAttributesA(pszAnsiFileName);
        
        CmFree(pszAnsiFileName);
    }

    return dwReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  GetModuleFileNameAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 GetModuleFileName API.
//            Note that we only allow MAX_PATH chars for the module name.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
DWORD WINAPI GetModuleFileNameAU(HMODULE hModule, LPWSTR lpFileName, DWORD nSize)
{
    DWORD dwReturn = 0;
    CHAR pszAnsiFileName[MAX_PATH] = {'\0'} ;

    MYDBGASSERT(MAX_PATH >= nSize);

    dwReturn = GetModuleFileNameA(hModule, pszAnsiFileName, __min(nSize, MAX_PATH));

    if(dwReturn && lpFileName) 
    {
        SzToWz(pszAnsiFileName, lpFileName, __min(nSize, MAX_PATH));
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetModuleHandleAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 GetModuleHandle API.
//            Note that we only allow MAX_PATH chars for the module name.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   sumitc Created    10/20/2000
//
//+----------------------------------------------------------------------------
HMODULE WINAPI GetModuleHandleAU(LPCWSTR lpModuleName)
{
    HMODULE hMod = NULL;
    LPSTR   pszAnsiModuleName = WzToSzWithAlloc(lpModuleName);

    if (pszAnsiModuleName)
    {
        hMod = GetModuleHandleA(pszAnsiModuleName);

        CmFree(pszAnsiModuleName);
    }

    return hMod;
}

//+----------------------------------------------------------------------------
//
// Function:  GetPrivateProfileIntAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 GetPrivateProfileInt API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
UINT WINAPI GetPrivateProfileIntAU(IN LPCWSTR lpAppName, IN LPCWSTR lpKeyName, IN INT nDefault, 
                                   IN LPCWSTR lpFileName)
{
    UINT uReturn = nDefault;

    if (lpAppName && lpKeyName && lpFileName)
    {
        CHAR pszAnsiAppName[MAX_PATH+1];
        CHAR pszAnsiKeyName[MAX_PATH+1];
        CHAR pszAnsiFileName[MAX_PATH+1];

        BOOL bSuccess = TRUE;
        int nChars;
        nChars = WzToSz(lpAppName, pszAnsiAppName, MAX_PATH);
        bSuccess =  bSuccess && nChars && (MAX_PATH >= nChars);

        nChars = WzToSz(lpKeyName, pszAnsiKeyName, MAX_PATH);
        bSuccess =  bSuccess && nChars && (MAX_PATH >= nChars);

        nChars = WzToSz(lpFileName, pszAnsiFileName, MAX_PATH);
        bSuccess =  bSuccess && nChars && (MAX_PATH >= nChars);

        if (bSuccess)
        {
            uReturn = GetPrivateProfileIntA(pszAnsiAppName, pszAnsiKeyName, nDefault, 
                pszAnsiFileName);
        }

        CMASSERTMSG(bSuccess, TEXT("GetPrivateProfileIntAU -- Failed to convert lpAppName, lpKeyName, or lpFileName"));
    }

    return uReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetPrivateProfileStringAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 GetPrivateProfileString API.
//            Note that either lpAppName or lpKeyName could be NULL.  This means
//            that our return buffer will contain multiple lines of NULL terminated
//            text.  We must use MultiByteToWideChar directly with a size param
//            to properly convert such a situation.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
DWORD WINAPI GetPrivateProfileStringAU(IN LPCWSTR lpAppName, IN LPCWSTR lpKeyName, 
                                       IN LPCWSTR lpDefault, OUT LPWSTR lpReturnedString, 
                                       IN DWORD nSize, IN LPCWSTR lpFileName)
{
    //
    //  Declare all the temp vars we need
    //
    LPSTR pszAnsiAppName = NULL;
    LPSTR pszAnsiKeyName = NULL;
    LPSTR pszAnsiReturnedString = NULL;
    CHAR szAnsiAppName[MAX_PATH+1];
    CHAR szAnsiKeyName[MAX_PATH+1];
    CHAR szAnsiDefault[MAX_PATH+1];
    CHAR szAnsiFileName[MAX_PATH+1];
    DWORD dwReturn = 0;
    int nChars;

    //
    //  Check the inputs, note that either lpAppName or lpKeyName may be NULL (or both)
    //
    if (lpDefault && lpReturnedString && nSize && lpFileName)
    {
        if (lpAppName) // pszAnsiAppName already initialized to NULL
        {
            pszAnsiAppName = szAnsiAppName;
            nChars = WzToSz(lpAppName, pszAnsiAppName, MAX_PATH);
            if (!nChars || (MAX_PATH < nChars))
            {
                //
                //  Conversion failed.
                //
                goto exit;
            }
        }

        if (lpKeyName) // pszAnsiKeyName already initialized to NULL
        {
            pszAnsiKeyName = szAnsiKeyName;
            nChars = WzToSz(lpKeyName, szAnsiKeyName, MAX_PATH);
            if (!nChars || (MAX_PATH < nChars))
            {
                //
                //  Conversion failed.
                //
                goto exit;
            }
        }
        
        nChars = WzToSz(lpDefault, szAnsiDefault, MAX_PATH);
        if (!nChars || (MAX_PATH < nChars))
        {
            goto exit;
        }

        nChars = WzToSz(lpFileName, szAnsiFileName, MAX_PATH);
        if (!nChars || (MAX_PATH < nChars))            
        {
            goto exit;
        }

        //
        //  Alloc the Ansi return Buffer
        //
        pszAnsiReturnedString = (LPSTR)CmMalloc(nSize*sizeof(CHAR));

        if (pszAnsiReturnedString)
        {
            dwReturn = GetPrivateProfileStringA(pszAnsiAppName, pszAnsiKeyName, szAnsiDefault, 
                                                pszAnsiReturnedString, nSize, szAnsiFileName);

            if (dwReturn)
            {
                if (pszAnsiAppName && pszAnsiKeyName)
                {
                    if (!SzToWz(pszAnsiReturnedString, lpReturnedString, nSize))
                    {
                        dwReturn = 0;
                    }
                }
                else
                {
                    //
                    //  We have multiple lines of text in the return buffer, use MultiByteToWideChar
                    //  with a size specifier
                    //
                    if (!MultiByteToWideChar(CP_ACP, 0, pszAnsiReturnedString, dwReturn, 
                                             lpReturnedString, nSize))
                    {
                        dwReturn = 0;
                    }
                }
            }
        }
    }

exit:

    CmFree(pszAnsiReturnedString);
    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetStringTypeExAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 GetStringTypeEx API.  Note
//            that because we only use one char at a time with this API, I have
//            limited it to a 10 char static buffer to make it faster.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL WINAPI GetStringTypeExAU(IN LCID Locale, IN DWORD dwInfoType, IN LPCWSTR lpSrcStr, 
                              IN int cchSrc, OUT LPWORD lpCharType)
{
    BOOL bReturn = FALSE;
    CHAR szAnsiString[10];  // We should only be using 1 char at a time with this

    if (lpSrcStr && cchSrc)
    {
        MYDBGASSERT(cchSrc <= 10);

        int nCount = WideCharToMultiByte(CP_ACP, 0, lpSrcStr, cchSrc, szAnsiString, 
                                         9, NULL, NULL);

        if (nCount) // nCount may not exactly equal cchSrc if DBCS chars were necessary
        {
            bReturn = GetStringTypeExA(Locale, dwInfoType, szAnsiString, nCount, lpCharType);
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetSystemDirectoryAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 GetSystemDirectory API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
UINT WINAPI GetSystemDirectoryAU(OUT LPWSTR lpBuffer, IN UINT uSize)
{
    UINT uReturn = 0;
    LPSTR pszAnsiSystemDir;

    pszAnsiSystemDir = uSize ? (LPSTR)CmMalloc(uSize*sizeof(CHAR)) : NULL;

    if (pszAnsiSystemDir || (0 == uSize))
    {
        uReturn = GetSystemDirectoryA(pszAnsiSystemDir, uSize);
        CMASSERTMSG(uReturn, TEXT("GetSystemDirectoryAU -- GetSystemDirectoryAU failed."));

        if (uReturn && lpBuffer && (uSize >= uReturn))
        {
            if (!SzToWz(pszAnsiSystemDir, lpBuffer, uSize))
            {
                //
                //  Conversion failed.
                //
                CMASSERTMSG(FALSE, TEXT("GetSystemDirectoryAU -- SzToWz conversion failed."));
                uReturn = 0;
            }
        }
    }

    CmFree(pszAnsiSystemDir);

    return uReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetTempFileNameAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 GetTempFileName API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
UINT WINAPI GetTempFileNameAU(IN LPCWSTR lpPathName, IN LPCWSTR lpPrefixString, IN UINT uUnique, 
                              OUT LPWSTR lpTempFileName)
{
    UINT uReturn = 0;

    if (lpPathName && lpPrefixString && lpTempFileName)
    {
        CHAR szAnsiTempFileName[MAX_PATH+1];
        CHAR szPathName[MAX_PATH+1];
        CHAR szPrefixString[MAX_PATH+1];
        BOOL bSuccess = TRUE;
        int nChars;
        
        nChars = WzToSz(lpPathName, szPathName, MAX_PATH);
        bSuccess =  bSuccess && nChars && (MAX_PATH >= nChars);

        nChars = WzToSz(lpPrefixString, szPrefixString, MAX_PATH);
        bSuccess =  bSuccess && nChars && (MAX_PATH >= nChars);

        if (bSuccess)
        {
            uReturn = GetTempFileNameA(szPathName, szPrefixString, uUnique, szAnsiTempFileName);
            if (uReturn)
            {
                if (!SzToWz(szAnsiTempFileName, lpTempFileName, MAX_PATH))
                {
                    CMASSERTMSG(FALSE, TEXT("GetTempFileNameAU -- conversion of output buffer failed."));
                    uReturn = 0;
                }
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("GetTempFileNameAU -- conversion of inputs failed."));
            SetLastError(ERROR_INVALID_PARAMETER);
        }
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return uReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetTempPathAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 GetTempPath API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
DWORD WINAPI GetTempPathAU(IN DWORD nBufferLength, OUT LPWSTR lpBuffer)
{
    UINT uReturn = 0;

    LPSTR pszAnsiBuffer = (LPSTR)CmMalloc(nBufferLength*sizeof(CHAR));

    if (pszAnsiBuffer)
    {
        uReturn = GetTempPathA(nBufferLength, pszAnsiBuffer);
        if (uReturn)
        {
            if (!SzToWz(pszAnsiBuffer, lpBuffer, nBufferLength))
            {
                CMASSERTMSG(FALSE, TEXT("GetTempPathAU -- conversion of output buffer failed."));
                uReturn = 0;
            }
        }
        CmFree(pszAnsiBuffer);
    }

    return uReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  GetTimeFormatAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 GetTimeFormat API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   sumitc Created    11/20/00
//
//+----------------------------------------------------------------------------
int WINAPI GetTimeFormatAU(IN LCID Locale, IN DWORD dwFlags,
                                IN CONST SYSTEMTIME *lpTime, IN LPCWSTR lpFormat,
                                OUT LPWSTR lpTimeStr, IN int cchTime)
{
    int iReturn = 0;
    LPSTR pszAnsiFormat = NULL;
    LPSTR pszAnsiBuffer = NULL;

    if (lpFormat)
    {
        pszAnsiFormat = WzToSzWithAlloc(lpFormat);
        if (!pszAnsiFormat)
        {
            CMASSERTMSG(FALSE, TEXT("GetTimeFormatAU -- Conversion of lpFormat Failed."));
            goto exit;
        }
    }
    else
    {
        pszAnsiFormat = (LPSTR)lpFormat; // Could be NULL
    }

    if (lpTimeStr && cchTime)
    {
        pszAnsiBuffer = (LPSTR) CmMalloc(cchTime * sizeof(CHAR));
    }

    iReturn = GetTimeFormatA(Locale, dwFlags, lpTime, pszAnsiFormat, pszAnsiBuffer, cchTime);

    if (iReturn && lpTimeStr && cchTime && pszAnsiBuffer) 
    {
        SzToWz(pszAnsiBuffer, lpTimeStr, cchTime);
    }

exit:

    CmFree(pszAnsiFormat);
    CmFree(pszAnsiBuffer);

    return iReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  GetUserNameAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 GetUserName API.
//            Note that we assume the user name will fit in MAX_PATH chars.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL WINAPI GetUserNameAU(OUT LPWSTR lpBuffer, IN OUT LPDWORD pdwSize)
{
    BOOL bReturn = FALSE;

    if (lpBuffer && pdwSize && *pdwSize)
    {        
        MYDBGASSERT(MAX_PATH >= *pdwSize);
        CHAR szAnsiBuffer[MAX_PATH+1];  // API says UNLEN+1 needed but this is less than MAX_PATH
        DWORD dwTemp = MAX_PATH;

        bReturn = GetUserNameA(szAnsiBuffer, &dwTemp);

        if (bReturn)
        {
            if (!SzToWz(szAnsiBuffer, lpBuffer, *pdwSize))
            {
                bReturn = FALSE;
            }
            else
            {
                *pdwSize = lstrlenAU(lpBuffer) + 1;
            }
        }        
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    CMASSERTMSG(bReturn, TEXT("GetUserNameAU Failed."));

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetVersionExAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 GetVersionEx API.  Note that
//            we check to make sure we aren't passed an OSVERSIONINFOEXW struct
//            because that struct is currently NT5 only.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL WINAPI GetVersionExAU(IN OUT LPOSVERSIONINFOW lpVersionInformation)
{
    BOOL bReturn = FALSE;

    if (lpVersionInformation)
    {
        OSVERSIONINFOA AnsiVersionInfo;
        
        //
        //  Check to make sure we didn't get an OSVERSIONINFOEXW struct instead of a OSVERSIONINFO
        //  the EX version is NT5 only we shouldn't be calling this on NT5.
        //
        MYDBGASSERT(lpVersionInformation->dwOSVersionInfoSize != sizeof(_OSVERSIONINFOEXW));

        AnsiVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

        bReturn = GetVersionExA(&AnsiVersionInfo);
        if (bReturn)
        {
            //lpVersionInformation.dwOSVersionInfoSize; // should be set appropriately already
            lpVersionInformation->dwMajorVersion = AnsiVersionInfo.dwMajorVersion;
            lpVersionInformation->dwMinorVersion = AnsiVersionInfo.dwMinorVersion;
            lpVersionInformation->dwBuildNumber = AnsiVersionInfo.dwBuildNumber;
            lpVersionInformation->dwPlatformId = AnsiVersionInfo.dwPlatformId;

            if (!SzToWz(AnsiVersionInfo.szCSDVersion, lpVersionInformation->szCSDVersion, 128-1))
            {
                bReturn = FALSE;
            }
        }
    }

    CMASSERTMSG(bReturn, TEXT("GetVersionExAU Failed"));
    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetWindowTextAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 GetWindowText API.  This API
//            is implemented as a WM_GETTEXT message just as the real windows
//            API is.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
int WINAPI GetWindowTextAU(HWND hWnd, LPWSTR lpStringW, int nMaxChars)
{
    return (int) SendMessageAU(hWnd, WM_GETTEXT, (WPARAM) nMaxChars, (LPARAM) lpStringW);
}

//+----------------------------------------------------------------------------
//
// Function:  GetWindowTextAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 GetWindowText API.  This API
//            is implemented as a WM_GETTEXT message just as the real windows
//            API is.  Note that since MF_STRING is 0, we must check to make sure
//            that it isn't one of the other menu item choices (MF_OWNERDRAW, 
//            MF_BITMAP, or MF_SEPARATOR).  The other MF_ flags are just modifiers
//            for the above basic types. 
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL WINAPI InsertMenuAU(IN HMENU hMenu, IN UINT uPosition, IN UINT uFlags, 
                         IN UINT_PTR uIDNewItem, IN LPCWSTR lpNewItem)
{
    BOOL bReturn = FALSE;
    LPSTR pszAnsiNewItem = NULL;
    BOOL bFreeAnsiNewItem = FALSE;

    if (hMenu)
    {
        //
        //  Since MF_STRING == 0, we must check that it is not MF_OWNERDRAW or MF_BITMAP or
        //  that it is not MF_SEPARATOR
        //
        if ((0 == (uFlags & MF_BITMAP)) && (0 == (uFlags & MF_OWNERDRAW)) && 
            (0 == (uFlags & MF_SEPARATOR)) && lpNewItem)
        {
            //
            //  Then the menu item actually contains a string and we must convert it.
            //
            pszAnsiNewItem = WzToSzWithAlloc(lpNewItem);

            if (!pszAnsiNewItem)
            {
                CMASSERTMSG(FALSE, TEXT("InsertMenuAU -- Conversion of lpNewItem Failed."));
                goto exit;
            }
            
            bFreeAnsiNewItem = TRUE;
        }
        else
        {
            pszAnsiNewItem = (LPSTR)lpNewItem; // Could be NULL
        }

        bReturn = InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, pszAnsiNewItem);
    }

exit:

    if (bFreeAnsiNewItem)
    {
        CmFree(pszAnsiNewItem);
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  LoadCursorAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 LoadCursor API.  Note that
//            lpCursorName could be a string or it could be a resource ID from
//            MAKEINTRESOURCE.  We assume the cursor name will fit in MAX_PATH
//            chars if it is a string.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
HCURSOR WINAPI LoadCursorAU(IN HINSTANCE hInstance, IN LPCWSTR lpCursorName)
{
    LPSTR pszCursorName;
    CHAR szCursorName[MAX_PATH+1];
    HCURSOR hReturn = NULL;

    if (lpCursorName)
    {
        BOOL bSuccess = TRUE;

        if (0 == HIWORD(lpCursorName))
        {
            pszCursorName = (LPSTR)lpCursorName;
        }
        else
        {
            int nChars;
            pszCursorName = szCursorName;
                    
            nChars = WzToSz(lpCursorName, pszCursorName, MAX_PATH);
            bSuccess =  bSuccess && nChars && (MAX_PATH >= nChars);
        }

        if (bSuccess)
        {
            hReturn = LoadCursorA(hInstance, pszCursorName);
        }    
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return hReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  LoadIconAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 LoadIcon API.  Note that
//            lpIconName could be a string or it could be a resource ID from
//            MAKEINTRESOURCE.  We assume the icon name will fit in MAX_PATH
//            chars if it is a string.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
HICON WINAPI LoadIconAU(IN HINSTANCE hInstance, IN LPCWSTR lpIconName)
{
    LPSTR pszIconName;
    CHAR szIconName[MAX_PATH+1];
    HICON hReturn = NULL;

    if (hInstance && lpIconName)
    {
        BOOL bSuccess = TRUE;

        if (0 == HIWORD(lpIconName))
        {
            pszIconName = (LPSTR)lpIconName;
        }
        else
        {
            int nChars;
            pszIconName = szIconName;
                    
            nChars = WzToSz(lpIconName, pszIconName, MAX_PATH);
            bSuccess =  bSuccess && nChars && (MAX_PATH >= nChars);
        }

        if (bSuccess)
        {
            hReturn = LoadIconA(hInstance, pszIconName);
        }    
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return hReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  LoadImageAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 LoadImage API.  Note that
//            pszwName could be a string or it could be a resource ID from
//            MAKEINTRESOURCE.  We assume the image name will fit in MAX_PATH
//            chars if it is a string.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
HANDLE WINAPI LoadImageAU(IN HINSTANCE hInst, IN LPCWSTR pszwName, IN UINT uType, IN int cxDesired, 
                          IN int cyDesired, IN UINT fuLoad)
{
    HANDLE hReturn = NULL;

    MYDBGASSERT(hInst || (LR_LOADFROMFILE & fuLoad)); // we don't support loading OEM images -- implement it if you need it.

    if (pszwName)
    {
        CHAR szAnsiName [MAX_PATH+1];
        LPSTR pszAnsiName;

        if (0 == HIWORD(pszwName))
        {
            pszAnsiName = LPSTR(pszwName);
        }
        else
        {
            pszAnsiName = szAnsiName;
            int iChars = WzToSz(pszwName, pszAnsiName, MAX_PATH);

            if (!iChars || (MAX_PATH < iChars))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto exit;
            }
        }

        hReturn = LoadImageA(hInst, pszAnsiName, uType, cxDesired, cyDesired, fuLoad);
    }

exit:

    return hReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  LoadLibraryExAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 LoadLibraryEx API.  Note that
//            we expect the library name to fit in MAX_PATH ANSI chars.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
HMODULE WINAPI LoadLibraryExAU(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
{
    CHAR pszLibFileName[MAX_PATH+1];
    HMODULE hReturn = NULL;

    if (lpLibFileName && (NULL == hFile)) // hFile is reserved, it must be NULL
    {
        if(WzToSz(lpLibFileName, pszLibFileName, MAX_PATH))
        {
            hReturn = LoadLibraryExA(pszLibFileName, hFile, dwFlags);            
        }
    }

    return hReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  LoadMenuAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 LoadMenu API.  Note that
//            lpMenuName could be a string or it could be a resource ID from
//            MAKEINTRESOURCE.  We assume the menu name will fit in MAX_PATH
//            chars if it is a string.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
HMENU WINAPI LoadMenuAU(IN HINSTANCE hInstance, IN LPCWSTR lpMenuName)
{
    HMENU hMenuReturn = NULL;
    LPSTR pszAnsiMenuName;
    CHAR szAnsiMenuName[MAX_PATH+1];

    if (hInstance && lpMenuName)
    {
        if (HIWORD(lpMenuName))
        {
            pszAnsiMenuName = szAnsiMenuName;
            int iChars = WzToSz(lpMenuName, pszAnsiMenuName, MAX_PATH);
            if (!iChars || (MAX_PATH < iChars))
            {
                goto exit;
            }
        }
        else
        {
            pszAnsiMenuName = (LPSTR)lpMenuName;
        }

        hMenuReturn = LoadMenuA(hInstance, pszAnsiMenuName);
    }

exit:
    return hMenuReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  LoadStringAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 LoadString API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
int WINAPI LoadStringAU(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBufferMax)
{
    int iReturn = 0;

    if (uID && hInstance) // lpBuffer and nBufferMax could be Zero
    {
        LPSTR pszAnsiBuffer = nBufferMax ? (LPSTR)CmMalloc(nBufferMax*sizeof(CHAR)) : NULL;
        if (pszAnsiBuffer || (0 == nBufferMax))
        {
            iReturn = LoadStringA(hInstance, uID, pszAnsiBuffer, nBufferMax);

            if (lpBuffer && iReturn && (iReturn <= nBufferMax))
            {
                if (!SzToWz(pszAnsiBuffer, lpBuffer, nBufferMax))
                {
                    iReturn = 0;
                }
            }
        }
        CmFree(pszAnsiBuffer);
    }

    CMASSERTMSG(iReturn, TEXT("LoadStringAU Failed."));

    return iReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  lstrcatAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 lstrcat API.  Note that we
//            use wcscat instead of doing a conversion from Unicode to ANSI,
//            then using lstrcatA, and then converting back to Unicode again.
//            That seemed like a lot of effort when wcscat should work just fine.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
LPWSTR WINAPI lstrcatAU(IN OUT LPWSTR lpString1, IN LPCWSTR lpString2)
{
    if (lpString2 && lpString2)
    {
        return wcscat(lpString1, lpString2);
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("NULL String passed to lstrcatAU"));
        return lpString1;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  lstrcmpAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 lstrcmp API.  Note that we
//            use wcscmp instead of doing a conversion from Unicode to ANSI,
//            then using lstrcmpA, and then converting back to Unicode again.
//            That seemed like a lot of effort when wcscmp should work just fine.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
int WINAPI lstrcmpAU(IN LPCWSTR lpString1, IN LPCWSTR lpString2)
{
    if (lpString1 && lpString2)
    {
        return wcscmp(lpString1, lpString2);
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("NULL String passed to lstrcmpAU"));
        //
        // Wasn't exactly sure what to do on failure since their isn't a failure
        // return value from lstrcmp.  I looked at the current implementation
        // and they do something like the following.
        //
        if (lpString1)
        {
            return 1;
        }
        else if (lpString2)
        {
            return -1;
        }
        else
        {
            return 0;
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  lstrcmpiAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 lstrcmpi API.  Note that we
//            use _wcsicmp instead of doing a conversion from Unicode to ANSI,
//            then using lstrcmpiA, and then converting back to Unicode again.
//            That seemed like a lot of effort when _wcsicmp should work just fine.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
int WINAPI lstrcmpiAU(IN LPCWSTR lpString1, IN LPCWSTR lpString2)
{
    if (lpString1 && lpString2)
    {
        return _wcsicmp(lpString1, lpString2);
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("NULL String passed to lstrcmpiAU"));
        //
        // Wasn't exactly sure what to do on failure since their isn't a failure
        // return value from lstrcmp.  I looked at the current implementation
        // and they do something like the following.
        //
        if (lpString1)
        {
            return 1;
        }
        else if (lpString2)
        {
            return -1;
        }
        else
        {
            return 0;
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  lstrcpyAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 lstrcpy API.  Note that we
//            use wcscpy instead of doing a conversion from Unicode to ANSI,
//            then using lstrcpyA, and then converting back to Unicode again.
//            That seemed like a lot of effort when wcscpy should work just fine.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
LPWSTR WINAPI lstrcpyAU(OUT LPWSTR pszDest, IN LPCWSTR pszSource)
{
    if (pszDest && pszSource)
    {
        return wcscpy(pszDest, pszSource);
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("NULL String passed to lstrcpyAU"));
        return pszDest;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  lstrcpynAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 lstrcpyn API.  Note that we
//            use wcsncpy instead of doing a conversion from Unicode to ANSI,
//            then using lstrcpynA, and then converting back to Unicode again.
//            That seemed like a lot of effort when wcsncpy should work just fine.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
LPWSTR WINAPI lstrcpynAU(OUT LPWSTR pszDest, IN LPCWSTR pszSource, IN int iMaxLength)
{
    if (pszDest && pszSource && iMaxLength)
    {
        LPWSTR pszReturn = wcsncpy(pszDest, pszSource, iMaxLength);

        //
        //  wcsncpy and lstrcpy behave differently about terminating NULL
        //  characters.  The last char in the lstrcpyn buffer always gets
        //  a TEXT('\0'), whereas wcsncpy doesn't do this.  Thus we must
        //  NULL the last char before returning.
        //

        pszDest[iMaxLength-1] = TEXT('\0');

        return pszReturn;
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("Invalid parameter passed to lstrcpynAU"));
        return pszDest;    
    }
}

//+----------------------------------------------------------------------------
//
// Function:  lstrlenAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 lstrlen API.  Note that we
//            use wcslen instead of doing a conversion from Unicode to ANSI,
//            then using lstrlenA, and then converting back to Unicode again.
//            That seemed like a lot of effort when wcslen should work just fine.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
int WINAPI lstrlenAU(IN LPCWSTR lpString)
{
    if (lpString)
    {
        return wcslen(lpString);
    }
    else
    {
//        CMASSERTMSG(FALSE, TEXT("NULL String passed to lstrlenAU"));
        return 0;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  OpenEventAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 OpenEvent API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
HANDLE WINAPI OpenEventAU(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName)
{
    HANDLE hReturn = NULL;

    if (lpName)
    {
        LPSTR pszAnsiName = WzToSzWithAlloc(lpName);
        
        if (pszAnsiName)
        {
            hReturn = OpenEventA(dwDesiredAccess, bInheritHandle, pszAnsiName);
        }

        CmFree(pszAnsiName);
    }

    return hReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  OpenFileMappingAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 OpenFileMapping API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
HANDLE WINAPI OpenFileMappingAU(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName)
{
    HANDLE hReturn = NULL;

    if (lpName)
    {
        LPSTR pszAnsiName = WzToSzWithAlloc(lpName);
        
        if (pszAnsiName)
        {
            hReturn = OpenFileMappingA(dwDesiredAccess, bInheritHandle, pszAnsiName);
        }

        CmFree(pszAnsiName);
    }

    return hReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RegCreateKeyExAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RegCreateKeyEx API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
LONG APIENTRY RegCreateKeyExAU(IN HKEY hKey, IN LPCWSTR lpSubKey, IN DWORD Reserved, IN LPWSTR lpClass,
                               IN DWORD dwOptions, IN REGSAM samDesired, IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                               OUT PHKEY phkResult, OUT LPDWORD lpdwDisposition)
{
    LONG lReturn = ERROR_INVALID_PARAMETER;
    
    if (lpSubKey)
    {
        LPSTR pszAnsiSubKey = WzToSzWithAlloc(lpSubKey);
        LPSTR pszAnsiClass = lpClass ? WzToSzWithAlloc(lpClass) : NULL;

        if (pszAnsiSubKey && (pszAnsiClass || !lpClass))
        {
            lReturn = RegCreateKeyExA(hKey, pszAnsiSubKey, Reserved, pszAnsiClass,
                                      dwOptions, samDesired, lpSecurityAttributes,
                                      phkResult, lpdwDisposition);
        }
        else
        {
            lReturn = ERROR_NOT_ENOUGH_MEMORY;   
        }

        CmFree(pszAnsiSubKey);
        CmFree(pszAnsiClass);
    }

    CMASSERTMSG(ERROR_SUCCESS == lReturn, TEXT("RegCreateKeyExAU Failed."));
    return lReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RegDeleteKeyAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RegDeleteKey API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
LONG APIENTRY RegDeleteKeyAU(IN HKEY hKey, IN LPCWSTR lpSubKey)
{
    LONG lReturn = ERROR_INVALID_PARAMETER;

    if (lpSubKey)
    {
        LPSTR pszAnsiSubKey = WzToSzWithAlloc(lpSubKey);

        if (pszAnsiSubKey)
        {
            lReturn = RegDeleteKeyA(hKey, pszAnsiSubKey);
        }
        else
        {
            lReturn = ERROR_NOT_ENOUGH_MEMORY;   
        }

        CmFree(pszAnsiSubKey);
    }

    CMASSERTMSG(ERROR_SUCCESS == lReturn, TEXT("RegDeleteKeyAU Failed."));
    return lReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RegDeleteValueAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RegDeleteValue API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
LONG APIENTRY RegDeleteValueAU(IN HKEY hKey, IN LPCWSTR lpValueName)
{
    LONG lReturn = ERROR_INVALID_PARAMETER;

    if (lpValueName)
    {
        LPSTR pszAnsiValueName = WzToSzWithAlloc(lpValueName);

        if (pszAnsiValueName)
        {
            lReturn = RegDeleteValueA(hKey, pszAnsiValueName);
            CmFree(pszAnsiValueName);
        }
        else
        {
            lReturn = ERROR_NOT_ENOUGH_MEMORY;           
        }
    }

    return lReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RegEnumKeyExAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RegEnumKeyEx API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
LONG RegEnumKeyExAU(IN HKEY hKey, IN DWORD dwIndex, OUT LPWSTR lpName, IN OUT LPDWORD lpcbName, IN LPDWORD lpReserved, IN OUT LPWSTR lpClass, IN OUT LPDWORD lpcbClass, OUT PFILETIME lpftLastWriteTime)
{    
    LONG lReturn = ERROR_INVALID_PARAMETER;

    if (lpcbName)
    {
        MYDBGASSERT((lpName && *lpcbName) || ((NULL == lpName) && (0 == *lpcbName)));

        LPSTR pszAnsiClass = lpClass ? WzToSzWithAlloc(lpClass) : NULL;

        LPSTR pszTmpBuffer = lpName ? (LPSTR)CmMalloc(*lpcbName) : NULL;

        DWORD dwSizeTmp = lpName ? *lpcbName : 0;

        if (pszTmpBuffer || (NULL == lpName))
        {
            lReturn = RegEnumKeyExA(hKey, dwIndex, pszTmpBuffer, &dwSizeTmp, lpReserved, pszAnsiClass, lpcbClass, lpftLastWriteTime);

            if ((ERROR_SUCCESS == lReturn) && pszTmpBuffer)
            {
                if (!SzToWz(pszTmpBuffer, lpName, (*lpcbName)))
                {
                    lReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    *lpcbName = (lstrlenAU((WCHAR*)lpName) + 1);
                }
            }
        }
        else
        {
            lReturn = ERROR_NOT_ENOUGH_MEMORY;
        }

        CmFree(pszTmpBuffer);
    }

    return lReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RegisterClassExAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RegisterClassEx API.  Note
//            that we don't deal with the lpszMenuName parameter.  If this is
//            needed then conversion code will have to be written.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
ATOM WINAPI RegisterClassExAU(CONST WNDCLASSEXW *lpWcw)
{
    WNDCLASSEXA wca;
    CHAR szClassName[MAX_PATH];
    ATOM ReturnAtom = 0;

    if (lpWcw->lpszClassName)
    {
        if (WzToSz(lpWcw->lpszClassName, szClassName, MAX_PATH))
        {
            wca.cbSize        = sizeof(WNDCLASSEXA);
            wca.lpfnWndProc   = lpWcw->lpfnWndProc;    
            wca.style         = lpWcw->style;
            wca.cbClsExtra    = lpWcw->cbClsExtra;
            wca.cbWndExtra    = lpWcw->cbWndExtra;
            wca.hInstance     = lpWcw->hInstance;
            wca.hIcon         = lpWcw->hIcon;
            wca.hCursor       = lpWcw->hCursor;
            wca.hbrBackground = lpWcw->hbrBackground;
            wca.hIconSm       = lpWcw->hIconSm;
            wca.lpszClassName = szClassName;
            
            MYDBGASSERT(NULL == lpWcw->lpszMenuName);
            wca.lpszMenuName = NULL;

            //
            //  Now register the class.
            //
            ReturnAtom = RegisterClassExA(&wca);
            if (0 == ReturnAtom)
            {
                //
                //  We want to assert failure unless we failed because the class
                //  was already registered.  This can happen if something
                //  calls two CM entry points without exiting first.  A prime
                //  example of this is rasrcise.exe.  Unfortunately, GetLastError()
                //  returns 0 when we try to register the class twice.  Thus I 
                //  will only assert if the ReturnAtom is 0 and dwError is non-zero.
                //
                DWORD dwError = GetLastError();
                CMASSERTMSG(!dwError, TEXT("RegisterClassExAU Failed."));
            }
        }
    }

    return  ReturnAtom;
}

//+----------------------------------------------------------------------------
//
// Function:  RegisterWindowMessageAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RegisterWindowMessage API.  Note
//            that we expect the message name to fit within MAX_PATH characters.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
UINT WINAPI RegisterWindowMessageAU(IN LPCWSTR lpString)
{
    UINT uReturn = 0;

    if (lpString)
    {
        MYDBGASSERT(MAX_PATH > lstrlenAU(lpString));
        CHAR szAnsiString [MAX_PATH+1];

        if (WzToSz(lpString, szAnsiString, MAX_PATH))
        {
            uReturn = RegisterWindowMessageA(szAnsiString);
        }
    }

    return uReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RegOpenKeyExAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RegOpenKeyEx API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
LONG APIENTRY RegOpenKeyExAU(IN HKEY hKey, IN LPCWSTR lpSubKey, IN DWORD ulOptions, 
                             IN REGSAM samDesired, OUT PHKEY phkResult)
{
    LONG lReturn = ERROR_INVALID_PARAMETER;

    if (lpSubKey)
    {
        LPSTR pszAnsiSubKey = WzToSzWithAlloc(lpSubKey);

        if (pszAnsiSubKey)
        {
            lReturn = RegOpenKeyExA(hKey, pszAnsiSubKey, ulOptions, samDesired, phkResult);
        }
        else
        {
            lReturn = ERROR_NOT_ENOUGH_MEMORY;   
        }

        CmFree(pszAnsiSubKey);
    }

//    CMASSERTMSG(ERROR_SUCCESS == lReturn, TEXT("RegOpenKeyExAU Failed."));
    return lReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RegQueryValueExAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RegQueryValueEx API.  Note that
//            we don't handle the REG_MULTI_SZ type.  We would have to have
//            special code to handle it and we currently don't need it.  Be careful
//            modifying this function unless you have read and thoroughly understood
//            all of the comments.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
LONG APIENTRY RegQueryValueExAU(IN HKEY hKey, IN LPCWSTR lpValueName, IN LPDWORD lpReserved, 
                                OUT LPDWORD lpType, IN OUT LPBYTE lpData, IN OUT LPDWORD lpcbData)
{
    LONG lReturn = ERROR_NOT_ENOUGH_MEMORY;

    //
    //  lpValueName could be NULL or it could be "".  In either case they are after the default
    //  entry so just pass NULL (don't convert "").
    //
    LPSTR pszAnsiValueName = (lpValueName && lpValueName[0]) ? WzToSzWithAlloc(lpValueName) : NULL;

    if (pszAnsiValueName || !lpValueName || (TEXT('\0') == lpValueName[0]))
    {
        //
        //  lpData could also be NULL, they may not actually want the value just to see if it exists
        //
        LPSTR pszTmpBuffer = lpData ? (LPSTR)CmMalloc(*lpcbData) : NULL;

        if (pszTmpBuffer || !lpData)
        {
            DWORD dwTemp = *lpcbData; // we don't want the original value overwritten
            lReturn = RegQueryValueExA(hKey, pszAnsiValueName, lpReserved, lpType, 
                                       (LPBYTE)pszTmpBuffer, &dwTemp);

            if ((ERROR_SUCCESS == lReturn) && pszTmpBuffer)
            {
                if ((REG_SZ == *lpType) || (REG_EXPAND_SZ == *lpType))
                {
                    if (!SzToWz(pszTmpBuffer, (WCHAR*)lpData, (*lpcbData)/sizeof(WCHAR)))
                    {
                        lReturn = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        *lpcbData = (lstrlenAU((WCHAR*)lpData) + 1) * sizeof(WCHAR);
                    }
                }
                else if (REG_MULTI_SZ == *lpType)
                {
                    //
                    //  We currently don't have the parsing logic to convert a Multi_SZ.
                    //  Since CM doesn't query any keys that return this type, this shouldn't
                    //  be a problem.  However, someday we may need to fill in this code.  For
                    //  now, just assert.
                    //
                    CMASSERTMSG(FALSE, TEXT("RegQueryValueExAU -- Converion and Parsing code for REG_MULTI_SZ UNIMPLEMENTED."));
                    lReturn = ERROR_CALL_NOT_IMPLEMENTED; // closest I could find to E_NOTIMPL
                }
                else
                {
                    //
                    //  Non - text data, nothing to convert so just copy it over
                    //
                    *lpcbData = dwTemp;
                    memcpy(lpData, pszTmpBuffer, dwTemp);            
                }
            }
            else
            {
                *lpcbData = dwTemp;                
            }

            CmFree (pszTmpBuffer);
        }
    }

    CmFree(pszAnsiValueName);

//    CMASSERTMSG(ERROR_SUCCESS == lReturn, TEXT("RegOpenKeyExAU Failed."));
    return lReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RegSetValueExAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RegSetValueEx API.  Note that
//            this wrapper doesn't support writing REG_MULTI_SZ, this code will
//            have to be implemented if we ever need it.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
LONG APIENTRY RegSetValueExAU(IN HKEY hKey, IN LPCWSTR lpValueName, IN DWORD Reserved, 
                              IN DWORD dwType, IN CONST BYTE* lpData, IN DWORD cbData)
{
    LONG lReturn = ERROR_INVALID_PARAMETER;

    if (lpData)
    {
        LPSTR pszAnsiValueName = (lpValueName && lpValueName[0]) ? WzToSzWithAlloc(lpValueName) : NULL;
        LPSTR pszTmpData = NULL;
        DWORD dwTmpCbData;

        if (pszAnsiValueName || !lpValueName || (TEXT('\0') == lpValueName[0]))
        {
            if ((REG_EXPAND_SZ == dwType) || (REG_SZ == dwType))
            {
                pszTmpData = WzToSzWithAlloc((WCHAR*)lpData);

                if (pszTmpData)
                {
                    dwTmpCbData = lstrlenA(pszTmpData) + 1;
                }
                else
                {
                    lReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else if (REG_MULTI_SZ == dwType)
            {
                //  We currently don't have the parsing logic to convert a Multi_SZ.
                //  Since CM doesn't set any keys that use this type, this shouldn't
                //  be a problem.  However, someday we may need to fill in this code.  For
                //  now, just assert.
                //
                CMASSERTMSG(FALSE, TEXT("RegSetValueExAU -- Converion and Parsing code for REG_MULTI_SZ UNIMPLEMENTED."));
                lReturn = ERROR_CALL_NOT_IMPLEMENTED; // closest I could find to E_NOTIMPL           
            }
            else
            {
                //
                //  No text data, leave the buffer alone
                //
                pszTmpData = (LPSTR)lpData;
                dwTmpCbData = cbData;
            }

            if (pszTmpData)
            {
                lReturn = RegSetValueExA(hKey, pszAnsiValueName, Reserved, dwType, 
                                         (LPBYTE)pszTmpData, dwTmpCbData);

                if ((REG_EXPAND_SZ == dwType) || (REG_SZ == dwType))
                {
                    CmFree(pszTmpData);
                }
            }

            CmFree(pszAnsiValueName);
        }
        else
        {
            lReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return lReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  SearchPathAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 SearchPath API.  Note that
//            this wrapper uses wcsrchr to fix up the lpFilePart parameter in 
//            the converted return buffer.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
DWORD WINAPI SearchPathAU(IN LPCWSTR lpPath, IN LPCWSTR lpFileName, IN LPCWSTR lpExtension, 
                          IN DWORD nBufferLength, OUT LPWSTR lpBuffer, OUT LPWSTR *lpFilePart)
{
    DWORD dwReturn = ERROR_INVALID_PARAMETER;

    if (lpFileName && (L'\0' != lpFileName[0]))
    {
        CHAR szAnsiPath[MAX_PATH+1];
        CHAR szAnsiFileName[MAX_PATH+1];
        CHAR szAnsiExt[MAX_PATH+1];
        LPSTR pszAnsiPath;
        LPSTR pszAnsiExt;
        int iChars;
        
        //
        //  Convert the path if it exists
        //
        if (lpPath && (L'\0' != lpPath[0]))
        {
            pszAnsiPath = szAnsiPath;
            MYVERIFY(0 != WzToSz(lpPath, pszAnsiPath, MAX_PATH));
        }
        else
        {
            pszAnsiPath = NULL;
        }

        //
        //  Convert the extension if it exists
        //
        if (lpExtension && (L'\0' != lpExtension[0]))
        {
            pszAnsiExt = szAnsiExt;
            MYVERIFY(0 != WzToSz(lpExtension, pszAnsiExt, MAX_PATH));
        }
        else
        {
            pszAnsiExt = NULL;
        }
        
        //
        //  Convert the file name, which must exist
        //
        iChars = WzToSz(lpFileName, szAnsiFileName, MAX_PATH);

        if (iChars && (MAX_PATH >= iChars))
        {
            LPSTR pszAnsiBuffer = (LPSTR)CmMalloc(nBufferLength);

            if (pszAnsiBuffer)
            {
                dwReturn = SearchPathA(pszAnsiPath, szAnsiFileName, pszAnsiExt, nBufferLength, 
                                       pszAnsiBuffer, NULL);

                if (dwReturn && lpBuffer)
                {
                    //
                    //  We have a successful search.  Now convert the output buffer
                    //
                    iChars = SzToWz(pszAnsiBuffer, lpBuffer, nBufferLength);
                    if (!iChars || (nBufferLength < (DWORD)iChars))
                    {
                        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        //
                        //  Fix up lpFilePart
                        //
                        if (lpFilePart)
                        {
                            //
                            //  Find the last slash
                            //
                            *lpFilePart = wcsrchr(lpBuffer, L'\\');
                            if (*lpFilePart)
                            {
                                //
                                //  Increment
                                //
                                (*lpFilePart)++;
                            }
                        }
                    }
                }
                CmFree(pszAnsiBuffer);
            }
        }
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  SendDlgItemMessageAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 SendDlgItemMessage API.  Note that
//            this wrapper uses GetDlgItem and SendMessage just as the Win32
//            implementation of the API does.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
LONG_PTR WINAPI SendDlgItemMessageAU(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    LONG lReturn = 0;
    HWND hWnd = GetDlgItem(hDlg, nIDDlgItem);

    if (hWnd)
    {
        //
        // Rather than going through SendDlgItemMessageA, we just
        // do what the system does, i.e., go through 
        // SendMessage
        //
        lReturn = SendMessageAU(hWnd, Msg, wParam, lParam);
    }

    return lReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  SendMessageAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 SendMessage API.  This
//            wrapper attempts to handle all of the Windows Messages that
//            need conversion, either before the message is sent or after it
//            returns.  Obviously this is an inexact science.  I have checked
//            and tested all of the message types currently in CM but new ones
//            may be added at some point.  I owe much of this function to 
//            F. Avery Bishop and his sample code.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
LRESULT WINAPI SendMessageAU(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    LPVOID lpTempBuffer = NULL;
    int nLength = 0;
    CHAR cCharA[3] ;
    WCHAR cCharW[3] ;

    //
    // Preprocess messages that pass chars and strings via wParam and lParam
    //
    switch (Msg)
    {
        //
        // Single Unicode Character in wParam. Convert Unicode character
        // to ANSI and pass lParam as is.
        //
        case EM_SETPASSWORDCHAR: // wParam is char, lParam = 0 

        case WM_CHAR:            //*wParam is char, lParam = key data
        case WM_SYSCHAR:         // wParam is char, lParam = key data
            // Note that we don't handle LeadByte and TrailBytes for
            // these two cases. An application should send WM_IME_CHAR
            // in these cases anyway

        case WM_DEADCHAR:        // wParam is char, lParam = key data
        case WM_SYSDEADCHAR:     // wParam is char, lParam = key data
        case WM_IME_CHAR:        //*

            cCharW[0] = (WCHAR) wParam ;
            cCharW[1] = L'\0' ;

            if (!WzToSz(cCharW, cCharA, 3))
            {
                return FALSE;
            }

            if(Msg == WM_IME_CHAR)
            {
                wParam = (cCharA[1] & 0x00FF) | (cCharA[0] << 8);
            }
            else
            {
                wParam = cCharA[0];
            }

            wParam &= 0x0000FFFF;

            break;

        //
        // In the following cases, lParam is pointer to an IN buffer containing
        // text to send to window.
        // Preprocess by converting from Unicode to ANSI
        //
        case CB_ADDSTRING:       // wParam = 0, lParm = lpStr, buffer to add 
        case LB_ADDSTRING:       // wParam = 0, lParm = lpStr, buffer to add
        case CB_DIR:             // wParam = file attributes, lParam = lpszFileSpec buffer
        case LB_DIR:             // wParam = file attributes, lParam = lpszFileSpec buffer
        case CB_FINDSTRING:      // wParam = start index, lParam = lpszFind  
        case LB_FINDSTRING:      // wParam = start index, lParam = lpszFind
        case CB_FINDSTRINGEXACT: // wParam = start index, lParam = lpszFind
        case LB_FINDSTRINGEXACT: // wParam = start index, lParam = lpszFind
        case CB_INSERTSTRING:    //*wParam = index, lParam = lpszString to insert
        case LB_INSERTSTRING:    //*wParam = index, lParam = lpszString to insert
        case CB_SELECTSTRING:    // wParam = start index, lParam = lpszFind
        case LB_SELECTSTRING:    // wParam = start index, lParam = lpszFind
        case WM_SETTEXT:         //*wParam = 0, lParm = lpStr, buffer to set 
        {
            if (NULL != (LPWSTR) lParam)
            {
                nLength = 2*lstrlenAU((LPWSTR)lParam) + 1; // Need double length for DBCS characters

                lpTempBuffer = (LPVOID)CmMalloc(nLength);
            }

            if (!lpTempBuffer || (!WzToSz((LPWSTR)lParam, (LPSTR)lpTempBuffer, nLength)))
            {
                CmFree(lpTempBuffer);
                return FALSE;
            }

            lParam = (LPARAM) lpTempBuffer;

            break ;

        }
    }

    // This is where the actual SendMessage takes place
    lResult = SendMessageA(hWnd, Msg, wParam, lParam) ;

    nLength = 0;

    if(lResult > 0)
    {

        switch (Msg)
        {
            //
            // For these cases, lParam is a pointer to an OUT buffer that received text from
            // SendMessageA in ANSI. Convert to Unicode and send back.
            //
            case WM_GETTEXT:         // wParam = numCharacters, lParam = lpBuff to RECEIVE string
            case WM_ASKCBFORMATNAME: // wParam = nBufferSize, lParam = lpBuff to RECEIVE string 

                nLength = (int) wParam;

                if(!nLength)
                {
                    break;
                }

            case CB_GETLBTEXT:       // wParam = index, lParam = lpBuff to RECEIVE string
            case EM_GETLINE:         // wParam = Line no, lParam = lpBuff to RECEIVE string

                if(!nLength)
                {                    
                    nLength = lstrlenA((LPSTR) lParam) + 1 ;
                }

                lpTempBuffer = (LPVOID) CmMalloc(nLength*sizeof(WCHAR));

                if(!lpTempBuffer || (!SzToWz((LPCSTR) lParam, (LPWSTR) lpTempBuffer, nLength)))
                {
                    *((LPWSTR) lParam) = L'\0';
                    CmFree(lpTempBuffer);
                    return FALSE;
                }

                lstrcpyAU((LPWSTR) lParam, (LPWSTR) lpTempBuffer) ;
        }
    }

    if(lpTempBuffer != NULL)
    {
        CmFree(lpTempBuffer);
    }

    return lResult;
}

//+----------------------------------------------------------------------------
//
// Function:  SetCurrentDirectoryAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 SetCurrentDirectory API.
//            Note that we expect the directory path to fit in MAX_PATH chars.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL SetCurrentDirectoryAU(LPCWSTR pszwPathName)
{
    BOOL bReturn = FALSE;

    if (pszwPathName && (L'\0' != pszwPathName[0]))
    {
        CHAR szAnsiPath[MAX_PATH+1];
    
        int iChars = WzToSz(pszwPathName, szAnsiPath, MAX_PATH);

        if (iChars && (MAX_PATH >= iChars))
        {
            bReturn = SetCurrentDirectoryA(szAnsiPath);
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  SetDlgItemTextAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 SetDlgItemText API.
//            This function calls SendMessageAU with a WM_SETTEXT and the 
//            appropriate Dialog Item from GetDlgItem.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL WINAPI SetDlgItemTextAU(IN HWND hDlg, IN int nIDDlgItem, IN LPCWSTR pszwString)
{
    return (BOOL) (0 < SendMessageAU(GetDlgItem(hDlg, nIDDlgItem), WM_SETTEXT, (WPARAM) 0, (LPARAM) pszwString));
}

//+----------------------------------------------------------------------------
//
// Function:  SetWindowTextAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 SetWindowText API.
//            This function calls SendMessageAU with a WM_SETTEXT.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL WINAPI SetWindowTextAU(HWND hWnd, LPCWSTR pszwString)
{
    return (BOOL) (0 < SendMessageAU(hWnd, WM_SETTEXT, 0, (LPARAM) pszwString));
}

//+----------------------------------------------------------------------------
//
// Function:  UnregisterClassAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 UnregisterClass API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL WINAPI UnregisterClassAU(IN LPCWSTR lpClassName, IN HINSTANCE hInstance)
{
    BOOL bReturn = FALSE;

    if (lpClassName)
    {
        LPSTR pszAnsiClassName = WzToSzWithAlloc(lpClassName);

        if (pszAnsiClassName)
        {
            bReturn = UnregisterClassA(pszAnsiClassName, hInstance);
        }

        CmFree(pszAnsiClassName);    
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  WinHelpAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 WinHelp API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL WINAPI WinHelpAU(IN HWND hWndMain, IN LPCWSTR lpszHelp, IN UINT uCommand, IN ULONG_PTR dwData)
{
    BOOL bReturn = FALSE;

    if (lpszHelp)
    {
        LPSTR pszAnsiHelp = WzToSzWithAlloc(lpszHelp);

        if (pszAnsiHelp)
        {
            bReturn = WinHelpA(hWndMain, pszAnsiHelp, uCommand, dwData);
        }

        CmFree(pszAnsiHelp);    
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  WritePrivateProfileStringAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 WritePrivateProfileString API.
//            Note that we expect lpAppName, lpKeyName, and lpFileName to all
//            fit in MAX_PATH chars.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL WINAPI WritePrivateProfileStringAU(IN LPCWSTR lpAppName, IN LPCWSTR lpKeyName, 
                                        IN LPCWSTR lpString, IN LPCWSTR lpFileName)
{
    BOOL bReturn = FALSE;

    //
    //  Check inputs, but note that either lpKeyName or lpString could be NULL
    //
    if (lpAppName && lpFileName)
    {
        CHAR szAnsiAppName[MAX_PATH+1];        
        CHAR szAnsiFileName[MAX_PATH+1];
        CHAR szAnsiKeyName[MAX_PATH+1];
        LPSTR pszAnsiKeyName = NULL;
        LPSTR pszAnsiString;

        if (WzToSz(lpAppName, szAnsiAppName, MAX_PATH))
        {
            if (WzToSz(lpFileName, szAnsiFileName, MAX_PATH))
            {
                if (lpKeyName)
                {
                    pszAnsiKeyName = szAnsiKeyName;
                    WzToSz(lpKeyName, pszAnsiKeyName, MAX_PATH);
                }
                // else pszAnsiKeyName was already init-ed to NULL

                if (pszAnsiKeyName || !lpKeyName)
                {
                    pszAnsiString = lpString ? WzToSzWithAlloc(lpString) : NULL;

                    if (pszAnsiString || (!lpString))
                    {
                        bReturn = WritePrivateProfileStringA(szAnsiAppName, pszAnsiKeyName, 
                                                             pszAnsiString, szAnsiFileName);

                        CmFree(pszAnsiString);
                    }
                }
            }
        }
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    CMASSERTMSG(bReturn, TEXT("WritePrivateProfileStringAU Failed."));
    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  wsprintfAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 wsprintf API.
//            Note that it uses a va_list and calls wvsprintfAU.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
int WINAPIV wsprintfAU(OUT LPWSTR pszwDest, IN LPCWSTR pszwFmt, ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, pszwFmt);
    ret = wvsprintfAU(pszwDest, pszwFmt, arglist);
    va_end(arglist);
    return ret;
}

//+----------------------------------------------------------------------------
//
// Function:  wvsprintfAU
//
// Synopsis:  Unicode to Ansi wrapper for the win32 wvsprintf API.  In order to
//            avoid parsing the format string to convert the %s to %S and the
//            %c to %C and then calling wvsprintfA, which is originally how this
//            function was written but which isn't really very safe because
//            we don't know the size of the Dest buffer, we will call the
//            C runtime function vswprintf to directly handle a Unicode string.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb  Created                              6/24/99
//            quintinb  Changed algorithm to use 
//                      the C runtime vswprintf              02/05/00
//
//+----------------------------------------------------------------------------
int WINAPI wvsprintfAU(OUT LPWSTR pszwDest, IN LPCWSTR pszwFmt, IN va_list arglist)
{

    int iReturn = 0;

    if (pszwDest && pszwFmt)
    {
        //
        //  Use the C runtime version of the function
        //
        iReturn = vswprintf(pszwDest, pszwFmt, arglist);
    }

    return iReturn;

}

//+----------------------------------------------------------------------------
//
// Function:  InitCmUToA
//
// Synopsis:  This function is called once cmutoa.dll is loaded.  It will init
//            the passed in UAPIINIT struct with the appropriate function pointers.
//
// Arguments: PUAPIINIT pUAInit -- pointer to a UAInit struct which contains memory
//                                 for all the requested function pointers.
//
// Returns:   BOOL -- always returns TRUE
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL InitCmUToA(PUAPIINIT pUAInit) 
{
    //
    //  Note that we don't need any translation here, the prototype is the same for A or W
    //
    *(pUAInit->pCallWindowProcU) = CallWindowProcA;
    *(pUAInit->pDefWindowProcU) = DefWindowProcA;
    *(pUAInit->pDispatchMessageU) = DispatchMessageA;
    *(pUAInit->pGetClassLongU) = GetClassLongA;
    *(pUAInit->pGetMessageU) = GetMessageA;
    *(pUAInit->pGetWindowLongU) = GetWindowLongA;
    *(pUAInit->pGetWindowTextLengthU) = GetWindowTextLengthA;
    *(pUAInit->pIsDialogMessageU) = IsDialogMessageA;
    *(pUAInit->pPeekMessageU) = PeekMessageA;
    *(pUAInit->pPostMessageU) = PostMessageA;
    *(pUAInit->pPostThreadMessageU) = PostThreadMessageA;
    *(pUAInit->pSetWindowLongU) = SetWindowLongA;

    //
    //  Whereas we need wrappers here to do parameter conversion here
    //
    *(pUAInit->pCharLowerU) = CharLowerAU;
    *(pUAInit->pCharNextU) = CharNextAU;
    *(pUAInit->pCharPrevU) = CharPrevAU;
    *(pUAInit->pCharUpperU) = CharUpperAU;
    *(pUAInit->pCreateDialogParamU) = CreateDialogParamAU;
    *(pUAInit->pCreateDirectoryU) = CreateDirectoryAU;
    *(pUAInit->pCreateEventU) = CreateEventAU;
    *(pUAInit->pCreateFileU) = CreateFileAU;
    *(pUAInit->pCreateFileMappingU) = CreateFileMappingAU;
    *(pUAInit->pCreateMutexU) = CreateMutexAU;
    *(pUAInit->pCreateProcessU) = CreateProcessAU;
    *(pUAInit->pCreateWindowExU) = CreateWindowExAU;
    *(pUAInit->pDeleteFileU) = DeleteFileAU;
    *(pUAInit->pDialogBoxParamU) = DialogBoxParamAU;
    *(pUAInit->pExpandEnvironmentStringsU) = ExpandEnvironmentStringsAU;
    *(pUAInit->pFindResourceExU) = FindResourceExAU;
    *(pUAInit->pFindWindowExU) = FindWindowExAU;
    *(pUAInit->pGetDateFormatU) = GetDateFormatAU;
    *(pUAInit->pGetDlgItemTextU) = GetDlgItemTextAU;
    *(pUAInit->pGetFileAttributesU) = GetFileAttributesAU;
    *(pUAInit->pGetModuleFileNameU) = GetModuleFileNameAU;
    *(pUAInit->pGetModuleHandleU) = GetModuleHandleAU;
    *(pUAInit->pGetPrivateProfileIntU) = GetPrivateProfileIntAU;
    *(pUAInit->pGetPrivateProfileStringU) = GetPrivateProfileStringAU;
    *(pUAInit->pGetStringTypeExU) = GetStringTypeExAU;
    *(pUAInit->pGetSystemDirectoryU) = GetSystemDirectoryAU;
    *(pUAInit->pGetTempFileNameU) = GetTempFileNameAU;
    *(pUAInit->pGetTempPathU) = GetTempPathAU;
    *(pUAInit->pGetTimeFormatU) = GetTimeFormatAU;
    *(pUAInit->pGetUserNameU) = GetUserNameAU;
    *(pUAInit->pGetVersionExU) = GetVersionExAU;
    *(pUAInit->pGetWindowTextU) = GetWindowTextAU;
    *(pUAInit->pInsertMenuU) = InsertMenuAU;
    *(pUAInit->pLoadCursorU) = LoadCursorAU;
    *(pUAInit->pLoadIconU) = LoadIconAU;
    *(pUAInit->pLoadImageU) = LoadImageAU;
    *(pUAInit->pLoadLibraryExU) = LoadLibraryExAU;
    *(pUAInit->pLoadMenuU) = LoadMenuAU;
    *(pUAInit->pLoadStringU) = LoadStringAU;
    *(pUAInit->plstrcatU) = lstrcatAU;
    *(pUAInit->plstrcmpU) = lstrcmpAU;
    *(pUAInit->plstrcmpiU) = lstrcmpiAU;
    *(pUAInit->plstrcpyU) = lstrcpyAU;
    *(pUAInit->plstrcpynU) = lstrcpynAU;
    *(pUAInit->plstrlenU) = lstrlenAU;
    *(pUAInit->pOpenEventU) = OpenEventAU;
    *(pUAInit->pOpenFileMappingU) = OpenFileMappingAU;
    *(pUAInit->pRegCreateKeyExU) = RegCreateKeyExAU;
    *(pUAInit->pRegDeleteKeyU) = RegDeleteKeyAU;
    *(pUAInit->pRegDeleteValueU) = RegDeleteValueAU;
    *(pUAInit->pRegEnumKeyExU) = RegEnumKeyExAU;
    *(pUAInit->pRegisterClassExU) = RegisterClassExAU;
    *(pUAInit->pRegisterWindowMessageU) = RegisterWindowMessageAU;
    *(pUAInit->pRegOpenKeyExU) = RegOpenKeyExAU;
    *(pUAInit->pRegQueryValueExU) = RegQueryValueExAU;
    *(pUAInit->pRegSetValueExU) = RegSetValueExAU;
    *(pUAInit->pSearchPathU) = SearchPathAU;
    *(pUAInit->pSendDlgItemMessageU) = SendDlgItemMessageAU;
    *(pUAInit->pSendMessageU) = SendMessageAU;
    *(pUAInit->pSetCurrentDirectoryU) = SetCurrentDirectoryAU;
    *(pUAInit->pSetDlgItemTextU) = SetDlgItemTextAU;
    *(pUAInit->pSetWindowTextU) = SetWindowTextAU;
    *(pUAInit->pUnregisterClassU) = UnregisterClassAU;
    *(pUAInit->pWinHelpU) = WinHelpAU;
    *(pUAInit->pWritePrivateProfileStringU) = WritePrivateProfileStringAU;
    *(pUAInit->pwsprintfU) = wsprintfAU;
    *(pUAInit->pwvsprintfU) = wvsprintfAU;

    //
    //  Currently this always returns TRUE because none of the above can really
    //  fail.  However, in the future we may need more of a meaningful return
    //  value here.
    //
    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  RasDeleteEntryUA
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RasDeleteEntry API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
DWORD APIENTRY RasDeleteEntryUA(LPCWSTR pszwPhoneBook, LPCWSTR pszwEntry)
{
    DWORD dwReturn = ERROR_INVALID_PARAMETER;

    //
    //  The phonebook should always be NULL on win9x
    //
    MYDBGASSERT(NULL == pszwPhoneBook);

    RasLinkageStructA* pAnsiRasLinkage = (RasLinkageStructA*)TlsGetValue(g_dwTlsIndex);
    MYDBGASSERT(NULL != pAnsiRasLinkage);
    MYDBGASSERT(NULL != pAnsiRasLinkage->pfnDeleteEntry);

    if (pszwEntry && pAnsiRasLinkage && pAnsiRasLinkage->pfnDeleteEntry)
    {
        CHAR szAnsiEntry [RAS_MaxEntryName + 1];
        int iChars = WzToSz(pszwEntry, szAnsiEntry, RAS_MaxEntryName);

        if (iChars && (RAS_MaxEntryName >= iChars))
        {
            dwReturn = pAnsiRasLinkage->pfnDeleteEntry(NULL, szAnsiEntry);
        }    
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RasGetEntryPropertiesUA
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RasGetEntryProperties API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
DWORD APIENTRY RasGetEntryPropertiesUA(LPCWSTR pszwPhoneBook, LPCWSTR pszwEntry, 
                                       LPRASENTRYW pRasEntryW, LPDWORD pdwEntryInfoSize, 
                                       LPBYTE pbDeviceInfo, LPDWORD pdwDeviceInfoSize)
{
    DWORD dwReturn = ERROR_INVALID_PARAMETER;

    //
    //  The phonebook should always be NULL on win9x
    //
    MYDBGASSERT(NULL == pszwPhoneBook);
    MYDBGASSERT(NULL == pbDeviceInfo); // We don't use or handle this TAPI param.  If we need it,
                                       // conversion must be implemented.

    RasLinkageStructA* pAnsiRasLinkage = (RasLinkageStructA*)TlsGetValue(g_dwTlsIndex);
    MYDBGASSERT(NULL != pAnsiRasLinkage);
    MYDBGASSERT(NULL != pAnsiRasLinkage->pfnGetEntryProperties);

    if (pszwEntry && pdwEntryInfoSize && pAnsiRasLinkage && pAnsiRasLinkage->pfnGetEntryProperties)
    {

        CHAR szAnsiEntry [RAS_MaxEntryName + 1];
        RASENTRYA RasEntryA;
        DWORD dwTmpEntrySize = sizeof(RASENTRYA);

        ZeroMemory(&RasEntryA, sizeof(RASENTRYA));

        int iChars = WzToSz(pszwEntry, szAnsiEntry, RAS_MaxEntryName);

        if (iChars && (RAS_MaxEntryName >= iChars))
        {
            dwReturn = pAnsiRasLinkage->pfnGetEntryProperties(NULL, szAnsiEntry, &RasEntryA, 
                                                              &dwTmpEntrySize, NULL, NULL);

            if ((ERROR_SUCCESS == dwReturn) && pRasEntryW)
            {
                //
                //  Do conversion of RASENTRYA to RASENTRYW
                //

                // pRasEntryW->dwSize -- this param should already be set
                pRasEntryW->dwfOptions = RasEntryA.dwfOptions;

                //
                // Location/phone number.
                //
                pRasEntryW->dwCountryID = RasEntryA.dwCountryID;
                pRasEntryW->dwCountryCode = RasEntryA.dwCountryCode;                
                MYVERIFY(0 != SzToWz(RasEntryA.szAreaCode, pRasEntryW->szAreaCode, RAS_MaxAreaCode));
                MYVERIFY(0 != SzToWz(RasEntryA.szLocalPhoneNumber, pRasEntryW->szLocalPhoneNumber, RAS_MaxPhoneNumber));
                pRasEntryW->dwAlternateOffset = RasEntryA.dwAlternateOffset;
                //
                // PPP/Ip
                //
                memcpy(&(pRasEntryW->ipaddr), &(RasEntryA.ipaddr), sizeof(RASIPADDR));
                memcpy(&(pRasEntryW->ipaddrDns), &(RasEntryA.ipaddrDns), sizeof(RASIPADDR));
                memcpy(&(pRasEntryW->ipaddrDnsAlt), &(RasEntryA.ipaddrDnsAlt), sizeof(RASIPADDR));
                memcpy(&(pRasEntryW->ipaddrWins), &(RasEntryA.ipaddrWins), sizeof(RASIPADDR));
                memcpy(&(pRasEntryW->ipaddrWinsAlt), &(RasEntryA.ipaddrWinsAlt), sizeof(RASIPADDR));
                //
                // Framing
                //
                pRasEntryW->dwFrameSize = RasEntryA.dwFrameSize;
                pRasEntryW->dwfNetProtocols = RasEntryA.dwfNetProtocols;
                pRasEntryW->dwFramingProtocol = RasEntryA.dwFramingProtocol;
                //
                // Scripting
                //
                MYVERIFY(0 != SzToWz(RasEntryA.szScript, pRasEntryW->szScript, MAX_PATH));
                //
                // AutoDial
                //
                MYVERIFY(0 != SzToWz(RasEntryA.szAutodialDll, pRasEntryW->szAutodialDll, MAX_PATH));
                MYVERIFY(0 != SzToWz(RasEntryA.szAutodialFunc, pRasEntryW->szAutodialFunc, MAX_PATH));
                //
                // Device
                //
                MYVERIFY(0 != SzToWz(RasEntryA.szDeviceType, pRasEntryW->szDeviceType, RAS_MaxDeviceType));
                MYVERIFY(0 != SzToWz(RasEntryA.szDeviceName, pRasEntryW->szDeviceName, RAS_MaxDeviceName));
                //
                // X.25 -- we don't use x25
                //
                pRasEntryW->szX25PadType[0] = L'\0';
                pRasEntryW->szX25Address[0] = L'\0';
                pRasEntryW->szX25Facilities[0] = L'\0';
                pRasEntryW->szX25UserData[0] = L'\0';
                pRasEntryW->dwChannels = 0;
                //
                // Reserved
                //
                pRasEntryW->dwReserved1 = RasEntryA.dwReserved1;
                pRasEntryW->dwReserved2 = RasEntryA.dwReserved2;
            }
            else if ((ERROR_BUFFER_TOO_SMALL == dwReturn) || !pRasEntryW)
            {
                //
                //  We don't know the actual size since we are passing a RASENTRYA, but
                //  the user only knows about RASENTRYW.  Thus double the returned size.
                //
                *pdwEntryInfoSize = 2*dwTmpEntrySize;
            }
        }    
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RasSetEntryPropertiesUA
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RasSetEntryProperties API.
//            Note that we do not support the pbDeviceInfo
//            parameter, if you need it you will have to implement it.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
DWORD APIENTRY RasSetEntryPropertiesUA(LPCWSTR pszwPhoneBook, LPCWSTR pszwEntry, LPRASENTRYW pRasEntryW,
                                       DWORD dwEntryInfoSize, LPBYTE pbDeviceInfo, DWORD dwDeviceInfoSize)
{
    DWORD dwReturn = ERROR_INVALID_PARAMETER;

    //
    // We don't use or handle this TAPI param.  If we need it, conversion must be implemented.
    // Note that 1 is a special value for Windows Millennium (see Millennium bug 127371)
    //
    MYDBGASSERT((NULL == pbDeviceInfo) || ((LPBYTE)1 == pbDeviceInfo)); 

    RasLinkageStructA* pAnsiRasLinkage = (RasLinkageStructA*)TlsGetValue(g_dwTlsIndex);

    MYDBGASSERT(NULL != pAnsiRasLinkage);
    MYDBGASSERT(NULL != pAnsiRasLinkage->pfnSetEntryProperties);

    if (pszwEntry && dwEntryInfoSize && pRasEntryW && pAnsiRasLinkage && pAnsiRasLinkage->pfnSetEntryProperties)
    {
        //
        //  The phonebook should always be NULL on Win9x.
        //
        MYDBGASSERT(NULL == pszwPhoneBook);

        CHAR szAnsiEntry [RAS_MaxEntryName + 1];

        int iChars = WzToSz(pszwEntry, szAnsiEntry, RAS_MaxEntryName);

        if (iChars && (RAS_MaxEntryName >= iChars))
        {
            //
            //  Figure out the correct size to use
            //
            MYDBGASSERT((sizeof(RASENTRYW) == pRasEntryW->dwSize) ||(sizeof(RASENTRYW_V401) == pRasEntryW->dwSize));
            DWORD dwSize;

            if ((sizeof (RASENTRYW_V401) == pRasEntryW->dwSize) && OS_MIL)
            {
                //
                //  Millennium uses the NT4 structure size
                //
                dwSize = sizeof(RASENTRYA_V401);
            }
            else
            {
                dwSize = sizeof(RASENTRYA);        
            }

            //
            //  Allocate the RasEntryStructure
            //
            LPRASENTRYA pAnsiRasEntry = (LPRASENTRYA)CmMalloc(dwSize);

            if (pAnsiRasEntry)
            {
                //
                //  Do conversion of RASENTRYA to RASENTRYW
                //

                pAnsiRasEntry->dwSize = dwSize;
                pAnsiRasEntry->dwfOptions = pRasEntryW->dwfOptions;

                //
                // Location/phone number.
                //
                pAnsiRasEntry->dwCountryID = pRasEntryW->dwCountryID;
                pAnsiRasEntry->dwCountryCode = pRasEntryW->dwCountryCode;                
                MYVERIFY(0 != WzToSz(pRasEntryW->szAreaCode, pAnsiRasEntry->szAreaCode, RAS_MaxAreaCode));
                MYVERIFY(0 != WzToSz(pRasEntryW->szLocalPhoneNumber, pAnsiRasEntry->szLocalPhoneNumber, RAS_MaxPhoneNumber));
            
                CMASSERTMSG(0 == pRasEntryW->dwAlternateOffset, TEXT("RasSetEntryPropertiesUA -- dwAlternateOffset != 0 is not supported.  This will need to be implemented if used."));
                pAnsiRasEntry->dwAlternateOffset = 0;
            
                //
                // PPP/Ip
                //
                memcpy(&(pAnsiRasEntry->ipaddr), &(pRasEntryW->ipaddr), sizeof(RASIPADDR));
                memcpy(&(pAnsiRasEntry->ipaddrDns), &(pRasEntryW->ipaddrDns), sizeof(RASIPADDR));
                memcpy(&(pAnsiRasEntry->ipaddrDnsAlt), &(pRasEntryW->ipaddrDnsAlt), sizeof(RASIPADDR));
                memcpy(&(pAnsiRasEntry->ipaddrWins), &(pRasEntryW->ipaddrWins), sizeof(RASIPADDR));
                memcpy(&(pAnsiRasEntry->ipaddrWinsAlt), &(pRasEntryW->ipaddrWinsAlt), sizeof(RASIPADDR));
                //
                // Framing
                //
                pAnsiRasEntry->dwFrameSize = pRasEntryW->dwFrameSize;
                pAnsiRasEntry->dwfNetProtocols = pRasEntryW->dwfNetProtocols;
                pAnsiRasEntry->dwFramingProtocol = pRasEntryW->dwFramingProtocol;
                //
                // Scripting
                //
                MYVERIFY(0 != WzToSz(pRasEntryW->szScript, pAnsiRasEntry->szScript, MAX_PATH));
                //
                // AutoDial
                //
                MYVERIFY(0 != WzToSz(pRasEntryW->szAutodialDll, pAnsiRasEntry->szAutodialDll, MAX_PATH));
                MYVERIFY(0 != WzToSz(pRasEntryW->szAutodialFunc, pAnsiRasEntry->szAutodialFunc, MAX_PATH));
                //
                // Device
                //
                MYVERIFY(0 != WzToSz(pRasEntryW->szDeviceType, pAnsiRasEntry->szDeviceType, RAS_MaxDeviceType));
                MYVERIFY(0 != WzToSz(pRasEntryW->szDeviceName, pAnsiRasEntry->szDeviceName, RAS_MaxDeviceName));
                //
                // X.25 -- we don't use x25
                //
                pAnsiRasEntry->szX25PadType[0] = '\0';
                pAnsiRasEntry->szX25Address[0] = '\0';
                pAnsiRasEntry->szX25Facilities[0] = '\0';
                pAnsiRasEntry->szX25UserData[0] = '\0';
                pAnsiRasEntry->dwChannels = 0;
                //
                // Reserved
                //
                pAnsiRasEntry->dwReserved1 = pRasEntryW->dwReserved1;
                pAnsiRasEntry->dwReserved2 = pRasEntryW->dwReserved2;

                if (sizeof(RASENTRYA_V401) == dwSize)
                {
                    //
                    //  Copy over the 4.01 data
                    //
                    LPRASENTRYA_V401 pAnsi401RasEntry = (LPRASENTRYA_V401)pAnsiRasEntry;
                    LPRASENTRYW_V401 pWide401RasEntry = (LPRASENTRYW_V401)pRasEntryW;

                    pAnsi401RasEntry->dwSubEntries = pWide401RasEntry->dwSubEntries;
                    pAnsi401RasEntry->dwDialMode = pWide401RasEntry->dwDialMode;
                    pAnsi401RasEntry->dwDialExtraPercent = pWide401RasEntry->dwDialExtraPercent;
                    pAnsi401RasEntry->dwDialExtraSampleSeconds = pWide401RasEntry->dwDialExtraSampleSeconds;
                    pAnsi401RasEntry->dwHangUpExtraPercent = pWide401RasEntry->dwHangUpExtraPercent;
                    pAnsi401RasEntry->dwHangUpExtraSampleSeconds = pWide401RasEntry->dwHangUpExtraSampleSeconds;
                    pAnsi401RasEntry->dwIdleDisconnectSeconds = pWide401RasEntry->dwIdleDisconnectSeconds;
                }

                dwReturn = pAnsiRasLinkage->pfnSetEntryProperties(NULL, szAnsiEntry, pAnsiRasEntry, 
                                                                  pAnsiRasEntry->dwSize, pbDeviceInfo, 0);

                CmFree(pAnsiRasEntry);
            }
        }    
    }

    return dwReturn;
}



//+----------------------------------------------------------------------------
//
// Function:  RasDialParamsWtoRasDialParamsA
//
// Synopsis:  Wrapper function to handle converting a RasDialParamsW struct to 
//            a RasDialParamsA Struct.  Used by RasSetEntryDialParamsUA and
//            RasDialUA.
//
// Arguments: LPRASDIALPARAMSW pRdpW - pointer to a RasDialParamsW
//            LPRASDIALPARAMSA pRdpA - pointer to a RasDialParamsA
//
// Returns:   Nothing 
//
// History:   quintinb Created     7/15/99
//
//+----------------------------------------------------------------------------
void RasDialParamsWtoRasDialParamsA (LPRASDIALPARAMSW pRdpW, LPRASDIALPARAMSA pRdpA)
{
    pRdpA->dwSize = sizeof(RASDIALPARAMSA);
    MYVERIFY(0 != WzToSz(pRdpW->szEntryName, pRdpA->szEntryName, RAS_MaxEntryName));
    MYVERIFY(0 != WzToSz(pRdpW->szPhoneNumber, pRdpA->szPhoneNumber, RAS_MaxPhoneNumber));
    MYVERIFY(0 != WzToSz(pRdpW->szCallbackNumber, pRdpA->szCallbackNumber, RAS_MaxCallbackNumber));
    MYVERIFY(0 != WzToSz(pRdpW->szUserName, pRdpA->szUserName, UNLEN));
    MYVERIFY(0 != WzToSz(pRdpW->szPassword, pRdpA->szPassword, PWLEN));
    MYVERIFY(0 != WzToSz(pRdpW->szDomain, pRdpA->szDomain, DNLEN));
}

//+----------------------------------------------------------------------------
//
// Function:  RasDialParamsAtoRasDialParamsW
//
// Synopsis:  Wrapper function to handle converting a RasDialParamsA struct to 
//            a RasDialParamsW Struct.  Used by RasGetEntryDialParamsUA.
//
// Arguments: LPRASDIALPARAMSW pRdpA - pointer to a RasDialParamsA
//            LPRASDIALPARAMSA pRdpW - pointer to a RasDialParamsW
//
// Returns:   Nothing 
//
// History:   quintinb Created     7/15/99
//
//+----------------------------------------------------------------------------
void RasDialParamsAtoRasDialParamsW (LPRASDIALPARAMSA pRdpA, LPRASDIALPARAMSW pRdpW)
{
    pRdpW->dwSize = sizeof(RASDIALPARAMSW);
    MYVERIFY(0 != SzToWz(pRdpA->szEntryName, pRdpW->szEntryName, RAS_MaxEntryName));
    MYVERIFY(0 != SzToWz(pRdpA->szPhoneNumber, pRdpW->szPhoneNumber, RAS_MaxPhoneNumber));
    MYVERIFY(0 != SzToWz(pRdpA->szCallbackNumber, pRdpW->szCallbackNumber, RAS_MaxCallbackNumber));
    MYVERIFY(0 != SzToWz(pRdpA->szUserName, pRdpW->szUserName, UNLEN));
    MYVERIFY(0 != SzToWz(pRdpA->szPassword, pRdpW->szPassword, PWLEN));
    MYVERIFY(0 != SzToWz(pRdpA->szDomain, pRdpW->szDomain, DNLEN));
}

//+----------------------------------------------------------------------------
//
// Function:  RasGetEntryDialParamsUA
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RasGetEntryDialParams API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
DWORD APIENTRY RasGetEntryDialParamsUA(LPCWSTR pszwPhoneBook, LPRASDIALPARAMSW pRasDialParamsW, LPBOOL pbPassword)
{
    DWORD dwReturn = ERROR_BUFFER_INVALID;

    RasLinkageStructA* pAnsiRasLinkage = (RasLinkageStructA*)TlsGetValue(g_dwTlsIndex);

    MYDBGASSERT(NULL != pAnsiRasLinkage);
    MYDBGASSERT(NULL != pAnsiRasLinkage->pfnGetEntryDialParams);

    if (pRasDialParamsW && pbPassword && pAnsiRasLinkage && pAnsiRasLinkage->pfnGetEntryDialParams)
    {
        //
        //  The phonebook should always be NULL on win9x
        //
        MYDBGASSERT(NULL == pszwPhoneBook);

        RASDIALPARAMSA RasDialParamsA;
        ZeroMemory(&RasDialParamsA, sizeof(RASDIALPARAMSA));
        RasDialParamsA.dwSize = sizeof(RASDIALPARAMSA);
        int iChars = WzToSz(pRasDialParamsW->szEntryName, RasDialParamsA.szEntryName, RAS_MaxEntryName);

        if (iChars && (RAS_MaxEntryName >= iChars))
        {
            dwReturn = pAnsiRasLinkage->pfnGetEntryDialParams(NULL, &RasDialParamsA, pbPassword);

            if (ERROR_SUCCESS == dwReturn)
            {
                RasDialParamsAtoRasDialParamsW(&RasDialParamsA, pRasDialParamsW);
            }
        }
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RasSetEntryDialParamsUA
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RasSetEntryDialParams API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
DWORD APIENTRY RasSetEntryDialParamsUA(LPCWSTR pszwPhoneBook, LPRASDIALPARAMSW pRasDialParamsW, 
                                       BOOL bRemovePassword)
{
    DWORD dwReturn = ERROR_BUFFER_INVALID;

    RasLinkageStructA* pAnsiRasLinkage = (RasLinkageStructA*)TlsGetValue(g_dwTlsIndex);

    MYDBGASSERT(NULL != pAnsiRasLinkage);
    MYDBGASSERT(NULL != pAnsiRasLinkage->pfnSetEntryDialParams);

    if (pRasDialParamsW && pAnsiRasLinkage && pAnsiRasLinkage->pfnSetEntryDialParams)
    {
        //
        //  The phonebook should always be NULL on win9x
        //
        MYDBGASSERT(NULL == pszwPhoneBook);

        RASDIALPARAMSA RasDialParamsA;

        RasDialParamsWtoRasDialParamsA (pRasDialParamsW, &RasDialParamsA);

        dwReturn = pAnsiRasLinkage->pfnSetEntryDialParams(NULL, &RasDialParamsA, bRemovePassword);
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RasEnumDevicesUA
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RasEnumDevices API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
DWORD RasEnumDevicesUA(LPRASDEVINFOW pRasDevInfo, LPDWORD pdwCb, LPDWORD pdwDevices)
{
    DWORD dwReturn = ERROR_INVALID_PARAMETER;
    DWORD dwSize;

    RasLinkageStructA* pAnsiRasLinkage = (RasLinkageStructA*)TlsGetValue(g_dwTlsIndex);

    MYDBGASSERT(NULL != pAnsiRasLinkage);
    MYDBGASSERT(NULL != pAnsiRasLinkage->pfnEnumDevices);

    if (pdwCb && pdwDevices && pAnsiRasLinkage && pAnsiRasLinkage->pfnEnumDevices)
    {
        LPRASDEVINFOA pAnsiDevInfo;

        if ((NULL == pRasDevInfo) && (0 == *pdwCb))
        {
            //
            //  Then the caller is just trying to size the buffer
            //
            dwSize = 0;
            pAnsiDevInfo = NULL;        
        }
        else
        {
            dwSize = ((*pdwCb)/sizeof(RASDEVINFOW))*sizeof(RASDEVINFOA); 
            pAnsiDevInfo = (LPRASDEVINFOA)CmMalloc(dwSize);

            if (NULL == pAnsiDevInfo)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            pAnsiDevInfo[0].dwSize = sizeof(RASDEVINFOA);
        }

        dwReturn = pAnsiRasLinkage->pfnEnumDevices(pAnsiDevInfo, &dwSize, pdwDevices);
        
        //
        //  Resize the buffer in terms of RASDEVINFOW structs
        //
        *pdwCb = ((dwSize)/sizeof(RASDEVINFOA))*sizeof(RASDEVINFOW);

        if (ERROR_SUCCESS == dwReturn && pRasDevInfo)
        {
            //
            //  Then we need to convert the returned structs
            //

            MYDBGASSERT((*pdwDevices)*sizeof(RASDEVINFOW) <= *pdwCb);

            for (DWORD dwIndex = 0; dwIndex < *pdwDevices; dwIndex++)
            {
                MYVERIFY(0 != SzToWz(pAnsiDevInfo[dwIndex].szDeviceType, 
                                     pRasDevInfo[dwIndex].szDeviceType, RAS_MaxDeviceType));

                MYVERIFY(0 != SzToWz(pAnsiDevInfo[dwIndex].szDeviceName, 
                                     pRasDevInfo[dwIndex].szDeviceName, RAS_MaxDeviceName));
            }
        }

        //
        //  Free the Ansi buffer
        //
        CmFree (pAnsiDevInfo);
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RasDialUA
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RasDial API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
DWORD APIENTRY RasDialUA(LPRASDIALEXTENSIONS pRasDialExt, LPCWSTR pszwPhoneBook, 
                         LPRASDIALPARAMSW pRasDialParamsW, DWORD dwNotifierType, LPVOID pvNotifier, 
                         LPHRASCONN phRasConn)
{
    DWORD dwReturn = ERROR_INVALID_PARAMETER;
    MYDBGASSERT(NULL == pszwPhoneBook);

    RasLinkageStructA* pAnsiRasLinkage = (RasLinkageStructA*)TlsGetValue(g_dwTlsIndex);

    MYDBGASSERT(NULL != pAnsiRasLinkage);
    MYDBGASSERT(NULL != pAnsiRasLinkage->pfnDial);

    if (pRasDialParamsW && phRasConn && pAnsiRasLinkage && pAnsiRasLinkage->pfnDial)
    {        
        RASDIALPARAMSA RasDialParamsA;

        RasDialParamsWtoRasDialParamsA (pRasDialParamsW, &RasDialParamsA);

        dwReturn = pAnsiRasLinkage->pfnDial(pRasDialExt, NULL, &RasDialParamsA, dwNotifierType, 
                                            pvNotifier, phRasConn);        
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RasHangUpUA
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RasHangUp API.  Which for
//            some reason has an ANSI and Unicode form, not sure why.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
DWORD APIENTRY RasHangUpUA(HRASCONN hRasConn)
{
    DWORD dwReturn = ERROR_INVALID_PARAMETER;
    RasLinkageStructA* pAnsiRasLinkage = (RasLinkageStructA*)TlsGetValue(g_dwTlsIndex);

    MYDBGASSERT(NULL != pAnsiRasLinkage);
    MYDBGASSERT(NULL != pAnsiRasLinkage->pfnHangUp);

    if (hRasConn && pAnsiRasLinkage && pAnsiRasLinkage->pfnHangUp)
    {        
        dwReturn = pAnsiRasLinkage->pfnHangUp(hRasConn);
    }

    return dwReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  RasGetErrorStringUA
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RasGetErrorString API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
DWORD APIENTRY RasGetErrorStringUA(UINT uErrorValue, LPWSTR pszwOutBuf, DWORD dwBufSize)
{
    DWORD dwReturn = ERROR_INVALID_PARAMETER;

    RasLinkageStructA* pAnsiRasLinkage = (RasLinkageStructA*)TlsGetValue(g_dwTlsIndex);

    MYDBGASSERT(NULL != pAnsiRasLinkage);
    MYDBGASSERT(NULL != pAnsiRasLinkage->pfnGetErrorString);

    if (pszwOutBuf && dwBufSize && pAnsiRasLinkage && pAnsiRasLinkage->pfnGetErrorString)
    {        
        LPSTR pszAnsiBuf = (LPSTR)CmMalloc(dwBufSize);

        if (pszAnsiBuf)
        {
            dwReturn = pAnsiRasLinkage->pfnGetErrorString(uErrorValue, pszAnsiBuf, dwBufSize);

            if (ERROR_SUCCESS == dwReturn)
            {
                int iChars = SzToWz(pszAnsiBuf, pszwOutBuf, dwBufSize);
                if (!iChars || (dwBufSize < (DWORD)iChars))
                {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }

        CmFree(pszAnsiBuf);
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RasGetConnectStatusUA
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RasGetConnectStatus API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
DWORD RasGetConnectStatusUA(HRASCONN hRasConn, LPRASCONNSTATUSW pRasConnStatusW)
{
    DWORD dwReturn = ERROR_INVALID_PARAMETER;

    RasLinkageStructA* pAnsiRasLinkage = (RasLinkageStructA*)TlsGetValue(g_dwTlsIndex);

    MYDBGASSERT(NULL != pAnsiRasLinkage);
    MYDBGASSERT(NULL != pAnsiRasLinkage->pfnGetConnectStatus);

    if (pRasConnStatusW && pAnsiRasLinkage && pAnsiRasLinkage->pfnGetConnectStatus)
    {        
        RASCONNSTATUSA RasConnStatusA;
        ZeroMemory(&RasConnStatusA, sizeof(RASCONNSTATUSA));
        RasConnStatusA.dwSize = sizeof(RASCONNSTATUSA);

        dwReturn = pAnsiRasLinkage->pfnGetConnectStatus(hRasConn, &RasConnStatusA);

        if (ERROR_SUCCESS == dwReturn)
        {
            pRasConnStatusW->rasconnstate = RasConnStatusA.rasconnstate;
            pRasConnStatusW->dwError = RasConnStatusA.dwError;
            int iChars = SzToWz(RasConnStatusA.szDeviceType, pRasConnStatusW->szDeviceType, 
                RAS_MaxDeviceType);

            if (!iChars || (RAS_MaxDeviceType < iChars))
            {
                dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                iChars = SzToWz(RasConnStatusA.szDeviceName, pRasConnStatusW->szDeviceName, 
                    RAS_MaxDeviceName);

                if (!iChars || (RAS_MaxDeviceName < iChars))
                {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }

    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RasSetSubEntryPropertiesUA
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RasSetSubEntryProperties API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   SumitC    Created    10/26/99
//
//-----------------------------------------------------------------------------
DWORD APIENTRY
RasSetSubEntryPropertiesUA(LPCWSTR pszwPhoneBook, LPCWSTR pszwSubEntry,
                           DWORD dwSubEntry, LPRASSUBENTRYW pRasSubEntryW,
                           DWORD dwSubEntryInfoSize, LPBYTE pbDeviceConfig,
                           DWORD dwcbDeviceConfig)
{
    DWORD dwReturn = ERROR_INVALID_PARAMETER;

    MYDBGASSERT(NULL == pbDeviceConfig);    // must currently be NULL
    MYDBGASSERT(0 == dwcbDeviceConfig);     // must currently be 0

    RasLinkageStructA* pAnsiRasLinkage = (RasLinkageStructA*)TlsGetValue(g_dwTlsIndex);

    MYDBGASSERT(NULL != pAnsiRasLinkage);
    MYDBGASSERT(NULL != pAnsiRasLinkage->pfnSetEntryProperties);

    if (pszwSubEntry && dwSubEntryInfoSize && pRasSubEntryW && pAnsiRasLinkage && pAnsiRasLinkage->pfnSetSubEntryProperties)
    {
        //
        //  The phonebook should always be NULL on win9x
        //
        MYDBGASSERT(NULL == pszwPhoneBook);

        CHAR szAnsiSubEntry [RAS_MaxEntryName + 1];
        RASSUBENTRYA AnsiRasSubEntry;        

        ZeroMemory(&AnsiRasSubEntry, sizeof(RASSUBENTRYA));
        DWORD dwTmpEntrySize = sizeof(RASSUBENTRYA);


        int iChars = WzToSz(pszwSubEntry, szAnsiSubEntry, RAS_MaxEntryName);

        if (iChars && (RAS_MaxEntryName >= iChars))
        {
            //
            //  Do conversion of RASSUBENTRYW to RASSUBENTRYA
            //

            AnsiRasSubEntry.dwSize = sizeof(RASSUBENTRYA);
            AnsiRasSubEntry.dwfFlags = pRasSubEntryW->dwfFlags;
            
            //
            // Device
            //
            MYVERIFY(0 != WzToSz(pRasSubEntryW->szDeviceType, AnsiRasSubEntry.szDeviceType, RAS_MaxDeviceType));
            MYVERIFY(0 != WzToSz(pRasSubEntryW->szDeviceName, AnsiRasSubEntry.szDeviceName, RAS_MaxDeviceName));
            //
            // Location/phone number.
            //
            MYVERIFY(0 != WzToSz(pRasSubEntryW->szLocalPhoneNumber, AnsiRasSubEntry.szLocalPhoneNumber, RAS_MaxPhoneNumber));
            
            CMASSERTMSG(0 == pRasSubEntryW->dwAlternateOffset, TEXT("RasSetSubEntryPropertiesUA -- dwAlternateOffset != 0 is not supported.  This will need to be implemented if used."));
            AnsiRasSubEntry.dwAlternateOffset = 0;

            dwReturn = pAnsiRasLinkage->pfnSetSubEntryProperties(NULL, szAnsiSubEntry, dwSubEntry,
                                                                 &AnsiRasSubEntry, dwTmpEntrySize, NULL, 0);
        }    
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RasDeleteSubEntryUA
//
// Synopsis:  Unicode to Ansi wrapper for the win32 RasDeleteSubEntryUA API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   SumitC    Created    12/14/99
//
//-----------------------------------------------------------------------------
DWORD APIENTRY
RasDeleteSubEntryUA(LPCWSTR pszwPhoneBook, LPCWSTR pszwEntry, DWORD dwSubEntryId)
{
    DWORD dwReturn = ERROR_INVALID_PARAMETER;

    //
    //  The phonebook should always be NULL on win9x
    //
    MYDBGASSERT(NULL == pszwPhoneBook);

    RasLinkageStructA* pAnsiRasLinkage = (RasLinkageStructA*)TlsGetValue(g_dwTlsIndex);
    MYDBGASSERT(NULL != pAnsiRasLinkage);
    MYDBGASSERT(NULL != pAnsiRasLinkage->pfnDeleteSubEntry);

    if (pszwEntry && pAnsiRasLinkage && pAnsiRasLinkage->pfnDeleteSubEntry)
    {
        CHAR szAnsiEntry [RAS_MaxEntryName + 1];
        int iChars = WzToSz(pszwEntry, szAnsiEntry, RAS_MaxEntryName);

        if (iChars && (RAS_MaxEntryName >= iChars))
        {
            dwReturn = pAnsiRasLinkage->pfnDeleteSubEntry(NULL, szAnsiEntry, dwSubEntryId);
        }    
    }

    return dwReturn;

}

//+----------------------------------------------------------------------------
//
// Function:  FreeCmRasUtoA
//
// Synopsis:  Unloads the RAS dlls (rasapi32.dll and rnaph.dll) and cleans up
//            the RAS linkage structure.  To get more details about the cmutoa
//            RAS linkage see InitCmRasUtoA and cmdial\ras.cpp\LinkToRas.
//
// Arguments: Nothing
//
// Returns:   Nothing
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
void FreeCmRasUtoA()
{
    RasLinkageStructA* pAnsiRasLinkage = (RasLinkageStructA*)TlsGetValue(g_dwTlsIndex);

    CMASSERTMSG(pAnsiRasLinkage, TEXT("FreeCmRasUtoA -- RasLinkage hasn't been established yet.  Why are we calling FreeCmRasUtoA now?"));

    if (pAnsiRasLinkage)
    {        
        if (pAnsiRasLinkage->hInstRas)
        {
            FreeLibrary(pAnsiRasLinkage->hInstRas);
        }

        if (pAnsiRasLinkage->hInstRnaph)
        {
            FreeLibrary(pAnsiRasLinkage->hInstRnaph);
        }

        CmFree(pAnsiRasLinkage);
        TlsSetValue(g_dwTlsIndex, (LPVOID)NULL);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  InitCmRasUtoA
//
// Synopsis:  Function to Initialize the Unicode to ANSI conversion layer for
//            RAS functions.  In order to make the LinkToRas stuff work the 
//            same on win9x and on NT (all come from one dll) we have Cmdial32.dll 
//            link to cmutoa and get all of the RAS Entry points through Cmutoa.dll.
//            In order to make this work, we need to keep function pointers to all of
//            the RAS Dll's in memory.  In order to prevent two cmdial's on different
//            threads from calling InitCmRasUtoA and FreeCmRasUtoA at the wrong times
//            (one thread freeing right after another had initialized would leave 
//            the first thread in a broken state), we usesthread local storage
//            to hold a pointer to a RasLinkageStructA.  This makes us thread safe
//            and allows us to only have to init the RAS pointers once per thread 
//            (having multiple Cmdials in the same thread is pretty unlikely anyway).
//            See cmdial\ras.cpp\LinkToRas for more details on the cmdial side of
//            things.
//
// Arguments: Nothing
//
// Returns:   BOOL -- TRUE if all of the requested APIs were loaded properly.
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
BOOL InitCmRasUtoA()
{
    BOOL bReturn = TRUE;
    BOOL bTryRnaph = FALSE;

    //
    //  First Try to get the RasLinkageStruct out of Thread Local Storage, we
    //  may already be initialized.
    //
    RasLinkageStructA* pAnsiRasLinkage = (RasLinkageStructA*)TlsGetValue(g_dwTlsIndex);

    CMASSERTMSG(NULL == pAnsiRasLinkage, TEXT("InitCmRasUtoA -- RasLinkage Already established.  Why are we calling InitCmRasUtoA more than once?"));

    if (NULL == pAnsiRasLinkage)
    {
        //
        //  Then we haven't linked to RAS yet, first allocate the struct
        //
        pAnsiRasLinkage = (RasLinkageStructA*)CmMalloc(sizeof(RasLinkageStructA));

        if (!pAnsiRasLinkage)
        {
            return FALSE;
        }

        //
        //  Now that we have a structure, lets start filling it in.  Try getting all of
        //  the entry points out of RasApi32.dll first, then try rnaph.dll if necessary.
        //

        pAnsiRasLinkage->hInstRas = LoadLibraryExA("rasapi32.dll", NULL, 0);

        CMASSERTMSG(NULL != pAnsiRasLinkage->hInstRas, TEXT("InitCmRasUtoA -- Unable to load rasapi32.dll.  Failing Ras Link."));

        //  before doing this, fix up the array based on whether we are on
        //  Millennium or not.  The function below exists only on Millennium
        if (!OS_MIL)
        {
            c_ArrayOfRasFuncsA[10] = NULL; //RasSetSubEntryProperties
            c_ArrayOfRasFuncsA[11] = NULL; //RasDeleteSubEntry
        }

        if (pAnsiRasLinkage->hInstRas)
        {
            for (int i = 0 ; c_ArrayOfRasFuncsA[i] ; i++)
            {
                pAnsiRasLinkage->apvPfnRas[i] = GetProcAddress(pAnsiRasLinkage->hInstRas, c_ArrayOfRasFuncsA[i]);

                if (!(pAnsiRasLinkage->apvPfnRas[i]))
                {
                    bTryRnaph = TRUE;
                }                   
            }
        }

        //
        //  If we missed a few, then we need to get them from rnaph.dll
        //
        if (bTryRnaph)
        {
            pAnsiRasLinkage->hInstRnaph = LoadLibraryExA("rnaph.dll", NULL, 0);
            CMASSERTMSG(NULL != pAnsiRasLinkage->hInstRnaph, TEXT("InitCmRasUtoA -- Unable to load Rnaph.dll.  Failing Ras Link."));

            if (pAnsiRasLinkage->hInstRnaph)
            {
                for (int i = 0 ; c_ArrayOfRasFuncsA[i] ; i++)
                {
                    if (NULL == pAnsiRasLinkage->apvPfnRas[i])
                    {
                        pAnsiRasLinkage->apvPfnRas[i] = GetProcAddress(pAnsiRasLinkage->hInstRnaph, c_ArrayOfRasFuncsA[i]);

                        if (!(pAnsiRasLinkage->apvPfnRas[i]))
                        {
                            bReturn = FALSE;
                        }
                    }
                }        
            }
        }

        //
        //  Always save the pAnsiRasLinkage value to thread local storage, if the linkage wasn't successful
        //  we will call FreeCmRasUtoA to clean it up.  If it was successful we need to maintain it for later
        //  use.  Note that the first thing FreeCmRasUtoA does is get the Ras Linkage struct pointer out of 
        //  thread local storage because that is were it would reside under normal operation.
        //

        TlsSetValue(g_dwTlsIndex, (LPVOID)pAnsiRasLinkage);   

        if (!bReturn)
        {
            //
            //  Ras Linkage failed for some reason.  We need to free up any resources we
            //  may have partially filled in.
            //
            FreeCmRasUtoA();
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  SHGetPathFromIDListUA
//
// Synopsis:  Unicode to Ansi wrapper for the win32 SHGetPathFromIDList API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
BOOL SHGetPathFromIDListUA(LPCITEMIDLIST pidl, LPWSTR pszPath)
{
    BOOL bReturn = FALSE;

    if (pidl && pszPath)
    {
        CHAR szAnsiPath[MAX_PATH+1];

        bReturn = SHGetPathFromIDListA(pidl, szAnsiPath);

        if (bReturn)
        {
            int iChars = SzToWz(szAnsiPath, pszPath, MAX_PATH); // don't know correct length but 
                                                                // the API says the path should be at
                                                                // least MAX_PATH
            if (!iChars || (MAX_PATH < (DWORD)iChars))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                bReturn = FALSE;
            }
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  SHGetSpecialFolderLocationUA
//
// Synopsis:  While the win32 SHGetSpecialFolderLocation API doesn't actually 
//            require any conversion between Unicode and ANSI, CM's shell dll
//            class can only take one dll to take entry points from.  Thus I
//            was forced to add these here so that the class could get all the
//            shell APIs it needed from cmutoa.dll.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
HRESULT SHGetSpecialFolderLocationUA(HWND hwnd, int csidl, LPITEMIDLIST *ppidl)
{
    return SHGetSpecialFolderLocation(hwnd, csidl, ppidl);
}

//+----------------------------------------------------------------------------
//
// Function:  SHGetMallocUA
//
// Synopsis:  While the win32 SHGetMalloc API doesn't actually 
//            require any conversion between Unicode and ANSI, CM's shell dll
//            class can only take one dll to take entry points from.  Thus I
//            was forced to add these here so that the class could get all the
//            shell APIs it needed from cmutoa.dll.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
HRESULT SHGetMallocUA(LPMALLOC * ppMalloc)
{
    return SHGetMalloc(ppMalloc);
}

//+----------------------------------------------------------------------------
//
// Function:  ShellExecuteExUA
//
// Synopsis:  Unicode to Ansi wrapper for the win32 ShellExecuteEx API.
//            Note that we do note convert the lpIDList param of the 
//            SHELLEXECUTEINFOW struct because it is just a binary blob.  Thus
//            figuring out how to convert it if we don't know what it is.  If
//            we need this in the future we will have to deal with it on a case
//            by case basis.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
BOOL ShellExecuteExUA(LPSHELLEXECUTEINFOW pShellInfoW)
{
    BOOL bReturn = FALSE;
    SHELLEXECUTEINFOA ShellInfoA;
    ZeroMemory(&ShellInfoA, sizeof(ShellInfoA));

    if (pShellInfoW)
    {
        ShellInfoA.cbSize = sizeof(ShellInfoA);
        ShellInfoA.fMask = pShellInfoW->fMask;
        ShellInfoA.hwnd = pShellInfoW->hwnd;

        if (pShellInfoW->lpVerb)
        {
            ShellInfoA.lpVerb = WzToSzWithAlloc(pShellInfoW->lpVerb);
            if (NULL == ShellInfoA.lpVerb)
            {
                goto exit;
            }
        }

        if (pShellInfoW->lpFile)
        {
            ShellInfoA.lpFile = WzToSzWithAlloc(pShellInfoW->lpFile);
            if (NULL == ShellInfoA.lpFile)
            {
                goto exit;
            }
        }

        if (pShellInfoW->lpParameters)
        {
            ShellInfoA.lpParameters = WzToSzWithAlloc(pShellInfoW->lpParameters);
            if (NULL == ShellInfoA.lpParameters)
            {
                goto exit;
            }
        }

        if (pShellInfoW->lpDirectory)
        {
            ShellInfoA.lpDirectory = WzToSzWithAlloc(pShellInfoW->lpDirectory);
            if (NULL == ShellInfoA.lpDirectory)
            {
                goto exit;
            }
        }

        ShellInfoA.nShow = pShellInfoW->nShow;
        ShellInfoA.hInstApp = pShellInfoW->hInstApp;
        
        //
        // Since this is a binary blob conversion could be difficult.
        // We also don't currently use it, so I won't spend the cycles implementing it now.
        //
        MYDBGASSERT(NULL == pShellInfoW->lpIDList);
        ShellInfoA.lpIDList = NULL;

        if (pShellInfoW->lpClass)
        {
            ShellInfoA.lpClass = WzToSzWithAlloc(pShellInfoW->lpClass);
            if (NULL == ShellInfoA.lpClass)
            {
                goto exit;
            }
        }

        ShellInfoA.hkeyClass = pShellInfoW->hkeyClass;
        ShellInfoA.hIcon = pShellInfoW->hIcon; // hIcon/hMonitor is a union so we only need one of them to get the mem
        // HANDLE hProcess this is a return param dealt with below.

        //
        //  Finally call ShellExecuteExA
        //
        bReturn = ShellExecuteExA(&ShellInfoA);

        if (ShellInfoA.hProcess)
        {
            //
            //  The Caller asked for the process handle so send it back.
            //
            pShellInfoW->hProcess = ShellInfoA.hProcess;          
        }
    }

exit:

    CmFree((void*)ShellInfoA.lpVerb);
    CmFree((void*)ShellInfoA.lpFile);
    CmFree((void*)ShellInfoA.lpParameters);
    CmFree((void*)ShellInfoA.lpDirectory);
    CmFree((void*)ShellInfoA.lpClass);

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  Shell_NotifyIconUA
//
// Synopsis:  Unicode to Ansi wrapper for the win32 Shell_NotifyIcon API.
//
// Arguments: See the win32 API definition
//
// Returns:   See the win32 API definition
//
// History:   quintinb Created    7/15/99
//
//+----------------------------------------------------------------------------
BOOL Shell_NotifyIconUA (DWORD dwMessage, PNOTIFYICONDATAW pnidW)
{
    BOOL bReturn = FALSE;
    
    if (pnidW)
    {
        NOTIFYICONDATAA nidA;

        ZeroMemory (&nidA, sizeof(NOTIFYICONDATAA));
        nidA.cbSize = sizeof(NOTIFYICONDATAA);

        nidA.hWnd = pnidW->hWnd;
        nidA.uID = pnidW->uID;
        nidA.uFlags = pnidW->uFlags;
        nidA.uCallbackMessage = pnidW->uCallbackMessage;
        nidA.hIcon = pnidW->hIcon;

        int iChars = WzToSz(pnidW->szTip, nidA.szTip, 64); // 64 is the length of the szTip in the 4.0 struct
        if (!iChars || (64 < iChars))
        {
            nidA.szTip[0] = '\0';
        }

        bReturn = Shell_NotifyIconA(dwMessage, &nidA);
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\mprcommn\thunk.c ===
/*
    File thunk.c

    Provides api's to convert one-the-wire structures to the host structures
    for the mpr api's.

    The MprApi's provide many structures with embedded pointers.  These pointers
    are converted to 32 bit offsets before transmitting them on the wire.  In 
    order to preserve compatibility accross 64bit and 32bit machines, the 
    following thunking code is required.  RPC doesn't do this for us in the
    cases where we marshall our own data.

*/

#include <windows.h>
#include <mprapip.h>
#include <rpc.h>
#include <rpcndr.h>

//
// Call:        MprUtilGetSizeOfMultiSz
//
// Returns:     size in bytes of lpwsDialoutHoursRestriction
//
// Description: Utility to calculate the size in bytes of MULTI_SZ 
//
DWORD 
MprUtilGetSizeOfMultiSz(
    IN LPWSTR lpwsMultiSz)
{
    LPWSTR lpwsPtr = lpwsMultiSz;
    DWORD dwcbBytes  = 0;
    DWORD dwCurCount;

    if ( lpwsPtr == NULL )
    {
        return( 0 );
    }

    while( *lpwsPtr != L'\0' )
    {
        dwCurCount = ( wcslen( lpwsPtr ) + 1 );
        dwcbBytes += dwCurCount;
        lpwsPtr += dwCurCount;
    }

    //
    // One more for the last NULL terminator
    //

    dwcbBytes++;

    dwcbBytes *= sizeof( WCHAR );

    return( dwcbBytes );
}

//
// Generic allocation for the thunking api's
//
PVOID
MprThunkAlloc(
    IN DWORD dwSize)
{
    return LocalAlloc( LMEM_FIXED , dwSize);
}

//
// Generic free for the thunking api's
//
VOID
MprThunkFree(   
    IN PVOID pvData)
{
    LocalFree( pvData );
}

//
// Cleans up after MprThunkInterface_HtoW
//
DWORD 
MprThunkInterfaceFree(
    IN PVOID   pvInfo,
    IN DWORD   dwLevel)
{
#ifdef _WIN64

    if ( pvInfo )
    {
        LocalFree( pvInfo );
    }

#else

    if ( dwLevel == 1 || dwLevel == 2 )
    {
        if ( pvInfo )
        {
            LocalFree( pvInfo );
        }
    }

#endif

    return NO_ERROR;
}

//
// Converts an array of MPRI_INTERFACE_0 structures to an array
// of MPR_INTERFACE_0 structures on a 64 bit machine.  On a 32
// bit machine, the structures are identical.
//
DWORD
MprThunkInterface_32to64_0(
    IN  MPRI_INTERFACE_0* pIfs32,
    IN  DWORD dwBufferSize,
    IN  DWORD dwCount,
    IN  BOOL fAllocate,
    IN  MprThunk_Allocation_Func pAlloc,
    IN  MprThunk_Free_Func pFree,
    OUT MPR_INTERFACE_0** ppIfs0)
{
    DWORD dwErr = NO_ERROR, i;
    MPR_INTERFACE_0 *pCur64 = NULL, *pIfs64 = NULL;
    MPRI_INTERFACE_0* pCur32 = NULL;

    if (dwCount == 0)
    {
        *ppIfs0 = NULL;
        return NO_ERROR;
    }

    do
    {
        // Allocate the new structures
        //
        if (fAllocate)
        {
            pIfs64 = (MPR_INTERFACE_0*)
                pAlloc(dwCount * sizeof(MPR_INTERFACE_0));
            if (pIfs64 == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
        else
        {
            pIfs64 = *ppIfs0;
        }

        // Copy over all of the information
        //
        for (i = 0, pCur32 = pIfs32, pCur64 = pIfs64;
             i < dwCount;
             i++, pCur32++, pCur64++)
        {
            wcscpy(pCur64->wszInterfaceName, pCur32->wszInterfaceName);
            pCur64->hInterface           = UlongToPtr(pCur32->dwInterface);
            pCur64->fEnabled             = pCur32->fEnabled;
            pCur64->dwIfType             = pCur32->dwIfType;
            pCur64->dwConnectionState    = pCur32->dwConnectionState;
            pCur64->fUnReachabilityReasons = pCur32->fUnReachabilityReasons;
            pCur64->dwLastError          = pCur32->dwLastError;
        }

        // Assign the return value
        //
        *ppIfs0 = pIfs64;

    } while (FALSE);

    // Cleanup
    //
    {
        if (dwErr != NO_ERROR)
        {
            if (pIfs64 && fAllocate)
            {
                pFree(pIfs64);
            }
        }
    }

    return dwErr;
}        

//
// Converts an array of MPRI_INTERFACE_1 structures to an array
// of MPR_INTERFACE_1 structures on a 64 bit machine.  On a 32
// bit machine, the structures are identical.
//
DWORD
MprThunkInterface_32to64_1(
    IN  MPRI_INTERFACE_1* pIfs32,
    IN  DWORD dwBufferSize,
    IN  MprThunk_Allocation_Func pAlloc,
    IN  MprThunk_Free_Func pFree,
    OUT MPR_INTERFACE_1** ppIfs1)
{
    DWORD dwErr = NO_ERROR, i, dwSize;
    MPR_INTERFACE_1 *pIfs64 = NULL;

    if (pIfs32 == NULL)
    {
        *ppIfs1 = NULL;
        return NO_ERROR;
    }

    do
    {
        // Compute the size of the buffer to allocate for storing
        // the level-one information.  The size the sum of the 
        // size of the on-the-wire buffer plus the extra space for 
        // 64 bit embedded pointers.
        // 
        dwSize = 
            dwBufferSize + 
            (sizeof(MPR_INTERFACE_1) - sizeof(MPRI_INTERFACE_1));
            
        pIfs64 = (MPR_INTERFACE_1*)pAlloc(dwSize);
        if (pIfs64 == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Thunk the common level-zero stuff
        //
        dwErr = MprThunkInterface_32to64_0(
                    (MPRI_INTERFACE_0*)pIfs32, 
                    dwBufferSize,
                    1, 
                    FALSE, 
                    pAlloc,
                    pFree,
                    (MPR_INTERFACE_0**)&pIfs64);
        if (dwErr != NO_ERROR)
        {   
            break;
        }

        // Thunk the level-one specific stuff
        //
        pIfs64->lpwsDialoutHoursRestriction = 
            UlongToPtr(pIfs32->dwDialoutHoursRestrictionOffset);

        // Copy over the variable-length data.
        //
        CopyMemory(
            (PVOID)(pIfs64 + 1),
            (CONST VOID*)(pIfs32 + 1),
            dwBufferSize - sizeof(MPRI_INTERFACE_1));
                
        // Assign the return value
        //
        *ppIfs1 = pIfs64;

    } while (FALSE);

    // Cleanup
    //
    {
        if (dwErr != NO_ERROR)
        {
            if (pIfs64)
            {
                pFree(pIfs64);
            }
        }
    }

    return dwErr;
}        

//
// Converts an array of MPRI_INTERFACE_2 structures to an array
// of MPR_INTERFACE_2 structures on a 64 bit machine.  On a 32
// bit machine, the structures are identical.
//
DWORD
MprThunkInterface_32to64_2(
    IN  MPRI_INTERFACE_2* pIfs32,
    IN  DWORD dwBufferSize,
    IN  MprThunk_Allocation_Func pAlloc,
    IN  MprThunk_Free_Func pFree,
    OUT MPR_INTERFACE_2** ppIfs2)
{
    DWORD dwErr = NO_ERROR, i, dwSize;
    MPR_INTERFACE_2 *pIfs64 = NULL;

    if (pIfs32 == NULL)
    {
        *ppIfs2 = NULL;
        return NO_ERROR;
    }

    do
    {
        // Compute the size of the buffer to allocate for storing
        // the level-one information.  The size the sum of the 
        // size of the on-the-wire buffer plus the extra space for 
        // 64 bit embedded pointers.
        // 
        dwSize = 
            dwBufferSize + 
            (sizeof(MPR_INTERFACE_2) - sizeof(MPRI_INTERFACE_2));
            
        pIfs64 = (MPR_INTERFACE_2*)pAlloc(dwSize);
        if (pIfs64 == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Thunk the common level-zero stuff
        //
        dwErr = MprThunkInterface_32to64_0(
                    (MPRI_INTERFACE_0*)pIfs32, 
                    dwBufferSize,
                    1, 
                    FALSE, 
                    pAlloc,
                    pFree,
                    (MPR_INTERFACE_0**)&pIfs64);
        if (dwErr != NO_ERROR)
        {   
            break;
        }

        // Thunk the level-two specific stuff
        //

        pIfs64->dwfOptions                = pIfs32->dwfOptions;
        pIfs64->ipaddr                    = pIfs32->ipaddr;
        pIfs64->ipaddrDns                 = pIfs32->ipaddrDns;
        pIfs64->ipaddrDnsAlt              = pIfs32->ipaddrDnsAlt;
        pIfs64->ipaddrWins                = pIfs32->ipaddrWins;
        pIfs64->ipaddrWinsAlt             = pIfs32->ipaddrWinsAlt;
        pIfs64->dwfNetProtocols           = pIfs32->dwfNetProtocols;
        pIfs64->dwChannels                = pIfs32->dwChannels;
        pIfs64->dwSubEntries              = pIfs32->dwSubEntries;
        pIfs64->dwDialMode                = pIfs32->dwDialMode;
        pIfs64->dwDialExtraPercent        = pIfs32->dwDialExtraPercent;
        pIfs64->dwDialExtraSampleSeconds  = pIfs32->dwDialExtraSampleSeconds;
        pIfs64->dwHangUpExtraPercent      = pIfs32->dwHangUpExtraPercent;
        pIfs64->dwHangUpExtraSampleSeconds= pIfs32->dwHangUpExtraSampleSeconds;
        pIfs64->dwIdleDisconnectSeconds   = pIfs32->dwIdleDisconnectSeconds;
        pIfs64->dwType                    = pIfs32->dwType;
        pIfs64->dwEncryptionType          = pIfs32->dwEncryptionType;
        pIfs64->dwCustomAuthKey           = pIfs32->dwCustomAuthKey;
        pIfs64->dwCustomAuthDataSize      = pIfs32->dwCustomAuthDataSize;
        pIfs64->guidId                    = pIfs32->guidId;
        pIfs64->dwVpnStrategy             = pIfs32->dwVpnStrategy;

        // The following get set in the post-thunk processing when 
        // pointers to variable length data are adjusted.
        //
        // pIfs64->szAlternates;
        // pIfs64->lpbCustomAuthData;

        wcscpy(pIfs64->szLocalPhoneNumber, pIfs32->szLocalPhoneNumber);
        wcscpy(pIfs64->szDeviceType,       pIfs32->szDeviceType);
        wcscpy(pIfs64->szDeviceName,       pIfs32->szDeviceName);
        wcscpy(pIfs64->szX25PadType,       pIfs32->szX25PadType);
        wcscpy(pIfs64->szX25Address,       pIfs32->szX25Address);
        wcscpy(pIfs64->szX25Facilities,    pIfs32->szX25Facilities);
        wcscpy(pIfs64->szX25UserData,      pIfs32->szX25UserData);

        // Copy over the variable-length data.
        //
        CopyMemory(
            (PVOID)(pIfs64 + 1),
            (CONST VOID*)(pIfs32 + 1),
            dwBufferSize - sizeof(MPRI_INTERFACE_2));
                
        // Assign the return value
        //
        *ppIfs2 = pIfs64;

    } while (FALSE);

    // Cleanup
    //
    {
        if (dwErr != NO_ERROR)
        {
            if (pIfs64)
            {
                pFree(pIfs64);
            }
        }
    }

    return dwErr;
}        

//
// Converts an array of MPR_INTERFACE_0 structures to an array
// of MPRI_INTERFACE_0 structures on a 64 bit machine.  On a 32
// bit machine, the structures are identical.
//
DWORD
MprThunkInterface_64to32_0(
    IN  MPR_INTERFACE_0* pIf64,
    OUT MPRI_INTERFACE_0* pIf0)
{
    wcscpy(pIf0->wszInterfaceName, pIf64->wszInterfaceName);
    
    pIf0->dwInterface             = PtrToUlong(pIf64->hInterface);
    pIf0->fEnabled                = pIf64->fEnabled;
    pIf0->dwIfType                = pIf64->dwIfType;
    pIf0->dwConnectionState       = pIf64->dwConnectionState;
    pIf0->fUnReachabilityReasons  = pIf64->fUnReachabilityReasons;
    pIf0->dwLastError             = pIf64->dwLastError;

    return NO_ERROR;
}        

//
// Converts an MPR_INTERFACE_1 structure to a of MPRI_INTERFACE_1 
// structure on a 64 bit machine.  On a 32 bit machine, the 
// structures are identical.
//
DWORD
MprThunkInterface_64to32_1(
    IN  MPR_INTERFACE_1* pIf64,
    OUT MPRI_INTERFACE_1* pIf1)
{
    DWORD dwErr = NO_ERROR, i;

    do
    {
        // Thunk the common level-zero stuff
        //
        dwErr = MprThunkInterface_64to32_0(
                    (MPR_INTERFACE_0*)pIf64, 
                    (MPRI_INTERFACE_0*)pIf1);
        if (dwErr != NO_ERROR)
        {   
            break;
        }

    } while (FALSE);

    return dwErr;
}        

//
// Converts an array of MPR_INTERFACE_2 structures to an array
// of MPRI_INTERFACE_2 structures on a 64 bit machine.  On a 32
// bit machine, the structures are identical.
//
DWORD
MprThunkInterface_64to32_2(
    IN  MPR_INTERFACE_2* pIf64,
    OUT MPRI_INTERFACE_2* pIf2)
{
    DWORD dwErr = NO_ERROR, i;

    do
    {
        // Thunk the common level-zero stuff
        //
        dwErr = MprThunkInterface_64to32_0(
                    (MPR_INTERFACE_0*)pIf64, 
                    (MPRI_INTERFACE_0*)pIf2);
        if (dwErr != NO_ERROR)
        {   
            break;
        }

        // Thunk the level-two specific stuff
        //
        pIf2->dwfOptions                = pIf64->dwfOptions;
        pIf2->ipaddr                    = pIf64->ipaddr;
        pIf2->ipaddrDns                 = pIf64->ipaddrDns;
        pIf2->ipaddrDnsAlt              = pIf64->ipaddrDnsAlt;
        pIf2->ipaddrWins                = pIf64->ipaddrWins;
        pIf2->ipaddrWinsAlt             = pIf64->ipaddrWinsAlt;
        pIf2->dwfNetProtocols           = pIf64->dwfNetProtocols;
        pIf2->dwChannels                = pIf64->dwChannels;
        pIf2->dwSubEntries              = pIf64->dwSubEntries;
        pIf2->dwDialMode                = pIf64->dwDialMode;
        pIf2->dwDialExtraPercent        = pIf64->dwDialExtraPercent;
        pIf2->dwDialExtraSampleSeconds  = pIf64->dwDialExtraSampleSeconds;
        pIf2->dwHangUpExtraPercent      = pIf64->dwHangUpExtraPercent;
        pIf2->dwHangUpExtraSampleSeconds= pIf64->dwHangUpExtraSampleSeconds;
        pIf2->dwIdleDisconnectSeconds   = pIf64->dwIdleDisconnectSeconds;
        pIf2->dwType                    = pIf64->dwType;
        pIf2->dwEncryptionType          = pIf64->dwEncryptionType;
        pIf2->dwCustomAuthKey           = pIf64->dwCustomAuthKey;
        pIf2->dwCustomAuthDataSize      = pIf64->dwCustomAuthDataSize;
        pIf2->guidId                    = pIf64->guidId;
        pIf2->dwVpnStrategy             = pIf64->dwVpnStrategy;

        wcscpy(pIf2->szLocalPhoneNumber, pIf64->szLocalPhoneNumber);
        wcscpy(pIf2->szDeviceType,       pIf64->szDeviceType);
        wcscpy(pIf2->szDeviceName,       pIf64->szDeviceName);
        wcscpy(pIf2->szX25PadType,       pIf64->szX25PadType);
        wcscpy(pIf2->szX25Address,       pIf64->szX25Address);
        wcscpy(pIf2->szX25Facilities,    pIf64->szX25Facilities);
        wcscpy(pIf2->szX25UserData,      pIf64->szX25UserData);

    } while (FALSE);

    return dwErr;
}        

//
// Convert interface structs from the wire representation to the 
// host representation
//
DWORD
MprThunkInterface_WtoH(
    IN      DWORD   dwLevel,
    IN      LPBYTE  lpbBuffer,
    IN      DWORD   dwBufferSize,
    IN      DWORD   dwCount,
    IN      MprThunk_Allocation_Func pAlloc,
    IN      MprThunk_Free_Func pFree,
    OUT     LPBYTE* lplpbBuffer)
{
    MPR_INTERFACE_0* pIfs0 = NULL;
    MPR_INTERFACE_1* pIf1 = NULL;
    MPR_INTERFACE_2* pIf2 = NULL;
    DWORD dwErr = NO_ERROR, i;

#ifdef _WIN64        

    //
    // Generate the 64 bit host structures based on the 32 bit
    // wire structures.
    //
    switch (dwLevel)
    {
        case 0:
            dwErr = MprThunkInterface_32to64_0(
                        (MPRI_INTERFACE_0*)lpbBuffer,
                        dwBufferSize,
                        dwCount,
                        TRUE,
                        pAlloc,
                        pFree,
                        &pIfs0);
            *lplpbBuffer = (LPBYTE)pIfs0;
            break;

        case 1:
            dwErr = MprThunkInterface_32to64_1(
                        (MPRI_INTERFACE_1*)lpbBuffer, 
                        dwBufferSize,
                        pAlloc,
                        pFree,
                        &pIf1);
            *lplpbBuffer = (LPBYTE)pIf1;
            break;

        case 2:
            dwErr = MprThunkInterface_32to64_2(
                        (MPRI_INTERFACE_2*)lpbBuffer, 
                        dwBufferSize,
                        pAlloc,
                        pFree,
                        &pIf2);
            *lplpbBuffer = (LPBYTE)pIf2;
            break;
    }

    // Free the unthunked data
    //
    pFree(lpbBuffer);
    
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }
    
#else

    // 32 bit -- nothing to do since the structures
    // match
    //
    *lplpbBuffer = lpbBuffer;
    
#endif

    // By this point in the code, the structures have been converted from
    // their wire format to the host format and stored in *lplpbBuffer.
    // Now we perform some post-processing to adjust the pointers to 
    // variable length data.

    switch (dwLevel)
    {
        case 0:
            break;

        case 1:
            pIf1 = (MPR_INTERFACE_1*)(*lplpbBuffer);
            if ( pIf1->lpwsDialoutHoursRestriction != NULL )
            {
                pIf1->lpwsDialoutHoursRestriction = (PWCHAR)(pIf1 + 1);
            }
            break;
            
        case 2:
            pIf2 = (MPR_INTERFACE_2*)(*lplpbBuffer);
            if ( pIf2->dwCustomAuthDataSize )
            {
                pIf2->lpbCustomAuthData = (LPBYTE)(pIf2 + 1);
            }
            if ( pIf2->szAlternates )
            {
                pIf2->szAlternates = (PWCHAR)
                    (*lplpbBuffer                + 
                     sizeof(MPR_INTERFACE_2)     +
                     pIf2->dwCustomAuthDataSize
                    );
            }
            break;
    }

    return dwErr;
}

DWORD
MprThunkInterface_HtoW(
    IN      DWORD   dwLevel,
    IN      LPBYTE  lpbBuffer,
    OUT     LPBYTE* lplpbBuffer,
    OUT     LPDWORD lpdwSize)
{
    DWORD dwErr = NO_ERROR, dwSize, dwOffset;
    LPBYTE lpbRet = NULL;
    
    switch ( dwLevel )
    {
        case 0:
            dwSize = sizeof(MPRI_INTERFACE_0);
#ifdef _WIN64     
            // Allocate and thunk a wire structure
            //
            lpbRet = MprThunkAlloc(dwSize);
            if (lpbRet == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            dwErr = 
                MprThunkInterface_64to32_0(
                    (MPR_INTERFACE_0*)lpbBuffer,
                    (MPRI_INTERFACE_0*)lpbRet);
#else
            // Nothing to do host and wire structures are identical
            // and there is no variable length data
            //
            lpbRet = lpbBuffer;
#endif
            break;

        case 1:
            {
                MPR_INTERFACE_1 * pIf1 = (MPR_INTERFACE_1*)lpbBuffer;
                MPRI_INTERFACE_1 * pIfi1 = NULL;
                DWORD             cbDialoutHoursRestriction;

                // Allocate a buffer to store the on-the-wire info
                //
                cbDialoutHoursRestriction = 
                    MprUtilGetSizeOfMultiSz(
                        pIf1->lpwsDialoutHoursRestriction );

                dwSize = 
                    sizeof( MPRI_INTERFACE_1 ) + cbDialoutHoursRestriction;

                lpbRet = MprThunkAlloc(dwSize);
                if ( lpbRet == NULL )
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
#ifdef _WIN64
                dwErr = 
                    MprThunkInterface_64to32_1(
                        pIf1,
                        (MPRI_INTERFACE_1*)lpbRet);
                if (dwErr != NO_ERROR)
                {
                    break;
                }
#else
                CopyMemory(lpbRet, pIf1, sizeof(MPR_INTERFACE_1));
#endif
                // Level 1 specific embedded pointers.  Set them to non-zero
                // to indicate whether there is variable length data.
                //
                pIfi1 = (MPRI_INTERFACE_1*)lpbRet;
                pIfi1->dwDialoutHoursRestrictionOffset = 
                    !!(PtrToUlong(pIf1->lpwsDialoutHoursRestriction));

                // Copy in variable length data
                //
                if ( cbDialoutHoursRestriction > 0 )
                {
                    CopyMemory( 
                        lpbRet + sizeof(MPRI_INTERFACE_1),
                        pIf1->lpwsDialoutHoursRestriction,
                        cbDialoutHoursRestriction );
                }
            }                
            break;
            
        case 2:
            {
                MPR_INTERFACE_2 * pIf2 = (MPR_INTERFACE_2*)lpbBuffer;
                MPRI_INTERFACE_2 * pIfi2 = NULL;
                DWORD dwAltSize = MprUtilGetSizeOfMultiSz(pIf2->szAlternates);

                // Calcluate the size of the variable length structure
                //
                dwSize = 
                    sizeof( MPRI_INTERFACE_2 )       + 
                    dwAltSize                        + 
                    pIf2->dwCustomAuthDataSize;

                // Allocate the buffer
                //
                lpbRet = MprThunkAlloc(dwSize);
                if ( lpbRet == NULL )
                {
                    dwErr = GetLastError();
                    break;
                }

                // Copy over the base strucuture
                //
#ifdef _WIN64
                dwErr = 
                    MprThunkInterface_64to32_2(
                        pIf2,
                        (MPRI_INTERFACE_2*)lpbRet);
                if (dwErr != NO_ERROR)
                {
                    break;
                }
#else
                CopyMemory(lpbRet, pIf2, sizeof(MPR_INTERFACE_2));
#endif                
                // Level 2 specific embedded pointers.  Set them to non-zero
                // to indicate whether there is variable length data.
                //
                pIfi2 = (MPRI_INTERFACE_2*)lpbRet;
                pIfi2->dwAlternatesOffset = !!(PtrToUlong(pIf2->szAlternates));
                pIfi2->dwCustomAuthDataOffset = !!pIf2->dwCustomAuthDataSize;

                // Copy the custom auth data if any
                //
                dwOffset = sizeof( MPRI_INTERFACE_2 );
                if ( pIf2->dwCustomAuthDataSize )
                {
                    CopyMemory(
                        lpbRet + dwOffset,
                        pIf2->lpbCustomAuthData,
                        pIf2->dwCustomAuthDataSize);
                }

                // Copy the alternates list if any
                //
                dwOffset += pIf2->dwCustomAuthDataSize;
                if ( dwAltSize > 0 )
                {
                    CopyMemory( 
                        lpbRet + dwOffset,
                        pIf2->szAlternates,
                        dwAltSize );
                }
            }
            break;

        default:
            return( ERROR_NOT_SUPPORTED );
    }

    if (dwErr == NO_ERROR)
    {
        *lplpbBuffer = lpbRet;
        *lpdwSize = dwSize;
    }
    else
    {
        MprThunkInterfaceFree(lpbRet, dwLevel);
    }
    
    return dwErr;
}
//
// Converts an array of RASI_PORT_0 structures to an array
// of RAS_PORT_0 structures on a 64 bit machine.  On a 32
// bit machine, the structures are identical.
//
DWORD
MprThunkPort_32to64_0(
    IN  RASI_PORT_0* pPorts32,
    IN  DWORD dwBufferSize,
    IN  DWORD dwCount,
    IN  MprThunk_Allocation_Func pAlloc,
    IN  MprThunk_Free_Func pFree,
    OUT RAS_PORT_0** ppPorts0)
{
    DWORD dwErr = NO_ERROR, i;
    RAS_PORT_0 *pCur64 = NULL, *pPorts64 = NULL;
    RASI_PORT_0* pCur32 = NULL;

    if (dwCount == 0)
    {
        *ppPorts0 = NULL;
        return NO_ERROR;
    }

    do
    {
        // Allocate the new structures
        //
        pPorts64 = (RAS_PORT_0*)
            pAlloc(dwCount * sizeof(RAS_PORT_0));
        if (pPorts64 == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Copy over all of the information
        //
        for (i = 0, pCur32 = pPorts32, pCur64 = pPorts64;
             i < dwCount;
             i++, pCur32++, pCur64++)
        {
            pCur64->hPort = UlongToPtr(pCur32->dwPort);
            pCur64->hConnection = UlongToPtr(pCur32->dwConnection);
            pCur64->dwPortCondition = pCur32->dwPortCondition;
            pCur64->dwTotalNumberOfCalls = pCur32->dwTotalNumberOfCalls;
            pCur64->dwConnectDuration = pCur32->dwConnectDuration;
            wcscpy(pCur64->wszPortName, pCur32->wszPortName);
            wcscpy(pCur64->wszMediaName, pCur32->wszMediaName);
            wcscpy(pCur64->wszDeviceName, pCur32->wszDeviceName);
            wcscpy(pCur64->wszDeviceType, pCur32->wszDeviceType);
        }

        // Assign the return value
        //
        *ppPorts0 = pPorts64;

    } while (FALSE);

    // Cleanup
    //
    {
        if (dwErr != NO_ERROR)
        {
            if (pPorts64)
            {
                pFree(pPorts64);
            }
        }
    }

    return dwErr;
}        

//
// Converts an array of RASI_PORT_1 structures to an array
// of RAS_PORT_1 structures on a 64 bit machine.  On a 32
// bit machine, the structures are identical.
//
DWORD
MprThunkPort_32to64_1(
    IN  RASI_PORT_1* pPorts32,
    IN  DWORD dwBufferSize,
    IN  DWORD dwCount,
    IN  MprThunk_Allocation_Func pAlloc,
    IN  MprThunk_Free_Func pFree,
    OUT RAS_PORT_1** ppPorts1)
{
    DWORD dwErr = NO_ERROR, i;
    RAS_PORT_1 *pCur64 = NULL, *pPorts64 = NULL;
    RASI_PORT_1* pCur32 = NULL;

    if (dwCount == 0)
    {
        *ppPorts1 = NULL;
        return NO_ERROR;
    }

    do
    {
        // Allocate the new structures
        //
        pPorts64 = (RAS_PORT_1*)
            pAlloc(dwCount * sizeof(RAS_PORT_1));
        if (pPorts64 == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Copy over all of the information
        //
        for (i = 0, pCur32 = pPorts32, pCur64 = pPorts64;
             i < dwCount;
             i++, pCur32++, pCur64++)
        {
            pCur64->hPort                = UlongToPtr(pCur32->dwPort);
            pCur64->hConnection          = UlongToPtr(pCur32->dwConnection);
            pCur64->dwHardwareCondition  = pCur32->dwHardwareCondition;
            pCur64->dwLineSpeed          = pCur32->dwLineSpeed;
            pCur64->dwBytesXmited        = pCur32->dwBytesXmited;
            pCur64->dwBytesRcved         = pCur32->dwBytesRcved;
            pCur64->dwFramesXmited       = pCur32->dwFramesXmited;
            pCur64->dwFramesRcved        = pCur32->dwFramesRcved;
            pCur64->dwCrcErr             = pCur32->dwCrcErr;
            pCur64->dwTimeoutErr         = pCur32->dwTimeoutErr;
            pCur64->dwAlignmentErr       = pCur32->dwAlignmentErr;
            pCur64->dwHardwareOverrunErr = pCur32->dwHardwareOverrunErr;
            pCur64->dwFramingErr         = pCur32->dwFramingErr;
            pCur64->dwBufferOverrunErr   = pCur32->dwBufferOverrunErr;
            pCur64->dwCompressionRatioIn = pCur32->dwCompressionRatioIn;
            pCur64->dwCompressionRatioOut= pCur32->dwCompressionRatioOut;
        }

        // Assign the return value
        //
        *ppPorts1 = pPorts64;

    } while (FALSE);

    // Cleanup
    //
    {
        if (dwErr != NO_ERROR)
        {
            if (pPorts64)
            {
                pFree(pPorts64);
            }
        }
    }

    return dwErr;
}        


//
// Convert port structs from the wire representation to the 
// host representation
//
DWORD
MprThunkPort_WtoH(
    IN      DWORD   dwLevel,
    IN      LPBYTE  lpbBuffer,
    IN      DWORD   dwBufferSize,
    IN      DWORD   dwCount,
    IN      MprThunk_Allocation_Func pAlloc,
    IN      MprThunk_Free_Func pFree,
    OUT     LPBYTE* lplpbBuffer)
{
    DWORD dwErr = NO_ERROR, i;
    LPBYTE lpbTemp = NULL;

#ifdef _WIN64        

    //
    // Generate the 64 bit host structures based on the 32 bit
    // wire structures.
    //
    switch (dwLevel)
    {
        case 0:
            dwErr = MprThunkPort_32to64_0(
                        (RASI_PORT_0*)lpbBuffer,
                        dwBufferSize,
                        dwCount,
                        pAlloc,
                        pFree,
                        (RAS_PORT_0**)&lpbTemp);
            *lplpbBuffer = lpbTemp;
            break;

        case 1:
            dwErr = MprThunkPort_32to64_1(
                        (RASI_PORT_1*)lpbBuffer, 
                        dwBufferSize,
                        dwCount,
                        pAlloc,
                        pFree,
                        (RAS_PORT_1**)&lpbTemp);
            *lplpbBuffer = lpbTemp;
            break;
    }

    // Free the unthunked data
    //
    pFree(lpbBuffer);
    
#else

    // 32 bit -- nothing to do since the structures
    // match
    //
    *lplpbBuffer = lpbBuffer;
    
#endif

    return dwErr;
}

//
// Converts an array of RASI_CONNECTION_0 structures to an array
// of RAS_CONNECTION_0 structures on a 64 bit machine.  On a 32
// bit machine, the structures are identical.
//
DWORD
MprThunkConnection_32to64_0(
    IN  RASI_CONNECTION_0* pConnections32,
    IN  DWORD dwBufferSize,
    IN  DWORD dwCount,
    IN  MprThunk_Allocation_Func pAlloc,
    IN  MprThunk_Free_Func pFree,
    OUT RAS_CONNECTION_0** ppConnections0)
{
    DWORD dwErr = NO_ERROR, i;
    RAS_CONNECTION_0 *pCur64 = NULL, *pConns64 = NULL;
    RASI_CONNECTION_0* pCur32 = NULL;

    if (dwCount == 0)
    {
        *ppConnections0 = NULL;
        return NO_ERROR;
    }

    do
    {
        // Allocate the new structures
        //
        pConns64 = (RAS_CONNECTION_0*)
            pAlloc(dwCount * sizeof(RAS_CONNECTION_0));
        if (pConns64 == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Copy over all of the information
        //
        for (i = 0, pCur32 = pConnections32, pCur64 = pConns64;
             i < dwCount;
             i++, pCur32++, pCur64++)
        {
            pCur64->hConnection         = UlongToPtr(pCur32->dwConnection);
            pCur64->hInterface          = UlongToPtr(pCur32->dwInterface);
            pCur64->dwConnectDuration   = pCur32->dwConnectDuration;
            pCur64->dwInterfaceType     = pCur32->dwInterfaceType;
            pCur64->dwConnectionFlags   = pCur32->dwConnectionFlags;
            
            wcscpy(pCur64->wszInterfaceName, pCur32->wszInterfaceName);
            wcscpy(pCur64->wszUserName,      pCur32->wszUserName);
            wcscpy(pCur64->wszLogonDomain,   pCur32->wszLogonDomain);
            wcscpy(pCur64->wszRemoteComputer,pCur32->wszRemoteComputer);        
        }

        // Assign the return value
        //
        *ppConnections0 = pConns64;

    } while (FALSE);

    // Cleanup
    //
    {
        if (dwErr != NO_ERROR)
        {
            if (pConns64)
            {
                pFree(pConns64);
            }
        }
    }

    return dwErr;
}        

//
// Converts an array of RASI_CONNECTION_1 structures to an array
// of RAS_CONNECTION_1 structures on a 64 bit machine.  On a 32
// bit machine, the structures are identical.
//
DWORD
MprThunkConnection_32to64_1(
    IN  RASI_CONNECTION_1* pConnections32,
    IN  DWORD dwBufferSize,
    IN  DWORD dwCount,
    IN  MprThunk_Allocation_Func pAlloc,
    IN  MprThunk_Free_Func pFree,
    OUT RAS_CONNECTION_1** ppConnections1)
{
    DWORD dwErr = NO_ERROR, i;
    RAS_CONNECTION_1 *pCur64 = NULL, *pConns64 = NULL;
    RASI_CONNECTION_1* pCur32 = NULL;

    if (dwCount == 0)
    {
        *ppConnections1 = NULL;
        return NO_ERROR;
    }

    do
    {
        // Allocate the new structures
        //
        pConns64 = (RAS_CONNECTION_1*)
            pAlloc(dwCount * sizeof(RAS_CONNECTION_1));
        if (pConns64 == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Copy over all of the information
        //
        for (i = 0, pCur32 = pConnections32, pCur64 = pConns64;
             i < dwCount;
             i++, pCur32++, pCur64++)
        {
            pCur64->hConnection          = UlongToPtr(pCur32->dwConnection);
            pCur64->hInterface           = UlongToPtr(pCur32->dwInterface);
            pCur64->PppInfo              = pCur32->PppInfo;
            pCur64->dwBytesXmited        = pCur32->dwBytesXmited;
            pCur64->dwBytesRcved         = pCur32->dwBytesRcved;
            pCur64->dwFramesXmited       = pCur32->dwFramesXmited;
            pCur64->dwFramesRcved        = pCur32->dwFramesRcved;
            pCur64->dwCrcErr             = pCur32->dwCrcErr;
            pCur64->dwTimeoutErr         = pCur32->dwTimeoutErr;
            pCur64->dwAlignmentErr       = pCur32->dwAlignmentErr;
            pCur64->dwHardwareOverrunErr = pCur32->dwHardwareOverrunErr;
            pCur64->dwFramingErr         = pCur32->dwFramingErr;
            pCur64->dwBufferOverrunErr   = pCur32->dwBufferOverrunErr;
            pCur64->dwCompressionRatioIn = pCur32->dwCompressionRatioIn;
            pCur64->dwCompressionRatioOut= pCur32->dwCompressionRatioOut;
        }

        // Assign the return value
        //
        *ppConnections1 = pConns64;

    } while (FALSE);

    // Cleanup
    //
    {
        if (dwErr != NO_ERROR)
        {
            if (pConns64)
            {
                pFree(pConns64);
            }
        }
    }

    return dwErr;
}        

//
// Converts an array of RASI_CONNECTION_2 structures to an array
// of RAS_CONNECTION_2 structures on a 64 bit machine.  On a 32
// bit machine, the structures are identical.
//
DWORD
MprThunkConnection_32to64_2(
    IN  RASI_CONNECTION_2* pConnections32,
    IN  DWORD dwBufferSize,
    IN  DWORD dwCount,
    IN  MprThunk_Allocation_Func pAlloc,
    IN  MprThunk_Free_Func pFree,
    OUT RAS_CONNECTION_2** ppConnections2)
{
    DWORD dwErr = NO_ERROR, i;
    RAS_CONNECTION_2 *pCur64 = NULL, *pConns64 = NULL;
    RASI_CONNECTION_2* pCur32 = NULL;

    if (dwCount == 0)
    {
        *ppConnections2 = NULL;
        return NO_ERROR;
    }

    do
    {
        // Allocate the new structures
        //
        pConns64 = (RAS_CONNECTION_2*)
            pAlloc(dwCount * sizeof(RAS_CONNECTION_2));
        if (pConns64 == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Copy over all of the information
        //
        for (i = 0, pCur32 = pConnections32, pCur64 = pConns64;
             i < dwCount;
             i++, pCur32++, pCur64++)
        {
            pCur64->hConnection          = UlongToPtr(pCur32->dwConnection);
            pCur64->dwInterfaceType      = pCur32->dwInterfaceType;
            pCur64->guid                 = pCur32->guid;
            pCur64->PppInfo2             = pCur32->PppInfo2;

            wcscpy(pCur64->wszUserName,  pCur32->wszUserName);
        }

        // Assign the return value
        //
        *ppConnections2 = pConns64;

    } while (FALSE);

    // Cleanup
    //
    {
        if (dwErr != NO_ERROR)
        {
            if (pConns64)
            {
                pFree(pConns64);
            }
        }
    }

    return dwErr;
}        


//
// Convert connection structs from the wire representation to the 
// host representation
//
DWORD
MprThunkConnection_WtoH(
    IN      DWORD   dwLevel,
    IN      LPBYTE  lpbBuffer,
    IN      DWORD   dwBufferSize,
    IN      DWORD   dwCount,
    IN      MprThunk_Allocation_Func pAlloc,
    IN      MprThunk_Free_Func pFree,
    OUT     LPBYTE* lplpbBuffer)
{
    DWORD dwErr = NO_ERROR, i;
    LPBYTE lpbTemp = NULL;

#ifdef _WIN64        

    //
    // Generate the 64 bit host structures based on the 32 bit
    // wire structures.
    //
    switch (dwLevel)
    {
        case 0:
            dwErr = MprThunkConnection_32to64_0(
                        (RASI_CONNECTION_0*)lpbBuffer,
                        dwBufferSize,
                        dwCount,
                        pAlloc,
                        pFree,
                        (RAS_CONNECTION_0**)&lpbTemp);
            *lplpbBuffer = lpbTemp;
            break;

        case 1:
            dwErr = MprThunkConnection_32to64_1(
                        (RASI_CONNECTION_1*)lpbBuffer, 
                        dwBufferSize,
                        dwCount,
                        pAlloc,
                        pFree,
                        (RAS_CONNECTION_1**)&lpbTemp);
            *lplpbBuffer = lpbTemp;
            break;
            
        case 2:
            dwErr = MprThunkConnection_32to64_2(
                        (RASI_CONNECTION_2*)lpbBuffer, 
                        dwBufferSize,
                        dwCount,
                        pAlloc,
                        pFree,
                        (RAS_CONNECTION_2**)&lpbTemp);
            *lplpbBuffer = lpbTemp;
            break;
    }

    // Free the unthunked data
    //
    pFree(lpbBuffer);
    
#else

    // 32 bit -- nothing to do since the structures
    // match
    //
    *lplpbBuffer = lpbBuffer;
    
#endif

    return dwErr;
}

DWORD
MprThunkCredentials_WtoH(
    IN      DWORD dwLevel,
    IN      MPR_CREDENTIALSEXI *pCredsI,
    IN      MprThunk_Allocation_Func pAlloc,
    OUT     PBYTE *lplpbBuffer)
{
    DWORD dwRetCode = NO_ERROR;

    if(NULL == pCredsI)
    {
        dwRetCode = E_INVALIDARG;
        goto done;
    }

    switch(dwLevel)
    {
        case 0:
        case 1:
        case 2:
        {
            //
            // the credentials structure is structurally the
            // same for all levels. We just use the strcuture
            // for level 0 for all cases.
            //
            MPR_CREDENTIALSEX_0 *pCred0 = NULL;
            
            pCred0 = pAlloc(
                          pCredsI->dwSize 
                        + sizeof(MPR_CREDENTIALSEX_0));

            if(NULL == pCred0)
            {
                dwRetCode = GetLastError();
                break;
            }

            pCred0->dwSize = pCredsI->dwSize;
            pCred0->lpbCredentialsInfo = (PBYTE) (pCred0 + 1);
            CopyMemory(
                    pCred0->lpbCredentialsInfo,
                    ((PBYTE) pCredsI) + pCredsI->dwOffset,
                    pCredsI->dwSize);

            *lplpbBuffer = (PBYTE) pCred0;

            break;
        }
        default:
        {
            dwRetCode = E_INVALIDARG;
            break;
        }            
    }

done:
    return dwRetCode;
}
            
DWORD
MprThunkCredentials_HtoW(
    IN      DWORD dwLevel,
    IN      BYTE *pBuffer,
    IN      MprThunk_Allocation_Func pAlloc,
   OUT      DWORD *pdwSize,
   OUT      PBYTE *lplpbBuffer)
{

    DWORD dwRetCode = NO_ERROR;
    MPR_CREDENTIALSEX_0 *pCreds0 = (MPR_CREDENTIALSEX_0 *) pBuffer;

    if(     (NULL == pCreds0)
        ||  (NULL == lplpbBuffer)
        ||  (NULL == pdwSize))
    {
        dwRetCode = E_INVALIDARG;
        goto done;
    }

    if(NULL == pAlloc)
    {
        pAlloc = MprThunkAlloc;
    }

    switch(dwLevel)
    {
        case 0:
        case 1:
        case 2:
        {
            MPR_CREDENTIALSEXI *pCredsI;
            
            //
            // allocate for pCredsI
            //
            *pdwSize = pCreds0->dwSize + sizeof(MPR_CREDENTIALSEXI);
            
            pCredsI = (MPR_CREDENTIALSEXI *) pAlloc(*pdwSize);
                    
            if(NULL == pCredsI)
            {
                dwRetCode = GetLastError();
                break;
            }

            ZeroMemory(pCredsI, *pdwSize);
            pCredsI->dwSize = pCreds0->dwSize;
            pCredsI->dwOffset = FIELD_OFFSET(MPR_CREDENTIALSEXI, bData);
            
            CopyMemory((pCredsI->bData),
                       (PBYTE) pCreds0->lpbCredentialsInfo,
                       pCreds0->dwSize);

            *lplpbBuffer = (BYTE *) pCredsI;                        

            break;                       
        }                   
        default:
        {
            dwRetCode = E_INVALIDARG;
            break;
        }
    }               
    
done:
    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\api.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: api.c
//
// History:
//      Abolade Gbadegesin  July-25-1995    Created
//
// API entry-points for tracing dll
//============================================================================
    
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rtutils.h>
#include <stdlib.h>
#include "trace.h"


#define ENTER_TRACE_API(lpserver)	\
       (((lpserver)!=NULL) && ((lpserver)->TS_StopEvent != NULL))





//
// called before any other functions; responsible for creating
// and initializing a client structure for the caller
// and notifying the server of the new client
//
DWORD
APIENTRY
TraceRegisterEx(
    IN LPCTSTR lpszCallerName,
    IN DWORD dwFlags
    ) {

    DWORD dwErr, dwClientID;
    LPTRACE_SERVER lpserver;
    LPTRACE_CLIENT lpclient, *lplpc, *lplpcstart, *lplpcend;

    lpserver = GET_TRACE_SERVER();
    ASSERTMSG ("Could not create trace server ", lpserver!=NULL);
    if (!lpserver)
        return INVALID_TRACEID;

    TRACE_ACQUIRE_WRITELOCK(lpserver);


    //
    // complete the console thread event creations if not done before
    //
    if (lpserver->TS_TableEvent == NULL) {

        dwErr = TraceCreateServerComplete(lpserver);

        if (dwErr != 0) {
            TRACE_RELEASE_WRITELOCK(lpserver);
            return INVALID_TRACEID;
        }
    }


    
    lpclient = TraceFindClient(lpserver, lpszCallerName);

    if (lpclient != NULL) {

        //
        // client already exists
        //

        TRACE_RELEASE_WRITELOCK(lpserver);

        return lpclient->TC_ClientID;
    }



    //
    // find an empty space
    //

    lplpcstart = lpserver->TS_ClientTable;
    lplpcend = lplpcstart + MAX_CLIENT_COUNT;

    for (lplpc = lplpcstart; lplpc < lplpcend; lplpc++) {

        if (*lplpc == NULL) { break; }
    }


    if (lplpc >= lplpcend) {

        //
        // no space in table
        //

        TRACE_RELEASE_WRITELOCK(lpserver);

        return INVALID_TRACEID;
    }


    //
    // create the new client and enable it
    //

    dwErr = TraceCreateClient(lplpc);


    if (dwErr != 0) {

        //
        // something wrong, so abort
        //
        TRACE_RELEASE_WRITELOCK(lpserver);

        return INVALID_TRACEID;
    }


    lpclient = *lplpc;
    lpclient->TC_ClientID = dwClientID = (DWORD)(lplpc - lplpcstart);

    lstrcpyn(
        lpclient->TC_ClientName, lpszCallerName,
        MAX_CLIENTNAME_LENGTH - 1
        );

    //
    // copy the client name in the other format as well
    //
#ifdef UNICODE
    wcstombs(
        lpclient->TC_ClientNameA, lpclient->TC_ClientNameW,
        MAX_CLIENTNAME_LENGTH - 1
        );
#else
    mbstowcs(
        lpclient->TC_ClientNameW, lpclient->TC_ClientNameA,
        MAX_CLIENTNAME_LENGTH - 1
        );
#endif


    if ((dwFlags & TRACE_USE_FILE) || (dwFlags & TRACE_USE_CONSOLE)) {

        if (dwFlags & TRACE_USE_FILE) {
            lpclient->TC_Flags |= TRACEFLAGS_USEFILE;
        }
        if (dwFlags & TRACE_USE_CONSOLE) {
            lpclient->TC_Flags |= TRACEFLAGS_USECONSOLE;
        }

    }
    else {
        lpclient->TC_Flags |= TRACEFLAGS_REGCONFIG;
    }



    //
    // load client's configuration and open its file
    // and its console buffer if necessary
    //

    dwErr = TraceEnableClient(lpserver, lpclient, TRUE);

    if (dwErr != 0) {

        //
        // something wrong, so abort
        //

        TraceDeleteClient(lpserver, lplpc);


        TRACE_RELEASE_WRITELOCK(lpserver);

        return INVALID_TRACEID;
    }
    

    //
    // Create trace server thread if required
    //
    if (g_serverThread==NULL) {
    
        dwErr = TraceCreateServerThread(dwFlags, TRUE,TRUE); //have lock,check
        
        if (NO_ERROR != dwErr){
            TRACE_RELEASE_WRITELOCK(lpserver);
            return INVALID_TRACEID;
        }
    }

    
    TRACE_RELEASE_WRITELOCK(lpserver);


    //
    // tell server there is a new client in the table
    //
    SetEvent(lpserver->TS_TableEvent);


    return dwClientID;
}


DWORD
APIENTRY
TraceDeregisterEx(
    IN  DWORD   dwTraceID,
    IN  DWORD   dwFlags
    );


//
// called to stop tracing.
// frees client state and notifies server of change
//
DWORD
APIENTRY
TraceDeregister(
    IN DWORD dwTraceID
    ) {

    return TraceDeregisterEx(dwTraceID, 0);
}



DWORD
APIENTRY
TraceDeregisterEx(
    IN  DWORD   dwTraceID,
    IN  DWORD   dwFlags
    ) {

    DWORD dwErr;
    LPTRACE_CLIENT *lplpc;
    LPTRACE_SERVER lpserver;

    if (dwTraceID == INVALID_TRACEID || dwTraceID >= MAX_CLIENT_COUNT) {
        return ERROR_INVALID_PARAMETER;
    }

    lpserver = GET_TRACE_SERVER_NO_INIT ();
    //ASSERTMSG ("Server not initialized ", lpserver);
    if (!ENTER_TRACE_API(lpserver)) { return ERROR_CAN_NOT_COMPLETE; }


    //
    // lock the server, unless the flag says not to.
    //
    if (!(dwFlags & TRACE_NO_SYNCH)) { TRACE_ACQUIRE_WRITELOCK(lpserver); }


    //
    // get the client pointer
    //
    lplpc = lpserver->TS_ClientTable + dwTraceID;
    dwErr = TraceDeleteClient(lpserver, lplpc);

    //
    // reset array for client change notifications.
    // only used if server thread is not created
    //

    if (!g_serverThread) {

        SetWaitArray(lpserver);
    }
    
    if (!(dwFlags & TRACE_NO_SYNCH)) { TRACE_RELEASE_WRITELOCK(lpserver); }


    //
    // tell the server that a client has left
    //
    SetEvent(lpserver->TS_TableEvent);

    return 0;
}



DWORD
APIENTRY
TraceGetConsole(
    IN DWORD dwTraceID,
    OUT LPHANDLE lphConsole
    ) {

    LPTRACE_CLIENT lpclient;
    LPTRACE_SERVER lpserver;

    if (dwTraceID == INVALID_TRACEID || dwTraceID >= MAX_CLIENT_COUNT ||
        lphConsole == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    lpserver = GET_TRACE_SERVER_NO_INIT ();
    ASSERTMSG ("Server not initialized ", lpserver);
    if (!ENTER_TRACE_API(lpserver)) { return ERROR_CAN_NOT_COMPLETE; }

    *lphConsole = NULL;

    TRACE_ACQUIRE_READLOCK(lpserver);

    lpclient = lpserver->TS_ClientTable[dwTraceID];

    if (lpclient == NULL) {

        TRACE_RELEASE_READLOCK(lpserver);
        return ERROR_INVALID_PARAMETER;
    }

    TRACE_ACQUIRE_READLOCK(lpclient);

    *lphConsole = lpclient->TC_Console;

    TRACE_RELEASE_READLOCK(lpclient);

    TRACE_RELEASE_READLOCK(lpserver);

    return 0;
}



DWORD
APIENTRY
TracePrintf(
    IN DWORD dwTraceID,
    IN LPCTSTR lpszFormat,
    IN ... OPTIONAL
    ) {

    DWORD dwSize;
    va_list arglist;

    if (dwTraceID == INVALID_TRACEID || dwTraceID >= MAX_CLIENT_COUNT) {
        return 0;
    }

    CREATE_SERVER_THREAD_IF_REQUIRED();
    
    va_start(arglist, lpszFormat);
    dwSize = TraceVprintfInternal(dwTraceID, 0, lpszFormat, arglist);
    va_end(arglist);

    return dwSize;
}




DWORD
APIENTRY
TracePrintfEx(
    IN DWORD dwTraceID,
    IN DWORD dwFlags,
    IN LPCTSTR lpszFormat,
    IN ... OPTIONAL
    ) {
    DWORD dwSize;
    va_list arglist;

    if (dwTraceID == INVALID_TRACEID || dwTraceID >= MAX_CLIENT_COUNT) {
        return 0;
    }

    CREATE_SERVER_THREAD_IF_REQUIRED();

    va_start(arglist, lpszFormat);
    dwSize = TraceVprintfInternal(dwTraceID, dwFlags, lpszFormat, arglist);
    va_end(arglist);

    return dwSize;
}


DWORD
APIENTRY
TraceVprintfEx(
    IN DWORD dwTraceID,
    IN DWORD dwFlags,
    IN LPCTSTR lpszFormat,
    IN va_list arglist
    ) {

    if (dwTraceID == INVALID_TRACEID || dwTraceID >= MAX_CLIENT_COUNT) {
        return 0;
    }

    CREATE_SERVER_THREAD_IF_REQUIRED();

    return TraceVprintfInternal(dwTraceID, dwFlags, lpszFormat, arglist);
}


DWORD
TraceVprintfInternal(
    IN DWORD dwTraceID,
    IN DWORD dwFlags,
    IN LPCTSTR lpszFormat,
    IN va_list arglist
    ) {
    SYSTEMTIME st;
    DWORD dwThread;
    DWORD dwErr, dwSize;
    LPTRACE_CLIENT lpclient;
    LPTRACE_SERVER lpserver;
    PTCHAR szFormat, szBuffer;

    
    lpserver = GET_TRACE_SERVER_NO_INIT ();
    ASSERTMSG ("Server not initialized ", lpserver);
    if (!ENTER_TRACE_API(lpserver)) { return ERROR_CAN_NOT_COMPLETE; }


    //
    // return quickly if no output will be generated;
    //
    if (dwFlags & TRACE_USE_MASK) {
        if (!(*(lpserver->TS_FlagsCache + dwTraceID) & (dwFlags & 0xffff0000))) {
            return 0;
        }
    }
    else {
        if (!*(lpserver->TS_FlagsCache + dwTraceID)) {
            return 0;
        }
    }

    TRACE_ACQUIRE_READLOCK(lpserver);


    lpclient = lpserver->TS_ClientTable[dwTraceID];

    if (lpclient == NULL) {

        TRACE_RELEASE_READLOCK(lpserver);
        return 0;
    }


    TRACE_ACQUIRE_READLOCK(lpclient);

    if (TRACE_CLIENT_IS_DISABLED(lpclient)) {
        TRACE_RELEASE_READLOCK(lpclient);
        TRACE_RELEASE_READLOCK(lpserver);
        return 0;
    }


    szFormat = (PTCHAR) HeapAlloc(GetProcessHeap(), 0, DEF_PRINT_BUFSIZE);
    if (!szFormat) {
        TRACE_RELEASE_READLOCK(lpclient);
        TRACE_RELEASE_READLOCK(lpserver);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    szBuffer = (PTCHAR) HeapAlloc(GetProcessHeap(), 0, DEF_PRINT_BUFSIZE);
    if (!szBuffer) {
        TRACE_RELEASE_READLOCK(lpclient);
        TRACE_RELEASE_READLOCK(lpserver);
        HeapFree(GetProcessHeap(), 0, szFormat);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // default format for output is
    //    \n<time>:
    //
    if (dwFlags & TRACE_NO_STDINFO) {
        wvsprintf(szBuffer, lpszFormat, arglist);
    }
    else {

        GetLocalTime(&st);

        if ((dwFlags & TRACE_USE_MSEC) == 0) {
            if (dwFlags & TRACE_USE_DATE) {
                wsprintf(
                    szFormat, TEXT("\r\n[%03d] %02u-%02u %02u:%02u:%02u: %s") ,
                    GetCurrentThreadId(), st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond,
                    lpszFormat
                    );
            }
            else {
                wsprintf(
                    szFormat, TEXT("\r\n[%03d] %02u:%02u:%02u: %s") ,
                    GetCurrentThreadId(), st.wHour, st.wMinute, st.wSecond,
                    lpszFormat
                    );
            }
        }
        else {
            if (dwFlags & TRACE_USE_DATE) {
                wsprintf(
                    szFormat, TEXT("\r\n[%03d] %02u-%02u %02u:%02u:%02u:%03u: %s") ,
                    GetCurrentThreadId(), st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond,
                    st.wMilliseconds, lpszFormat
                    );
            }
            else {
                wsprintf(
                    szFormat, TEXT("\r\n[%03d] %02u:%02u:%02u:%03u: %s") ,
                    GetCurrentThreadId(), st.wHour, st.wMinute, st.wSecond,
                    st.wMilliseconds, lpszFormat
                    );
            }
        }

        wvsprintf(szBuffer, szFormat, arglist);
    }

    dwSize = TraceWriteOutput(lpserver, lpclient, dwFlags, szBuffer);

    TRACE_RELEASE_READLOCK(lpclient);

    TRACE_RELEASE_READLOCK(lpserver);

    HeapFree(GetProcessHeap(), 0, szFormat);       
    HeapFree(GetProcessHeap(), 0, szBuffer); 

    return dwSize;
}



DWORD
APIENTRY
TracePutsEx(
    IN DWORD dwTraceID,
    IN DWORD dwFlags,
    IN LPCTSTR lpszString
    ) {

    SYSTEMTIME st;
    DWORD dwErr, dwSize;
    LPTRACE_CLIENT lpclient;
    LPTRACE_SERVER lpserver;
    LPCTSTR lpszOutput;
    PTCHAR szBuffer;


    if (dwTraceID == INVALID_TRACEID || dwTraceID >= MAX_CLIENT_COUNT) {
        return 0;
    }

    lpserver = GET_TRACE_SERVER_NO_INIT ();
    ASSERTMSG ("Server not initialized ", lpserver);

    if (!ENTER_TRACE_API(lpserver)) { return ERROR_CAN_NOT_COMPLETE; }

    CREATE_SERVER_THREAD_IF_REQUIRED();


    //
    // return quickly if no output will be generated;
    //
    if (dwFlags & TRACE_USE_MASK) {
        if (!(*(lpserver->TS_FlagsCache + dwTraceID) & (dwFlags & 0xffff0000))) {
            return 0;
        }
    }
    else {
        if (!*(lpserver->TS_FlagsCache + dwTraceID)) { return 0; }
    }

    TRACE_ACQUIRE_READLOCK(lpserver);

    lpclient = lpserver->TS_ClientTable[dwTraceID];

    if (lpclient == NULL) {

        TRACE_RELEASE_READLOCK(lpserver);
        return 0;
    }


    TRACE_ACQUIRE_READLOCK(lpclient);

    
    if (TRACE_CLIENT_IS_DISABLED(lpclient)) {
        TRACE_RELEASE_READLOCK(lpclient);
        TRACE_RELEASE_READLOCK(lpserver);
        return 0;
    }
    
    szBuffer = (PTCHAR) HeapAlloc(GetProcessHeap(), 0, DEF_PRINT_BUFSIZE);
    if (!szBuffer) {
        TRACE_RELEASE_READLOCK(lpclient);
        TRACE_RELEASE_READLOCK(lpserver);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    if (dwFlags & TRACE_NO_STDINFO) {
        lpszOutput = lpszString;
    }
    else {

        GetLocalTime(&st);

        if ((dwFlags & TRACE_USE_MSEC) == 0) {
            if (dwFlags & TRACE_USE_DATE) {
                wsprintf(
                    szBuffer, TEXT("\r\n[%03d] %02u-%02u %02u:%02u:%02u: %s") ,
                    GetCurrentThreadId(), st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond,
                    lpszString
                    );
            }
            else {
                wsprintf(
                    szBuffer, TEXT("\r\n[%03d] %02u:%02u:%02u: %s"),
                    GetCurrentThreadId(), st.wHour, st.wMinute, st.wSecond,
                    lpszString
                    );
            }
        }
        else {
            if (dwFlags & TRACE_USE_DATE) {
                wsprintf(
                    szBuffer, TEXT("\r\n[%03d] %02u-%02u %02u:%02u:%02u:%03u: %s") ,
                    GetCurrentThreadId(), st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond,
                    st.wMilliseconds, lpszString
                    );
            }
            else {
                wsprintf(
                    szBuffer, TEXT("\r\n[%03d] %02u:%02u:%02u:%03u: %s"),
                    GetCurrentThreadId(), st.wHour, st.wMinute, st.wSecond,
                    st.wMilliseconds, lpszString
                    );
            }
        }
        lpszOutput = szBuffer;
    }

    dwSize = TraceWriteOutput(lpserver, lpclient, dwFlags, lpszOutput);

    HeapFree(GetProcessHeap(), 0, szBuffer); 

    TRACE_RELEASE_READLOCK(lpclient);
    TRACE_RELEASE_READLOCK(lpserver);

    return dwSize;
}



DWORD
APIENTRY
TraceDumpEx(
    IN DWORD dwTraceID,
    IN DWORD dwFlags,
    IN LPBYTE lpbBytes,
    IN DWORD dwByteCount,
    IN DWORD dwGroupSize,
    IN BOOL bAddressPrefix,
    IN LPCTSTR lpszPrefix
    ) {

    SYSTEMTIME st;
    DWORD dwThread;
    LPTRACE_SERVER lpserver;
    LPTRACE_CLIENT lpclient;
    DWORD dwLine, dwBytesOutput;
    TCHAR szPrefix[MAX_CLIENTNAME_LENGTH + 48] = TEXT("");
    BYTE szBuffer[BYTES_PER_DUMPLINE];

    if (dwTraceID == INVALID_TRACEID ||
        dwTraceID >= MAX_CLIENT_COUNT ||
        lpbBytes == NULL ||
        dwByteCount == 0 ||
        (dwGroupSize != 1 && dwGroupSize != 2 && dwGroupSize != 4)
        ) {

        return ERROR_INVALID_PARAMETER;
    }

    lpserver = GET_TRACE_SERVER_NO_INIT ();
    ASSERTMSG ("Server not initialized ", lpserver);

    if (!ENTER_TRACE_API(lpserver)) { return ERROR_CAN_NOT_COMPLETE; }


    CREATE_SERVER_THREAD_IF_REQUIRED();


    //
    // return quickly if no output will be generated;
    //
    if (dwFlags & TRACE_USE_MASK) {
        if (!(*(lpserver->TS_FlagsCache + dwTraceID) & (dwFlags & 0xffff0000))) {
            return 0;
        }
    }
    else {
        if (!*(lpserver->TS_FlagsCache + dwTraceID)) { return 0; }
    }

    TRACE_ACQUIRE_READLOCK(lpserver);

    lpclient = lpserver->TS_ClientTable[dwTraceID];

    if (lpclient == NULL) {

        TRACE_RELEASE_READLOCK(lpserver);
        return 0;
    }


    TRACE_ACQUIRE_READLOCK(lpclient);

    if (TRACE_CLIENT_IS_DISABLED(lpclient)) {
        TRACE_RELEASE_READLOCK(lpclient);
        TRACE_RELEASE_READLOCK(lpserver);
        return 0;
    }

    dwBytesOutput = 0;

    if ((dwFlags & TRACE_NO_STDINFO) == 0) {

        GetLocalTime(&st);

        if ((dwFlags & TRACE_USE_MSEC) == 0) {
            wsprintf(
                szPrefix,
                TEXT("[%03d] %02u:%02u:%02u: "),
                GetCurrentThreadId(), st.wHour, st.wMinute, st.wSecond
                );
        }
        else {
            wsprintf(
                szPrefix,
                TEXT("[%03d] %02u:%02u:%02u:%03u: "),
                GetCurrentThreadId(), st.wHour, st.wMinute, st.wSecond,
                st.wMilliseconds
                );
        }
    }

    if (lpszPrefix != NULL) {
        lstrcat(szPrefix, lpszPrefix);
    }


    //
    // see if the start of the byte buffer is not aligned correctly
    // on a DWORD boundary
    //

    if ((ULONG_PTR)lpbBytes & (dwGroupSize - 1)) {
        DWORD dwPad;

        //
        // it is, so first dump the leading bytes:
        // get size of misalignment, and make certain
        // misalignment size isn't greater than total size
        //

        dwPad = (DWORD) ((ULONG_PTR)lpbBytes & (dwGroupSize - 1));
        dwPad = (dwPad > dwByteCount) ? dwByteCount : dwPad;
        dwLine = BYTES_PER_DUMPLINE;


        //
        // copy the misaligned bytes into the buffer
        //

        ZeroMemory(szBuffer, dwLine);
        CopyMemory(szBuffer + (dwLine - dwPad), lpbBytes, dwPad);


        //
        // now dump the line, but give the helper function a pointer
        // to the byte buffer passed in as an argument
        // to print as the prefix (actually, give it the place
        // in the real byte buffer that it would be dumping from
        // if things weren't misaligned
        //

        dwBytesOutput +=
            TraceDumpLine(
                lpserver, lpclient, dwFlags, szBuffer, dwLine, dwGroupSize,
                bAddressPrefix, 
                (LPBYTE) ((ULONG_PTR)lpbBytes - (dwLine - dwPad)), szPrefix
                );

        (ULONG_PTR)lpbBytes += dwPad;
        dwByteCount -= dwPad;
    }


    //
    // now loop through until we can't print out any more
    //

    dwLine = BYTES_PER_DUMPLINE;

    while (dwByteCount > 0) {

        //
        // there is a line or more left in the buffer
        // no special processing needed
        //

        if (dwByteCount >= BYTES_PER_DUMPLINE) {

            dwBytesOutput +=
                TraceDumpLine(
                    lpserver, lpclient, dwFlags, lpbBytes, dwLine, dwGroupSize,
                    bAddressPrefix, lpbBytes, szPrefix
                    );

            lpbBytes += dwLine;
            dwByteCount -= dwLine;
        }
        else {

            //
            // for the last line, copy the stuff to a buffer and then
            // print that buffer's contents, passing the argument buffer
            // as the address to use as a prefix
            //

            ZeroMemory(szBuffer, dwLine);
            CopyMemory(szBuffer, lpbBytes, dwByteCount);

            dwBytesOutput +=
                TraceDumpLine(
                    lpserver, lpclient, dwFlags, szBuffer, dwLine,
                    dwGroupSize, bAddressPrefix, lpbBytes, szPrefix
                    );

            lpbBytes += dwLine;
            dwByteCount = 0;
        }
    }

    TRACE_RELEASE_READLOCK(lpclient);
    TRACE_RELEASE_READLOCK(lpserver);

    return dwBytesOutput;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\uapi\uapiinit\uapiinit.cpp ===
//+----------------------------------------------------------------------------
//
// File:     uapiinit.cpp
//
// Module:   UAPIINIT (static lib)
//
// Synopsis: This static library wraps up the initialization code needed for a module
//           to use cmutoa.dll.  Calling the InitUnicodeAPI function either sets up
//           the modules U pointers (this library also contains all the U pointer
//           declarations) with the W version of the API if running on NT or the
//           appropriate A or UA API depending on whether conversion is needed before/after
//           calling the windows API or not.  Modules using this lib should include the
//           uapi.h header in their precompiled header and should have cmutoa.dll handy
//           on win9x.  The idea for this library and the associated dll was borrowed
//           from F. Avery Bishop's April 1999 MSJ article "Design a Single Unicode
//           App that Runs on Both Windows 98 and Windows 2000"
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb      Created    4-25-99
//
// History: 
//+----------------------------------------------------------------------------

#include <windows.h>
#include <shlobj.h>
#include "cmdebug.h"
#include "cmutoa.h"

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

UAPI_CallWindowProc CallWindowProcU;
UAPI_CharLower CharLowerU;
UAPI_CharPrev CharPrevU;
UAPI_CharNext CharNextU;
UAPI_CharUpper CharUpperU;
UAPI_CreateDialogParam CreateDialogParamU;
UAPI_CreateDirectory CreateDirectoryU;
UAPI_CreateEvent CreateEventU;
UAPI_CreateFile CreateFileU;
UAPI_CreateFileMapping CreateFileMappingU;
UAPI_CreateMutex CreateMutexU;
UAPI_CreateProcess CreateProcessU;
UAPI_CreateWindowEx CreateWindowExU;
UAPI_DefWindowProc DefWindowProcU;
UAPI_DeleteFile DeleteFileU;
UAPI_DialogBoxParam DialogBoxParamU;
UAPI_DispatchMessage DispatchMessageU;
UAPI_ExpandEnvironmentStrings ExpandEnvironmentStringsU;
UAPI_FindResourceEx FindResourceExU;
UAPI_FindWindowEx FindWindowExU;
UAPI_GetClassLong GetClassLongU;
UAPI_GetDateFormat GetDateFormatU;
UAPI_GetDlgItemText GetDlgItemTextU;
UAPI_GetFileAttributes GetFileAttributesU;
UAPI_GetMessage GetMessageU;
UAPI_GetModuleFileName GetModuleFileNameU;
UAPI_GetModuleHandle GetModuleHandleU;
UAPI_GetPrivateProfileInt GetPrivateProfileIntU;
UAPI_GetPrivateProfileString GetPrivateProfileStringU;
UAPI_GetStringTypeEx GetStringTypeExU;
UAPI_GetSystemDirectory GetSystemDirectoryU;
UAPI_GetTempFileName GetTempFileNameU;
UAPI_GetTempPath GetTempPathU;
UAPI_GetTimeFormat GetTimeFormatU;
UAPI_GetUserName GetUserNameU;
UAPI_GetVersionEx GetVersionExU;
UAPI_GetWindowLong GetWindowLongU;
UAPI_GetWindowText GetWindowTextU;
UAPI_GetWindowTextLength GetWindowTextLengthU;
UAPI_InsertMenu InsertMenuU;
UAPI_IsDialogMessage IsDialogMessageU;
UAPI_LoadCursor LoadCursorU;
UAPI_LoadIcon LoadIconU;
UAPI_LoadImage LoadImageU;
UAPI_LoadLibraryEx LoadLibraryExU;
UAPI_LoadMenu LoadMenuU;
UAPI_LoadString LoadStringU;
UAPI_lstrcat lstrcatU;
UAPI_lstrcmp lstrcmpU;
UAPI_lstrcmpi lstrcmpiU;
UAPI_lstrcpy lstrcpyU;
UAPI_lstrcpyn lstrcpynU;
UAPI_lstrlen lstrlenU;
UAPI_OpenEvent OpenEventU;
UAPI_OpenFileMapping OpenFileMappingU;
UAPI_PeekMessage PeekMessageU;
UAPI_PostMessage PostMessageU;
UAPI_PostThreadMessage PostThreadMessageU;
UAPI_RegCreateKeyEx RegCreateKeyExU;
UAPI_RegDeleteKey RegDeleteKeyU;
UAPI_RegDeleteValue RegDeleteValueU;
UAPI_RegEnumKeyEx RegEnumKeyExU;
UAPI_RegisterClassEx RegisterClassExU;
UAPI_RegisterWindowMessage RegisterWindowMessageU;
UAPI_RegOpenKeyEx RegOpenKeyExU;
UAPI_RegQueryValueEx RegQueryValueExU;
UAPI_RegSetValueEx RegSetValueExU;
UAPI_SearchPath SearchPathU;
UAPI_SendDlgItemMessage SendDlgItemMessageU;
UAPI_SendMessage SendMessageU;
UAPI_SetCurrentDirectory SetCurrentDirectoryU;
UAPI_SetDlgItemText SetDlgItemTextU;
UAPI_SetWindowLong SetWindowLongU;
UAPI_SetWindowText SetWindowTextU;
UAPI_UnregisterClass UnregisterClassU;
UAPI_WinHelp WinHelpU;
UAPI_wsprintf wsprintfU;
UAPI_WritePrivateProfileString WritePrivateProfileStringU;
UAPI_wvsprintf wvsprintfU;

//+----------------------------------------------------------------------------
//
// Function:  CheckUAPIFunctionPointers
//
// Synopsis:  Checks all of the xxxU function pointers to ensure that they are
//            non-NULL.  Will catch a function load failure.
//
// Arguments: None
//
// Returns:   BOOL - TRUE on success
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL CheckUAPIFunctionPointers()
{
    return (CallWindowProcU &&
            CharLowerU &&
            CharPrevU &&
            CharNextU &&
            CharUpperU &&
            CreateDialogParamU &&
            CreateDirectoryU &&
            CreateEventU &&
            CreateFileU &&
            CreateFileMappingU &&
            CreateMutexU &&
            CreateProcessU &&
            CreateWindowExU &&
            DefWindowProcU &&
            DeleteFileU &&
            DialogBoxParamU &&
            DispatchMessageU &&
            ExpandEnvironmentStringsU &&
            FindResourceExU &&
            FindWindowExU &&
            GetClassLongU &&
            GetDateFormatU &&
            GetDlgItemTextU &&
            GetFileAttributesU &&
            GetMessageU &&
            GetModuleFileNameU &&
            GetModuleHandleU &&
            GetPrivateProfileIntU &&
            GetPrivateProfileStringU &&
            GetStringTypeExU &&
            GetSystemDirectoryU &&
            GetTempFileNameU &&
            GetTempPathU &&
            GetTimeFormatU &&
            GetUserNameU &&
            GetVersionExU &&
            GetWindowLongU &&
            GetWindowTextU &&
            GetWindowTextLengthU &&
            InsertMenuU &&
            IsDialogMessageU &&
            LoadCursorU &&
            LoadIconU &&
            LoadImageU &&
            LoadLibraryExU &&
            LoadMenuU &&
            LoadStringU &&
            lstrcatU &&
            lstrcmpU &&
            lstrcmpiU &&
            lstrcpyU &&
            lstrcpynU &&
            lstrlenU &&
            OpenEventU &&
            OpenFileMappingU &&
            PeekMessageU &&
            PostMessageU &&
            PostThreadMessageU &&
            RegCreateKeyExU &&
            RegDeleteKeyU &&
            RegDeleteValueU &&
            RegEnumKeyExU &&
            RegisterClassExU &&
            RegisterWindowMessageU &&
            RegOpenKeyExU &&
            RegQueryValueExU &&
            RegSetValueExU &&
            SearchPathU && 
            SendDlgItemMessageU &&
            SendMessageU &&
            SetCurrentDirectoryU &&
            SetDlgItemTextU &&
            SetWindowLongU &&
            SetWindowTextU &&
            UnregisterClassU &&
            WinHelpU &&
            wsprintfU &&
            WritePrivateProfileStringU &&
            wvsprintfU);
}

//+----------------------------------------------------------------------------
//
// Function:  InitUnicodeAPI
//
// Synopsis:  Initializes the Unicode wrapper APIs.  Thus on Windows NT we will
//            use the native Unicode (xxxW) form of the API and on Win9x we
//            will use the UA form located in cmutoa.dll.  This prevents have
//            a wrapper function to call through on the NT platforms were it is
//            really unneccesary.
//
// Arguments: None
//
// Returns:   BOOL - TRUE on success
//
// History:   quintinb Created    6/24/99
//
//+----------------------------------------------------------------------------
BOOL InitUnicodeAPI()
{
    OSVERSIONINFO Osv;
    BOOL IsWindowsNT;
    HMODULE hCmUtoADll = NULL;


    Osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO) ;

    if(!GetVersionEx(&Osv))
    {
        return FALSE ;
    }

    IsWindowsNT = (BOOL) (Osv.dwPlatformId == VER_PLATFORM_WIN32_NT) ;

// define this symbol in UAPI.H to emulate Windows 9x when testing on Windows NT.
#ifdef EMULATE9X
    IsWindowsNT = FALSE;
#endif

    if(IsWindowsNT)
    {
        CallWindowProcU = CallWindowProcW;
        CharLowerU = CharLowerW;
        CharPrevU = CharPrevW;
        CharNextU = CharNextW;
        CharUpperU = CharUpperW;
        CreateDialogParamU = CreateDialogParamW;
        CreateDirectoryU = CreateDirectoryW;
        CreateEventU = CreateEventW;
        CreateFileU = CreateFileW;
        CreateFileMappingU = CreateFileMappingW;
        CreateMutexU = CreateMutexW;
        CreateProcessU = CreateProcessW;
        CreateWindowExU = CreateWindowExW;
        DefWindowProcU = DefWindowProcW;
        DeleteFileU = DeleteFileW;
        DialogBoxParamU = DialogBoxParamW;
        DispatchMessageU = DispatchMessageW;
        ExpandEnvironmentStringsU = ExpandEnvironmentStringsW;
        FindResourceExU = FindResourceExW;
        FindWindowExU = FindWindowExW;
        GetClassLongU = GetClassLongW;
        GetDateFormatU = GetDateFormatW;
        GetDlgItemTextU = GetDlgItemTextW;
        GetFileAttributesU = GetFileAttributesW;
        GetMessageU = GetMessageW;
        GetModuleFileNameU = GetModuleFileNameW;
        GetModuleHandleU = GetModuleHandleW;
        GetPrivateProfileIntU = GetPrivateProfileIntW;
        GetPrivateProfileStringU = GetPrivateProfileStringW;
        GetStringTypeExU = GetStringTypeExW;
        GetSystemDirectoryU = GetSystemDirectoryW;
        GetTempFileNameU = GetTempFileNameW;
        GetTempPathU = GetTempPathW;
        GetTimeFormatU = GetTimeFormatW;
        GetUserNameU = GetUserNameW;
        GetVersionExU = GetVersionExW;
        GetWindowLongU = GetWindowLongPtrW;
        GetWindowTextU = GetWindowTextW;
        GetWindowTextLengthU = GetWindowTextLengthW;
        InsertMenuU = InsertMenuW;
        IsDialogMessageU = IsDialogMessageW;
        LoadCursorU = LoadCursorW;
        LoadIconU = LoadIconW;
        LoadImageU = LoadImageW;
        LoadLibraryExU = LoadLibraryExW;
        LoadMenuU = LoadMenuW;
        LoadStringU = LoadStringW;
        lstrcatU = lstrcatW;
        lstrcmpU = lstrcmpW;
        lstrcmpiU = lstrcmpiW;
        lstrcpyU = lstrcpyW;
        lstrcpynU = lstrcpynW;
        lstrlenU = lstrlenW;
        OpenEventU = OpenEventW;
        OpenFileMappingU = OpenFileMappingW;
        PeekMessageU = PeekMessageW;
        PostMessageU = PostMessageW;
        PostThreadMessageU = PostThreadMessageW;
        RegCreateKeyExU = RegCreateKeyExW;
        RegDeleteKeyU = RegDeleteKeyW;
        RegDeleteValueU = RegDeleteValueW;
        RegEnumKeyExU = RegEnumKeyExW;
        RegisterClassExU = RegisterClassExW;
        RegisterWindowMessageU = RegisterWindowMessageW;
        RegOpenKeyExU = RegOpenKeyExW;
        RegQueryValueExU = RegQueryValueExW;
        RegSetValueExU = RegSetValueExW;
        SearchPathU = SearchPathW;
        SendDlgItemMessageU = SendDlgItemMessageW;
        SendMessageU = SendMessageW;
        SetCurrentDirectoryU = SetCurrentDirectoryW;
        SetDlgItemTextU = SetDlgItemTextW;
        SetWindowLongU = SetWindowLongPtrW;
        SetWindowTextU = SetWindowTextW;
        UnregisterClassU = UnregisterClassW;
        WinHelpU = WinHelpW;
        wsprintfU = wsprintfW;
        WritePrivateProfileStringU = WritePrivateProfileStringW;
        wvsprintfU = wvsprintfW;
    }
    else
    {
        BOOL (*InitCmUToA)(PUAPIINIT);
        UAPIINIT UAInit;

        ZeroMemory(&UAInit, sizeof(UAPIINIT));

        hCmUtoADll = LoadLibraryExA("cmutoa.DLL", NULL, 0);

        if(!hCmUtoADll)
        {       
            DWORD dwError = GetLastError();
            CMASSERTMSG(FALSE, TEXT("InitUnicodeAPI -- Cmutoa.dll Failed to Load."));
            return FALSE;
        }

        // Get Initialization routine from the DLL
        InitCmUToA = (BOOL (*)(PUAPIINIT)) GetProcAddress(hCmUtoADll, "InitCmUToA") ;

        // Set up structure containing locations of U function pointers
        UAInit.pCallWindowProcU = &CallWindowProcU;
        UAInit.pCharLowerU = &CharLowerU;
        UAInit.pCharPrevU = &CharPrevU;
        UAInit.pCharNextU = &CharNextU;
        UAInit.pCharUpperU = &CharUpperU;
        UAInit.pCreateDialogParamU = &CreateDialogParamU;
        UAInit.pCreateDirectoryU = &CreateDirectoryU;
        UAInit.pCreateEventU = &CreateEventU;
        UAInit.pCreateFileU = &CreateFileU;
        UAInit.pCreateFileMappingU = &CreateFileMappingU;
        UAInit.pCreateMutexU = &CreateMutexU;
        UAInit.pCreateProcessU = &CreateProcessU;
        UAInit.pCreateWindowExU = &CreateWindowExU;
        UAInit.pDefWindowProcU = &DefWindowProcU;
        UAInit.pDeleteFileU = &DeleteFileU;
        UAInit.pDialogBoxParamU = &DialogBoxParamU;
        UAInit.pDispatchMessageU = &DispatchMessageU;
        UAInit.pExpandEnvironmentStringsU = &ExpandEnvironmentStringsU;
        UAInit.pFindResourceExU = &FindResourceExU;
        UAInit.pFindWindowExU = &FindWindowExU;
        UAInit.pGetClassLongU = &GetClassLongU;
        UAInit.pGetDateFormatU = &GetDateFormatU;
        UAInit.pGetDlgItemTextU = &GetDlgItemTextU;
        UAInit.pGetFileAttributesU = &GetFileAttributesU;
        UAInit.pGetMessageU = &GetMessageU;
        UAInit.pGetModuleFileNameU = &GetModuleFileNameU;
        UAInit.pGetModuleHandleU = &GetModuleHandleU;
        UAInit.pGetPrivateProfileIntU = &GetPrivateProfileIntU;
        UAInit.pGetPrivateProfileStringU = &GetPrivateProfileStringU;
        UAInit.pGetStringTypeExU = &GetStringTypeExU;
        UAInit.pGetSystemDirectoryU = &GetSystemDirectoryU;
        UAInit.pGetTempFileNameU = &GetTempFileNameU;
        UAInit.pGetTempPathU = &GetTempPathU;
        UAInit.pGetTimeFormatU = &GetTimeFormatU;
        UAInit.pGetUserNameU = &GetUserNameU;
        UAInit.pGetVersionExU = &GetVersionExU;
        UAInit.pGetWindowLongU = &GetWindowLongU;
        UAInit.pGetWindowTextU = &GetWindowTextU;
        UAInit.pGetWindowTextLengthU = &GetWindowTextLengthU;
        UAInit.pInsertMenuU = &InsertMenuU;
        UAInit.pIsDialogMessageU = &IsDialogMessageU;
        UAInit.pLoadCursorU = &LoadCursorU;
        UAInit.pLoadIconU = &LoadIconU;
        UAInit.pLoadImageU = &LoadImageU;
        UAInit.pLoadLibraryExU = &LoadLibraryExU;
        UAInit.pLoadMenuU = &LoadMenuU;
        UAInit.pLoadStringU = &LoadStringU;
        UAInit.plstrcatU = &lstrcatU;
        UAInit.plstrcmpU = &lstrcmpU;
        UAInit.plstrcmpiU = &lstrcmpiU;
        UAInit.plstrcpyU = &lstrcpyU;
        UAInit.plstrcpynU = &lstrcpynU;
        UAInit.plstrlenU = &lstrlenU;
        UAInit.pOpenEventU = &OpenEventU;
        UAInit.pOpenFileMappingU = &OpenFileMappingU;
        UAInit.pPeekMessageU = &PeekMessageU;
        UAInit.pPostMessageU = &PostMessageU;
        UAInit.pPostThreadMessageU = &PostThreadMessageU;
        UAInit.pRegCreateKeyExU = &RegCreateKeyExU;
        UAInit.pRegDeleteKeyU = &RegDeleteKeyU;
        UAInit.pRegDeleteValueU = &RegDeleteValueU;
        UAInit.pRegEnumKeyExU = &RegEnumKeyExU;
        UAInit.pRegisterClassExU = &RegisterClassExU;
        UAInit.pRegisterWindowMessageU = &RegisterWindowMessageU;
        UAInit.pRegOpenKeyExU = &RegOpenKeyExU;
        UAInit.pRegQueryValueExU = &RegQueryValueExU;
        UAInit.pRegSetValueExU = &RegSetValueExU;
        UAInit.pSearchPathU = &SearchPathU;
        UAInit.pSendDlgItemMessageU = &SendDlgItemMessageU;
        UAInit.pSendMessageU = &SendMessageU;
        UAInit.pSetCurrentDirectoryU = &SetCurrentDirectoryU;
        UAInit.pSetDlgItemTextU = &SetDlgItemTextU;
        UAInit.pSetWindowLongU = &SetWindowLongU;
        UAInit.pSetWindowTextU = &SetWindowTextU;
        UAInit.pUnregisterClassU = &UnregisterClassU;
        UAInit.pWinHelpU = &WinHelpU;
        UAInit.pwsprintfU = &wsprintfU;
        UAInit.pWritePrivateProfileStringU = &WritePrivateProfileStringU;
        UAInit.pwvsprintfU = &wvsprintfU;

        if( NULL == InitCmUToA || !InitCmUToA(&UAInit)) 
        {
            CMASSERTMSG(FALSE, TEXT("InitUnicodeAPI -- Unable to find InitCmUToA or InitCmUToA Failed."));
            FreeLibrary(hCmUtoADll);
            return FALSE;
        }

        for (int i = 0; i < (sizeof(UAPIINIT) / sizeof(LPVOID)); i++)
        {
            if (UAInit.ppvUapiFun[i])
            {
                if (NULL == *(UAInit.ppvUapiFun[i]))
                {
                    CMTRACE1(TEXT("Unable to fill UAInit[%d].  Please Investigate"), i);
                }
            }
            else
            {
                CMTRACE1(TEXT("No Memory for UAInit[%d].  Please Investigate"), i);
            }
        }
    }

    if(!CheckUAPIFunctionPointers()) 
    {
        CMASSERTMSG(FALSE, TEXT("InitUnicodeAPI -- CheckUAPIFunctionPointers failed."));
        FreeLibrary(hCmUtoADll);
        return FALSE;
    }

    return TRUE ;
}

//+----------------------------------------------------------------------------
//
// Function:  UnInitUnicodeAPI
//
// Synopsis:  De-Initializes the Unicode wrapper APIs.  See InitUnicodeAPI for
//            details.  Primarily, this function frees the module handle(s).
//
// Arguments: None
//
// Returns:   BOOL - TRUE on success
//
// History:   sumitc   Created    7/01/2000
//
//+----------------------------------------------------------------------------
BOOL UnInitUnicodeAPI()
{
    OSVERSIONINFO Osv;
    BOOL IsWindowsNT;

    Osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO) ;

    if(!GetVersionEx(&Osv))
    {
        return FALSE ;
    }

    IsWindowsNT = (BOOL) (Osv.dwPlatformId == VER_PLATFORM_WIN32_NT) ;

// define this symbol in UAPI.H to emulate Windows 9x when testing on Windows NT.
#ifdef EMULATE9X
    IsWindowsNT = FALSE;
#endif

    if(!IsWindowsNT)
    {
        HMODULE hCmUtoADll;

        hCmUtoADll = GetModuleHandleA("cmutoa.DLL");

        if (!hCmUtoADll)
        {
            CMTRACE(TEXT("UnInitUnicodeAPI - strange.. cmutoa.dll is not loaded into the process!"));
            return FALSE;
        }

        FreeLibrary(hCmUtoADll);
    }

    return TRUE;
}


#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\client_w.c ===
#include "unicode.h"
#include "client.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\assert.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    assert.c
//
// History:
//  Abolade Gbadegesin  Nov-19-1995  Created.
//
// Contains Assert functio for Router components.
//============================================================================


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rtutils.h>




VOID
RouterAssert(
    IN PSTR pszFailedAssertion,
    IN PSTR pszFileName,
    IN DWORD dwLineNumber,
    IN PSTR pszMessage OPTIONAL
    ) {

    CHAR szResponse[2];

    while (TRUE) {
        DbgPrint(
            "\n***Assertion failed: %s%s\n*** Source File: %s, line %ld\n\n",
            pszMessage ? pszMessage : "",
            pszFailedAssertion,
            pszFileName,
            dwLineNumber
            );

        DbgPrompt(
            "Break, Ignore, Terminate Process or Terminate Thread (bipt)? ",
            szResponse,
            sizeof(szResponse)
            );

        switch (szResponse[0]) {
            case 'B':
            case 'b':
                DbgBreakPoint();
                break;

            case 'I':
            case 'i':
                return;

            case 'P':
            case 'p':
                TerminateProcess(
                    GetCurrentProcess(), (DWORD)STATUS_UNSUCCESSFUL
                    );
                break;

            case 'T':
            case 't':
                TerminateThread(
                    GetCurrentThread(), (DWORD)STATUS_UNSUCCESSFUL
                    );
                break;
        }
    }

    DbgBreakPoint();
    TerminateProcess(GetCurrentProcess(), (DWORD)STATUS_UNSUCCESSFUL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\profwiz\wiz_str.h ===
//+----------------------------------------------------------------------------
//
// File:     wiz_str.h
//
// Module:   CMAK.EXE
//
// Synopsis: Header file for profwiz specific strings
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   nickball   Created      10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_WIZ_STR
#define _CM_WIZ_STR

const TCHAR* const c_pszTargetFileVersion   = TEXT("TargetFileVersion");
const TCHAR* const c_pszOptions             = TEXT("Options");
const TCHAR* const c_pszFriendlyName        = TEXT("FriendlyName");
const TCHAR* const c_pszInfVersion          = TEXT("InfVersion");
const TCHAR* const c_pszIncludeCmCode       = TEXT("IncludeCMCode");
const TCHAR* const c_pszUpdatePhonebook     = TEXT("UpdatePhonebook");
const TCHAR* const c_pszCmProxy             = TEXT("CmProxy");
const TCHAR* const c_pszUsePwdCache         = TEXT("UsePWDcache");
const TCHAR* const c_pszPhoneName           = TEXT("PhoneName");
const TCHAR* const c_pszLicenseFile         = TEXT("LicenseFile");
const TCHAR* const c_pszTargetName          = TEXT("TargetName");
const TCHAR* const c_pszUninstallAppTitle   = TEXT("UninstallAppTitle");
const TCHAR* const c_pszAppLaunched         = TEXT("AppLaunched");
const TCHAR* const c_pszDisplayLicense      = TEXT("DisplayLicense");
const TCHAR* const c_pszLcid                = TEXT("LCID");
const TCHAR* const c_pszCpsUrl              = TEXT("/pbserver/pbserver.dll");
const TCHAR* const c_pszIncludeSupportDll   = TEXT("IncludeSupportDll");
const TCHAR* const c_pszDesktopIcon         = TEXT("DesktopIcon");
const TCHAR* const c_pszInfBeginPrompt      = TEXT("BeginPrompt");
const TCHAR* const c_pszInfEndPrompt        = TEXT("EndPrompt");
const TCHAR* const c_pszAppCaption          = TEXT("Microsoft Connection Manager Administration Kit");
const TCHAR* const c_pszExtraFiles          = TEXT("Extra Files");
const TCHAR* const c_pszMergeProfiles       = TEXT("Merge Profiles");
const TCHAR* const c_pszOne                 = TEXT("1");
const TCHAR* const c_pszZero                = TEXT("0");
const TCHAR* const c_pszWildCard            = TEXT("*.*");
const TCHAR* const c_pszTemplateInf         = TEXT("template.inf");
const TCHAR* const c_pszTemplateSed         = TEXT("template.sed");
const TCHAR* const c_pszTemplateCms         = TEXT("template.cms");
const TCHAR* const c_pszTemplateCmp         = TEXT("template.cmp");
const TCHAR* const c_pszProfiles            = TEXT("Profiles");
const TCHAR* const c_pszSupport             = TEXT("Support");
const TCHAR* const c_pszCmakExe             = TEXT("cmak.exe");
const TCHAR* const c_pszIntl                = TEXT("Intl");
const TCHAR* const c_pszDisplay             = TEXT("Display");
const TCHAR* const c_pszTcpIpFmtStr         = TEXT("TCP/IP&%s");
const TCHAR* const c_pszScriptingFmtStr     = TEXT("Scripting&%s");
const TCHAR* const c_pszServerFmtStr        = TEXT("Server&%s");
const TCHAR* const c_pszNetworkingFmtStr    = TEXT("Networking&%s");
const TCHAR* const c_pszCmLCID              = TEXT("CmLCID");
const TCHAR* const c_pszDisplayLCID         = TEXT("DisplayLCID");
const TCHAR* const c_pszInstallPrompt       = TEXT("InstallPrompt");

//
//  Route plumbing switches
//
const TCHAR* const c_pszStaticFileNameSwitch = TEXT("/STATIC_FILE_NAME");
const TCHAR* const c_pszUrlPathSwitch = TEXT("/URL_UPDATE_PATH");
const TCHAR* const c_pszDontRequireUrlSwitch = TEXT("/DONT_REQUIRE_URL");

//
//  CmProxy switches
//
const TCHAR* const c_pszSourceFileNameSwitch = TEXT("/source_filename");
const TCHAR* const c_pszDialRasEntrySwitch = TEXT("/DialRasEntry");
const TCHAR* const c_pszTunnelRasEntrySwitch = TEXT("/TunnelRasEntry");
const TCHAR* const c_pszProfileSwitch = TEXT("/Profile");
const TCHAR* const c_pszBackupFileNameSwitch = TEXT("/backup_filename");


#endif // _CM_WIZ_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\config.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    config.c
//
// History:
//      t-abolag    7/22/95     Created.
//
// contains client configuration functions for tracing dll
//============================================================================


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <rtutils.h>
#include "trace.h"


//----------------------------------------------------------------------------
// Function:            TraceEnableClient
//
// Parameters:
//      LPTRACE_CLIENT *lpclient
//      BOOL            bFirstTime
//
// This function is called when a client first registers,
// every time a client is re-enabled after having been disabled,
// and every time a client's settings change.
// it assumes the client specified has been locked for writing
// and thus that the server is locked for writing
//----------------------------------------------------------------------------
DWORD
TraceEnableClient(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient,
    BOOL bFirstTime
    ) {


    DWORD dwErr, dwOldFlags, dwCache;

    // enable by clearing disabled flag
    lpclient->TC_Flags &= ~TRACEFLAGS_DISABLED;

    dwCache = 0;
    dwOldFlags = lpclient->TC_Flags;


    //
    // if the client uses registry settings, load them
    //
    if (TRACE_CLIENT_USES_REGISTRY(lpclient)) {

        dwErr = TraceRegConfigClient(lpclient, bFirstTime);
        if (dwErr != 0) { return dwErr; }
    }


    //
    // if console tracing enabled and client had no console buffer
    // open a console buffer for the client
    //
    if (TRACE_CLIENT_USES_CONSOLE(lpclient)) {

        //
        // open the console only if it wasn't already open
        //
        if (bFirstTime || (dwOldFlags & TRACEFLAGS_USECONSOLE) == 0) {
            TraceOpenClientConsole(lpserver, lpclient);
        }

        dwCache |= (lpclient->TC_ConsoleMask | TRACEFLAGS_USECONSOLE);
    }
    else {

        //
        // console isn't enabled; if it WAS enabled,
        // close the old console
        //
        if (!bFirstTime && (dwOldFlags & TRACEFLAGS_USECONSOLE)) {

            //
            // used to use the console, 
            // the buffer handle should be closed and active buffer
            // set to be someone else
            //
            TraceCloseClientConsole(lpserver, lpclient);
        }
    }


    //
    // if this client was using a file, close it even if
    // file tracing is still enabled for the client.
    // the path of the tracing file may have been changed
    //
    if (!bFirstTime && (dwOldFlags & TRACEFLAGS_USEFILE)) {
        TraceCloseClientFile(lpclient);
    }


    //
    // if file tracing enabled open the client's tracing file
    //
    if (TRACE_CLIENT_USES_FILE(lpclient)) {
        TraceCreateClientFile(lpclient);
        dwCache |= (lpclient->TC_FileMask | TRACEFLAGS_USEFILE);
    }

    InterlockedExchange(
        lpserver->TS_FlagsCache + lpclient->TC_ClientID, dwCache
        );

    return 0;
}



//----------------------------------------------------------------------------
// Function:            TraceDisableClient
//
// Parameters:
//      LPTRACE_CLIENT *lpclient
//
// This function is called when a client is disabled
// it assumes the client specified has been locked for writing
//----------------------------------------------------------------------------
DWORD
TraceDisableClient(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient
    ) {

    // disable by setting the disabled flag
    lpclient->TC_Flags |= TRACEFLAGS_DISABLED;

    InterlockedExchange(lpserver->TS_FlagsCache + lpclient->TC_ClientID, 0);

    return 0;
}



//----------------------------------------------------------------------------
// Function:            TraceRegConfigClient
//
// Parameters:
//      LPTRACE_CLIENT *lpclient
//      BOOL            bFirstTime
//
// This function loads the client's tracing configuration
// for the registry under
//  Software
//      \\Microsoft
//               \\Tracing
//                  \\<client_name>
//                          EnableFileTracing       REG_DWORD
//                          EnableConsoleTracing    REG_DWORD
//                          MaxFileSize             REG_DWORD
//                          FileDirectory           REG_EXPAND_SZ
//----------------------------------------------------------------------------
DWORD
TraceRegConfigClient(
    LPTRACE_CLIENT lpclient,
    BOOL bFirstTime
    ) {

    HKEY hkeyTracing;
    TCHAR szTracing[MAX_PATH];
    TCHAR szFileDir[MAX_PATH];
    DWORD dwErr, dwType, dwValue, dwSize;

    if (bFirstTime) {
        lstrcpy(szTracing, REGKEY_TRACING);
        lstrcat(szTracing, STR_DIRSEP);
        lstrcat(szTracing, lpclient->TC_ClientName);
    
        //
        // open the registry key for the client
        //
        dwErr = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE, szTracing, 0, KEY_READ, &hkeyTracing
                    );

        //
        // if that failed, try to create it
        //
        if (dwErr != ERROR_SUCCESS) {

            dwErr = TraceRegCreateDefaults(szTracing, &hkeyTracing);

            if (dwErr != ERROR_SUCCESS) {
                lpclient->TC_ConfigKey = NULL;
                return dwErr;
            }
        }

        lpclient->TC_ConfigKey = hkeyTracing;
    }
    else {
        hkeyTracing = lpclient->TC_ConfigKey;
    }



    //
    // read the file-tracing flag 
    //
    dwSize = sizeof(DWORD);
    dwErr = RegQueryValueEx(
                hkeyTracing, REGVAL_ENABLEFILETRACING, NULL,
                &dwType, (LPBYTE)&dwValue, &dwSize
                );

    if (dwErr != ERROR_SUCCESS || dwType != REG_DWORD) {
        dwValue = DEF_ENABLEFILETRACING;
    }


    if (dwValue != 0) { lpclient->TC_Flags |= TRACEFLAGS_USEFILE; }
    else { lpclient->TC_Flags &= ~TRACEFLAGS_USEFILE; }


    //
    // read the file-tracing mask
    //
    dwSize = sizeof(DWORD);
    dwErr = RegQueryValueEx(
                hkeyTracing, REGVAL_FILETRACINGMASK, NULL,
                &dwType, (LPBYTE)&dwValue, &dwSize
                );
    if (dwErr != ERROR_SUCCESS || dwType != REG_DWORD) {
        dwValue = DEF_FILETRACINGMASK;
    }

    lpclient->TC_FileMask = (dwValue & 0xffff0000);


    //
    // read the console-tracing flag
    //
    dwSize = sizeof(DWORD);
    dwErr = RegQueryValueEx(
                hkeyTracing, REGVAL_ENABLECONSOLETRACING, NULL,
                &dwType, (LPBYTE)&dwValue, &dwSize
                );
    if (dwErr != ERROR_SUCCESS || dwType != REG_DWORD) {
        dwValue = DEF_ENABLECONSOLETRACING;
    }

    if (dwValue != 0) { lpclient->TC_Flags |= TRACEFLAGS_USECONSOLE; }
    else { lpclient->TC_Flags &= ~TRACEFLAGS_USECONSOLE; }



    //
    // read the console-tracing mask
    //
    dwSize = sizeof(DWORD);
    dwErr = RegQueryValueEx(
                hkeyTracing, REGVAL_CONSOLETRACINGMASK, NULL,
                &dwType, (LPBYTE)&dwValue, &dwSize
                );
    if (dwErr != ERROR_SUCCESS || dwType != REG_DWORD) {
        dwValue = DEF_CONSOLETRACINGMASK;
    }

    lpclient->TC_ConsoleMask = (dwValue & 0xffff0000);


    //
    // read the maximum file size
    //
    dwSize = sizeof(DWORD);
    dwErr = RegQueryValueEx(
                hkeyTracing, REGVAL_MAXFILESIZE, NULL,
                &dwType, (LPBYTE)&dwValue, &dwSize
                );
    if (dwErr != ERROR_SUCCESS || dwType != REG_DWORD) {
        dwValue = DEF_MAXFILESIZE;
    }

    lpclient->TC_MaxFileSize = dwValue;


    //
    // read the tracing file directory
    //
    dwSize = MAX_PATH * sizeof(TCHAR);
    dwErr = RegQueryValueEx(hkeyTracing, REGVAL_FILEDIRECTORY,
                            NULL, &dwType, (LPBYTE)szFileDir, &dwSize);
    if (dwErr != ERROR_SUCCESS ||
        (dwType != REG_EXPAND_SZ && dwType != REG_SZ)) {
        lstrcpy(szFileDir, DEF_FILEDIRECTORY);
    }

    ExpandEnvironmentStrings(szFileDir, lpclient->TC_FileDir, MAX_PATH);

#ifdef UNICODE
    wcstombs(
        lpclient->TC_FileDirA, lpclient->TC_FileDirW,
        lstrlenW(lpclient->TC_FileDirW) + 1
        );
#else
    mbstowcs(
        lpclient->TC_FileDirW, lpclient->TC_FileDirA,
        lstrlenA(lpclient->TC_FileDirA) + 1
        );
#endif


    //
    // request registry change notification
    //
    if (lpclient->TC_ConfigEvent == NULL) {
        lpclient->TC_ConfigEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    }

    dwErr = RegNotifyChangeKeyValue(
                lpclient->TC_ConfigKey, FALSE,
                REG_NOTIFY_CHANGE_ATTRIBUTES |
                REG_NOTIFY_CHANGE_LAST_SET | 
                REG_NOTIFY_CHANGE_SECURITY,
                lpclient->TC_ConfigEvent, TRUE
                );

    return 0;
}


DWORD
TraceRegCreateDefaults(
    LPCTSTR lpszTracing,
    PHKEY phkeyTracing
    ) {

    DWORD dwSize, dwValue;
    DWORD dwErr, dwDisposition;
    TCHAR szFileDir[MAX_PATH];

    //
    // create \\Microsoft\\Tracing
    //
    dwErr = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE, REGKEY_TRACING, 0, NULL,
                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                phkeyTracing, &dwDisposition
                );

    RegCloseKey(*phkeyTracing);


    //
    // create \\Microsoft\\Tracing
    //
    dwErr = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE, lpszTracing, 0, NULL,
                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                phkeyTracing, &dwDisposition
                );
    if (dwErr != ERROR_SUCCESS) { return dwErr; }



    dwSize = sizeof(DWORD);

    dwValue = DEF_ENABLEFILETRACING;
    dwErr = RegSetValueEx(
                *phkeyTracing, REGVAL_ENABLEFILETRACING, 0,
                REG_DWORD, (LPBYTE)&dwValue, dwSize
                );

    dwValue = DEF_ENABLECONSOLETRACING;
    dwErr = RegSetValueEx(
                *phkeyTracing, REGVAL_ENABLECONSOLETRACING, 0,
                REG_DWORD, (LPBYTE)&dwValue, dwSize
                );

    dwValue = DEF_FILETRACINGMASK;
    dwErr = RegSetValueEx(
                *phkeyTracing, REGVAL_FILETRACINGMASK, 0,
                REG_DWORD, (LPBYTE)&dwValue, dwSize
                );

    dwValue = DEF_CONSOLETRACINGMASK;
    dwErr = RegSetValueEx(
                *phkeyTracing, REGVAL_CONSOLETRACINGMASK, 0,
                REG_DWORD, (LPBYTE)&dwValue, dwSize
                );

    dwValue = DEF_MAXFILESIZE;
    dwErr = RegSetValueEx(
                *phkeyTracing, REGVAL_MAXFILESIZE, 0,
                REG_DWORD, (LPBYTE)&dwValue, dwSize
                );

    lstrcpy(szFileDir, DEF_FILEDIRECTORY);
    dwSize = lstrlen(szFileDir) * sizeof(TCHAR);
    dwErr = RegSetValueEx(
                *phkeyTracing, REGVAL_FILEDIRECTORY, 0,
                REG_EXPAND_SZ, (LPBYTE)&szFileDir, dwSize
                );

    return ERROR_SUCCESS;
}



//
// assumes client is locked for reading
//
DWORD
TraceUpdateConsoleTitle(
    LPTRACE_CLIENT lpclient
    ) {

    TCHAR szTitle[MAX_PATH];
    if (TRACE_CLIENT_IS_DISABLED(lpclient)) {
        wsprintf(szTitle, TEXT("%s [Tracing Inactive]"),
                 lpclient->TC_ClientName);
    }
    else {
        wsprintf(szTitle, TEXT("%s [Tracing Active]"), lpclient->TC_ClientName);
    }

    SetConsoleTitle(szTitle);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\config_w.c ===
#include "unicode.h"
#include "config.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\event_w.c ===
#include "unicode.h"
#include "event.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\client.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: client.c
//
// History:
//      Abolade Gbadegesin  July-25-1995    Created
//
// Client struct routines and I/O routines for tracing dll
//============================================================================


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <rtutils.h>

#include "trace.h"


//
// assumes server is locked for writing
//
DWORD
TraceCreateClient(
    LPTRACE_CLIENT *lplpclient
    ) {

    DWORD dwErr;
    LPTRACE_CLIENT lpclient;

    lpclient = HeapAlloc(GetProcessHeap(), 0, sizeof(TRACE_CLIENT));

    if (lpclient == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY; 
    }

    
    //
    // initialize fields in the client structure
    //

    lpclient->TC_ClientID = MAX_CLIENT_COUNT;
    lpclient->TC_Flags = 0;
    lpclient->TC_File = NULL;
    lpclient->TC_Console = NULL;
    lpclient->TC_ConfigKey = NULL;
    lpclient->TC_ConfigEvent = NULL;
    lpclient->TC_MaxFileSize = DEF_MAXFILESIZE;

    ZeroMemory(lpclient->TC_ClientNameA, MAX_CLIENTNAME_LENGTH * sizeof(CHAR));
    ZeroMemory(lpclient->TC_ClientNameW, MAX_CLIENTNAME_LENGTH * sizeof(WCHAR));


    lstrcpy(lpclient->TC_FileDir, DEF_FILEDIRECTORY);

#ifdef UNICODE
    wcstombs(
        lpclient->TC_FileDirA, lpclient->TC_FileDirW,
        lstrlenW(lpclient->TC_FileDirW) + 1
        );
#else
    mbstowcs(
        lpclient->TC_FileDirW, lpclient->TC_FileDirA,
        lstrlenA(lpclient->TC_FileDirA) + 1
        );
#endif

    __try {
        TRACE_STARTUP_LOCKING(lpclient);
        dwErr = NO_ERROR;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        dwErr = GetExceptionCode();
        HeapFree(GetProcessHeap(), 0, lpclient);
        lpclient = NULL;
    }

    InterlockedExchangePointer(lplpclient, lpclient);

    return dwErr;
}



//
// assumes server is locked for writing and client is locked for writing
//
DWORD
TraceDeleteClient(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT *lplpclient
    ) {

    LPTRACE_CLIENT lpclient;

    if (lplpclient == NULL || *lplpclient == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    lpclient = *lplpclient;

    InterlockedExchangePointer(lplpclient, NULL);

    InterlockedExchange(lpserver->TS_FlagsCache + lpclient->TC_ClientID, 0);

    TRACE_CLEANUP_LOCKING(lpclient);


    //
    // closing this key will cause the event to be signalled
    // however, we hold the lock on the table so the server thread
    // will be blocked until the cleanup completes
    //
    if (lpclient->TC_ConfigKey != NULL) {
        RegCloseKey(lpclient->TC_ConfigKey);
    }

    if (lpclient->TC_ConfigEvent != NULL) {
        CloseHandle(lpclient->TC_ConfigEvent);
    }

    if (TRACE_CLIENT_USES_CONSOLE(lpclient)) {
        TraceCloseClientConsole(lpserver, lpclient);
    }

    if (TRACE_CLIENT_USES_FILE(lpclient)) {
        TraceCloseClientFile(lpclient);
    }

    HeapFree(GetProcessHeap(), 0, lpclient);

    return 0;
}



//
// assumes server is locked for reading or for writing
//
LPTRACE_CLIENT
TraceFindClient(
    LPTRACE_SERVER lpserver,
    LPCTSTR lpszClient
    ) {

    DWORD dwClient;
    LPTRACE_CLIENT *lplpc, *lplpcstart, *lplpcend;

    lplpcstart = lpserver->TS_ClientTable;
    lplpcend = lplpcstart + MAX_CLIENT_COUNT;

    for (lplpc = lplpcstart; lplpc < lplpcend; lplpc++) {
        if (*lplpc != NULL &&
            lstrcmp((*lplpc)->TC_ClientName, lpszClient) == 0) {
            break;
        }
    }

    return (lplpc < lplpcend) ? *lplpc : NULL;
}



//
// assumes that the server is locked for writing,
// and that the client is locked for writing
// also assumes the client is not already a console client
//
DWORD TraceOpenClientConsole(LPTRACE_SERVER lpserver,
                             LPTRACE_CLIENT lpclient) {
    DWORD dwErr;
    COORD screen;
    HANDLE hConsole;


    //
    // if all console tracing is disabled, do nothing
    //
    if ((lpserver->TS_Flags & TRACEFLAGS_USECONSOLE) == 0) {
        return 0;
    }


    //
    // create the console if it isn't already created
    //
    if (lpserver->TS_Console == NULL) {
        COORD screen;

        //
        // allocate a console and set the buffer size
        //

        AllocConsole();

        lpserver->TS_Console = GetStdHandle(STD_INPUT_HANDLE);

        if (lpserver->TS_Console == INVALID_HANDLE_VALUE ) 
            return GetLastError();
    }


    //
    // allocate a console for this client
    //
    hConsole = CreateConsoleScreenBuffer(
                    GENERIC_READ | GENERIC_WRITE, 0, NULL,
                    CONSOLE_TEXTMODE_BUFFER, NULL
                    );
    if (hConsole == INVALID_HANDLE_VALUE) { return GetLastError(); }


    //
    // set the buffer to the standard size
    // and save the console buffer handle
    //
    screen.X = DEF_SCREENBUF_WIDTH;
    screen.Y = DEF_SCREENBUF_HEIGHT;
    SetConsoleScreenBufferSize(hConsole, screen);

    lpclient->TC_Console = hConsole;


    //
    // see if there was a previous console client;
    // if not, set this new one's screen buffer to be
    // the active screen buffer
    //
    if (lpserver->TS_ConsoleOwner == MAX_CLIENT_COUNT) {
        TraceUpdateConsoleOwner(lpserver, 1);
    }

    return 0;
}



//
// assumes that the server is locked for writing,
// and that the client is locked for writing
// also assumes the client is already a console client
//
DWORD
TraceCloseClientConsole(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient
    ) {

    HANDLE hConsole;

    //
    // if all console tracing is disabled, do nothing
    //
    if ((lpserver->TS_Flags & TRACEFLAGS_USECONSOLE) == 0) {
        return 0;
    }


    //
    // close the client's screen buffer and associated handles
    //
    if (lpclient->TC_Console != NULL) {

        CloseHandle(lpclient->TC_Console);
        lpclient->TC_Console = NULL;
    }
    


    //
    // if the client owned the screen, find another owner
    //
    if (lpserver->TS_ConsoleOwner == lpclient->TC_ClientID) {

        TraceUpdateConsoleOwner(lpserver, 1);
    }


    //
    // if no owner was found, free the server's console
    //
    if (lpserver->TS_ConsoleOwner == MAX_CLIENT_COUNT ||
        lpserver->TS_ConsoleOwner == lpclient->TC_ClientID) {


        lpserver->TS_ConsoleOwner = MAX_CLIENT_COUNT;

        CloseHandle(lpserver->TS_Console);

        lpserver->TS_Console = NULL;

        FreeConsole();
    }

    return 0;
}



//
// assumes that the server is locked for reading or writing
// and that the client is locked for writing
//
DWORD
TraceCreateClientFile(
    LPTRACE_CLIENT lpclient
    ) {

    DWORD dwErr;
    HANDLE hFile;
    LPOVERLAPPED lpovl;
    TCHAR szFilename[MAX_PATH];


    //
    // create the directory in case it doesn't exist
    //
    CreateDirectory(lpclient->TC_FileDir, NULL);


    //
    // figure out the file name
    //
    lstrcpy(szFilename, lpclient->TC_FileDir);
    lstrcat(szFilename, STR_DIRSEP);
    lstrcat(szFilename, lpclient->TC_ClientName);
    lstrcat(szFilename, STR_LOGEXT);
    

    //
    // open the file, disabling write sharing
    //
    hFile = CreateFile(
                szFilename, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ,
                NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL
                );

    if (hFile == INVALID_HANDLE_VALUE) {
        return GetLastError();
    }

    SetFilePointer(hFile, 0, NULL, FILE_END);

    lpclient->TC_File = hFile;


    return 0;
}



//
// assumes that the server is locked for reading or writing
// and that the client is locked for writing
//
DWORD
TraceMoveClientFile(
    LPTRACE_CLIENT lpclient
    ) {

    TCHAR szDestname[MAX_PATH], szSrcname[MAX_PATH];


    lstrcpy(szSrcname, lpclient->TC_FileDir);
    lstrcat(szSrcname, STR_DIRSEP);
    lstrcat(szSrcname, lpclient->TC_ClientName);
    lstrcpy(szDestname, szSrcname);
    lstrcat(szSrcname, STR_LOGEXT);
    lstrcat(szDestname, STR_OLDEXT);


    //
    // close the file handle if it is open
    //
    TraceCloseClientFile(lpclient);


    //
    // do the move
    //
    MoveFileEx(
        szSrcname, szDestname,
        MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED
        );


    //
    // re-open the log file
    //
    return TraceCreateClientFile(lpclient);
}



//
// assumes that the server is locked for reading or writing
// and that the client is locked for writing
//
DWORD
TraceCloseClientFile(
    LPTRACE_CLIENT lpclient
    ) {

    if (lpclient->TC_File != NULL) {
        CloseHandle(lpclient->TC_File);
        lpclient->TC_File = NULL;
    }

    return 0;
}



//
// assumes that the server is locked for reading or writing
// and that the client is locked for reading 
//
DWORD
TraceWriteOutput(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient,
    DWORD dwFlags,
    LPCTSTR lpszOutput
    ) {

    BOOL bSuccess;
    DWORD dwFileMask, dwConsoleMask;
    DWORD dwErr, dwFileSize, dwBytesToWrite, dwBytesWritten, dwChars;

    dwBytesWritten = 0;
    dwBytesToWrite = lstrlen(lpszOutput) * sizeof(TCHAR);


    dwFileMask = dwConsoleMask = 1;


    // 
    // if the client uses output masking, compute the mask for this message
    //

    if (dwFlags & TRACE_USE_MASK) {
        dwFileMask = (dwFlags & lpclient->TC_FileMask);
        dwConsoleMask = (dwFlags & lpclient->TC_ConsoleMask);
    }


    if (TRACE_CLIENT_USES_FILE(lpclient) &&
        dwFileMask != 0 && lpclient->TC_File != NULL) {

        //
        // check the size of the file to see if it needs renaming
        //

        dwFileSize = GetFileSize(lpclient->TC_File, NULL);


        if ((dwFileSize + dwBytesToWrite) > lpclient->TC_MaxFileSize) {

            TRACE_READ_TO_WRITELOCK(lpclient);


            //
            // move the existing file over and start with an empty one
            //

            dwErr = TraceMoveClientFile(lpclient);
            if (dwErr!=NO_ERROR)
                return dwErr;

            dwFileSize = 0;

            TRACE_WRITE_TO_READLOCK(lpclient);
        }
    
    
        //
        // perform the write operation
        //
        bSuccess =
            WriteFile(
                lpclient->TC_File, lpszOutput, dwBytesToWrite,
                &dwBytesWritten, NULL
                );

    }


    if (TRACE_CLIENT_USES_CONSOLE(lpclient) &&
        dwConsoleMask != 0 && lpclient->TC_Console != NULL) {
        
        //
        // write to the console directly; this is less costly
        // than writing to a file, which is fortunate since we
        // cannot use completion ports with console handles
        //

        dwChars = dwBytesToWrite / sizeof(TCHAR);

        bSuccess =
            WriteConsole(
                lpclient->TC_Console, lpszOutput, dwChars, &dwChars, NULL
                );

    }

    return dwBytesWritten;
}



//----------------------------------------------------------------------------
// Function:            TraceDumpLine
//
// Parameters:
//      LPTRACE_CLIENT  lpclient    pointer to client struct for caller
//      LPBYTE          lpbBytes    address of buffer to dump
//      DWORD           dwLine      length of line in bytes
//      DWORD           dwGroup     size of byte groupings
//      BOOL            bPrefixAddr if TRUE, prefix lines with addresses
//      LPBYTE          lpbPrefix   address with which to prefix lines
//      LPTSTR          lpszPrefix  optional string with which to prefix lines
//----------------------------------------------------------------------------
DWORD
TraceDumpLine(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient,
    DWORD dwFlags,
    LPBYTE lpbBytes,
    DWORD dwLine,
    DWORD dwGroup,
    BOOL bPrefixAddr,
    LPBYTE lpbPrefix,
    LPCTSTR lpszPrefix
    ) {

    INT offset;
    LPTSTR lpszHex, lpszAscii;
    TCHAR szBuffer[256] = TEXT("\r\n");
    TCHAR szAscii[BYTES_PER_DUMPLINE + 2] = TEXT("");
    TCHAR szHex[(3 * BYTES_PER_DUMPLINE) + 1] = TEXT("");
    TCHAR szDigits[] = TEXT("0123456789ABCDEF");


    //
    // prepend prefix string if necessary
    //

    if (lpszPrefix != NULL) {
        lstrcat(szBuffer, lpszPrefix);
    }


    //
    // prepend address if needed
    //
    if (bPrefixAddr) {

        LPTSTR lpsz;
        ULONG_PTR ulpAddress = (ULONG_PTR) lpbPrefix;
        ULONG  i;

        
        //
        // each line prints out a hex-digit
        // with the most-significant digit leftmost in the string
        // prepend address to lpsz[1]..lpsz[2*sizeof(ULONG_PTR)]
        //
        
        lpsz = szBuffer + lstrlen(szBuffer);

        for (i=0;  i<2*sizeof(ULONG_PTR);  i++) {

            lpsz[2*sizeof(ULONG_PTR)-i] = szDigits[ulpAddress & 0x0F];

            ulpAddress >>= 4;
        }

        lpsz[2*sizeof(ULONG_PTR) + 1] = TEXT(':');
        lpsz[2*sizeof(ULONG_PTR) + 2] = TEXT(' ');
        lpsz[2*sizeof(ULONG_PTR) + 3] = TEXT('\0');
    }

    lpszHex = szHex;
    lpszAscii = szAscii;


    //
    // rather than test the size of the grouping every time through
    // a loop, have a loop for each group size
    //
    switch(dwGroup) {

        //
        // single byte groupings
        //
        case 1: {
            while (dwLine >= sizeof(BYTE)) {

                //
                // print hex digits
                //
                *lpszHex++ = szDigits[*lpbBytes / 16];
                *lpszHex++ = szDigits[*lpbBytes % 16];
                *lpszHex++ = TEXT(' ');

                //
                // print ascii characters
                //
                *lpszAscii++ =
                    (*lpbBytes >= 0x20 && *lpbBytes < 0x80) ? *lpbBytes
                                                            : TEXT('.');

                ++lpbBytes;
                --dwLine;
            }
            break;
        }


        //
        // word-sized groupings
        //
        case 2: {
            WORD wBytes;
            BYTE loByte, hiByte;

            //
            // should already be aligned on a word boundary
            //
            while (dwLine >= sizeof(WORD)) {

                wBytes = *(LPWORD)lpbBytes;

                loByte = LOBYTE(wBytes);
                hiByte = HIBYTE(wBytes);

                // print hex digits
                *lpszHex++ = szDigits[hiByte / 16];
                *lpszHex++ = szDigits[hiByte % 16];
                *lpszHex++ = szDigits[loByte / 16];
                *lpszHex++ = szDigits[loByte % 16];
                *lpszHex++ = TEXT(' ');

                // print ascii characters
                *lpszAscii++ =
                    (hiByte >= 0x20 && hiByte < 0x80) ? hiByte : TEXT('.');
                *lpszAscii++ =
                    (loByte >= 0x20 && loByte < 0x80) ? loByte : TEXT('.');

                dwLine -= sizeof(WORD);
                lpbBytes += sizeof(WORD);
            }
            break;
        }

        //
        // double-word sized groupings
        //
        case 4: {
            DWORD dwBytes;
            BYTE loloByte, lohiByte, hiloByte, hihiByte;

            //
            // should already be aligned on a double-word boundary
            //
            while (dwLine >= sizeof(DWORD)) {

                dwBytes = *(LPDWORD)lpbBytes;

                hihiByte = HIBYTE(HIWORD(dwBytes));
                lohiByte = LOBYTE(HIWORD(dwBytes));
                hiloByte = HIBYTE(LOWORD(dwBytes));
                loloByte = LOBYTE(LOWORD(dwBytes));

                // print hex digits
                *lpszHex++ = szDigits[hihiByte / 16];
                *lpszHex++ = szDigits[hihiByte % 16];
                *lpszHex++ = szDigits[lohiByte / 16];
                *lpszHex++ = szDigits[lohiByte % 16];
                *lpszHex++ = szDigits[hiloByte / 16];
                *lpszHex++ = szDigits[hiloByte % 16];
                *lpszHex++ = szDigits[loloByte / 16];
                *lpszHex++ = szDigits[loloByte % 16];
                *lpszHex++ = TEXT(' ');

                // print ascii characters
                *lpszAscii++ =
                    (hihiByte >= 0x20 && hihiByte < 0x80) ? hihiByte
                                                          : TEXT('.');
                *lpszAscii++ =
                    (lohiByte >= 0x20 && lohiByte < 0x80) ? lohiByte
                                                          : TEXT('.');
                *lpszAscii++ =
                    (hiloByte >= 0x20 && hiloByte < 0x80) ? hiloByte
                                                          : TEXT('.');
                *lpszAscii++ =
                    (loloByte >= 0x20 && loloByte < 0x80) ? loloByte
                                                          : TEXT('.');

                // on to the next double-word
                dwLine -= sizeof(DWORD);
                lpbBytes += sizeof(DWORD);
            }
            break;
        }
        default:
            break;
    }

    *lpszHex = *lpszAscii = TEXT('\0');
    lstrcat(szBuffer, szHex);
    lstrcat(szBuffer, TEXT("|"));
    lstrcat(szBuffer, szAscii);
    lstrcat(szBuffer, TEXT("|"));

    return TraceWriteOutput(lpserver, lpclient, dwFlags, szBuffer);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\log.h ===
#define WTLOG_BASE                           40000

#define WTLOG_INIT_CRITSEC_FAILED            (WTLOG_BASE + 1)
/*
 * WT was unable to initialize a critical section.
 * The data is the exception code.
 */

#define WTLOG_CREATE_EVENT_FAILED            (WTLOG_BASE + 2)
/*
 * WT was unable to create an event.
 * The data is the error code.
 */
 
#define WTLOG_HEAP_CREATE_FAILED             (WTLOG_BASE + 3)
/*
 * WT was unable to create a heap.
 * The data is the error code.
 */

#define WTLOG_HEAP_ALLOC_FAILED              (WTLOG_BASE + 4)
/*
 * WT was unable to allocate memory from its heap.
 * The data is the error code.
 */

#define WTLOG_WSASTARTUP_FAILED              (WTLOG_BASE + 5)
/*
 * WT was unable to start Windows Sockets.
 * The data is the error code.
 */

#define WTLOG_CREATE_WAITABLE_TIMER_FAILED 	 (WTLOG_BASE + 6)
/*
 * WT was unable to create waitable timer.
 * The data is the error code.
 */ 

 #define WTLOG_ERROR_DETECTED 	             (WTLOG_BASE + 7)
/*
 * Some Error Detected.
 * The data is the error code.
 */ 

 #define WTLOG_WSA_RECV_FROM_FAILED	         (WTLOG_BASE + 8)
/*
 * WSARecvFrom failed in AsyncWSARecvFrom.
 * The data is the error code.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\makefile.inc ===
$(O)\wtmsg.mc:    .\log.h
    mapmsg NET WTLOG_BASE .\log.h > $(O)\wtmsg.mc

$(O)\wtmsg.h $(O)\msg00001.bin:    $(O)\wtmsg.mc
    mc -v $(O)\wtmsg.mc -h .\$(O) -r .\$(O)

$(O)\wt.rc: $(O)\msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\ibase.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    ibase.c
//
// History:
//  Abolade Gbadegesin  Oct-27-1995 Created.
//
// Contains utility for manipulating InfoBase and InfoBlock structures.
//============================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <iprtinfo.h>
#include <rtutils.h>


typedef InfoBase INFOBASE, *PINFOBASE;
typedef InfoBlock INFOBLOCK, *PINFOBLOCK;


DWORD
APIENTRY
InfoBaseAlloc(
    IN DWORD dwVersion,
    OUT PBYTE *ppInfoBase
    ) {

    DWORD dwErr;
    PINFOBASE pbase;

    if (ppInfoBase == NULL) { return ERROR_INVALID_PARAMETER; }

    pbase = (PINFOBASE)HeapAlloc(GetProcessHeap(), 0, sizeof(InfoBase));

    if (pbase == NULL) {
        dwErr = GetLastError();
    }
    else {

        pbase->IB_Version = dwVersion;
        pbase->IB_NumInfoBlocks = 0;

        dwErr = NO_ERROR;
    }

    *ppInfoBase = (PBYTE)pbase;

    return dwErr;
}


DWORD
APIENTRY
InfoBaseFree(
    IN PBYTE pInfoBase
    ) {

    HeapFree(GetProcessHeap(), 0, pInfoBase);
    return NO_ERROR;
}


DWORD
APIENTRY
InfoBaseGetSize(
    IN PBYTE pInfoBase
    ) {

    PINFOBASE pbase;
    PINFOBLOCK pblock;

    if (pInfoBase == NULL) { return 0; }

    pbase = (PINFOBASE)pInfoBase;

    if (pbase->IB_NumInfoBlocks == 0) {

        return sizeof(InfoBase) - sizeof(InfoBlock);
    }


    pblock = pbase->IB_InfoBlock + (pbase->IB_NumInfoBlocks - 1);

    return pblock->IB_Size + pblock->IB_StartOffset;
}



DWORD
APIENTRY
InfoBaseSet(
    IN DWORD dwInfoType,
    IN PBYTE pOldInfoBase,
    IN PBYTE pNewInfoBlock,
    IN PBYTE pNewInfoData,
    OUT PBYTE *ppNewInfoBase
    ) {

    INT i, j;
    PBYTE pOldData, pNewData;
    PINFOBASE pOldBase, pNewBase;
    PINFOBLOCK pOldBlock, pNewBlock;
    DWORD dwErr, dwOldSize, dwNewSize, dwOffset;

    if (pOldInfoBase == NULL || ppNewInfoBase == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppNewInfoBase = NULL;

    pOldBase = (PINFOBASE)pOldInfoBase;
    pNewBlock = (PINFOBLOCK)pNewInfoBlock;
    pNewData = pNewInfoData;

    do {

        //
        // get a pointer to the existing block if one exists
        //

        dwErr = InfoBaseGet(
                    dwInfoType,
                    pOldInfoBase,
                    (PBYTE *)&pOldBlock,
                    &pOldData
                    );
    
        //
        // get the size of the old infobase
        // and adjust to find the new size
        //

        dwNewSize = dwOldSize = InfoBaseGetSize(pOldInfoBase);

        if (pOldBlock != NULL) {
            dwNewSize -= pOldBlock->IB_Size;
        }

        if (pNewBlock != NULL) {
            dwNewSize += pNewBlock->IB_Size;
        }


        pNewBase = (PINFOBASE)HeapAlloc(GetProcessHeap(), 0, dwNewSize);

        if (pNewBase == NULL) {

            dwErr = GetLastError();
            break;
        }

        //
        // initialize the allocated infobase
        //

        pNewBase->IB_Version = pOldBase->IB_Version;
        pNewBase->IB_NumInfoBlocks = 0;


        //
        // copy the infoblocks to the new base, skipping the one being set;
        //

        dwOffset = sizeof(INFOBASE) - sizeof(INFOBLOCK) +
                   (pNewBase->IB_NumInfoBlocks - 1) * sizeof(INFOBLOCK);

        for (i = 0, j = 0; i < (INT)pOldBase->IB_NumInfoBlocks; i++) {

            if ((pOldBase->IB_InfoBlock + i) == pOldBlock) {
                continue;
            }

            pNewBase->IB_InfoBlock[j] = pOldBase->IB_InfoBlock[i];
            pNewBase->IB_InfoBlock[j].IB_StartOffset = dwOffset;

            RtlCopyMemory(
                (PBYTE)pNewBase + dwOffset,
                (PBYTE)pOldBase + pOldBase->IB_InfoBlock[i].IB_StartOffset,
                pOldBase->IB_InfoBlock[i].IB_Size
                );

            ++pNewBase->IB_NumInfoBlocks;
            dwOffset += pOldBase->IB_InfoBlock[i].IB_Size;
            ++j;
        }


        //
        // if a block was provided for the infotype being set, append it
        //

        if (pNewBlock != NULL) {

            pNewBase->IB_InfoBlock[j] = *pNewBlock;
            pNewBase->IB_InfoBlock[j].IB_StartOffset = dwOffset;

            RtlCopyMemory(
                (PBYTE)pNewBase + dwOffset,
                pNewData,
                pNewBlock->IB_Size
                );

            ++pNewBase->IB_NumInfoBlocks;
        }


        //
        // save the new infobase
        //

        *ppNewInfoBase = (PBYTE)pNewBase;
        dwErr = NO_ERROR;

    } while(FALSE);


    return dwErr;
}




DWORD
APIENTRY
InfoBaseGet(
    IN DWORD dwInfoType,
    IN PBYTE pInfoBase,
    OUT PBYTE *ppInfoBlock,
    OUT PBYTE *ppInfoData
    ) {

    DWORD dwErr;
    PINFOBASE pbase;
    PINFOBLOCK pblock, pblockend;

    if (ppInfoBlock != NULL) { *ppInfoBlock = NULL; }
    if (ppInfoData != NULL) { *ppInfoData = NULL; }

    if (pInfoBase == NULL) { return ERROR_INVALID_PARAMETER; }

    pbase = (PINFOBASE)pInfoBase;
    pblock = pbase->IB_InfoBlock;
    pblockend = pblock + pbase->IB_NumInfoBlocks;


    dwErr = ERROR_NO_DATA;

    for ( ; pblock < pblockend; pblock++) {

        if (pblock->IB_InfoType == dwInfoType) {

            if (ppInfoBlock != NULL) {
                *ppInfoBlock = (PBYTE)pblock;
            }
            if (ppInfoData != NULL) {
                *ppInfoData = (PBYTE)pbase + pblock->IB_StartOffset;
            }

            dwErr = NO_ERROR;
            break;
        }
    }

    return dwErr;
}



DWORD
APIENTRY
InfoBaseGetFirst(
    IN PBYTE pInfoBase,
    OUT PBYTE *ppFirstInfoBlock,
    OUT PBYTE *ppFirstInfoData
    ) {

    DWORD dwErr;
    PINFOBASE pbase;
    PINFOBLOCK pblock;

    if (ppFirstInfoBlock != NULL) { *ppFirstInfoBlock = NULL; }
    if (ppFirstInfoData != NULL) { *ppFirstInfoData = NULL; }

    if (pInfoBase == NULL) { return ERROR_INVALID_PARAMETER; }

    pbase = (PINFOBASE)pInfoBase;

    if (pbase->IB_NumInfoBlocks == 0) {
        dwErr = ERROR_NO_MORE_ITEMS;
    }
    else {

        pblock = pbase->IB_InfoBlock;

        if (ppFirstInfoBlock != NULL) {
            *ppFirstInfoBlock = (PBYTE)pblock;
        }
        if (ppFirstInfoData != NULL) {
            *ppFirstInfoData = (PBYTE)pbase + pblock->IB_StartOffset;
        }

        dwErr = NO_ERROR;
    }

    return dwErr;
}



DWORD
APIENTRY
InfoBaseGetNext(
    IN PBYTE pInfoBase,
    IN PBYTE pInfoBlock,
    OUT PBYTE *ppNextInfoBlock,
    OUT PBYTE *ppNextInfoData
    ) {

    PINFOBASE pbase;
    PINFOBLOCK pblock;
    DWORD dwErr, dwNext;

    if (ppNextInfoBlock != NULL) { *ppNextInfoBlock = NULL; }
    if (ppNextInfoData != NULL) { *ppNextInfoData = NULL; }

    if (pInfoBase == NULL || pInfoBlock == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    pbase = (PINFOBASE)pInfoBase;
    pblock = pbase->IB_InfoBlock;

    dwNext = ((PINFOBLOCK)pInfoBlock - pblock) + 1;

    if (dwNext >= pbase->IB_NumInfoBlocks) {
        dwErr = ERROR_NO_MORE_ITEMS;
    }
    else {

        pblock += dwNext;

        if (ppNextInfoBlock != NULL) {
            *ppNextInfoBlock = (PBYTE)pblock;
        }
        if (ppNextInfoData != NULL) {
            *ppNextInfoData = (PBYTE)pbase + pblock->IB_StartOffset;
        }

        dwErr = NO_ERROR;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\event.c ===
/********************************************************************/
/**		  Copyright(c) 1992 Microsoft Corporation.	   **/
/********************************************************************/

//
//
// Filename:	event.c
//
// Description: 
//
// History:
//		August 26,1992.	Stefan Solomon	    Created original version.
//      August 27,1995. Abolade Gbadegesin  Modified to support Unicode.
//                                          See trace.h for notes on how
//                                          this file is used to support
//                                          both ANSI and Unicode.
//
//


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#include <tchar.h>
#include <stdio.h>
#include <nb30.h>
#include <lmcons.h>
#include <rtutils.h>
#include <mprapi.h>
#include <raserror.h>
#include <mprerror.h>
#include <mprlog.h>


#define ROUTER_SERVICE RRAS_SERVICE_NAME

HINSTANCE g_hDll;

#if defined(UNICODE) || defined(_UNICODE)

#define STRING_NULL             UNICODE_NULL

#define UNICODE_STRING_TAG      L'S'
#define ANSI_STRING_TAG         L's'
#define TCHAR_STRING_TAG        L't'
#define DECIMAL_TAG             L'd'
#define IPADDRESS_TAG           L'I'

#else

#define STRING_NULL             '\0'

#define UNICODE_STRING_TAG      'S'
#define ANSI_STRING_TAG         's'
#define TCHAR_STRING_TAG        't'
#define DECIMAL_TAG             'd'
#define IPADDRESS_TAG           'I'

#endif

#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

//
//
// Function:	LogError
//
// Descr:
//
//

VOID
APIENTRY
LogError(
    IN DWORD    dwMessageId,
    IN DWORD    cNumberOfSubStrings,
    IN LPTSTR   *plpszSubStrings,
    IN DWORD    dwErrorCode
) {
    HANDLE 	hLog;
    PSID 	pSidUser = NULL;

    hLog = RegisterEventSource(NULL, ROUTER_SERVICE );

    if ( dwErrorCode == NO_ERROR ) 
    {
        //
        // No error codes were specified
        //

	    ReportEvent( hLog,
                     EVENTLOG_ERROR_TYPE,
                     0,            		// event category
                     dwMessageId,
                     pSidUser,
                     (WORD)cNumberOfSubStrings,
                     0,
                     plpszSubStrings,
                     (PVOID)NULL
                   );

    }
    else 
    {
        //
        // Log the error code specified
        //

	    ReportEvent( hLog,
                     EVENTLOG_ERROR_TYPE,
                     0,            		// event category
                     dwMessageId,
                     pSidUser,
                     (WORD)cNumberOfSubStrings,
                     sizeof(DWORD),
                     plpszSubStrings,
                     (PVOID)&dwErrorCode
                   );
    }

    DeregisterEventSource( hLog );
}



//
//
// Function:	LogEvent
//
// Descr:
//
//

VOID
APIENTRY
LogEvent(
     IN DWORD	wEventType,
     IN DWORD	dwMessageId,
     IN DWORD	cNumberOfSubStrings,
     IN LPTSTR	*plpszSubStrings
) {
    HANDLE 	hLog;
    PSID 	pSidUser = NULL;

    // Audit enabled

    hLog = RegisterEventSource( NULL, ROUTER_SERVICE );

    ReportEvent( hLog,
		         (WORD)wEventType,		// success/failure audit
		         0,				        // event category
		         dwMessageId,
		         pSidUser,
		         (WORD)cNumberOfSubStrings,
		         0,
		         plpszSubStrings,
		         (PVOID)NULL);

    DeregisterEventSource( hLog );
}




//----------------------------------------------------------------------------
// Function:    RouterLogRegister
//
// Returns a HANDLE which can be passed to RouterLogEvent
// to log events from the specified source.
//----------------------------------------------------------------------------

HANDLE
RouterLogRegister(
    LPCTSTR lpszSource
    ) {

    return RegisterEventSource(NULL, lpszSource);
}



//----------------------------------------------------------------------------
// Function:    RouterLogDeregister
//
// Closes a HANDLE created by RouterLogRegister
//----------------------------------------------------------------------------

VOID
RouterLogDeregister(
    HANDLE hLogHandle
    ) {

    if(NULL != hLogHandle)
    {
        DeregisterEventSource(hLogHandle);
    }
}



//----------------------------------------------------------------------------
// Function:    RouterLogEvent
//
// Logs an event using a HANDLE created by RouterLogRegister.
//----------------------------------------------------------------------------

VOID
RouterLogEvent(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPTSTR *plpszSubStringArray,
    IN DWORD dwErrorCode
    ) {

    if(NULL == hLogHandle)
    {
        return;
    }

    if (dwErrorCode == NO_ERROR) {

        ReportEvent(
            hLogHandle,
            (WORD)dwEventType,
            0,
            dwMessageId,
            NULL,
            (WORD)dwSubStringCount,
            0,
            plpszSubStringArray,
            (PVOID)NULL
            );
    }
    else {

        ReportEvent(
            hLogHandle,
            (WORD)dwEventType,
            0,
            dwMessageId,
            NULL,
            (WORD)dwSubStringCount,
            sizeof(DWORD),
            plpszSubStringArray,
            (PVOID)&dwErrorCode
            );
    }
}


VOID
RouterLogEventEx(
    IN HANDLE   hLogHandle,
    IN DWORD    dwEventType,
    IN DWORD    dwErrorCode,
    IN DWORD    dwMessageId,
    IN LPCTSTR  ptszFormat,
    ...
    )
{
    va_list     vlArgList;

    if(NULL == hLogHandle)
    {
        return;
    }
    
    va_start(vlArgList, ptszFormat);
    RouterLogEventValistEx(
        hLogHandle,
        dwEventType,
        dwErrorCode,
        dwMessageId,
        ptszFormat,
        vlArgList
        );
    va_end(vlArgList);
}

VOID
RouterLogEventValistEx(
    IN HANDLE   hLogHandle,
    IN DWORD    dwEventType,
    IN DWORD    dwErrorCode,
    IN DWORD    dwMessageId,
    IN LPCTSTR  ptszFormat,
    IN va_list  vlArgList
    )

/*++

Routine Description

    This function logs an event, but also parses out the insert strings

Locks

    None

Arguments

    hLogHandle      Handle from RegisterLogRegister()
    dwEventType     EVENTLOG_{ERROR|WARNING|INFORMATION}_TYPE
    dwErrorCode     The error code to report
    dwMessageId     The ID of the message string
    ptszFormat      A string specifying the format of the following insert
                    values. The type of the value is dictated by the format
                    string. The format string consists of a series of %<X>
                    There MUST BE NOTHING ELSE - no escape characters, no 
                    nothing.
                    Valid <X> are:
                    S:  Unicode string
                    s:  ANSII string
                    t:  TCHAR string
                    d:  integer
                    I:  IP Address in network order

Return Value

    None    

--*/

{
    PWCHAR      rgpwszInsertArray[20];
    LPCTSTR     ptszTemp;
    WORD        wNumInsert;
    ULONG       i, ulDecIndex, ulFormatLen;

    
    //
    // 22 is enough to hold 2^64
    // There can be max 20 insert strings
    //
    
    WCHAR  rgpwszDecString[20][22];

    
    if (ptszFormat==NULL)
        ptszFormat = TEXT("");


    if(NULL == hLogHandle)
    {
        return;
    }

    //
    // First make sure that the format list doesnt specify more than
    // 20 characters
    //
    
    ptszTemp = ptszFormat;

    ulFormatLen = _tcslen(ptszFormat);

    wNumInsert  = 0;
    ulDecIndex  = 0;
    i           = 0;
 
    //
    // We will only walk the first 20 format specifiers
    //
    
    while((i < ulFormatLen) && (wNumInsert < 20))
    {   
        if(*ptszTemp == __TEXT('%'))
        {
            //
            // Ok so this could be a good specifier - check the next character
            //
            
            i++;
            
            ptszTemp++;
            
            switch(*ptszTemp)
            {
                case UNICODE_STRING_TAG:
                {
                    
                    rgpwszInsertArray[wNumInsert] = va_arg(vlArgList, PWCHAR);
                    
                    wNumInsert++;
                    
                    break;
                }
                
                case ANSI_STRING_TAG:
                {
                    PCHAR   pszString;
                    PWCHAR  pwszWideString;
                    ULONG   ulLen;
                    
                    pszString = va_arg(vlArgList,
                                       PCHAR);
                    
                    ulLen = strlen(pszString);
                    
                    if(ulLen)
                    {
                        pwszWideString = _alloca(ulLen * sizeof(WCHAR));
                        
                        MultiByteToWideChar(CP_ACP,
                                            0,
                                            pszString,
                                            -1,
                                            pwszWideString,
                                            ulLen);
                        
                        rgpwszInsertArray[wNumInsert] = pwszWideString;
                    }
                    else
                    {
                        //
                        // L"" will be on our stack, but it cant go away
                        //
                        
                        rgpwszInsertArray[wNumInsert] = L"";
                    }
                    
                    wNumInsert++;
                    break;
                }
                
                case TCHAR_STRING_TAG:
                {
                    
#if defined(UNICODE) || defined(_UNICODE)
                    
                    rgpwszInsertArray[wNumInsert] = va_arg(vlArgList, PWCHAR);

#else
                    PCHAR   pszString;
                    PWCHAR  pwszWideString;
                    ULONG   ulLen;
                    
                    pszString = va_arg(vlArgList, PCHAR);
                    
                    ulLen = strlen(pszString);

                    if(ulLen)
                    {
                        pwszWideString = _alloca(ulLen * sizeof(WCHAR));
                        
                        MultiByteToWideChar(CP_ACP,
                                            0,
                                            pszString,
                                            -1,
                                            pwszWideString,
                                            ulLen);
                        
                        rgpwszInsertArray[wNumInsert] = pwszWideString;
                    }
                    else
                    {
                        //
                        // L"" will be on our stack, but it cant go away
                        //
                        
                        rgpwszInsertArray[wNumInsert] = L"";
                    }

#endif
                        
                    wNumInsert++;
                        
                    break;
                }
                
                case DECIMAL_TAG:
                {
                    _snwprintf(&(rgpwszDecString[ulDecIndex][0]),
                               21,
                               L"%d",
                               va_arg(vlArgList, int));
                    
                    
                    rgpwszDecString[ulDecIndex][21] = UNICODE_NULL;
                    
                    rgpwszInsertArray[wNumInsert] =
                        &(rgpwszDecString[ulDecIndex][0]);
                    
                    ulDecIndex++;
                    wNumInsert++;
                    
                    break;
                }

                case IPADDRESS_TAG:
                {
                    DWORD   dwAddr;
                    
                    dwAddr = va_arg(vlArgList, int);
                    
                    _snwprintf(&(rgpwszDecString[ulDecIndex][0]),
                               21,
                               L"%d.%d.%d.%d",
                               PRINT_IPADDR(dwAddr));
                    
                    rgpwszDecString[ulDecIndex][21] = UNICODE_NULL;
                    
                    rgpwszInsertArray[wNumInsert] =
                        &(rgpwszDecString[ulDecIndex][0]);
                    
                    ulDecIndex++;
                    wNumInsert++;
                    
                    break;
                }
            }
        }

        //
        // Scan next character
        //
        
        ptszTemp++;
            
        i++;
    }
    
    if (dwErrorCode == NO_ERROR)
    {

        ReportEventW(hLogHandle,
                     (WORD)dwEventType,
                     0,
                     dwMessageId,
                     NULL,
                     wNumInsert,
                     0,
                     rgpwszInsertArray,
                     (PVOID)NULL);
    }
    else
    {

        ReportEventW(hLogHandle,
                     (WORD)dwEventType,
                     0,
                     dwMessageId,
                     NULL,
                     wNumInsert,
                     sizeof(DWORD),
                     rgpwszInsertArray,
                     (PVOID)&dwErrorCode);
    }
}



//----------------------------------------------------------------------------
// Function:    RouterLogEventData
//
// Logs an event using a HANDLE created by RouterLogRegister.
// Allows caller to include data in the eventlog message.
//----------------------------------------------------------------------------

VOID
RouterLogEventData(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPTSTR *plpszSubStringArray,
    IN DWORD dwDataBytes,
    IN LPBYTE lpDataBytes
    ) {

    if(NULL == hLogHandle)
    {
        return;
    }

    ReportEvent(
        hLogHandle,
        (WORD)dwEventType,
        0,
        dwMessageId,
        NULL,
        (WORD)dwSubStringCount,
        (WORD)dwDataBytes,
        plpszSubStringArray,
        (PVOID)lpDataBytes
        );
}

//----------------------------------------------------------------------------
// Function:    RouterLogEventString
//
// Logs an event using a HANDLE created by RouterLogRegister.
// Allows caller to include an error code string into the log
//----------------------------------------------------------------------------

VOID
RouterLogEventString(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN LPTSTR *plpszSubStringArray,
    IN DWORD dwErrorCode,
    IN DWORD dwErrorIndex
    ){

    DWORD   dwRetCode;
    DWORD   dwIndex;
    DWORD   dwSubStringIndex = 0;
    LPTSTR  plpszStringArray[20];

    if(NULL == hLogHandle)
    {
        return;
    }

    RTASSERT( dwSubStringCount < 21 );
    RTASSERT( dwErrorIndex <= dwSubStringCount );

    dwSubStringCount++;

    for ( dwIndex = 0; dwIndex < dwSubStringCount; dwIndex++ )
    {
        if ( dwIndex == dwErrorIndex )
        {
            dwRetCode = RouterGetErrorString( 
                                        dwErrorCode,
                                        &plpszStringArray[dwIndex] );

            if ( dwRetCode != NO_ERROR )
            {
                DbgPrint("Error %d\n",dwRetCode);

                //RTASSERT( dwRetCode == NO_ERROR );
                return;
            }
        }
        else
        {
            plpszStringArray[dwIndex] = plpszSubStringArray[dwSubStringIndex++];
        }
    }

    ReportEvent(
            hLogHandle,
            (WORD)dwEventType,
            0,
            dwMessageId,
            NULL,
            (WORD)dwSubStringCount,
            sizeof(DWORD),
            plpszStringArray,
            (PVOID)&dwErrorCode
            );

    LocalFree( plpszStringArray[dwErrorIndex] );
}

//----------------------------------------------------------------------------
// Function:    RouterGetErrorString
//
// Given an error code from raserror.h mprerror.h or winerror.h will return
// a string associated with it. The caller is required to free the string
// by calling LocalFree.
//----------------------------------------------------------------------------
DWORD 
RouterGetErrorString(
    IN      DWORD      dwError,
    OUT     LPTSTR *   lplpszErrorString
)
{
    DWORD       dwRetCode        = NO_ERROR;
    DWORD       dwBufferSize;

    if ( ( ( dwError >= RASBASE ) && ( dwError <= RASBASEEND ) ) ||
         ( ( dwError >= ROUTEBASE ) && ( dwError <= ROUTEBASEEND ) ) || 
         ( ( dwError >= ROUTER_LOG_BASE) && (dwError <= ROUTER_LOG_BASEEND)))
    {
        // make sure that load library is called only once

        if (InterlockedCompareExchangePointer(
                                            &g_hDll,
                                            INVALID_HANDLE_VALUE, 
                                            NULL) == NULL)                                            
        {
            g_hDll = LoadLibrary( TEXT("mprmsg.dll") );

            if(g_hDll == NULL)
            {
                return( GetLastError() );
            }
        }

        while (*((HINSTANCE volatile *)&g_hDll)==INVALID_HANDLE_VALUE)
            Sleep(500);
        if (g_hDll==NULL)
            return ERROR_CAN_NOT_COMPLETE;
            
        
        dwRetCode = FormatMessage(
                                FORMAT_MESSAGE_FROM_HMODULE |
                                FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                g_hDll,
                                dwError,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (LPTSTR)lplpszErrorString,
                                0,
                                NULL );
    }
    else
    {
        dwRetCode = FormatMessage(
                               FORMAT_MESSAGE_ALLOCATE_BUFFER |
                               FORMAT_MESSAGE_IGNORE_INSERTS |
                               FORMAT_MESSAGE_FROM_SYSTEM,
                               NULL,
                               dwError,
                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                               (LPTSTR)lplpszErrorString,
                               0,
                               NULL );
    }

    if ( dwRetCode == 0 )
    {
        return( GetLastError() );
    }
    else
    {
        return( NO_ERROR );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\mm.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    mm.h
//
// History:
//      Abolade Gbadegesin      Jan-26-1996     Created.
//
// Contains internal declarations for memory-management routines.
//============================================================================

#ifndef _MM_H_
#define _MM_H_


// struct:  MMHEADER
//
// Describes an entry in the memory-managed heap.

typedef struct _MMHEADER {

    LIST_ENTRY      leLink;
    LARGE_INTEGER   liTimeStamp;
    DWORD           dwBlockSize;

} MMHEADER, *PMMHEADER;




// struct:  MMHEAP
//
// Describes a memory-managed heap.
// This consists of a critical section used to synchronize acces to the heap,
// a busy list used to store headers for entries currently allocated,
// and a free list used to store headers for recently de-allocated entries.
// The busy list is sorted by the time of allocation, most-recent-first,
// and the free list is sorted by size, smallest-first.

typedef struct _MMHEAP {

    HANDLE          hHeap;
    LIST_ENTRY      lhFreeList;
    LIST_ENTRY      lhBusyList;
    CRITICAL_SECTION csListLock;

} MMHEAP, *PMMHEAP;


#endif // _MM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\mm.c ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    mm.c
//
// History:
//      Abolade Gbadegesin      Jan-226-1996    Created.
//
// Contains code for memory management in IPRIP
//============================================================================



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rtutils.h>
#include "mm.h"


// Function:    MmHeapCreate
//
// This function creates a heap and initializes lists which will contain
// the addresses of allocated and freed blocks of memory.

HANDLE
MmHeapCreate(
    DWORD dwInitialSize,
    DWORD dwMaximumSize
    ) {

    DWORD dwErr;
    HANDLE hHeap;
    MMHEAP *pheap;


    //
    // create a Win32 heap; we specify no serialization
    // since our critical section will enforce serialization
    //

    hHeap = HeapCreate(HEAP_NO_SERIALIZE, dwInitialSize, dwMaximumSize);
    if (hHeap == NULL) { return NULL; }


    //
    // within the heap created, allocate space for the managed heap
    //

    pheap = HeapAlloc(hHeap, 0, sizeof(MMHEAP));
    if (pheap == NULL) {

        dwErr = GetLastError();
        HeapDestroy(hHeap);
        SetLastError(dwErr);

        return NULL;
    }


    //
    // initialize the managed heap
    //

    pheap->hHeap = hHeap;
    InitializeListHead(&pheap->lhFreeList);
    InitializeListHead(&pheap->lhBusyList);
    InitializeCriticalSection(&pheap->csListLock);


    //
    // return a pointer to the managed heap structure
    //

    return (HANDLE)pheap;
}




// Function:    MmHeapDestroy
//
// This function destroys a heap.

BOOL
MmHeapDestroy(
    HANDLE hHeap
    ) {

    MMHEAP *pheap;

    pheap = (MMHEAP *)hHeap;


    //
    // delete the lists' synchronization object
    //

    DeleteCriticalSection(&pheap->csListLock);


    //
    // a managed heap can be destroyed by merely destroying the heap
    // which was initially created for the managed heap, since all
    // allocations came out of that heap
    //

    return HeapDestroy(pheap->hHeap);
}



// Function:    MmHeapAlloc
//
// This function makes an allocation from a managed heap

PVOID
MmHeapAlloc(
    HANDLE hHeap,
    DWORD dwBytes
    ) {

    INT cmp;
    DWORD dwErr;
    MMHEAP *pheap;
    MMHEADER *phdr;
    LIST_ENTRY *ple, *phead;

    if (!hHeap || !dwBytes) { return NULL; }

    pheap = (MMHEAP *)hHeap;


    EnterCriticalSection(&pheap->csListLock);


    //
    // search the free-list for the allocation which
    // is closest in size to the number of bytes requested
    //

    phdr = NULL;
    phead = &pheap->lhFreeList;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        phdr = CONTAINING_RECORD(ple, MMHEADER, leLink);

        cmp = (dwBytes - phdr->dwBlockSize);

        if (cmp < 0) { continue; }
        else
        if (cmp > 0) { break; }

        //
        // the entry found is precisely the required size;
        //

        break;
    }


    //
    // if a re-usable entry was found, reset its timestamp,
    // move it to the busy-list, and return a pointer past the header.
    // otherwise, allocate a new entry for the caller,
    // initialize it, place it on the busy-list, and return a pointer.
    //

    if (ple != phead) {

        //
        // a re-usable entry was found
        //

        RemoveEntryList(&phdr->leLink);
    }
    else {

        //
        // no re-usable entry was found, allocate a new one
        //

        phdr = HeapAlloc(
                    pheap->hHeap, HEAP_NO_SERIALIZE, dwBytes + sizeof(MMHEADER)
                    );
        if (!phdr) {

            dwErr = GetLastError();
            LeaveCriticalSection(&pheap->csListLock);
            SetLastError(dwErr);

            return NULL;
        }
    }


    //
    // set the entry's timestamp and put it on the busy list
    //

    NtQuerySystemTime(&phdr->liTimeStamp);

    InsertHeadList(&pheap->lhBusyList, &phdr->leLink);


    LeaveCriticalSection(&pheap->csListLock);

    return (PVOID)(phdr + 1);
}



// Function:    MmHeapFree
//
// This function frees an allocation made by MmHeapAlloc

BOOL
MmHeapFree(
    HANDLE hHeap,
    PVOID pMem
    ) {

    INT cmp;
    MMHEAP *pheap;
    MMHEADER *phdr, *phdrFree;
    LIST_ENTRY *ple, *phead;

    if (!hHeap || !pMem) { return FALSE; }

    pheap = (MMHEAP *)hHeap;


    EnterCriticalSection(&pheap->csListLock);


    phdr = (MMHEADER *)((PBYTE)pMem - sizeof(MMHEADER));


    //
    // remove the entry from the busy-list
    //

    RemoveEntryList(&phdr->leLink);


    //
    // place the entry on the free-list,
    // which is in order of ascending size (smallest-first)
    //

    phead = &pheap->lhFreeList;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        phdrFree = CONTAINING_RECORD(ple, MMHEADER, leLink);

        cmp = (phdr->dwBlockSize - phdrFree->dwBlockSize);

        if (cmp < 0) { break; }
        else
        if (cmp > 0) { continue; }

        //
        // the allocations are the same size, but the newly-free one
        // is most likely the most-recently active
        //

        break;
    }


    //
    // insert the newly-free entry before the one found
    // (since this is a circular list, we accomplish this
    // using InsertTailList; think about it a while.)
    //

    NtQuerySystemTime(&phdr->liTimeStamp);

    InsertTailList(ple, &phdr->leLink);


    LeaveCriticalSection(&pheap->csListLock);

    return TRUE;
}



// Function:    MmHeapCollectGarbage
//
// This function is called by the owner of the heap.
// It takes as its argument an interval I in systime-units
// (system-time is measured in 100-nanosecond units), and any allocations
// on the free list which have not been re-used in the past I systime-units
// are returned to the Win32 heap.
//
// To return all free entries to the Win32 heap, specify an interval of 0.

BOOL
MmHeapCollectGarbage(
    HANDLE hHeap,
    LARGE_INTEGER liInterval
    ) {

    INT cmp;
    MMHEAP *pheap;
    MMHEADER *phdr;
    LIST_ENTRY *ple, *phead;
    LARGE_INTEGER liCutoff;

    if (!hHeap) { return FALSE; }

    pheap = (MMHEAP *)hHeap;

    EnterCriticalSection(&pheap->csListLock);


    //
    // get the current system-time, and from that compute the cutoff-time
    // for allocation timestamps, by subtracting the interval passed in
    // to get the time of the earliest allocation which can be exempt
    // from garbage-collection
    //

    NtQuerySystemTime(&liCutoff);
    liCutoff = RtlLargeIntegerSubtract(liCutoff, liInterval);


    //
    // go through the free-list
    //

    phead = &pheap->lhFreeList;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        phdr = CONTAINING_RECORD(ple, MMHEADER, leLink);

        if (RtlLargeIntegerLessThan(liCutoff, phdr->liTimeStamp)) { continue; }


        //
        // this allocation is stamped from before the cutoff interval,
        // so we'll have to free it (with care, since it is a link
        // in the list we are walking through).
        //

        ple = ple->Blink;

        RemoveEntryList(&phdr->leLink);

        HeapFree(pheap->hHeap, HEAP_NO_SERIALIZE, phdr);
    }

    LeaveCriticalSection(&pheap->csListLock);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\unicode.h ===
// exists to force UNICODE compilation of this specific file
//
#define UNICODE     1
#define _UNICODE    1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\setup.c ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    setup.c
//
// History:
//  06/24/96    Abolade Gbadegesin      Created.
//
// Implements API functions used by IP and IPX to read installation information
// stored under HKLM\Software\Microsoft\Router.
//
// The API functions are presented first, followed by private functions
// in alphabetical order.
//============================================================================

#define UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rtutils.h>

//
// Constant strings used to access the registry:
//
const WCHAR c_szDLLName[]                       = L"DLLName";
const WCHAR c_szMicrosoft[]                     = L"Microsoft";
const WCHAR c_szProtocolId[]                    = L"ProtocolId";
const WCHAR c_szRouter[]                        = L"Router";
const TCHAR c_szCurrentVersion[]                = L"CurrentVersion";
const WCHAR c_szRouterManagers[]                = L"RouterManagers";
const WCHAR c_szSoftware[]                      = L"Software";


//
// Memory management macros:
//
#define Malloc(s)       HeapAlloc(GetProcessHeap(), 0, (s))
#define ReAlloc(p,s)    HeapReAlloc(GetProcessHeap(), 0, (p), (s))
#define Free(p)         HeapFree(GetProcessHeap(), 0, (p))
#define Free0(p)        ((p) ? Free(p) : TRUE)

DWORD
QueryRmSoftwareKey(
    IN      HKEY                    hkeyMachine,
    IN      DWORD                   dwTransportId,
    OUT     HKEY*                   phkrm,
    OUT     LPWSTR*                 lplpwsRm
    );


//----------------------------------------------------------------------------
// Function:    MprSetupProtocolEnum
//
// Enumerates the protocols installed for transport 'dwTransportId'.
//
// The information is loaded from HKLM\Software\Microsoft\Router,
// where subkeys exist for each router-manager under the 'RouterManagers' key.
// Each router-manager subkey has subkeys containing information
// about that router-manager's routing-protocols.
//
// This API reads a subset of that information, so that router-managers
// can map protocol-IDs to DLL names when loading routing-protocols.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprSetupProtocolEnum(
    IN      DWORD                   dwTransportId,
    OUT     LPBYTE*                 lplpBuffer,         // MPR_PROTOCOL_0
    OUT     LPDWORD                 lpdwEntriesRead
    ) {

    HKEY hkrm;
    WCHAR* lpwsRm = NULL;
    DWORD dwErr, dwItemCount;
    MPR_PROTOCOL_0* pItem, *pItemTable = NULL;


    //
    // Validate the caller's parameters
    //

    if (!lplpBuffer ||
        !lpdwEntriesRead) { return ERROR_INVALID_PARAMETER; }

    *lplpBuffer = NULL;
    *lpdwEntriesRead = 0;


    //
    // Open the key for the specified router-manager
    // under HKLM\Software\Microsoft\Router\CurrentVersion\RouterManagers
    //

    dwErr = QueryRmSoftwareKey(
                HKEY_LOCAL_MACHINE, dwTransportId, &hkrm, &lpwsRm
                );

    if (dwErr != NO_ERROR) { return dwErr; }


    //
    // The transport was found, so its registry key is in 'hkrm'
    //

    do {

        //
        // Retrieve information about the subkeys of the router-manager,
        // since these should all contain data for routing-protocols.
        //

        WCHAR* pwsKey;
        DWORD i, dwSize, dwType;
        DWORD dwKeyCount, dwMaxKeyLength;

        dwErr = RegQueryInfoKey(
                    hkrm, NULL, NULL, NULL, &dwKeyCount, &dwMaxKeyLength,
                    NULL, NULL, NULL, NULL, NULL, NULL
                    );

        if (dwErr != ERROR_SUCCESS) { break; }


        //
        // Allocate enough space for the longest of the subkeys
        //

        pwsKey = Malloc((dwMaxKeyLength + 1) * sizeof(WCHAR));

        if (!pwsKey) { dwErr = ERROR_NOT_ENOUGH_MEMORY; break; }


        //
        // Allocate an array to hold the keys' contents
        //

        pItemTable = (MPR_PROTOCOL_0*)Malloc(dwKeyCount * sizeof(*pItem));

        if (!pItemTable) { dwErr = ERROR_NOT_ENOUGH_MEMORY; break; }

        ZeroMemory(pItemTable, dwKeyCount * sizeof(*pItem));


        //
        // Enumerate the keys
        //

        dwItemCount = 0;

        for (i = 0; i < dwKeyCount; i++) {

            HKEY hkprot;
            PBYTE pValue = NULL;


            //
            // Get the name of the current key
            //

            dwSize = dwMaxKeyLength + 1;
            dwErr = RegEnumKeyEx(
                        hkrm, i, pwsKey, &dwSize, NULL, NULL, NULL, NULL
                        );

            if (dwErr != ERROR_SUCCESS) { continue; }


            //
            // Open the key
            //

            dwErr = RegOpenKeyEx(hkrm, pwsKey, 0, KEY_READ, &hkprot);

            if (dwErr != ERROR_SUCCESS) { continue; }


            pItem = pItemTable + dwItemCount;

            do {

                DWORD dwMaxValLength;


                //
                // Copy the string for the protocol
                //

                lstrcpyn(pItem->wszProtocol, pwsKey, RTUTILS_MAX_PROTOCOL_NAME_LEN+1);


                //
                // Get information about the key's values
                //

                dwErr = RegQueryInfoKey(
                            hkprot, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                            NULL, &dwMaxValLength, NULL, NULL
                            );

                if (dwErr != ERROR_SUCCESS) { break; }


                //
                // Allocate space to hold the longest of the values
                //

                pValue = Malloc(dwMaxValLength + 1);

                if (!pValue) { dwErr = ERROR_NOT_ENOUGH_MEMORY; break; }


                //
                // Read the ProtocolId value
                //

                dwSize = dwMaxValLength + 1;

                dwErr = RegQueryValueEx(
                            hkprot, c_szProtocolId, 0, &dwType, pValue, &dwSize
                            );

                if (dwErr != ERROR_SUCCESS) { break; }

                pItem->dwProtocolId = *(PDWORD)pValue;



                //
                // Read the DLLName value
                //

                dwSize = dwMaxValLength + 1;

                dwErr = RegQueryValueEx(
                            hkprot, c_szDLLName, 0, &dwType, pValue, &dwSize
                            );

                if (dwErr != ERROR_SUCCESS) { break; }

                lstrcpyn(
                    pItem->wszDLLName, (WCHAR*)pValue, RTUTILS_MAX_PROTOCOL_DLL_LEN+1);


                //
                // Increment the count of loaded protocols
                //

                ++dwItemCount;

                dwErr = ERROR_SUCCESS;

            } while(FALSE);

            Free0(pValue);

            RegCloseKey(hkprot);
        }

        Free0(pwsKey);

    } while(FALSE);

    Free0(lpwsRm);

    if (dwErr != NO_ERROR) {

        Free0(pItemTable);
    }
    else {

        //
        // Adjust the size of the buffer to be returned,
        // in case not all the keys contained routing-protocols,
        // and save the number of protocols loaded.
        //

        *lplpBuffer = ReAlloc(pItemTable, dwItemCount * sizeof(*pItem));
        *lpdwEntriesRead = dwItemCount;
    }

    RegCloseKey(hkrm);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MprSetupProtocolFree
//
// Called to free a buffer allocated by 'MprSetupProtocolEnum'.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprSetupProtocolFree(
    IN      LPVOID                  lpBuffer
    ) {

    if (!lpBuffer) { return ERROR_INVALID_PARAMETER; }

    Free(lpBuffer);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    QueryRmSoftwareKey
//
// Called to open the key for a router-manager given its transport ID.
//----------------------------------------------------------------------------

DWORD
QueryRmSoftwareKey(
    IN      HKEY                    hkeyMachine,
    IN      DWORD                   dwTransportId,
    OUT     HKEY*                   phkrm,
    OUT     LPWSTR*                 lplpwsRm
    ) {

    HKEY hkey;
    DWORD dwErr;
    WCHAR wszKey[256], *pwsKey;


    //
    // Open the key HKLM\Software\Microsoft\Router\RouterManagers
    //

    wsprintf(
        wszKey, L"%s\\%s\\%s\\%s\\%s", c_szSoftware, c_szMicrosoft, c_szRouter,
        c_szCurrentVersion, c_szRouterManagers
        );

    dwErr = RegOpenKeyEx(hkeyMachine, wszKey, 0, KEY_READ, &hkey);

    if (dwErr != ERROR_SUCCESS) { return dwErr; }


    //
    // Enumerate the subkeys of the 'RouterManagers' key,
    // in search of one which as a 'ProtocolId' value equal to 'dwTransportId'.
    //

    do {

        //
        // Retrieve information about the subkeys of the key
        //

        DWORD dwKeyCount, dwMaxKeyLength;
        DWORD i, dwSize, dwType, dwProtocolId = ~dwTransportId;


        dwErr = RegQueryInfoKey(
                    hkey, NULL, NULL, NULL, &dwKeyCount, &dwMaxKeyLength,
                    NULL, NULL, NULL, NULL, NULL, NULL
                    );

        if (dwErr != ERROR_SUCCESS) { break; }


        //
        // Allocate enough space for the longest of the subkeys
        //

        pwsKey = Malloc((dwMaxKeyLength + 1) * sizeof(WCHAR));

        if (!pwsKey) { dwErr = ERROR_NOT_ENOUGH_MEMORY; break; }



        //
        // Enumerate the keys
        //

        for (i = 0; i < dwKeyCount; i++) {

            //
            // Get the name of the current key
            //

            dwSize = dwMaxKeyLength + 1;

            dwErr = RegEnumKeyEx(
                        hkey, i, pwsKey, &dwSize, NULL, NULL, NULL, NULL
                        );

            if (dwErr != ERROR_SUCCESS) { continue; }


            //
            // Open the key
            //

            dwErr = RegOpenKeyEx(hkey, pwsKey, 0, KEY_READ, phkrm);

            if (dwErr != ERROR_SUCCESS) { continue; }


            //
            // Try to read the ProtocolId value
            //

            dwSize = sizeof(dwProtocolId);

            dwErr = RegQueryValueEx(
                        *phkrm, c_szProtocolId, 0, &dwType,
                        (BYTE*)&dwProtocolId, &dwSize
                        );

            //
            // Break if this is the transport we're looking for,
            // otherwise close the key and continue
            //

            if (dwErr == ERROR_SUCCESS &&
                dwProtocolId == dwTransportId) { break; }


            RegCloseKey(*phkrm);
        }

        if (i >= dwKeyCount) { Free(pwsKey); break; }


        //
        // The transport was found, so save its key-name
        //

        *lplpwsRm = pwsKey;

    } while(FALSE);

    RegCloseKey(hkey);

    return (*lplpwsRm ? NO_ERROR : ERROR_NO_MORE_ITEMS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\server.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: init.c
//
// History:
//      Abolade Gbadegesin  July-24-1995    Created
//
// Server routines for tracing dll.
// All functions invoked by the server thread are code-page independent.
//============================================================================


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rtutils.h>
#include "trace.h"


// waits on
// lpserver->hConsole
// lpserver->hStopEvent
// lpserver->hTableEvent
// lpclient->hConfigEvent for each client

#define POS_CONSOLE     0
#define POS_STOP        1
#define POS_TABLE       2
#define POS_CLIENT_0    3
#define POS_MAX         MAXIMUM_WAIT_OBJECTS
#define ADJUST_ARRAY(a) ((a) + posBase)
#define ADJUST_INDEX(i) ((i) - posBase)
#define OFFSET_CLIENT(i,d)  (((i) + MAX_CLIENT_COUNT + d) % MAX_CLIENT_COUNT)


extern VOID StopWorkers (VOID);
LPTRACE_SERVER  g_server = NULL;
HINSTANCE           g_module;
HANDLE          g_loadevent = NULL;
HMODULE         g_moduleRef;
HANDLE          g_serverThread;
ULONG           g_traceCount; //attempt server thread creation ?
ULONG           g_traceTime; //when last attempt to create server thread.
DWORD           g_posBase, g_posLast;//not used by serverthread.
                            // only to decide if new serverthread to be created
HANDLE          g_hWaitHandles[POS_MAX];




HINSTANCE
IncrementModuleReference (
    VOID
    );

BOOL WINAPI DLLMAIN(HINSTANCE hInstDLL, DWORD dwReason, LPVOID lpvReserved) {
    BOOL    bSuccess;
    HANDLE      c_loadevent;

    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hInstDLL);
            g_module = hInstDLL;
                // If a server threade managed to start before we got
                // DLL_PROCESS_ATTACH call (possible because of NT Loader
                // bug), we need to release it
            c_loadevent = (HANDLE)InterlockedExchangePointer (
                                    &g_loadevent,
                                    INVALID_HANDLE_VALUE);
            if (c_loadevent!=NULL) {
                bSuccess = SetEvent (c_loadevent);
                ASSERTMSG ("Could not signal waiting trace servers ", bSuccess);
            }
            else
                bSuccess = TRUE;
            break;

        case DLL_PROCESS_DETACH:
            if (g_server) {
                bSuccess = TraceShutdownServer(g_server);
                g_server = NULL;
            }
            else
                bSuccess = TRUE;
            StopWorkers ();
            break;

        default:
            bSuccess = TRUE;
    }

    return bSuccess;
}


HINSTANCE
IncrementModuleReference (
    VOID
    ) {
    HMODULE hmodule;
    TCHAR       szmodule[MAX_PATH+1];
    HANDLE      l_loadevent;
    HANDLE      c_loadevent;
    DWORD       rc;

        // Create an event in case we need to wait for DLL_PROCESS_ATTACH
    l_loadevent = CreateEvent (NULL, TRUE, FALSE, NULL);
    ASSERTMSG ("Could not create load event ", l_loadevent!=NULL);

    if (l_loadevent!=NULL) {
            // Make our event global if either no-one else
            // has done this yet
        c_loadevent = (HANDLE)InterlockedCompareExchangePointer (
                                (PVOID *)&g_loadevent,
                                l_loadevent,
                                NULL);
        if (c_loadevent==NULL) {
            rc = WaitForSingleObject (l_loadevent, INFINITE);
                // Let other waiting threads run as we going to close
                // our event right after this
            Sleep (0);
        }
        else if (c_loadevent==INVALID_HANDLE_VALUE) {
                // DLL_PROCESS_ATTACH has already been called
            rc = WAIT_OBJECT_0;
        }
        else {
                        // Somebody else managed to start before us
                        // -> wait on that event
#if DBG
            DbgPrint ("RTUTILS: %lx - trace server thread waiting for load on existing event.\n",
                                GetCurrentThreadId ());
#endif
            rc = WaitForSingleObject (c_loadevent, INFINITE);
                // Just in case the handle has been closed before we
                // managed to start the wait (unlikely because
                // of Sleep call above, but just in case ...)
            if ((rc!=WAIT_OBJECT_0)
                    && (GetLastError ()==ERROR_INVALID_HANDLE)) {
#if DBG
                DbgPrint ("RTUTILS: %lx - trace server thread load event was destroyed during wait.\n",
                                GetCurrentThreadId ());
#endif
                rc = WAIT_OBJECT_0;
            }
        }

        ASSERTMSG ("Wait on load event failed ", rc==WAIT_OBJECT_0);

        CloseHandle (l_loadevent);

        if (rc==WAIT_OBJECT_0) {

            //
            // we do a LoadLibrary to increment the reference count
            // on RTUTILS.DLL, so that when we're unloaded by the application,
            // our address space doesn't disappear.
            // instead, our event will be signalled and then we cleanup
            // and call FreeLibraryAndExitThread to unload ourselves
            //

            rc = GetModuleFileName(g_module, szmodule, sizeof(szmodule)/sizeof (szmodule[0]));
            ASSERTMSG ("Could not get dll path ", rc>0);
            if (rc>0) {
                hmodule = LoadLibrary(szmodule);
                if (hmodule!=NULL)
                    return hmodule;
            }
        }
    }


    return NULL;
}



//
// sets up server struct in readiness for clients registering
//
LPTRACE_SERVER TraceCreateServer (
    LPTRACE_SERVER *lpserver
    ) {
    LPTRACE_SERVER      l_lpserver, c_lpserver;
    DWORD               rc;


    l_lpserver = (LPTRACE_SERVER)GlobalAlloc (GPTR, sizeof (TRACE_SERVER));
    if (l_lpserver!=NULL) {

        l_lpserver->TS_Flags = 0;
        l_lpserver->TS_Console = NULL;
        l_lpserver->TS_StopEvent = NULL;
        l_lpserver->TS_TableEvent = NULL;
        l_lpserver->TS_ClientCount = 0;
        l_lpserver->TS_ConsoleOwner = MAX_CLIENT_COUNT;

        ZeroMemory(l_lpserver->TS_FlagsCache, MAX_CLIENT_COUNT * sizeof(DWORD));
        ZeroMemory(
            l_lpserver->TS_ClientTable, MAX_CLIENT_COUNT * sizeof(LPTRACE_CLIENT)
            );

        try {
            TRACE_STARTUP_LOCKING(l_lpserver);
            rc = NO_ERROR;
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            rc = GetExceptionCode ();
        }

        ASSERTMSG ("Cound not initialize lock ", rc==NO_ERROR);
        if (rc==NO_ERROR) {
            c_lpserver = InterlockedCompareExchangePointer (
                        (PVOID *)lpserver,
                        l_lpserver,
                        NULL
                        );
            if (c_lpserver==NULL) {
                return l_lpserver;
            }
            else {
                TRACE_CLEANUP_LOCKING (l_lpserver);
                GlobalFree (l_lpserver);
                return c_lpserver;
            }
        }
        GlobalFree (l_lpserver);
    }

#if DBG
    DbgPrint ("RTUTILS: %lx - trace server creation failed.\n",
                GetCurrentThreadId ());
#endif
    return NULL;
}


//
// cleans server struct and de-allocates memory used
//
BOOL
TraceShutdownServer(
    LPTRACE_SERVER lpserver
    ) {


    if (lpserver->TS_StopEvent != NULL &&
        (lpserver->TS_Flags & TRACEFLAGS_SERVERTHREAD)) {

        //
        // server thread is active, let it do cleanup
        //

        SetEvent(lpserver->TS_StopEvent);
    }
    else {

        //
        // we'll do the cleanup ourselves
        //

        TraceCleanUpServer(lpserver);
    }

    return TRUE;
}


DWORD
TraceCleanUpServer(
    LPTRACE_SERVER lpserver
    ) {

    LPTRACE_CLIENT lpclient, *lplpc, *lplpcstart, *lplpcend;

//    TRACE_ACQUIRE_WRITELOCK(lpserver);

    TRACE_CLEANUP_LOCKING(lpserver);


    //
    // delete client structures
    //
    lplpcstart = lpserver->TS_ClientTable;
    lplpcend = lplpcstart + MAX_CLIENT_COUNT;

    for (lplpc = lplpcstart; lplpc < lplpcend; lplpc++) {
        if (*lplpc != NULL) {

            TraceDeleteClient(lpserver, lplpc);
        }
    }

    lpserver->TS_ConsoleOwner = MAX_CLIENT_COUNT;
    lpserver->TS_ClientCount = 0;

    if (lpserver->TS_TableEvent != NULL) {
        CloseHandle(lpserver->TS_TableEvent);
        lpserver->TS_TableEvent = NULL;
    }

    if (lpserver->TS_StopEvent != NULL) {
        CloseHandle(lpserver->TS_StopEvent);
        lpserver->TS_StopEvent = NULL;
    }

    if (lpserver->TS_Console != NULL) {
        CloseHandle(lpserver->TS_Console);
        lpserver->TS_Console = NULL;
        FreeConsole();
    }

    lpserver->TS_Flags = 0;

    return TRUE;
}



//
// assumes server is locked for writing
//
DWORD
TraceCreateServerComplete(
    LPTRACE_SERVER lpserver
    ) {

    HKEY hkeyConfig;
    DWORD dwType, dwSize, dwValue;
    DWORD dwErr, dwThread, dwDisposition;


    do { // breakout loop

        //
        // create event signalled to stop server thread
        //
        lpserver->TS_StopEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (lpserver->TS_StopEvent == NULL) {
            dwErr = GetLastError(); break;
        }


        //
        // create event signalled when client registers/deregisters
        //
        lpserver->TS_TableEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (lpserver->TS_TableEvent == NULL) {
            dwErr = GetLastError(); break;
        }


        //
        // open registry key containing server configuration
        //
        dwErr = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE, REGKEY_TRACING, 0, NULL,
                    REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hkeyConfig, &dwDisposition
                    );

        if (dwErr != NO_ERROR) { break; }


        //
        // read the server configuration from the config key
        //
        dwSize = sizeof(DWORD);

        dwErr = RegQueryValueEx(
                    hkeyConfig, REGVAL_ENABLECONSOLETRACING, NULL,
                    &dwType, (PBYTE)&dwValue, &dwSize
                    );

        if (dwErr != NO_ERROR) {

            dwType = REG_DWORD;
            dwSize = sizeof(DWORD);
            dwValue = DEF_ENABLECONSOLETRACING;

            RegSetValueEx(
                hkeyConfig, REGVAL_ENABLECONSOLETRACING, 0,
                dwType, (PBYTE)&dwValue, dwSize
                );
        }

        if (dwValue != 0) { lpserver->TS_Flags |= TRACEFLAGS_USECONSOLE; }

        RegCloseKey(hkeyConfig); hkeyConfig = 0;


        //
        // set up array for client change notifications.
        // only used if server thread is not created
        //
        SetWaitArray(lpserver);
                    
        return NO_ERROR;

    } while(FALSE);


    //
    // something went wrong, so clean up
    //
    if (lpserver->TS_TableEvent != NULL) {
        CloseHandle(lpserver->TS_TableEvent);
        lpserver->TS_TableEvent = NULL;
    }
    if (lpserver->TS_StopEvent != NULL) {
        CloseHandle(lpserver->TS_StopEvent);
        lpserver->TS_StopEvent = NULL;
    }

    return dwErr;
}

//
// creates server thread if required
//

DWORD
TraceCreateServerThread (
    DWORD dwFlags,
    BOOL bCallerLocked, //does caller have write lock
    BOOL bNewRegister //new client registered. so check
    )
{
    DWORD dwErr=NO_ERROR;
    DWORD dwCurrentTime = GetTickCount();
    BOOL bCreate, bLocked=bCallerLocked;
    LPTRACE_SERVER lpserver;
    DWORD dwThread=0;



    lpserver = GET_TRACE_SERVER();
    if (!lpserver)
        return INVALID_TRACEID;

    //
    // check if serverthread should be created
    //

    bCreate = FALSE;

    
    do {
        if ((dwFlags & TRACE_USE_FILE) || (dwFlags & TRACE_USE_CONSOLE)) {
            bCreate = TRUE;
            break;
        }
        
        if (g_traceTime > dwCurrentTime)
            g_traceTime = dwCurrentTime;

        if (!bNewRegister) {
            if (dwCurrentTime - g_traceTime < 30000)
                break;
        }
        
        if (!bLocked){
            TRACE_ACQUIRE_WRITELOCK(lpserver);
            bLocked = TRUE;
        }

        
        // check again under lock if server thread has been created
        if (g_serverThread) {
            bCreate = FALSE;
            break;
        }
        
        //
        // enter the wait, passing the adjusted handle count
        // and the adjusted array base
        //

        {
            DWORD dwRetval;

            if (!bNewRegister) {

                // g_posLast points to the next empty event entry
                dwRetval = WaitForMultipleObjects(
                            g_posLast - g_posBase, g_hWaitHandles + g_posBase, FALSE, 0
                            );
                if (dwRetval==WAIT_TIMEOUT)
                    break;
            }
        }

        {
            LPTRACE_CLIENT *lplpc, *lplpcstart, *lplpcend;

            g_traceTime = dwCurrentTime;
                        
            lplpcstart = lpserver->TS_ClientTable;
            lplpcend = lpserver->TS_ClientTable + MAX_CLIENT_COUNT;
            g_posLast = POS_CLIENT_0;
            
            for (lplpc = lplpcstart; lplpc < lplpcend; lplpc++) {
                if (*lplpc == NULL)
                    continue;

                if (!TRACE_CLIENT_IS_DISABLED(*lplpc))
                    TraceEnableClient(lpserver, *lplpc, FALSE);
               
                if (TRACE_CLIENT_USES_CONSOLE(*lplpc)
                                    || TRACE_CLIENT_USES_FILE(*lplpc))
                {
                    bCreate = TRUE;
                    break;
                }
                if (TRACE_CLIENT_USES_REGISTRY(*lplpc))
                    g_hWaitHandles[g_posLast++] = (*lplpc)->TC_ConfigEvent;
            }
        }
        

    } while (FALSE);

    
    if (!bCreate) {
        if (bLocked && !bCallerLocked)
            TRACE_RELEASE_WRITELOCK(lpserver);
        return dwErr;
    }

    if (!bLocked) {
        TRACE_ACQUIRE_WRITELOCK(lpserver);
        bLocked = TRUE;
    }
    
    do {
        // final check under lock to see if thread created
        if (g_serverThread)
            break;
            
        g_moduleRef = IncrementModuleReference ();
        if (g_moduleRef==NULL) {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }


        g_serverThread = CreateThread(
                        NULL, 0, TraceServerThread, lpserver, 0, &dwThread
                        );

        if (g_serverThread == NULL) {
            dwErr = GetLastError();
            FreeLibrary(g_moduleRef);
            break;
        }

        CloseHandle(g_serverThread);

    } while (FALSE);

    if (bLocked && !bCallerLocked)
        TRACE_RELEASE_WRITELOCK(lpserver);

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:        TraceServerThread
//
// Parameters:
//      LPVOID      lpvParam
//
//----------------------------------------------------------------------------
DWORD
TraceServerThread(
    LPVOID lpvParam
    ) {

    DWORD dwErr;
    DWORD posBase, posLast;
    LPTRACE_SERVER lpserver;
    DWORD aWaitIndices[POS_MAX];
    HANDLE hWaitHandles[POS_MAX];
    LPTRACE_CLIENT lpclient, *lplpc, *lplpcstart, *lplpcend;


    //
    // get the server who owns this thread
    //

    lpserver = (LPTRACE_SERVER)lpvParam;


    //
    // set the flag to indicate we're running
    //

    InterlockedExchange(
        &lpserver->TS_Flags, lpserver->TS_Flags | TRACEFLAGS_SERVERTHREAD
        );

    posBase = posLast = 0;
    lplpcstart = lpserver->TS_ClientTable;
    lplpcend = lpserver->TS_ClientTable + MAX_CLIENT_COUNT;


    //
    // make sure the latest config is loaded
    //
    TRACE_ACQUIRE_WRITELOCK(lpserver);
    for (lplpc = lplpcstart; lplpc < lplpcend; lplpc++) {
        if (*lplpc != NULL && !TRACE_CLIENT_IS_DISABLED(*lplpc))
            TraceEnableClient(lpserver, *lplpc, FALSE);
    }
    TRACE_RELEASE_WRITELOCK(lpserver);


    while (TRUE) {

        //
        // to figure out which handles will be waited on
        // first lock the server for reading
        //
        TRACE_ACQUIRE_READLOCK(lpserver);


        //
        // if a thread is using the console, wait on console input handle
        // otherwise, the base of the array of handles waited on
        // is adjusted upward (by setting posBase to 1); then, when the
        // wait returns the index of the signalled handle, the index is
        // compared against the POS_ constants adjusted downward
        // (by subtracting posBase from them);
        // thus if posBase is 1, we pass &hWaitHandles[1] and if we get
        // back 2, we compared it to (POS_CLIENT_0 - 1)==2 and then we
        // access position (2 - (POS_CLIENT_0 - 1))==0 in the actual
        // client table
        //
        if (lpserver->TS_Console != NULL) {
            posBase = 0;
            hWaitHandles[POS_CONSOLE] = lpserver->TS_Console;
        }
        else {
            posBase = 1;
            hWaitHandles[POS_CONSOLE] = NULL;
        }

        hWaitHandles[POS_STOP] = lpserver->TS_StopEvent;
        hWaitHandles[POS_TABLE] = lpserver->TS_TableEvent;

        posLast = POS_CLIENT_0;

        for (lplpc = lplpcstart; lplpc < lplpcend; lplpc++) {
            if (*lplpc != NULL && TRACE_CLIENT_USES_REGISTRY(*lplpc)) {
                aWaitIndices[posLast] = (ULONG) (lplpc - lplpcstart);
                hWaitHandles[posLast++] = (*lplpc)->TC_ConfigEvent;
            }
        }

        TRACE_RELEASE_READLOCK(lpserver);



        //
        // enter the wait, passing the adjusted handle count
        // and the adjusted array base
        //

        dwErr = WaitForMultipleObjects(
                    posLast - posBase, hWaitHandles + posBase, FALSE, INFINITE
                    );


        dwErr += (DWORD)posBase;
        if (dwErr == (WAIT_OBJECT_0 + POS_CONSOLE)) {

            //
            // must be a key pressed in the console, so
            // process it
            //
            // lock server for writing
            //
            TRACE_ACQUIRE_WRITELOCK(lpserver);

            if (lpserver->TS_Console != NULL) {
                TraceProcessConsoleInput(lpserver);
            }

            TRACE_RELEASE_WRITELOCK(lpserver);
        }
        else
        if (dwErr == (WAIT_OBJECT_0 + POS_STOP)) {

            //
            // time to break out of the loop
            //
            break;
        }
        else
        if (dwErr == (WAIT_OBJECT_0 + POS_TABLE)) {
            DWORD dwOwner;

            // a client registered or deregistered;
            // we pick up the new reg config change event
            // the next time through the loop
        }
        else
        if (dwErr >= (WAIT_OBJECT_0 + POS_CLIENT_0) &&
            dwErr <= (WAIT_OBJECT_0 + posLast)) {

            //
            // config changed for a client, lock server for writing
            // and lock client for writing, and reload the configuration
            // from the registry; take care in case the client has
            // already deregistered
            //
            TRACE_ACQUIRE_WRITELOCK(lpserver);

            lplpc = lpserver->TS_ClientTable +
                    aWaitIndices[dwErr - WAIT_OBJECT_0];
            if (*lplpc == NULL) {
                TRACE_RELEASE_WRITELOCK(lpserver);
                continue;
            }


            //
            // load the client's configuration, unless it's disabled
            //
            if (!TRACE_CLIENT_IS_DISABLED(*lplpc)) {

                TraceEnableClient(lpserver, *lplpc, FALSE);
            }

            TRACE_RELEASE_WRITELOCK(lpserver);
        }
    }


    //
    // we've received the stop signal, so do cleanup and quit
    //

    TraceCleanUpServer(lpserver);

    //
    // unload the library and exit; this call never returns
    //

    FreeLibraryAndExitThread(g_moduleRef, 0);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:            TraceProcessConsoleInput
//
// Parameters:
//      LPTRACE_SERVER *lpserver
//
// Invoked when user presses a key in the console
// Keypresses handle are
//  spacebar            toggle the enabled/disabled flag for the client
//                      whose screen buffer is active
//  pause               same as <spacebar>
//  ctrl-tab            set the active screen buffer to that of
//                      the next client in the table
//  ctrl-shift-tab      set the active screen buffer to that of
//                      the previous client in the table
//  up, down, left, right  scrolls the console window as expected
//  pageup, pagedown    scrolls the console window as expected
// assumes the server is locked for writing
//----------------------------------------------------------------------------
DWORD
TraceProcessConsoleInput(
    LPTRACE_SERVER lpserver
    ) {

    INT dir;
    BOOL bSuccess;
    HANDLE hStdin;
    DWORD dwCount;
    WORD wRepCount;
    INPUT_RECORD inputRec;
    PKEY_EVENT_RECORD pkeyRec;
    DWORD dwConsoleOwner, dwNewOwner;
    LPTRACE_CLIENT lpclient, lpowner;


    //
    // see who owns the console
    //

    dwConsoleOwner = lpserver->TS_ConsoleOwner;

    if (dwConsoleOwner == MAX_CLIENT_COUNT) {

        //
        // no-one owns the console, so just return
        //
        return 0;
    }

    lpclient = lpserver->TS_ClientTable[dwConsoleOwner];


    //
    // get the console input handle
    //
    hStdin = lpserver->TS_Console;

    if (hStdin == NULL) {

        //
        // no console, so quit
        //
        return 0;
    }


    //
    // read input record
    //
    bSuccess = ReadConsoleInput(hStdin, &inputRec, 1, &dwCount);

    if (!bSuccess || dwCount == 0) {
        return GetLastError();
    }


    //
    // return if its not a keyboard event
    //
    if (inputRec.EventType != KEY_EVENT) {
        return 0;
    }


    //
    // if its one we handle, handle it
    //
    pkeyRec = &inputRec.Event.KeyEvent;
    if (!pkeyRec->bKeyDown) {

        //
        // we process when the key is pressed, not released
        //
        return 0;
    }

    wRepCount = pkeyRec->wRepeatCount;
    switch(pkeyRec->wVirtualKeyCode) {

        //
        // space-bar and pause are handled identically
        //
        case VK_PAUSE:
        case VK_SPACE:

            if (lpclient == NULL) { break; }

            //
            // if space bar or pause pressed an even
            // number of times, do nothing
            //
            if ((wRepCount & 1) == 0) { break; }


            //
            // toggle the enabled flag for the client
            //
            if (TRACE_CLIENT_IS_DISABLED(lpclient)) {
                TraceEnableClient(lpserver, lpclient, FALSE);
            }
            else {
                TraceDisableClient(lpserver, lpclient);
            }

            TraceUpdateConsoleTitle(lpclient);

            break;

        //
        // arrow keys are handled here
        //
        case VK_LEFT:

            if (lpclient == NULL) { break; }

            TraceShiftConsoleWindow(lpclient, -wRepCount, 0, NULL);
            break;
        case VK_RIGHT:

            if (lpclient == NULL) { break; }

            TraceShiftConsoleWindow(lpclient, wRepCount, 0, NULL);
            break;
        case VK_UP:

            if (lpclient == NULL) { break; }

            TraceShiftConsoleWindow(lpclient, 0, -wRepCount, NULL);
            break;
        case VK_DOWN:

            if (lpclient == NULL) { break; }

            TraceShiftConsoleWindow(lpclient, 0, wRepCount, NULL);
            break;


        //
        // page-up and page-down are handled here
        //
        case VK_PRIOR:
        case VK_NEXT: {

            INT iHeight;
            CONSOLE_SCREEN_BUFFER_INFO csbi;


            if (lpclient == NULL) { break; }


            //
            // find the current height of the window
            //
            GetConsoleScreenBufferInfo(lpclient->TC_Console, &csbi);

            iHeight = csbi.srWindow.Bottom - csbi.srWindow.Top;
            if (pkeyRec->wVirtualKeyCode == VK_PRIOR) {
                TraceShiftConsoleWindow(
                    lpclient, 0, -(wRepCount * iHeight), &csbi
                    );
            }
            else {
                TraceShiftConsoleWindow(
                    lpclient, 0, (wRepCount * iHeight), &csbi
                    );
            }

            break;
        }

        case VK_TAB:
            if ((pkeyRec->dwControlKeyState & LEFT_CTRL_PRESSED) ||
                (pkeyRec->dwControlKeyState & RIGHT_CTRL_PRESSED)) {

                //
                // ok, we can handle it.
                //
                // see if we are to move to
                // the previous screen buffer or to the next screen buffer
                //

                if (pkeyRec->dwControlKeyState & SHIFT_PRESSED) {
                    // moving to previous screen buffer
                    //
                    dir = -1;
                }
                else {
                    // moving to next screen buffer
                    //
                    dir = 1;
                }


                //
                // call the function which changes the console owner
                //
                TraceUpdateConsoleOwner(lpserver, dir);

            }
            break;
    }
    return 0;
}


//
// assumes client is locked for reading or writing
//
DWORD
TraceShiftConsoleWindow(
    LPTRACE_CLIENT lpclient,
    INT iXShift,
    INT iYShift,
    PCONSOLE_SCREEN_BUFFER_INFO pcsbi
    ) {

    PCOORD pc;
    PSMALL_RECT pr;
    CONSOLE_SCREEN_BUFFER_INFO csbi;


    //
    // if caller did not pass in current console info,
    // get the info before going any further
    //
    if (pcsbi == NULL) {
        pcsbi = &csbi;
        GetConsoleScreenBufferInfo(lpclient->TC_Console, pcsbi);
    }


    //
    // shift the window from its current position
    //
    pc = &pcsbi->dwSize;
    pr = &pcsbi->srWindow;
    pr->Left += (USHORT)iXShift; pr->Right += (USHORT)iXShift;
    pr->Top += (USHORT)iYShift; pr->Bottom += (USHORT)iYShift;
    if (pr->Left < 0 || pr->Top < 0) { return 0; }
    if (pr->Right >= pc->X || pr->Bottom >= pc->Y) { return 0; }

    SetConsoleWindowInfo(lpclient->TC_Console, TRUE, pr);

    return 0;
}




//
// searches for a new console owner in the specified direction
// assumes server is locked for writing
//
DWORD
TraceUpdateConsoleOwner(
    LPTRACE_SERVER lpserver,
    INT dir
    ) {

    INT i;
    DWORD dwOldOwner, dwNewOwner;
    LPTRACE_CLIENT lpNewOwner, lpOldOwner;


    //
    // if no-one owns the console, dwOldOwner is MAX_CLIENT_COUNT
    // in this case, the algorithm below ensures that the console
    // is assigned to someone else, if there is another console client
    //
    dwOldOwner = lpserver->TS_ConsoleOwner;
    if (dwOldOwner != MAX_CLIENT_COUNT) {
        lpOldOwner = lpserver->TS_ClientTable[dwOldOwner];
    }
    else {
        lpOldOwner = NULL;
    }


    //
    // find another owner; the macro OFFSET_CLIENT wraps
    // around both ends of the array, so we only need to take care
    // that the loop executes no more than MAX_CLIENT_COUNT times
    //
    for (i = 0, dwNewOwner = OFFSET_CLIENT(dwOldOwner, dir);
         i < MAX_CLIENT_COUNT && dwNewOwner != dwOldOwner;
         i++, dwNewOwner = OFFSET_CLIENT(dwNewOwner, dir)) {

        lpNewOwner = lpserver->TS_ClientTable[dwNewOwner];
        if (lpNewOwner != NULL) {


            if (TRACE_CLIENT_USES_CONSOLE(lpNewOwner)) {

                //
                // found a console client, so break out of the search
                //
                break;
            }

        }
    }


    if (lpNewOwner != NULL && TRACE_CLIENT_USES_CONSOLE(lpNewOwner)) {

        //
        // switch to the next buffer as follows:
        // call SetConsoleActiveScreenBuffer
        // update lpserver->dwConsoleOwner
        // update the console title since the new console owner
        //      may be disabled
        //

        SetConsoleActiveScreenBuffer(lpNewOwner->TC_Console);
        lpserver->TS_ConsoleOwner = dwNewOwner;


        TraceUpdateConsoleTitle(lpNewOwner);

    }
    else
    if (lpOldOwner == NULL || !TRACE_CLIENT_USES_CONSOLE(lpOldOwner)) {

        //
        // no owner was found, and the current owner is gone
        // set the owner ID to MAX_CLIENT_COUNT, thereby
        // guaranteeing that the next console client
        // will become the console owner
        //

        lpserver->TS_ConsoleOwner = MAX_CLIENT_COUNT;
    }


    return 0;
}


// assumes server lock
VOID
SetWaitArray(
    LPTRACE_SERVER lpserver
    )
{
    //
    // reset array for client change notifications.
    // only used if server thread is not created
    //
    {
        LPTRACE_CLIENT *lplpc, *lplpcstart, *lplpcend;
        
        g_posBase = POS_TABLE;

        g_hWaitHandles[POS_TABLE] = lpserver->TS_TableEvent;

        g_posLast = POS_CLIENT_0;
        lplpcstart = lpserver->TS_ClientTable;
        lplpcend = lpserver->TS_ClientTable + MAX_CLIENT_COUNT;

        for (lplpc = lplpcstart; lplpc < lplpcend; lplpc++) {
            if (*lplpc != NULL && TRACE_CLIENT_USES_REGISTRY(*lplpc)) {
                g_hWaitHandles[g_posLast++] = (*lplpc)->TC_ConfigEvent;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\worker.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    common\trace\worker.c

Abstract:
    Worker threads for the router process

Revision History:

    Gurdeep Singh Pall          7/28/95  Created

    12-10-97: lokeshs:  removed blocking of InitializeWorkerThread()
                        on initialization of the first AlertableThread() created

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <rtutils.h>


//
// #includes for the wait-server threads
//
#include "wt.h"
#include "wtproto.h"
#include "trace.h"
#include "workerinc.h"
#include "wttrace.h"


//
// Global variables for wait-server threads
//
WAIT_THREAD_GLOBAL    WTG;




//
// Functions for asynchronous receives.
// Currently #def 0. If these functions are to be enabled, then
// all files #including rtutils.h should use winsock2.h
//

#if 0

//------------------------------------------------------------------------------//
//          ProcessAsyncRecv                                                    //
// This function runs the callback registered with the asynchronous receive     //
//------------------------------------------------------------------------------//
VOID
WINAPI
ProcessAsyncRecv(
    DWORD           dwErrorCode,
    DWORD           dwNumBytesRecv,
    LPOVERLAPPED    lpOverlapped
    )
{
    PASYNC_SOCKET_DATA     pSockData;

    TRACE_ENTER("ProcessAsyncRecv: going to run the user function");

    pSockData = CONTAINING_RECORD(lpOverlapped, ASYNC_SOCKET_DATA, Overlapped);

    UNREFERENCED_PARAMETER (dwErrorCode);

    pSockData->NumBytesReceived = dwNumBytesRecv;

    TRACE1(RECEIVE, "Received %d bytes size packet", dwNumBytesRecv);
    ((WORKERFUNCTION)pSockData->pFunction)(pSockData);


    TRACE_LEAVE("ProcessAsyncRecv: ran the user function");

    return;
}



//------------------------------------------------------------------------------//
//          AsyncSocketInit                                                     //
// This function binds the socket with the IoCompletionPort, that is used to    //
// wait for the asynchronous receives                                           //
//------------------------------------------------------------------------------//
DWORD
APIENTRY
AsyncSocketInit (
    SOCKET    sock
    )
{
    HANDLE     hTemp;
    DWORD    dwErr;

    // initialize worker threads if not yet done
    if (!ENTER_WORKER_API) {
        dwErr = GetLastError();
        return (dwErr == NO_ERROR ? ERROR_CAN_NOT_COMPLETE : dwErr);
    }

    TRACE_ENTER("AsyncSocketInit()");

    hTemp = CreateIoCompletionPort((HANDLE)sock, WorkQueuePort,
                                    (ULONG)ProcessAsyncRecv, 0);

    if (hTemp!=WorkQueuePort) {
        dwErr = GetLastError();
        return dwErr;
     }

    TRACE_LEAVE("AsyncSocketInit()");

    return NO_ERROR;
}


//------------------------------------------------------------------------------//
//          AsyncWSARecvFrom                                                    //
// This function calls the WSARecvFrom                                          //                                                        //
//------------------------------------------------------------------------------//
DWORD
APIENTRY
AsyncWSARecvFrom (
    SOCKET        sock,
    PASYNC_SOCKET_DATA    pSockData
    )
{

    DWORD    dwFromLen;
    DWORD    dwErr;

    TRACE_ENTER("AsyncWSARecvFrom()");

    dwFromLen = sizeof (pSockData->SrcAddress);


    ZeroMemory((PVOID)&pSockData->Overlapped, sizeof(OVERLAPPED));
    pSockData->Overlapped.hEvent = NULL;


    dwErr = WSARecvFrom(sock, &pSockData->WsaBuf, 1, &pSockData->NumBytesReceived,
                        &pSockData->Flags,
                        (SOCKADDR FAR *)&pSockData->SrcAddress,
                        &dwFromLen, &pSockData->Overlapped, NULL);


    if (dwErr!=SOCKET_ERROR) {
        TRACE0(RECEIVE, "the WSAReceiveFrom returned immediately\n");
    }
    else {
        dwErr = WSAGetLastError();
        if (dwErr!=WSA_IO_PENDING) {
            TRACE1(RECEIVE, "WSARecvFrom() returned in AsyncWSARecvFrom() with error code: %0x", dwErr);
            LOGERR0(WSA_RECV_FROM_FAILED, dwErr);
        }
        else
            TRACE0(RECEIVE, "WSARecvFrom() returned WSA_IO_PENDING in AsyncWSARecvFrom()");
    }

    TRACE_LEAVE("AsyncWSARecvFrom()");
    return NO_ERROR;
}


#endif //#def 0 of the Asynchronous Receive From functions




// Time that thread has to be idle before exiting
LARGE_INTEGER    ThreadIdleTO = {
            (ULONG)(THREAD_IDLE_TIMEOUT*(-10000000)),
            0xFFFFFFFF};
// Time that the worker queue is not served before starting new thread
CONST LARGE_INTEGER    WorkQueueTO = {
            (ULONG)(WORK_QUEUE_TIMEOUT*(-10000000)),
            0xFFFFFFFF};
// Total number of threads
LONG                ThreadCount;
// Number of threads waiting on the completion port
LONG                ThreadsWaiting;
// Min allowed number of threads
LONG                MinThreads;
// Completion port for threads to wait on
HANDLE              WorkQueuePort;
// Timer to intiate creation of new thread if worker queue is not
// server within a timeout
HANDLE              WorkQueueTimer;


// Queue for alertable work items
LIST_ENTRY          AlertableWorkQueue ;
// Lock for the alertable work item queue
CRITICAL_SECTION    AlertableWorkQueueLock ;
// Heap for alertable work items
HANDLE              AlertableWorkerHeap ;
// Worker Semaphore used for releasing alertable worker threads
HANDLE              AlertableThreadSemaphore;
// Number of alertable threads
LONG                AlertableThreadCount;


volatile LONG WorkersInitialized=WORKERS_NOT_INITIALIZED;



//* WorkerThread()
//
//  Function: Thread to execute work items in.
//
//  Returns:  Nothing
//
//*
DWORD APIENTRY
WorkerThread (
    LPVOID    param
    ) {
        // It'll be waiting
    InterlockedIncrement (&ThreadsWaiting);
    do {
        LPOVERLAPPED_COMPLETION_ROUTINE completionRoutine;
        NTSTATUS                        status;
        PVOID                           context;
        IO_STATUS_BLOCK                 ioStatus;

        status = NtRemoveIoCompletion (
                            WorkQueuePort,
                            (PVOID *)&completionRoutine,
                            &context,
                            &ioStatus,
                            &ThreadIdleTO);
        if (NT_SUCCESS (status)) {
            switch (status) {
                    // We did dequeue a work item
            case STATUS_SUCCESS:
                if (InterlockedExchangeAdd (&ThreadsWaiting, -1)==1) {
                        // Last thread to wait, start the timer
                        // to create a new thread
                    SetWaitableTimer (WorkQueueTimer,
                                        &WorkQueueTO,
                                        0,
                                        NULL, NULL,
                                        FALSE);
                }
                        // Execute work item/completion routine
                completionRoutine (
                        // Quick check for success that all work items
                        // and most of IRP complete with
                    (ioStatus.Status==STATUS_SUCCESS)
                            ? NO_ERROR
                            : RtlNtStatusToDosError (ioStatus.Status),
                    (DWORD)ioStatus.Information,
                    (LPOVERLAPPED)context);

                if (InterlockedExchangeAdd (&ThreadsWaiting, 1)==0) {
                        // Cancel time if this is the first thread
                        // to return
                    CancelWaitableTimer (WorkQueueTimer);
                }
                break;
                    // Thread was not used for ThreadIdle timeout, see
                    // if we need to quit
            case STATUS_TIMEOUT:
                while (1) {
                        // Make a local copy of the count and
                        // attempt to atomically check and update
                        // it if necessary
                    LONG    count = ThreadCount;

                        // Quick check for min thread condition
                    if (count<=MinThreads)
                        break;
                    else {
                            // Attempt to decrease the count
                                // use another local variable
                                // because of MIPS optimizer bug
                        LONG    newCount = count-1;
                        if (InterlockedCompareExchange (&ThreadCount,
                                                        newCount, count)==count) {
                            // Succeded, exit the thread
                            goto ExitThread;
                        }
                        // else try again
                    }
                }
                break;
            default:
                ASSERTMSG ("Unexpected status code returned ", FALSE);
                break;
            }
        }
        // Execute while we are initialized
    }
    while (WorkersInitialized==WORKERS_INITIALIZED);

ExitThread:
    InterlockedDecrement (&ThreadsWaiting);
    return 0;
}




//* AlertableWorkerThread()
//
//  Function: Alertable work item thread
//
//  Returns:  Nothing
//
//*
DWORD APIENTRY
AlertableWorkerThread (
    LPVOID param
    ) {
    HANDLE      WaitArray [] = {
#define ALERTABLE_THREAD_SEMAPHORE    WAIT_OBJECT_0
                                AlertableThreadSemaphore,
#define WORK_QUEUE_TIMER            (WAIT_OBJECT_0+1)
                                WorkQueueTimer
                                };



    do {
        WorkItem    *workitem;
        DWORD       rc;

        // Wait for signal to run
        //
        rc = WaitForMultipleObjectsEx (
                    sizeof (WaitArray)/sizeof (WaitArray[0]),
                    WaitArray,
                    FALSE,
                    INFINITE,
                        TRUE);
        switch (rc) {
        case ALERTABLE_THREAD_SEMAPHORE:
                // Pick up and execute the worker
            EnterCriticalSection (&AlertableWorkQueueLock);
            ASSERT (!IsListEmpty (&AlertableWorkQueue));
            workitem = (WorkItem *) RemoveHeadList (&AlertableWorkQueue) ;
            LeaveCriticalSection (&AlertableWorkQueueLock);

            (workitem->WI_Function) (workitem->WI_Context);
            HeapFree (AlertableWorkerHeap, 0, workitem);
            break;
        case WORK_QUEUE_TIMER:
                // Work queue has not been served wothin specified
                // timeout
            while (1) {
                    // Make a local copy of the count
                LONG count = ThreadCount;
                    // Make sure we havn't exceded the limit
                if (count>=MAX_WORKER_THREADS)
                    break;
                else {
                    // Try to increment the value
                            // use another local variable
                            // because of MIPS optimizer bug
                    LONG    newCount = count+1;
                    if (InterlockedCompareExchange (&ThreadCount,
                                                    newCount, count)==count) {
                        HANDLE    hThread;
                        DWORD    tid;
                            // Create new thread if increment succeded
                        hThread = CreateThread (NULL, 0, WorkerThread, NULL, 0, &tid);
                        if (hThread!=NULL) {
                            CloseHandle (hThread);
                        }
                        else    // Restore the value if thread creation
                                // failed
                            InterlockedDecrement (&ThreadCount);
                        break;
                    }
                    // else repeat the loop if ThreadCount was modified
                    // while we were checking
                }
            }
            break;
        case WAIT_IO_COMPLETION:
                // Handle IO completion
            break;
        case 0xFFFFFFFF:
                // Error, we must have closed the semaphore handle
            break;
        default:
            ASSERTMSG ("Unexpected rc from WaitForObject ", FALSE);
        }
    }
    while (WorkersInitialized==WORKERS_INITIALIZED);

    return 0 ;
}




//* WorkerCompletionRoutine
//
//  Function:    Worker function wrapper for non-io work items
//
VOID WINAPI
WorkerCompletionRoutine (
    DWORD           dwErrorCode,
    PVOID           ActualContext,
    LPOVERLAPPED    ActualCompletionRoutine
    ) {
    UNREFERENCED_PARAMETER (dwErrorCode);
    ((WORKERFUNCTION)ActualCompletionRoutine)(ActualContext);
}


//* InitializeWorkerThread()
//
//  Function: Called by the first work item
//
//  Returns: WORKERS_INITIALIZED if successful.
//           WORKERS_NOT_INITIALIZED not.
//*
LONG
InitializeWorkerThread (
    LONG    initFlag
    ) {

    DWORD    dwErr;


#if 0
    if (initFlag==WORKERS_INITIALIZING) {
#if DBG
        DbgPrint ("RTUTILS: %lx - waiting for worker initialization.\n", GetCurrentThreadId ());
#endif
        while (WorkersInitialized==WORKERS_INITIALIZING)
            Sleep (100);
#if DBG
        DbgPrint ("RTUTILS: %lx - wait for worker initialization done.\n", GetCurrentThreadId ());
#endif
    }

    if (WorkersInitialized==WORKERS_INITIALIZED) {
        return WORKERS_INITIALIZED;
    }
    else {
        INT         i;
        DWORD       tid;
        HANDLE      threadhandle;
        SYSTEM_INFO    systeminfo;

        // Get number of processors
        //
        GetSystemInfo (&systeminfo) ;

        MinThreads = systeminfo.dwNumberOfProcessors;
        ThreadsWaiting = 0;

        // Init critical section
        //
        InitializeCriticalSection (&AlertableWorkQueueLock);

        // Initialize work queue
        //
        InitializeListHead (&AlertableWorkQueue) ;


        // Allocate private heap
        //
        AlertableWorkerHeap = HeapCreate (0,    // no flags
                                systeminfo.dwPageSize,// initial heap size
                                0);             // no maximum size
        if (AlertableWorkerHeap != NULL) {
            // Create counting semaphore for releasing alertable threads
            AlertableThreadSemaphore = CreateSemaphore(NULL, // No security
                                        0,          // Initial value
                                        MAXLONG,    // Max items to queue
                                        NULL);      // No name
            if (AlertableThreadSemaphore!=NULL) {
                    // Create completion port for work items
                WorkQueuePort = CreateIoCompletionPort (
                            INVALID_HANDLE_VALUE,    // Just create a port, no file yet
                            NULL,                   // New port
                            0,                      // Key is ignored
                            MAX_WORKER_THREADS);    // Number of active threads
                if (WorkQueuePort!=NULL) {
                        // Create timer to trigger creation of
                        // new threads if work queue is not served
                        // for the specified timeout
                    WorkQueueTimer = CreateWaitableTimer (
                                        NULL,       // No security
                                        FALSE,      // auto-reset
                                        NULL);      // No name
                    if (WorkQueueTimer!=NULL) {

                        // Start Alertable threads

                        //
                        //
                        // initialize the global structure for wait threads
                        //
                        dwErr = InitializeWaitGlobal();
                        if (dwErr!=NO_ERROR) {
                            DeInitializeWaitGlobal();
                            goto ThreadCreationError;
                        }


                        /*WTG.g_InitializedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
                        if (WTG.g_InitializedEvent==NULL)
                            goto ThreadCreationError;
                        */

                        //
                        // create one alertable thread and wait for it to get initialized
                        // This makes sure that at least one server thread is initialized
                        // before the others attemp to use it.
                        //

                        i =0;
                        threadhandle = CreateThread (
                                    NULL,    // No security
                                    0,      // Default stack
                                    AlertableWaitWorkerThread,// Start routine
                                    (PVOID)(LONG_PTR)i,        // Thread param
                                    0,      // No flags
                                    &tid);
                        if (threadhandle!=NULL)
                            CloseHandle (threadhandle);
                        else
                            goto ThreadCreationError;

                        /*
                        WaitForSingleObject(WTG.g_InitializedEvent, INFINITE);
                        CloseHandle(WTG.g_InitializedEvent);
                        */

/*
                        //
                        // create the other alertable threads but dont wait on them to
                        // get initialization
                        //
                        for (i=1; i < NUM_ALERTABLE_THREADS; i++) {
                            threadhandle = CreateThread (
                                    NULL,    // No security
                                    0,      // Default stack
                                    AlertableWaitWorkerThread,// Start routine
                                    (PVOID)(LONG_PTR)i,        // Thread id
                                    0,      // No flags
                                    &tid);
                            if (threadhandle!=NULL)
                                CloseHandle (threadhandle);
                            else
                                goto ThreadCreationError;
                        }

*/


                        // Start the rest of worker threads
                        //
                        for (i=0; i < MinThreads; i++) {
                            threadhandle = CreateThread (
                                    NULL,    // No security
                                    0,      // Default stack
                                    WorkerThread,// Start routine
                                    NULL,    // No parameter
                                    0,      // No flags
                                    &tid) ;
                            if (threadhandle!=NULL)
                                CloseHandle (threadhandle);
                            else
                                goto ThreadCreationError;
                        }
                        ThreadCount = i;
                        WorkersInitialized = WORKERS_INITIALIZED;
                        return WORKERS_INITIALIZED;
                    ThreadCreationError:
                        // Cleanup in case of failure
                        // Threads will exit by themselves when objects are
                        // deleted
                        CloseHandle (WorkQueueTimer);
                    }
                    CloseHandle (WorkQueuePort);
                }
                CloseHandle (AlertableThreadSemaphore);
            }
            HeapDestroy (AlertableWorkerHeap);
        }
        DeleteCriticalSection (&AlertableWorkQueueLock);

#if DBG
        DbgPrint ("RTUTILS: %lx - worker initialization failed (%ld).\n",
                        GetCurrentThreadId (), GetLastError ());
#endif
        return WORKERS_NOT_INITIALIZED;
    }
#endif
        return WORKERS_NOT_INITIALIZED;
    
}

//* StopWorkers()
//
//  Function: Cleanup worker thread when dll is unloaded
//
//*
VOID
StopWorkers (
    VOID
    ) {
        // Make sure we were initialized
    if (WorkersInitialized==WORKERS_INITIALIZED) {
            // All work items should have been completed
            // already (no other components should be using
            // our routines or we shouldn't have been unloaded)

            // Set the flag telling all threads to quit
        WorkersInitialized = WORKERS_NOT_INITIALIZED;
            // Close all syncronization objects (this should
            // terminate the wait)
        CloseHandle (WorkQueueTimer);
        CloseHandle (WorkQueuePort);
        CloseHandle (AlertableThreadSemaphore);
            // Let threads complete
        Sleep (1000);
            // Destroy the rest
        HeapDestroy (AlertableWorkerHeap);
        DeleteCriticalSection (&AlertableWorkQueueLock);
    }
}


//* QueueWorkItem()
//
//  Function: Queues the supplied work item in the work queue.
//
//  Returns:  0 (success)
//            Win32 error codes for cases like out of memory
//
//*
DWORD APIENTRY
QueueWorkItem (WORKERFUNCTION functionptr, PVOID context, BOOL serviceinalertablethread)
{
    DWORD       retcode ;
    LONG        initFlag;

    // if uninitialized, attempt to initialize worker threads
    //
    if (!ENTER_WORKER_API) {
        retcode = GetLastError();
        return (retcode == NO_ERROR ? ERROR_CAN_NOT_COMPLETE : retcode);
    }

        // based on this flag insert in either the alertablequeue or the workerqueue
        //
    if (!serviceinalertablethread) {
        NTSTATUS status;
            // Use completion port to execute the item
        status = NtSetIoCompletion (
                        WorkQueuePort,          // Port
                        (PVOID)WorkerCompletionRoutine,    // Completion routine
                        functionptr,            // Apc context
                        STATUS_SUCCESS,         // Status
                        (ULONG_PTR)context);        // Information ()
        if (status==STATUS_SUCCESS)
            retcode = NO_ERROR;

        else
            retcode = RtlNtStatusToDosError (status);
    }
    else {
            // Create and queue work item
        WorkItem    *workitem ;
        workitem = (WorkItem *) HeapAlloc (
                                        AlertableWorkerHeap,
                                        0,    // No flags
                                        sizeof (WorkItem));

        if (workitem != NULL) {
            workitem->WI_Function = functionptr ;
            workitem->WI_Context  = context ;

            EnterCriticalSection (&AlertableWorkQueueLock) ;
            InsertTailList (&AlertableWorkQueue, &workitem->WI_List) ;

            LeaveCriticalSection (&AlertableWorkQueueLock) ;
            // let a worker thread run if waiting
            //
            ReleaseSemaphore (AlertableThreadSemaphore, 1, NULL) ;


            retcode = 0 ;

        }
        else
            retcode = GetLastError () ;
    }


    return retcode ;
}

// Function: Associates file handle with the completion port (all
//          asynchronous io on this handle will be queued to the
//          completion port)
//
// FileHandle:    file handle to be associated with completion port
// CompletionProc: procedure to be called when io associated with
//              the file handle completes. This function will be
//              executed in the context of non-alertable worker thread
DWORD
APIENTRY
SetIoCompletionProc (
    IN HANDLE                           FileHandle,
    IN LPOVERLAPPED_COMPLETION_ROUTINE    CompletionProc
    ) {
    HANDLE    hdl;
    LONG    initFlag;
    DWORD    retcode;
    // if uninitialized, attempt to initialize worker threads
    //
    if (!ENTER_WORKER_API) {
        retcode = GetLastError();
        return (retcode == NO_ERROR ? ERROR_CAN_NOT_COMPLETE : retcode);
    }

    hdl = CreateIoCompletionPort (FileHandle,
                            WorkQueuePort,
                            (UINT_PTR)CompletionProc,
                            0);
    if (hdl!=NULL)
        return NO_ERROR;
    else
        return GetLastError ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\workerinc.h ===
#ifndef _WORKERINC_H_
#define _WORKERINC_H_

//
// EXTERN GLOBAL DECLARATIONS OF WORKER.C
//


extern LARGE_INTEGER            ThreadIdleTO;
extern CONST LARGE_INTEGER      WorkQueueTO;
extern LONG                     ThreadCount;
extern LONG                     ThreadsWaiting;
extern LONG                     MinThreads;
extern HANDLE                   WorkQueuePort;
extern HANDLE                   WorkQueueTimer;
extern LIST_ENTRY               AlertableWorkQueue ;
extern CRITICAL_SECTION         AlertableWorkQueueLock ;
extern HANDLE                   AlertableWorkerHeap ;
extern HANDLE                   AlertableThreadSemaphore;
extern LONG                     AlertableThreadCount;


#define WORKERS_NOT_INITIALIZED 0
#define WORKERS_INITIALIZING    -1
#define WORKERS_INITIALIZED     1
extern volatile LONG WorkersInitialized;


#define ENTER_WORKER_API (                                                  \
    (InterlockedCompareExchange (                                           \
                (PLONG)&WorkersInitialized,                                 \
                WORKERS_INITIALIZING,                                       \
                WORKERS_NOT_INITIALIZED)==WORKERS_NOT_INITIALIZED)          \
        ? (InitializeWorkerThread(WORKERS_NOT_INITIALIZED)==WORKERS_INITIALIZED)    \
        : ((WorkersInitialized==WORKERS_INITIALIZED)                        \
            ? TRUE                                                          \
            : InitializeWorkerThread(WORKERS_INITIALIZING))                 \
    )

LONG
InitializeWorkerThread (
    LONG    initFlags
    );

DWORD APIENTRY
WorkerThread (
    LPVOID      param
    );

struct WorkItem {
    LIST_ENTRY      WI_List ;       // link to next and prev element
    WORKERFUNCTION  WI_Function ;   // function to call
    PVOID           WI_Context ;    // context passed into function call
} ;

typedef struct WorkItem WorkItem ;

DWORD APIENTRY
WorkerThread (
    LPVOID      param
    );

#endif //_WORKERINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\trace.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: trace.h
//
// History:
//    Abolade Gbadegesin    July-24-1995    Created
//
// Private declarations for tracing API functions
//
// Support for both ANSI and Unicode is achieved by having separate
// versions of all code-page dependent functions for each.
// All source files containing code-page dependent functions contain only
// code-page dependent functions, and the build instructions copy the
// source files containing code-page dependent functions to two separate
// files, one of which is compiled with UNICODE defined, the other without.
//
// At this time the macros in this header file are resolved either to
// ANSI declarations or Unicode declarations for types and functions.
// Thus there is only one set of sources to maintain but compilation produces
// separate execution paths for clients using ANSI and Unicode.

// For example the file api.c which contains TraceRegisterEx will be copied
// to both api_a.c and api_w.c, and api_w.c will be compiled with -DUNICODE
// causing TraceRegisterEx in the file to resolve to TraceRegisterExW,
// and causing TCHAR and LPTSTR and LPCTSTR to resolve to WCHAR, LPWSTR, and
// LPCWSTR respectively; api_a.c will be compiled with UNICODE undefined,
// causing TraceRegisterEx to resolve to TraceRegisterExA, and causing TCHAR,
// LPTSTR and LPCTSTR to resolve to CHAR, LPSTR and LPCSTR respectively.
// The final DLL will then contain both TraceRegisterExA and TraceRegisterExW
// and clients which define UNICODE will end up invoking TraceRegisterExW
// and the other Unicode variants, while clients which do not will invoke
// TraceRegisterExA and the other ANSI variants.
//
// The server thread and the functions it invokes include explicit
// calls to the correct code-page dependent function based on whether the
// flag TRACEFLAGS_UNICODE is set in the client structure being operated on.
// Thus, the server is the only part of the system aware that more than one
// code page is in use, and the file server.c is compiled as is so the 
// single set of its functions deals with both ANSI and Unicode clients.
// The alternative would be to have two server threads when both
// ANSI and Unicode clients register in a single process, but this alternative
// is too costly in terms of resources and additional synchronization.
//============================================================================
    

#ifndef _TRACE_H_
#define _TRACE_H_


#define TRACEFLAGS_DISABLED     0x00000001
#define TRACEFLAGS_USEFILE      0x00000002
#define TRACEFLAGS_USECONSOLE   0x00000004
#define TRACEFLAGS_REGCONFIG    0x00000008
#define TRACEFLAGS_SERVERTHREAD 0x00000010


#define MAX_CLIENT_COUNT        60
#define MAX_CLIENTNAME_LENGTH   64


//
// strings associated with client registry configuration 
//

#define REGKEY_TRACING          TEXT("Software\\Microsoft\\Tracing")

#define REGVAL_ENABLEFILETRACING    TEXT("EnableFileTracing")
#define REGVAL_ENABLECONSOLETRACING TEXT("EnableConsoleTracing")
#define REGVAL_FILETRACINGMASK      TEXT("FileTracingMask")
#define REGVAL_CONSOLETRACINGMASK   TEXT("ConsoleTracingMask")
#define REGVAL_MAXFILESIZE          TEXT("MaxFileSize")
#define REGVAL_FILEDIRECTORY        TEXT("FileDirectory")

#define DEF_ENABLEFILETRACING       0
#define DEF_ENABLECONSOLETRACING    0
#define DEF_FILETRACINGMASK         0xffff0000
#define DEF_CONSOLETRACINGMASK      0xffff0000
#define DEF_MAXFILESIZE             0x100000
#define DEF_FILEDIRECTORY           TEXT("%windir%\\tracing")

#define DEF_SCREENBUF_WIDTH         128
#define DEF_SCREENBUF_HEIGHT        5000

//max line length:349
#define DEF_PRINT_BUFSIZE           10000
#define BYTES_PER_DUMPLINE          16

#define STR_DIRSEP                  TEXT("\\")
#define STR_LOGEXT                  TEXT(".LOG")
#define STR_OLDEXT                  TEXT(".OLD")



//
// structure describing each client.
// a client struct should be locked for writing when
//  enabling or disabling it, and when loading its configuration
// a client struct should be locked for reading on all other accesses
// 

typedef struct _TRACE_CLIENT {

    RTL_RESOURCE        ReadWriteLock;

    DWORD               TC_Flags;
    DWORD               TC_ClientID;

    CHAR                TC_ClientNameA[MAX_CLIENTNAME_LENGTH];
    WCHAR               TC_ClientNameW[MAX_CLIENTNAME_LENGTH];
#ifdef UNICODE
#define TC_ClientName   TC_ClientNameW
#else
#define TC_ClientName   TC_ClientNameA
#endif

    HANDLE              TC_File;
    HANDLE              TC_Console;
    DWORD               TC_FileMask;
    DWORD               TC_ConsoleMask;
    DWORD               TC_MaxFileSize;

    CHAR                TC_FileDirA[MAX_PATH];
    WCHAR               TC_FileDirW[MAX_PATH];

#ifdef UNICODE
#define TC_FileDir      TC_FileDirW
#else
#define TC_FileDir      TC_FileDirA
#endif

    HKEY                TC_ConfigKey;
    HANDLE              TC_ConfigEvent;

} TRACE_CLIENT, *LPTRACE_CLIENT;



//
// structure describing each server.
// a server struct must be locked for writing when adding
//  or removing a client to the client table, and when changing
//  the owner of the console
// a server should be locked for reading on all other accesses
//

typedef struct _TRACE_SERVER {

    RTL_RESOURCE        ReadWriteLock;

    DWORD               TS_Flags;
    DWORD               TS_ClientCount;
    DWORD               TS_ConsoleOwner;

    HANDLE              TS_Console;
    HANDLE              TS_StopEvent;
    HANDLE              TS_TableEvent;

    DWORD               TS_FlagsCache[MAX_CLIENT_COUNT];
    LPTRACE_CLIENT      TS_ClientTable[MAX_CLIENT_COUNT];


} TRACE_SERVER, *LPTRACE_SERVER;


#define GET_TRACE_SERVER() (                                    \
    (g_server!=NULL) ? g_server : TraceCreateServer(&g_server)	\
    )

#define GET_TRACE_SERVER_NO_INIT()	(g_server)

//
// macros used to lock client and server structures
//
#define TRACE_STARTUP_LOCKING(ob)                                       \
            RtlInitializeResource(&(ob)->ReadWriteLock)
#define TRACE_CLEANUP_LOCKING(ob)                                       \
            RtlDeleteResource(&(ob)->ReadWriteLock)
#define TRACE_ACQUIRE_READLOCK(ob)                                      \
            RtlAcquireResourceShared(&(ob)->ReadWriteLock, TRUE)
#define TRACE_RELEASE_READLOCK(ob)                                      \
            RtlReleaseResource(&(ob)->ReadWriteLock)
#define TRACE_ACQUIRE_WRITELOCK(ob)                                     \
            RtlAcquireResourceExclusive(&(ob)->ReadWriteLock, TRUE)
#define TRACE_RELEASE_WRITELOCK(ob)                                     \
            RtlReleaseResource(&(ob)->ReadWriteLock)
#define TRACE_READ_TO_WRITELOCK(ob)                                     \
            RtlConvertSharedToExclusive(&(ob)->ReadWriteLock)
#define TRACE_WRITE_TO_READLOCK(ob)                                     \
            RtlConvertExclusiveToShared(&(ob)->ReadWriteLock)


//
// macros used to interpret client flags
//
#define TRACE_CLIENT_IS_DISABLED(c)                                     \
            ((c)->TC_Flags & TRACEFLAGS_DISABLED)
#define TRACE_CLIENT_USES_FILE(c)                                       \
            ((c)->TC_Flags & TRACEFLAGS_USEFILE)
#define TRACE_CLIENT_USES_CONSOLE(c)                                    \
            ((c)->TC_Flags & TRACEFLAGS_USECONSOLE)
#define TRACE_CLIENT_USES_REGISTRY(c)                                   \
            ((c)->TC_Flags & TRACEFLAGS_REGCONFIG)
#define TRACE_CLIENT_USES_UNICODE(c)                                    \
            ((c)->TC_Flags & TRACEFLAGS_UNICODE)


// macro used to create server thread if required

DWORD
TraceCreateServerThread (
    DWORD Flags,
    BOOL bHaveLock,
    BOOL bTraceRegister
    );
    
#define CREATE_SERVER_THREAD_IF_REQUIRED()   {\
    if (!g_serverThread) TraceCreateServerThread(0, FALSE,FALSE);}



//
// code-page independent function declarations
//
LPTRACE_SERVER
TraceCreateServer(
    LPTRACE_SERVER *lpserver
    );

BOOL
TraceShutdownServer(
    LPTRACE_SERVER lpserver
    );

DWORD
TraceCleanUpServer(
    LPTRACE_SERVER lpserver
    );

DWORD
TraceServerThread(
    LPVOID lpvParam
    );

DWORD
TraceCreateServerComplete(
    LPTRACE_SERVER lpserver
    );


DWORD
TraceProcessConsoleInput(
    LPTRACE_SERVER lpserver
    );

DWORD
TraceShiftConsoleWindow(
    LPTRACE_CLIENT lpclient,
    INT iXShift,
    INT iYShift,
    PCONSOLE_SCREEN_BUFFER_INFO pcsbi
    );

DWORD
TraceUpdateConsoleOwner(
    LPTRACE_SERVER lpserver,
    INT dir
    );

VOID
SetWaitArray(
    LPTRACE_SERVER lpserver
    );


//
// code-page dependent function declarations
//
// ANSI declarations
//

LPTRACE_CLIENT
TraceFindClientA(
    LPTRACE_SERVER lpserver,
    LPCSTR lpszClient
    );

DWORD
TraceCreateClientA(
    LPTRACE_CLIENT *lplpentry
    );

DWORD
TraceDeleteClientA(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT *lplpentry
    );

DWORD
TraceEnableClientA(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient,
    BOOL bFirstTime
    );

DWORD
TraceDisableClientA(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient
    );

DWORD
TraceRegConfigClientA(
    LPTRACE_CLIENT lpclient,
    BOOL bFirstTime
    );

DWORD
TraceRegCreateDefaultsA(
    LPCSTR lpszTracing,
    PHKEY phkeyTracing
    );

DWORD
TraceOpenClientConsoleA(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient
    );

DWORD
TraceCloseClientConsoleA(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient
    );

DWORD
TraceCreateClientFileA(
    LPTRACE_CLIENT lpclient
    );

DWORD
TraceMoveClientFileA(
    LPTRACE_CLIENT lpclient
    );

DWORD
TraceCloseClientFileA(
    LPTRACE_CLIENT lpclient
    );

DWORD
TraceWriteOutputA(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient,
    DWORD dwFlags,
    LPCSTR lpszOutput
    );

DWORD
TraceUpdateConsoleTitleA(
    LPTRACE_CLIENT lpclient
    );

DWORD
TraceDumpLineA(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient,
    DWORD dwFlags,
    LPBYTE lpbBytes,
    DWORD dwLine,
    DWORD dwGroup,
    BOOL bPrefixAddr,
    LPBYTE lpbPrefix,
    LPCSTR lpszPrefix
    );

DWORD
TraceVprintfInternalA(
    DWORD dwTraceID,
    DWORD dwFlags,
    LPCSTR lpszFormat,
    va_list arglist
    );


//
// Unicode declarations
//
LPTRACE_CLIENT
TraceFindClientW(
    LPTRACE_SERVER lpserver,
    LPCWSTR lpszClient
    );

DWORD
TraceCreateClientW(
    LPTRACE_CLIENT *lplpentry
    );

DWORD
TraceDeleteClientW(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT *lplpentry
    );

DWORD
TraceEnableClientW(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient,
    BOOL bFirstTime
    );

DWORD
TraceDisableClientW(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient
    );

DWORD
TraceRegConfigClientW(
    LPTRACE_CLIENT lpclient,
    BOOL bFirstTime
    );

DWORD
TraceRegCreateDefaultsW(
    LPCWSTR lpszTracing,
    PHKEY phkeyTracing
    );

DWORD
TraceOpenClientConsoleW(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient
    );

DWORD
TraceCloseClientConsoleW(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient
    );

DWORD
TraceCreateClientFileW(
    LPTRACE_CLIENT lpclient
    );

DWORD
TraceMoveClientFileW(
    LPTRACE_CLIENT lpclient
    );

DWORD
TraceCloseClientFileW(
    LPTRACE_CLIENT lpclient
    );

DWORD
TraceWriteOutputW(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient,
    DWORD dwFlags,
    LPCWSTR lpszOutput
    );

DWORD
TraceUpdateConsoleTitleW(
    LPTRACE_CLIENT lpclient
    );

DWORD
TraceDumpLineW(
    LPTRACE_SERVER lpserver,
    LPTRACE_CLIENT lpclient,
    DWORD dwFlags,
    LPBYTE lpbBytes,
    DWORD dwLine,
    DWORD dwGroup,
    BOOL bPrefixAddr,
    LPBYTE lpbPrefix,
    LPCWSTR lpszPrefix
    );

DWORD
TraceVprintfInternalW(
    DWORD dwTraceID,
    DWORD dwFlags,
    LPCWSTR lpszFormat,
    va_list arglist
    );




//
// code-page independent macro definitions
//

#ifdef UNICODE
#define TraceFindClient                 TraceFindClientW
#define TraceCreateClient               TraceCreateClientW
#define TraceDeleteClient               TraceDeleteClientW
#define TraceEnableClient               TraceEnableClientW
#define TraceDisableClient              TraceDisableClientW
#define TraceRegConfigClient            TraceRegConfigClientW
#define TraceRegCreateDefaults          TraceRegCreateDefaultsW
#define TraceOpenClientConsole          TraceOpenClientConsoleW
#define TraceCloseClientConsole         TraceCloseClientConsoleW
#define TraceCreateClientFile           TraceCreateClientFileW
#define TraceMoveClientFile             TraceMoveClientFileW
#define TraceCloseClientFile            TraceCloseClientFileW
#define TraceWriteOutput                TraceWriteOutputW
#define TraceUpdateConsoleTitle         TraceUpdateConsoleTitleW
#define TraceDumpLine                   TraceDumpLineW
#define TraceVprintfInternal            TraceVprintfInternalW
#else
#define TraceFindClient                 TraceFindClientA
#define TraceCreateClient               TraceCreateClientA
#define TraceDeleteClient               TraceDeleteClientA
#define TraceEnableClient               TraceEnableClientA
#define TraceDisableClient              TraceDisableClientA
#define TraceRegConfigClient            TraceRegConfigClientA
#define TraceRegCreateDefaults          TraceRegCreateDefaultsA
#define TraceOpenClientConsole          TraceOpenClientConsoleA
#define TraceCloseClientConsole         TraceCloseClientConsoleA
#define TraceCreateClientFile           TraceCreateClientFileA
#define TraceMoveClientFile             TraceMoveClientFileA
#define TraceCloseClientFile            TraceCloseClientFileA
#define TraceWriteOutput                TraceWriteOutputA
#define TraceUpdateConsoleTitle         TraceUpdateConsoleTitleA
#define TraceDumpLine                   TraceDumpLineA
#define TraceVprintfInternal            TraceVprintfInternalA
#endif


// global data declarations
//
extern LPTRACE_SERVER g_server;
extern HANDLE g_serverThread;

#endif  // _TRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\wt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    common\rtutils\wt.h.c

Abstract:
    Worker threads for the router process

Revision History:

    K.S.Lokesh

created
    

--*/
#ifndef _WT_H_
#define _WT_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rtutils.h>
#include <stdlib.h>
#include <stdio.h>
#include "wttrace.h"
#include "log.h"



#define WT_STATUS_CREATED       0
#define WT_STATUS_REGISTERED    1
#define WT_STATUS_INACTIVE      3
#define WT_STATUS_ACTIVE        0x4
#define WT_STATUS_FIRED         0x8
#define WT_STATUS_DELETED       0xFFFFFFFF

//
// WAIT_THREAD_ENTRY structure maintained by each wait-thread
//
typedef struct _WAIT_THREAD_ENTRY {

    DWORD                wte_ServerId;                          // id of the wait thread 
    DWORD                wte_ThreadId;                          // thread id of the wait thread server
    DWORD                wte_NumClients; 
    
    // list for timers/events
    LIST_ENTRY          wteL_ClientEventEntries;                // list of current client events
    LIST_ENTRY          wteL_ClientTimerEntries;                // list of current client timers
    HANDLE              wte_Timer;
    LONGLONG            wte_Timeout;                            // time when the timer is set to go off
    CRITICAL_SECTION    wte_CSTimer;

    
    // array for WaitForMultipleObjects
    #define EVENTS_ARRAY_SZ    2*MAXIMUM_WAIT_OBJECTS
    PWT_EVENT_ENTRY        wteA_EventMapper[EVENTS_ARRAY_SZ];        // maps to list entries
    HANDLE                 wteA_Events[EVENTS_ARRAY_SZ];            // for WaitForMultipleObjects()

    DWORD                wte_LowIndex;
    DWORD                wte_NumTotalEvents;
    DWORD                wte_NumActiveEvents;            
    DWORD                wte_NumHighPriorityEvents;
    DWORD                wte_NumActiveHighPriorityEvents;
    
    // adding/deleting events/timers
    HANDLE              wte_ClientNotifyWTEvent;                // client->: there are events to be added
    HANDLE              wte_WTNotifyClientEvent;                // WT->client: the events have been added

    DWORD               wte_ChangeType;
    PLIST_ENTRY         wtePL_EventsToChange;
    PLIST_ENTRY         wtePL_TimersToChange;
    PWT_WORK_ITEM       wteP_BindingToChange;
    // add events and then bindings. delete bindings and then events

    #define                CHANGE_TYPE_NONE    0
    #define                CHANGE_TYPE_ADD        1
    #define                CHANGE_TYPE_DELETE  3
    #define                CHANGE_TYPE_BIND_FUNCTION_ADD 4
    #define                CHANGE_TYPE_BIND_FUNCTION_DELETE 5
    
    DWORD               wte_Status;
    DWORD               wte_RefCount;
    LIST_ENTRY          wte_Links;                            
    CRITICAL_SECTION    wte_CS;
     
} WAIT_THREAD_ENTRY, *PWAIT_THREAD_ENTRY;

#define NUM_CLIENT_EVENTS_FREE(pwte) \
          (MAXIMUM_WAIT_OBJECTS - pwte->wte_NumTotalEvents)

#define EA_OVERFLOW(pwte, numEventsToAdd) \
    (((DWORD)pwte->wte_LowIndex + pwte->wte_NumActiveEvents + numEventsToAdd) \
    > (EVENTS_ARRAY_SZ-1))

#define EA_EXISTS_LOW_PRIORITY_EVENT(pwte) \
    ((pwte->wte_NumActiveEvents - pwte->wte_NumActiveHighPriorityEvents) > 0)

#define EA_INDEX_LOW_LOW_PRIORITY_EVENT(pwte) \
    (pwte->wte_LowIndex + pwte->wte_NumActiveHighPriorityEvents)


#define EA_INDEX_HIGH_LOW_PRIORITY_EVENT(pwte) \
    (pwte->wte_LowIndex + pwte->wte_NumActiveEvents -1)

#define EA_INDEX_LOW_HIGH_PRIORITY_EVENT(pwte) \
    (pwte->wte_LowIndex)

#define EA_INDEX_HIGH_HIGH_PRIORITY_EVENT(pwte) \
    (pwte->wte_LowIndex + pwte->wte_NumActiveHighPriorityEvents - 1)

//
// WAIT_THREAD_GLOBAL structure 
//
typedef struct _WAIT_THREAD_GLOBAL {

    DWORD               g_Initialized;
    
    LIST_ENTRY          gL_WaitThreadEntries;

    HANDLE              g_Heap;
    
    //HANDLE                g_InitializedEvent;        // set after 1st alertable thread is initialized
    
    CRITICAL_SECTION    g_CS;
    DWORD               g_TraceId;
    DWORD               g_LogLevel;
     HANDLE             g_LogHandle;
     
} WAIT_THREAD_GLOBAL, *PWAIT_THREAD_GLOBAL ;



//
// EXTERN GLOBAL VARIABLES
//

extern WAIT_THREAD_GLOBAL    WTG;

// 
// PROTOTYPE DECLARATIONS
//


    
// Create the events and the timer for a server
// called by server only
DWORD
CreateServerEventsAndTimer (
    IN    PWAIT_THREAD_ENTRY    pwte
    );


// creates a wait thread entry and initializes it
DWORD
CreateWaitThreadEntry (
    IN      DWORD                dwThreadId,
    OUT     PWAIT_THREAD_ENTRY   *ppwte
    );

    
// deinitializes the global structure for wait-thread
DWORD
DeInitializeWaitGlobal(
    );

DWORD
DeleteClientEvent (
    IN    PWT_EVENT_ENTRY       pee,
    IN    PWAIT_THREAD_ENTRY    pwte
    );

// removes a wait server thread from the list of servers
DWORD
DeleteWaitThreadEntry (
    IN    PWAIT_THREAD_ENTRY    pwte
    );

DWORD
DeRegisterClientEventBinding (
    IN    PWAIT_THREAD_ENTRY    pwte
    );
    
DWORD
DeRegisterClientEventsTimers (
    IN     PWAIT_THREAD_ENTRY   pte
    );



VOID
FreeWaitEventBinding (
    IN    PWT_WORK_ITEM    pwiWorkItem
    );
    
DWORD
FreeWaitThreadEntry (
    IN    PWAIT_THREAD_ENTRY    pwte
    );

    
// returns a wait thread which has the required number of free events
PWAIT_THREAD_ENTRY
GetWaitThread (
    IN    DWORD    dwNumEventsToAdd,
    IN    DWORD    dwNumTimersToAdd
    );


// initialize the global data structure for all wait threads
DWORD
InitializeWaitGlobal(
    );


// Insert the event in the events array and the map array
VOID
InsertInEventsArray (
    PWT_EVENT_ENTRY       pee,
    PWAIT_THREAD_ENTRY    pwte
    );

    
// insert an event entry in the events list and increment counters
VOID
InsertInEventsList (
    PWT_EVENT_ENTRY       pee,
    PWAIT_THREAD_ENTRY    pwte
    );

    
// insert the new wait server thread into a list of increasing ServerIds
DWORD
InsertWaitThreadEntry (
    IN    PWAIT_THREAD_ENTRY    pwteInsert
    );


DWORD
RegisterClientEventLocal (
    IN    PWT_EVENT_ENTRY       pee,
    IN    PWAIT_THREAD_ENTRY    pwte
    );

DWORD
RegisterClientEventBinding (
    IN    PWAIT_THREAD_ENTRY    pwte
    );

    
// Process event: waitable timer fired
VOID
WorkerFunction_WaitableTimer(
    PVOID pContext
    );

VOID
WorkerFunction_ProcessClientNotifyWTEvent (
    IN    PVOID pContext
    );

VOID
WorkerFunction_ProcessWorkQueueTimer (
    IN    PVOID pContext
    );

VOID
WorkerFunction_ProcessAlertableThreadSemaphore (
    IN    PVOID pContext
    );


    
//
// APIS
//

//
// The client has the lock on the server
DWORD
AddClientEvent (
    IN    PWT_EVENT_ENTRY        pee,
    IN    PWAIT_THREAD_ENTRY     pwte
    );



// The client has the lock on the server
DWORD
AddClientTimer (
    PWT_TIMER_ENTRY        pte,
    PWAIT_THREAD_ENTRY  pwte
    );


DWORD 
APIENTRY
AlertableWaitWorkerThread (
    LPVOID param
    );


DWORD
DeleteClientTimer (
    PWT_TIMER_ENTRY     pte,
    PWAIT_THREAD_ENTRY  pwte
    );


VOID
FreeWaitEvent (
    IN    PWT_EVENT_ENTRY    peeEvent
    );


VOID
FreeWaitTimer (
    IN    PWT_TIMER_ENTRY pte
    );

    
DWORD
RegisterClientEventsTimers (
    PWAIT_THREAD_ENTRY    pwte
    );





//
// #defines
//

#define WT_MALLOC(sz)  HeapAlloc(WTG.g_Heap,0,(sz))
#define WT_FREE(p)     HeapFree(WTG.g_Heap, 0, (p))
#define WT_FREE_NOT_NULL(p)   ((p) ? WT_FREE(p) : TRUE)





//
// MACROS
//
#define ENTER_WAIT_API() \
      ((ENTER_WORKER_API) && (WTG.g_Initialized==0x12345678))

      
#define SET_TIMER_INFINITE(time) \
    time = 0


#define IS_TIMER_INFINITE(time) \
    (time == 0)


#endif     // _WT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\wt.c ===
#include "wt.h"
#include "wtproto.h"
#include "workerinc.h"

//----------------------------------------------------------------------------------//
//                                         WorkerFunction_ProcessClientNotifyWTEvent                                    //
//      the client has locks on wte_CS, so that no one can add or delete                                //
//  if you need to add timers, you have to take lock on wte_CSTimer                                     //
//----------------------------------------------------------------------------------//
VOID
WorkerFunction_ProcessClientNotifyWTEvent (
        IN      PVOID pContext
    )
{
        PWAIT_THREAD_ENTRY      pwte;
        BOOL                            bLockTimer;


        pwte = (PWAIT_THREAD_ENTRY) pContext;
        TRACE0(ENTER, "Entering WorkerFunction_ProcessClientNotifyWTEvent:");

        switch (pwte->wte_ChangeType) {

                case CHANGE_TYPE_ADD :
                        RegisterClientEventsTimers(pwte);
                        break;

                case CHANGE_TYPE_DELETE :
                        DeRegisterClientEventsTimers(pwte);
                        break;

                case CHANGE_TYPE_BIND_FUNCTION_ADD :
                        RegisterClientEventBinding(pwte);
                        break;

                case CHANGE_TYPE_BIND_FUNCTION_DELETE :
                        DeRegisterClientEventBinding(pwte);
                        break;
        }

        SET_EVENT(pwte->wte_WTNotifyClientEvent, "wte_WTNotifyClientEvent",
                                "WorkerFunction_ProcessClientNotifyWTEvent");
        TRACE0(LEAVE, "Leaving WorkerFunction_ProcessClientNotifyWTEvent:");
        return;

} //end WorkerFunction_ProcessClientNotifyWTEvent


//----------------------------------------------------------------------------------//
//                                       WorkerFunction_ProcessWorkQueueTimer                                                   //
//----------------------------------------------------------------------------------//
VOID
WorkerFunction_ProcessWorkQueueTimer (
        IN      PVOID pContext
    )
{

        TRACE0(ENTER, "Entering WorkerFunction_ProcessWorkQueueTimer:");


        // Work queue has not been served within specified
    // timeout
    while (1) {
            // Make a local copy of the count
        LONG   count = ThreadCount;
            // Make sure we havn't exceded the limit
        if (count>=MAX_WORKER_THREADS)
            break;
        else {
            // Try to increment the value
                    // use another local variable
                    // because of MIPS optimizer bug
            LONG    newCount = count+1;
            if (InterlockedCompareExchange (&ThreadCount,
                                            newCount, count)==count) {
                HANDLE  hThread;
                DWORD   tid;
                    // Create new thread if increment succeded
                hThread = CreateThread (NULL, 0, WorkerThread, NULL, 0, &tid);
                if (hThread!=NULL) {
                    CloseHandle (hThread);
                }
                else    // Restore the value if thread creation
                        // failed
                    InterlockedDecrement (&ThreadCount);
                break;
            }
            // else repeat the loop if ThreadCount was modified
            // while we were checking
        }
    }

        TRACE0(LEAVE, "Leaving WorkerFunction_ProcessWorkQueueTimer:");
    return;

} //end WorkerFunction_ProcessWorkQueueTimer


//----------------------------------------------------------------------------------//
//                                       WorkerFunction_ProcessAlertableThreadSemaphore                                 //
//----------------------------------------------------------------------------------//
VOID
WorkerFunction_ProcessAlertableThreadSemaphore (
        IN      PVOID pContext
    )
{
        WorkItem    *workitem;


        TRACE0(ENTER, "Entering WorkerFunction_ProcessAlertableThreadSemaphore:");

        EnterCriticalSection(&AlertableWorkQueueLock);
    ASSERT (!IsListEmpty (&AlertableWorkQueue));
    workitem = (WorkItem *) RemoveHeadList (&AlertableWorkQueue) ;
    LeaveCriticalSection(&AlertableWorkQueueLock);

    (workitem->WI_Function) (workitem->WI_Context);
    HeapFree (AlertableWorkerHeap, 0, workitem);

        TRACE0(LEAVE, "Leaving WorkerFunction_ProcessAlertableThreadSemaphore:");
    return;
}

//++-------------------------------------------------------------------------------*//
//                                       WorkerFunction_ProcessWaitableTimer                                                            //
// Process event: waitable timer fired                                                                                          //
// takes lock on wte_CSTimer and releases it in the end                                                         //
//----------------------------------------------------------------------------------//
VOID
WorkerFunction_ProcessWaitableTimer(
    IN  PVOID pContext
    )
{
        PWAIT_THREAD_ENTRY      pwte;
        LONGLONG                        liCurrentTime;
        PLIST_ENTRY                     ple, pHead, pleCurrent;
        PWT_TIMER_ENTRY         pte;
        BOOL                            bActiveTimers;

        TRACE0(ENTER, "Entering WorkerFunction_ProcessWaitableTimer:");


        pwte = (PWAIT_THREAD_ENTRY) pContext;


        // get lock on server threads timer
        ENTER_CRITICAL_SECTION(&pwte->wte_CSTimer, "wte_CSTimer", "WorkerFunction_ProcessWaitableTimer");

        NtQuerySystemTime((LARGE_INTEGER*) &liCurrentTime);


        // ordered in increasing time, with inactive timers at the end
        pHead = &pwte->wteL_ClientTimerEntries;
        for (ple=pHead->Flink;  ple!=pHead;  ) {
                pte = CONTAINING_RECORD(ple, WT_TIMER_ENTRY, te_ServerLinks);

                if (pte->te_Status == TIMER_INACTIVE)           // inactive timers at end of list
                        break;

                if (IS_TIMER_INFINITE(pte->te_Timeout)) { //should have been inactive
                        ple = ple->Flink;
                        continue;
                }

                if (pte->te_Timeout<=liCurrentTime) {
                        //
                        // set timer status to inactive and insert at end of timer queue
                        //
                        pte->te_Status = TIMER_INACTIVE;
                        SET_TIMER_INFINITE(pte->te_Timeout);

                        pleCurrent = ple;
                        ple = ple->Flink;
                        RemoveEntryList(pleCurrent);
                        InsertTailList(pHead, pleCurrent);


                        // run the function in current thread or dispatch to worker thread
                        //
                        if (pte->te_RunInServer) {
                                (pte->te_Function)(pte->te_Context);
                        }
                        else {
                                QueueWorkItem( pte->te_Function, pte->te_Context, FALSE ); // do not run in alertable thread
                        }
                }

                else {
                        break;
                }

        }

        //
        // search for active timers with timeout which is not infinite
        //

        if (IsListEmpty(pHead))
                bActiveTimers = FALSE;
        else {
                ple = pHead->Flink;

                pte = CONTAINING_RECORD(ple, WT_TIMER_ENTRY, te_ServerLinks);

                bActiveTimers = (pte->te_Status==TIMER_INACTIVE) ? FALSE : TRUE;
        }

        //
        // if active timers present, then set waitableTimer
        //
        if (bActiveTimers) {

                // set next timeout value for the wait server
                pwte->wte_Timeout = pte->te_Timeout;
                TRACE2(TIMER, "SetWaitableTimer set to <%lu:%lu> after being fired",
                                        TIMER_HIGH(pte->te_Timeout), TIMER_LOW(pte->te_Timeout));

                SetWaitableTimer(pwte->wte_Timer, (LARGE_INTEGER*)&pte->te_Timeout, 0, NULL, NULL, FALSE);
        }

        // no active timer in queue. do not set the waitable timer
        else {
                SET_TIMER_INFINITE(pwte->wte_Timeout);
        }

#if DBG2
        DebugPrintWaitWorkerThreads(DEBUGPRINT_FILTER_EVENTS);
#endif
        LEAVE_CRITICAL_SECTION(&pwte->wte_CSTimer, "wte_CSTimer", "WorkerFunction_ProcessWaitableTimer");

        TRACE0(LEAVE, "Leaving WorkerFunction_ProcessWaitableTimer:");
        return;

} //end WorkerFunction_ProcessWaitableTimer


//---------------------------------------------------------------------------------*//
//                                      CreateServerEventsAndTimer                                                                      //
// Create the events for a server and the timer(called by server only)                          //
// assumes lock on server and server timer structure                                                            //
// THIS FUNCTION SHOULD NOT HAVE ANY CALLS TO API FUNCTIONS                                                     //
//----------------------------------------------------------------------------------//
DWORD
CreateServerEventsAndTimer (
        IN      PWAIT_THREAD_ENTRY      pwte
        )
{
        PWT_EVENT_ENTRY peeWaitableTimer, peeClientNotifyWTEvent,
                                        peeAlertableThreadSemaphore, peeWorkQueueTimer;


        // waitable timer (set to infinity time)
        peeWaitableTimer = CreateWaitEvent(
                                                                pwte->wte_Timer,
                                                                NULL, FALSE, FALSE, NULL,
                                                                TRUE,   // highPriority
                                                                (WORKERFUNCTION) WorkerFunction_ProcessWaitableTimer,
                                                                (PVOID)pwte,    // context
                                                                0,              // context size=0, as just a pointer value is being passed
                                                                TRUE    // run in server context
                                                           );

        if (!peeWaitableTimer)
            return ERROR_NOT_ENOUGH_MEMORY;

        peeWaitableTimer->ee_EventId = 1;
        RegisterClientEventLocal(peeWaitableTimer, pwte);

        // ClientNotifyWTEvent
        peeClientNotifyWTEvent = CreateWaitEvent(
                                                                        pwte->wte_ClientNotifyWTEvent,
                                                                        NULL, FALSE, FALSE, NULL,
                                                                        TRUE,   // highPriority
                                                                        (WORKERFUNCTION) WorkerFunction_ProcessClientNotifyWTEvent,
                                                                        (PVOID)pwte,    // context
                                                                        0,              // context size=0, as just a pointer value is being passed
                                                                        TRUE    // run in server context
                                                                   );
        if (!peeClientNotifyWTEvent )
            return ERROR_NOT_ENOUGH_MEMORY;

        peeClientNotifyWTEvent->ee_EventId = 2;
        RegisterClientEventLocal(peeClientNotifyWTEvent, pwte);


        // AlertableThreadSemaphore
        peeAlertableThreadSemaphore = CreateWaitEvent(
                                                                                AlertableThreadSemaphore,
                                                                                NULL, FALSE, FALSE, NULL,
                                                                                FALSE,  // Priority=low
                                                                                (WORKERFUNCTION) WorkerFunction_ProcessAlertableThreadSemaphore,
                                                                                NULL,   // context
                                                                                0,              // context size=0, as just a pointer value is being passed
                                                                                TRUE    // run in server context
                                                                           );
        peeAlertableThreadSemaphore->ee_EventId = 3;
        RegisterClientEventLocal(peeAlertableThreadSemaphore, pwte);


        // WorkQueueTimer
        peeWorkQueueTimer = CreateWaitEvent(
                                                                WorkQueueTimer,
                                                                NULL, FALSE, FALSE, NULL,
                                                                FALSE,  // Priority=low
                                                                (WORKERFUNCTION) WorkerFunction_ProcessWorkQueueTimer,
                                                                NULL,   // context
                                                                0,              // context size=0, as just a pointer value is being passed
                                                                TRUE    // run in server context
                                                           );
        peeWorkQueueTimer->ee_EventId = 4;
        RegisterClientEventLocal(peeWorkQueueTimer, pwte);


        return NO_ERROR;

} //end CreateServerEventsAndTimer

//---------------------------------------------------------------------------------*//
//                                      InitializeWaitGlobal                                                                                    //
// initialize the global data structure for all wait threads                                            //
//----------------------------------------------------------------------------------//
DWORD
InitializeWaitGlobal(
        )
{
        BOOL    bErr;
        DWORD   dwErr = NO_ERROR;



        ZeroMemory(&WTG, sizeof(WTG));

        WTG.g_Initialized = 0x12345678;


        //
        // initialize tracing and logging
        //
        WTG.g_TraceId = TraceRegister("WAIT_THREAD");
        //todo:set the logging level
        WTG.g_LogLevel = WT_LOGGING_ERROR;
        WTG.g_LogHandle = RouterLogRegister("WAIT_THREAD");

        TRACE0(ENTER, "Entering InitializeWaitGlobal()");



        //
        // initialize global structure
        //
        bErr = FALSE;
        do { // error breakout loop

                //
                // create a private heap for Wait-Thread
                //

                WTG.g_Heap = AlertableWorkerHeap;                               // created in worker.c
                if (WTG.g_Heap==NULL)
                        WTG.g_Heap = HeapCreate(0, 0, 0);

                if (WTG.g_Heap == NULL) {

                        dwErr = GetLastError();
                        TRACE1(
                        ANY, "error %d creating Wait-Thread global heap", dwErr
                        );
                        LOGERR0(HEAP_CREATE_FAILED, dwErr);

                        bErr = FALSE;
                        break;
                }



                // initialize list for wait thread entries
                //
                InitializeListHead(&WTG.gL_WaitThreadEntries);



                // initialize critical section
                //
                try {
                InitializeCriticalSection(&WTG.g_CS);
                }
                except (EXCEPTION_EXECUTE_HANDLER) {
                dwErr = GetExceptionCode();
                TRACE1(
                         ANY, "exception %d initializing global critical section",
                         dwErr
                         );
                LOGERR0(INIT_CRITSEC_FAILED, dwErr);

                        bErr = TRUE;
                break;
                }


        } while (FALSE);

        TRACE1(LEAVE, "leaving InitializeWaitGlobal: %d", dwErr);

        if (bErr)
                return dwErr;
        else
                return NO_ERROR;

} //end InitializeWaitGlobal


//---------------------------------------------------------------------------------*//
//                                      DeInitializeWaitGlobal                                                                                  //
//deinitializes the global structure for wait-thread                                                            //
//todo: free the server entries and the event/timers etc associated with them           //
//----------------------------------------------------------------------------------//

DWORD
DeInitializeWaitGlobal(
        )
{
        PLIST_ENTRY                     ple, pHead;
        PWAIT_THREAD_ENTRY      pwte;


        ENTER_CRITICAL_SECTION(&WTG.g_CS, "g_CS", "DeInitializeWaitGlobal");

        if (WTG.g_Initialized==0) {
                LEAVE_CRITICAL_SECTION(&WTG.g_CS, "g_CS", "DeInitializeWaitGlobal");
                TRACE0(LEAVE, "leaving DeInitializeWaitGlobal:Pending");
                return ERROR_CAN_NOT_COMPLETE;
        }
        else
                WTG.g_Initialized = 0;


        //
        // if waitThreadEntries exist, then for each server entry mark each event/binding
        // as deleted and return pending
        //
        if (!IsListEmpty(&WTG.gL_WaitThreadEntries)) {

                pHead = &WTG.gL_WaitThreadEntries;
                for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                        pwte = CONTAINING_RECORD(ple, WAIT_THREAD_ENTRY, wte_Links);
                        ENTER_CRITICAL_SECTION(&pwte->wte_CS, "deleting wte_CS", "DeInitializeWaitGlobal");
                        pwte->wte_Status = WT_STATUS_DELETED;
                }

                //todo should I also mark each event and timer as deleted

                TRACE0(LEAVE, "leaving DeInitializeWaitGlobal:Pending");

                return ERROR_CAN_NOT_COMPLETE;
        }

        DeInitializeWaitGlobalComplete();

        return NO_ERROR;

} //end DeInitializeWaitGlobal

//----------------------DeInitializeWaitGlobalComplete-----------------------------//
DWORD
DeInitializeWaitGlobalComplete (
        )
{

        TRACE0(LEAVE, "leaving DeInitializeWaitGlobal");

        // for each server entry mark each event/binding as deleted
        // and return pending

        TraceDeregister(WTG.g_TraceId);
        RouterLogDeregister(WTG.g_LogHandle);


        // delete critical section
        try{
        DeleteCriticalSection(&WTG.g_CS);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
        }


        // destroy heap
        /*if (WTG.g_Heap != NULL) {
        HeapDestroy(WTG.g_Heap);
        }*/

        return NO_ERROR;

} //end DeInitializeWaitGlobal


//++-------------------------------------------------------------------------------*//
//                                      InsertWaitThreadEntry                                                                                   //
// insert the new wait server thread into a list of increasing ServerIds                        //
// initializes the serverId                                                                                                                     //
// assumes: it has lock on WTG.g_cs, and pwte->wte_CS, and pwte->wte_CSTimer            //
// NO CALLS TO APIS SHOULD BE MADE HERE                                                                                         //
//----------------------------------------------------------------------------------//
DWORD
InsertWaitThreadEntry (
        IN      PWAIT_THREAD_ENTRY      pwteInsert
        )
{
        PLIST_ENTRY                     ple, pHead;
        PWAIT_THREAD_ENTRY      pwte;
        DWORD                           dwServerId;


        //
        // find the lowest unallocated SeverId and insert the new server in the ordered list
        //

        dwServerId = 1;
        pHead = &WTG.gL_WaitThreadEntries;


        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink,dwServerId++) {

                pwte = CONTAINING_RECORD(ple, WAIT_THREAD_ENTRY, wte_Links);

                if (dwServerId==pwte->wte_ServerId) {
                        continue;
                }
                else
                        break;
        }


        // insert in list
        if (dwServerId==1) { // not required. but kept for easy understanding
                InsertHeadList(&WTG.gL_WaitThreadEntries, &pwteInsert->wte_Links);
        }
        else {
                InsertTailList(ple, &pwteInsert->wte_Links);
        }

        // set serverId
        pwteInsert->wte_ServerId = dwServerId;


        pwteInsert->wte_Status = WT_STATUS_REGISTERED;

        return NO_ERROR;

} //end InsertWaitThreadEntry


//---------------------------------------------------------------------------------*//
//                                      RemoveWaitThreadEntry                                                                                   //
// removes a wait server thread from the list of servers                                                        //
// assumes: it has lock on WTG.g_cs     and wte_CS                                                                              //
//----------------------------------------------------------------------------------//
DWORD
DeleteWaitThreadEntry (
        IN      PWAIT_THREAD_ENTRY      pwte
        )
{
        // set status to deleted
        pwte->wte_Status = WT_STATUS_DELETED;


        // if RefCount == 0, then remove it from the list and free it

        if (pwte->wte_RefCount==0) {

                // free the wait thread entry
                RemoveEntryList(&pwte->wte_Links);
                FreeWaitThreadEntry(pwte);

                // deinitialize global structure if it is also marked for delete and its
                // WaitThreadEntry list is empty
                if ((WTG.g_Initialized==WT_STATUS_DELETED)
                        &&(IsListEmpty(&WTG.gL_WaitThreadEntries)))
                {
                        DeInitializeWaitGlobalComplete();
                }

        }
        return NO_ERROR;
}


//---------------------------------------------------------------------------------*//
//                                      CreateWaitThreadEntry                                                                                   //
// creates a wait thread entry and initializes it                                                                       //
// no locks required                                                                                                                            //
//----------------------------------------------------------------------------------//
DWORD
CreateWaitThreadEntry (
        IN      DWORD                           dwThreadId,
        OUT     PWAIT_THREAD_ENTRY      *ppwte
        )
{
        PWAIT_THREAD_ENTRY      pwte;
        DWORD                           dwErr = NO_ERROR;
        BOOL                            bErr = TRUE;



        TRACE0(ENTER, "Entering CreateWaitThreadEntry");

        //
        // allocate wait-thread-entry entry
        //
        *ppwte = pwte = WT_MALLOC(sizeof(WAIT_THREAD_ENTRY));
        if (pwte == NULL) {

                dwErr = GetLastError();
                TRACE2(
                ANY, "error %d allocating %d bytes for wait-thread-entry",
                dwErr, sizeof(WAIT_THREAD_ENTRY)
                );
                LOGERR0(HEAP_ALLOC_FAILED, dwErr);

        return dwErr;
        }

        ZeroMemory(pwte, sizeof(WAIT_THREAD_ENTRY));


        //
        // initialize global structure
        //

        do { // error breakout loop


                // critical section
                try {
                InitializeCriticalSection(&pwte->wte_CS);
                }
                except (EXCEPTION_EXECUTE_HANDLER) {
                dwErr = GetExceptionCode();
                TRACE1(
                         ANY, "exception %d initializing global critical section",
                         dwErr
                         );
                LOGERR0(INIT_CRITSEC_FAILED, dwErr);

                break;
                }



                // current clients
                //server id is set when it is inserted into global list
                pwte->wte_ThreadId = dwThreadId;                                                //ServerId is assigned during insertion of wte
                pwte->wte_NumClients = 0;


                // list for events/timers
                InitializeListHead(&pwte->wteL_ClientEventEntries);
                InitializeListHead(&pwte->wteL_ClientTimerEntries);



                // create waitable timer
                pwte->wte_Timer = CreateWaitableTimer(NULL, FALSE, NULL);

                if (pwte->wte_Timer == NULL) {
                        dwErr = GetLastError();
                        TRACE1(
                         ANY, "error creating waitable timer",
                         dwErr
                         );
                LOGERR0(CREATE_WAITABLE_TIMER_FAILED, dwErr);

                break;
                }


                SET_TIMER_INFINITE(pwte->wte_Timeout);                  //set timeout to infinity


                // critical section for timers
                try {
                InitializeCriticalSection(&pwte->wte_CSTimer);
                }
                except (EXCEPTION_EXECUTE_HANDLER) {
                dwErr = GetExceptionCode();
                TRACE1(
                         ANY, "exception %d initializing critical section for timer",
                         dwErr
                         );
                LOGERR0(INIT_CRITSEC_FAILED, dwErr);

                break;
                }


                // array for WaitForMultipleObjects
                pwte->wte_LowIndex = 0;
                pwte->wte_NumTotalEvents = 0;
                pwte->wte_NumActiveEvents = 0;
                pwte->wte_NumHighPriorityEvents = 0;
                pwte->wte_NumActiveHighPriorityEvents = 0;

                //
                // adding/deleting events/timers
                //

                // create event: Client notifies WT: wake up WT to add/delete events/timers
                pwte->wte_ClientNotifyWTEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

                if (pwte->wte_ClientNotifyWTEvent == NULL) {
                        dwErr = GetLastError();
                        TRACE1(START, "error %d creating event Client-notify-WT", dwErr);
                        LOGERR0(CREATE_EVENT_FAILED, dwErr);

                        break;
                }


                // create event: WT notifies Client: the work requested has been done
                pwte->wte_WTNotifyClientEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

                if (pwte->wte_WTNotifyClientEvent == NULL) {
                        dwErr = GetLastError();
                        TRACE1(START, "error:%d creating event WT-notify-Client", dwErr);
                        LOGERR0(CREATE_EVENT_FAILED, dwErr);

                        break;
                }



                // variables used to add/delete events/timers

                pwte->wte_ChangeType = CHANGE_TYPE_NONE;
                pwte->wte_Status = 0;
                pwte->wte_RefCount = 0;
                pwte->wtePL_EventsToChange = NULL;
                pwte->wtePL_TimersToChange = NULL;


                bErr = FALSE;

        } while (FALSE);



        TRACE1(LEAVE, "Leaving CreateWaitThreadEntry: %d", dwErr);

        if (bErr) {
                FreeWaitThreadEntry(pwte);
                return dwErr;
        }
        else
                return NO_ERROR;

}//end CreateWaitThreadEntry


//---------------------------------------------------------------------------------*//
//                                      FreeWaitThreadEntry                                                                                         //
//----------------------------------------------------------------------------------//
DWORD
FreeWaitThreadEntry (
        IN      PWAIT_THREAD_ENTRY      pwte
        )
{
        DWORD           dwErr = NO_ERROR;



        TRACE0(ENTER, "Entering FreeWaitThreadEntry");


        DeleteCriticalSection(&pwte->wte_CS);



        // delete waitable timer
        if (pwte->wte_Timer!=NULL)
                CloseHandle(pwte->wte_Timer);


        DeleteCriticalSection(&pwte->wte_CSTimer);

        // delete event: Client notifies WT
        if (pwte->wte_ClientNotifyWTEvent!=NULL)
                CloseHandle(&pwte->wte_ClientNotifyWTEvent);


        // delete event: WT notifies Client
        if (pwte->wte_WTNotifyClientEvent!=NULL)
                CloseHandle(pwte->wte_WTNotifyClientEvent);


        //
        // free wait-thread-entry record
        //
        WT_FREE(pwte);


        // deinitialize global structure if it is also marked for delete and its
        // WaitThreadEntry list is empty
        if ((WTG.g_Initialized==WT_STATUS_DELETED)
                &&(IsListEmpty(&WTG.gL_WaitThreadEntries)))
        {
                DeInitializeWaitGlobalComplete();
        }


        TRACE1(LEAVE, "Leaving FreeWaitThreadEntry: %d", dwErr);

        return NO_ERROR;

} //end FreeWaitThreadEntry




//----------------------------------------------------------------------------------//
//                                      GetWaitThread                                                                                           //
// returns a wait thread which has the required number of free events                           //
// assumes lock on g_CS.                                                                                                                        //
// if NumTotalEvents is low enough, do interlocked increment.                                           //
//----------------------------------------------------------------------------------//
PWAIT_THREAD_ENTRY
GetWaitThread (
        IN      DWORD   dwNumEventsToAdd,  //==0, if only timers are being added
        IN  DWORD       dwNumTimersToadd
        )
{
        PLIST_ENTRY             ple, pHead;
        PWAIT_THREAD_ENTRY      pwte;
        BOOL                            bFound;
        DWORD                           dwIncrRefCount = dwNumEventsToAdd + dwNumTimersToadd;


        pHead = &WTG.gL_WaitThreadEntries;

        //
        // Locate a wait-thread with required events free.
        //
        bFound = FALSE;
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                pwte = CONTAINING_RECORD(ple, WAIT_THREAD_ENTRY, wte_Links);

                // cannot allocate this server because it is not active
                if ((pwte->wte_Status != WT_STATUS_REGISTERED)
                        && (pwte->wte_Status != WT_STATUS_ACTIVE)
                   )
                {
                        ETRACE0("could not allocate this wte as it is not registered");
                        continue;
                }

                if (NUM_CLIENT_EVENTS_FREE(pwte) >= dwNumEventsToAdd) {

                        // increment RefCount so that it cannot be deleted
                        // interlocked operation as it can be decremented outside g_CS and inside only wte_CS
                        InterlockedExchangeAdd((PLONG)&pwte->wte_RefCount, dwIncrRefCount);

                        InterlockedExchangeAdd((PLONG)&pwte->wte_NumTotalEvents,
                                                                        (LONG)dwNumEventsToAdd);
                        bFound = TRUE;
                        break;
                }
        }

        if (bFound) {

                //shift the wte to the end so that all server threads are balanced
                RemoveEntryList(ple);
                InsertTailList(pHead, ple);

                return pwte;
        }
        else {
                return NULL;
        }
}


//----------------------------------------------------------------------------------//
//                                      RegisterClientEventLocal                                                                                //
// Register the wait event locally                                                                                                      //
// event being registered by the server itself:                                                                         //
// assumes lock on server                                                                                                                       //
// somewhat similar to AddClientEvent                                               //
//----------------------------------------------------------------------------------//
DWORD
RegisterClientEventLocal (
        IN      PWT_EVENT_ENTRY         pee,
        IN      PWAIT_THREAD_ENTRY      pwte
        )
{
        // insert wait event in list of event entries //dont have to do interlocked here
        pwte->wte_RefCount ++;
        pwte->wte_NumTotalEvents ++;


        InsertInEventsList(pee, pwte);


        // insert wait event in array of event entries
        if (pee->ee_bInitialState == FALSE) {
                InsertInEventsArray(pee, pwte);
        }
        else {
                pee->ee_Status = WT_STATUS_INACTIVE + WT_STATUS_FIRED;  // but arrayIndex ==-1
        }


        return NO_ERROR;
}


//----------------------------------------------------------------------------------//
//                                       InsertInEventsList                                                                                     //
// assumes lock on server                                                                                                                       //
// Insert the event in the list and increment the counters                                                      //
// NumTotalEvents has been increased during allocation of the server                            //
//----------------------------------------------------------------------------------//
VOID
InsertInEventsList (
        IN      PWT_EVENT_ENTRY         pee,
        IN      PWAIT_THREAD_ENTRY      pwte
        )
{

        InsertHeadList(&pwte->wteL_ClientEventEntries, &pee->ee_ServerLinks);

        //
        // set fields of event entry
        //
        pee->ee_ServerId = pwte->wte_ServerId;
        pee->eeP_wte = pwte;
        pee->ee_Status = WT_STATUS_REGISTERED;

        //
        // change fields of wait thread entry
        //

        //pwte->wte_RefCount++; //RefCount incremented during allocation
        //pwte->wte_NumTotalEvents ++; //incremented during allocation
        if (pee->ee_bHighPriority) {
                pwte->wte_NumHighPriorityEvents ++;
        }

        return;
}

//----------------------------------------------------------------------------------//
//                                       DeleteFromEventsList                                                                                   //
// NumTotalEvents/Refcount is interlockedDecremented                                                            //
//----------------------------------------------------------------------------------//
VOID
DeleteFromEventsList (
        IN      PWT_EVENT_ENTRY         pee,
        IN      PWAIT_THREAD_ENTRY      pwte
        )
{

        // remove entry from list
        RemoveEntryList(&pee->ee_ServerLinks);

        //
        // set fields of event entry
        //
        pee->ee_Status = WT_STATUS_DELETED;

        //
        // change fields of wait thread entry
        //

        // pwte->wte_NumTotalEvents ++; interlocked incremented during allocation
        if (pee->ee_bHighPriority) {
                pwte->wte_NumHighPriorityEvents --;
        }

        InterlockedDecrement(&pwte->wte_NumTotalEvents);
        // decremented in DeleteClientEventComplete if ee_RefCount is 0
        //InterlockedDecrement(&pwte->wte_RefCount);

        return;
}

//----------------------------------------------------------------------------------//
//                                      DeleteFromEventsArray                                                                                   //
// pee: status is not set to inactive, but array pointer is set to -1                           //
// pwte: decrement active counters                                                                                                      //
//----------------------------------------------------------------------------------//
VOID
DeleteFromEventsArray (
        IN      PWT_EVENT_ENTRY         pee,
        IN      PWAIT_THREAD_ENTRY      pwte
        )
{
        INT             iIndex;
        DWORD   dwCount;

        iIndex = pee->ee_ArrayIndex;
        dwCount = pwte->wte_NumActiveEvents + pwte->wte_LowIndex - iIndex - 1;

        // shift right part towards left if its size is smaller
        if (dwCount <= pwte->wte_NumActiveEvents/2) {
                EventsArray_MoveOverlap (
                                        pwte,
                                        iIndex,  //dstn
                                        iIndex+1,       //src
                                        dwCount //count
                                    );
        }
        // shift left part towards right
        else {
                EventsArray_MoveOverlap (
                                        pwte,
                                        pwte->wte_LowIndex+1,  //dstn
                                        pwte->wte_LowIndex,     //src
                                        pwte->wte_NumActiveEvents - dwCount -1  //count
                                    );
                pwte->wte_LowIndex ++;
        }


        // set fields of event entry
        //
        pee->ee_ArrayIndex = -1;

        // change fields of wait thread entry
        //
        pwte->wte_NumActiveEvents --;
        if (pee->ee_bHighPriority) {
                pwte->wte_NumActiveHighPriorityEvents--;
        }
}//end DeleteFromEventsArray



//----------------------------------------------------------------------------------//
//                                      InsertInEventsArray                                                                                             //
// assumes lock on server:wte_CS        :todo is the lock required                                              //
// Insert the event in the events array and the map array       (no checks are performed)//
// pee: status set to active, set index to array position                                                       //
// pwte: increment active counters                                                                                                      //
//----------------------------------------------------------------------------------//
VOID
InsertInEventsArray (
        IN      PWT_EVENT_ENTRY         pee,
        IN      PWAIT_THREAD_ENTRY      pwte
        )
{
        INT             iIndex;


        // if the array is filled to the extreme right, then shift all events to the left end
        if (EA_OVERFLOW(pwte, 1))
                        EventsArray_CopyLeftEnd(pwte);


        //
        // get index where it has to be inserted
        //
        if (pee->ee_bHighPriority) {

                // the highPriority event has to be moved to the place right of the righmost HighPriority event
                iIndex = EA_INDEX_LOW_LOW_PRIORITY_EVENT(pwte);
                //copy the 1st low priority event to end+1;
                if (EA_EXISTS_LOW_PRIORITY_EVENT(pwte)) {
                        EventsArray_Move(pwte,
                                                         EA_INDEX_HIGH_LOW_PRIORITY_EVENT(pwte)+1,  //dstn
                                                         iIndex,        //src
                                                         1              //count
                                                        );
                }
        }
        else {          // low priority event: insert in the end
                iIndex = EA_INDEX_HIGH_LOW_PRIORITY_EVENT(pwte)+1;

        }


        // insert the event
        EventsArray_InsertEvent(pee, pwte, iIndex);


        // set fields of event entry
        //
        pee->ee_Status = WT_STATUS_ACTIVE;
        pee->ee_ArrayIndex = iIndex;


        // change fields of wait thread entry
        //
        pwte->wte_NumActiveEvents ++;
        if (pee->ee_bHighPriority) {
                pwte->wte_NumActiveHighPriorityEvents++;
        }
}//end InsertInEventsArray



//----------------------------------------------------------------------------------//
//                                      InactivateEvent                                                                                                 //
// Remove the event from the arrays and set the inactive flag                                           //                                                                                      //
// Used with bManual reset                                                                                                                      //
//----------------------------------------------------------------------------------//
VOID
InactivateEvent (
        IN PWT_EVENT_ENTRY      pee
        )
{

        DWORD                           dwIndex;
        PWAIT_THREAD_ENTRY      pwte;


        dwIndex = pee->ee_ArrayIndex;
        pwte = pee->eeP_wte;

        // if event is not at the right end of the array, then events on its right have to be shifted
        if (dwIndex != EA_INDEX_HIGH_LOW_PRIORITY_EVENT(pwte)) {
                EventsArray_MoveOverlap(pwte, dwIndex, dwIndex+1,
                                                (pwte->wte_NumActiveEvents + pwte->wte_LowIndex - dwIndex -1)
                                                );
        }


        //
        // change fields in event entry to make it inactive
        //
        pee->ee_ArrayIndex = -1;
        pee->ee_Status = (pee->ee_Status&WT_STATUS_FIRED) + WT_STATUS_INACTIVE;

        //
        // change fields in wait thread entry
        //
        pwte->wte_NumActiveEvents --;
        if (pee->ee_bHighPriority) {
                pwte->wte_NumActiveHighPriorityEvents --;
        }
        return;
}




//----------------------------------------------------------------------------------//
//                                              EventsArray_CopyLeftEnd                                                                         //
// copy all the events to the left end of the array                                                                     //
// sets the wte_LowIndex value                                                                                                          //
//----------------------------------------------------------------------------------//
VOID
EventsArray_CopyLeftEnd (
        IN      PWAIT_THREAD_ENTRY      pwte
        )
{

        EventsArray_Move(pwte,
                                         0,                                             //dstn
                                         pwte->wte_LowIndex,            //src
                                         pwte->wte_NumActiveEvents      //count
                                        );

        //
        // change fields of wait thread entry
        //
        pwte->wte_LowIndex = 0;

        return;
}

//----------------------------------------------------------------------------------//
//                                              EventsArray_Move                                                                                        //
// copy dwCount events from the srcIndex to dstnIndex (no overlap)                                      //
//----------------------------------------------------------------------------------//
VOID
EventsArray_Move (
        IN      PWAIT_THREAD_ENTRY      pwte,
        IN      DWORD   dwDstnIndex,
        IN      DWORD   dwSrcIndex,
        IN      DWORD   dwCount
        )
{
        PWT_EVENT_ENTRY pee;
        DWORD   i;

        if (dwCount==0)
                return;

        CopyMemory( &pwte->wteA_Events[dwDstnIndex],
                                &pwte->wteA_Events[dwSrcIndex],
                                sizeof(HANDLE) * dwCount
                          );

        CopyMemory( &pwte->wteA_EventMapper[dwDstnIndex],
                                &pwte->wteA_EventMapper[dwSrcIndex],
                                sizeof(PWT_EVENT_ENTRY) * dwCount
                          );

        for (i=0;  i<dwCount;  i++) {
                pee = pwte->wteA_EventMapper[dwDstnIndex + i];
                pee->ee_ArrayIndex = dwDstnIndex + i;
        }
        return;
}

//----------------------------------------------------------------------------------//
//                                              EventsArray_MoveOverlap                                                                         //
// copy dwCount events from the srcIndex to dstnIndex (with overlap)                            //
//----------------------------------------------------------------------------------//
VOID
EventsArray_MoveOverlap (
        IN      PWAIT_THREAD_ENTRY      pwte,
        IN      DWORD   dwDstnIndex,
        IN      DWORD   dwSrcIndex,
        IN      DWORD   dwCount
        )
{
        PWT_EVENT_ENTRY pee;
        DWORD   i;

        if (dwCount==0)
                return;

        MoveMemory( &pwte->wteA_Events[dwDstnIndex],
                                &pwte->wteA_Events[dwSrcIndex],
                                sizeof(HANDLE) * dwCount
                          );

        MoveMemory( &pwte->wteA_EventMapper[dwDstnIndex],
                                &pwte->wteA_EventMapper[dwSrcIndex],
                                sizeof(PWT_EVENT_ENTRY) * dwCount
                          );

        for (i=0;  i<dwCount;  i++) {
                pee = pwte->wteA_EventMapper[dwDstnIndex + i];
                pee->ee_ArrayIndex = dwDstnIndex + i;
        }
        return;
}


//----------------------------------------------------------------------------------//
//                                      EventsArray_InsertEvent                                                                                 //
// Insert the event in the events array and the map array                                                       //
//----------------------------------------------------------------------------------//
VOID
EventsArray_InsertEvent (
        IN      PWT_EVENT_ENTRY         pee,
        IN      PWAIT_THREAD_ENTRY      pwte,
        IN      INT                                     iIndex
        )
{
        // insert event in events array
        pwte->wteA_Events[iIndex] = pee->ee_Event;

        // insert pointer in map array
        pwte->wteA_EventMapper[iIndex] = pee;

        return;
}



//---------------------------------------------------------------------------------*//
//                                      GetListLength                                                                                                   //
// returns the length of the list                                                                                                       //
// returns 0 if the list contains the header only                                                                       //
//----------------------------------------------------------------------------------//
INT
GetListLength (
        IN      PLIST_ENTRY     pHead
        )
{
        PLIST_ENTRY             ple;
        DWORD                   dwCount=0;

        if (pHead==NULL)
                return -1;

        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

                dwCount++;
        }

        return dwCount;

}

VOID
PrintEvent (
        PWT_EVENT_ENTRY pee,
        DWORD                   level
        )
{
        PLIST_ENTRY             pHead, ple;
        PWT_WORK_ITEM   pwi;

        if (pee->ee_Event==NULL)
                printf("        Event is NULL\n");

        printf("--      -------------------------------------------------------------------------\n");

        printf("--      <%2d><ee_bManualReset:%2d>   <ee_bInitialState:%2d>   <ee_Status:%2d>  <ee_bHighPriority:%2d>\n",
                                pee->ee_EventId, pee->ee_bManualReset, pee->ee_bInitialState, pee->ee_Status,
                                pee->ee_bHighPriority);

        printf("--      <ee_bSignalSingle:%2d>      <ee_bOwnerSelf:%2d>       <ee_ArrayIndex:%2d> <ee_ServerId:4%d>\n",
                                pee->ee_bSignalSingle, pee->ee_bOwnerSelf, pee->ee_ArrayIndex, pee->ee_ServerId);
        printf("--      <ee_RefCount:%d\n",     pee->ee_RefCount);
        pHead = &pee->eeL_wi;
        printf("--      LIST OF EVENT BINDINGS\n");
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                pwi = CONTAINING_RECORD(ple, WT_WORK_ITEM, wi_ServerLinks);
                printf("--              <wi_ContextSz:%lu>      <wi_RunInServer:%d>      <wiP_ee:%lu>\n",
                                pwi->wi_ContextSz,  pwi->wi_RunInServer, (UINT_PTR)(PVOID)pwi->wiP_ee);
        }

        return;
}



VOID
PrintTimer (
        PWT_TIMER_ENTRY         pte,
        DWORD                           level
        )
{

        LARGE_INTEGER   li;
        TRACE0(WAIT_TIMER,"__      ________________________________________________________________________");
        TRACE4(WAIT_TIMER, "__      <TimerId:%2d><Timeout:%lu:%lu>   <te_ContextSz:%lu>",
                                        pte->te_TimerId, TIMER_HIGH(pte->te_Timeout), TIMER_LOW(pte->te_Timeout), pte->te_ContextSz);
        TRACE3(WAIT_TIMER, "__      <te_RunInServer:%1d>  <te_Status:%1d>   <te_ServerId:%d>",
                                        pte->te_RunInServer, pte->te_Status, pte->te_ServerId);

        return;
}


//----------------------------------------------------------------------------------//
//          PrintWaitThreadEntry                                                    //
// Prints the events and timers registered with this server.                        //
//----------------------------------------------------------------------------------//
VOID
PrintWaitThreadEntry (
        PWAIT_THREAD_ENTRY      pwte,
        DWORD                           level
        )
{
        PLIST_ENTRY                     ple, pHead;
        PWT_EVENT_ENTRY         pee;
        PWT_TIMER_ENTRY         pte;
        DWORD                           dwHigh, dwLow;
        LARGE_INTEGER           li;
        BOOL                            bPrint;
        DWORD                           i;


        TRACE0(WAIT_TIMER, "\n");
        TRACE0(WAIT_TIMER, "=================================================================================");
        TRACE3(WAIT_TIMER, "== <wte_ServerId:%2lu>        <wte_ThreadId:%2lu> <wte_NumClients:%2lu>",
                                pwte->wte_ServerId, pwte->wte_ThreadId, pwte->wte_NumClients);
        TRACE2(WAIT_TIMER, "== <wte_Status:%2lu>  <wte_RefCount:%2lu>", pwte->wte_Status, pwte->wte_RefCount);


        //
        // print list of events registered
        //
        if (!(level&DEBUGPRINT_FILTER_EVENTS)) {

                TRACE0(WAIT_TIMER, "-- ");
                TRACE0(WAIT_TIMER, "---------------------------------------------------------------------------------");
                TRACE2(WAIT_TIMER,"-- <wte_LowIndex:%2lu>         <wte_NumTotalEvents:%2lu>",
                                        pwte->wte_LowIndex, pwte->wte_NumTotalEvents);
                TRACE2(WAIT_TIMER, "-- <wte_NumActiveEvents:%2lu>  <wte_NumHighPriorityEvents:%2lu>",
                                        pwte->wte_NumActiveEvents, pwte->wte_NumHighPriorityEvents);
                TRACE1(WAIT_TIMER, "-- <wte_NumActiveHighPriorityEvents:%2lu>", pwte->wte_NumActiveHighPriorityEvents);


                if (level&0x2) {//dont print the initial 4 reserved events
                        bPrint = FALSE;
                        i = 0;
                }
                else
                        bPrint = TRUE;

                TRACE0(WAIT_TIMER, "--");
                pHead = &pwte->wteL_ClientEventEntries;
                for (ple=pHead->Blink;  ple!=pHead;  ple=ple->Blink) {
                        if (!bPrint) {
                                if (++i==4)
                                        bPrint=TRUE;
                                continue;
                        }

                        pee = CONTAINING_RECORD(ple, WT_EVENT_ENTRY, ee_ServerLinks);
                        PrintEvent(pee, level);
                }

                for (i=0;  i<=10; i++) {
                        if (pwte->wteA_EventMapper[i]==NULL)
                                TRACE0(WAIT_TIMER, "--");
                        else
                                TRACE2(WAIT_TIMER, "<%d:%d>", (pwte->wteA_EventMapper[i])->ee_EventId,
                                                        (pwte->wteA_EventMapper[i])->ee_ArrayIndex);
                }

        }


        //
        // print list of timers registered
        //
        if (!(level&DEBUGPRINT_FILTER_TIMERS)) {
                li = *(LARGE_INTEGER*)(PVOID)&pwte->wte_Timeout;
                dwHigh = li.HighPart;
                dwLow = li.LowPart;

                TRACE0(WAIT_TIMER, "--");
                TRACE0(WAIT_TIMER,"_________________________________________________________________________________");
                TRACE2(WAIT_TIMER, "__ <wte_Timeout.high:%lu> <wte_Timeout.low:%lu>", dwHigh, dwLow);
                pHead = &pwte->wteL_ClientTimerEntries;
                for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                        pte = CONTAINING_RECORD(ple, WT_TIMER_ENTRY, te_ServerLinks);
                        PrintTimer(pte, level);
                }
        }

        return;

} //PrintWaitThreadEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\sources.inc ===
CPS_BUILD_ROOT=$(CPS_ROOT)\build\$(_OBJ_DIR)

INCLUDES=$(CPS_ROOT)\inc;$(CPS_ROOT)\inc\$(O)

!if !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG
!endif

!ifdef DEBUG_MEM
C_DEFINES=$(C_DEFINES) -DDEBUG_MEM
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\wttrace.h ===
#ifndef _WT_TRACE_H_
#define _WT_TRACE_H_


#define TRACEID         WTG.g_TraceId

//
// constants and macros used for tracing 
//

#define WT_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define WT_TRACE_ENTER           ((DWORD)0x00010000 | TRACE_USE_MASK)
#define WT_TRACE_LEAVE           ((DWORD)0x00020000 | TRACE_USE_MASK)

#define WT_TRACE_TIMER           ((DWORD)0x00100000 | TRACE_USE_MASK)
#define WT_TRACE_RECEIVE         ((DWORD)0x00200000 | TRACE_USE_MASK)
#define WT_TRACE_CS				 ((DWORD)0x00400000 | TRACE_USE_MASK)
#define WT_TRACE_EVENT			 ((DWORD)0x00800000 | TRACE_USE_MASK)

#define WT_TRACE_WT				 ((DWORD)0x01000000 | TRACE_USE_MASK)
#define WT_TRACE_START           ((DWORD)0x02000000 | TRACE_USE_MASK)
#define WT_TRACE_STOP            ((DWORD)0x04000000 | TRACE_USE_MASK)
#define WT_TRACE_WAIT_TIMER      ((DWORD)0x10000000 | TRACE_USE_MASK)



#define WAIT_DBG 1
#if WAIT_DBG
#define ENTER_CRITICAL_SECTION(pcs, type, proc) 			\
			TRACE2(CS,"----To enter %s in %s", type, proc);	\
			EnterCriticalSection(pcs); 						\
			TRACE2(CS,"----Entered %s in %s", type, proc)
			
#define LEAVE_CRITICAL_SECTION(pcs, type, proc) 		\
			TRACE2(CS,"----Left %s in %s", type, proc);	\
			LeaveCriticalSection(pcs)

#define WAIT_FOR_SINGLE_OBJECT( event, time, type, proc) \
		TRACE2(EVENT, "++++To wait for singleObj %s in %s", type, proc);	\
		WaitForSingleObject(event, time);	\
		TRACE2(EVENT, "++++WaitForSingleObj returned %s in %s", type, proc)

#define SET_EVENT(event, type, proc) \
		TRACE2(EVENT, "++++SetEvent %s in %s", type, proc);	\
		SetEvent(event)
		
#else 
#define ENTER_CRITICAL_SECTION(pcs, type, proc) \
			EnterCriticalSection(pcs)
			
#define LEAVE_CRITICAL_SECTION(pcs, type, proc)	\
			LeaveCriticalSection(pcs)
			
#define WAIT_FOR_SINGLE_OBJECT( event, time, type, proc) \
		WaitForSingleObject(event, time)
		
#define SET_EVENT(event, type, proc) \
		SetEvent(event)
			
#endif


#define TRACESTART()            \
            TRACEID = TraceRegister("WAIT_THREAD")
#define TRACESTOP()             \
            TraceDeregister(TRACEID)
#define ETRACE0(a)             \
            TracePrintfEx(TRACEID, WT_TRACE_ANY, a)
#define TRACE0(l,a)             \
            TracePrintfEx(TRACEID, WT_TRACE_ ## l, a)
#define TRACE1(l,a,b)           \
            TracePrintfEx(TRACEID, WT_TRACE_ ## l, a, b)
#define TRACE2(l,a,b,c)         \
            TracePrintfEx(TRACEID, WT_TRACE_ ## l, a, b, c)
#define TRACE3(l,a,b,c,d)       \
            TracePrintfEx(TRACEID, WT_TRACE_ ## l, a, b, c, d)
#define TRACE4(l,a,b,c,d,e)     \
            TracePrintfEx(TRACEID, WT_TRACE_ ## l, a, b, c, d, e)
#define TRACE5(l,a,b,c,d,e,f)   \
            TracePrintfEx(TRACEID, WT_TRACE_ ## l, a, b, c, d, e, f)

#define TRACEDUMP(l,a,b,c)      \
            TraceDumpEx(TRACEID,l,a,b,c,TRUE)


#define DBG2 0
#if DBG 
#define TRACE_ENTER(str) \
		TracePrintfEx(TRACEID, WT_TRACE_ENTER, str)
		
#define TRACE_LEAVE(str) \
		TracePrintfEx(TRACEID, WT_TRACE_LEAVE, str)

#else
#define TRACE_ENTER(str) 		
#define TRACE_LEAVE(str)
#endif




//
// Event logging macros
//

#define LOGLEVEL        WTG.g_LogLevel
#define LOGHANDLE       WTG.g_LogHandle
#define LOGERR          RouterLogError
#define LOGWARN         RouterLogWarning
#define LOGINFO         RouterLogInformation
#define LOGWARNDATA     RouterLogWarningData


//
// constants used for logging
//

#define WT_LOGGING_NONE      0
#define WT_LOGGING_ERROR     1
#define WT_LOGGING_WARN      2
#define WT_LOGGING_INFO      3

// Error logging

#define LOGERR0(msg,err) \
        if (LOGLEVEL >= WT_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,WTLOG_ ## msg,0,NULL,(err))
#define LOGERR1(msg,a,err) \
        if (LOGLEVEL >= WT_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,WTLOG_ ## msg,1,&(a),(err))
#define LOGERR2(msg,a,b,err) \
        if (LOGLEVEL >= WT_LOGGING_ERROR) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGERR(LOGHANDLE,WTLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGERR3(msg,a,b,c,err) \
        if (LOGLEVEL >= WT_LOGGING_ERROR) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGERR(LOGHANDLE,WTLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGERR4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= WT_LOGGING_ERROR) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGERR(LOGHANDLE,WTLOG_ ## msg,4,_asz,(err)); \
        }


// Warning logging

#define LOGWARN0(msg,err) \
        if (LOGLEVEL >= WT_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,WTLOG_ ## msg,0,NULL,(err))
#define LOGWARN1(msg,a,err) \
        if (LOGLEVEL >= WT_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,WTLOG_ ## msg,1,&(a),(err))
#define LOGWARN2(msg,a,b,err) \
        if (LOGLEVEL >= WT_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARN(LOGHANDLE,WTLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGWARN3(msg,a,b,c,err) \
        if (LOGLEVEL >= WT_LOGGING_WARN) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGWARN(LOGHANDLE,WTLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGWARN4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= WT_LOGGING_WARN) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGWARN(LOGHANDLE,WTLOG_ ## msg,4,_asz,(err)); \
        }

#define LOGWARNDATA2(msg,a,b,dw,buf) \
        if (LOGLEVEL >= WT_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARNDATA(LOGHANDLE,WTLOG_ ## msg,2,_asz,(dw),(buf)); \
        }


// Information logging

#define LOGINFO0(msg,err) \
        if (LOGLEVEL >= WT_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,WTLOG_ ## msg,0,NULL,(err))
#define LOGINFO1(msg,a,err) \
        if (LOGLEVEL >= WT_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,WTLOG_ ## msg,1,&(a),(err))
#define LOGINFO2(msg,a,b,err) \
        if (LOGLEVEL >= WT_LOGGING_INFO) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGINFO(LOGHANDLE,WTLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGINFO3(msg,a,b,c,err) \
        if (LOGLEVEL >= WT_LOGGING_INFO) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGINFO(LOGHANDLE,WTLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGINFO4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= WT_LOGGING_INFO) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGINFO(LOGHANDLE,WTLOG_ ## msg,4,_asz,(err)); \
        }








#endif //_WT_TRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\wtapi.c ===
#include "wt.h"
#include "wtproto.h"
#include "workerinc.h"


//////////////////////////////////////////////////////////////////////////////////
//
// create event and register client are separated so that all events/timers can be 
// registered as one atomic operation.
// assumption: you should always register. 
//
// Locks: the server does not need to take lock when changing the arrays/lists
// arrays and lists can be changed by the wait server thread only after it has 
// been signalled
// g_CS, wte_CS, wte_CSTimer -->> order of taking locks
// -- wte_CS always taken by client on behalf of the server:
//        used to lock the list of changes till the changes have completed 
//          (RefCount can decrease now)
//         server locks it only when it is initializing itself


// -- wte_CSTimer taken by client when it wants to change a timer which already
//             exists or by server when it wants to go throught the timer list after 
//          the timer is fired.
//    note: if wte_CS is taken by server then it may lead to deadlock 
//                lock taken by client which wakes up server. server wakes up on 
//              some other event which needs that lock
//      note: wte_CSTimer lock is taken by clients and server independently and not 
//              on behalf of the other. So no possibility of deadlock

// -- g_CS : locked by client for finding which server to use (wte->wte_NumTotalEvents)
// -- g_CS : locked by server to delete itself.

// wte_NumTotalEvents read under g_CS or wte_CS, incremented under g_CS, 
//      decremented under wte_CS
//        so use interlocked operation. you might not have been able to allocate 
//        a server which just then frees events, but this "inconsistency" is fine


// RULES: never free a shared event when other bindings exist
//   //todo: when last event/timer is deleted, delete the wte if deleted flag is set
//   3. all events that have been created have to be registered before deleting them
//     //todo: remove above requirement


// you can call deregister functions from within server thread
// YOU CANNOT CALL FUNCTIONS LIKE DEREGISTER//REGISTER from within a server thread. 
// Be careful when you queue to alertable thread. an alertable thread cannot be 
// client/server at same time.
//
//////////////////////////////////////////////////////////////////////////////////


VOID
APIENTRY
WTFreeEvent (
    IN    PWT_EVENT_ENTRY    peeEvent
    )
{
    if (peeEvent==NULL)
        return;
        
    FreeWaitEvent(peeEvent);
        
    return;
}



VOID
APIENTRY
WTFreeTimer (
    IN PWT_TIMER_ENTRY pteTimer
    )
{
    if (pteTimer==NULL)
        return;

    FreeWaitTimer(pteTimer);
        
    return;
}



VOID
APIENTRY
WTFree (
    PVOID ptr
    )
{
    
    WT_FREE(ptr);
        
    return;
}



//------------------------------------------------------------------------------//            
//            DebugPrintWaitWorkerThreads                                            //
//THE LATEST STATE MAY NOT BE THE ONE YOU EXPECT, eg if you set event and       //
//immediately do debugprint, the alertableThread might not have processed it by //
//the time the enumeration is done                                              //
//------------------------------------------------------------------------------//
VOID
APIENTRY
DebugPrintWaitWorkerThreads (
    DWORD    dwDebugLevel
    )
{
    PLIST_ENTRY             ple, pHead;
    PWAIT_THREAD_ENTRY      pwte;
    DWORD                   dwErr;

    // initialize worker threads if not yet done
    if (!ENTER_WAIT_API()) {
        dwErr = GetLastError();
        return;
     }


    TRACE_ENTER("Entering DebugPrintWaitWorkerThreads");

    ENTER_CRITICAL_SECTION(&WTG.g_CS, "g_CS", "DebugPrintWaitWorkerThreads");

    pHead = &WTG.gL_WaitThreadEntries;
    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

        
         pwte = CONTAINING_RECORD(ple, WAIT_THREAD_ENTRY, wte_Links);

        ENTER_CRITICAL_SECTION(&pwte->wte_CS, "wte_CS", 
                                "DebugPrintWaitWorkerThreads");
        ENTER_CRITICAL_SECTION(&pwte->wte_CSTimer, "wte_CSTimer", 
                                "DebugPrintWaitWorkerThreads");

        PrintWaitThreadEntry(pwte, dwDebugLevel);

        
        LEAVE_CRITICAL_SECTION(&pwte->wte_CSTimer, 
                                "wte_CSTimer", "DebugPrintWaitWorkerThreads");

        LEAVE_CRITICAL_SECTION(&pwte->wte_CS, "wte_CS", 
                                "DebugPrintWaitWorkerThreads");
    }

    LEAVE_CRITICAL_SECTION(&WTG.g_CS, "g_CS", "DebugPrintWaitWorkerThreads");    
    
    TRACE_LEAVE("Leaving DebugPrintWaitWorkerThreads");
    return;
}



//++----------------------------------------------------------------------------//
//                    AlertableWaitWorkerThread                                    //
//------------------------------------------------------------------------------//
DWORD 
APIENTRY
AlertableWaitWorkerThread (
    IN    LPVOID param
    )
{
    
    PWAIT_THREAD_ENTRY  pwte;
    DWORD               dwErr = NO_ERROR;
    DWORD               dwThreadId = GetCurrentThreadId();
    DWORD               dwRetVal, dwIndex;
    BOOL                bBreakout = FALSE;
    //DWORD               dwFirstThread;
    

    //TRACE0(ENTER, "Entering AlertableWaitWorkerThread: ");

    //dwFirstThread = (DWORD) param;

    
    //
    // create the structures and add this thread as one of the aletertable 
    // wait threads.
    //

    // create and initialize wait thread entry
    dwErr = CreateWaitThreadEntry(dwThreadId, &pwte);

    // exit if thread could not be initialized
    if (dwErr!=NO_ERROR) {
        return dwErr;
    }

    //
    // get global lock and insert wait-thread-entry into the list of entries
    //

    EnterCriticalSection(&WTG.g_CS);

    // acquire lock on server thread and timer section before inserting 
    // into global list
    EnterCriticalSection(&pwte->wte_CS);
    EnterCriticalSection(&pwte->wte_CSTimer);

    
    InsertWaitThreadEntry(pwte);


    //THERE SHOULD BE NO CALLS TO RTUTILS APIS IN THIS FUNCTION TILL HERE WHEN 
    //INITIALIZING THE FIRST ALERTABLE THREAD
    // set event so that rest of rtutils initialization can proceed
    /*if (dwFirstThread==0) {
        TRACE0(CS, "Initialization of 1st worker thread done");
        SetEvent(WTG.g_InitializedEvent);        
    }
    */

    //
    // create the initial events and waitable timer
    //
    dwErr = CreateServerEventsAndTimer(pwte);

    
    LeaveCriticalSection(&WTG.g_CS);

    

    // initialization done: release lock on server thread
    LeaveCriticalSection(&pwte->wte_CSTimer);
    LeaveCriticalSection(&pwte->wte_CS);



    //
    // wait for servicing events
    //
    
    do {

        // locks not required as pwteEvents(array,list) can be changed by server 
        // thread only

        TRACE0(CS, "AlertableThread waiting for events:%d");
        dwRetVal = WaitForMultipleObjectsEx(pwte->wte_NumActiveEvents, 
                                           &pwte->wteA_Events[pwte->wte_LowIndex],
                                          FALSE, INFINITE, TRUE);
        TRACE0(CS, "AlertableThread woken by signalled event");

        switch (dwRetVal) {

        case WAIT_IO_COMPLETION:
        {
            // Handled IO completion
            break;
        }
            
        case 0xFFFFFFFF:
        {
            // Error, we must have closed the semaphore handle
               bBreakout = TRUE;
            break;
        }
        
        default:
        {
            PLIST_ENTRY     ple, pHead;
            PWT_WORK_ITEM    pwi;
            PWT_EVENT_ENTRY    pee;
            DWORD            dwCount;


            //
            // wait returned an error
            //
            if (dwRetVal > (WAIT_OBJECT_0+pwte->wte_NumActiveEvents-1))
            {
                bBreakout = TRUE;
                break;
            }

            
            //
            // service the different events
            //
                
                
            // get pointer to event entry
            dwIndex = dwRetVal - WAIT_OBJECT_0 + pwte->wte_LowIndex;
            pee = pwte->wteA_EventMapper[dwIndex];

        
            // move event to end of array, and shift the left part rightwards, or 
            // the right part leftwards (only if the event is not a high priority event)
            
            if (!pee->ee_bHighPriority) {

                if (EA_OVERFLOW(pwte, 1)) {
                    EventsArray_CopyLeftEnd(pwte);
                    dwIndex = dwRetVal - WAIT_OBJECT_0 + pwte->wte_LowIndex;
                }


                //if righmost entry, then dont have to shift
                if (!(dwIndex==EA_INDEX_HIGH_LOW_PRIORITY_EVENT(pwte))) { 
                    // move the signalled event to the right end
                    EventsArray_Move(pwte, 
                         EA_INDEX_HIGH_LOW_PRIORITY_EVENT(pwte)+1,  //dstn
                         dwIndex,    //src
                         1        //count
                        );    

                    dwCount = pwte->wte_NumActiveEvents + pwte->wte_LowIndex 
                                - dwIndex - 1;

                    // shift right part towards left if its size is smaller
                    if (dwCount <= pwte->wte_NumActiveEvents/2) {
                        EventsArray_MoveOverlap (
                                pwte, 
                                dwIndex,  //dstn
                                dwIndex+1,    //src
                                dwCount+1    //count: 
                                //+1 as the entry has been moved to the right end
                                );
                    } 
                    // shift left part towards right
                    else { 
                        EventsArray_MoveOverlap (
                                pwte, 
                                pwte->wte_LowIndex+1,  //dstn
                                pwte->wte_LowIndex,    //src
                                pwte->wte_NumActiveEvents - dwCount -1    //count
                                );    
                        pwte->wte_LowIndex ++;
                    }
                }
            }

                
            // for each work item allocate context if not run in server context
            // so all functions can be run only in server or worker context.
            // else there will be errors.

            pHead = &pee->eeL_wi;
            for (ple=pHead->Flink;  ple!=pHead; ) {
            
                pwi = CONTAINING_RECORD(ple, WT_WORK_ITEM, wi_ServerLinks);
                if (pwi->wi_Function==NULL) {
                    continue;
                }

                ple = ple->Flink;    // this allows deregistering of current binding
                
                // Run the work item in the present context or queue it to worker thread
                DispatchWorkItem(pwi);
                
            }

            //
            // if it is manual reset then remove from array, and shift it from 
            // active to inactive 
            //
            if (pee->ee_bManualReset) {
                pee->ee_Status = WT_STATUS_FIRED;
                
                InactivateEvent(pee);
            }

            break;
                        
        } //end case:default

        
        } //end switch
        
    } while ((WorkersInitialized==WORKERS_INITIALIZED) &&(bBreakout!=TRUE));

    TRACE0(LEAVE, "Leaving AlertableWaitWorkerThread:");
    return 0;
    
} //end AlertableWaitWorkerThread


    

//------------------------------------------------------------------------------//
//                        UpdateWaitTimer                                               //
// a timer can be inactivated by setting the update timeout to 0                //
// relative time can be sent by sending the complement: time = -time            //
//------------------------------------------------------------------------------//
DWORD
APIENTRY
UpdateWaitTimer (
    IN    PWT_TIMER_ENTRY    pte,
    IN    LONGLONG        *pTime
    )
{
    PWAIT_THREAD_ENTRY    pwte;
    PLIST_ENTRY            ple, pHead;
    PWT_TIMER_ENTRY        pteCur;
    BOOL                bDecrease;
    LONGLONG            newTime = *pTime;
    LONGLONG            oldTime;
    LONGLONG            currentTime;
    

    
    // get the waitThreadEntry
    pwte = pte->teP_wte;
    
    oldTime = pte->te_Timeout;
    pte->te_Timeout = newTime;
    //convert relative time to absolute time
    if (newTime<0) {
        newTime = -newTime;
        NtQuerySystemTime((LARGE_INTEGER*) &currentTime);
        newTime += currentTime;
    }
        
    
    // if wait thread is set to deleted, then return error
    if (pwte->wte_Status == WT_STATUS_DELETED) {
        return ERROR_CAN_NOT_COMPLETE;
    }



    ENTER_CRITICAL_SECTION(&pwte->wte_CSTimer, "wte_CSTimer", "UpdateWaitTimer");


    // the timer should have been deleted
    if (pte->te_Status==WT_STATUS_DELETED) {
        TRACE0(TIMER, "cannot update timer whose status is set to deleted");
        LEAVE_CRITICAL_SECTION(&pwte->wte_CSTimer, "wte_CSTimer", "UpdateWaitTimer");
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    // the timer is to be disabled and inserted at end of timers list
    if (IS_TIMER_INFINITE(newTime)) {
        TRACE0(TIMER, "Called UpdateWaitTimer to disable a timer");
        
        SET_TIMER_INFINITE(pte->te_Timeout);
        pte->te_Status = TIMER_INACTIVE;
        RemoveEntryList(&pte->te_ServerLinks);
        InsertTailList(&pwte->wteL_ClientTimerEntries, &pte->te_ServerLinks);
    }

    else {
        TRACE4(TIMER, "Called UpdateWaitTimer to update timer from <%lu:%lu> to <%lu:%lu>",
                TIMER_HIGH(oldTime), TIMER_LOW(oldTime), 
                TIMER_HIGH(newTime), TIMER_LOW(newTime));
                
        bDecrease = (newTime<oldTime) || (IS_TIMER_INFINITE(oldTime));
        pte->te_Status = TIMER_ACTIVE;            
        pHead = &pwte->wteL_ClientTimerEntries;
        ple = bDecrease? (pte->te_ServerLinks).Blink:  (pte->te_ServerLinks).Flink;
        
        RemoveEntryList(&pte->te_ServerLinks);
        
        if (bDecrease) {

            for ( ;  ple!=pHead;  ple=ple->Blink) {
                pteCur = CONTAINING_RECORD(ple, WT_TIMER_ENTRY, te_ServerLinks);
                if (pteCur->te_Status==TIMER_INACTIVE)
                    continue;
                if (pteCur->te_Timeout>newTime)
                    continue;
                else
                    break;
            }

            InsertHeadList(ple, &pte->te_ServerLinks);
        }

        else {

            for ( ; ple!=pHead;  ple=ple->Flink) {
                pteCur = CONTAINING_RECORD(ple, WT_TIMER_ENTRY, te_ServerLinks);
                if (IS_TIMER_INFINITE(pteCur->te_Timeout) 
                    || (pteCur->te_Status==TIMER_INACTIVE)
                    || (pteCur->te_Timeout>newTime)) 
                {
                    break;
                }
            }
            InsertTailList(ple, &pte->te_ServerLinks);
        }
    }

    //
    // see if the WaitableTimer timeout has to be changed
    //
    pteCur = CONTAINING_RECORD(pwte->wteL_ClientTimerEntries.Flink, WT_TIMER_ENTRY, te_ServerLinks);
    if (pteCur->te_Status == TIMER_INACTIVE) {
        TRACE0(TIMER, "CancelWaitableTimer called");
        
        SET_TIMER_INFINITE(pwte->wte_Timeout);
        
        CancelWaitableTimer(pwte->wte_Timer);
    }
    
    else if (pteCur->te_Timeout!=pwte->wte_Timeout) {
        TRACE2(TIMER, "SetWaitableTimer called <%lu:%lu>",
                TIMER_HIGH(pteCur->te_Timeout), TIMER_LOW(pteCur->te_Timeout));
                
        pwte->wte_Timeout = pteCur->te_Timeout;
        SetWaitableTimer(pwte->wte_Timer, (LARGE_INTEGER*)&pwte->wte_Timeout, 0, NULL, NULL, FALSE);
    }


    
    LEAVE_CRITICAL_SECTION(&pwte->wte_CSTimer, "wte_CSTimer", "UpdateWaitTimer");
        
    return NO_ERROR;
}



//++--------------------------------------------------------------------------------//
//                        DispatchWorkItem                                            //
//----------------------------------------------------------------------------------//
DWORD 
DispatchWorkItem (
    IN     PWT_WORK_ITEM     pwi
    )
{
    PVOID    pContext;
    DWORD    dwErr = NO_ERROR;        

    // if it has to run in server context
    if (pwi->wi_RunInServer) {
        (pwi->wi_Function)(pwi->wi_Context);
    }
    
    // else queue to worker thread
    else {

        QueueWorkItem(pwi->wi_Function, pwi->wi_Context, FALSE); 
    }

    return NO_ERROR;
}






//++----------------------------------------------------------------------------//
//                    RegisterWaitEventsTimers                                       //
// Register the client with the wait thread                                        //
// The client acquires lock on wte_CS on behalf of the server. If timers have to//
//      change then the server has to lock the timers in RegisterClientEventTimers//
//------------------------------------------------------------------------------//
DWORD
APIENTRY
RegisterWaitEventsTimers (
    IN    PLIST_ENTRY pLEventsToAdd,
    IN    PLIST_ENTRY    pLTimersToAdd
    )
{

    PWAIT_THREAD_ENTRY    pwte;
    INT                    iNumEventsToAdd, iNumTimersToAdd;
    DWORD                dwErr;
    

    //ChangeClientEventsTimersAux(1, pwte); // add

    
    // you cannot register without creating it first!!
    // initialize worker threads if not yet done
    if (!ENTER_WAIT_API()) {
        dwErr = GetLastError();
         return (dwErr == NO_ERROR ? ERROR_CAN_NOT_COMPLETE : dwErr);
     }


    TRACE0(ENTER, "Entering : RegisterWaitEventsTimers");

    // get global lock: g_CS
    ENTER_CRITICAL_SECTION(&WTG.g_CS, "g_CS", "RegisterWaitEventsTimers");

    //
    // locate the wait thread server with iNumEventsToAdd free events
    //
    // if iNumEventsToAdd ptr !=0 but list length is 1, means no list header
    iNumEventsToAdd = GetListLength(pLEventsToAdd);
    if (iNumEventsToAdd<0) 
        iNumEventsToAdd = 0;
        
    if ((pLEventsToAdd!=NULL) && (iNumEventsToAdd==0))
        iNumEventsToAdd = 1;

    iNumTimersToAdd = GetListLength(pLTimersToAdd);
    if (iNumTimersToAdd<0) 
        iNumTimersToAdd = 0;
        
    if ((pLTimersToAdd!=NULL) && (iNumTimersToAdd==0))
        iNumTimersToAdd = 1;

    
    // iNumEventsToAdd may be 0, if timers only have to be added
    // getWaiThread increments the refCount of the server so that it cannot be deleted
    // wte_NumTotalEvents so that space is reserved
    
    pwte = GetWaitThread(iNumEventsToAdd, iNumTimersToAdd);
    if (pwte==NULL) {
        TRACE0(WT, "could not allocate wait thread");
        LEAVE_CRITICAL_SECTION(&WTG.g_CS, "g_CS", "RegisterWaitEventsTimers");
        return ERROR_WAIT_THREAD_UNAVAILABLE;
    }

    // lock server: wte_CS
    ENTER_CRITICAL_SECTION(&pwte->wte_CS, "wte_CS", "RegisterWaitEventsTimers");

    // release global lock: g_CS
    LEAVE_CRITICAL_SECTION(&WTG.g_CS, "g_CS", "RegisterWaitEventsTimers");

 

    //
    // events/timers to be added
    //
    pwte->wte_ChangeType = CHANGE_TYPE_ADD;
    pwte->wtePL_EventsToChange = pLEventsToAdd;
    pwte->wtePL_TimersToChange = pLTimersToAdd;

    //
    // Wake up the server so that it can enter the events and timers of the client
    //
    SET_EVENT(pwte->wte_ClientNotifyWTEvent, "wte_ClientNotifyWTEvent", "RegisterWaitEventsTimers");
    
    // Wait till wait server notifies on completion
    //
    WAIT_FOR_SINGLE_OBJECT(pwte->wte_WTNotifyClientEvent, INFINITE, 
                            "wte_WTNotifyClientEvent", "RegisterWaitEventsTimers");
    
    //release server lock: wte_CS
    LEAVE_CRITICAL_SECTION(&pwte->wte_CS, "wte_CS", "RegisterWaitEventsTimers");



    TRACE0(LEAVE, "Leaving: RegisterWaitEventsTimers");
    return NO_ERROR;
    
} //end RegisterWaitEventsTimers





//++----------------------------------------------------------------------------//
//                    RegisterClientEventsTimers:aux                                //
// Add the client events and timers                                                //
// The client has the lock on the server and has already increased the refCount    //
//------------------------------------------------------------------------------//
DWORD
RegisterClientEventsTimers (
    IN    PWAIT_THREAD_ENTRY    pwte
    )
{
    ChangeClientEventsTimersAux(1, pwte, pwte->wtePL_EventsToChange, 
                                pwte->wtePL_TimersToChange); // add
    return NO_ERROR;
}


//++----------------------------------------------------------------------------//
//                    ChangeClientEventsTimersAux:aux                                //
// Add/delete the client events and timers                                        //
// The client has the lock on the server and has already increased the refCount //
// (add)                                                                        //
//------------------------------------------------------------------------------//
DWORD
ChangeClientEventsTimersAux (
    IN  BOOL                bChangeTypeAdd,
    IN  PWAIT_THREAD_ENTRY  pwte,
    IN  PLIST_ENTRY         pLEvents,
    IN  PLIST_ENTRY         pLTimers
    )
{
    PLIST_ENTRY        ple;
    PWT_EVENT_ENTRY    pee;
    PWT_TIMER_ENTRY    pte;

    //
    // process each event to be changed(added/deleted)
    //
    if (pLEvents != NULL) {
    
        //
        // list of events
        //
        if (!IsListEmpty(pLEvents)) {
            
            for (ple=pLEvents->Flink;  ple!=pLEvents; ) {
                pee = CONTAINING_RECORD(ple, WT_EVENT_ENTRY, ee_Links);

                ple = ple->Flink;
                
                if (bChangeTypeAdd) 
                    AddClientEvent(pee, pwte);
                else 
                    DeleteClientEvent(pee, pwte);
            }
        } 
        //
        // single event
        else {             // list empty but not null, so pointer to only one event
            pee = CONTAINING_RECORD(pLEvents, WT_EVENT_ENTRY, ee_Links);
            if (bChangeTypeAdd) 
                AddClientEvent(pee, pwte);
            else 
                DeleteClientEvent(pee, pwte);
        }
    }
    
    //
    // process each timer to be added/deleted
    //
    if (pLTimers != NULL) {


        ENTER_CRITICAL_SECTION(&pwte->wte_CSTimer, "wte_CSTimer", 
                                "ChangeClientEventsTimersAux");

        //
        // list of timers
        //
        if (!IsListEmpty(pLTimers)) {
            for (ple=pLTimers->Flink;  ple!=pLTimers;) {
                pte = CONTAINING_RECORD(ple, WT_TIMER_ENTRY, te_Links);

                ple = ple->Flink;
                
                if (bChangeTypeAdd) 
                    AddClientTimer(pte, pwte);
                else
                    DeleteClientTimer(pte, pwte);
            }
        }
        //
        //single timer
        else {            // list empty but not null, so pointer to only one timer
            pte = CONTAINING_RECORD(pLTimers, WT_TIMER_ENTRY, te_Links);
                if (bChangeTypeAdd)
                    AddClientTimer(pte, pwte);
                else
                    DeleteClientTimer(pte, pwte);
        }


        LEAVE_CRITICAL_SECTION(&pwte->wte_CSTimer, "wte_CSTimer", 
                                "ChangeClientEventsTimersAux");

    }
    
    return NO_ERROR;
}



//++----------------------------------------------------------------------------//
//                    AddClientEvent                                                //
// calling client has locked the server wte_CS: and increased refCount with server    //
// somewhat similar to RegisterClientEventLocal                                    //
//------------------------------------------------------------------------------//
DWORD
AddClientEvent (
    IN    PWT_EVENT_ENTRY        pee,
    IN    PWAIT_THREAD_ENTRY     pwte
    )
{

    // the event might have been deleted by some other thread (such things should 
    // never happen)
    if (pee->ee_Status==WT_STATUS_DELETED) {

        //todo check above

        // delete the event if RefCount is 0
        if (pee->ee_RefCount==0) {
            FreeWaitEvent(pee);
        }

        // decrement refcount as it was increased by client adding the events
        InterlockedDecrement(&pwte->wte_NumTotalEvents);
        InterlockedDecrement(&pwte->wte_RefCount);
        
        return ERROR_WT_EVENT_ALREADY_DELETED;
    }
    
        
    // insert the client event into the list of client events
    InsertInEventsList(pee, pwte);
    

    // insert the client into the MapArray and EventsArray
    if (pee->ee_bInitialState == FALSE) {
        InsertInEventsArray(pee, pwte);
    }
    //fired so not inserted in array
    else {
        pee->ee_Status = WT_STATUS_INACTIVE + WT_STATUS_FIRED;
    }
    
    return NO_ERROR;
}

    
//++----------------------------------------------------------------------------//
//                    AddClientTimer                                                    //
// The client has the lock on the server                                            //
// refcount has already been changed during registration                            //
//------------------------------------------------------------------------------//
DWORD
AddClientTimer (
    PWT_TIMER_ENTRY        pte,
    PWAIT_THREAD_ENTRY     pwte
    )
{
    // change fields of timerEntry
    pte->te_Status = TIMER_INACTIVE;
    pte->te_ServerId = pwte->wte_ServerId;
    pte->teP_wte = pwte;

    
    //insert inactive timers at end of list
    InsertTailList(&pwte->wteL_ClientTimerEntries, &pte->te_ServerLinks);
    
    return NO_ERROR;
}


//++----------------------------------------------------------------------------//
//                    DeleteClientTimer                                                //
// The client has the lock on the server                                            //
//------------------------------------------------------------------------------//
DWORD
DeleteClientTimer (
    PWT_TIMER_ENTRY        pte,
    PWAIT_THREAD_ENTRY  pwte
    )
{

    // change fields of waitThreadEntry
    InterlockedDecrement(&pwte->wte_RefCount);
    
    // if deleted flag set and refcount is 0, delete the wait entry
    if ((pwte->wte_Status == WT_STATUS_DELETED)
        && (pwte->wte_RefCount==0) 
       )
    {
        FreeWaitThreadEntry(pwte);
    }


    //remove the timer from timer list
    RemoveEntryList(&pte->te_ServerLinks);

    FreeWaitTimer(pte);



    //
    // see if the WaitableTimer timeout has to be changed
    //
    
    // if list is empty then cancel the timer
    if (IsListEmpty(&pwte->wteL_ClientTimerEntries)) {
    
        if (!IS_TIMER_INFINITE(pwte->wte_Timeout))
            CancelWaitableTimer(pwte->wte_Timer);
            
        SET_TIMER_INFINITE(pwte->wte_Timeout);
    }
    else {
        PWT_TIMER_ENTRY    pteCur;

        
        pteCur = CONTAINING_RECORD(pwte->wteL_ClientTimerEntries.Flink, 
                                    WT_TIMER_ENTRY, te_ServerLinks);
        if (pteCur->te_Status == TIMER_INACTIVE) {
            TRACE0(TIMER, "CancelWaitableTimer called in DeleteClientTimer");

            if (!IS_TIMER_INFINITE(pwte->wte_Timeout))
                CancelWaitableTimer(pwte->wte_Timer);
                
            SET_TIMER_INFINITE(pwte->wte_Timeout);
        }
        
        else if (pteCur->te_Timeout!=pwte->wte_Timeout) {
            TRACE2(TIMER, "SetWaitableTimer called in DeleteClientTimer<%lu:%lu>",
                    TIMER_HIGH(pteCur->te_Timeout), 
                    TIMER_LOW(pteCur->te_Timeout));
                    
            pwte->wte_Timeout = pteCur->te_Timeout;
            SetWaitableTimer(pwte->wte_Timer, (LARGE_INTEGER*)&pwte->wte_Timeout, 
                                0, NULL, NULL, FALSE);
        }
    }


    return NO_ERROR;
}



//++---------------------------------------------------------------------------*//
//                    CreateWaitEventBinding                                            //
// creates, initializes and returns a work_item for waitEvent                        //
// note WT_EVENT_BINDING==WT_WORK_ITEM                                                //
// increments refCount for the EventEntry so that it cannot be deleted                //
//------------------------------------------------------------------------------//    
PWT_EVENT_BINDING 
APIENTRY
CreateWaitEventBinding (
    IN    PWT_EVENT_ENTRY  pee,
    IN    WORKERFUNCTION   pFunction,
    IN    PVOID            pContext,
    IN    DWORD            dwContextSz,
    IN    BOOL             bRunInServerContext
    )
{

    DWORD               dwErr = NO_ERROR;
    PWT_WORK_ITEM       pWorkItem;
    PWAIT_THREAD_ENTRY  pwte;
    BOOL                bErr = TRUE;

    
    // initialize worker threads if not yet done
    if (!ENTER_WAIT_API()) {
        dwErr = GetLastError();
         return NULL;
     }

    TRACE0(ENTER, "CreateWaitEventBinding:");

    do { //breakout loop

        //
        // allocate work item
        //
        pWorkItem = WT_MALLOC(sizeof(WT_WORK_ITEM));
        if (pWorkItem==NULL) {
            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for work item",
                dwErr, sizeof(WT_WORK_ITEM)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }

        //
        // initialize work item
        //
        pWorkItem->wi_Function = pFunction;
        pWorkItem->wi_Context = pContext;
        pWorkItem->wi_ContextSz = dwContextSz;
        pWorkItem->wi_RunInServer = bRunInServerContext;
        
        pWorkItem->wiP_ee  = pee;
        InitializeListHead(&pWorkItem->wi_ServerLinks);
        InitializeListHead(&pWorkItem->wi_Links);

        pwte = pee->eeP_wte;

        if ((pee->ee_Status==0) || (pee->ee_Status==WT_STATUS_DELETED)) {
            break;
        }
        ENTER_CRITICAL_SECTION(&pwte->wte_CS, "wte_CS", "CreateWaitEventBinding");
        if ((pee->ee_Status==0) || (pee->ee_Status==WT_STATUS_DELETED)) {
            LEAVE_CRITICAL_SECTION(&pwte->wte_CS, "wte_CS", 
                                        "CreateWaitEventBinding");
            break;
        }
        LEAVE_CRITICAL_SECTION(&pwte->wte_CS, "wte_CS", "CreateWaitEventBinding");
        

        bErr = FALSE;
    } while (FALSE); //breakout loop

    if (bErr) {
        TRACE1(LEAVE, "Could not CreateWaitEventBinding: %d", dwErr);
        FreeWaitEventBinding(pWorkItem);
        return NULL;
    } 
    else {
        TRACE1(LEAVE, "Leaving CreateWaitEventBinding: %d", NO_ERROR);

        return pWorkItem;
    }
} //end CreateWaitEventBinding

//++----------------------------------------------------------------------------//
//                           FreeWaitEventBinding                                    //
// Called by DeleteWaitEventBinding                                                //
// Free an eventBinding entry which has been deregistered(deleted)                //
//------------------------------------------------------------------------------//
VOID
FreeWaitEventBinding (
    IN    PWT_WORK_ITEM    pwiWorkItem
    )
{    

    DWORD        dwErr;


    TRACE0(ENTER, "Entering FreeWaitEventBinding: ");
    
    if (pwiWorkItem==NULL)
        return ;


    // free context
    /*if (pwiWorkItem->wi_ContextSz>0) 
        WT_FREE_NOT_NULL(pwiWorkItem->wi_Context);*/
    
    // free wt_eventBinding structure
    WT_FREE(pwiWorkItem);

    TRACE0(LEAVE, "Leaving FreeWaitEventBinding:");
    return;
}


//++--------------------------------------------------------------------------------//
//                           ChangeWaitEventBindingAux                                    //
// called by (De)RegisterWaitEventBinding API                                       //
//----------------------------------------------------------------------------------//
DWORD
ChangeWaitEventBindingAux (
    IN    BOOL                bChangeTypeAdd,
    IN    PWT_EVENT_BINDING    pwiWorkItem
    )
{

    DWORD               dwErr = NO_ERROR;
    PWAIT_THREAD_ENTRY  pwte;
    PWT_EVENT_ENTRY     pee;

    

    // get pointer to event entry
    pee = pwiWorkItem->wiP_ee;
    if (pee==NULL) {
        return ERROR_CAN_NOT_COMPLETE;    //this error should not occur
    }
    
    // get pointer to wait-thread-entry
    pwte = pee->eeP_wte;
    if (pwte==NULL) {                    //this error should not occur
        return ERROR_CAN_NOT_COMPLETE;    
    }


    //
    // lock wait server: insert the binding into change list and wake up server
    // 
    ENTER_CRITICAL_SECTION(&pwte->wte_CS, "wte_CS", "ChangeWaitEventBindingAux");


    
    if (bChangeTypeAdd) {
        if ((pee->ee_Status==0) || (pee->ee_Status==WT_STATUS_DELETED)) {
            LEAVE_CRITICAL_SECTION(&pwte->wte_CS, "wte_CS", 
                                            "CreateWaitEventBindingAux");
            return ERROR_CAN_NOT_COMPLETE;
        }
        
        pwte->wte_ChangeType = CHANGE_TYPE_BIND_FUNCTION_ADD;
    }
    else {
        pwte->wte_ChangeType = CHANGE_TYPE_BIND_FUNCTION_DELETE;
    }

    //insert in wte list of wait server thread
    pwte->wteP_BindingToChange = pwiWorkItem;

    

    //
    // Wake up the server so that it can enter the events and timers of the client
    //
    SET_EVENT(pwte->wte_ClientNotifyWTEvent, "wte_ClientNotifyWTEvent", 
                            "ChangeWaitEventBindingAux");

    
    // Wait till wait server notifies on completion
    //
    WAIT_FOR_SINGLE_OBJECT(pwte->wte_WTNotifyClientEvent, INFINITE, "wte_WTNotifyClientEvent", "ChangeWaitEventBindingAux");
    

    //release server lock: wte_CS
    LEAVE_CRITICAL_SECTION(&pwte->wte_CS, "wte_CS", "ChangeWaitEventBindingAux");


    return NO_ERROR;

} //end ChangeWaitEventBindingAux


//++-----------------------------------------------------------------------------//
//                    RegisterClientEventBinding:aux                             //
// Server adds the event binding to the event                                    //
//-------------------------------------------------------------------------------//
DWORD
RegisterClientEventBinding (
    IN    PWAIT_THREAD_ENTRY    pwte
    )
{
    return ChangeClientEventBindingAux(1, pwte, pwte->wteP_BindingToChange); //server add event binding
}


//++----------------------------------------------------------------------------//
//                    DeRegisterClientEventBinding:aux                          //
// Server adds the event binding to the event                                   //
//------------------------------------------------------------------------------//
DWORD
DeRegisterClientEventBinding (
    IN    PWAIT_THREAD_ENTRY    pwte
    )
{
    return ChangeClientEventBindingAux(0, pwte, pwte->wteP_BindingToChange); //server delete event binding
}

//++----------------------------------------------------------------------------//
//                     ChangeClientEventBindingAux                              //
// client has lock on the server. RefCount of event increased when binding created//
//------------------------------------------------------------------------------//
DWORD
ChangeClientEventBindingAux (
    IN    BOOL                bChangeTypeAdd,
    IN    PWAIT_THREAD_ENTRY  pwte,
    IN    PWT_WORK_ITEM        pwi
    )
{
    PWT_EVENT_ENTRY    pee;


    // client has verified that the event entry has not been deleted

    
    if (pwi==NULL)     // binding cannot be null
        return ERROR_CAN_NOT_COMPLETE;


    pee = pwi->wiP_ee;


    if (bChangeTypeAdd) {

        pee->ee_RefCount++;

        InsertHeadList(&pee->eeL_wi, &pwi->wi_ServerLinks);

        // if count==0 and initial state is active and 
        if (pee->ee_Status & WT_STATUS_FIRED) {
            // queue the work item
                DispatchWorkItem(pwi);
        }
    } 
    
    // deleting eventBinding
    else {
        pee->ee_RefCount --;
        
        RemoveEntryList(&pwi->wi_ServerLinks);

        FreeWaitEventBinding(pwi);
        
        // if ee has deleted flag set and RefCount is 0, then complete its deletion
        if ( (pee->ee_RefCount==0) && (pee->ee_Status==WT_STATUS_DELETED) ) {
            DeleteClientEventComplete(pee, pwte);
        }
    }
    
    return NO_ERROR;
}

//++----------------------------------------------------------------------------//
//                       RegisterWaitEventBinding                               //
//------------------------------------------------------------------------------//
DWORD
APIENTRY
RegisterWaitEventBinding (
    IN    PWT_EVENT_BINDING    pwiWorkItem
    )
{

    DWORD        dwErr = NO_ERROR;

    
    // initialize worker threads if not yet done
    if (!ENTER_WAIT_API()) {
        dwErr = GetLastError();
         return (dwErr == NO_ERROR ? ERROR_CAN_NOT_COMPLETE : dwErr);
     }

    TRACE0(ENTER, "Entering RegisterWaitEventFunction:");


    // call the auxiliary function to add the entry into the server structure and wake it
    // the aux function checks if it is running in server context
    ChangeWaitEventBindingAux(1,//add
                              pwiWorkItem
                             );
        

    TRACE1(LEAVE, "Leaving BindFunctionToWaitEvent: %d", NO_ERROR);

    return NO_ERROR;

} //end RegisterWaitEventBinding

//++----------------------------------------------------------------------------//
//                       DeRegisterWaitEventBindingSelf                         //
//------------------------------------------------------------------------------//
DWORD
APIENTRY
DeRegisterWaitEventBindingSelf (
    IN    PWT_EVENT_BINDING    pwiWorkItem
    )
{

    PWAIT_THREAD_ENTRY    pwte;
    DWORD        dwError = NO_ERROR;
    PWT_EVENT_ENTRY        pee;

    

    TRACE0(ENTER, "Entering DeRegisterWaitEventBindingSelf:");

    if (pwiWorkItem==NULL)
        return NO_ERROR;

    // get pointer to event entry
    pee = pwiWorkItem->wiP_ee;
    if (pee==NULL) {
        return ERROR_CAN_NOT_COMPLETE;    //this error should not occur
    }
    
    // get pointer to wait-thread-entry
    pwte = pee->eeP_wte;
    if (pwte==NULL) {                    //this error should not occur
        return ERROR_CAN_NOT_COMPLETE;    
    }
    
    dwError = ChangeClientEventBindingAux(0, pwte, pwiWorkItem);
    
    TRACE1(LEAVE, "Leaving DeRegisterWaitEventBindingSelf: %d", dwError);

    return dwError;

} 


//++----------------------------------------------------------------------------//
//                       DeRegisterWaitEventBinding                             //
//------------------------------------------------------------------------------//
DWORD
APIENTRY
DeRegisterWaitEventBinding (
    IN    PWT_EVENT_BINDING    pwiWorkItem
    )
{

    DWORD        dwErr = NO_ERROR;


    TRACE0(ENTER, "Entering DeRegisterWaitEventBinding:");


    // call the auxiliary function to add the entry into the server structure and wake it
    dwErr = ChangeWaitEventBindingAux(0,//Delete
                                      pwiWorkItem
                                     );
        

    TRACE1(LEAVE, "Leaving DeRegisterWaitEventBinding: %d", NO_ERROR);

    return dwErr;

} //end DeRegisterWaitEventBinding


//++---------------------------------------------------------------------------*//
//                    CreateWaitTimer                                           //
// creates, initializes and returns a wait timer                                //
//------------------------------------------------------------------------------//    
PWT_TIMER_ENTRY
APIENTRY
CreateWaitTimer (
    IN    WORKERFUNCTION    pFunction,
    IN    PVOID            pContext,
    IN    DWORD            dwContextSz,
    IN    BOOL            bRunInServerContext
    )
{
    PWT_TIMER_ENTRY    pte;
    DWORD            dwErr;
    DWORD            bErr = TRUE;
    
    
    // initialize worker threads if not yet done
    if (!ENTER_WAIT_API()) {
        dwErr = GetLastError();
         return (NULL);
     }

    TRACE0(ENTER, "Entering CreateWaitTimer: ");



    do { // breakout loop
        
        //
        // allocate wait-timer structure
        //
        pte = WT_MALLOC(sizeof(WT_TIMER_ENTRY));
        if (pte==NULL) {
            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for wait-timer structure",
                dwErr, sizeof(WT_TIMER_ENTRY)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize fields of the waitTimer
        //
        SET_TIMER_INFINITE(pte->te_Timeout);
        pte->te_Function = pFunction;
        pte->te_Context = pContext;
        pte->te_ContextSz = dwContextSz;
        pte->te_RunInServer = bRunInServerContext;
        pte->te_Status = 0;
        //serverId, teP_wte and ServerLinks are set when it is registered
        InitializeListHead(&pte->te_ServerLinks);
        InitializeListHead(&pte->te_Links);

        pte->te_Flag = FALSE;

        bErr = FALSE;

    } while (FALSE); //end breakout loop

    
    if (bErr) {
        FreeWaitTimer(pte);
        TRACE0(LEAVE, "Leaving CreateWaitTimer: Not Created");
        return NULL;
    }
    else {
        TRACE0(LEAVE, "Leaving CreateWaitTimer: Created");
        return pte;
    }
        
} //end createWaitTimer


//++---------------------------------------------------------------------------*//
//                    FreeWaitTimer                                             //
// frees memory/handles associated with the waitTimer                           //
//------------------------------------------------------------------------------//
VOID
FreeWaitTimer (
    IN    PWT_TIMER_ENTRY pte
    )
{

    TRACE0(ENTER, "Entering FreeWaitTimer: ");

    if (pte==NULL) 
        return;

        
    //free context
    //WT_FREE_NOT_NULL(pte->te_Context);

    //free timer structure
    WT_FREE(pte);

    TRACE0(LEAVE, "Leaving FreeWaitTimer:");
    return;
} //end FreeWaitTimer


//++---------------------------------------------------------------------------*//
//                    CreateWaitEvent                                           //
// no locks required                                                            //
// creates, initializes and returns a wait event                                //
//------------------------------------------------------------------------------//    
PWT_EVENT_ENTRY
APIENTRY
CreateWaitEvent (
    IN    HANDLE            pEvent,                            // handle to event if already created

    IN    LPSECURITY_ATTRIBUTES lpEventAttributes,         // pointer to security attributes 
    IN    BOOL            bManualReset,
    IN    BOOL            bInitialState,
    IN    LPCTSTR         lpName,                         // pointer to event-object name 

    IN  BOOL            bHighPriority,                    // create high priority event

    IN    WORKERFUNCTION     pFunction,                        // if null, means will be set by other clients
    IN    PVOID             pContext,                        // can be null
    IN  DWORD            dwContextSz,                    // size of context: used for allocating context to functions
    // context size can be 0, without context being null                                                        
    IN     BOOL            bRunInServerContext                // run in server thread or get dispatched to worker thread
    )
{

    PWT_EVENT_ENTRY    peeEvent;
    PWT_WORK_ITEM    pWorkItem;
    DWORD            dwErr;
    BOOL            bErr = TRUE;


    // initialize worker threads if not yet done
    if (!ENTER_WAIT_API()) {
        dwErr = GetLastError();
         return (NULL);
     }

    TRACE0(ENTER, "Entering CreateWaitEvent: ");



    do { // breakout loop
    
        //
        // allocate wt_event structure
        //

        peeEvent = WT_MALLOC(sizeof(WT_EVENT_ENTRY));
        if (peeEvent==NULL) {
            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for wait-thread-entry",
                dwErr, sizeof(WT_EVENT_ENTRY)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }

        //
        // create event 
        //
        if (pEvent!=NULL) {
            peeEvent->ee_Event = pEvent;
            peeEvent->ee_bDeleteEvent = FALSE;
        } 
        else {
            peeEvent->ee_bDeleteEvent = TRUE;
            
            peeEvent->ee_Event = CreateEvent(lpEventAttributes, bManualReset, 
                                                bInitialState, lpName);
            if (peeEvent->ee_Event==NULL) {
            
                WT_FREE(peeEvent);
                peeEvent = NULL;
                
                dwErr = GetLastError();
                TRACE1(
                    ANY, "error %d creating event",
                    dwErr
                    );
                LOGERR0(CREATE_EVENT_FAILED, dwErr);

                break;
            }

        }

        
        //
        // initialize fields of wt_event entry
        //
        
        peeEvent->ee_bManualReset = bManualReset;
        peeEvent->ee_bInitialState = bInitialState;

        peeEvent->ee_Status = 0;                        // created but not registered
        peeEvent->ee_bHighPriority = bHighPriority;


        // initialize list of work items
        InitializeListHead(&peeEvent->eeL_wi);

        // create work item
        //
        if (pFunction==NULL) {
            // no work item set by this client
        } 
        else {
            pWorkItem = WT_MALLOC(sizeof(WT_WORK_ITEM));
            if (pWorkItem==NULL) {
                dwErr = GetLastError();
                TRACE2(
                    ANY, "error %d allocating %d bytes for work item",
                    dwErr, sizeof(WT_WORK_ITEM)
                    );
                LOGERR0(HEAP_ALLOC_FAILED, dwErr);

                break;
            }

            pWorkItem->wi_Function = pFunction;
            pWorkItem->wi_Context = pContext;
            pWorkItem->wi_ContextSz = dwContextSz;
            pWorkItem->wi_RunInServer = bRunInServerContext;
            
            pWorkItem->wiP_ee = peeEvent;  //not required to be set in this case
            InitializeListHead(&pWorkItem->wi_ServerLinks);
            InsertHeadList(&peeEvent->eeL_wi, &pWorkItem->wi_ServerLinks);
            InitializeListHead(&pWorkItem->wi_Links);
        }
        
        peeEvent->ee_bSignalSingle = FALSE;                 // signal everyone
        if (pFunction!=NULL) 
            peeEvent->ee_bOwnerSelf = TRUE;                 // currently all events can be shared
        else 
            peeEvent->ee_bOwnerSelf = FALSE; 

        peeEvent->ee_ArrayIndex = -1;                    // points to index in events array, when event is active

        //peeEvent->ee_ServerId = 0;                    // server id is set when it is inserted into wait server

        peeEvent->eeP_wte = NULL;    

        InitializeListHead(&peeEvent->ee_ServerLinks);
        InitializeListHead(&peeEvent->ee_Links);

        peeEvent->ee_RefCount = 0;                        // note: refcount can be 0 and still there can be 1 workItem
            
        peeEvent->ee_bFlag = FALSE;
        bErr = FALSE;
    } while (FALSE); //end breakout loop

    
    if (bErr) {
        FreeWaitEvent(peeEvent);
        TRACE0(LEAVE, "Leaving CreateWaitEvent: Not Created");
        return NULL;
    }
    else {
        TRACE0(LEAVE, "Leaving CreateWaitEvent: Created");
        return peeEvent;
    }
        
} //end createWaitEvent



//++----------------------------------------------------------------------------//
//                           DeleteClientEvent                                        //
// Free an event entry which has been deregistered(deleted)                        //
// frees all fields of the wait event without touching others                    //
// interlockedDecrement(pwte->wte_NumTotalEvents)                                //
//------------------------------------------------------------------------------//
DWORD
DeleteClientEvent (
    IN    PWT_EVENT_ENTRY       pee,
    IN    PWAIT_THREAD_ENTRY    pwte
    )
{
    DWORD    dwErr;

    // can be called when the event has to be deleted or when the last binding is 
    // being deleted and the delete flag is set.
    

    // if event is active Delete from events array
    if ((pee->ee_Status==WT_STATUS_ACTIVE)&&(pee->ee_ArrayIndex!=-1)) {
        DeleteFromEventsArray(pee, pwte);
        pee->ee_Status = WT_STATUS_INACTIVE; // not req
    }

    // does interlocked decrement and sets status to deleted
    DeleteFromEventsList(pee, pwte);


    // decrement the RefCount with the waitThreadEntry
    // free memory and handles assocaited with the wait event entry
    if (pee->ee_RefCount==0) {
        DeleteClientEventComplete(pee, pwte);
    }
    // else DeleteClientEventComplete will be called when last binding is deleted
    
    return NO_ERROR;
    
} //end DeleteWaitEvent


// complete the deletion of the client eventEntry which could not be completed
// due to existing bindings
VOID
DeleteClientEventComplete (
    IN PWT_EVENT_ENTRY    pee,
    IN    PWAIT_THREAD_ENTRY    pwte
    )
{

    pwte->wte_RefCount--;
    //todo: do i have to check if wte_refcount==0 and set to deleted
    
    FreeWaitEvent(pee);
    
    return;
}

//++--------------------------------------------------------------------------------//
//                           FreeWaitEvent                                                //
// Called by DeleteWaitEvent                                                        //
// Free an event entry which has been deregistered(deleted)                            //
//----------------------------------------------------------------------------------//
VOID
FreeWaitEvent (
    IN    PWT_EVENT_ENTRY    peeEvent
    )
{    
    PLIST_ENTRY        pHead, ple;
    PWT_WORK_ITEM    pwi;
    DWORD            dwErr;
    DWORD            dwNumWorkItems=0;


    TRACE0(ENTER, "Entering FreeWaitEvent: ");
    
    if (peeEvent==NULL)
        return;
        

    if (peeEvent->ee_bDeleteEvent)
        CloseHandle(peeEvent->ee_Event);

    // there should be no work items or should have been created as part of this entry
    dwNumWorkItems = GetListLength(&peeEvent->eeL_wi);
    ASSERT((peeEvent->ee_RefCount==0) 
            && ((dwNumWorkItems==0)
                    || ((dwNumWorkItems==1)&&(peeEvent->ee_bOwnerSelf))
                )
            );
            
    // free all work items and their context
    // actually there cannot be more than 1 such item at most
    pHead = &peeEvent->eeL_wi;
    for (ple=pHead->Flink;  ple!=pHead; ) {
    
        pwi = CONTAINING_RECORD(ple, WT_WORK_ITEM, wi_ServerLinks);


        if ((pwi->wi_Context!=NULL) && (pwi->wi_ContextSz>0))
            ;
            //WT_FREE(pwi->wi_Context);

        
        ple = ple->Flink;


        WT_FREE(pwi);
    }
    
    // free wt_event structure
    WT_FREE(peeEvent);

    TRACE0(LEAVE, "Leaving FreeWaitEvent:");
    return;
}
    


//++--------------------------------------------------------------------------------//
//                    DeRegisterClientsEventsTimers                                   //
// Server DeRegister the client with the wait thread                                //
//----------------------------------------------------------------------------------//
DWORD
DeRegisterClientEventsTimers (
    IN     PWAIT_THREAD_ENTRY     pwte
    )
{
    DWORD dwErr;
    dwErr = ChangeClientEventsTimersAux(0, pwte, pwte->wtePL_EventsToChange, 
                                        pwte->wtePL_TimersToChange); //delete event
    return dwErr;
}


//++--------------------------------------------------------------------------------//
//                    DeRegisterWaitEventsTimersSelf                                  //
// DeRegister the client from within its server                                        //
// Either send in NULL, a proper list, of a single node. dont send a empty header!! //
//----------------------------------------------------------------------------------//
DWORD
APIENTRY
DeRegisterWaitEventsTimersSelf (
    IN    PLIST_ENTRY pLEvents,
    IN    PLIST_ENTRY    pLTimers
    )
{
    PWAIT_THREAD_ENTRY    pwte;
    DWORD                dwError;
    
    
    if ((pLEvents==NULL)&&(pLTimers==NULL))
        return NO_ERROR;
        
    

    TRACE_ENTER("DeRegisterWaitEventsTimersSelf");

        
    // get pwte
    if (pLEvents!=NULL) {
        PWT_EVENT_ENTRY    pee;  
        
        // the below will work even if there is only one record
        pee = CONTAINING_RECORD(pLEvents->Flink, WT_EVENT_ENTRY, ee_Links);
        pwte = pee->eeP_wte;
    }
    else {
        PWT_TIMER_ENTRY    pte;  

        if (pLTimers==NULL)
            return NO_ERROR;
                    
        pte = CONTAINING_RECORD(pLTimers->Flink, WT_TIMER_ENTRY, te_Links);
        pwte = pte->teP_wte;
    }
    
    dwError =    ChangeClientEventsTimersAux ( 0, //delete
                                          pwte, pLEvents, pLTimers);

    TRACE_LEAVE("DeRegisterWaitEventsTimersSelf");                                      

    return dwError;
}
//++--------------------------------------------------------------------------------//
//                    DeRegisterWaitEventsTimers                                       //
// DeRegister the client with the wait thread                                        //
// Either send in NULL, a proper list, of a single node. dont send a empty header!! //
//----------------------------------------------------------------------------------//
DWORD
APIENTRY
DeRegisterWaitEventsTimers (
    IN    PLIST_ENTRY pLEvents,
    IN    PLIST_ENTRY    pLTimers
    )
{

    PWAIT_THREAD_ENTRY    pwte;
    DWORD                dwErr = NO_ERROR;


    if ((pLEvents==NULL)&&(pLTimers==NULL))
        return NO_ERROR;
        
    

    TRACE0(ENTER, "Entering : DeRegisterWaitEventsTimers");

        
    // get pwte
    if (pLEvents!=NULL) {
        PWT_EVENT_ENTRY    pee;  
        
        // the below will work even if there is only one record
        pee = CONTAINING_RECORD(pLEvents->Flink, WT_EVENT_ENTRY, ee_Links);
        pwte = pee->eeP_wte;
    }
    else {
        PWT_TIMER_ENTRY    pte;  

        if (pLTimers==NULL)
            return NO_ERROR;
                    
        pte = CONTAINING_RECORD(pLTimers->Flink, WT_TIMER_ENTRY, te_Links);
        pwte = pte->teP_wte;
    }



        

    // lock server: wte_CS
    ENTER_CRITICAL_SECTION(&pwte->wte_CS, "wte_CS", "DeRegisterWaitEventsTimers");


    //
    // events/timers to be deleted
    //
    pwte->wte_ChangeType = CHANGE_TYPE_DELETE;
    pwte->wtePL_EventsToChange = pLEvents;
    pwte->wtePL_TimersToChange = pLTimers;


        
    // Wake up the server so that it can delete the events and timers of the client
    
    SET_EVENT(pwte->wte_ClientNotifyWTEvent, "wte_ClientNotifyWTEvent", "DeRegisterWaitEventsTimers");

            
    WAIT_FOR_SINGLE_OBJECT(pwte->wte_WTNotifyClientEvent, INFINITE, "wte_WTNotifyClientEvent", "DeRegisterWaitEventsTimers");
    

    LEAVE_CRITICAL_SECTION(&pwte->wte_CS, "wte_CS", "DeRegisterWaitEventsTimers");


    TRACE0(LEAVE, "Leaving: DeRegisterWaitEventsTimers");
    
    return NO_ERROR;
} //end DeRegisterWaitEventsTimers


#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\inc\cpsprdver.h ===
/*----------------------------------------------------------------------------
    cpsprdver.h
  
    Versioning information common to all modules in Connection Point Services.

    Copyright (c) 1998 Microsoft Corporation
    All rights reserved.

    Authors:
        byao        Baogang Yao

    History:
    2/25/98     quintinb    Created
  --------------------------------------------------------------------------*/
#include "pnpuverp.h"

#undef VER_PRODUCTNAME_STR
#define VER_PRODUCTNAME_STR		"Microsoft(R) Connection Point Services"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\hhwrap\hhwrap.h ===
/*----------------------------------------------------------------------------
    hhwrap.h
  
    Definitions for the HtmlHelp wrapper used by PBA.

    Copyright (c) 1998 Microsoft Corporation
    All rights reserved.

    Authors:
        billbur        William Burton

    History:
    ??/??/98     billbur        Created
    09/02/99     quintinb       Created Header
  --------------------------------------------------------------------------*/

#ifndef INC_HHWRAP_H
#define INC_HHWRAP_H


//-------------------------------------------------------------------------
// Exported function declarations

BOOL WINAPI CallHtmlHelp(HWND, LPSTR, UINT, DWORD);

#endif // INC_HHWRAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\hhwrap\hhwrap.c ===
/*----------------------------------------------------------------------------
    hhwrap.c
  
    Implements the HtmlHelp wrapper for PBA in the function CallHtmlHelp.
    This function calls HTMLHelp with the parameters passed

    Copyright (c) 1998 Microsoft Corporation
    All rights reserved.

    Authors:
        billbur        William Burton

    History:
    ??/??/98     billbur        Created
    09/02/99     quintinb       Created Header
  --------------------------------------------------------------------------*/

#include <windows.h>
#include "hhwrap.h"
#include "htmlhelp.h"

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
{
    return TRUE;
}


//
//  FUNCTION: CallHtmlHelp(HWND hWnd, LPSTR lpszFile, UINT uCommand, DWORD dwData)
//
//  PURPOSE:
//    Calls HTMLHelp with the parameters passed.
//
//  PARAMETERS:
//    hWnd       -  Handle of the calling window
//    lpszFile   -  Character string containing the name of the help module
//	  uCommand	 -  Specifies the action to perform
//	  dwData	 -  Specifies any data that may be required based on the value of the uCommand parameter
//    
//
//  RETURN VALUE:
//    TRUE if the call was successful
//	  FALSE if the call failed
//

BOOL WINAPI CallHtmlHelp(HWND hWnd, LPSTR lpszFile, UINT uCommand, DWORD dwData)
{
	HWND	hwndHtmlHelp;
    
	hwndHtmlHelp = HtmlHelp(hWnd, lpszFile, uCommand, dwData);
	
	if (0 == hwndHtmlHelp)
	{
		return FALSE;
	}
    
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pba\source\resource.h ===
//+----------------------------------------------------------------------------
//
// File:     resource.h
//
// Module:   pbadmin.exe
//
// Synopsis: Resource IDs for pba_res.rc
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header    09/02/99
//
//+----------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pba_res.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_PBA_RETYPE                  129
#define IDI_ICON1                       130
#define IDI_ICON2                       131
#define ID_APP_TITLE                    1001
#define ID_DLG_OK                       1002
#define ID_DLG_CANCEL                   1003
#define ID_DLG_SAVE                     1004
#define ID_DLG_CLOSE                    1005
#define ID_DLG_YES                      1006
#define ID_DLG_NO                       1007
#define ID_DLG_PRINT                    1008
#define ID_DLG_BROWSE                   1009
#define ID_DLG_ADD                      1011
#define ID_DLG_EDIT                     1012
#define ID_DLG_DELETE                   1013
#define ID_DLG_SAVE2                    1014
#define ID_DLG_BROWSE2                  1015
#define ID_FILE_COPY                    2002
#define ID_REGIONS_TITLE                2003
#define ID_REGIONS_IMPORT               2004
#define ID_REGIONS_LIST                 2005
#define ID_REGIONS_NEWREGION            2006
#define ID_REGIONS_FILTER               2007
#define ID_PRINTING_MSG                 2010
#define ID_MAIN_PBLIST                  3010
#define ID_MAIN_FILTERBOX               3011
#define ID_MAIN_FILTERBY                3012
#define ID_MAIN_CONTAINING              3013
#define ID_MAIN_APPLY                   3014
#define ID_MAIN_ADD                     3015
#define ID_MAIN_EDIT                    3016
#define ID_MAIN_DELETE                  3017
#define ID_MAIN_POP                     3018
#define ID_MAIN_AREACODE                3019
#define ID_MAIN_ACCESSNUM               3020
#define ID_MAIN_COUNTRY                 3021
#define ID_MAIN_REGION                  3022
#define ID_MAIN_STATUS                  3023
#define ID_MAIN_DELETECONF              3024
#define ID_MAIN_LIST1                   3025
#define ID_MAIN_LIST2                   3026
#define ID_MAIN_LIST3                   3027
#define ID_MAIN_LIST4                   3028
#define ID_MAIN_LIST5                   3029
#define ID_MAIN_LIST6                   3030
#define ID_MAIN_LIST7                   3031
#define ID_MAIN_MENU1                   3032
#define ID_MAIN_MENU2                   3033
#define ID_MAIN_MENU3                   3034
#define ID_MAIN_MENU4                   3035
#define ID_MAIN_MENU5                   3036
#define ID_MAIN_MENU6                   3037
#define ID_MAIN_MENU7                   3038
#define ID_MAIN_MENU8                   3039
#define ID_MAIN_MENU9                   3040
#define ID_MAIN_MENU10                  3041
#define ID_MAIN_MENU11                  3042
#define ID_MAIN_MENU12                  3043
#define ID_MAIN_MENU13                  3044
#define ID_MAIN_MENU15                  3046
#define ID_MAIN_MENU16                  3047
#define ID_MAIN_MENU17                  3048
#define ID_MAIN_MENU18                  3049
#define ID_MAIN_MENU19                  3050
#define ID_MAIN_MENU20                  3051
#define ID_MAIN_MENU21                  3052
#define ID_MAIN_NOPB                    3060
#define ID_MAIN_LOADING                 3061
#define ID_ADD_TAB1                     4038
#define ID_ADD_TAB2                     4039
#define ID_ADD_TAB3                     4045
#define ID_ADD_POP                      4046
#define ID_ADD_COUNTRY                  4047
#define ID_ADD_REGION                   4048
#define ID_ADD_AREACODE                 4049
#define ID_ADD_ACESSNUM                 4050
#define ID_ADD_STATUS                   4051
#define ID_ADD_FLAGS                    4052
#define ID_ADD_DUNSCRIPT                4053
#define ID_ADD_ANALOG                   4054
#define ID_ADD_MIN                      4055
#define ID_ADD_MAX                      4056
#define ID_ADD_LASTEDIT                 4057
#define ID_EDIT_LASTEDIT                4057
#define ID_ADD_TITLE                    4058
#define ID_EDIT_TITLE                   4059
#define ID_ADD_PRODUCTION               4060
#define ID_ADD_BETA                     4061
#define ID_ADD_NONE                     4062
#define ID_ADD_ALL                      4063
#define ID_DELPB_CONF                   4066
#define ID_NEWPB_TITLE                  4067
#define ID_NEWPB_DESC                   4068
#define ID_NEWPB_LABEL                  4069
#define ID_COPYPB_TITLE                 4070
#define ID_COPYPB_LBL1                  4071
#define ID_COPYPB_LBL2                  4072
#define ID_ADD_FLAG1                    4080
#define ID_ADD_FLAG2                    4081
#define ID_ADD_FLAG3                    4082
#define ID_ADD_FLAG4                    4083
#define ID_ADD_FLAG5                    4084
#define ID_ADD_FLAG6                    4085
#define ID_ADD_FLAG7                    4086
#define ID_ADD_FLAG8                    4087
#define ID_DELPB_WARN                   4088
#define ID_BUILD_TITLE                  5191
#define ID_BUILD_CREATECMB              5192
#define ID_BUILD_POSTCMB                5193
#define ID_BUILD_OPTIONSCMB             5194
#define ID_BUILD_CREATELBL              5195
#define ID_BUILD_POSTLBL                5196
#define ID_BUILD_VERSIONLBL             5197
#define ID_BUILD_DIRLBL                 5198
#define ID_BUILD_SERVERLBL              5199
#define ID_BUILD_STATUSLBL              5200
#define ID_BUILD_UNKNOWN                5201
#define ID_BUILD_OPERATING              5204
#define ID_REGION_TITLE                 5205
#define ID_DIRBROWSE_TITLE              5205
#define ID_REGION_LISTLBL               5206
#define ID_VIEW_DELTA                   5206
#define ID_REGION_IMPORTCMB             5207
#define ID_VIEW_FULLPB                  5207
#define ID_VIEW_TITLE                   5208
#define ID_VIEW_LISTLBL                 5209
#define ID_OPTIONS_SERVICELBL           5210
#define ID_OPTIONS_SERVICELBL2          5211
#define ID_OPTIONS_BASELBL              5212
#define ID_OPTIONS_BASELBL2             5213
#define ID_OPTIONS_INFLBL               5214
#define ID_OPTIONS_DESCLBL              5214
#define ID_OPTIONS_SIGNINGLBL           5215
#define ID_OPTIONS_URLLBL               5215
#define ID_OPTIONS_CERTLBL              5216
#define ID_OPTIONS_KEYLBL               5217
#define ID_OPTIONS_TAB1                 5218
#define ID_OPTIONS_TAB2                 5219
#define ID_OPTIONS_TAB3                 5220
#define ID_OPTIONS_SERVERLBL            5221
#define ID_OPTIONS_UIDLBL               5222
#define ID_OPTIONS_PWDLBL               5223
#define ID_OPTIONS_LISTLBL              5224
#define ID_OPTIONS_TITLE                5225
#define ID_LOG_REGADD                   5230
#define ID_LOG_REGEDIT                  5231
#define ID_LOG_REGDEL                   5232
#define ID_LOG_POPADD                   5233
#define ID_LOG_POPEDIT                  5234
#define ID_LOG_POPDEL                   5235
#define ID_LOG_DATE                     5236
#define ID_LOG_ACTION                   5237
#define ID_LOG_KEY                      5238
#define ID_LOG_RECORD                   5239
#define ID_ABOUT_VER                    6001
#define ID_ABOUT_COPYRIGHT              6002
#define ID_ABOUT_WARNING                6003
#define ID_ABOUT_TITLE                  6004
#define ID_MSG_1                        6010
#define ID_MSG_2                        6011
#define ID_MSG_3                        6012
#define ID_MSG_4                        6013
#define ID_MSG_5                        6014
#define ID_MSG_6                        6015
#define ID_MSG_7                        6016
#define ID_MSG_8                        6017
#define ID_MSG_9                        6018
#define ID_MSG_10                       6019
#define ID_MSG_11                       6020
#define ID_MSG_12                       6021
#define ID_MSG_13                       6022
#define ID_MSG_14                       6023
#define ID_MSG_15                       6024
#define ID_MSG_16                       6025
#define ID_MSG_17                       6026
#define ID_MSG_18                       6027
#define ID_MSG_19                       6028
#define ID_MSG_20                       6029
#define ID_MSG_21                       6030
#define ID_MSG_22                       6031
#define ID_MSG_23                       6032
#define ID_MSG_24                       6033
#define ID_MSG_25                       6034
#define ID_MSG_26                       6035
#define ID_MSG_27                       6036
#define ID_MSG_28                       6037
#define ID_MSG_29                       6038
#define ID_MSG_30                       6039
#define ID_MSG_31                       6040
#define ID_MSG_32                       6041
#define ID_MSG_33                       6042
#define ID_MSG_34                       6043
#define ID_MSG_35                       6044
#define ID_MSG_36                       6045
#define ID_MSG_37                       6046
#define ID_MSG_38                       6047
#define ID_MSG_39                       6048
#define ID_MSG_40                       6049
#define ID_MSG_41                       6050
#define ID_MSG_42                       6051
#define ID_MSG_43                       6052
#define ID_MSG_44                       6053
#define ID_MSG_45                       6054
#define ID_MSG_46                       6055
#define ID_MSG_47                       6056
#define ID_MSG_48                       6057
#define ID_MSG_49                       6058
#define ID_MSG_50                       6059
#define ID_MSG_51                       6060
#define ID_MSG_52                       6061
#define ID_MSG_53                       6062
#define ID_MSG_54                       6063
#define ID_MSG_55                       6064
#define ID_MSG_56                       6065
#define ID_MSG_57                       6066
#define ID_MSG_58                       6067
#define ID_MSG_59                       6068
#define ID_MSG_60                       6069
#define ID_MSG_61                       6070
#define ID_MSG_62                       6071
#define ID_MSG_63                       6072
#define ID_MSG_64                       6074
#define ID_MSG_65                       6075
#define ID_MSG_66                       6076
#define ID_MSG_67                       6077
#define ID_MSG_68                       6078
#define ID_MSG_69                       6079
#define ID_MSG_70                       6080
#define ID_MSG_71                       6081
#define ID_MSG_72                       6082
#define ID_MSG_73                       6083
#define ID_MSG_74                       6084
#define ID_MSG_75                       6085
#define ID_MSG_76                       6086
#define ID_MSG_77                       6087
#define ID_MSG_78                       6088
#define ID_MSG_79                       6089
#define ID_MSG_80                       6090
#define ID_MSG_81                       6091
#define ID_MSG_82                       6092
#define ID_MSG_83                       6093
#define ID_MSG_84                       6094
#define ID_MSG_85                       6095
#define IDS_MSG_86                      6096
#define IDS_MSG_87                      6097
#define IDS_MSG_88                      6098
#define IDS_MSG_89                      6099
#define IDS_MSG_90                      6100
#define IDS_MSG_91                      6101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        7001
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         10001
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pbserver\common.h ===
/*----------------------------------------------------------------------------
    common.h

    Header file for common global variable declarations
    
    Copyright (c) 1998 Microsoft Corporation
    All rights reserved.

    Authors:
        byao        Baogang Yao

    History:
        ??/??/97    byao        Created
        09/02/99    quintinb    Created Header
  --------------------------------------------------------------------------*/
#ifndef _COMMON_INCL_
#define _COMMON_INCL_


// comment the following line if not debug
//#ifdef DEBUG
//#define _LOG_DEBUG_MESSAGE
//#endif

#include "ntevents.h"
#include "pbsvrmsg.h"

extern CNTEvent * g_pEventLog;

extern CRITICAL_SECTION g_CriticalSection;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\common\rtutils\wtproto.h ===
// copy all the events to the left end of the array
VOID
EventsArray_CopyLeftEnd (
	PWAIT_THREAD_ENTRY	pwte
	);


// Insert the event in the events array and the map array
VOID
EventsArray_InsertEvent (
	PWT_EVENT_ENTRY		pee,
	PWAIT_THREAD_ENTRY	pwte,
	INT					iIndex
	);

// copy dwCount events from the srcIndex to dstnIndex (no overlap)
VOID
EventsArray_Move (
	IN	PWAIT_THREAD_ENTRY	pwte,
	IN	DWORD	dwDstnIndex,
	IN	DWORD	dwSrcIndex,
	IN	DWORD	dwCount
	);

// copy dwCount events from the srcIndex to dstnIndex (with overlap)
VOID
EventsArray_MoveOverlap (
	IN	PWAIT_THREAD_ENTRY	pwte,
	IN	DWORD	dwDstnIndex,
	IN	DWORD	dwSrcIndex,
	IN	DWORD	dwCount
	);

// called by server to (un)bind event bindings
DWORD
ChangeClientEventBindingAux (
	IN	BOOL				bChangeTypeAdd,
	IN	PWAIT_THREAD_ENTRY  pwte,
	IN  PWT_WORK_ITEM		pwi
	);

DWORD
ChangeClientEventsTimersAux (
 	IN  BOOL				bChangeTypeAdd,
	IN	PWAIT_THREAD_ENTRY	pwte,
	IN  PLIST_ENTRY			pLEvents,
	IN	PLIST_ENTRY			pLTimers
	);

	
//++called by (De)RegisterWaitEventBinding API
DWORD
ChangeWaitEventBindingAux (
	IN	BOOL				bChangeTypeAdd,
	IN	PWT_EVENT_BINDING	pwiWorkItem
	);

VOID
DeleteClientEventComplete (
	IN PWT_EVENT_ENTRY	pee,
	IN	PWAIT_THREAD_ENTRY	pwte
	);

VOID
DeleteFromEventsArray (
	IN	PWT_EVENT_ENTRY		pee,
	IN	PWAIT_THREAD_ENTRY	pwte
	);

VOID
DeleteFromEventsList (
	IN	PWT_EVENT_ENTRY		pee,
	IN	PWAIT_THREAD_ENTRY	pwte
	);
	
DWORD
DeInitializeWaitGlobalComplete (
	);

DWORD 
DispatchWorkItem (
	IN 	PWT_WORK_ITEM 	pwi
	);
	
INT
GetListLength (
	IN	PLIST_ENTRY	pList
	);


//++remove event from the array while keeping it in the list. mark it inactive.
VOID
InactivateEvent (
	IN PWT_EVENT_ENTRY	pee
	);



VOID
PrintEvent (
	PWT_EVENT_ENTRY	pee,
	DWORD			level
	);
	
VOID
PrintTimer (
	PWT_TIMER_ENTRY 	pte,
	DWORD				level
	);

VOID
PrintWaitThreadEntry (
	PWAIT_THREAD_ENTRY 	pwte,
	DWORD				level
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pbserver\ntevents.h ===
/*--------------------------------------------------------

  ntevents.h
      Defines a generic class that can register an NT
	  event source and log NT events on that evens source.

  Copyright (c) 1996-1998 Microsoft Corporation
  All rights reserved.

  Authors:
      rsraghav    R.S. Raghavan

  History:
      03-10-95    rsraghav    Created. 

  -------------------------------------------------------*/

#ifdef __cplusplus	 // file should be compiled only if it included by a c++ source

#ifndef _NTEVENTS_H_
#define _NTEVENTS_H_

#if defined(DEBUG) && defined(INLINE)
#undef THIS_FILE
static char BASED_CODE NTEVENTS_H[] = "ntevents.h";
#define THIS_FILE NTEVENTS_H
#endif									 

// #include "pwpmsg.h"
//////////////////////////////////////////////////////////////////////
// CNTEvent	- generic class that allows to register an event source and log
//				NT events through that event source.

class CNTEvent
{
	public:
		CNTEvent(const char *pszEventSourceName);
		~CNTEvent();

		BOOL FLogEvent(WORD wEventType, DWORD dwEventID, const char *pszParam1 = NULL, 
						const char *pszParam2 = NULL, const char *pszParam3 = NULL, 
						const char *pszParam4 = NULL, const char *pszParam5 = NULL,
						const char *pszParam6 = NULL, const char *pszParam7 = NULL,
						const char *pszParam8 = NULL, const char *pszParam9 = NULL);

		BOOL FLogError(DWORD dwEventID, const char *pszParam1 = NULL, 
						const char *pszParam2 = NULL, const char *pszParam3 = NULL, 
						const char *pszParam4 = NULL, const char *pszParam5 = NULL,
						const char *pszParam6 = NULL, const char *pszParam7 = NULL,
						const char *pszParam8 = NULL, const char *pszParam9 = NULL)
		{
			return FLogEvent(EVENTLOG_ERROR_TYPE, dwEventID, pszParam1, pszParam2, pszParam3,
						pszParam4, pszParam5, pszParam6, pszParam7, pszParam8, pszParam9);
		}

		BOOL FLogWarning(DWORD dwEventID, const char *pszParam1 = NULL, 
						const char *pszParam2 = NULL, const char *pszParam3 = NULL, 
						const char *pszParam4 = NULL, const char *pszParam5 = NULL,
						const char *pszParam6 = NULL, const char *pszParam7 = NULL,
						const char *pszParam8 = NULL, const char *pszParam9 = NULL)
		{
			return FLogEvent(EVENTLOG_WARNING_TYPE, dwEventID, pszParam1, pszParam2, pszParam3,
						pszParam4, pszParam5, pszParam6, pszParam7, pszParam8, pszParam9);
		}

		BOOL FLogInfo(DWORD dwEventID, const char *pszParam1 = NULL, 
						const char *pszParam2 = NULL, const char *pszParam3 = NULL, 
						const char *pszParam4 = NULL, const char *pszParam5 = NULL,
						const char *pszParam6 = NULL, const char *pszParam7 = NULL,
						const char *pszParam8 = NULL, const char *pszParam9 = NULL)
		{
			return FLogEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, pszParam1, pszParam2, pszParam3,
						pszParam4, pszParam5, pszParam6, pszParam7, pszParam8, pszParam9);
		}
		
	private:
		HANDLE		m_hEventSource;		// handle to the event source
};

#endif // _NTEVENTS_H_ 

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pbserver\pbserver.h ===
/*----------------------------------------------------------------------------
    pbserver.h

    CPhoneBkServer class definition
    
    Copyright (c) 1997-1998 Microsoft Corporation
    All rights reserved.

    Authors:
        byao        Baogang Yao

    History:
        01/23/97    byao    Created
  --------------------------------------------------------------------------*/
#ifndef _PBSVR_INCL_
#define _PBSVR_INCL_

#define VERSION_LEN 64
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

#include <httpext.h>


// HTTP status code  -- copied from 'afxisapi.h'
#define HTTP_STATUS_OK              200     // OK
#define HTTP_STATUS_CREATED         201     // created
#define HTTP_STATUS_ACCEPTED        202     // accepted
#define HTTP_STATUS_NO_CONTENT      204     // no content
#define HTTP_STATUS_REDIRECT        301     // moved permanently
#define HTTP_STATUS_TEMP_REDIRECT   302     // moved temporarily
#define HTTP_STATUS_NOT_MODIFIED    304     // not modified
#define HTTP_STATUS_BAD_REQUEST     400     // bad request
#define HTTP_STATUS_AUTH_REQUIRED   401     // unauthorized
#define HTTP_STATUS_FORBIDDEN       403     // forbidden
#define HTTP_STATUS_NOT_FOUND       404     // not found
#define HTTP_STATUS_SERVICE_NA      405     // service unavailable
#define HTTP_STATUS_SERVER_ERROR    500     // internal server error
#define HTTP_STATUS_NOT_IMPLEMENTED 501     // not implemented
#define HTTP_STATUS_BAD_GATEWAY     502     // bad gateway

#define NAME_VALUE_LEN      128

// If the query string is NULL, or there are invalid number of parameters in it,
// then treat it as an 'INVALID_QUERY_STRING'
#define INVALID_QUERY_STRING  -1

typedef struct {
    char m_achName[NAME_VALUE_LEN];
    char m_achVal[NAME_VALUE_LEN];
} PARAMETER_PAIR, *LPPARAMETER_PAIR;


// query parameter that will be passed from client to the ISA
typedef struct _query_parameter {
     int m_dOSArch;
     int m_dOSType;
     int m_dLCID;
     char m_achOSVer[VERSION_LEN];
     char m_achCMVer[VERSION_LEN];
     char m_achPB[VERSION_LEN];
     int m_dPBVer;
} QUERY_PARAMETER, *LPQUERY_PARAMETER;

class CPhoneBkServer 
{
private:
    BOOL m_bInitialized;
    QUERY_PARAMETER m_QueryParameter;

public:
    BOOL GetExtensionVersion(LPHSE_VERSION_INFO pVer);
    DWORD HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK lpEcb);

protected:

    BOOL GetQueryParameter(char *pszQuery, LPQUERY_PARAMETER lpQueryParamter);
    void FormSQLQuery(char *pszQuery, char *pszService, int dLCID, int dOSType, int dOSArch);
    void BuildStatusCode(LPTSTR pszResponse, DWORD dwCode);
    DWORD GetFileLength(LPSTR lpszFileName);
    BOOL SendFile(LPEXTENSION_CONTROL_BLOCK lpEcb, LPSTR lpszFileName, BOOL bWait);
    BOOL Virtual2Physical(
                        LPEXTENSION_CONTROL_BLOCK lpEcb, 
                        char *pszVirtualPath,
                        char *pszPhysicalPath
                    );
    int  GetParameterPairs(
                        char *pszInputString, 
                        LPPARAMETER_PAIR lpPairs, 
                        int dMaxPairs
                    );

};


// helping functions
BOOL InitProcess();
BOOL CleanUpProcess();
BOOL InitDBNames();
BOOL UpdatePhoneBook();
BOOL InitializeSharedMem(SECURITY_ATTRIBUTES sa);
//BOOL GrantPermissions( LPTSTR Object );
void CleanUpSharedMem();
BOOL GetSemaphore();
BOOL SetAclPerms(PACL * ppAcl);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pbserver\ntevents.cpp ===
/*--------------------------------------------------------

  ntevents.cpp
      Defines a generic class that can register an NT
      event source and log NT events on that evens source.

  Copyright (c) 1996-1998 Microsoft Corporation
  All rights reserved.

  Authors:
      rsraghav    R.S. Raghavan

  History:
      03-10-95    rsraghav    Created. 

  -------------------------------------------------------*/
#include <windows.h>
#include "ntevents.h"

///////////////////////////////////////////////////////////////////////////////
//  
//  Function:       CNTEvent::CNTEvent
// 
//  Description:    This is the constructor for the generic NT Even logging class
// 
//  Parameters:     pszEventSourceName - points to a null-terminated string 
//                      representing the event source name.
//
//
//  Histroy:        03/10/96    rsraghav    Created
///////////////////////////////////////////////////////////////////////////////

CNTEvent::CNTEvent(const char *pszEventSourceName)
{
    if (pszEventSourceName)
    {
        m_hEventSource = RegisterEventSource(NULL, pszEventSourceName);
    }
}



///////////////////////////////////////////////////////////////////////////////
//  
//  Function:       CNTEvent::~CNTEvent
// 
//  Description:    This is the destructor for the generic NT Even logging class
// 
//  Parameters:     none.
//
//
//  Histroy:        03/10/96    rsraghav    Created
///////////////////////////////////////////////////////////////////////////////

CNTEvent::~CNTEvent()
{
    if (m_hEventSource)
    {
        DeregisterEventSource(m_hEventSource);
        m_hEventSource = NULL;
    }
}


///////////////////////////////////////////////////////////////////////////////
//  
//  Function:       CNTEvent::FLogEvent
// 
//  Description:    This fucntion allows logging events to the event source
//                  associated with this object. The function is a generic
//                  log function that could handle upto 5 insert strings.
//                  The string params are given the default value of NULL,
//                  and the first NULL parameter in the argument list terminates
//                  the insert string list.
// 
//  Parameters:     wEventType - type of event to be logged (possible values
//                      are EVENTLOG_INFORMATION_TYPE, EVENTLOG_ERROR_TYPE,
//                      EVENTLOG_WARNING_TYPE, EVENTLOG_AUDIT_SUCCESS, and
//                      EVENTLOG_AUDIT_FAILURE)
//                  dwEventID - ID of the event to be logged (constants are 
//                      defined in the appropriate header files generated
//                      by the mc compiler.
//                  pszParamN - {N=1,2,3,4,5} represent the appropriate insert
//                      string parameter. All have default value NULL, and the
//                      first NULL parameter terminates the insert string list.
//
//
//  Histroy:        03/10/96    rsraghav    Created
///////////////////////////////////////////////////////////////////////////////


BOOL CNTEvent::FLogEvent(WORD wEventType, DWORD dwEventID, const char *pszParam1 /* = NULL */, 
                        const char *pszParam2 /* = NULL */, const char *pszParam3 /* = NULL */, 
                        const char *pszParam4 /* = NULL */, const char *pszParam5 /* = NULL */,
                        const char *pszParam6 /* = NULL */, const char *pszParam7 /* = NULL */,
                        const char *pszParam8 /* = NULL */, const char *pszParam9 /* = NULL */)
{
    if (!m_hEventSource)
    {
        OutputDebugString("Can't log event, m_hEventSource is NULL\n");
        return FALSE;
    }

    const char *pszInsertString[10];
    const int cszInsertString = (sizeof(pszInsertString) / sizeof(pszInsertString[0]));
    WORD cInsertStrings = 0;

    pszInsertString[0] = pszParam1;
    pszInsertString[1] = pszParam2;
    pszInsertString[2] = pszParam3;
    pszInsertString[3] = pszParam4;
    pszInsertString[4] = pszParam5;
    pszInsertString[5] = pszParam6;
    pszInsertString[6] = pszParam7;
    pszInsertString[7] = pszParam8;
    pszInsertString[8] = pszParam9;
    pszInsertString[9] = NULL;

    for (int i = 0; i < cszInsertString; ++i)
    {
        if (pszInsertString[i])
        {
            cInsertStrings++;
        }
        else
        {
            break;
        }
    }

    return ReportEvent(m_hEventSource, wEventType, 0, dwEventID, NULL, cInsertStrings, 0, (const char **) pszInsertString, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pbserver\util.h ===
/*----------------------------------------------------------------------------
	util.h

	Header file for utility functions.  Downloaded sample code 
    from http://hoohoo.ncsa.uiuc.edu/cgi
	
    Copyright (c) 1997-1998 Microsoft Corporation
    All rights reserved.

    Authors:
        byao		Baogang Yao

    History:
        01/23/97    byao	    Created
        09/02/99    quintinb    Created Header
  --------------------------------------------------------------------------*/
#ifndef _UTIL_INCL_
#define _UTIL_INCL_

#define LF 10
#define CR 13

void GetWord(char *pszWord, char *pszLine, char cStopChar, int nMaxWordLen);
void UnEscapeURL(char *pszURL);
void LogDebugMessage(const char *pszString);
BOOL GetRegEntry(HKEY hKeyType,
					const char* pszSubkey,
					const char* pszKeyName,
					DWORD dwRegType,
					const BYTE* lpbDataIn,
					DWORD cbDataIn,
					BYTE* lpbDataOut,
					LPDWORD pcbDataOut);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pbserver\util.c ===
/*----------------------------------------------------------------------------
    util.cpp
  
    utility functions for phone book server

    Copyright (c) 1997-1998 Microsoft Corporation
    All rights reserved.

    Authors:
        byao        Baogang Yao

    History:
    1/23/97     byao    -- Created
  --------------------------------------------------------------------------*/


#include <windows.h>
#include <stdio.h>
#include <assert.h>
#include <winreg.h>

#include "util.h"

// comment the following line if not debug
//#ifdef DEBUG
//#define _LOG_DEBUG_MESSAGE
//#endif


////////////////////////////////////////////////////////////////////////////////////
//
//  Name:       GetWord
//
//  Synopsis:   Get the first word from a line, using a given separator character
//
//  Parameters:
//      pszWord[out]    The first word from the line
//      pszLine[in]     The byte line
//      cStopChar[in]   The separator character
//      nMaxWordLen [in] The max length of the word (not counting terminating null)
//
void GetWord(char *pszWord, char *pszLine, char cStopChar, int nMaxWordLen) 
{
    int i = 0, j;

    for(i = 0; pszLine[i] && (pszLine[i] != cStopChar) && (i < nMaxWordLen); i++)
    {
        pszWord[i] = pszLine[i];
    }

    pszWord[i] = '\0';
    if(pszLine[i]) ++i;
    
    j = 0;
    while(pszLine[j++] = pszLine[i++]);
}

//////////////////////////////////////////////////////////////////////
// 
// Name:        Decrypt the URL_escaped code  '%xx' characters 
//
// Synopsis:    HTTPd generated 
// 
// Return:      Original special character, such as '*', '?', etc.
//      
// Parameters:  
//   
//      pszEscapedSequence[in]  escaped sequence, such as 3F (%3F)
//
static char HexToChar(char *pszEscapedSequence) 
{
    register char cCh;

    cCh = (pszEscapedSequence[0] >= 'A' ? ((pszEscapedSequence[0] & 0xdf) - 'A')+10 : (pszEscapedSequence[0] - '0'));
    cCh *= 16;
    cCh += (pszEscapedSequence[1] >= 'A' ? ((pszEscapedSequence[1] & 0xdf) - 'A')+10 : (pszEscapedSequence[1] - '0'));
    return cCh;
}

//////////////////////////////////////////////////////////////////////////////
// 
//  Name:       UnEscapeURL
//  
//  Synopsis:   convert the after-escaped URL string back to normal ASCII string
//  
//  Parameter:
//      pszURL[in/out]  The pointer to the URL, the string will be converted
//
//
void UnEscapeURL(char *pszURL) 
{
    register int i,j;

    for(i = 0, j = 0; pszURL[j]; ++i, ++j)
    {
        if ((pszURL[i] = pszURL[j]) == '%')
        {
            pszURL[i] = HexToChar(&pszURL[j + 1]);
            j += 2;
        }
        else
        {
            if ('+' == pszURL[i])
            {
                pszURL[i] = ' ';
            }
        }
    }

    pszURL[i] = '\0';
}

// Log debug information to a debug file
// very useful utility function
void LogDebugMessage(const char *pszString)
{
#ifdef _LOG_DEBUG_MESSAGE
    
    static HANDLE hDbgFile = INVALID_HANDLE_VALUE;
    char szBuffer[2048];
    DWORD dwBytesWritten;

    if (INVALID_HANDLE_VALUE == hDbgFile)
    {
        SYSTEMTIME st;
        char szLogFileName[1024];
        GetLocalTime(&st);
        sprintf(szLogFileName, "isapidbg%04u%02u%02u%02u%02u%02u",  
                st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
        hDbgFile = CreateFile(szLogFileName,
                              GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              CREATE_NEW,
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                              NULL);
    }

    if (INVALID_HANDLE_VALUE == hDbgFile)
    {
        DWORD dwErrorCode = GetLastError();
        return;
    }

    sprintf(szBuffer, "%d\t%d\t%s\r\n", GetTickCount(), GetCurrentThreadId(), pszString);

    if ((FALSE == WriteFile(hDbgFile, (LPCVOID) &szBuffer[0], strlen(szBuffer), &dwBytesWritten, NULL)) ||
        (dwBytesWritten != strlen(szBuffer)))
    {
        CloseHandle(hDbgFile);
        hDbgFile = INVALID_HANDLE_VALUE;
    } 

    OutputDebugString(szBuffer);

    return;

#endif
}   

//+---------------------------------------------------------------------------
//
//  Function:   GetRegEntry
//
//  Synopsis:   Gets the value of specified registry key
//
//  Arguments:  hKeyType    [Key Type - HKEY_LOCAL_MACHINE,...]
//              pszSubKey   [Subkey under hKeyType]
//              pszKeyName  [Key name whose value should be retrieved]
//              dwRegType   [Type of the registry key - REG_SZ,...]
//              lpbDataIn   [Default value for the reg key]
//              cbDataIn    [Size of lpbDataIn]
//              lpbDataOut  [Value of the registry key || Default Value ]
//              pcbDataIn   [Size of lpbDataOut]
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//  History:    VetriV  Created     2/6/96
//
//----------------------------------------------------------------------------

BOOL GetRegEntry(HKEY hKeyType,
                 const char* pszSubkey,
                 const char* pszKeyName,
                 DWORD dwRegType,
                 const BYTE* lpbDataIn,
                 DWORD cbDataIn,
                 BYTE * lpbDataOut,
                 LPDWORD pcbDataOut)
{
    HKEY hKey;
    DWORD dwResult;
    LONG retcode;

    assert(pszSubkey && pszKeyName);

    if (!pszSubkey)
    {
        return FALSE;
    }

    if (!pszKeyName)
    {
        return FALSE;
    }
    
    // create the specified key; If the key already exists, open it
    retcode = RegCreateKeyEx(hKeyType,
                             (LPCTSTR)pszSubkey,
                             0,
                             0,
                             REG_OPTION_NON_VOLATILE,
                             KEY_QUERY_VALUE,
                             NULL,
                             &hKey,
                             &dwResult);

    if (ERROR_SUCCESS != retcode)
    {
        SetLastError(retcode);
        return FALSE;
    }
    
    // get the data and type for a value name
    retcode =  RegQueryValueEx(hKey,
                               (LPTSTR)pszKeyName,
                               0,
                               NULL,
                               lpbDataOut,
                               pcbDataOut);

    if (ERROR_SUCCESS != retcode)
    {
        SetLastError(retcode);
        RegCloseKey(hKey);
        return FALSE;
    }

    RegCloseKey(hKey);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetRegEntryStr()
//
//  Synopsis:   Gets the value of specified registry key using the key name
//              An easier way than GetRegEntry()
//
//  Arguments:  pszBuffer       [buffer for the key value]
//              dwBufferSize    [size of the buffer]
//              pszKeyName      [Key name whose value should be retrieved]
//
//  History:    t-byao      Created     6/10/96
//
//----------------------------------------------------------------------------

BOOL GetRegEntryStr(unsigned char *pszBuffer,
                    DWORD dwBufferSize, 
                    const char *pszKeyName)
{
    return GetRegEntry(HKEY_LOCAL_MACHINE,
                       "SOFTWARE\\MICROSOFT\\NAMESERVICE\\MAPPING", pszKeyName,
                       REG_SZ,NULL,0,pszBuffer,&dwBufferSize);
}


#if 0
/*
//+---------------------------------------------------------------------------
//
//  Function:   GetRegEntryInt()
//
//  Synopsis:   Gets the value of specified registry key using the key name
//              An easier way than GetRegEntry()
//
//  Arguments:  cstrKeyName     [Key name whose value should be retrieved]
//
//  Returns:    Value of the Key (type: int)
//
//  History:    t-byao      Created     6/17/96
//
//----------------------------------------------------------------------------

BOOL GetRegEntryInt(int *pdValue, const char *pszKeyName)
{
    DWORD dwSize=sizeof(int);
    DWORD dwValue;
    BOOL  ret;
    
    ret = GetRegEntry(HKEY_LOCAL_MACHINE,
                      "SOFTWARE\\MICROSOFT\\NAMESERVICE\\MAPPING",
                      pszKeyName,
                      REG_DWORD,NULL,0,(BYTE *)&dwValue,&dwSize);
    if (ret)
    {
        *pdValue = dwValue;
    }
    return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetRegEntryDWord()
//
//  Synopsis:   Gets the value of specified DWORD registry key using the key name
//              An easier way than using GetRegEntry() directly
//
//  Arguments:  cstrKeyName     [Key name whose value should be retrieved]
//
//  Returns:    Value of the Key (type: DWORD)
//
//  History:    t-byao      Created     6/19/96
//
//----------------------------------------------------------------------------

BOOL GetRegEntryDWord(DWORD *pdValue, const char *pszKeyName)
{
    DWORD dwSize = sizeof(int);
    
    return GetRegEntry(HKEY_LOCAL_MACHINE,
                       "SOFTWARE\\MICROSOFT\\NAMESERVICE\\MAPPING",
                       pszKeyName,
                       REG_DWORD,NULL,
                       0,
                       (BYTE *)pdValue,
                       &dwSize);
}
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pbserver\pbserver.cpp ===
/*----------------------------------------------------------------------------
    pbserver.cpp
  
    CPhoneBkServer class implementation

    Copyright (c) 1997-1998 Microsoft Corporation
    All rights reserved.

    Authors:
        byao        Baogang Yao

    History:
    1/23/97     byao     -- Created
    5/29/97     t-geetat -- Modified -- added performance counters, 
                                        shared memory
    5/02/00     sumitc   -- removed db dependency                                   
  --------------------------------------------------------------------------*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <tchar.h>

#include <aclapi.h>

#include "common.h"
#include "pbserver.h"
#include "ntevents.h"

#include "cpsmon.h"

#include "shlobj.h"
#include "shfolder.h"

//
//  Phone book "database" implementation
//
char g_szPBDataDir[2 * MAX_PATH] = "";

HRESULT GetPhoneBook(char * pszPBName,
                     int dLCID,
                     int dOSType,
                     int dOSArch,
                     int dPBVerCurrent,
                     char * pszDownloadPath);

extern "C" 
{
    #include "util.h"
}

const DWORD MAX_BUFFER_SIZE = 1024;     // maximum size of input buffer
const DWORD SEND_BUFFER_SIZE = 4096;    // block size when sending CAB file
const char achDefService[] = "Default"; //default service name
const int dDefPBVer = 0;                // default phone book version number, this should be 0,
                                        // however, since David's test data used 0, we used 0 too.
                                        // SUBJECT TO CHANGE

#define MAX_PATH_LEN    256

// missing value -- if parameter-pair is empty, it is set to this value
const int MISSING_VALUE = -1;

// make this public so the thread can access it
unsigned char g_achDBDirectory[MAX_PATH_LEN+1];     // full path for all phone book files

// constant strings
unsigned char c_szChangeFileName[] = "newpb.txt";     // newpb.txt
unsigned char c_szDBName[] = "pbserver";              // "pbserver" -- data source name


// the following error status code/string is copied from ISAPI.CPP
// which is part of the MFC library source code
typedef struct _httpstatinfo {
    DWORD   dwCode;
    LPCTSTR pstrString;
} HTTPStatusInfo;

//
// The following two structures are used in the SystemTimeToGMT function
//
static  TCHAR * s_rgchDays[] =
{
    TEXT("Sun"),
    TEXT("Mon"),
    TEXT("Tue"),
    TEXT("Wed"),
    TEXT("Thu"),
    TEXT("Fri"),
    TEXT("Sat")
};

static TCHAR * s_rgchMonths[] =
{
    TEXT("Jan"),
    TEXT("Feb"),
    TEXT("Mar"),
    TEXT("Apr"),
    TEXT("May"),
    TEXT("Jun"),
    TEXT("Jul"),
    TEXT("Aug"),
    TEXT("Sep"),
    TEXT("Oct"),
    TEXT("Nov"),
    TEXT("Dec")
};

static HTTPStatusInfo statusStrings[] =
{
    { HTTP_STATUS_OK,               "OK" },
    { HTTP_STATUS_CREATED,          "Created" },
    { HTTP_STATUS_ACCEPTED,         "Accepted" },
    { HTTP_STATUS_NO_CONTENT,       "No download Necessary" },
    { HTTP_STATUS_TEMP_REDIRECT,    "Moved Temporarily" },
    { HTTP_STATUS_REDIRECT,         "Moved Permanently" },
    { HTTP_STATUS_NOT_MODIFIED,     "Not Modified" },
    { HTTP_STATUS_BAD_REQUEST,      "Bad Request" },
    { HTTP_STATUS_AUTH_REQUIRED,    "Unauthorized" },
    { HTTP_STATUS_FORBIDDEN,        "Forbidden" },
    { HTTP_STATUS_NOT_FOUND,        "Not Found" },
    { HTTP_STATUS_SERVER_ERROR,     "Server error, type unknown" },
    { HTTP_STATUS_NOT_IMPLEMENTED,  "Not Implemented" },
    { HTTP_STATUS_BAD_GATEWAY,      "Bad Gateway" },
    { HTTP_STATUS_SERVICE_NA,       "Cannot find service on server, bad request" },
    { 0, NULL }
};


// Server asynchronized I/O context
typedef struct _SERVER_CONTEXT
{
    EXTENSION_CONTROL_BLOCK *   pEcb;
    HSE_TF_INFO                 hseTF;
    TCHAR                       szBuffer[SEND_BUFFER_SIZE];
}
SERVERCONTEXT, *LPSERVERCONTEXT;

DWORD WINAPI MonitorDBFileChangeThread(LPVOID lpParam);
BOOL InitPBFilesPath();

//
// definition of global data
// All the following variable(object) can only have one instance
//  
CPhoneBkServer *    g_pPBServer;        // Phone Book Server object
CNTEvent *          g_pEventLog;        // event log
CRITICAL_SECTION    g_CriticalSection;  // critical section

HANDLE              g_hMonitorThread;   // the monitor thread that checks the new file notification

HANDLE              g_hProcessHeap;     // handle of the global heap for the extension process;

BOOL g_fNewPhoneBook = FALSE;    // whether there's a new phone book
BOOL g_fBeingShutDown = FALSE;   // whether the system is being shut down

//
// Variables used in memory mapping
//
CCpsCounter *g_pCpsCounter = NULL;      // Pointer to memory mapped object
HANDLE g_hSharedFileMapping = NULL;     // Handle to the shared file mapping
HANDLE g_hSemaphore = NULL;             // Handle to the semaphore for shared-file


////////////////////////////////////////////////////////////////////////
//
//  Name:       GetExtensionVersion
//  
//  Class:      CPhoneBkServer
//
//  Synopsis:   implement the first DLL entry point function
//              
//
//  Return:     TRUE    succeed
//              FALSE   
//  
//  Parameters: 
//              pszVer[out]         version information that needs to be filled out
//

BOOL CPhoneBkServer::GetExtensionVersion(LPHSE_VERSION_INFO pVer)
{
    // Set version number
    pVer -> dwExtensionVersion = MAKELONG(HSE_VERSION_MINOR,
                                          HSE_VERSION_MAJOR);

    // Load description string
    lstrcpyn(pVer->lpszExtensionDesc, 
             "Connection Point Server Application",
             HSE_MAX_EXT_DLL_NAME_LEN);

    OutputDebugString("CPhoneBkServer.GetExtensionVersion() : succeeded \n");
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// 
//  Name:       GetParameterPairs
//  
//  Class:      CPhoneBkServer
//
//  Synopsis:   Get the parameter-value pairs from an input string(from URL)
//  
//  Return:     number of parameter pairs actually read
//              a value of -1 stands for error   --> INVALID_QUERY_STRING
//
//  Parameter:
//      pszInputString[in]      Input string (null terminated)
//      lpPairs[out]            Pointer to the parameter/value pairs
//      int dMaxPairs           Maximum number of parameter pairs allowed 
//
int CPhoneBkServer:: GetParameterPairs(char *pszInputString, 
                                       LPPARAMETER_PAIR lpPairs, 
                                       int dMaxPairs) 
{
    int i = 0;

    if (NULL == pszInputString)
    {
        return INVALID_QUERY_STRING;
    }

    for(i = 0; pszInputString[0] != '\0' && i < dMaxPairs; i++)
    {
        // m_achVal == 'p=what%3F';
        GetWord(lpPairs[i].m_achVal, pszInputString, '&', NAME_VALUE_LEN - 1);

        // m_achVal == 'p=what?'   
        UnEscapeURL(lpPairs[i].m_achVal);

        GetWord(lpPairs[i].m_achName,lpPairs[i].m_achVal,'=', NAME_VALUE_LEN - 1);
        // m_achVal = what?
        // m_achName = p
    }

#ifdef _LOG_DEBUG_MESSAGE
    char achMsg[64];

    wsprintf(achMsg, "inside GetParameterPairs: dNumPairs : %d", i);
    LogDebugMessage(achMsg);

    if (pszInputString[0] != '\0') 
        LogDebugMessage("there are more parameters\n");
#endif

    if (pszInputString[0] != '\0')
    {
        // more parameters available
        return INVALID_QUERY_STRING;
    }
    else
    {
        //succeed
        return i;
    }
}

////////////////////////////////////////////////////////////////////////
//
//  Name:       GetQueryParameter
//  
//  Class:      CPhoneBkServer
//
//  Synopsis:   scan through the query string, and get the value for all 
//              query parameters
//
//  Return:     TRUE    all query parameters are correct
//              FALSE   invalid parameter existed
//  
//  Parameters: 
//              pszQuery[in]            Query string from the client(URL encripted)
//              pQueryParameter[out]    pointer to the query parameters structure
//
//
BOOL CPhoneBkServer:: GetQueryParameter(char *pszQuery, LPQUERY_PARAMETER lpQueryParameter)
{
    const int MAX_PARAMETER_NUM = 10;
    PARAMETER_PAIR  Pairs[MAX_PARAMETER_NUM]; // maximum 10 pairs  -- just to be safe.
    int dNumPairs, i;
    
#ifdef _LOG_DEBUG_MESSAGE 
    char achMsg[MAX_BUFFER_SIZE + 50];
    if (0 < _snprintf(achMsg, MAX_BUFFER_SIZE + 50, "pszquery=%s", pszQuery))
    {
        LogDebugMessage(achMsg);
    }
#endif

    dNumPairs = GetParameterPairs(pszQuery, Pairs, MAX_PARAMETER_NUM);

#ifdef _LOG_DEBUG_MESSAGE 
    wsprintf(achMsg, "number of pairs : %d", dNumPairs);
    LogDebugMessage(achMsg);
#endif

    // initialize the parameter values
    // check the validity of the parameter
    m_QueryParameter.m_achPB[0]='\0';  // empty service name
    m_QueryParameter.m_dPBVer =  MISSING_VALUE; // empty pbversion
    m_QueryParameter.m_dOSArch = MISSING_VALUE;
    m_QueryParameter.m_dOSType = MISSING_VALUE;
    m_QueryParameter.m_dLCID = MISSING_VALUE;
    m_QueryParameter.m_achCMVer[0] = '\0';
    m_QueryParameter.m_achOSVer[0] = '\0';

    if (INVALID_QUERY_STRING == dNumPairs)  // invalid number of parameters in query string
    {
        return FALSE;
    }

    for (i = 0; i < dNumPairs; i++)
    {
        _strlwr(Pairs[i].m_achName);

        if (lstrcmpi(Pairs[i].m_achName, "osarch") == 0)
        {
            if (lstrlen(Pairs[i].m_achVal) == 0)
                lpQueryParameter->m_dOSArch = MISSING_VALUE;
            else 
                lpQueryParameter->m_dOSArch = atoi(Pairs[i].m_achVal);
        }
        else if (lstrcmpi(Pairs[i].m_achName, "ostype") == 0)
        {
            if (lstrlen(Pairs[i].m_achVal) == 0)
                lpQueryParameter->m_dOSType = MISSING_VALUE;
            else 
                lpQueryParameter->m_dOSType = atoi(Pairs[i].m_achVal);
        }
        else if (lstrcmpi(Pairs[i].m_achName,"lcid") == 0)
        {
            if (lstrlen(Pairs[i].m_achVal) == 0)
                lpQueryParameter->m_dLCID = MISSING_VALUE;
            else
                lpQueryParameter->m_dLCID = atoi(Pairs[i].m_achVal);
        }
        else if (lstrcmpi(Pairs[i].m_achName,"osver") == 0)
        {
            lstrcpy(lpQueryParameter->m_achOSVer,Pairs[i].m_achVal);
        }
        else if (lstrcmpi(Pairs[i].m_achName,"cmver") == 0)
        {
            lstrcpy(lpQueryParameter->m_achCMVer, Pairs[i].m_achVal);
        }
        else if (lstrcmpi(Pairs[i].m_achName,"pb") == 0)
        {
            lstrcpy(lpQueryParameter->m_achPB,Pairs[i].m_achVal);
        }
        else if (lstrcmpi(Pairs[i].m_achName,"pbver") == 0)
        {
            if (lstrlen(Pairs[i].m_achVal) == 0)
                lpQueryParameter->m_dPBVer = MISSING_VALUE;
            else
                lpQueryParameter->m_dPBVer = atoi(Pairs[i].m_achVal);
        } 
    }

    // LogDebug message:

#ifdef _LOG_DEBUG_MESSAGE 
    sprintf(achMsg, "osarch:%d", m_QueryParameter.m_dOSArch);
    LogDebugMessage(achMsg);

    sprintf(achMsg, "ostype:%d", m_QueryParameter.m_dOSType);
    LogDebugMessage(achMsg);

    sprintf(achMsg, "lcid:%d", m_QueryParameter.m_dLCID);
    LogDebugMessage(achMsg);

    sprintf(achMsg, "osver:%s ", m_QueryParameter.m_achOSVer);
    LogDebugMessage(achMsg);

    sprintf(achMsg, "cmver:%s", m_QueryParameter.m_achCMVer);
    LogDebugMessage(achMsg);

    sprintf(achMsg, "PB :%s ", m_QueryParameter.m_achPB);
    LogDebugMessage(achMsg);

    sprintf(achMsg, "PBVer:%d ", m_QueryParameter.m_dPBVer);
    LogDebugMessage(achMsg);

#endif



    return TRUE;
}

#if 0
/*
////////////////////////////////////////////////////////////////////////
//
//  Name:       FormSQLQuery
//  
//  Class:      CPhoneBkServer
//
//  Synopsis:   Form a SQL query statement for ODBC database server
//
//
void CPhoneBkServer:: FormSQLQuery(char *pszQuery, char *pszService, int dLCID, int dOSType, int dOSArch)
{
    char achTempStr[128];

    lstrcpy(pszQuery,"Select Phonebooks.ISPid, Phonebooks.Version, Phonebooks.LCID");
    lstrcat(pszQuery,", Phonebooks.OS, Phonebooks.Arch, Phonebooks.VirtualPath");
    lstrcat(pszQuery," FROM ISPs, Phonebooks");

    sprintf(achTempStr," WHERE (ISPs.Description Like '%s'", pszService);
    lstrcat(pszQuery,achTempStr);

    lstrcat(pszQuery," AND ISPs.ISPid = Phonebooks.ISPid)");

    sprintf(achTempStr, " AND (Phonebooks.OS = %d)", dOSType);
    lstrcat(pszQuery,achTempStr);

    lstrcat(pszQuery," ORDER BY Phonebooks.Version DESC");
}


//----------------------------------------------------------------------------
//
//  Function:   Virtual2Physical()
//
//  Class:      CPhoneBkServer
//
//  Synopsis:   Convert a virtual path to a physical path
//
//  Arguments:  pEcb        - ISAPI extension control block
//              *pszFileName - the virtual path]
//
//  Returns:    TRUE:  succeed; otherwise FALSE
//
//  History:    05/30/96     VetriV    Created
//              1/25/97      byao      Modified to be used in the phone book 
//                                     server ISAPI
//----------------------------------------------------------------------------
BOOL CPhoneBkServer::Virtual2Physical(EXTENSION_CONTROL_BLOCK * pEcb, 
                                      char * pszVirtualPath,
                                      char * pszPhysicalPath)
{
    DWORD           dw = MAX_PATH;
    LPSTR           lpsz;
    char            szLocalFile[MAX_PATH];
    BOOL            fRet;

    // Is this a relative virtual path?
    //
    if (pszVirtualPath[0] != L'/' && pszVirtualPath[1] != L':')
    {
        // Base this path off of the path of our current script

        fRet = pEcb->GetServerVariable(pEcb->ConnID, "PATH_INFO", szLocalFile, &dw);

        if (FALSE == fRet)
        {
            return FALSE;
        }

        lpsz = _tcsrchr(szLocalFile, '/');
        assert(lpsz != NULL);
        if (!lpsz)
        {
            return FALSE;
        }
        *(++lpsz) = NULL;

        dw = sizeof(szLocalFile) - PtrToLong((const void *)(lpsz - szLocalFile));
    }
    else
    {
        lstrcpy(szLocalFile, pszVirtualPath);
    }
   
    LogDebugMessage("within Virtual2Physical:");
    LogDebugMessage(szLocalFile);

    // Map this to a physical file name
    dw = sizeof(szLocalFile);

    fRet = (*pEcb->ServerSupportFunction)(pEcb->ConnID, HSE_REQ_MAP_URL_TO_PATH, szLocalFile, &dw, NULL);

    if (FALSE == fRet)
    {
        return FALSE;
    }

    lstrcpy(pszPhysicalPath, szLocalFile);
    return TRUE;
}
*/
#endif


//----------------------------------------------------------------------------
//
//  Function:   GetFileLength()
//
//  Class:      CPhoneBkServer
//
//  Synopsis:   Reads the pszFileName file and sends back the file size
//
//  Arguments:  lpszFileName - Contains the file name (with full path)]
//
//  Returns:    TRUE if succeed, otherwise FALSE;
//
//  History:    03/07/97     byao      Created
//
//----------------------------------------------------------------------------
DWORD CPhoneBkServer::GetFileLength(LPSTR lpszFileName)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwFileSize;

    //
    // Open file
    //
    hFile = CreateFile(lpszFileName, 
                        GENERIC_READ, 
                        FILE_SHARE_READ, 
                        NULL, 
                        OPEN_EXISTING, 
                        FILE_FLAG_SEQUENTIAL_SCAN, 
                        NULL);
                       
    if (INVALID_HANDLE_VALUE == hFile)
        return 0L;

    //
    // Get File Size
    //
    dwFileSize = GetFileSize(hFile, NULL);
    CloseHandle(hFile);
    if (-1 == dwFileSize)
    {
        dwFileSize = 0;
    }

    return dwFileSize;
}


//----------------------------------------------------------------------------
//
//  Function:   SystemTimeToGMT
//
//  Synopsis:   Converts the given system time to string representation
//              containing GMT Formatted String
//
//  Arguments:  [st         System time that needs to be converted *Reference*]
//              [pstr       pointer to string which will contain the GMT time 
//                          on successful return]
//              [cbBuff     size of pszBuff in bytes]

//
//  Returns:    TRUE on success.  FALSE on failure.
//
//  History:    04/12/97     VetriV    Created (from IIS source)
//
//----------------------------------------------------------------------------
BOOL SystemTimeToGMT(const SYSTEMTIME & st, LPSTR pszBuff,  DWORD cbBuff)
{
    if (!pszBuff ||  cbBuff < 40 ) 
    {
        return FALSE;
    }

    //
    //  Formats a string like: "Thu, 14 Jul 1994 15:26:05 GMT"
    //
    sprintf(pszBuff, "%s, %02d %s %d %02d:%02d:%0d GMT", 
                    s_rgchDays[st.wDayOfWeek],
                    st.wDay,
                    s_rgchMonths[st.wMonth - 1],
                    st.wYear,
                    st.wHour,
                    st.wMinute,
                    st.wSecond);

    return TRUE;

} 
                    

//----------------------------------------------------------------------------
//
//  Function:   FormHttpHeader
//
//  Synopsis:   Form's the IIS 3.0 HTTP Header
//
//  Arguments:  pszBuffer       Buffer that will contain both the header and the 
//                              status text
//              pszResponse     status text
//              pszExtraHeader  extra header information
//
//  Returns:    ERROR_SUCCESS on success.  Error code on failure.
//
//  History:    04/12/97     VetriV    Created 
//              05/22/97     byao      Modified, to make it work with CPS server
//----------------------------------------------------------------------------
DWORD FormHttpHeader(LPSTR pszBuffer, LPSTR pszResponse, LPSTR pszExtraHeader)
{

    // start with stand IIS header
    wsprintf(pszBuffer, 
             "HTTP/1.0 %s\r\nServer: Microsoft-IIS/3.0\r\nDate: ",
             pszResponse);
    
    //
    // Append the time
    //
    SYSTEMTIME SysTime;
    TCHAR szTime[128];
    GetSystemTime(&SysTime);
    if (FALSE == SystemTimeToGMT(SysTime, szTime, 128))
    {
        //
        // TODO: Error Handling
        //
    }
    lstrcat(pszBuffer, szTime);
    lstrcat(pszBuffer, "\r\n");
    // Append extra header string
    lstrcat(pszBuffer, pszExtraHeader);

    return ERROR_SUCCESS;
}

//----------------------------------------------------------------------------
//
//  Function:   HseIoCompletion
//
//  Synopsis:   Callback routine that handles asynchronous WriteClient
//                  completion callback
//
//  Arguments:  [pECB       - Extension Control Block]
//              [pContext   - Pointer to the AsyncWrite structure]
//              [cbIO       - Number of bytes written]
//              [dwError    - Error code if there was an error while writing]
//
//  Returns:    None
//
//  History:    04/10/97     VetriV    Created
//              05/22/97     byao      Modified to make it work for CPS server
//
//----------------------------------------------------------------------------
VOID HseIoCompletion(EXTENSION_CONTROL_BLOCK * pEcb,
                     PVOID pContext,
                     DWORD cbIO,
                     DWORD dwError)
{
    LPSERVERCONTEXT lpServerContext = (LPSERVERCONTEXT) pContext;

    if (!lpServerContext)
    {
        return;
    }

    lpServerContext->pEcb->ServerSupportFunction(  
                                    lpServerContext->pEcb->ConnID,
                                    HSE_REQ_DONE_WITH_SESSION,
                                    NULL,
                                    NULL,
                                    NULL);

    if (lpServerContext->hseTF.hFile != INVALID_HANDLE_VALUE) 
    { 
        CloseHandle(lpServerContext->hseTF.hFile);
    }

    HeapFree(g_hProcessHeap, 0, lpServerContext);
    
    SetLastError(dwError);
    
    return;
}


////////////////////////////////////////////////////////////////////////
//
//  Name:       HttpExtensionProc
//  
//  Class:      CPhoneBkServer
//
//  Synopsis:   implement the second DLL entry point function
//              
//  Return:     HTTP status code
//  
//  Parameters: 
//              pEcb[in/out]   - extension control block
//
//  History:    Modified    byao        5/22/97
//              new implementation: using asynchronized I/O
//              Modified    t-geetat : Added PerfMon counters
//
/////////////////////////////////////////////////////////////////////////
DWORD CPhoneBkServer:: HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK pEcb)
{
    DWORD dwBufferLen = MAX_BUFFER_SIZE;
    char  achQuery[MAX_BUFFER_SIZE], achMsg[128];
    char  achPhysicalPath[MAX_PATH_LEN];

    int   dVersionDiff;  // version difference between client & server's phone books

    BOOL  fRet;
    DWORD dwStatusCode = NOERROR;
    int   dwRet;  
    DWORD dwCabFileSize;

    BOOL fHasContent = FALSE;
    CHAR szResponse[64];
    char  achExtraHeader[128];
    char  achHttpHeader[1024];
    char  achBuffer[SEND_BUFFER_SIZE];
    DWORD dwResponseSize;

    LPSERVERCONTEXT lpServerContext;
    HSE_TF_INFO  hseTF;
    QUERY_PARAMETER QueryParameter;

    g_pCpsCounter->AddHit(TOTAL);

    // get the query string
    fRet = (*pEcb->GetServerVariable)(pEcb->ConnID, 
                                       "QUERY_STRING", 
                                       achQuery, 
                                       &dwBufferLen);

    //
    //  If there is an error, log an NT event and leave.
    //
    if (!fRet)
    {
        dwStatusCode = GetLastError();

#ifdef _LOG_DEBUG_MESSAGE 
        switch (dwStatusCode)
        {
        case ERROR_INVALID_PARAMETER:
            lstrcpy(achMsg,"error: invalid parameter");
            break;
            
        case ERROR_INVALID_INDEX:
            lstrcpy(achMsg,"error: invalid index");
            break;
            
        case ERROR_INSUFFICIENT_BUFFER:
            lstrcpy(achMsg,"error: insufficient buffer");
            break;
            
        case ERROR_MORE_DATA:
            lstrcpy(achMsg,"error: more data coming");
            break;
            
        case ERROR_NO_DATA:
            lstrcpy(achMsg,"error: no data available");
            break;
        }

    LogDebugMessage(achMsg);
#endif
        wsprintf(achMsg, "%ld", dwStatusCode);
        g_pEventLog -> FLogError(PBSERVER_CANT_GET_PARAMETER, achMsg);

        goto CleanUp;
    }

    LogDebugMessage("prepare to get query parameters");

    // parse the query string, get the value of each parameter
    GetQueryParameter(achQuery, &QueryParameter);

    // check the validity of the parameter
    if (MISSING_VALUE == QueryParameter.m_dOSArch  ||
        MISSING_VALUE == QueryParameter.m_dOSType ||
        MISSING_VALUE == QueryParameter.m_dLCID   ||
        0 == lstrlen(QueryParameter.m_achCMVer)   ||
        0 == lstrlen(QueryParameter.m_achOSVer))
    {
         // invalid data 
        dwStatusCode = HTTP_STATUS_BAD_REQUEST;
        goto CleanUp;
    }

    //
    //  Use defaults for some missing values
    //
    if (0 == lstrlen(QueryParameter.m_achPB))
    {
        lstrcpy(QueryParameter.m_achPB, achDefService);
    }
    if (MISSING_VALUE == QueryParameter.m_dPBVer)
    {
        QueryParameter.m_dPBVer = dDefPBVer;
    }

    // DebugBreak();

#ifdef _LOG_DEBUG_MESSAGE 
    sprintf(achMsg, "in main thread, g_fNewPhoneBook = %s;",
            g_fNewPhoneBook ?  "TRUE" : "FALSE");
    LogDebugMessage(achMsg);
#endif

    HRESULT hr;

    hr = GetPhoneBook(QueryParameter.m_achPB,
                      QueryParameter.m_dLCID,
                      QueryParameter.m_dOSType, 
                      QueryParameter.m_dOSArch,
                      QueryParameter.m_dPBVer,
                      achPhysicalPath);

    fHasContent = FALSE;
    
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        // we couldn't find the required file (phonebook name is probably bad)
        dwStatusCode = HTTP_STATUS_SERVICE_NA;
    }
    else if (FAILED(hr))
    {
        // some other error
        dwStatusCode = HTTP_STATUS_SERVER_ERROR;
    }
    else if (S_FALSE == hr)
    {
        // you don't need a phone book
        dwStatusCode = HTTP_STATUS_NO_CONTENT;
    }
    else
    {
        // we have a phone book for you...
        fHasContent = TRUE;
        dwStatusCode = HTTP_STATUS_OK;
    }

CleanUp:

    if (HTTP_STATUS_OK != dwStatusCode && HTTP_STATUS_NO_CONTENT != dwStatusCode)
    {
        g_pCpsCounter->AddHit(ERRORS);
    }

    // DebugBreak();
    
    LogDebugMessage("download file:");
    LogDebugMessage(achPhysicalPath);

    // convert virtual path to physical path
    if (fHasContent)
    {
        // get cab file size
        dwCabFileSize = GetFileLength(achPhysicalPath);
    }

    BuildStatusCode(szResponse, dwStatusCode);
    dwResponseSize = lstrlen(szResponse);

    dwRet = HSE_STATUS_SUCCESS;

    // prepare for the header
    if (HTTP_STATUS_OK == dwStatusCode && dwCabFileSize)
    {
        // not a NULL cab file
        wsprintf(achExtraHeader,
                 "Content-Type: application/octet-stream\r\nContent-Length: %ld\r\n\r\n",
                 dwCabFileSize);
    }
    else
    {
        lstrcpy(achExtraHeader, "\r\n"); // just send back an empty line
    }


    // set up asynchronized I/O context

    lpServerContext = NULL;
    lpServerContext = (LPSERVERCONTEXT) HeapAlloc(g_hProcessHeap, 
                                                  HEAP_ZERO_MEMORY, 
                                                  sizeof(SERVERCONTEXT));
    if (!lpServerContext)
    {
        wsprintf(achMsg, "%ld", GetLastError());
        g_pEventLog->FLogError(PBSERVER_ERROR_INTERNAL, achMsg);
        return HSE_STATUS_ERROR;
    }

    lpServerContext->pEcb = pEcb;
    lpServerContext->hseTF.hFile = INVALID_HANDLE_VALUE;

    if (!pEcb->ServerSupportFunction(pEcb->ConnID,
                                      HSE_REQ_IO_COMPLETION,
                                      HseIoCompletion,
                                      0,
                                      (LPDWORD) lpServerContext))
    {
        wsprintf(achMsg, "%ld", GetLastError());
        g_pEventLog->FLogError(PBSERVER_ERROR_INTERNAL, achMsg);

        HeapFree(g_hProcessHeap, 0, lpServerContext);
        return HSE_STATUS_ERROR;
    }

    // if there's no content, send header and status code back using WriteClient();
    // otherwise, use TransmitFile to send the file content back
    FormHttpHeader(achHttpHeader, szResponse, achExtraHeader);
    lstrcpy(lpServerContext->szBuffer, achHttpHeader);

    //
    // send status code or the file back
    //
    dwRet = HSE_STATUS_PENDING;
    
    if (!fHasContent)
    {
        // Append status text as the content
        lstrcat(lpServerContext->szBuffer, szResponse);
        dwResponseSize = lstrlen(lpServerContext->szBuffer);

        if (pEcb->WriteClient(pEcb->ConnID, 
                               lpServerContext->szBuffer,
                               &dwResponseSize,
                               HSE_IO_ASYNC) == FALSE)
        {
            pEcb->dwHttpStatusCode = HTTP_STATUS_SERVER_ERROR;
            dwRet = HSE_STATUS_ERROR;
            
            wsprintf(achMsg, "%ld", GetLastError());
            g_pEventLog->FLogError(PBSERVER_ERROR_CANT_SEND_HEADER,achMsg);

            HeapFree(g_hProcessHeap, 0, lpServerContext);
            return dwRet;
        }
    }
    else
    {
        // send file back using TransmitFile
        HANDLE hFile = INVALID_HANDLE_VALUE;
        hFile = CreateFile(achPhysicalPath,
                            GENERIC_READ, 
                            FILE_SHARE_READ, 
                            NULL, 
                            OPEN_EXISTING, 
                            FILE_FLAG_SEQUENTIAL_SCAN, 
                            NULL);
                       
        if (INVALID_HANDLE_VALUE == hFile)
        {
            wsprintf(achMsg, "%s (%u)", achPhysicalPath, GetLastError());
            g_pEventLog->FLogError(PBSERVER_ERROR_CANT_OPEN_FILE, achMsg);

            HeapFree(g_hProcessHeap, 0, lpServerContext);
            return HSE_STATUS_ERROR;
        }

        lpServerContext->hseTF.hFile = hFile;

        lpServerContext->hseTF.pfnHseIO = NULL;
        lpServerContext->hseTF.pContext = lpServerContext;

        lpServerContext->hseTF.BytesToWrite = 0; // entire file
        lpServerContext->hseTF.Offset = 0;  // from beginning

        lpServerContext->hseTF.pHead = lpServerContext->szBuffer;
        lpServerContext->hseTF.HeadLength = lstrlen(lpServerContext->szBuffer);

        lpServerContext->hseTF.pTail = NULL;
        lpServerContext->hseTF.TailLength = 0;

        lpServerContext->hseTF.dwFlags = HSE_IO_ASYNC | HSE_IO_DISCONNECT_AFTER_SEND;
        
        if (!pEcb->ServerSupportFunction(pEcb->ConnID,
                                      HSE_REQ_TRANSMIT_FILE,
                                      &(lpServerContext->hseTF),
                                      0,
                                      NULL))
        {
            wsprintf(achMsg, "%ld", GetLastError());
            g_pEventLog->FLogError(PBSERVER_ERROR_CANT_SEND_CONTENT,achMsg);
            dwRet = HSE_STATUS_ERROR;

            CloseHandle(lpServerContext->hseTF.hFile);
            HeapFree(g_hProcessHeap, 0, lpServerContext);
            return dwRet;
        }
    }

    return HSE_STATUS_PENDING;
}


//
// build status string from code
// 
void CPhoneBkServer::BuildStatusCode(LPTSTR pszResponse, DWORD dwCode)
{
    assert(pszResponse);

    HTTPStatusInfo * pInfo = statusStrings;

    while (pInfo->pstrString)
    {
        if (dwCode == pInfo->dwCode)
        {
            break;
        }
        pInfo++;
    }

    if (pInfo->pstrString)
    {
        wsprintf(pszResponse, "%d %s", dwCode, pInfo->pstrString);
    }
    else
    {
        assert(dwCode != HTTP_STATUS_OK);
        // ISAPITRACE1("Warning: Nonstandard status code %d\n", dwCode);
        BuildStatusCode(pszResponse, HTTP_STATUS_OK);
    }
}

//
// DLL initialization function
//
BOOL WINAPI DllMain(HINSTANCE hInst, ULONG ulReason,
                    LPVOID lpReserved)
{
    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH: 
        //DebugBreak();
        OutputDebugString("DllMain: process attach\n");
        return InitProcess();
        break;

    case DLL_PROCESS_DETACH:
        LogDebugMessage("process detach");
        break;
    }

    return TRUE;
}

//
// global initialization procedure. 
// 
BOOL InitProcess()
{
    //TODO: in order to avoid any future problems, any significant initialization 
    //      should be done in GetExtensionVersion()
    DWORD               dwID;
    DWORD               dwServiceNameLen;
    SECURITY_ATTRIBUTES sa;
    PACL                pAcl = NULL;

    g_fBeingShutDown = FALSE;

    //
    //  May throw STATUS_NO_MEMORY if memory is low.  We want to make sure this
    //  doesn't bring down the process (the admin may have configured pbserver
    //  to run in-process)
    //
    __try
    {
        OutputDebugString("InitProcess:  to InitializeCriticalSection ... \n"); 
        // initialize CriticalSection
        InitializeCriticalSection(&g_CriticalSection);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
#if DBG
        char achMsg[256];
        DWORD dwErr = GetExceptionCode();
        
        wsprintf(achMsg,"InitProcess: InitializeCriticalSection failed, thread=%ld ExceptionCode=%08lx", GetCurrentThreadId(), dwErr);
        OutputDebugString(achMsg);
#endif
        return FALSE;
    }

    OutputDebugString("InitProcess:  to GetProcessHeap() ... \n");  
    g_hProcessHeap = GetProcessHeap();
    if (NULL == g_hProcessHeap)
    {
        goto failure;
    }

    OutputDebugString("InitProcess:  to new CNTEvent... \n");   

    g_pEventLog = new CNTEvent("Phone Book Service");
    if (NULL == g_pEventLog) 
        goto failure;

/*
    // check for validity of timebomb
    dwServiceNameLen = lstrlen(SERVICE_NAME);
    
    if (!IsTimeBombValid(SERVICE_NAME, dwServiceNameLen)) {
        g_pEventLog -> FLogError(PBSERVER_ERROR_SERVICE_EXPIRED);
        goto failure;
    }
*/

    // Begin Geeta
    //
    // Create a semaphore for the shared memory
    //
    
    // Initialize a default Security attributes, giving world permissions,
    // this is basically prevent Semaphores and other named objects from
    // being created because of default acls given by winlogon when perfmon
    // is being used remotely.
    sa.bInheritHandle = FALSE;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = malloc(sizeof(SECURITY_DESCRIPTOR));
    if ( !sa.lpSecurityDescriptor )
    {
        goto failure;
    }

    if ( !InitializeSecurityDescriptor(sa.lpSecurityDescriptor,SECURITY_DESCRIPTOR_REVISION) ) 
    {
        goto failure;
    }

    // bug 30991: Security issue, don't use NULL DACLs.
    //
    if (FALSE == SetAclPerms(&pAcl))
    {
        goto failure;
    }

    if (FALSE == SetSecurityDescriptorDacl(sa.lpSecurityDescriptor, TRUE, pAcl, FALSE)) 
    {
        goto failure;
    }

    OutputDebugString("InitProcess: To create semaphone...\n");

    g_hSemaphore = CreateSemaphore( &sa,    // Security attributes
                1,                          // Initial Count
                1,                          // Max count
                SEMAPHORE_OBJECT );         // Semaphore name -- in "cpsmon.h"

    if (ERROR_ALREADY_EXISTS == GetLastError())
    {
        //
        //  We're not expecting anyone to have this semaphore already created.
        //  In the interests of security (a pre-existing semaphore could have been
        //  created by anyone, and we don't want anyone other than ourselves owning
        //  the pbsmon semaphore), we exit.
        //
        OutputDebugString("InitProcess: semaphore already exists - exiting.\n");
        assert(0);
        goto failure;
        // ISSUE-2000/10/30-SumitC Note that if pbserver is taken down without the
        //                         chance to delete the semaphore, we can't restart
        //                         until the machine is rebooted.
    }

    if ( NULL == g_hSemaphore )  
    {
        goto failure;
    }
    
    OutputDebugString("InitProcess: To initialize shared memory ...\n");
    //
    // initialize Shared memory
    //
    if (!InitializeSharedMem(sa))
    {
        goto failure;
    }

    // free the memory
    free ((void *) sa.lpSecurityDescriptor);
        
    OutputDebugString("InitProcess: To grant permissions SHARED_OBJECT...\n");

    //
    // initialize Counters
    //
    OutputDebugString("InitProcess: To initialize perfmon counters\n");
    g_pCpsCounter->InitializeCounters();

    // End Geeta

    //
    //  Initialize the global variables.  Note: must do this before Creating the
    //  monitor thread (because of g_szPBDataDir, g_achDBFileName etc)
    //
    if (!InitPBFilesPath())
    {
        goto failure;
    }

    char achTempName[MAX_PATH_LEN+1];
    char szDBFileName[MAX_PATH_LEN+1];
    DWORD dwBufferSize;
    char *pszFoundPosition;

    // get the full path name for the data base
    wsprintf(achTempName, "SOFTWARE\\ODBC\\ODBC.INI\\%s", c_szDBName);
    OutputDebugString(achTempName);

    dwBufferSize = sizeof(szDBFileName);
    if (!GetRegEntry(HKEY_LOCAL_MACHINE, 
                     achTempName, 
                     "DBQ",
                     REG_SZ,
                     NULL,
                     0,
                     (unsigned char *)&szDBFileName,
                     &dwBufferSize)) 
    {
        /*
        wsprintf(achMsg,"HKLM\\%s\\DBQ : Error code %ld", achTempName, GetLastError());
        g_pEventLog->FLogError(PBSERVER_ERROR_ODBC_CANT_READ_REGISTRY, achMsg);
        */

        goto failure;
    }

    // initialize the NewDBFilename -->  actually newpb.mdb
    //          & the ChangeFileName --> actually newpb.txt
    //
    lstrcpy(achTempName, szDBFileName);
    pszFoundPosition = _tcsrchr(achTempName, '\\');  // found the last '\' --> path info
    if( pszFoundPosition != NULL)
    {
        *(pszFoundPosition+1) = '\0';
    }

    // store the directory name for the phone book files
    lstrcpy((char *)g_achDBDirectory, achTempName);

    //
    // initialize PhoneBookServer object
    // PhoneBookServer object should be the last to initialize because
    // it requires some other objects to be initialized first, such as 
    // eventlog, critical section, odbc interface, etc.

    OutputDebugString("InitProcess: To new a phone book server\n");
    g_pPBServer = new CPhoneBkServer;
    if (NULL == g_pPBServer)
    {
        return FALSE;
    }

    OutputDebugString("InitProcess: To create a thread for DB file change monitoring\n");
    // create the thread to monitor file change
    g_hMonitorThread = CreateThread(
                            NULL, 
                            0, 
                            (LPTHREAD_START_ROUTINE)MonitorDBFileChangeThread, 
                            NULL, 
                            0, 
                            &dwID
                        );

    if (INVALID_HANDLE_VALUE == g_hMonitorThread)
    {
        g_pEventLog->FLogError(PBSERVER_ERROR_INTERNAL);
        goto failure;
    }
    SetThreadPriority(g_hMonitorThread, THREAD_PRIORITY_ABOVE_NORMAL);

    return TRUE;

failure:  // clean up everything in case of failure
    OutputDebugString("InitProcess: failed\n");

    DeleteCriticalSection(&g_CriticalSection);

    // free the memory
    if (sa.lpSecurityDescriptor)
    {
        free ((void *) sa.lpSecurityDescriptor);
    }
    
    if (g_pEventLog)
    {
        delete g_pEventLog; 
        g_pEventLog = NULL;
    }

    if (g_pPBServer)
    {
        delete g_pPBServer;
        g_pPBServer = NULL;
    }

    if (pAcl)
    {
        LocalFree(pAcl);
    }    
    
    // Begin geeta
    if (g_hSemaphore)
    {
        CloseHandle(g_hSemaphore);
        g_hSemaphore = NULL;
    }
    // end geeta
    
    return FALSE;
}


// global cleanup process
BOOL CleanUpProcess()
{
    HANDLE hFile; // handle for the temporary file
    DWORD dwResult;
    char achDumbFile[2 * MAX_PATH + 4];
    char achMsg[64];

    // kill the change monitor thread
    if (g_hMonitorThread != INVALID_HANDLE_VALUE)
    {
        // now try to synchronize between the main thread and the child thread

        // step1: create a new file in g_szPBDataDir, therefore unblock the child thread
        //        which is waiting for such a change in file directory
        g_fBeingShutDown = TRUE;
        lstrcpy(achDumbFile, (char *)g_szPBDataDir);
        lstrcat(achDumbFile,"temp");

        // create a temp file, then delete it! 
        // This is to create a change in the directory so the child thread can exit itself
        FILE * fpTemp = fopen(achDumbFile, "w");
        if (fpTemp)
        {
            fclose(fpTemp);
            DeleteFile(achDumbFile);
        }

        // step2: wait for the child thread to terminate
        dwResult = WaitForSingleObject(g_hMonitorThread, 2000L);  // wait for one second
        if (WAIT_FAILED == dwResult)
        { 
            wsprintf(achMsg, "%ld", GetLastError());
            g_pEventLog -> FLogError(PBSERVER_ERROR_WAIT_FOR_THREAD, achMsg);
        }

        if (g_hMonitorThread != INVALID_HANDLE_VALUE)
        {
            CloseHandle(g_hMonitorThread);
        }
    }
    
    // disconnect from ODBC
    if (g_pPBServer)
    {
        delete g_pPBServer;
        g_pPBServer = NULL;
    }

    // clean up all allocated resources
    if (g_pEventLog)
    {
        delete g_pEventLog;
        g_pEventLog = NULL;
    }

    // Begin Geeta
    //
    //  Close the semaphore
    //
    if ( NULL != g_hSemaphore )
    {
        CloseHandle(g_hSemaphore);
        g_hSemaphore = NULL;
        OutputDebugString("CLEANUPPROCESS: Semaphore deleted\n");
    }

    //
    //  Close the shared memory object
    //
    CleanUpSharedMem();
    // End Geeta

    DeleteCriticalSection(&g_CriticalSection);

    return TRUE;
}


// Entry Points of this ISAPI Extension DLL

// ISA entry point function. Intialize the server object g_pPBServer
BOOL WINAPI GetExtensionVersion(LPHSE_VERSION_INFO pVer)
{
    return g_pPBServer ? g_pPBServer->GetExtensionVersion(pVer) : FALSE;
}


// ISA entry point function. Implemented through object g_pPBServer
DWORD WINAPI HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK pEcb)
{
    DWORD dwRetCode;

    if (NULL == g_pPBServer)
    {
        return HSE_STATUS_ERROR;
    }
        
    dwRetCode = g_pPBServer->HttpExtensionProc(pEcb);
    
    return dwRetCode;   
    
}


//
// The standard entry point called by IIS as the last function.
//
BOOL WINAPI TerminateExtension(DWORD dwFlags)
{
    return CleanUpProcess();    
}


//
//  StrEqual(achStr, pszStr)
//
//  Test whether achStr is equal to pszStr.
//  Please note: the point here is: achStr is not zero-ended

BOOL StrEqual(char achStr[], char *pszStr)
{
    int i;

    for (i = 0; i < lstrlen(pszStr); i++)
    {
        if (achStr[i] != pszStr[i])
        {
            return FALSE;
        }
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   MonitorDBFileChangeThread
//
//  Synopsis:   Call the MonitorDBFileChange method to monitor any write to
//              the database file
//
//  Arguments:  [lpParam]   -- additional thread parameter
//
//  History:    01/28/97     byao  Created
//
//----------------------------------------------------------------------------
DWORD WINAPI MonitorDBFileChangeThread(LPVOID lpParam)
{
    HANDLE  hDir = NULL;
    char    achMsg[256];
    DWORD   dwRet = 0;
    DWORD   dwNextEntry, dwAction, dwFileNameLength, dwOffSet;
    char    achFileName[MAX_PATH_LEN+1];
    char    achLastFileName[MAX_PATH_LEN+1];
    
    //
    //  open a handle to the PBS dir, which we're going to monitor
    //
    hDir = CreateFile (
            (char *)g_achDBDirectory,           // pointer to the directory name
            FILE_LIST_DIRECTORY,                // access (read-write) mode
            FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,  // share mode
            NULL,                               // security descriptor
            OPEN_EXISTING,                      // how to create
            FILE_FLAG_BACKUP_SEMANTICS,         // file attributes
            NULL                                // file with attributes to copy
           );

    if (INVALID_HANDLE_VALUE == hDir)
    {
        wsprintf(achMsg, "%ld", GetLastError());
        g_pEventLog->FLogError(PBSERVER_ERROR_CANT_CREATE_FILE, (char *)g_szPBDataDir, achMsg);
        dwRet = 1L;
        goto Cleanup;
    }
    
    while (1)
    {
        const DWORD c_dwMaxChanges = 1024;
        BYTE        arrChanges[c_dwMaxChanges]; 
        DWORD       dwNumChanges;

        //
        //  This is a synchronous call - we sit here waiting for something to
        //  change in this directory.  If something does, we check to see if it
        //  is something for which we should log an event.
        //
        if (!ReadDirectoryChangesW(hDir, 
                                   arrChanges, 
                                   c_dwMaxChanges, 
                                   FALSE,
                                   FILE_NOTIFY_CHANGE_LAST_WRITE,
                                   &dwNumChanges,
                                   NULL,
                                   NULL))
        {
            //
            //  if this fails, log the failure and leave
            //
            wsprintf(achMsg, "%ld", GetLastError()); 
            g_pEventLog->FLogError(PBSERVER_ERROR_CANT_DETERMINE_CHANGE, achMsg); 
            OutputDebugString(achMsg);
            dwRet = 1L;
            goto Cleanup;
        }  

        OutputDebugString("detected a file system change\n");   
        achLastFileName[0] = TEXT('\0');
        dwNextEntry = 0;

        do 
        {
            DWORD dwBytes;

            FILE_NOTIFY_INFORMATION * pFNI = (FILE_NOTIFY_INFORMATION*) &arrChanges[dwNextEntry];

            // check only the first change 
            dwOffSet = pFNI->NextEntryOffset;
            dwNextEntry += dwOffSet;
            dwAction = pFNI->Action; 
            dwFileNameLength = pFNI->FileNameLength;

            OutputDebugString("prepare to convert the changed filename\n");
            //TODO: check whether we can use UNICODE for all filenames
            dwBytes = WideCharToMultiByte(CP_ACP, 
                                          0,
                                          pFNI->FileName,
                                          dwFileNameLength,
                                          achFileName,
                                          MAX_PATH_LEN,
                                          NULL,
                                          NULL);

            if (0 == dwBytes) 
            {
                // failed to convert filename
                g_pEventLog->FLogError(PBSERVER_ERROR_CANT_CONVERT_FILENAME, achFileName);
                OutputDebugString("Can't convert filename\n");
                continue;
            }

            //
            //  Conversion succeeded.  Null-terminate the filename.
            //
            achFileName[dwBytes/sizeof(WCHAR)] = '\0';

            if (0 == _tcsicmp(achLastFileName, achFileName))
            {
                // the same file changed
                OutputDebugString("the same file changed again\n");
                continue;
            }

            // keep the last filename
            _tcscpy(achLastFileName, achFileName);

            if (g_fBeingShutDown)
            {
                //
                //  Time to go ...
                //
                dwRet = 1L;
                goto Cleanup;
            }

            //
            //  now a file has changed. Test whether it's monitored file 'newpb.txt'
            //
            LogDebugMessage(achLastFileName);
            LogDebugMessage((char *)c_szChangeFileName);

            if ((0 == _tcsicmp(achLastFileName, (char *)c_szChangeFileName)) &&
                (FILE_ACTION_ADDED == dwAction || FILE_ACTION_MODIFIED == dwAction)) 
            {
                EnterCriticalSection(&g_CriticalSection);
                LogDebugMessage("entered critical section!");

                g_fNewPhoneBook = TRUE;

                LogDebugMessage("leaving critical section!");
                LeaveCriticalSection(&g_CriticalSection);

                g_pEventLog->FLogInfo(PBSERVER_INFO_NEW_PHONEBOOK);
            }

#ifdef _LOG_DEBUG_MESSAGE 
            sprintf(achMsg, "in child thread, g_fNewPhoneBook = %s;",
                    g_fNewPhoneBook ?  "TRUE" : "FALSE");
            LogDebugMessage(achMsg);
#endif
        }
        while (dwOffSet);
    }

Cleanup:

    if (hDir)
    {
        CloseHandle(hDir);
    }

    return dwRet;
}

// Begin Geeta
//----------------------------------------------------------------------------
//
//  Function:   GetSemaphore
//
//  Synopsis:   This function gets hold of the semaphore for accessing shared file.
//
//  Arguments:  None.
//
//  Returns:    TRUE if succeeds, FALSE if fails.
//
//  History:    06/02/97     t-geetat  Created
//
//----------------------------------------------------------------------------
BOOL GetSemaphore()
{
    DWORD   WaitRetValue = WaitForSingleObject( g_hSemaphore, INFINITE );

    switch (WaitRetValue)
    {
    case WAIT_OBJECT_0:
        return TRUE ;
    case WAIT_ABANDONED:
        return TRUE;
    default:
        return FALSE;
    }

    return FALSE;
}


//----------------------------------------------------------------------------
//
//  Function:   InitializeSharedMem
//
//  Synopsis:   Sets up the memory mapped file
//
//  Arguments:  SECURITY_ATTRIBUTES sa: security descriptor for this object
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//  History:    05/29/97  Created by Geeta Tarachandani
//
//----------------------------------------------------------------------------
BOOL InitializeSharedMem(SECURITY_ATTRIBUTES sa)
{   
    //
    // Create a memory mapped object
    //
    OutputDebugString("InitializeSharedMem: to create file mapping\n");
    g_hSharedFileMapping = CreateFileMapping( 
                        INVALID_HANDLE_VALUE,       // Shared object is in memory
                        &sa,                        // security descriptor
                        PAGE_READWRITE| SEC_COMMIT, // Desire R/W access
                        0,                          // |_
                        sizeof(CCpsCounter),        // |  Size of mapped object
                        SHARED_OBJECT );            // Shared Object

    if (NULL == g_hSharedFileMapping) 
    {
        goto CleanUp;
    }

    OutputDebugString("InitializeSharedMem: MapViewofFileEx\n");
    g_pCpsCounter = (CCpsCounter *) MapViewOfFileEx(
                         g_hSharedFileMapping,  // Handle to shared file
                         FILE_MAP_WRITE,        // Write access desired
                         0,                     // Mapping offset
                         0,                     // Mapping offset
                         sizeof(CCpsCounter),   // Mapping object size
                         NULL );                // Any base address

    if (NULL == g_pCpsCounter) 
    {
        goto CleanUp;
    }

    return TRUE;

CleanUp:
    CleanUpSharedMem();
    return FALSE;

}


//----------------------------------------------------------------------------
//
//  Function:   InitializeCounters()
//
//  Class:      CCpsCounter
//
//  Synopsis:   Initializes all the Performance Monitoring Counters to 0
//
//  Arguments:  None
//
//  Returns:    void
//
//  History:    05/29/97  Created by Geeta Tarachandani
//
//----------------------------------------------------------------------------

void CCpsCounter::InitializeCounters( void )
{
    m_dwTotalHits       =0;
    m_dwNoUpgradeHits   =0;
    m_dwDeltaUpgradeHits=0;
    m_dwFullUpgradeHits =0;
    m_dwErrors          =0;
}

inline void CCpsCounter::AddHit(enum CPS_COUNTERS eCounter)
{
    if (GetSemaphore()) 
    {
        switch (eCounter)
        {
        case TOTAL:
            g_pCpsCounter->m_dwTotalHits ++;
            break;
        case NO_UPGRADE:
            g_pCpsCounter->m_dwNoUpgradeHits ++;
            break;
        case DELTA_UPGRADE:
            g_pCpsCounter->m_dwDeltaUpgradeHits ++;
            break;
        case FULL_UPGRADE:
            g_pCpsCounter->m_dwFullUpgradeHits ++;
            break;
        case ERRORS:
            g_pCpsCounter->m_dwErrors ++;
            break;
        default:
            OutputDebugString("Unknown counter type");
            break;
        }
    }

    ReleaseSemaphore(g_hSemaphore, 1, NULL);
}


//----------------------------------------------------------------------------
//
//  Function:   CleanUpSharedMem()
//
//  Synopsis:   Unmaps the shared file & closes all file handles
//
//  Arguments:  None
//
//  Returns:    Void
//
//  History:    06/01/97  Created by Geeta Tarachandani
//
//----------------------------------------------------------------------------
void CleanUpSharedMem()
{
    //
    // Unmap the shared file
    //
    if (g_pCpsCounter)
    {
        UnmapViewOfFile( g_pCpsCounter );
        g_pCpsCounter = NULL;
    }

    CloseHandle(g_hSharedFileMapping);
    g_hSharedFileMapping = NULL;
}

// End Geeta


BOOL InitPBFilesPath()
{
    if (lstrlen(g_szPBDataDir))
    {
        return TRUE;
    }
    else
    {
        //
        //  Get location of PB files on this machine (\program files\phone book service\data)
        //

        if (S_OK == SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES, NULL, SHGFP_TYPE_CURRENT, g_szPBDataDir))
        {
            lstrcat(g_szPBDataDir, "\\phone book service\\Data\\");
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
}


HRESULT GetCurrentPBVer(char * pszPBName, int * pnCurrentPBVer)
{
    HRESULT hr = S_OK;
    char    szTmp[2 * MAX_PATH];
    int     nNewestPB = 0;

    assert(pszPBName);
    assert(pnCurrentPBVer);

    if (!pszPBName || !pnCurrentPBVer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!InitPBFilesPath())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  go to subdir named 'pszPBName', and find all FULL cabs.
    //
    wsprintf(szTmp, "%s%s\\*full.cab", g_szPBDataDir, pszPBName);

    HANDLE hFind;
    WIN32_FIND_DATA finddata;

    hFind = FindFirstFile(szTmp, &finddata);
    if (INVALID_HANDLE_VALUE == hFind)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Cleanup;
    }

    //
    //  Find the highest-numbered full cab we have, and cache that number
    //
    do
    {
        int nVer;
        int nRet = sscanf(finddata.cFileName, "%dfull.cab", &nVer);
        if (1 == nRet)
        {
            if (nVer > nNewestPB)
            {
                nNewestPB = nVer;
            }
        }
    }
    while (FindNextFile(hFind, &finddata));
    FindClose(hFind);

    *pnCurrentPBVer = nNewestPB;

#if DBG

    //
    //  re-iterate, looking for deltas.
    //
    wsprintf(szTmp, "%s%s\\*delta*.cab", g_szPBDataDir, pszPBName);

    hFind = FindFirstFile(szTmp, &finddata);
    if (INVALID_HANDLE_VALUE == hFind)
    {
        OutputDebugString("found Nfull, but no deltas (this is ok if this is the first phonebook)");
        goto Cleanup;
    }

    do
    {
        int nVerTo, nVerFrom;
        int nRet = sscanf(finddata.cFileName, "%ddelta%d.cab", &nVerTo, &nVerFrom);
        if (2 == nRet)
        {
            if (nVerTo > nNewestPB)
            {
                assert(0 && "largest DELTA cab has corresponding FULL cab missing");
                break;
            }
        }
    }
    while (FindNextFile(hFind, &finddata));
    FindClose(hFind);
#endif

Cleanup:
    return hr;
}

BOOL
CheckIfFileExists(const char * psz)
{
    HANDLE hFile = CreateFile(psz,
                              GENERIC_READ, 
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        return FALSE;
    }
    else
    {
        CloseHandle(hFile);
        return TRUE;
    }
}


HRESULT
GetPhoneBook(IN  char * pszPBName,
             IN  int dLCID,
             IN  int dOSType,
             IN  int dOSArch,
             IN  int dPBVerCaller,
             OUT char * pszDownloadPath)
{
    HRESULT hr = S_OK;
    int     dVersionDiff;
    int     nCurrentPBVer;
#if DBG
    char    achMsg[256];
#endif

    assert(pszPBName);
    assert(pszDownloadPath);
    if (!pszPBName || !pszDownloadPath)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = GetCurrentPBVer(pszPBName, &nCurrentPBVer);
    if (S_OK != hr)
    {
        goto Cleanup;
    }

    dVersionDiff = nCurrentPBVer - dPBVerCaller;

    if (dVersionDiff <= 0)
    {
        //
        //  no download
        //
        hr = S_FALSE;

        g_pCpsCounter->AddHit(NO_UPGRADE);
    }
    else
    {
        if (dVersionDiff < 5 && 0 != dPBVerCaller)
        {
            //
            //  incremental update => try to find the delta cab
            //
            wsprintf(pszDownloadPath, "%s%s\\%dDELTA%d.cab",
                     g_szPBDataDir, pszPBName, nCurrentPBVer, dPBVerCaller);
            // x:\program files\phone book service\  phone_book_name \ nDELTAm.cab

            if (!CheckIfFileExists(pszDownloadPath))
            {
                hr = S_FALSE;
            }
            else
            {
                g_pCpsCounter->AddHit(DELTA_UPGRADE);
            }
        }

        //
        //  note that if we tried to find a delta above and failed, hr is set to
        //  S_FALSE, so we fall through to the full download below.
        //

        if (dVersionDiff >= 5 || 0 == dPBVerCaller || S_FALSE == hr)
        {
            //
            //  bigger than 5, or no pb at all => full download
            //
            wsprintf(pszDownloadPath, "%s%s\\%dFULL.cab",
                     g_szPBDataDir, pszPBName, nCurrentPBVer);
            // x:\program files\phone book service\  phone_book_name \ nFULL.cab

            if (!CheckIfFileExists(pszDownloadPath))
            {
                hr = S_OK;
                // return "success", the failure to open the file will be trapped
                // by caller.
            }
            else
            {
                if (S_FALSE == hr)
                {
                    hr = S_OK;
                }
                g_pCpsCounter->AddHit(FULL_UPGRADE);
            }
        }
    }

Cleanup:
    
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pbserver\setacl.cpp ===
//+----------------------------------------------------------------------------
//
// File:    setacl.cpp
//
// Module:  PBSERVER.DLL
//
// Synopsis: Security/SID/ACL stuff for CM
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  09-Mar-2000 SumitC  Created
//
//+----------------------------------------------------------------------------

#include <windows.h>

//+----------------------------------------------------------------------------
//
// Func:    SetAclPerms
//
// Desc:    Sets appropriate permissions for CM/CPS's shared objects
//
// Args:    [ppAcl] - location to return an allocated ACL
//
// Return:  BOOL, TRUE for success, FALSE for failure
//
// Notes:   fix for 30991: Security issue, don't use NULL DACLs.
//
// History: 09-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
SetAclPerms(PACL * ppAcl)
{
    DWORD                       dwError = 0;
    SID_IDENTIFIER_AUTHORITY    siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    siaNtAuth = SECURITY_NT_AUTHORITY;
    PSID                        psidWorldSid = NULL;
    PSID                        psidLocalSystemSid = NULL;
    int                         cbAcl;
    PACL                        pAcl = NULL;

    // Create a SID for all users
    if ( !AllocateAndInitializeSid(  
            &siaWorld,
            1,
            SECURITY_WORLD_RID,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            &psidWorldSid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    // Create a SID for Local System account
    if ( !AllocateAndInitializeSid(  
            &siaNtAuth,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0,
            0,
            0,
            0,
            0,
            0,
            &psidLocalSystemSid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    // Calculate the length of required ACL buffer
    // with 2 ACEs.
    cbAcl =     sizeof(ACL)
            +   2 * sizeof(ACCESS_ALLOWED_ACE)
            +   GetLengthSid(psidWorldSid)
            +   GetLengthSid(psidLocalSystemSid);

    pAcl = (PACL) LocalAlloc(0, cbAcl);
    if (NULL == pAcl)
    {
        dwError = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    if ( ! InitializeAcl(pAcl, cbAcl, ACL_REVISION2))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    // Add ACE with EVENT_ALL_ACCESS for all users
    if ( ! AddAccessAllowedAce(pAcl,
                               ACL_REVISION2,
                               GENERIC_READ | GENERIC_EXECUTE,
                               psidWorldSid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    // Add ACE with EVENT_ALL_ACCESS for Local System
    if ( ! AddAccessAllowedAce(pAcl,
                               ACL_REVISION2,
                               GENERIC_ALL,
                               psidLocalSystemSid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

Cleanup:

    if (dwError)
    {
        if (pAcl)
        {
           LocalFree(pAcl);
        }
    }
    else
    {
        *ppAcl = pAcl;
    }

    if (psidWorldSid)
    {
        FreeSid(psidWorldSid);
    }

    if (psidLocalSystemSid)
    {
        FreeSid(psidLocalSystemSid);
    }
        
    return dwError ? FALSE : TRUE;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pbsmon\cpsmon.h ===
/*----------------------------------------------------------------------------
    cpsmon.h
  
    Header file shared by pbsmon.cpp & pbserver.dll -- Has the shared memory object

    Copyright (c) 1997-1998 Microsoft Corporation
    All rights reserved.

    Authors:
        t-geetat    Geeta Tarachandani

    History:
    5/29/97 t-geetat    Created
  --------------------------------------------------------------------------*/
#define SHARED_OBJECT    "MyCCpsCounter"
#define SEMAPHORE_OBJECT     "Sem_MyCpsMon"

enum CPS_COUNTERS
{
    TOTAL,
    NO_UPGRADE,
    DELTA_UPGRADE,
    FULL_UPGRADE,
    ERRORS
};

class CCpsCounter {
public :
    
    DWORD m_dwTotalHits;
    DWORD m_dwNoUpgradeHits;
    DWORD m_dwDeltaUpgradeHits;
    DWORD m_dwFullUpgradeHits;
    DWORD m_dwErrors;

    void InitializeCounters( void );
    void AddHit(enum CPS_COUNTERS eCounter);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pbsmon\cpsmon.cpp ===
/*----------------------------------------------------------------------------
	Cpsmon.cpp
  
	Implementation of pbsmon.dll -- the perfmon DLL for counting the number of
	                                times the phone book server was accessed 
					since it started

    Copyright (c) 1997-1998 Microsoft Corporation
    All rights reserved.

    Authors:
        t-geetat	Geeta Tarachandani

    History:
	6/2/97	t-geetat	Created
  --------------------------------------------------------------------------*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "cpsmon.h"
#include "CpsSym.h"
#include "LoadData.h"

BOOL		g_bOpenOK		=FALSE;		// TRUE if Open went OK, FALSE otherwise
DWORD		g_dwNumOpens	=0;			// Active "opens" reference counts

CPSMON_DATA_DEFINITION g_CpsMonDataDef;
HANDLE		g_hSharedFileMapping=NULL;	// Handle to shared file map
CCpsCounter *g_pCpsCounter=NULL;		// Pointer to the shared object
HANDLE		g_hSemaphore=NULL;			// Handle to semaphore for shared file

//----------------------------------------------------------------------------
//
//  Function:   GetSemaphore
//
//  Synopsis:   This function gets hold of the semaphore for accessing shared file.
//
//  Arguments:  None.
//
//	Returns:	TRUE if succeeds, FALSE if fails.
//
//  History:    06/02/97     t-geetat  Created
//
//----------------------------------------------------------------------------
BOOL GetSemaphore()
{
	DWORD	WaitRetValue = WaitForSingleObject( g_hSemaphore, INFINITE );
	
	switch( WaitRetValue ) 
	{

	case	WAIT_OBJECT_0	: return TRUE ;
	case	WAIT_ABANDONED	: return TRUE;
	default					: return FALSE;
	
	}

	return FALSE;
}

//----------------------------------------------------------------------------
//
//  Function:   OpenPerfMon
//
//  Synopsis:   This function opens & maps the shared memory used to pass 
//              counter-values between the phone-book server & perfmon.dll
//				It also initializes the data-structures used to pass data back
//				to the registry
//
//  Arguments:  lpDeviceName -- Pointer to object ID of the device to be opened
//							 --> Should be NULL.
//
//	Returns:	ERROR_SUCCESS if succeeds, GetLastError() if fails.
//
//  History:    06/02/97     t-geetat  Created
//
//----------------------------------------------------------------------------
DWORD OpenPerfMon( LPWSTR lpDeviceName )
{

	if ( g_bOpenOK ) 
	{
		g_dwNumOpens ++;
		return ERROR_SUCCESS;
	}


	/*--------------------
	 *	Open the semaphore
	 *-------------------*/
	if(g_hSemaphore == NULL)
	{
		g_hSemaphore = OpenSemaphore( 
			SYNCHRONIZE | SEMAPHORE_MODIFY_STATE,	// Desired for sync
			FALSE,						// Inheritance not desired
			SEMAPHORE_OBJECT );				// Semaphore name -- from "cpsmon.h"
	}
	if ( NULL == g_hSemaphore )
	{
		//
		// the phone book server DLL should create this Semaphore. So we can assume
		// the server has not been loaded yet. Just return silently.
		//
		return ERROR_SUCCESS;
	}

	
	/*-------------------------------------
	 *	Open shared memory ( if exists )
	 *------------------------------------*/
	g_hSharedFileMapping = OpenFileMapping(
				FILE_MAP_READ,				// Read only access desired
				FALSE,					// Don't want to inherit
				SHARED_OBJECT);			// from "cpsmon.h"

	if ( NULL == g_hSharedFileMapping )	
	{
		goto CleanUp;
	}

	
	/*----------------------------------
	 *	Map the shared-file into memory
	 *---------------------------------*/
	g_pCpsCounter = (CCpsCounter *)MapViewOfFileEx(
					g_hSharedFileMapping,	// File mapping handle
					FILE_MAP_READ,		// Read only access desired
					0,			// 	|_ File Offset
					0,			//	|
					sizeof( CCpsCounter ),	// no. of bytes to map
					NULL );			// Any address

	if ( NULL == g_pCpsCounter ) 
	{
		goto CleanUp;
	}

	
	/*------------------------------------------------
	 *	Initialize the data-structure g_CpsMonDataDef
	 *-----------------------------------------------*/
	InitializeDataDef();

	
	/*-----------------------------------------------------------------
	 *	Update static data strucutures g_CpsMonDataDef by adding base to
	 *  the	offset value in the structure.
	 *-----------------------------------------------------------------*/
	if (!UpdateDataDefFromRegistry()) 
	{
		goto CleanUp;
	}

	
	/*-------------
	 * Success  :)
	 *-------------*/
	g_bOpenOK = TRUE;
	g_dwNumOpens ++;
	return ERROR_SUCCESS;


CleanUp :
	/*-------------
	 *	Failure :(
	 *-------------*/

	if ( NULL != g_hSemaphore )	
	{
		CloseHandle( g_hSemaphore );
		g_hSemaphore = NULL;
	}

	if ( NULL != g_hSharedFileMapping )	
	{
		CloseHandle( g_hSharedFileMapping );
		g_hSharedFileMapping = NULL;
	}
	 
	if ( NULL != g_pCpsCounter ) 
	{
		g_pCpsCounter = NULL;
	}

	return GetLastError();
}

//----------------------------------------------------------------------------
//
//  Function:   CollectPerfMon
//
//  Synopsis:   This function opens & maps the shared memory used to pass 
//              counter-values between the phone-book server & perfmon.dll
//				It also initializes the data-structures used to pass data back
//				to the registry
//
//  Arguments:  
//		lpwszValue	Pointer to wide character string passed by registry
//
//		lppData	IN  :	Pointer to address of buffer to receive completed 
//						PerfDataBlock and subordinate structures This routine
//						appends its data to the buffer starting at *lppData.
//				OUT :	Points to the first byte after the data structure added
//						by this routine.
//			
//		lpcbTotalBytes	IN  :	Address of DWORD that tells the size in bytes 
//								of the buffer *lppData.
//						OUT :	The number of bytes added by this routine is
//								written to the DWORD pointed to by this arg.
//
//		lpcObjectTypes	IN  :	Address of DWORD to receive the number of
//								objects added by this routine
//						OUT :	The number of objs. added by this routine.
//
//	Returns:	ERROR_SUCCESS if succeeds, GetLastError() if fails.
//
//  History:    06/02/97     t-geetat  Created
//
//----------------------------------------------------------------------------
DWORD CollectPerfMon( 
	IN		LPWSTR	lpwszValue,
	IN	OUT	LPVOID	*lppData,
	IN	OUT	LPDWORD	lpcbTotalBytes,
	IN	OUT	LPDWORD	lpcObjectTypes
)
{
	DWORD		dwQueryType;
	CPSMON_DATA_DEFINITION	*pCpsMonDataDef;
	CPSMON_COUNTERS			*pCpsMonCounters;
	DWORD		SpaceNeeded = 0;

	//See if the semaphore was created after the intial OpenPerfmon. 
	
	if(g_hSemaphore == NULL)
	{
		g_hSemaphore = OpenSemaphore( 
			SYNCHRONIZE | SEMAPHORE_MODIFY_STATE,	// Desired for sync
			FALSE,						// Inheritance not desired
			SEMAPHORE_OBJECT );				// Semaphore name -- from "cpsmon.h"
		 if(g_hSemaphore)
		{
		OpenPerfMon(NULL);
		}
	}

	if ( NULL == g_hSemaphore )
	{
		//
		// the phone book server DLL should create this Semaphore. So we can assume
		// the server has not been loaded yet. Just return silently.
		//
		*lpcbTotalBytes	= (DWORD) 0;
		*lpcObjectTypes = (DWORD) 0;
		return ERROR_SUCCESS;
	}

	
		
	/*------------------------
	 * Check if Open went OK
	 *------------------------*/
	if ( !g_bOpenOK ) 
	{
		/*-----------------------------------------
		 *	Unable to continue because open failed
		 *-----------------------------------------*/
		*lpcbTotalBytes	= (DWORD) 0;
		*lpcObjectTypes = (DWORD) 0;
		return ERROR_SUCCESS;
	}
	
	
	/*------------------------------------
	 *	Retrieve the TYPE of the request
	 *------------------------------------*/
	dwQueryType = GetQueryType( lpwszValue );

	if ( QUERY_FOREIGN == dwQueryType )
	{
		/*-------------------------------------
		 *	Unable to service non-NT requests
		 *------------------------------------*/
		*lpcbTotalBytes = (DWORD) 0;
		*lpcObjectTypes = (DWORD) 0;
		return ERROR_SUCCESS;
	}


	if ( QUERY_ITEMS == dwQueryType )
	{
		/*-----------------------------------------------
		 *	The registry is asking for specifis objects.
		 *  Check if we're one of the chosen
		 *-----------------------------------------------*/
		if ( !IsNumberInUnicodeList(
					  g_CpsMonDataDef.m_CpsMonObjectType.ObjectNameTitleIndex,
					  lpwszValue ) )
		{
			*lpcbTotalBytes = (DWORD) 0;
			*lpcObjectTypes = (DWORD) 0;
			return ERROR_SUCCESS;
		}
	}

	
	/*-------------------------------------------
	 * We need space for header and the counters
	 * Let's see if there's enough space
	 *-------------------------------------------*/
	SpaceNeeded = sizeof(CPSMON_DATA_DEFINITION) + sizeof( CPSMON_COUNTERS );
	
	if ( SpaceNeeded > *lpcbTotalBytes )  
	{
		*lpcbTotalBytes = (DWORD) 0;
		*lpcObjectTypes = (DWORD) 0;
		return ERROR_MORE_DATA;
	}


	/*-------------------------------------------------------------
	 * Copy the initialized Object Type & the Counter Definitions
	 * into the caller's data buffer
	 *-------------------------------------------------------------*/
	pCpsMonDataDef = (CPSMON_DATA_DEFINITION *) *lppData;

	memmove( pCpsMonDataDef, &g_CpsMonDataDef, sizeof(CPSMON_DATA_DEFINITION) );
	

	/*--------------------------------
	 * Now try to retrieve the data
	 *-------------------------------*/
	pCpsMonCounters = (CPSMON_COUNTERS *)(pCpsMonDataDef + 1);

	if ( GetSemaphore() ) 
	{

		CPSMON_COUNTERS CpsMonCounters =	{
			// The PERF_COUNTER_BLOCK structure
			{ { sizeof( CPSMON_COUNTERS )}, 0},
			// The RAW counters
			g_pCpsCounter->m_dwTotalHits,
			g_pCpsCounter->m_dwNoUpgradeHits,
			g_pCpsCounter->m_dwDeltaUpgradeHits,
			g_pCpsCounter->m_dwFullUpgradeHits,	 
			g_pCpsCounter->m_dwErrors,
			// The RATE counters
			g_pCpsCounter->m_dwTotalHits,
			g_pCpsCounter->m_dwNoUpgradeHits,
			g_pCpsCounter->m_dwDeltaUpgradeHits,
			g_pCpsCounter->m_dwFullUpgradeHits,
			g_pCpsCounter->m_dwErrors,

		};
		memmove( pCpsMonCounters, &CpsMonCounters, sizeof(CPSMON_COUNTERS) );
	}
	
  	ReleaseSemaphore( g_hSemaphore, 1, NULL );



	/*-------------------------------
	 * Update arguements for return
	 *------------------------------*/
	*lppData = (LPBYTE)(*lppData) + SpaceNeeded;	
	*lpcObjectTypes = 1;
	*lpcbTotalBytes = SpaceNeeded;


	/*--------------------
	 * Success at last :)
	 *-------------------*/
	return ERROR_SUCCESS;

}

//----------------------------------------------------------------------------
//
//  Function:   ClosePerfMon
//
//  Synopsis:   This function closes the open handles to the shared file and semaphore
//
//  Arguments:  None
//
//	Returns:	ERROR_SUCCESS
//
//  History:    06/03/97     t-geetat  Created
//
//----------------------------------------------------------------------------
DWORD ClosePerfMon()
{
	g_dwNumOpens --;

	if ( NULL != g_hSharedFileMapping )	
	{	
		CloseHandle( g_hSharedFileMapping );
	}
	
	if ( NULL != g_hSemaphore ) 
	{
		CloseHandle(g_hSemaphore);
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pbsmon\cpssym.h ===
/*----------------------------------------------------------------------------
	CpsSym.h
  
	Symbol file for entry into registry

    Copyright (c) 1997-1998 Microsoft Corporation
    All rights reserved.

    Authors:
        t-geetat	Geeta Tarachandani

    History:
	6/2/97	t-geetat	Created
  --------------------------------------------------------------------------*/

#define OBJECT_CPS_SERVER		0

#define COUNTER_TOTAL_HITS		2
#define COUNTER_NO_UPGRADE		4
#define	COUNTER_DELTA_UPGRADE	6
#define	COUNTER_FULL_UPGRADE	8
#define COUNTER_ERRORS			10

#define COUNTER_TOTAL_HITS_PER_SEC		12
#define COUNTER_NO_UPGRADE_PER_SEC		14
#define	COUNTER_DELTA_UPGRADE_PER_SEC	16
#define	COUNTER_FULL_UPGRADE_PER_SEC	18
#define COUNTER_ERRORS_PER_SEC			20
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pbsmon\loaddata.h ===
/*----------------------------------------------------------------------------
	LoadData.h
  
	Header file for return structures to cpsmon.cpp 

    Copyright (c) 1997-1998 Microsoft Corporation
    All rights reserved.

    Authors:
        t-geetat	Geeta Tarachandani

    History:
	6/2/97	t-geetat	Created
  --------------------------------------------------------------------------*/

#include <winperf.h>

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

typedef struct _CPSMON_DATA_DEFINITION 
{
    PERF_OBJECT_TYPE		m_CpsMonObjectType;

    PERF_COUNTER_DEFINITION	m_CpsMonTotalHits;
    PERF_COUNTER_DEFINITION	m_CpsMonNoUpgrade;
    PERF_COUNTER_DEFINITION	m_CpsMonDeltaUpgrade;
    PERF_COUNTER_DEFINITION	m_CpsMonFullUpgrade;
    PERF_COUNTER_DEFINITION	m_CpsMonErrors;

    PERF_COUNTER_DEFINITION	m_CpsMonTotalHitsPerSec;
    PERF_COUNTER_DEFINITION	m_CpsMonNoUpgradePerSec;
    PERF_COUNTER_DEFINITION	m_CpsMonDeltaUpgradePerSec;
    PERF_COUNTER_DEFINITION	m_CpsMonFullUpgradePerSec;
    PERF_COUNTER_DEFINITION	m_CpsMonErrorsPerSecs;

} CPSMON_DATA_DEFINITION;

#define NUM_OF_INFO_COUNTERS	((	sizeof(CPSMON_DATA_DEFINITION) -  \
									sizeof(PERF_OBJECT_TYPE)) /		\
									sizeof(PERF_COUNTER_DEFINITION) )

extern CPSMON_DATA_DEFINITION	g_CpsMonDataDef;

// The following is for alignment
typedef struct _INFO_COUNTER_BLOCK 
{
	PERF_COUNTER_BLOCK  m_PerfCounterBlock;
	LARGE_INTEGER		DummyForAlignment;

} INFO_COUNTER_BLOCK;

typedef struct _CPSMON_COUNTERS 
{
    INFO_COUNTER_BLOCK  m_CounterBlock;

    DWORD               m_dwTotalHits;
    DWORD               m_dwNoUpgrade;
    DWORD               m_dwDeltaUpgrade;
    DWORD               m_dwFullUpgrade;
    DWORD               m_dwErrors;

    DWORD               m_dwTotalHitsPerSec;
    DWORD               m_dwNoUpgradePerSec;
    DWORD               m_dwDeltaUpgradePerSec;
    DWORD               m_dwFullUpgradePerSec;
    DWORD               m_dwErrorsPerSec;

} CPSMON_COUNTERS;

BOOL UpdateDataDefFromRegistry();
void InitializeDataDef();
DWORD GetQueryType ( IN LPWSTR lpValue );
BOOL IsNumberInUnicodeList ( IN DWORD   dwNumber, IN LPWSTR  lpwszUnicodeList );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\adsi.cpp ===
/*
	File	adsi.cpp

	Com interaction with adsi

	Paul Mayfield, 4/14/98
*/

#include "dsrights.h"
#include "sddl.h"
#include "mprapip.h"
#include "dsgetdc.h"

// Definition for convenience
//
#define DSR_ADS_RIGHT_GENERIC_READ (ADS_RIGHT_READ_CONTROL    | \
                                    ADS_RIGHT_DS_LIST_OBJECT  | \
                                    ADS_RIGHT_DS_READ_PROP    | \
                                    ADS_RIGHT_ACTRL_DS_LIST   )

#define DSR_ADS_ACE_INHERITED (ADS_ACEFLAG_INHERIT_ONLY_ACE   | \
                               ADS_ACEFLAG_INHERIT_ACE)


#define DSR_ADS_FLAG_ALL (ADS_FLAG_OBJECT_TYPE_PRESENT | \
                          ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT)

#define MPRFLAG_DOMAIN_ALL (MPRFLAG_DOMAIN_NT4_SERVERS | \
                            MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS)

//
// Describes an Access control entry
//
typedef struct _DSR_ACE_DESCRIPTOR
{
    LONG   dwAccessMask;
    LONG   dwAceType;
    LONG   dwAceFlags;
    LONG   dwFlags;
    BSTR   bstrTrustee;
    BSTR   bstrObjectType;
    BSTR   bstrInheritedObjectType;
    DWORD  dwMode;
} DSR_ACE_DESCRIPTOR;

//
// Structure maps a domain object to the ACES that should be
// added or removed from it in order to enable/disable legacy
// ras servers in the domain
//
typedef struct _DSR_ACE_APPLICATION
{
    IADs* pObject;
    DWORD dwCount;
    DSR_ACE_DESCRIPTOR* pAces;

} DSR_ACE_APPLICATION;

//
// Parameters used to generate a DSR_ACE_APPLICATION
//
typedef struct _DSR_ACE_APPLICATION_DESC
{
    PWCHAR pszObjectCN;         // NULL means domain root
    PWCHAR pszObjectClass;
    DWORD dwCount;
    DSR_ACE_DESCRIPTOR* pAces;

} DSR_ACE_APPLICATION_DESC;

//
// Structure contains the information needed to have
// ACL's in the AD of a given domain adjusted such that 
// the various modes (MPR_DOMAIN_*) of access are granted.
//
typedef struct _DSR_DOMAIN_ACCESS_INFO
{
    // The name of a DC in the target domain
    //
    PWCHAR pszDC;

    // Aces 
    //
    DSR_ACE_APPLICATION* pAces;
    DWORD dwAceCount;

    // Stored here for convenience, pointers
    // to common ds objects
    //
    IADs* pDomain;      
    IADs* pRootDse;

} DSR_DOMAIN_ACCESS_INFO;

//
// Strings used in DS queries
//
static const WCHAR pszLdapPrefix[]           = L"LDAP://";
static const WCHAR pszLdap[]                 = L"LDAP:";
static const WCHAR pszCN[]                   = L"CN=";
static const WCHAR pszGCPrefix[]             = L"GC://";
static const WCHAR pszGC[]                   = L"GC:";
static const WCHAR pszRootDse[]              = L"RootDSE";
static const WCHAR pszSecurityDesc[]         = L"ntSecurityDescriptor";
static const WCHAR pszDn[]                   = L"distinguishedName";
static const WCHAR pszSid[]                  = L"objectSid";
static const WCHAR pszEveryone[]             = L"S-1-1-0";
static const WCHAR pszDefaultNamingContext[] = L"defaultNamingContext";

static const WCHAR pszSystemClass[]          = L"Container";
static const WCHAR pszSystemCN[]             = L"CN=System";

static const WCHAR pszBuiltinClass[]         = L"builtinDomain";
static const WCHAR pszBuiltinCN[]            = L"CN=Builtin";

static const WCHAR pszSamSvrClass[]          = L"samServer";
static const WCHAR pszSamSvrCN[]             = L"CN=Server,CN=System";

static const WCHAR pszAccessChkClass[]       = L"Container";
static const WCHAR pszAccessChkCN[]          = 
    L"CN=RAS and IAS Servers Access Check,CN=System";

static const WCHAR pszGuidUserParms[]        =
    L"{BF967A6D-0DE6-11D0-A285-00AA003049E2}";

static const WCHAR pszGuidUserClass[]        =
    L"{BF967ABA-0DE6-11D0-A285-00aa003049E2}";

//
// This GUID is the property set of the following
// attributes needed for w2k level access.
//
// Token-Groups
// msNPAllowDialin
// msNPCallingStationID
// msRADIUSCallbackNumber
// msRADIUSFramedIPAddress
// msRADIUSFramedRoute
// msRADIUSServiceType
// 
static const WCHAR pszGuidRasPropSet1[]      =
    L"{037088F8-0AE1-11D2-B422-00A0C968F939}";

//
// This GUID is the property set of the following
// attributes needed for w2k level access
//
// User-Account-Control
// Account-Expires
//
static const WCHAR pszGuidRasPropSet2[]      =
    L"{4C164200-20C0-11D0-A768-00AA006E0529}";

//
// This GUID is the property of the following
// attribute needed for w2k level access
//
// Logon-Hours
//
static const WCHAR pszGuidLogonHours[]      =
    L"{BF9679AB-0DE6-11D0-A285-00AA003049E2}";

//
// This GUID is the value of the samAccountName 
// attribute needed for w2k level access.
//
// samAccountName
//
static const WCHAR pszGuidSamAccountName[]  =
    L"{3E0ABFD0-126A-11D0-A060-00AA006C33ED}";

// The optimal means for searching for a computer
// in a domain is to lookup its sam account name which
// is indexed.  The optimal means for searching for a
// group of a given sid is to lookup its SID which is indexed.
//
const WCHAR pszCompFilterFmt[]       = L"(samaccountname=%s$)";
const WCHAR pszGroupFilterFmt[]      = L"(objectSid=%s)";
const WCHAR pszUserClassFmt[]        =
                L"(&(objectClass=user)(!(objectClass=computer)))";

//
// Aces to be added to the domain root
//
DSR_ACE_DESCRIPTOR g_pAcesRoot[] = 
{                                  
    // Grant list options to everyone for the root domain
    // object (needed for nt4 servers in this domain)
    //
    {
        ADS_RIGHT_ACTRL_DS_LIST,        // dwAccessMask
        ADS_ACETYPE_ACCESS_ALLOWED,     // dwAceType
        0,                              // dwAceFlags
        0,                              // dwFlags
        (PWCHAR)pszEveryone,            // bstrTrustee
        NULL,                           // bstrObjectType
        NULL,                           // bstrInheritedObjectType
        MPRFLAG_DOMAIN_ALL              // mode
    },
    
    // Allow everyone to read the userparms property enabling 
    // this inheritable ACE to the root domain object
    // (needed for nt4 servers in this domain)
    {
        ADS_RIGHT_DS_READ_PROP,           // dwAccessMask
        ADS_ACETYPE_ACCESS_ALLOWED_OBJECT,// dwAceType
        DSR_ADS_ACE_INHERITED,            // dwAceFlags
        DSR_ADS_FLAG_ALL,                 // dwFlags
        (PWCHAR)pszEveryone,              // bstrTrustee
        (PWCHAR)pszGuidUserParms,         // bstrObjectType
        (PWCHAR)pszGuidUserClass,         // bstrInheritedObjectType
        MPRFLAG_DOMAIN_ALL                // mode
    },
    
    // All users should expose their RAS properties
    //
    {
        ADS_RIGHT_DS_READ_PROP,            // dwAccessMask
        ADS_ACETYPE_ACCESS_ALLOWED_OBJECT, // dwAceType
        DSR_ADS_ACE_INHERITED,             // dwAceFlags
        DSR_ADS_FLAG_ALL,                  // dwFlags
        (PWCHAR)pszEveryone,               // bstrTrustee
        (PWCHAR)pszGuidRasPropSet1,        // bstrObjectType
        (PWCHAR)pszGuidUserClass,          // bstrInheritedObjectType
        MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS  // mode
    },

    // All users should expose their RAS properties
    //
    {
        ADS_RIGHT_DS_READ_PROP,            // dwAccessMask
        ADS_ACETYPE_ACCESS_ALLOWED_OBJECT, // dwAceType
        DSR_ADS_ACE_INHERITED,             // dwAceFlags
        DSR_ADS_FLAG_ALL,                  // dwFlags
        (PWCHAR)pszEveryone,               // bstrTrustee
        (PWCHAR)pszGuidRasPropSet2,        // bstrObjectType
        (PWCHAR)pszGuidUserClass,          // bstrInheritedObjectType
        MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS  // mode
    },

    // All users should expose their logon hours property
    //
    {
        ADS_RIGHT_DS_READ_PROP,            // dwAccessMask
        ADS_ACETYPE_ACCESS_ALLOWED_OBJECT, // dwAceType
        DSR_ADS_ACE_INHERITED,             // dwAceFlags
        DSR_ADS_FLAG_ALL,                  // dwFlags
        (PWCHAR)pszEveryone,               // bstrTrustee
        (PWCHAR)pszGuidLogonHours,         // bstrObjectType
        (PWCHAR)pszGuidUserClass,          // bstrInheritedObjectType
        MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS  // mode
    },

    // All users should expose their samAccountName
    //
    {
        ADS_RIGHT_DS_READ_PROP,            // dwAccessMask
        ADS_ACETYPE_ACCESS_ALLOWED_OBJECT, // dwAceType
        DSR_ADS_ACE_INHERITED,             // dwAceFlags
        DSR_ADS_FLAG_ALL,                  // dwFlags
        (PWCHAR)pszEveryone,               // bstrTrustee
        (PWCHAR)pszGuidSamAccountName,     // bstrObjectType
        (PWCHAR)pszGuidUserClass,          // bstrInheritedObjectType
        MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS  // mode
    }
};

// 
// Aces to be added to the builtin class
//
DSR_ACE_DESCRIPTOR g_pAcesBuiltin[] = 
{
    {
        ADS_RIGHT_ACTRL_DS_LIST,    // dwAccessMask
        ADS_ACETYPE_ACCESS_ALLOWED, // dwAceType
        0,                          // dwAceFlags
        0,                          // dwFlags
        (PWCHAR)pszEveryone,        // bstrTrustee
        NULL,                       // bstrObjectType
        NULL,                       // bstrInheritedObjectType
        MPRFLAG_DOMAIN_ALL          // mode
    }
};

// 
// Aces to be added to the sam server object
//
DSR_ACE_DESCRIPTOR g_pAcesSamSvr[] = 
{
    {
        DSR_ADS_RIGHT_GENERIC_READ, // dwAccessMask
        ADS_ACETYPE_ACCESS_ALLOWED, // dwAceType
        0,                          // dwAceFlags
        0,                          // dwFlags
        (PWCHAR)pszEveryone,        // bstrTrustee
        NULL,                       // bstrObjectType
        NULL,                       // bstrInheritedObjectType
        MPRFLAG_DOMAIN_ALL          // mode
    }
};

// 
// Aces to be added to the system container
//
DSR_ACE_DESCRIPTOR g_pAcesSystem[] = 
{
    {
        ADS_RIGHT_ACTRL_DS_LIST,        // dwAccessMask
        ADS_ACETYPE_ACCESS_ALLOWED,     // dwAceType
        0,                              // dwAceFlags
        0,                              // dwFlags
        (PWCHAR)pszEveryone,            // bstrTrustee
        NULL,                           // bstrObjectType
        NULL,                           // bstrInheritedObjectType
        MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS  // mode
    }
};            

// 
// Aces to be added to the ras and ias servers access check obj.
//
DSR_ACE_DESCRIPTOR g_pAcesAccessCheck[] = 
{
    {
        DSR_ADS_RIGHT_GENERIC_READ,     // dwAccessMask
        ADS_ACETYPE_ACCESS_ALLOWED,     // dwAceType
        0,                              // dwAceFlags
        0,                              // dwFlags
        (PWCHAR)pszEveryone,            // bstrTrustee
        NULL,                           // bstrObjectType
        NULL,                           // bstrInheritedObjectType
        MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS  // mode
    }
};           

//
// The table of aces to be applied
//
DSR_ACE_APPLICATION_DESC g_pAces[] =
{
    {
        NULL,                               // Object (NULL = root)
        NULL,                               // Object class
        sizeof(g_pAcesRoot) / sizeof(*g_pAcesRoot), 
        g_pAcesRoot
    },

    // Grant list contents to everyone for the builtin
    //
    {
        (PWCHAR)pszBuiltinCN,               // Object
        (PWCHAR)pszBuiltinClass,            // Object class
        sizeof(g_pAcesBuiltin) / sizeof(*g_pAcesBuiltin), 
        g_pAcesBuiltin
    },

    // Grant generic read to everyone on the sam server
    // object 
    //
    {
        (PWCHAR)pszSamSvrCN,                // Object
        (PWCHAR)pszSamSvrClass,             // Object class
        sizeof(g_pAcesSamSvr) / sizeof(*g_pAcesSamSvr), 
        g_pAcesSamSvr
    },

    // Grant list contents to Everyone for the System
    // container
    //
    {
        (PWCHAR)pszSystemCN,                // Object
        (PWCHAR)pszSystemClass,             // Object class
        sizeof(g_pAcesSystem) / sizeof(*g_pAcesSystem), 
        g_pAcesSystem
    },

    // Grant generic read to Everyone for the 'RAS and IAS Servers
    // Access Check' container
    //
    {
        (PWCHAR)pszAccessChkCN,             // Object
        (PWCHAR)pszAccessChkClass,          // Object class
        sizeof(g_pAcesAccessCheck) / sizeof(*g_pAcesAccessCheck), 
        g_pAcesAccessCheck
    }
};

DWORD
DsrAccessInfoCleanup(
    IN DSR_DOMAIN_ACCESS_INFO* pSecurityInfo);

DWORD
DsrAceDescClear(
    IN DSR_ACE_DESCRIPTOR* pParams);

HRESULT
DsrAceDescCopy(
    OUT DSR_ACE_DESCRIPTOR* pDst,
    IN  DSR_ACE_DESCRIPTOR* pSrc);
    
VOID
DsrAceDescTrace(
    IN IADs* pIads,
    IN DSR_ACE_DESCRIPTOR* pA);
    
HRESULT
DsrAceAdd(
    IN  PWCHAR pszDC,
    IN  IADs* pIads,
    IN  DSR_ACE_DESCRIPTOR * pAceParams);
    
HRESULT
DsrAceCreate(
    IN  DSR_ACE_DESCRIPTOR * pAceParams,
    OUT IDispatch** ppAce);
    
HRESULT
DsrAceFind(
    IN  PWCHAR pszDC,
    IN  IADs* pObject,
    IN  DSR_ACE_DESCRIPTOR* pAceParams,
    OUT VARIANT* pVarSD,
    OUT IADsSecurityDescriptor** ppSD,
    OUT IADsAccessControlList** ppAcl,
    OUT IDispatch** ppAce);
    
HRESULT
DsrAceFindInAcl(
    IN  PWCHAR pszDC,
    IN  IADsAccessControlList* pAcl,
    IN  DSR_ACE_DESCRIPTOR* pAceDesc, 
    OUT IDispatch** ppAce);
    
HRESULT
DsrAceRemove(
    IN  PWCHAR pszDC,
    IN  IADs* pIads,
    IN  DSR_ACE_DESCRIPTOR * pAceParams);
    
HRESULT
DsrDomainQueryAccessEx(
    IN  PWCHAR pszDomain,
    OUT LPDWORD lpdwAccessFlags,
    OUT DSR_DOMAIN_ACCESS_INFO** ppInfo);
    
//
// Compares to optional strings
//
INT
DsrStrCompare(
    IN BSTR bstrS1,
    IN BSTR bstrS2)
{
    if ((!!bstrS1) != (!!bstrS2))
    {
        return -1;
    }

    if (bstrS1 == NULL)
    {
        return 0;
    }

    return lstrcmpi(bstrS1, bstrS2);
}

//
// Converts a SID into a buffer
//
DWORD
DsrStrFromSID(
    IN  PSID pSid,
    OUT PWCHAR pszString,
    IN  DWORD dwSize)
{
    NTSTATUS nStatus = STATUS_SUCCESS;  
    UNICODE_STRING UnicodeString;

    // Initialize the unicode string
    //
    RtlInitUnicodeString(&UnicodeString, NULL);

    do
    {
        // Convert the string
        //
        nStatus = RtlConvertSidToUnicodeString(
                    &UnicodeString,
                    pSid,
                    TRUE);
        if (! NT_SUCCESS(nStatus))
        {
            break;
        }

        // Validate the result
        //
        if (UnicodeString.Buffer == NULL)
        {
            nStatus = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        if (UnicodeString.Length > dwSize)
        {
            nStatus = STATUS_BUFFER_OVERFLOW;
            break;
        }

        // Copy the result
        //
        wcscpy(pszString, UnicodeString.Buffer);
        nStatus = STATUS_SUCCESS;
        
    } while (FALSE);        

    // Cleanup
    {
        if (UnicodeString.Buffer != NULL)
        {
            RtlFreeUnicodeString(&UnicodeString);
        }            
    }

    return RtlNtStatusToDosError(nStatus);
}


//
// Generates an LDAP path based on a domain and a 
// distinguished name
//
// Form of value returned: LDAP://<domain or dc>/dn
//
HRESULT
DsrDomainGenLdapPath(
    IN  PWCHAR pszDomain, 
    IN  PWCHAR pszDN, 
    OUT PWCHAR* ppszObject)
{    
    DWORD dwSize;

    // Calculate the size needed
    //
    dwSize = (wcslen(pszLdapPrefix) + wcslen(pszDN) + 1) * sizeof(WCHAR);
    if (pszDomain)
    {
        dwSize += (wcslen(pszDomain) + 1) * sizeof(WCHAR); // +1 for '/'
    }

    // Allocate the return value
    //
    *ppszObject = (PWCHAR) DsrAlloc(dwSize, FALSE);
    if (*ppszObject == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Format the return value
    if (pszDomain == NULL)
    {
        wsprintfW(*ppszObject, L"%s%s", pszLdapPrefix, pszDN);
    }
    else
    {
        wsprintfW(*ppszObject, L"%s%s/%s", pszLdapPrefix, pszDomain, pszDN);
    }

    return S_OK;
}        

//
// Returns a reference to rootDse of the given
// domain
//
HRESULT
DsrDomainGetRootDse(
    IN  PWCHAR pszDomain,
    OUT IADs** ppRootDse)
{
    HRESULT hr = S_OK;
    PWCHAR pszPath = NULL;
    DWORD dwSize = 0;

    do
    {
        // Get the object path
        //
        hr = DsrDomainGenLdapPath(pszDomain, (PWCHAR)pszRootDse, &pszPath);
        DSR_BREAK_ON_FAILED_HR(hr);
    
        // Get RootDSE
        //
        hr = ADsGetObject(pszPath, IID_IADs, (VOID**)ppRootDse);
        DSR_BREAK_ON_FAILED_HR( hr );

    } while (FALSE);

    // Cleanup
    {
        DSR_FREE(pszPath);

        if (FAILED (hr))
        {
            DSR_RELEASE(*ppRootDse);
        }
    }

    return hr;
}

//
// Returns a reference to the root domain object
//
HRESULT
DsrDomainGetBaseObjects(
    IN  PWCHAR pszDomain,
    OUT IADs** ppRootDse,
    OUT IADsContainer** ppDomain)
{
    PWCHAR pszDomainObj = NULL;
    HRESULT hr = S_OK;
    DWORD dwSize = 0;
    VARIANT var;

    // Iniatialize
    //
    {
        *ppRootDse = NULL;
        *ppDomain = NULL;
        VariantInit(&var);
    }

    do
    {
        // Get RootDSE
        //
        hr = DsrDomainGetRootDse(pszDomain, ppRootDse);
        DSR_BREAK_ON_FAILED_HR(hr);

        // Use RootDSE to figure out the name of the domain object
        // to query
        hr = (*ppRootDse)->Get((PWCHAR)pszDefaultNamingContext, &var);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Compute the distinguished name of the root domain object
        //
        hr = DsrDomainGenLdapPath(pszDomain, V_BSTR(&var), &pszDomainObj);
        DSR_BREAK_ON_FAILED_HR(hr);
        
        // Get the objects
        //
        hr = ADsGetObject(pszDomainObj, IID_IADsContainer, (VOID**)ppDomain);
        DSR_BREAK_ON_FAILED_HR( hr );

    } while (FALSE);

    // Cleanup
    //
    {
        if (FAILED( hr ))
        {
            DSR_RELEASE(*ppRootDse);
            DSR_RELEASE(*ppDomain);
            *ppRootDse = NULL;
            *ppDomain = NULL;
        }

        DSR_FREE(pszDomainObj);
        VariantClear(&var);
    }

    return hr;
}

//
// Initializes COM
//
HRESULT
DsrComIntialize()
{
    HRESULT hr;

    hr = CoInitializeEx (NULL, COINIT_APARTMENTTHREADED);
    if (hr == RPC_E_CHANGED_MODE)
    {
        hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);
    }

    if ((hr != S_FALSE) && (FAILED(hr)))
    {
        return hr;
    }

    return NO_ERROR;
}

//
// Unitializes COM
//
VOID
DsrComUninitialize()
{
    CoUninitialize();
}

//
// Creates a SID based on the array of bytes
// stored in a variant.
//
DWORD
DsrSidInit (
    IN  VARIANT * pVar,
    OUT PBYTE* ppbSid)
{
    SAFEARRAY * pArray = V_ARRAY(pVar);
    DWORD dwSize, dwLow, dwHigh, i;
    HRESULT hr;
    BYTE* pbRet = NULL;
    VARIANT var;

    DsrTraceEx (0, "DsrSidInit: entered.");

    // Get the array of bytes
    i = 0;
    hr = SafeArrayGetElement(pArray, (LONG*)&i, (VOID*)&var);
    if (FAILED (hr))
        return hr;

    // Initialize the return buffer accordingly
    pArray = V_ARRAY(&var);
    dwSize = SafeArrayGetDim(pArray);
    hr = SafeArrayGetLBound(pArray, 1, (LONG*)&dwLow);
    if (FAILED (hr))
        return DsrTraceEx(hr, "DsrSidInit: %x unable to get lbound", hr);

    hr = SafeArrayGetUBound(pArray, 1, (LONG*)&dwHigh);
    if (FAILED (hr))
        return DsrTraceEx(hr, "DsrSidInit: %x unable to get ubound", hr);

    DsrTraceEx (
            0,
            "DsrSidInit: Dim=%d, Low=%d, High=%d",
            dwSize,
            dwLow,
            dwHigh);

    // Allocate the sid
    if ((pbRet = (BYTE*)DsrAlloc((dwHigh - dwLow) + 2, TRUE)) == NULL) {
        return DsrTraceEx (
                    ERROR_NOT_ENOUGH_MEMORY,
                    "DsrSidInit: Unable to alloc");
    }

    // Copy in the bytes of the SID
    i = dwLow;
    while (TRUE) {
        hr = SafeArrayGetElement(pArray, (LONG*)&i, (VOID*)(&(pbRet[i])));
        if (FAILED (hr))
            break;
        i++;
    }

    DsrTraceEx(0, "DsrSidInit: copied %d bytes", i);

    *ppbSid = pbRet;

    {
        PUCHAR puSA;

        DsrTraceEx (0, "DsrSidInit: Sid Length: %d", GetLengthSid(pbRet));

        puSA = GetSidSubAuthorityCount(pbRet);
        if (puSA)
            DsrTraceEx (0, "DsrSidInit: Sid SA Count: %d", *puSA);
    }

    return NO_ERROR;
}

//
// Generates the ascii equivalent (suitable for submission as part of
// a query against the DS) of a SID based on a base SID and a sub authority
// to be appeneded.
//
HRESULT
DsrSidInitAscii(
    IN  LPBYTE pBaseSid,
    IN  DWORD dwSubAuthority,
    OUT PWCHAR* ppszSid)
{
    DWORD dwLen, dwSidLen, i;
    WCHAR* pszRet = NULL;
    PUCHAR puCount;
    LPBYTE pByte;

    // Calculate the length of the returned buffer
    dwSidLen = GetLengthSid(pBaseSid);
    dwLen = (dwSidLen * 2) + sizeof(DWORD) + 1;
    dwLen *= sizeof (WCHAR);

    // we put '\' before each byte, so double the size
    dwLen *= 2;

    // Allocate the return buffer
    pszRet = (PWCHAR) DsrAlloc(dwLen, TRUE);
    if (pszRet == NULL)
        return E_OUTOFMEMORY;

    // Increment the sub authority count
    puCount = GetSidSubAuthorityCount(pBaseSid);
    *puCount = *puCount + 1;

    // Copy the bytes
    for (i = 0; i < dwSidLen; i++) {
        pszRet[i*3] = L'\\';
        wsprintfW(&(pszRet[i*3+1]), L"%02x", (DWORD)pBaseSid[i]);
    }

    // Append the bytes for the new sub authority
    pByte = (LPBYTE)&(dwSubAuthority);
    for (; i < dwSidLen + sizeof(DWORD); i++) {
        pszRet[i*3] = L'\\';
        wsprintfW(&(pszRet[i*3+1]), L"%02x", (DWORD)pByte[i-dwSidLen]);
    }

    // Decrement the sub authority count -- restoring the
    // base sid.
    *puCount = *puCount - 1;

    *ppszSid = pszRet;

    return NO_ERROR;
}

//
// Searches given domain for a computer account
// with the given name and returns its ADsPath
// if found.
//
DWORD
DsrFindDomainComputer (
        IN  PWCHAR  pszDomain,
        IN  PWCHAR  pszComputer,
        OUT PWCHAR* ppszADsPath)
{
    HRESULT hr = S_OK;
    DWORD dwLen, dwSrchAttribCount;
    IDirectorySearch * pSearch = NULL;
    PWCHAR pszDomainPath = NULL, pszFilter = NULL;
    PWCHAR pszBase, pszPrefix;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCH_COLUMN adsColumn;
    PWCHAR ppszSrchAttribs[] =
    {
        (PWCHAR)pszDn,
        NULL
    };
    BOOL bSearchGC = FALSE;

    do {
        // Validate parameters
        if (!pszDomain || !pszComputer || !ppszADsPath) {
            hr = ERROR_INVALID_PARAMETER;
            break;
        }

        // Decide whether to search the GC or the domain
        // object
        if (bSearchGC) {
            pszBase = (PWCHAR)pszGC;
            pszPrefix = (PWCHAR)pszGCPrefix;
        }
        else {
            pszBase = (PWCHAR)pszLdap;
            pszPrefix = (PWCHAR)pszLdapPrefix;
        }

        // Allocate the domain path
        dwLen = (pszDomain) ? wcslen(pszDomain) : 0;
        dwLen += wcslen(pszPrefix) + 1;
        dwLen *= sizeof(WCHAR);
        pszDomainPath = (PWCHAR) DsrAlloc(dwLen, FALSE);
        if (pszDomainPath == NULL) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Format the domain path
        if (pszDomain) {
            wcscpy(pszDomainPath, pszPrefix);
            wcscat(pszDomainPath, pszDomain);
        }
        else
            wcscpy(pszDomainPath, pszBase);

        // Get a reference to the object to search
        // (either domain object or GC)
    	hr = ADsGetObject (
    	        pszDomainPath,
    	        IID_IDirectorySearch,
    	        (VOID**)&pSearch);
        if (FAILED (hr))
            break;

        // Prepare the search filter
        //
        dwLen = wcslen(pszCompFilterFmt) + wcslen(pszComputer) + 1;
        dwLen *= sizeof(WCHAR);
        pszFilter = (PWCHAR) DsrAlloc(dwLen, FALSE);
        if (pszFilter == NULL) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        wsprintfW(pszFilter, pszCompFilterFmt, pszComputer);

        // Count the number of attributes we're searching
        // for
        if (ppszSrchAttribs == NULL)
            dwSrchAttribCount = (DWORD)-1;
        else {
            for (dwSrchAttribCount = 0;
                 ppszSrchAttribs[dwSrchAttribCount];
                 dwSrchAttribCount++);
        }

        // Search the DS
        hr = pSearch->ExecuteSearch(
                pszFilter,
                ppszSrchAttribs,
                dwSrchAttribCount,
                &hSearch);
        if (FAILED (hr))
            break;

        // Get the first result
        hr = pSearch->GetNextRow(hSearch);
        if (hr == S_ADS_NOMORE_ROWS) {
            hr = ERROR_NOT_FOUND;
            break;
        }

        // Get the attribute we're interested in
        hr = pSearch->GetColumn(hSearch, (PWCHAR)pszDn, &adsColumn);
        if (SUCCEEDED (hr)) {
            dwLen = wcslen(adsColumn.pADsValues[0].PrintableString) +
                    wcslen(pszLdapPrefix)                           +
                    1;
            dwLen *= 2;
            *ppszADsPath = (PWCHAR) DsrAlloc(dwLen, FALSE);
            if (*ppszADsPath == NULL)
            {
                pSearch->FreeColumn(&adsColumn);
                hr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            wcscpy(*ppszADsPath, pszLdapPrefix);
            wcscat(*ppszADsPath, adsColumn.pADsValues[0].PrintableString);
            pSearch->FreeColumn (&adsColumn);
            hr = NO_ERROR;
        }

    } while (FALSE);

    // Cleanup
    {
        if (hSearch)
            pSearch->CloseSearchHandle(hSearch);
        DSR_FREE (pszDomainPath);
        DSR_FREE (pszFilter);
        DSR_RELEASE (pSearch);
    }

    return DSR_ERROR(hr);
}

//
// Searches given domain for the well known
// "RAS and IAS Servers" group and returns
// its ADsPath if found.
//
DWORD
DsrFindRasServersGroup (
        IN  PWCHAR  pszDomain,
        OUT PWCHAR* ppszADsPath)
{
    HRESULT hr = S_OK;
    DWORD dwLen, dwSrchAttribCount, dwErr;
    IDirectorySearch * pSearch = NULL;
    IADs * pIads = NULL;
    PWCHAR pszDomainPath = NULL, pszFilter = NULL;
    PWCHAR pszBase, pszPrefix, pszGroupSid = NULL;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCH_COLUMN adsColumn;
    PWCHAR ppszSrchAttribs[] =
    {
        (PWCHAR)pszDn,
        NULL
    };
    BOOL bSearchGC = FALSE;
    VARIANT var;
    LPBYTE pDomainSid = NULL;
    BSTR bstrSid = NULL;

    do {
        // Validate parameters
        if (!pszDomain || !ppszADsPath) {
            hr = ERROR_INVALID_PARAMETER;
            break;
        }

        // Decide whether to search the GC or the domain
        // object
        if (bSearchGC) {
            pszBase = (PWCHAR)pszGC;
            pszPrefix = (PWCHAR)pszGCPrefix;
        }
        else {
            pszBase = (PWCHAR)pszLdap;
            pszPrefix = (PWCHAR)pszLdapPrefix;
        }

        // Allocate the domain path
        dwLen = wcslen(pszDomain) + wcslen(pszPrefix) + 1;
        dwLen *= sizeof(WCHAR);
        pszDomainPath = (PWCHAR) DsrAlloc(dwLen, FALSE);
        if (pszDomainPath == NULL) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Format the domain path
        wcscpy(pszDomainPath, pszPrefix);
        wcscat(pszDomainPath, pszDomain);

        // Get a reference to the object to search
        // (either domain object or GC)
    	hr = ADsGetObject (
    	        pszDomainPath,
    	        IID_IDirectorySearch,
    	        (VOID**)&pSearch);
        if (FAILED (hr))
            break;

        // Get IADs reference to domain object
        hr = pSearch->QueryInterface(IID_IADs, (VOID**)&pIads);
        if (FAILED (hr))
            break;

        // Get the SID of the domain object
        VariantInit(&var);
        bstrSid = SysAllocString(pszSid);
        if (bstrSid == NULL)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }            
        hr = pIads->GetEx(bstrSid, &var);
        if (FAILED (hr))
        {
            break;
        }
        dwErr = DsrSidInit(&var, &pDomainSid);
        if (dwErr != NO_ERROR) {
            hr = dwErr;
            break;
        }
        VariantClear(&var);

        // Prepare the ascii version of the "RAS and IAS Servers" SID
        // for use in querying the DC
        hr = DsrSidInitAscii(
                pDomainSid,
                DOMAIN_ALIAS_RID_RAS_SERVERS,
                &pszGroupSid);
        if (FAILED (hr))
            break;
        DsrTraceEx(0, "GroupSid = %ls", pszGroupSid);

        // Prepare the search filter
        //
        dwLen = (wcslen(pszGroupFilterFmt) + wcslen(pszGroupSid) + 1);
        dwLen *= sizeof(WCHAR);
        pszFilter = (PWCHAR) DsrAlloc(dwLen, FALSE);
        if (pszFilter == NULL) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        wsprintfW(pszFilter, pszGroupFilterFmt, pszGroupSid);

        // Count the number of attributes we're searching
        // for
        if (ppszSrchAttribs == NULL)
            dwSrchAttribCount = (DWORD)-1;
        else 
        {
            for (dwSrchAttribCount = 0;
                 ppszSrchAttribs[dwSrchAttribCount];
                 dwSrchAttribCount++);
        }

        // Search the DS
        hr = pSearch->ExecuteSearch(
                pszFilter,
                ppszSrchAttribs,
                dwSrchAttribCount,
                &hSearch);
        if (FAILED (hr))
            break;

        // Get the first result
        hr = pSearch->GetNextRow(hSearch);
        if (hr == S_ADS_NOMORE_ROWS) {
            hr = ERROR_NOT_FOUND;
            break;
        }

        // Get the attribute we're interested in
        hr = pSearch->GetColumn(hSearch, (PWCHAR)pszDn, &adsColumn);
        if (SUCCEEDED (hr)) 
        {
            dwLen = wcslen(adsColumn.pADsValues[0].PrintableString) +
                    wcslen(pszLdapPrefix)                           +
                    1;
            dwLen *= sizeof(WCHAR);
            *ppszADsPath = (PWCHAR) DsrAlloc(dwLen, FALSE);
            if (*ppszADsPath == NULL)
            {
                pSearch->FreeColumn(&adsColumn);
                hr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            wsprintfW(
                *ppszADsPath,
                L"%s%s",
                pszLdapPrefix,
                adsColumn.pADsValues[0].PrintableString);
            pSearch->FreeColumn(&adsColumn);
            hr = NO_ERROR;
        }

    } while (FALSE);

    // Cleanup
    {
        if (hSearch)
            pSearch->CloseSearchHandle(hSearch);
        DSR_FREE (pszDomainPath);
        DSR_FREE (pszFilter);
        DSR_FREE (pDomainSid);
        DSR_FREE (pszGroupSid);
        DSR_RELEASE (pSearch);
        DSR_RELEASE (pIads);
        if (bstrSid)
            SysFreeString(bstrSid);
    }

    return DSR_ERROR(hr);
}

//
// Adds or removes a given object from a given group.
//
DWORD 
DsrGroupAddRemoveMember(
    IN PWCHAR pszGroupDN,
    IN PWCHAR pszNewMemberDN,
    IN BOOL bAdd)
{
    VARIANT_BOOL vbIsMember = VARIANT_FALSE;
    IADsGroup* pGroup = NULL;
    HRESULT hr = S_OK;

    DsrTraceEx (
        0,
        "DsrGroupAddRemoveMember entered for [%S] [%S]",
        pszGroupDN,
        pszNewMemberDN);

    do
    {
        // Get a reference to the group
        hr = ADsGetObject (pszGroupDN, IID_IADsGroup, (VOID**)&pGroup);
        if (FAILED (hr)) 
        {
         	DsrTraceEx(
     	        hr,
     	        "DsrGroupAddRemoveMember: %x from ADsGetObject(%S)",
     	        hr,
     	        pszGroupDN);
     	    break;
        }         	
         	
        // Find out if the given new member is in the group
        hr = pGroup->IsMember (pszNewMemberDN, &vbIsMember);
        if (FAILED (hr)) 
        {
            DsrTraceEx (
                hr,
                "DsrGroupAddRemoveMember: %x from IsMember\n",
                hr);
            break;
        }

        // Add the object to the group and flush the cache
        if (bAdd) 
        {
            if (vbIsMember == VARIANT_FALSE)
            {
                hr = pGroup->Add (pszNewMemberDN);
            }
        }
        else 
        {
            if (vbIsMember == VARIANT_TRUE)
            {
                hr = pGroup->Remove (pszNewMemberDN);
            }
        }

        // If the new member is already in the group, the error code
        // is ERROR_DS_CONSTRAINT_VIOLATION.  I suspect this may change.
        //
        if (hr == ERROR_DS_CONSTRAINT_VIOLATION)
        {
            hr = ERROR_ALREADY_EXISTS;
            break;
        }

        if (FAILED (hr)) 
        {
         	DsrTraceEx(
 	            hr,
 	            "DsrGroupAddRemoveMember: %x from Add/Remove",
 	            hr);
            break; 	            
        }         	
        
    } while (FALSE);

    // Cleanup
    {
        DSR_RELEASE(pGroup);
    }

    return DSR_ERROR(hr);
}

//
// Returns whether the given object is a member of
// the given group.
//
DWORD 
DsrGroupIsMember(
    IN  PWCHAR pszGroupDN,
    IN  PWCHAR pszObjectDN,
    OUT PBOOL  pbIsMember)
{
    IADsGroup * pGroup = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL vbIsMember = VARIANT_FALSE;

    DsrTraceEx (
        0,
        "DsrGroupIsMember: entered [%S] [%S].",
        pszGroupDN,
        pszObjectDN);

    do
    {
        // Get a reference to the group
        hr = ADsGetObject (pszGroupDN, IID_IADsGroup, (VOID**)&pGroup);
        if (FAILED (hr)) 
        {
            DsrTraceEx (
                hr,
                "DsrGroupIsMember: %x returned when opening %S", 
                hr, 
                pszGroupDN);
            *pbIsMember = FALSE;
            hr = NO_ERROR;
            break;
        }

        // Find out if the object is a member
        hr = pGroup->IsMember (pszObjectDN, &vbIsMember);
        if (FAILED (hr)) 
        {
            DsrTraceEx (hr, "DsrGroupIsMember: %x from IsMember\n", hr);
            break;
         }

        *pbIsMember = (vbIsMember == VARIANT_TRUE) ? TRUE : FALSE;
        
    } while (FALSE);

    // Cleanup
    {
        DSR_RELEASE(pGroup);
    }

    return DSR_ERROR(hr);
}

//
// Applies the aces in the given access settings to the 
// appropriate domain.
//
HRESULT
DsrAceAppAdd(
    IN  DWORD dwMode,
    IN  PWCHAR pszDC,
    IN  DSR_ACE_APPLICATION* pAces,
    IN  DWORD dwCount)
{    
    HRESULT hr = S_OK;
    DSR_ACE_APPLICATION* pAceApp = NULL;
    DWORD i, j;
    
    do
    {
        // Add the ACES to the domain objects
        //
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            for (j = 0; j < pAceApp->dwCount; j++)
            {
                if (pAceApp->pAces[j].dwMode != dwMode)
                {
                    continue;
                }
                hr = DsrAceAdd(
                        pszDC,
                        pAceApp->pObject,
                        &(pAceApp->pAces[j]));
                DSR_BREAK_ON_FAILED_HR( hr );
            }                
        }
        DSR_BREAK_ON_FAILED_HR( hr );

        // Commit the ACE's to the domain objects.
        //
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            hr = pAceApp->pObject->SetInfo();
            DSR_BREAK_ON_FAILED_HR( hr );
        }
        DSR_BREAK_ON_FAILED_HR( hr );
        
    } while (FALSE);

    // Cleanup
    {
    }

    return hr;
}

// 
// Releases the resources held by an ace application
//
HRESULT
DsrAceAppCleanup(
    IN DSR_ACE_APPLICATION* pAces,
    IN DWORD dwCount)
{
    DSR_ACE_APPLICATION* pAceApp = NULL;
    DWORD i, j;

    if (pAces)
    {
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            DSR_RELEASE(pAceApp->pObject);
            for (j = 0; j < pAceApp->dwCount; j++)
            {
                DsrAceDescClear(&(pAceApp->pAces[j]));
            }
        }

        DSR_FREE(pAces);
    }        

    return NO_ERROR;
}

// 
// Generates a list of ace applications based on a list
// of ace application descriptions
//
HRESULT
DsrAceAppFromAppDesc(
    IN  DSR_ACE_APPLICATION_DESC* pDesc,
    IN  DWORD dwCount,
    IN  IADsContainer* pContainer,
    IN  IADs* pDefault,
    OUT DSR_ACE_APPLICATION** ppAceApp,
    OUT LPDWORD lpdwCount)
{
    DSR_ACE_APPLICATION* pAceApp = NULL, *pCurApp = NULL;
    DSR_ACE_APPLICATION_DESC* pAceAppDesc = NULL;
    IDispatch* pDispatch = NULL;
    HRESULT hr = S_OK;                
    DWORD i, j;

    do
    {
        // Allocate and zero the ACE list
        //
        pAceApp = (DSR_ACE_APPLICATION*) 
            DsrAlloc(sizeof(DSR_ACE_APPLICATION) * dwCount, TRUE);
        if (pAceApp == NULL)
        {
           DSR_BREAK_ON_FAILED_HR(hr = E_OUTOFMEMORY);
        }

        // Set up the ACE applications
        //
        for (i = 0, pAceAppDesc = pDesc, pCurApp = pAceApp;
             i < dwCount;
             i++, pAceAppDesc++, pCurApp++)
        {
            // Allocate the appropriate number of ace
            // descriptors
            //
            pCurApp->pAces = (DSR_ACE_DESCRIPTOR*)
                DsrAlloc(
                    sizeof(DSR_ACE_DESCRIPTOR) * pAceAppDesc->dwCount, 
                    TRUE);
            if (pCurApp->pAces == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            pCurApp->dwCount = pAceAppDesc->dwCount;
            
            // Get the desired object in the DS
            //
            if (pAceAppDesc->pszObjectCN)
            {
                hr = pContainer->GetObject(
                        pAceAppDesc->pszObjectClass,
                        pAceAppDesc->pszObjectCN,
                        &pDispatch);
                DSR_BREAK_ON_FAILED_HR( hr );

                hr = pDispatch->QueryInterface(
                        IID_IADs,
                        (VOID**)&(pCurApp->pObject));
                DSR_BREAK_ON_FAILED_HR( hr );

                pDispatch->Release();
                pDispatch = NULL;
            }
            else
            {
                pCurApp->pObject = pDefault;
                pCurApp->pObject->AddRef();
            }

            // Copy over the ACE information
            //
            for (j = 0; j < pCurApp->dwCount; j++)
            {
                hr = DsrAceDescCopy(
                        &(pCurApp->pAces[j]),
                        &(pAceAppDesc->pAces[j]));
                DSR_BREAK_ON_FAILED_HR( hr );
            }                
            DSR_BREAK_ON_FAILED_HR( hr );
            
        }
        DSR_BREAK_ON_FAILED_HR( hr );

        // Assign the return values
        *ppAceApp = pAceApp;
        *lpdwCount = dwCount;
        
    } while (FALSE);        

    // Cleanup
    {
        if (FAILED(hr))
        {
            DsrAceAppCleanup(pAceApp, i);
        }
    }

    return hr;
}

// 
// Discovers whether a set of aces is present in the given 
// domain.
//
HRESULT
DsrAceAppQueryPresence(
    IN  PWCHAR pszDC,
    IN  DSR_ACE_APPLICATION* pAces,
    IN  DWORD dwCount,
    IN  DWORD dwMode,
    OUT PBOOL pbPresent)
{
    DSR_ACE_APPLICATION* pAceApp = NULL;
    IADsSecurityDescriptor* pSD = NULL;
    IADsAccessControlList* pAcl = NULL;
    IDispatch* pAce = NULL;
    VARIANT varSD;
    HRESULT hr = S_OK;
    BOOL bEnabled = FALSE, bOk = TRUE;
    DWORD i, j;

    do
    {
        // Initialize
        *pbPresent = FALSE;
        VariantInit(&varSD);

        // Find out if the ACES are set
        //
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            for (j = 0; j < pAceApp->dwCount; j++)
            {
                // Only validate aces that pertain to the 
                // given mode
                //
                if (pAceApp->pAces[j].dwMode != dwMode)
                {
                    continue;
                }
                
                hr = DsrAceFind(
                        pszDC,
                        pAceApp->pObject,
                        &(pAceApp->pAces[j]),
                        &varSD,
                        &pSD,
                        &pAcl,
                        &pAce);
                DSR_BREAK_ON_FAILED_HR( hr );

                // We're enabled so long as we don't find
                // a missing ACE
                //
                bOk = (pAce != NULL);

                // Cleanup
                //
                DSR_RELEASE( pAce );
                DSR_RELEASE( pAcl );
                DSR_RELEASE( pSD );
                VariantClear(&varSD);
                pAce = NULL;
                pAcl = NULL;
                pSD  = NULL;

                // Break if we find out we're not enabled
                //
                if (bOk == FALSE)
                {
                    break;
                }
            }                
            
            // Break if we find out we're not enabled
            //
            if (bOk == FALSE)
            {
                break;
            }
        }
        DSR_BREAK_ON_FAILED_HR( hr );

        *pbPresent = bOk;
        
    } while (FALSE);

    // Cleanup
    {
    }

    return hr;
}

//
// Applies the aces in the given access settings to the 
// appropriate domain.
//
HRESULT
DsrAceAppRemove(
    IN  DWORD dwMode,
    IN  PWCHAR pszDC,
    IN  DSR_ACE_APPLICATION* pAces,
    IN  DWORD dwCount)
{    
    HRESULT hr = S_OK;
    DSR_ACE_APPLICATION* pAceApp = NULL;
    DWORD i, j;
    
    do
    {
        // Add/Del the ACES to the domain objects
        //
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            for (j = 0; j < pAceApp->dwCount; j++)
            {
                if (pAceApp->pAces[j].dwMode != dwMode)
                {
                    continue;
                }
                hr = DsrAceRemove(
                        pszDC,
                        pAceApp->pObject,
                        &(pAceApp->pAces[j]));
                DSR_BREAK_ON_FAILED_HR( hr );
            }                
        }
        DSR_BREAK_ON_FAILED_HR( hr );

        // Commit the ACE's to the domain objects.
        //
        for (i = 0, pAceApp = pAces; i < dwCount; i++, pAceApp++)
        {
            hr = pAceApp->pObject->SetInfo();
            DSR_BREAK_ON_FAILED_HR( hr );
        }
        DSR_BREAK_ON_FAILED_HR( hr );
        
    } while (FALSE);

    // Cleanup
    {
    }

    return hr;
}

//
// Clear the dsr ace parameters
//
DWORD
DsrAceDescClear(
    IN DSR_ACE_DESCRIPTOR* pParams)
{
    if (pParams)
    {
        if (pParams->bstrTrustee)
        {
            SysFreeString(pParams->bstrTrustee);
        }
        if (pParams->bstrObjectType)
        {
            SysFreeString(pParams->bstrObjectType);
        }
        if (pParams->bstrInheritedObjectType)
        {
            SysFreeString(pParams->bstrInheritedObjectType);
        }

        ZeroMemory(pParams, sizeof(DSR_ACE_DESCRIPTOR));
    }

    return NO_ERROR;
}

//
// Returns 0 if ACE descriptors are describing the same ACE.
// FALSE, otherwise.
//
HRESULT
DsrAceDescCompare(
    IN DSR_ACE_DESCRIPTOR* pAce1,
    IN DSR_ACE_DESCRIPTOR* pAce2)
{
    DWORD dw1, dw2;
    
    // Compare the non-string fields so that we can rule things
    // out w/o string compares if possible
    //
    if (
        (pAce1->dwAccessMask != pAce2->dwAccessMask) ||
        (pAce1->dwAceFlags   != pAce2->dwAceFlags)   ||
        (pAce1->dwAceType    != pAce2->dwAceType)    ||
        (pAce1->dwFlags      != pAce2->dwFlags)
       )
    {
        return 1;
    }

    // Compare the strings
    //
    if ((DsrStrCompare(pAce1->bstrTrustee, pAce2->bstrTrustee))       ||
        (DsrStrCompare(pAce1->bstrObjectType, pAce2->bstrObjectType)) ||
        (DsrStrCompare(pAce1->bstrInheritedObjectType,
                       pAce2->bstrInheritedObjectType))
       )
    {
        return 1;
    }

    // Return success
    //
    return 0;
}

//
// Copy over the ACE information
//
HRESULT
DsrAceDescCopy(
    OUT DSR_ACE_DESCRIPTOR* pDst,
    IN  DSR_ACE_DESCRIPTOR* pSrc)
{
    HRESULT hr = S_OK;

    do
    {
        // Initialize the ACE parameters
        *pDst = *pSrc;

        if (pSrc->bstrTrustee)
        {
            pDst->bstrTrustee =
                SysAllocString(pSrc->bstrTrustee);

            if (pDst->bstrTrustee == NULL)
            {
               DSR_BREAK_ON_FAILED_HR(hr = E_OUTOFMEMORY);
            }
        }

        if (pSrc->bstrObjectType)
        {
            pDst->bstrObjectType =
                SysAllocString(pSrc->bstrObjectType);

            if (pDst->bstrObjectType == NULL)
            {
               DSR_BREAK_ON_FAILED_HR(hr = E_OUTOFMEMORY);
            }
        }

        if (pSrc->bstrInheritedObjectType)
        {
            pDst->bstrInheritedObjectType =
                SysAllocString(pSrc->bstrInheritedObjectType);

            if (pDst->bstrInheritedObjectType == NULL)
            {
               DSR_BREAK_ON_FAILED_HR(hr = E_OUTOFMEMORY);
            }
        }

    } while (FALSE);

    // Cleanup
    {
        if (FAILED( hr ))
        {
            if (pDst->bstrTrustee)
            {
               SysFreeString(pDst->bstrTrustee);
            }
            if (pDst->bstrObjectType)
            {
               SysFreeString(pDst->bstrObjectType);
            }
            if (pDst->bstrInheritedObjectType)
            {
               SysFreeString(pDst->bstrInheritedObjectType);
            }
        }
    }

    return hr;
}

//
// Populates the given ACE descriptor with the values from
// the given ACE.
//
HRESULT
DsrAceDescFromIadsAce(
    IN PWCHAR pszDC,
    IN IADsAccessControlEntry* pAce,
    IN DSR_ACE_DESCRIPTOR* pAceParams)
{
    HRESULT hr = S_OK;
    BSTR bstrTrustee = NULL;
    PWCHAR pszSid, pszDomain;
    PBYTE pbSid;
    DWORD dwSidSize, dwDomainSize;
    BOOL bOk;
    SID_NAME_USE SidNameUse;
    
    pszSid = (PWCHAR) DsrAlloc(sizeof(WCHAR)*1024, FALSE);
	pszDomain = (PWCHAR) DsrAlloc(sizeof(WCHAR)*1024, FALSE);
	pbSid = (PBYTE) DsrAlloc(sizeof(BYTE)*1024, FALSE);

	if (!pszSid || !pszDomain || !pbSid) {
	    if (pszSid)
	    	DsrFree(pszSid);
	    if (pszDomain)
			DsrFree(pszDomain);
	    if (pbSid)
			DsrFree(pbSid);

		return E_OUTOFMEMORY;
	}
	
    do
    {
        hr = pAce->get_AccessMask(&(pAceParams->dwAccessMask));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_AceType(&(pAceParams->dwAceType));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_AceFlags(&(pAceParams->dwAceFlags));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_Flags(&(pAceParams->dwFlags));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_ObjectType(&(pAceParams->bstrObjectType));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_InheritedObjectType(
                &(pAceParams->bstrInheritedObjectType));
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->get_Trustee(&bstrTrustee);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get the SID of the trustee
        //
        dwSidSize = sizeof(pbSid);
        dwDomainSize = sizeof(pszDomain) / sizeof(WCHAR);
        bOk = LookupAccountName(
                    pszDC,
                    bstrTrustee,
                    (PSID)pbSid,
                    &dwSidSize,
                    pszDomain,
                    &dwDomainSize,
                    &SidNameUse);
        if (bOk == FALSE)
        {
            hr = GetLastError();
            break;
        }

        // Convert the sid to a string
        //
        hr = DsrStrFromSID((PSID)pbSid, pszSid, sizeof(pszSid));
        if (hr != NO_ERROR)
        {
            break;
        }

        // Create the trustee accordingly
        //
        pAceParams->bstrTrustee = SysAllocString(pszSid);
        if (pAceParams->bstrTrustee == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

    } while (FALSE);

    // Cleanup
    {
        if (bstrTrustee)
        {
            SysFreeString(bstrTrustee);
        }

        if (FAILED(hr))
        {
            DsrAceDescClear(pAceParams);
        }
    }

	DsrFree(pszSid);
	DsrFree(pszDomain);
	DsrFree(pbSid);

    return hr;
}

PWCHAR 
DsrAceAttrToString(
    IN PWCHAR pszObjectType)
{
    if (pszObjectType == NULL)
    {
        return L"All";
    }
    else if (lstrcmpi(pszObjectType, pszGuidUserParms) == 0)
    {
        return L"UserParms (BF967A6D-0DE6-11D0-A285-00AA003049E2)";
    }
    else if (lstrcmpi(pszObjectType, pszGuidRasPropSet1) == 0)
    {
        return L"Ras user properties (037088F8-0AE1-11D2-B422-00A0C968F939)";
    }
    else if (lstrcmpi(pszObjectType, pszGuidRasPropSet2) == 0)
    {
        return L"Misc user properties (4C164200-20C0-11D0-A768-00AA006E0529)";
    }
    else if (lstrcmpi(pszObjectType, pszGuidLogonHours) == 0)
    {
        return L"Logon-Hours (BF9679AB-0DE6-11D0-A285-00AA003049E2)";
    }
    else if (lstrcmpi(pszObjectType, pszGuidSamAccountName) == 0)
    {
        return L"Sam account name (3E0ABFD0-126A-11D0-A060-00AA006C33ED)";
    }

    return pszObjectType;
}

PWCHAR 
DsrAceApplyToString(
    IN PWCHAR pszApply)
{
    if (pszApply == NULL)
    {
        return L"This object";
    }
    else if (lstrcmpi(pszApply, pszGuidUserClass) == 0)
    {
        return L"User objects (BF967ABA-0DE6-11D0-A285-00aa003049E2)";
    }

    return pszApply;
} 

PWCHAR
DsrAceMaskToString(
    IN DWORD dwType,
    IN DWORD dwMask,
    IN PWCHAR pszBuf)
{
    WCHAR pszTemp[64];
    *pszBuf = L'\0';

    switch (dwType)
    {
        case ADS_ACETYPE_ACCESS_ALLOWED:
            wcscpy(pszBuf, L"Allow:       ");
            break;
            
    	case ADS_ACETYPE_ACCESS_DENIED:
            wcscpy(pszBuf, L"Deny:        ");
            break;
            
    	case ADS_ACETYPE_SYSTEM_AUDIT:
            wcscpy(pszBuf, L"Audit:       ");
            break;
            
    	case ADS_ACETYPE_ACCESS_ALLOWED_OBJECT:
            wcscpy(pszBuf, L"Allow obj:   ");
            break;
            
    	case ADS_ACETYPE_ACCESS_DENIED_OBJECT:
            wcscpy(pszBuf, L"Deny obj:    ");
            break;
            
    	case ADS_ACETYPE_SYSTEM_AUDIT_OBJECT:
            wcscpy(pszBuf, L"Audit obj:   ");
            break;
    }    	

    wsprintfW(pszTemp, L"(%x): ", dwMask);
    wcscat(pszBuf, pszTemp);

    if (dwMask == DSR_ADS_RIGHT_GENERIC_READ)
    {
        wcscat(pszBuf, L"Generic read");
    }
    else if (dwMask == 0xffffffff)
    {
        wcscat(pszBuf, L"Full control");
    }
    else
    {
    	if (dwMask & ADS_RIGHT_READ_CONTROL)
    	    wcscat(pszBuf, L"R ctrl, ");
    	if (dwMask & ADS_RIGHT_WRITE_DAC)
    	    wcscat(pszBuf, L"R/W dac, ");
    	if (dwMask & ADS_RIGHT_WRITE_OWNER)
    	    wcscat(pszBuf, L"W own, ");
    	if (dwMask & ADS_RIGHT_SYNCHRONIZE)
    	    wcscat(pszBuf, L"Sync, ");
    	if (dwMask & ADS_RIGHT_ACCESS_SYSTEM_SECURITY)
    	    wcscat(pszBuf, L"Sys, ");
    	if (dwMask & ADS_RIGHT_GENERIC_READ)
    	    wcscat(pszBuf, L"R (gen), ");
    	if (dwMask & ADS_RIGHT_GENERIC_WRITE)
    	    wcscat(pszBuf, L"W (gen), ");
    	if (dwMask & ADS_RIGHT_GENERIC_EXECUTE)
    	    wcscat(pszBuf, L"Ex, ");
    	if (dwMask & ADS_RIGHT_GENERIC_ALL)
    	    wcscat(pszBuf, L"All, ");
    	if (dwMask & ADS_RIGHT_DS_CREATE_CHILD)
    	    wcscat(pszBuf, L"Cr cld, ");
    	if (dwMask & ADS_RIGHT_DS_DELETE_CHILD)
    	    wcscat(pszBuf, L"Del cld, ");
    	if (dwMask & ADS_RIGHT_ACTRL_DS_LIST)
    	    wcscat(pszBuf, L"List, ");
    	if (dwMask & ADS_RIGHT_DS_SELF)
    	    wcscat(pszBuf, L"Self, ");
    	if (dwMask & ADS_RIGHT_DS_READ_PROP)
    	    wcscat(pszBuf, L"R prop, ");
    	if (dwMask & ADS_RIGHT_DS_WRITE_PROP)
    	    wcscat(pszBuf, L"W prop, ");
    	if (dwMask & ADS_RIGHT_DS_DELETE_TREE)
    	    wcscat(pszBuf, L"Del tree, ");
    	if (dwMask & ADS_RIGHT_DS_LIST_OBJECT)
    	    wcscat(pszBuf, L"List obj, ");
    	if (dwMask & ADS_RIGHT_DS_CONTROL_ACCESS)
    	    wcscat(pszBuf, L"Ctrl acc, ");
    }

    return pszBuf;
}

PWCHAR
DsrAceFlagsToString(
    IN DWORD dwAceFlags,
    IN PWCHAR pszBuf)
{   
    WCHAR pszTemp[64];
    *pszBuf = L'\0';

    switch (dwAceFlags)
    {
        case 0:
            wcscpy(pszBuf, L"This object only");
    	    break;
        
        case ADS_ACEFLAG_INHERIT_ACE:
            wcscpy(pszBuf, L"This object and children");
    	    break;
    	    
    	case ADS_ACEFLAG_NO_PROPAGATE_INHERIT_ACE:
            wcscpy(pszBuf, L"No-prop inherit");
    	    break;
    	    
    	case ADS_ACEFLAG_INHERIT_ONLY_ACE:
            wcscpy(pszBuf, L"Inherit-only");
    	    break;
    	    
    	case ADS_ACEFLAG_INHERITED_ACE:
    	    wcscpy(pszBuf, L"Inherited");
    	    break;
    	    
    	case ADS_ACEFLAG_VALID_INHERIT_FLAGS:
    	    wcscpy(pszBuf, L"Valid inherit flags");
    	    break;
    	    
    	case ADS_ACEFLAG_SUCCESSFUL_ACCESS:
    	    wcscpy(pszBuf, L"Successful access");
    	    break;
    	    
    	case ADS_ACEFLAG_FAILED_ACCESS:
    	    wcscpy(pszBuf, L"Failed access");
    	    break;
    }  

    wsprintfW(pszTemp, L" (%x)", dwAceFlags);
    wcscat(pszBuf, pszTemp);

    return pszBuf;
}   	

//
// Traces out the contents of an ACE
//
VOID
DsrAceDescTrace(
    IN IADs* pIads,
    IN DSR_ACE_DESCRIPTOR* pA)
{
    VARIANT var;
    BSTR bstrProp = SysAllocString(pszDn);
    HRESULT hr = S_OK;
    WCHAR pszBuf[1024];

    do
    {
        VariantInit(&var);

        if (bstrProp == NULL)
        {
            hr = E_FAIL;
            break;
        }

        hr = pIads->Get(bstrProp, &var);
        DSR_BREAK_ON_FAILED_HR( hr );

        DsrTraceEx(0, "%ls", V_BSTR(&var));
        DsrTraceEx(0, "%ls", 
            DsrAceMaskToString(pA->dwAceType, pA->dwAccessMask, pszBuf));
        DsrTraceEx(0, "To:          %ls", pA->bstrTrustee);
        DsrTraceEx(0, "Attribute:   %ls", 
            DsrAceAttrToString(pA->bstrObjectType));
        DsrTraceEx(0, "ApplyTo:     %ls", 
            DsrAceApplyToString(pA->bstrInheritedObjectType));
        DsrTraceEx(0, "Inheritance: %ls", 
            DsrAceFlagsToString(pA->dwAceFlags, pszBuf));
        DsrTraceEx(0, "Flags:       %x", pA->dwFlags);
        DsrTraceEx(0, " ");

    } while (FALSE);

    // Cleanup
    //
    {
        SysFreeString(bstrProp);
        VariantClear(&var);        
    }        

    if (FAILED(hr))
    {
        DsrTraceEx(
            0, 
            "{ %-8x %-2x %-2x %-2x %-40ls %ls %ls }",
            pA->dwAccessMask,
            pA->dwAceType,
            pA->dwAceFlags,
            pA->dwFlags,
            pA->bstrTrustee,
            pA->bstrObjectType,
            pA->bstrInheritedObjectType);
    }
}

//
// Adds the given ace to the given ds object
//
HRESULT
DsrAceAdd(
    IN  PWCHAR pszDC,
    IN  IADs* pIads,
    IN  DSR_ACE_DESCRIPTOR * pAceParams)
{
    IADsSecurityDescriptor* pSD = NULL;
    IADsAccessControlList* pAcl = NULL;
    IDispatch* pAce = NULL;
    IDispatch* pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT var;

    // Initialize
    VariantInit(&var);

    do
    {
        // Get the security descriptor
        //
        pIads->Get((PWCHAR)pszSecurityDesc, &var);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get the appropriate interface to the sd
        //
        V_DISPATCH(&var)->QueryInterface(
            IID_IADsSecurityDescriptor,
            (VOID**)&pSD);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get a reference to the discretionary acl
        //
        hr = pSD->get_DiscretionaryAcl(&pDispatch);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pDispatch->QueryInterface(
                IID_IADsAccessControlList,
                (VOID**)&pAcl);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Don't add the ACE if it's already there.
        //
        hr = DsrAceFindInAcl(
                pszDC,                
                pAcl,
                pAceParams,
                &pAce);
        if (SUCCEEDED(hr) && pAce)
        {
            hr = S_OK;
            break;
        }

        // Trace out the ACE
        DsrAceDescTrace(pIads, pAceParams);

        // Create the ACE
        hr = DsrAceCreate(pAceParams, &pAce);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Add the newly created ACE to the ACL
        //
        hr = pAcl->AddAce(pAce);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Now commit the result in the ACL
        //
        hr = pSD->put_DiscretionaryAcl(pDispatch);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Finally, commit the result in the ds object
        //
        hr = pIads->Put((PWCHAR)pszSecurityDesc, var);
        DSR_BREAK_ON_FAILED_HR( hr );

    } while (FALSE);

    // Cleanup
    {
        DSR_RELEASE( pAce );
        DSR_RELEASE( pAcl );
        DSR_RELEASE( pDispatch );
        DSR_RELEASE( pSD );

        VariantClear(&var);
    }

    return DSR_ERROR(hr);
}

//
// Creates a new ACE object from the given parameters
//
HRESULT
DsrAceCreate(
    IN  DSR_ACE_DESCRIPTOR * pAceParams,
    OUT IDispatch** ppAce)
{
    IADsAccessControlEntry* pAce = NULL;
    IDispatch* pRet = NULL;
    HRESULT hr = S_OK;

    do
    {
        // Create the new ACE
        //
        hr = CoCreateInstance(
                CLSID_AccessControlEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlEntry,
                (VOID**) &pAce);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Initialize the values
        //
        hr = pAce->put_Trustee(pAceParams->bstrTrustee);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_AceFlags(pAceParams->dwAceFlags);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_Flags(pAceParams->dwFlags);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_AceType(pAceParams->dwAceType);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_AccessMask(pAceParams->dwAccessMask);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_ObjectType(pAceParams->bstrObjectType);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAce->put_InheritedObjectType(
                        pAceParams->bstrInheritedObjectType);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Query the return value
        //
        hr = pAce->QueryInterface(IID_IDispatch, (VOID**)&pRet);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Assign the return value
        *ppAce = pRet;

    } while (FALSE);

    // Cleanup
    {
        if (FAILED (hr))
        {
            DSR_RELEASE(pRet);
        }
        DSR_RELEASE(pAce);
    }

    return hr;
}

//
// Finds the given ace in the given acl
//
HRESULT
DsrAceFind(
    IN  PWCHAR pszDC,
    IN  IADs* pObject,
    IN  DSR_ACE_DESCRIPTOR* pAceParams,
    OUT VARIANT* pVarSD,
    OUT IADsSecurityDescriptor** ppSD,
    OUT IADsAccessControlList** ppAcl,
    OUT IDispatch** ppAce)
{
    IDispatch* pAcl = NULL;
    HRESULT hr = S_OK;

    do
    {
        // Get the security descriptor
        //
        pObject->Get((PWCHAR)pszSecurityDesc, pVarSD);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get the appropriate interface to the sd
        //
        V_DISPATCH(pVarSD)->QueryInterface(
            IID_IADsSecurityDescriptor,
            (VOID**)ppSD);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get a reference to the discretionary acl
        //
        hr = (*ppSD)->get_DiscretionaryAcl(&pAcl);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = pAcl->QueryInterface(
                IID_IADsAccessControlList,
                (VOID**)ppAcl);
        DSR_BREAK_ON_FAILED_HR( hr );

        hr = DsrAceFindInAcl(
                pszDC,
                *ppAcl,
                pAceParams,
                ppAce);
        DSR_BREAK_ON_FAILED_HR(hr);                

    } while (FALSE);

    // Cleanup
    {
        DSR_RELEASE( pAcl );

        if (*ppAce == NULL)
        {
            VariantClear(pVarSD);
            DSR_RELEASE(*ppAcl);
            DSR_RELEASE(*ppSD);
            *ppAcl = NULL;
            *ppSD = NULL;
        }
    }

    return hr;
}

//
// Finds the given ACE in the given ACL
//
HRESULT
DsrAceFindInAcl(
    IN  PWCHAR pszDC,
    IN  IADsAccessControlList* pAcl,
    IN  DSR_ACE_DESCRIPTOR* pAceDesc, 
    OUT IDispatch** ppAce)
{    
    DSR_ACE_DESCRIPTOR CurAceParams, *pCurAceDesc = &CurAceParams;
    IADsAccessControlEntry* pCurAce = NULL;
    HRESULT hr = S_OK;
    IUnknown* pUnknown = NULL;
    IEnumVARIANT* pEnumVar = NULL;
    IDispatch* pRet = NULL;
    DWORD dwRetrieved;
    VARIANT var;

    do
    {
        // Get an enumerator of the aces
        //
        hr = pAcl->get__NewEnum(&pUnknown);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get the right interface to enumerate the aces
        //
        hr = pUnknown->QueryInterface(IID_IEnumVARIANT, (VOID**)&pEnumVar);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Enumerate
        //
        pEnumVar->Reset();
        VariantInit(&var);
        ZeroMemory(pCurAceDesc, sizeof(DSR_ACE_DESCRIPTOR));
        while ((pEnumVar->Next(1, &var, &dwRetrieved) == S_OK) &&
               (dwRetrieved == 1)
              )
        {
            // Get the reference to the ace
            //
            hr = V_DISPATCH(&var)->QueryInterface(
                    IID_IADsAccessControlEntry,
                    (VOID**)&pCurAce);

            if (SUCCEEDED (hr))
            {
                // Read the ACE parameters
                //
                hr = DsrAceDescFromIadsAce(pszDC, pCurAce, pCurAceDesc);
                if (SUCCEEDED (hr))
                {
                    // Assign the ace if we have a match
                    //
                    if (DsrAceDescCompare(pCurAceDesc, pAceDesc) == 0)
                    {
                        pRet = V_DISPATCH(&var);
                    }

                    DsrAceDescClear(pCurAceDesc);
                }
                pCurAce->Release();
            }

            if (pRet == NULL)
            {
                VariantClear(&var);
            }
            else
            {
                break;
            }
        }

        // Assign the return value
        //
        *ppAce = pRet;
        
    } while (FALSE);        

    // Cleanup
    {
        DSR_RELEASE( pEnumVar );
        DSR_RELEASE( pUnknown );
    }

    return hr;
}    

//
// Removes the given ace from the given ds object
//
HRESULT
DsrAceRemove(
    IN  PWCHAR pszDC,
    IN  IADs* pIads,
    IN  DSR_ACE_DESCRIPTOR * pAceParams)
{
    IADsSecurityDescriptor* pSD = NULL;
    IADsAccessControlList* pAcl = NULL;
    IADsAccessControlEntry* pIadsAce = NULL;
    IDispatch* pAce = NULL;
    DSR_ACE_DESCRIPTOR CurAceParams;
    HRESULT hr = S_OK;
    VARIANT varSD;

    do
    {
        VariantInit(&varSD);

        hr = DsrAceFind(pszDC, pIads, pAceParams, &varSD, &pSD, &pAcl, &pAce);
        DSR_BREAK_ON_FAILED_HR( hr );

        if (pAce)
        {
            // Make sure the ace is the same as we think
            //
            hr = pAce->QueryInterface(
                    IID_IADsAccessControlEntry, 
                    (VOID**)&pIadsAce);
            if (SUCCEEDED(hr))
            {
                DsrTraceEx(0, "ACE to be removed!");
                DsrAceDescFromIadsAce(pszDC, pIadsAce, &CurAceParams);
                DsrAceDescTrace(pIads, &CurAceParams);
                DsrAceDescClear(&CurAceParams);
            }
            else
            {
                DsrTraceEx(0, "Unable to trace ACE that will be removed!\n");
            }
        
            // Remove the ace found if any.
            //
            // Trace out the ACE
            hr = pAcl->RemoveAce(pAce);
            DSR_BREAK_ON_FAILED_HR( hr );

            // Now commit the result in the ACL
            //
            hr = pSD->put_DiscretionaryAcl(pAcl);
            DSR_BREAK_ON_FAILED_HR( hr );

            // Finally, commit the result in the ds object
            //
            hr = pIads->Put((PWCHAR)pszSecurityDesc, varSD);
            DSR_BREAK_ON_FAILED_HR( hr );
        }
        else
        {
            DsrTraceEx(0, "DsrAceRemove: unable to match ACE for removal:");
            DsrAceDescTrace(pIads, pAceParams);
        }

    } while (FALSE);

    // Cleanup
    {
        DSR_RELEASE( pAce );
        DSR_RELEASE( pIadsAce );
        DSR_RELEASE( pAcl );
        DSR_RELEASE( pSD );
        VariantClear(&varSD);
    }

    return DSR_ERROR(hr);
}

//
// Cleans up after DsrAccessInfoInit
//
DWORD
DsrAccessInfoCleanup(
    IN DSR_DOMAIN_ACCESS_INFO* pInfo)
{
    if (pInfo)
    {
        // Cleanup the name of the DC
        //
        if (pInfo->pszDC)
        {
            DsrFree(pInfo->pszDC);
        }
    
        // Cleanup the ace applications
        //
        DsrAceAppCleanup(pInfo->pAces, pInfo->dwAceCount);

        // Release the hold on domain objects
        //
        DSR_RELEASE(pInfo->pRootDse);
        DSR_RELEASE(pInfo->pDomain);

        DsrFree(pInfo);
    }

    return NO_ERROR;
}

//
// Generates the information needed to enable nt4 ras
// servers in a domain
//
HRESULT
DsrAccessInfoInit(
    IN  PWCHAR pszDomain,
    OUT DSR_DOMAIN_ACCESS_INFO** ppInfo)
{
    DSR_DOMAIN_ACCESS_INFO* pInfo = NULL;
    IADsContainer* pDomContainer = NULL;
    IADs* pDomain = NULL;
    IDispatch* pDispatch = NULL;
    PDOMAIN_CONTROLLER_INFO pDomainInfo = NULL;
    HRESULT hr = S_OK;

    do
    {
        // Allocate and zero the return value
        //
        pInfo = (DSR_DOMAIN_ACCESS_INFO*)
                    DsrAlloc(sizeof(DSR_DOMAIN_ACCESS_INFO), TRUE);
        if (pInfo == NULL)
        {
           DSR_BREAK_ON_FAILED_HR(hr = E_OUTOFMEMORY);
        }

        // Get the name of a DC to query when needed
        //
        hr = DsGetDcNameW(
                NULL,
                pszDomain,
                NULL,
                NULL,
                DS_DIRECTORY_SERVICE_REQUIRED,
                &pDomainInfo);
        if (hr != NO_ERROR)
        {
            hr = HRESULT_FROM_WIN32(hr);
            break;
        }

        // Copy the string
        //
        pInfo->pszDC = (PWCHAR)
            DsrAlloc(
                (wcslen(pDomainInfo->DomainControllerName) + 1) * 
                sizeof(WCHAR),
                FALSE);
        if (pInfo->pszDC == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        wcscpy(pInfo->pszDC, pDomainInfo->DomainControllerName);

        // Get the well known domain containers
        //
        hr = DsrDomainGetBaseObjects(
                pszDomain,
                &(pInfo->pRootDse),
                &pDomContainer);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Get the interface to the domain object
        //
        hr = pDomContainer->QueryInterface(
                IID_IADs,
                (VOID**)&pDomain);
        DSR_BREAK_ON_FAILED_HR( hr );
        pInfo->pDomain = pDomain;
        pInfo->pDomain->AddRef();

        // Create ace applications 
        hr = DsrAceAppFromAppDesc(
                g_pAces,
                sizeof(g_pAces) / sizeof(*g_pAces),
                pDomContainer,
                pDomain,
                &(pInfo->pAces),
                &(pInfo->dwAceCount));
        DSR_BREAK_ON_FAILED_HR( hr );

        // Assign the return value
        *ppInfo = pInfo;

    } while (FALSE);

    // Cleanup
    //
    {
        DSR_RELEASE(pDomain);
        DSR_RELEASE(pDomContainer);
        DSR_RELEASE(pDispatch);
        if (FAILED (hr))
        {
            DsrAccessInfoCleanup(pInfo);
        }
        if (pDomainInfo)
        {
            NetApiBufferFree(pDomainInfo);
        }
    }

    return hr;
}

//
// Discovers the access mode of the domain currently.
//
// Assumes COM is initialized
//
HRESULT
DsrDomainQueryAccessEx(
    IN  PWCHAR pszDomain,
    OUT LPDWORD lpdwAccessFlags,
    OUT DSR_DOMAIN_ACCESS_INFO** ppInfo)
{
    DSR_DOMAIN_ACCESS_INFO* pInfo = NULL;
    HRESULT hr = S_OK;
    BOOL bOk = FALSE;

    if (lpdwAccessFlags == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    do
    {
        // Initialize
        //
        *lpdwAccessFlags = 0;
        
        // Read in the info that tells us what ACE's
        // need to be set.
        //
        hr = DsrAccessInfoInit(
                pszDomain, 
                &pInfo);
        DSR_BREAK_ON_FAILED_HR( hr );

        // Check for nt4 level access
        //
        bOk = FALSE;
        hr = DsrAceAppQueryPresence(
                pInfo->pszDC,
                pInfo->pAces,
                pInfo->dwAceCount,
                MPRFLAG_DOMAIN_ALL,
                &bOk);
        DSR_BREAK_ON_FAILED_HR(hr);

        // If we don't have nt4 access, we have no access
        //
        if (bOk == FALSE)
        {
            *lpdwAccessFlags = 0;
            break;
        }
        *lpdwAccessFlags |= MPRFLAG_DOMAIN_NT4_SERVERS;

        // Check for w2k level access
        //
        bOk = FALSE;
        hr = DsrAceAppQueryPresence(
                pInfo->pszDC,
                pInfo->pAces,
                pInfo->dwAceCount,
                MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS,
                &bOk);
        DSR_BREAK_ON_FAILED_HR(hr);

        // If we don't have w2k access, no need to proceed
        //
        if (bOk == FALSE)
        {
            break;
        }
        *lpdwAccessFlags |= MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS;

    } while (FALSE);

    // Cleanup
    {
        if (FAILED(hr))
        {
            if (pInfo)
            {
                DsrAccessInfoCleanup(pInfo);
            }
        }
        else
        {
            *ppInfo = pInfo;
        }
    }

    return hr;
}

//
// Returns the access level of the given domain
//
DWORD
DsrDomainQueryAccess(
    IN  PWCHAR pszDomain,
    OUT LPDWORD lpdwAccessFlags)
{
    DSR_DOMAIN_ACCESS_INFO* pInfo = NULL;
    HRESULT hr = S_OK;

    do
    {
        // Initialize
        hr = DsrComIntialize();
        DSR_BREAK_ON_FAILED_HR( hr );

        // Query the access
        hr = DsrDomainQueryAccessEx(
                pszDomain,
                lpdwAccessFlags,
                &pInfo);
        DSR_BREAK_ON_FAILED_HR(hr);
        
    } while (FALSE);

    // Cleanup
    {
        if (pInfo)
        {
            DsrAccessInfoCleanup(pInfo);
        }

        DsrComUninitialize();
    }

    return DSR_ERROR(hr);
}

//
// Sets the ACES in the given domain to enable nt4 servers
//
DWORD
DsrDomainSetAccess(
    IN PWCHAR pszDomain,
    IN DWORD dwAccessFlags)
{
    DSR_DOMAIN_ACCESS_INFO* pInfo = NULL;
    HRESULT hr = S_OK;
    BOOL bClean = TRUE;
    DWORD dwCurAccess = 0;

    do
    {
        // Initialize 
        hr = DsrComIntialize();
        DSR_BREAK_ON_FAILED_HR( hr );

        DsrTraceEx(
            0, 
            "DsrDomainSetAccess: Req: %x", 
            dwAccessFlags);
            
        // W2k mode always implies nt4 mode as well
        //
        if (dwAccessFlags & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS)
        {
            dwAccessFlags |= MPRFLAG_DOMAIN_NT4_SERVERS;
        }

        // Discover the current access on the domain and 
        // initialize the info we need
        //
        hr = DsrDomainQueryAccessEx(
                pszDomain,
                &dwCurAccess,
                &pInfo);
        DSR_BREAK_ON_FAILED_HR(hr);

        DsrTraceEx(
            0, 
            "DsrDomainSetAccess: Cur: %x", 
            dwCurAccess);

        // Remove all appropriate aces if the requested access
        // is none.
        if (dwAccessFlags == 0)
        {
            // Remove the nt4 mode aces if needed
            //
            if (dwCurAccess & MPRFLAG_DOMAIN_NT4_SERVERS)
            {
                hr = DsrAceAppRemove(
                        MPRFLAG_DOMAIN_ALL,
                        pInfo->pszDC,
                        pInfo->pAces,
                        pInfo->dwAceCount);
                DSR_BREAK_ON_FAILED_HR(hr);
            }

            if (dwCurAccess & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS)
            {
                hr = DsrAceAppRemove(
                        MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS,
                        pInfo->pszDC,
                        pInfo->pAces,
                        pInfo->dwAceCount);
                DSR_BREAK_ON_FAILED_HR(hr);
            }
        }

        // Set nt4 mode if needed
        //
        if (dwAccessFlags & MPRFLAG_DOMAIN_NT4_SERVERS)
        {
            // Remove w2k level access if needed
            //
            if ((!(dwAccessFlags & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS)) &&
                (dwCurAccess & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS))
            {
                hr = DsrAceAppRemove(
                        MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS,
                        pInfo->pszDC,
                        pInfo->pAces,
                        pInfo->dwAceCount);
                DSR_BREAK_ON_FAILED_HR(hr);
            }

            // Add nt4 level access if needed
            //
            if (! (dwCurAccess & MPRFLAG_DOMAIN_NT4_SERVERS))
            {
                hr = DsrAceAppAdd(
                        MPRFLAG_DOMAIN_ALL,
                        pInfo->pszDC,
                        pInfo->pAces,
                        pInfo->dwAceCount);
                DSR_BREAK_ON_FAILED_HR(hr);
            }
        }

        // Set w2k mode if needed
        //
        if (dwAccessFlags & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS)
        {
            if (!(dwCurAccess & MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS))
            {
                hr = DsrAceAppAdd(
                        MPRFLAG_DOMAIN_W2K_IN_NT4_DOMAINS,
                        pInfo->pszDC,
                        pInfo->pAces,
                        pInfo->dwAceCount);
                DSR_BREAK_ON_FAILED_HR(hr);
            }
        }
        
    } while (FALSE);

    // Cleanup
    {
        if (pInfo)
        {
            DsrAccessInfoCleanup(pInfo);
        }
        
        DsrComUninitialize();
    }

    return DSR_ERROR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pbsmon\perfutil.cpp ===
/*----------------------------------------------------------------------------
    PerfUtil.cpp
  
    Contains general functions used by pbsmon.dll

    Copyright (c) 1997-1998 Microsoft Corporation
    All rights reserved.

    Authors:
        t-geetat    Geeta Tarachandani

    History:
    6/12/97 t-geetat    Created
  --------------------------------------------------------------------------*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "Loaddata.h"
#include "CpsSym.h"

#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


void InitializeDataDef( void )
//----------------------------------------------------------------------------
//
//  Function:   InitializeDataDef
//
//  Synopsis:   Initializes the data-structure g_CpsMonDataDef to pass to the
//              performance monitoring application
//
//  Arguments:  None
//
//  Returns:    void
//
//  History:    06/03/97     t-geetat  Created
//
//----------------------------------------------------------------------------
{
    CPSMON_COUNTERS Ctr;    // This is a dummy variable, just to get offsets


    CPSMON_DATA_DEFINITION CpsMonDataDef = {
        // CPS_OBJECT_TYPE
        {   sizeof( CPSMON_DATA_DEFINITION ) + sizeof( CPSMON_COUNTERS ),// ??
            sizeof( CPSMON_DATA_DEFINITION ),
            sizeof( PERF_OBJECT_TYPE ),
            OBJECT_CPS_SERVER,
            0,
            OBJECT_CPS_SERVER,
            0,
            PERF_DETAIL_NOVICE,
            NUM_OF_INFO_COUNTERS,
            0,  // total hits is the default counter
            -1,  // num instances
            0,  // unicode instance names
            {0,0},
            {0,0}
        },
        //////////////////// 
        //  Raw Counters  //
        ////////////////////
        // Counter 0 -- TOTAL HITS
        {   sizeof(PERF_COUNTER_DEFINITION),
            COUNTER_TOTAL_HITS,
            0,
            COUNTER_TOTAL_HITS,
            0,
            -3, // Scale = 10^-3 = .001
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
           (DWORD)((LPBYTE)&(Ctr.m_dwTotalHits) - (LPBYTE)&Ctr)
        },
        // Counter 1 -- NO UPGRADES
        {   sizeof(PERF_COUNTER_DEFINITION),
            COUNTER_NO_UPGRADE,
            0,
            COUNTER_NO_UPGRADE,
            0,
            -3,     // Scale = 10^-3
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            (DWORD)((LPBYTE)&(Ctr.m_dwNoUpgrade) - (LPBYTE)&Ctr)
        },
        // Counter 2 -- DELTA UPGRADES
        {   sizeof(PERF_COUNTER_DEFINITION),
            COUNTER_DELTA_UPGRADE,
            0,
            COUNTER_DELTA_UPGRADE,
            0,
            -3,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
           (DWORD)((LPBYTE)&(Ctr.m_dwDeltaUpgrade) - (LPBYTE)&Ctr)
        },
        // Counter 3 -- FULL UPGRADE
        {   sizeof(PERF_COUNTER_DEFINITION),
            COUNTER_FULL_UPGRADE,
            0,
            COUNTER_FULL_UPGRADE,
            0,
            -3,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
           (DWORD)((LPBYTE)&(Ctr.m_dwFullUpgrade) - (LPBYTE)&Ctr)
        },
        // Counter 4 -- ERROR HITS
        {   sizeof(PERF_COUNTER_DEFINITION),
            COUNTER_ERRORS,
            0,
            COUNTER_ERRORS,
            0,
            -3,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
           (DWORD)((LPBYTE)&(Ctr.m_dwErrors) - (LPBYTE)&Ctr)
        },
        /////////////////////
        //  Rate Counters  //
        /////////////////////
        // Counter 5 -- TOTAL HITS/SEC
        {   sizeof(PERF_COUNTER_DEFINITION),
            COUNTER_TOTAL_HITS_PER_SEC,
            0,
            COUNTER_TOTAL_HITS_PER_SEC,
            0,
            0,      // Scale = 10^0
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_COUNTER,
            sizeof(DWORD),
           (DWORD)((LPBYTE)&(Ctr.m_dwTotalHitsPerSec) - (LPBYTE)&Ctr)
        },
        // Counter 6 -- NO UPGRADE/SEC
        {   sizeof(PERF_COUNTER_DEFINITION),
            COUNTER_NO_UPGRADE_PER_SEC,
            0,
            COUNTER_NO_UPGRADE_PER_SEC,
            0,
            0,      // Scale = 10^0
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_COUNTER,
            sizeof(DWORD),
           (DWORD)((LPBYTE)&(Ctr.m_dwNoUpgradePerSec) - (LPBYTE)&Ctr)
        },
        // Counter 7 -- DELTA UPGRADE/SEC
        {   sizeof(PERF_COUNTER_DEFINITION),
            COUNTER_DELTA_UPGRADE_PER_SEC,
            0,
            COUNTER_DELTA_UPGRADE_PER_SEC,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_COUNTER,
            sizeof(DWORD),
           (DWORD)((LPBYTE)&(Ctr.m_dwDeltaUpgradePerSec) - (LPBYTE)&Ctr)
        },
        // Counter 8 -- FULL UPGRADE/SEC
        {   sizeof(PERF_COUNTER_DEFINITION),
            COUNTER_FULL_UPGRADE_PER_SEC,
            0,
            COUNTER_FULL_UPGRADE_PER_SEC,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_COUNTER,
            sizeof(DWORD),
           (DWORD)((LPBYTE)&(Ctr.m_dwFullUpgradePerSec) - (LPBYTE)&Ctr)
        },
        // Counter 9 -- ERRORS/SEC
        {   sizeof(PERF_COUNTER_DEFINITION),
            COUNTER_ERRORS_PER_SEC,
            0,
            COUNTER_ERRORS_PER_SEC,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_COUNTER,
            sizeof(DWORD),
           (DWORD)((LPBYTE)&(Ctr.m_dwErrorsPerSec) - (LPBYTE)&Ctr)
        }

    };
    memmove( &g_CpsMonDataDef, &CpsMonDataDef, sizeof(CPSMON_DATA_DEFINITION) );
}

BOOL UpdateDataDefFromRegistry( void )
//----------------------------------------------------------------------------
//
//  Function:   UpdateDataDefFromRegistry
//
//  Synopsis:   Gets counter and help index base values from registry as follows :
//              1) Open key to registry entry
//              2) Read First Counter and First Help values
//              3) Update static data strucutures g_CpsMonDataDef by adding base to
//                  offset value in structure.
//
//  Arguments:  None
//
//  Returns:    TRUE if succeeds, FALSE otherwise
//
//  History:    06/03/97     t-geetat  Created
//
//----------------------------------------------------------------------------
{

    HKEY hKeyDriverPerf;
    BOOL status;
    DWORD type;
    DWORD size; 
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
    PERF_COUNTER_DEFINITION *pctr;
    DWORD i;

    status = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                "SYSTEM\\CurrentControlSet\\Services\\PBServerMonitor\\Performance",
                0L,
                KEY_READ,
                &hKeyDriverPerf);

    if (status != ERROR_SUCCESS) {
        // this is fatal, if we can't get the base values of the
        // counter or help names, then the names won't be available
        // to the requesting application  so there's not much
        // point in continuing.
        return FALSE;
    }

    size = sizeof (DWORD);
    status = RegQueryValueEx(
                    hKeyDriverPerf,
                    "First Counter",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstCounter,
                    &size);

    if (status != ERROR_SUCCESS) {
        // this is fatal, if we can't get the base values of the
        // counter or help names, then the names won't be available
        // to the requesting application  so there's not much
        // point in continuing.
        return FALSE;
    }

    size = sizeof (DWORD);
    status = RegQueryValueEx(
                    hKeyDriverPerf,
                    "First Help",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstHelp,
                    &size);

    if (status != ERROR_SUCCESS) {
        // this is fatal, if we can't get the base values of the
        // counter or help names, then the names won't be available
        // to the requesting application  so there's not much
        // point in continuing.
        return FALSE;
    }
    
    // Object
    g_CpsMonDataDef.m_CpsMonObjectType.ObjectNameTitleIndex += dwFirstCounter;
    g_CpsMonDataDef.m_CpsMonObjectType.ObjectHelpTitleIndex += dwFirstHelp;
        
    // All counters
    pctr = &g_CpsMonDataDef.m_CpsMonTotalHits;
    for( i=0; i<NUM_OF_INFO_COUNTERS; i++ )
    {
        pctr->CounterNameTitleIndex += dwFirstCounter;
        pctr->CounterHelpTitleIndex += dwFirstHelp;
        pctr ++;
    }

    RegCloseKey (hKeyDriverPerf); // close key to registry

    return TRUE;
}

DWORD GetQueryType ( IN LPWSTR lpValue )
/***************************************************************************

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

Source :- Perfmon-DLL samples by Bob Watson ( MSDN )

***********************************************************************************/
{
    WCHAR GLOBAL_STRING[] = L"Global";
    WCHAR FOREIGN_STRING[] = L"Foreign";
    WCHAR COSTLY_STRING[] = L"Costly";

    WCHAR NULL_STRING[] = L"\0";    // pointer to null string

    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}


BOOL IsNumberInUnicodeList (
            IN DWORD   dwNumber,
            IN LPWSTR  lpwszUnicodeList 
            )
/**********************************************************************************

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

    Source :- Perfmon-DLL samples by Bob Watson ( MSDN )

**************************************************************************************/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\apistub.c ===
/*********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	        **/
/*********************************************************************/

//***
//
// Filename:	apistub.c
//
// Description: This module contains the DIM/DDM server API RPC
//		        client stubs.
//
// History:     June 11,1995.	NarenG		Created original version.
//

#include <nt.h>
#include <ntrtl.h>      // For ASSERT
#include <nturtl.h>     // needed for winbase.h
#include <windows.h>    // Win32 base API's
#include <rpc.h>
#include <ntseapi.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <nturtl.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <lm.h>
#include <lmsvc.h>
#include <raserror.h>
#include <mprapip.h>
#include <mprerror.h>
#include <dimsvc.h>

DWORD
DimRPCBind(
	IN  LPWSTR 	            lpwsServerName,
	OUT HANDLE *            phDimServer
);

DWORD APIENTRY
MprAdminInterfaceSetCredentialsEx(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer
);
    
PVOID
MprAdminAlloc(
    IN DWORD dwSize)
{
    return MIDL_user_allocate(dwSize);
}

VOID
MprAdminFree(
    IN PVOID pvData)
{
    MIDL_user_free(pvData);
}

//**
//
// Call:        RasAdminIsServiceRunning
//
// Returns:     TRUE - Service is running.
//              FALSE - Servicis in not running.
//
//
// Description: Checks to see of Remote Access Service is running on the
//              remote machine
//
BOOL
RasAdminIsServiceRunning(
    IN  LPWSTR  lpwsServerName
)
{
    SC_HANDLE       hSM = NULL, hRemoteAccess = NULL, hRouter = NULL;
    DWORD           dwErr = NO_ERROR;
    BOOL            fIsRouterRunning = FALSE, bOk = FALSE;
    SERVICE_STATUS  Status;

    do
    {
        // Get a handle to the service controller
        //
        hSM = OpenSCManager(
                lpwsServerName,
                NULL,
                GENERIC_READ);
        if (hSM == NULL)
        {
            break;
        }

        // Open the remoteaccess service
        //
        hRemoteAccess = OpenService(
                            hSM,
                            L"RemoteAccess",
                            SERVICE_QUERY_STATUS);
        if (hRemoteAccess == NULL)
        {
            break;
        }

        // If remoteaccess service is running, return
        // true
        //
        bOk = QueryServiceStatus(
                hRemoteAccess,
                &Status);
        if (bOk && (Status.dwCurrentState == SERVICE_RUNNING))
        {
            fIsRouterRunning = TRUE;
            break;
        }

        // Otherwise, see if the router service is running.
        //
        hRouter = OpenService(
                    hSM,
                    L"Router",
                    SERVICE_QUERY_STATUS);
        if (hRouter == NULL)
        {
            break;
        }

        // If router service is running, return
        // true
        //
        bOk = QueryServiceStatus(
                hRouter,
                &Status);
        if (bOk && (Status.dwCurrentState == SERVICE_RUNNING))
        {
            fIsRouterRunning = TRUE;
            break;
        }

    } while (FALSE);

    // Cleanup
    {
        if (hRemoteAccess)
        {
            CloseServiceHandle(hRemoteAccess);
        }
        if (hRouter)
        {
            CloseServiceHandle(hRouter);
        }
        if (hSM)
        {
            CloseServiceHandle(hSM);
        }
    }

    return fIsRouterRunning;
}

//**
//
// Call:	    RasAdminServerConnect
//
// Returns:	    NO_ERROR - success
//		        non-zero returns from the DimRPCBind routine.
//		
//
// Description: This is the DLL entrypoint for RasAdminServerConnect
//
DWORD
RasAdminServerConnect(
    IN  LPWSTR 		        lpwsServerName,
    OUT RAS_SERVER_HANDLE * phRasServer
)
{
    //
    // Bind with the server
    //

    return( DimRPCBind( lpwsServerName, phRasServer ) );
}

//**
//
// Call:	    RasAdminServerDisconnect
//
// Returns:	    none.
//
// Description: This is the DLL entrypoint for RasAdminServerDisconnect
//
VOID
RasAdminServerDisconnect(
	IN RAS_SERVER_HANDLE    hRasServer
)
{
    RpcBindingFree( (handle_t *)&hRasServer );
}

//**
//
// Call:	    RasAdminBufferFree
//
// Returns:	    none
//
// Description: This is the DLL entrypoint for RasAdminBufferFree
//
DWORD
RasAdminBufferFree(
	IN PVOID		pBuffer
)
{
    if ( pBuffer == NULL )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    MIDL_user_free( pBuffer );

    return( NO_ERROR );
}

//**
//
// Call:	    RasAdminConnectionEnum
//
// Returns:	    NO_ERROR	- success
//		        ERROR_INVALID_PARAMETER
//		        non-zero returns from RRasAdminConnectionEnum
//
// Description: This is the DLL entry point for RasAdminConnectionEnum.
//
DWORD APIENTRY
RasAdminConnectionEnum(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      DWORD                   dwLevel,
    OUT     LPBYTE *                lplpbBuffer,        // RAS_CONNECTION_0
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN      LPDWORD                 lpdwResumeHandle    OPTIONAL
)
{
    DWORD			            dwRetCode;
    DIM_INFORMATION_CONTAINER   InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    // Validate parameters
    //
    if (dwPrefMaxLen == 0)
    {
        return ERROR_MORE_DATA;
    }

    //
    // Touch all pointers
    //

    try
    {
	    *lplpbBuffer 	  = NULL;
	    *lpdwEntriesRead  = 0;
	    *lpdwTotalEntries = 0;

	    if ( lpdwResumeHandle )
        {
	        *lpdwResumeHandle;
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
	    dwRetCode = RRasAdminConnectionEnum(
                            hRasServer,
                            dwLevel,
    					    &InfoStruct,
					        dwPrefMaxLen,
                            lpdwEntriesRead,
					        lpdwTotalEntries,
					        lpdwResumeHandle );

	    if ( InfoStruct.pBuffer != NULL )
        {
            dwRetCode = 
                MprThunkConnection_WtoH(
                    dwLevel,
                    InfoStruct.pBuffer,
                    InfoStruct.dwBufferSize,
                    *lpdwEntriesRead,
                    MprAdminAlloc,
                    MprAdminFree,
                    lplpbBuffer);
	    }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
	    dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	    RasAdminPortEnum
//
// Returns:	    NO_ERROR	- success
//		        ERROR_INVALID_PARAMETER
//		        non-zero returns from RRasAdminPortEnum
//
// Description: This is the DLL entry point for RasAdminPortEnum.
//
DWORD APIENTRY
RasAdminPortEnum(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      DWORD                   dwLevel,
    IN      HANDLE                  hRasConnection,
    OUT     LPBYTE *                lplpbBuffer,        // RAS_PORT_0
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN      LPDWORD                 lpdwResumeHandle    OPTIONAL
)
{
    DWORD			            dwRetCode;
    DIM_INFORMATION_CONTAINER   InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    //
    // Touch all pointers
    //

    try
    {
	    *lplpbBuffer 	  = NULL;
	    *lpdwEntriesRead  = 0;
	    *lpdwTotalEntries = 0;

	    if ( lpdwResumeHandle )
        {
	        *lpdwResumeHandle;
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
	    dwRetCode = RRasAdminPortEnum(
                            hRasServer,
                            dwLevel,
                            PtrToUlong(hRasConnection),
    					    &InfoStruct,
					        dwPrefMaxLen,
                            lpdwEntriesRead,
					        lpdwTotalEntries,
					        lpdwResumeHandle );

	    if ( InfoStruct.pBuffer != NULL )
        {
            dwRetCode = 
                MprThunkPort_WtoH(
                    dwLevel,
                    InfoStruct.pBuffer,
                    InfoStruct.dwBufferSize,
                    *lpdwEntriesRead,
                    MprAdminAlloc,
                    MprAdminFree,
                    lplpbBuffer);          
	    }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
	    dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	    RasAdminConnectionGetInfo
//
// Returns:	    NO_ERROR	- success
//		        ERROR_INVALID_PARAMETER
//		        non-zero return codes from RRasAdminConnectionGetInfo
//
// Description: This is the DLL entrypoint for RasAdminConnectionGetInfo
//
DWORD APIENTRY
RasAdminConnectionGetInfo(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      DWORD                   dwLevel,
	IN      HANDLE	                hRasConnection,
    OUT     LPBYTE *                lplpbBuffer
)
{
    DWORD	                    dwRetCode;
    DIM_INFORMATION_CONTAINER   InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    //
    // Make sure that all pointers passed in are valid
    //

    try
    {
		*lplpbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
	
	    dwRetCode = RRasAdminConnectionGetInfo(
                            hRasServer,
                            dwLevel,
                            PtrToUlong(hRasConnection),
					        &InfoStruct );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
	    dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    if ( dwRetCode == NO_ERROR )
    {
	    if ( InfoStruct.pBuffer != NULL )
        {
            MprThunkConnection_WtoH(
                dwLevel,
                InfoStruct.pBuffer,
                InfoStruct.dwBufferSize,
                1,
                MprAdminAlloc,
                MprAdminFree,
                lplpbBuffer);          
	    }
    }

    return( dwRetCode );
}

//**
//
// Call:	    RasAdminPortGetInfo
//
// Returns:	    NO_ERROR	- success
//		        ERROR_INVALID_PARAMETER
//		        non-zero return codes from RRasAdminPortGetInfo
//
// Description: This is the DLL entrypoint for RasAdminPortGetInfo
//
DWORD APIENTRY
RasAdminPortGetInfo(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      DWORD                   dwLevel,
	IN      HANDLE	                hPort,
	OUT     LPBYTE *                lplpbBuffer
)
{
    DWORD	                    dwRetCode;
    DIM_INFORMATION_CONTAINER   InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    //
    // Make sure that all pointers passed in are valid
    //

    try
    {
    	*lplpbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
	    dwRetCode = RRasAdminPortGetInfo(
                                    hRasServer,
                                    dwLevel,
                                    PtrToUlong(hPort),
					                &InfoStruct );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
	    dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    if ( dwRetCode == NO_ERROR )
    {
	    if ( InfoStruct.pBuffer != NULL )
        {
                MprThunkPort_WtoH(
                    dwLevel,
                    InfoStruct.pBuffer,
                    InfoStruct.dwBufferSize,
                    1,
                    MprAdminAlloc,
                    MprAdminFree,
                    lplpbBuffer);          
	    }
    }

    return( dwRetCode );
}

//**
//
// Call:        RasAdminGetErrorString
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RRasAdminGetErrorString
//
// Description: This is the DLL entrypoint for RasAdminGetErrorString
//
DWORD APIENTRY
RasAdminGetErrorString(
    IN      DWORD                   dwError,
    OUT     LPWSTR *                lplpwsErrorString
)
{
    return( MprAdminGetErrorString( dwError, lplpwsErrorString ) );
}

//**
//
// Call:	    RasAdminConnectionClearStats
//
// Returns:	    NO_ERROR	- success
//		        ERROR_INVALID_PARAMETER
//		        non-zero return codes from RRasAdminConnectionClearStats
//
// Description: This is the DLL entrypoint for RasAdminConnectionClearStats
//
DWORD APIENTRY
RasAdminConnectionClearStats(
    IN      RAS_SERVER_HANDLE       hRasServer,
	IN      HANDLE	                hRasConnection
)
{
    DWORD	dwRetCode;

    RpcTryExcept
    {
	    dwRetCode = RRasAdminConnectionClearStats(
                                    hRasServer,
                                    PtrToUlong(hRasConnection) );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
	    dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	    RasAdminPortClearStats
//
// Returns:	    NO_ERROR	- success
//		        ERROR_INVALID_PARAMETER
//		        non-zero return codes from RRasAdminPortClearStats
//
// Description: This is the DLL entrypoint for RasAdminPortClearStats
//
DWORD APIENTRY
RasAdminPortClearStats(
    IN      RAS_SERVER_HANDLE       hRasServer,
	IN      HANDLE	                hPort
)
{
    DWORD	dwRetCode;

    RpcTryExcept
    {
	    dwRetCode = RRasAdminPortClearStats( hRasServer, PtrToUlong(hPort) );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
	    dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	    RasAdminPortReset
//
// Returns:	    NO_ERROR	- success
//		        ERROR_INVALID_PARAMETER
//		        non-zero return codes from RRasAdminPortReset
//
// Description: This is the DLL entrypoint for RasAdminPortReset
//
DWORD APIENTRY
RasAdminPortReset(
    IN      RAS_SERVER_HANDLE       hRasServer,
	IN      HANDLE	                hPort
)
{
    DWORD	dwRetCode;

    RpcTryExcept
    {
	    dwRetCode = RRasAdminPortReset( hRasServer, PtrToUlong(hPort) );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
	    dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        RasAdminPortDisconnect
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RRasAdminPortDisconnect
//
// Description: This is the DLL entrypoint for RasAdminPortDisconnect
//
DWORD APIENTRY
RasAdminPortDisconnect(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      HANDLE                  hPort
)
{
    DWORD   dwRetCode;

    RpcTryExcept
    {
        dwRetCode = RRasAdminPortDisconnect( hRasServer, PtrToUlong(hPort) );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminSendUserMessage
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
MprAdminSendUserMessage(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hRasConnection,
    IN      LPWSTR                  lpwszMessage
)
{
    DWORD   dwRetCode;
    BOOL    fZeroLengthMessage = FALSE;

    //
    // make sure the buffer is valid, and enough bytes are really available
    //

    try
    {
        if ( wcslen( lpwszMessage ) == 0 )
        {
            fZeroLengthMessage = TRUE;
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    if ( fZeroLengthMessage )
    {
        return( NO_ERROR );
    }

    RpcTryExcept
    {
        dwRetCode = RRasAdminSendUserMessage(
                                    hMprServer,
                                    PtrToUlong(hRasConnection),
                                    lpwszMessage );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );

}

//**
//
// Call:        MprAdminServerGetInfo
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RMprAdminServerGetInfo
//
// Description: This is the DLL entrypoint for MprAdminServerGetInfo
//
DWORD APIENTRY
MprAdminServerGetInfo(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    IN      LPBYTE *                lplpbBuffer
)
{
    DWORD                       dwRetCode;
    DIM_INFORMATION_CONTAINER   InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    //
    // Make sure that all pointers passed in are valid
    //

    try
    {
    	*lplpbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RMprAdminServerGetInfo(
                                    hMprServer,
                                    dwLevel,
					                &InfoStruct );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    if ( dwRetCode == NO_ERROR )
    {
	    if ( InfoStruct.pBuffer != NULL )
        {
            *lplpbBuffer = InfoStruct.pBuffer;
	    }
    }

    return( dwRetCode );
}


DWORD APIENTRY
MprAdminServerSetCredentials(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer
)
{
    if(0 != dwLevel)
    {   
        return ERROR_INVALID_PARAMETER;
    }

    return MprAdminInterfaceSetCredentialsEx(
                    hMprServer,
                    NULL,
                    2,
                    lpbBuffer);
}

DWORD APIENTRY
MprAdminServerGetCredentials(
        IN  MPR_SERVER_HANDLE       hMprServer,
        IN  DWORD                   dwLevel,
        IN  LPBYTE *                lplpbBuffer)
{
    if(     (0 != dwLevel)
        ||  (NULL == lplpbBuffer))
    {
        return ERROR_INVALID_PARAMETER;

    }
    
    return MprAdminInterfaceGetCredentialsEx(
                hMprServer,
                NULL,
                2,
                lplpbBuffer);
}

//**
//
// Call:        MprAdminIsServiceRunning
//
// Returns:     TRUE - Service is running.
//              FALSE - Servicis in not running.
//
//
// Description: Checks to see of Remote Access Service is running on the
//              remote machine
//
BOOL
MprAdminIsServiceRunning(
    IN  LPWSTR  lpwsServerName
)
{
    BOOL fServiceStarted;
    DWORD dwErr;
    HANDLE hServer;

    // First query the service controller to see whether
    // the service is running.
    //
    fServiceStarted = RasAdminIsServiceRunning( lpwsServerName );
    if ( fServiceStarted == FALSE )
    {
        return FALSE;
    }

    // pmay: 209235
    //
    // Even if the service controller says that the service is
    // started, it may still be initializing.  
    //

    // Initalize
    {
        fServiceStarted = FALSE;
        dwErr = NO_ERROR;
        hServer = NULL;
    }

    do 
    {
        // Connect to the service rpc
        //
        dwErr = MprAdminServerConnect(
                    lpwsServerName,
                    &hServer);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Return TRUE iff the service has been 
        // running for more than zero seconds
        //
        fServiceStarted = TRUE;
        
    } while (FALSE);

    // Cleanup
    {
        if (hServer)
        {
            MprAdminServerDisconnect( hServer );
        }
    }
    
    return fServiceStarted;
}

//
// Call:        MprAdminServerConnect
//
// Returns:     NO_ERROR - success
//              non-zero returns from the DimRPCBind routine.
//
//
// Description: This is the DLL entrypoint for RouterInterfaceServerConnect
//
DWORD
MprAdminServerConnect(
    IN  LPWSTR                  lpwsServerName,
    OUT MPR_SERVER_HANDLE *     phMprServer
)
{
    DWORD dwErr = NO_ERROR;
    MPR_SERVER_0 * pMprServer0 = NULL;

    do 
    {
        //
        // Bind with the server
        //
        dwErr = DimRPCBind( lpwsServerName, phMprServer );
        
        if ( dwErr != NO_ERROR )
        {
            break;
        }

        // 
        // pmay: 209235
        //
        // Only return success if the service is running.
        //
        dwErr = MprAdminServerGetInfo(
                    *phMprServer,
                    0,
                    (LPBYTE*)&pMprServer0);
                    
        if (dwErr != NO_ERROR)
        {
            break;
        }
        
    } while (FALSE);

    // Cleanup
    {
        if ( pMprServer0 != NULL)
        {
            MprAdminBufferFree( pMprServer0 );
        }

        if (    (dwErr != NO_ERROR )
            &&  (NULL != *phMprServer))
        {
            MprAdminServerDisconnect( *phMprServer );
            *phMprServer = NULL;
        }
    }

    return dwErr;
}

//**
//
// Call:        MprAdminServerDisconnect
//
// Returns:     none.
//
// Description: This is the DLL entrypoint for RouterInterfaceServerDisconnect
//
VOID
MprAdminServerDisconnect(
    IN MPR_SERVER_HANDLE    hMprServer
)
{
    RpcBindingFree( (handle_t *)&hMprServer );
}

//**
//
// Call:        MprAdminBufferFree
//
// Returns:     none
//
// Description: This is the DLL entrypoint for RouterInterfaceBufferFree
//
DWORD
MprAdminBufferFree(
    IN PVOID        pBuffer
)
{
    if ( pBuffer == NULL )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    MIDL_user_free( pBuffer );

    return( NO_ERROR );
}

//**
//
// Call:        MprAdminTransportCreate
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: This is the DLL entrypoint for MprAdminTransportCreate
//
DWORD APIENTRY
MprAdminTransportCreate(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwTransportId,
    IN      LPWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      LPWSTR                  lpwsDLLPath
)
{
    DWORD                       dwRetCode;
    DIM_INTERFACE_CONTAINER     InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    try
    {
        if ( pGlobalInfo != NULL )
        {
            InfoStruct.dwGlobalInfoSize     = dwGlobalInfoSize;
            InfoStruct.pGlobalInfo          = pGlobalInfo;
        }

        if ( pClientInterfaceInfo != NULL )
        {
            InfoStruct.dwInterfaceInfoSize  = dwClientInterfaceInfoSize;
            InfoStruct.pInterfaceInfo       = pClientInterfaceInfo;
        }

    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceTransportCreate(
                                    hMprServer,
                                    dwTransportId,
                                    lpwsTransportName,
                                    &InfoStruct,
                                    lpwsDLLPath );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminTransportSetInfo
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from
//              RRouterInterfaceTransportSetGlobalInfo
//
// Description: This is the DLL entrypoint for
//              RouterInterfaceTransportSetGlobalInfo
//
DWORD APIENTRY
MprAdminTransportSetInfo(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwTransportId,
    IN      LPBYTE                  pGlobalInfo                 OPTIONAL,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize
)
{
    DWORD                       dwRetCode;
    DIM_INTERFACE_CONTAINER     InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    //
    // Make sure that all pointers passed in are valid
    //

    if ( ( pGlobalInfo == NULL ) && ( pClientInterfaceInfo == NULL ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    try
    {
        if ( pGlobalInfo != NULL )
        {
            InfoStruct.dwGlobalInfoSize     = dwGlobalInfoSize;
            InfoStruct.pGlobalInfo          = pGlobalInfo;
        }

        if ( pClientInterfaceInfo != NULL )
        {
            InfoStruct.dwInterfaceInfoSize  = dwClientInterfaceInfoSize;
            InfoStruct.pInterfaceInfo       = pClientInterfaceInfo;
        }

    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceTransportSetGlobalInfo(
                                    hMprServer,
                                    dwTransportId,
                                    &InfoStruct );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminTransportGetInfo
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from
//              RRouterInterfaceTransportGetGlobalInfo
//
// Description: This is the DLL entrypoint for
//              RouterInterfaceTransportGetGlobalInfo
//
DWORD APIENTRY
MprAdminTransportGetInfo(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwTransportId,
    OUT     LPBYTE *                ppGlobalInfo                    OPTIONAL,
    OUT     LPDWORD                 lpdwGlobalInfoSize              OPTIONAL,
    OUT     LPBYTE *                ppClientInterfaceInfo           OPTIONAL,
    OUT     LPDWORD                 lpdwClientInterfaceInfoSize     OPTIONAL
)
{
    DWORD                       dwRetCode;
    DIM_INTERFACE_CONTAINER     InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    if ( ( ppGlobalInfo == NULL ) && ( ppClientInterfaceInfo  == NULL ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Make sure that all pointers passed in are valid
    //

    try
    {
        if ( ppGlobalInfo != NULL )
        {
            *ppGlobalInfo = NULL;
            InfoStruct.fGetGlobalInfo = TRUE;
        }

        if ( ppClientInterfaceInfo != NULL )
        {
            *ppClientInterfaceInfo = NULL;
            InfoStruct.fGetInterfaceInfo = TRUE;
        }

    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceTransportGetGlobalInfo(
                                    hMprServer,
                                    dwTransportId,
                                    &InfoStruct );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    if ( dwRetCode == NO_ERROR )
    {
	    if ( InfoStruct.pGlobalInfo != NULL )
        {
            *ppGlobalInfo = (LPBYTE)(InfoStruct.pGlobalInfo);

            if ( lpdwGlobalInfoSize != NULL )
            {
                *lpdwGlobalInfoSize = InfoStruct.dwGlobalInfoSize;
            }
	    }

	    if ( InfoStruct.pInterfaceInfo != NULL )
        {
            *ppClientInterfaceInfo = (LPBYTE)(InfoStruct.pInterfaceInfo);

            if ( lpdwClientInterfaceInfoSize != NULL )
            {
                *lpdwClientInterfaceInfoSize = InfoStruct.dwInterfaceInfoSize;
            }
	    }
    }

    return( dwRetCode );
}

DWORD APIENTRY
MprAdminDeviceEnum(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    OUT     LPBYTE*                 lplpbBuffer,
    OUT     LPDWORD                 lpdwTotalEntries)
{
    DWORD                       dwRetCode;
    DIM_INFORMATION_CONTAINER   InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    if ( dwLevel != 0 )
    {   
        return ERROR_NOT_SUPPORTED;
    }
    
    //
    // Make sure that all pointers passed in are valid
    //

    try
    {
        *lplpbBuffer;
        *lpdwTotalEntries;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RRouterDeviceEnum(
                        hMprServer,
                        dwLevel,
                        &InfoStruct,
                        lpdwTotalEntries );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    if ( dwRetCode == NO_ERROR )
    {
        // Assign the return value
        //
        
        *lplpbBuffer = (LPBYTE)(InfoStruct.pBuffer);
    }

    return( dwRetCode );
}

//**
//
// Call:        MprAdminInterfaceCreate
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RRouterInterfaceCreate
//
// Description: This is the DLL entrypoint for RouterInterfaceCreate
//
DWORD APIENTRY
MprAdminInterfaceCreate(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer,
    OUT     HANDLE *                phInterface
)
{
    DWORD                       dwRetCode   = NO_ERROR, dwInterface = 0;
    DIM_INFORMATION_CONTAINER   InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    //
    // Make sure that all pointers passed in are valid
    //

    try
    {
        *phInterface = INVALID_HANDLE_VALUE;
        *lpbBuffer;

        //
        // Set up the interface information
        //
        dwRetCode = MprThunkInterface_HtoW(
                        dwLevel,
                        lpbBuffer,
                        &InfoStruct.pBuffer,
                        &InfoStruct.dwBufferSize);
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceCreate(
                                    hMprServer,
                                    dwLevel,
                                    &InfoStruct,
                                    &dwInterface );
        if (dwRetCode == NO_ERROR)
        {
            *phInterface = UlongToPtr(dwInterface);
        }

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    MprThunkInterfaceFree( InfoStruct.pBuffer, dwLevel );

    return( dwRetCode );
}

//
// Call:        MprAdminInterfaceGetInfo
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RRouterInterfaceGetInfo
//
// Description: This is the DLL entrypoint for RouterInterfaceGetInfo
//
DWORD APIENTRY
MprAdminInterfaceGetInfo(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwLevel,
    IN      LPBYTE *                lplpbBuffer
)
{
    DWORD                       dwRetCode;
    DIM_INFORMATION_CONTAINER   InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    //
    // Make sure that all pointers passed in are valid
    //

    try
    {
        *lplpbBuffer;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceGetInfo(
                                    hMprServer,
                                    dwLevel,
                                    &InfoStruct,
                                    PtrToUlong(hInterface) );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    if ( ( dwRetCode == NO_ERROR ) && ( InfoStruct.pBuffer != NULL ) )
    {
        dwRetCode = 
            MprThunkInterface_WtoH(
                dwLevel,
                InfoStruct.pBuffer,
                InfoStruct.dwBufferSize,
                1,
                MprAdminAlloc,
                MprAdminFree,
                lplpbBuffer);          
    }

    return( dwRetCode );
}

//**
//
// Call:        MprAdminInterfaceSetInfo
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RRouterInterfaceSetInfo
//
// Description: This is the DLL entrypoint for RouterInterfaceSetInfo
//
DWORD APIENTRY
MprAdminInterfaceSetInfo(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer
)
{
    DWORD                       dwRetCode;
    DIM_INFORMATION_CONTAINER   InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    //
    // Make sure that all pointers passed in are valid
    //

    try
    {
        *lpbBuffer;

        //
        // Set up the interface information
        //
        dwRetCode = MprThunkInterface_HtoW(
                        dwLevel,
                        lpbBuffer,
                        &InfoStruct.pBuffer,
                        &InfoStruct.dwBufferSize);

    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceSetInfo(
                                    hMprServer,
                                    dwLevel,
                                    &InfoStruct,
                                    PtrToUlong(hInterface) );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    MprThunkInterfaceFree( &InfoStruct.pBuffer, dwLevel );

    return( dwRetCode );
}

DWORD APIENTRY
MprAdminInterfaceDeviceGetInfo(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwIndex,
    IN      DWORD                   dwLevel,
    OUT     LPBYTE*                 lplpBuffer)
{
    DWORD                       dwRetCode = NO_ERROR;
    DIM_INFORMATION_CONTAINER   InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    if ( ( (int) dwLevel < 0 ) || ( dwLevel > 1 ) )
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Make sure that all pointers passed in are valid
    //

    try
    {
        *lplpBuffer;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    if (dwRetCode != NO_ERROR)
    {
        return ( dwRetCode );
    }

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceDeviceGetInfo(
                        hMprServer,
                        dwLevel,
                        &InfoStruct,
                        dwIndex,
                        PtrToUlong(hInterface) );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    // Process return values
    //
    if ( dwRetCode == NO_ERROR  )
    {
        // Fix any variable length structure pointers
        //
        switch ( dwLevel )
        {
            case 0:
                break;

            case 1:
                {
                    MPR_DEVICE_1* pDev1 = 
                        (MPR_DEVICE_1*)InfoStruct.pBuffer;

                    if ( ( InfoStruct.dwBufferSize != 0 ) &&
                         ( pDev1 != NULL )                && 
                         ( pDev1->szAlternates != NULL ) 
                       )
                    {
                        pDev1->szAlternates = (PWCHAR) (pDev1 + 1);
                    }
                }
                break;
        }

        // Assign the return value
        //
        if ( InfoStruct.dwBufferSize != 0 )
        {
            *lplpBuffer = InfoStruct.pBuffer;
        }            
    }        

    return( dwRetCode );
}

DWORD APIENTRY
MprAdminInterfaceDeviceSetInfo(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwIndex,
    IN      DWORD                   dwLevel,
    OUT     LPBYTE                  lpbBuffer)
{
    DWORD                       dwRetCode = NO_ERROR, dwAltSize = 0;
    DIM_INFORMATION_CONTAINER   InfoStruct;
    MPR_DEVICE_0*               pDev0 = (MPR_DEVICE_0*)lpbBuffer;
    MPR_DEVICE_1*               pDev1 = (MPR_DEVICE_1*)lpbBuffer;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    //
    // Make sure that all pointers passed in are valid
    //

    try
    {
        *lpbBuffer;

        //
        // Set up the interface information
        //
        switch ( dwLevel )
        {
            case 0:
                InfoStruct.dwBufferSize = sizeof(MPR_DEVICE_0);
                InfoStruct.pBuffer = (LPBYTE)pDev0;
                break;

            case 1:
                dwAltSize = MprUtilGetSizeOfMultiSz(pDev1->szAlternates);
                if ( pDev1->szAlternates == NULL ) 
                {
                    InfoStruct.dwBufferSize = sizeof(MPR_DEVICE_1);
                    InfoStruct.pBuffer = (LPBYTE)pDev1;
                    break;
                }

                InfoStruct.dwBufferSize = sizeof(MPR_DEVICE_1) + dwAltSize;
                InfoStruct.pBuffer = 
                    LocalAlloc(LPTR, InfoStruct.dwBufferSize);

                if ( InfoStruct.pBuffer == NULL )
                {
                    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                CopyMemory(
                    InfoStruct.pBuffer,
                    pDev1,
                    sizeof(MPR_DEVICE_1));

                ((MPR_DEVICE_1*)InfoStruct.pBuffer)->szAlternates = 
                    (PWCHAR) InfoStruct.pBuffer + sizeof(MPR_DEVICE_1);

                CopyMemory(
                    InfoStruct.pBuffer + sizeof(MPR_DEVICE_1),
                    pDev1->szAlternates,
                    dwAltSize);
                    
                break;

            default:
                dwRetCode = ERROR_NOT_SUPPORTED;
                break;
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    if (dwRetCode != NO_ERROR)
    {
        return ( dwRetCode );
    }

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceDeviceSetInfo(
                        hMprServer,
                        dwLevel,
                        &InfoStruct,
                        dwIndex,
                        PtrToUlong(hInterface) );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    if ( dwLevel == 1 )
    {
        if (InfoStruct.pBuffer == NULL)
        {
            LocalFree( InfoStruct.pBuffer );
        }
    }

    return( dwRetCode );
}


//**
//
// Call:        MprAdminInterfaceGetHandle
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RRouterInterfaceGetHandle
//
// Description: This is the DLL entrypoint for RouterInterfaceGetHandle
//
DWORD APIENTRY
MprAdminInterfaceGetHandle(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      LPWSTR                  lpwsInterfaceName,
    IN OUT  HANDLE *                phInterface,
    IN      BOOL                    fIncludeClientInterfaces
)
{
    DWORD dwRetCode, dwInterface = 0;

    //
    // Make sure that all pointers passed in are valid
    //

    try
    {
        *phInterface = INVALID_HANDLE_VALUE;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceGetHandle(
                                    hMprServer,
                                    lpwsInterfaceName,
                                    &dwInterface,
                                    (DWORD)fIncludeClientInterfaces );
        if (dwRetCode == NO_ERROR)
        {
            *phInterface = UlongToPtr(dwInterface);
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminInterfaceDelete
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RRouterInterfaceDelete
//
// Description: This is the DLL entrypoint for RouterInterfaceDelete
//
DWORD APIENTRY
MprAdminInterfaceDelete(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface
)
{
    DWORD   dwRetCode;

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceDelete(
                                     hMprServer,
                                     PtrToUlong(hInterface) );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminInterfaceTransportRemove
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RRouterInterfaceTransportRemove
//
// Description: This is the DLL entrypoint for RouterInterfaceTransportRemove
//
DWORD APIENTRY
MprAdminInterfaceTransportRemove(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwTransportId
)
{
    DWORD   dwRetCode;

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceTransportRemove(
                                     hMprServer,
                                     PtrToUlong(hInterface),
                                     dwTransportId );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	    MprAdminInterfaceEnum
//
// Returns:	    NO_ERROR	- success
//		        ERROR_INVALID_PARAMETER
//		        non-zero returns from RRouterInterfaceEnum
//
// Description: This is the DLL entry point for RouterInterfaceEnum.
//
DWORD APIENTRY
MprAdminInterfaceEnum(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    OUT     LPBYTE *                lplpbBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN      LPDWORD                 lpdwResumeHandle    OPTIONAL
)
{
    DWORD			            dwRetCode;
    DIM_INFORMATION_CONTAINER   InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    //
    // Touch all pointers
    //

    try
    {
	    *lplpbBuffer 	      = NULL;
	    *lpdwEntriesRead  = 0;
	    *lpdwTotalEntries = 0;

	    if ( lpdwResumeHandle )
        {
	        *lpdwResumeHandle;
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
	    dwRetCode = RRouterInterfaceEnum(
                            hMprServer,
                            dwLevel,
    					    &InfoStruct,
					        dwPrefMaxLen,
                            lpdwEntriesRead,
					        lpdwTotalEntries,
					        lpdwResumeHandle );

	    if ( InfoStruct.pBuffer != NULL)
        {
            dwRetCode = 
                MprThunkInterface_WtoH(
                    dwLevel,
                    InfoStruct.pBuffer,
                    InfoStruct.dwBufferSize,
                    *lpdwEntriesRead,
                    MprAdminAlloc,
                    MprAdminFree,
                    lplpbBuffer);          
	    }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
	    dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminInterfaceTransportGetInfo
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RRouterInterfaceTransportGetInfo
//
// Description: This is the DLL entrypoint for RouterInterfaceTransportGetInfo
//
DWORD APIENTRY
MprAdminInterfaceTransportGetInfo(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwTransportId,
    OUT     LPBYTE *                ppInterfaceInfo,
    OUT     LPDWORD                 lpdwInterfaceInfoSize
)
{
    DWORD                       dwRetCode;
    DIM_INTERFACE_CONTAINER     InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    if ( ppInterfaceInfo == NULL )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    //
    // Make sure that all pointers passed in are valid
    //

    try
    {
        if ( ppInterfaceInfo != NULL )
        {
            *ppInterfaceInfo = NULL;
            InfoStruct.fGetInterfaceInfo = TRUE;
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceTransportGetInfo(
                                    hMprServer,
                                    PtrToUlong(hInterface),
                                    dwTransportId,
                                    &InfoStruct );


    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    if ( dwRetCode == NO_ERROR )
    {
        *ppInterfaceInfo = (LPBYTE)(InfoStruct.pInterfaceInfo);

        if ( lpdwInterfaceInfoSize != NULL )
        {
            *lpdwInterfaceInfoSize = InfoStruct.dwInterfaceInfoSize;
        }
    }

    return( dwRetCode );
}

//**
//
// Call:        MprAdminInterfaceTransportAdd
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RRouterInterfaceTransportAdd
//
// Description: This is the DLL entrypoint for RouterInterfaceTransportAdd
//
DWORD APIENTRY
MprAdminInterfaceTransportAdd(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwTransportId,
    IN      LPBYTE                  pInterfaceInfo,
    IN      DWORD                   dwInterfaceInfoSize
)
{
    DWORD                       dwRetCode;
    DIM_INTERFACE_CONTAINER     InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    //
    // Make sure that all pointers passed in are valid
    //

    if ( pInterfaceInfo == NULL )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    try
    {
        if ( pInterfaceInfo != NULL )
        {
            InfoStruct.pInterfaceInfo       = pInterfaceInfo;
            InfoStruct.dwInterfaceInfoSize  = dwInterfaceInfoSize;
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceTransportAdd(
                                    hMprServer,
                                    PtrToUlong(hInterface),
                                    dwTransportId,
                                    &InfoStruct );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminInterfaceTransportSetInfo
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RRouterInterfaceTransportSetInfo
//
// Description: This is the DLL entrypoint for RouterInterfaceTransportSetInfo
//
DWORD APIENTRY
MprAdminInterfaceTransportSetInfo(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwTransportId,
    IN      LPBYTE                  pInterfaceInfo          OPTIONAL,
    IN      DWORD                   dwInterfaceInfoSize
)
{
    DWORD                       dwRetCode;
    DIM_INTERFACE_CONTAINER     InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    //
    // Make sure that all pointers passed in are valid
    //

    if ( pInterfaceInfo == NULL )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    try
    {
        if ( pInterfaceInfo != NULL )
        {
            InfoStruct.dwInterfaceInfoSize  = dwInterfaceInfoSize;
            InfoStruct.pInterfaceInfo       = pInterfaceInfo;
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceTransportSetInfo(
                                    hMprServer,
                                    PtrToUlong(hInterface),
                                    dwTransportId,
                                    &InfoStruct );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminInterfaceUpdateRoutes
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from
//
// Description: This is the DLL entrypoint for RouterInterfaceUpdateRoutes
//
//
DWORD APIENTRY
MprAdminInterfaceUpdateRoutes(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hDimInterface,
    IN      DWORD                   dwPid,
    IN      HANDLE                  hEvent
)
{
    DWORD                   dwRetCode;
    DWORD                   dwCurrentProcessId = GetCurrentProcessId();

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceUpdateRoutes(
                                    hMprServer,
                                    PtrToUlong(hDimInterface),
                                    dwPid,
                                    (ULONG_PTR) hEvent,
                                    dwCurrentProcessId );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminInterfaceQueryUpdateResult
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from
//
// Description: This is the DLL entrypoint for RouterInterfaceQueryUpdateResult
//
DWORD APIENTRY
MprAdminInterfaceQueryUpdateResult(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hDimInterface,
    IN      DWORD                   dwPid,
    OUT     LPDWORD                 lpdwUpdateResult
)
{
    DWORD                 dwRetCode;

    //
    // Make sure that all pointers passed in are valid
    //

    try
    {
        *lpdwUpdateResult = 0;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceQueryUpdateResult(
                                    hMprServer,
                                    PtrToUlong(hDimInterface),
                                    dwPid,
                                    lpdwUpdateResult );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminGetErrorString
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//
// Description: This is the DLL entrypoint for MprAdminGetErrorString
//
DWORD APIENTRY
MprAdminGetErrorString(
    IN      DWORD       dwError,
    OUT     LPWSTR *    lplpwsErrorString
)
{
    DWORD       dwRetCode       = NO_ERROR;
    DWORD       dwFlags         = FORMAT_MESSAGE_ALLOCATE_BUFFER;
    DWORD       dwBufferSize;
    HINSTANCE   hDll            = NULL;

    if ( ( ( dwError >= RASBASE ) && ( dwError <= RASBASEEND ) ) ||
         ( ( dwError >= ROUTEBASE ) && ( dwError <= ROUTEBASEEND ) ) )
    {
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
        hDll=LoadLibrary(TEXT("mprmsg.dll") );

        if ( hDll == NULL )
        {
            return( GetLastError() );
        }
    }
    else
    {
        dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }

    dwRetCode = FormatMessage(  dwFlags,
                                hDll,
                                dwError,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (LPWSTR)lplpwsErrorString,
                                0,
                                NULL );

    if ( hDll != NULL )
    {
        FreeLibrary( hDll );
    }

    if ( dwRetCode == 0 )
    {
        return( GetLastError() );
    }

    return( NO_ERROR );
}

//**
//
// Call:        MprAdminInterfaceConnect
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RRouterInterfaceConnect
//
// Description: This is the DLL entrypoint for RouterInterfaceConnect
//
DWORD APIENTRY
MprAdminInterfaceConnect(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hDimInterface,
    IN      HANDLE                  hEvent,
    IN      BOOL                    fBlocking
)
{
    DWORD                   dwRetCode;
    DWORD                   dwCurrentProcessId = GetCurrentProcessId();

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceConnect(
                                    hMprServer,
                                    PtrToUlong(hDimInterface),
                                    (ULONG_PTR)hEvent,
                                    (DWORD)fBlocking,
                                    dwCurrentProcessId );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminInterfaceDisconnect
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RRouterInterfaceDisconnect
//
// Description: This is the DLL entrypoint for RouterInterfaceDisconnect
//
DWORD APIENTRY
MprAdminInterfaceDisconnect(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hDimInterface
)
{
    DWORD                   dwRetCode;

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceDisconnect(
                                    hMprServer,
                                    PtrToUlong(hDimInterface) );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminInterfaceUpdatePhonebookInfo
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RRouterInterfaceUpdatePhonebookInfo
//
// Description: This is the DLL entrypoint for
//              RouterInterfaceUpdatePhonebookInfo
//
DWORD APIENTRY
MprAdminInterfaceUpdatePhonebookInfo(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hDimInterface
)
{
    DWORD                   dwRetCode;

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceUpdatePhonebookInfo(
                                    hMprServer,
                                    PtrToUlong(hDimInterface) );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

DWORD APIENTRY
MprAdminInterfaceSetCredentialsEx(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer)
{
    DWORD                       dwRetCode = NO_ERROR;
    DIM_INFORMATION_CONTAINER   InfoStruct;
    MPR_CREDENTIALSEXI* pCredsI = NULL;                            

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    //
    // Make sure that all pointers passed in are valid
    //

    try
    {
        *lpbBuffer;

        //
        // Set up the interface information
        //
        switch ( dwLevel )
        {
            case 0:
            {
                MPR_CREDENTIALSEX_0* pCredsEx0 =
                            (MPR_CREDENTIALSEX_0*)lpbBuffer;

                dwRetCode = MprThunkCredentials_HtoW(
                                dwLevel,
                                (PBYTE) pCredsEx0,
                                MprThunkAlloc,
                                &InfoStruct.dwBufferSize,
                                &InfoStruct.pBuffer);
                                            
                break;
            }
            case 1:
            case 2:
            {
                MPR_CREDENTIALSEX_1* pCredsEx1 =
                                (MPR_CREDENTIALSEX_1 *)lpbBuffer;
                                
                dwRetCode = MprThunkCredentials_HtoW(
                                    dwLevel,
                                    (PBYTE) pCredsEx1,
                                    MprThunkAlloc,
                                    &InfoStruct.dwBufferSize,
                                    &InfoStruct.pBuffer);

                break;
            }
            
            default:
                dwRetCode = ERROR_NOT_SUPPORTED;
                break;
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    if (dwRetCode != NO_ERROR)
    {
        return ( dwRetCode );
    }

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceSetCredentialsEx(
                        hMprServer,
                        dwLevel,
                        &InfoStruct,
                        PtrToUlong(hInterface) );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    if ( dwLevel == 0 )
    {
        if (InfoStruct.pBuffer == NULL)
        {
            ZeroMemory(InfoStruct.pBuffer, InfoStruct.dwBufferSize);
            MprThunkFree( InfoStruct.pBuffer );
        }
    }

    return( dwRetCode );
}

DWORD APIENTRY
MprAdminInterfaceGetCredentialsEx(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwLevel,
    IN      LPBYTE *                lplpbBuffer)
{
    DWORD                       dwRetCode;
    DIM_INFORMATION_CONTAINER   InfoStruct;

    ZeroMemory( &InfoStruct, sizeof( InfoStruct ) );

    if (    (dwLevel != 0)
        &&  (dwLevel != 1)
        &&  (dwLevel != 2))
    {
        return ERROR_NOT_SUPPORTED;
    }
    
    //
    // Make sure that all pointers passed in are valid
    //
    try
    {
        *lplpbBuffer;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RRouterInterfaceGetCredentialsEx(
                        hMprServer,
                        dwLevel,
                        &InfoStruct,
                        PtrToUlong(hInterface) );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    //
    // Assign the return value
    //
    if ( dwRetCode == NO_ERROR )
    {
        *lplpbBuffer = NULL;
        
        switch(dwLevel)
        {
            case 0:
            {
                MPR_CREDENTIALSEXI *pCredsI = (MPR_CREDENTIALSEXI *)
                                                InfoStruct.pBuffer;
                MPR_CREDENTIALSEX_0* pCred0 = NULL;

                dwRetCode = MprThunkCredentials_WtoH(
                                    dwLevel,
                                    pCredsI,
                                    MprAdminAlloc,
                                    (PBYTE *) &pCred0);
                                    
                if(NULL != InfoStruct.pBuffer)
                {
                    ZeroMemory(InfoStruct.pBuffer, InfoStruct.dwBufferSize);
                    MprAdminFree(InfoStruct.pBuffer);
                }

                *lplpbBuffer = (PBYTE) pCred0;

                break;
            }
            case 1:
            case 2:
            {
                MPR_CREDENTIALSEXI *pCredsI = (MPR_CREDENTIALSEXI *)
                                                InfoStruct.pBuffer;
                MPR_CREDENTIALSEX_1* pCred1 = NULL;

                dwRetCode = MprThunkCredentials_WtoH(
                                    dwLevel,
                                    pCredsI,
                                    MprAdminAlloc,
                                    (PBYTE *) &pCred1);

                if(NULL != InfoStruct.pBuffer)
                {
                    ZeroMemory(InfoStruct.pBuffer, InfoStruct.dwBufferSize);
                    MprAdminFree(InfoStruct.pBuffer);
                }

                *lplpbBuffer = (PBYTE) pCred1;

                break;
            }
        }
    }

    return( dwRetCode );
}

//**
//
// Call:        MprAdminRegisterConnectionNotification
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
MprAdminRegisterConnectionNotification(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hEventNotification
)
{
    DWORD dwRetCode;
    DWORD dwCurrentProcessId = GetCurrentProcessId();

    if ( ( hEventNotification == INVALID_HANDLE_VALUE ) ||
         ( hEventNotification == NULL ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RRasAdminConnectionNotification(
                                    hMprServer,
                                    TRUE,
                                    dwCurrentProcessId,
                                    (ULONG_PTR) hEventNotification );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );

}

//**
//
// Call:        MprAdminDeregisterConnectionNotification
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
MprAdminDeregisterConnectionNotification(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hEventNotification
)
{
    DWORD dwRetCode;

    if ( ( hEventNotification == INVALID_HANDLE_VALUE ) ||
         ( hEventNotification == NULL ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RRasAdminConnectionNotification(
                                    hMprServer,
                                    FALSE,
                                    0,
                                    (ULONG_PTR)hEventNotification );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//
// Call:        MprAdminMIBServerConnect
//
// Returns:     NO_ERROR - success
//              non-zero returns from the DimRPCBind routine.
//
//
// Description: This is the DLL entrypoint for MIBServerConnect
//
DWORD
MprAdminMIBServerConnect(
    IN  LPWSTR                  lpwsServerName,
    OUT MIB_SERVER_HANDLE *     phMIBServer
)
{
    //
    // Bind with the server
    //

    return( DimRPCBind( lpwsServerName, phMIBServer ) );

}

//**
//
// Call:        MprAdminMIBServerDisconnect
//
// Returns:     none.
//
// Description: This is the DLL entrypoint for MIBServerDisconnect
//
VOID
MprAdminMIBServerDisconnect(
    IN MIB_SERVER_HANDLE    hMIBServer
)
{
    RpcBindingFree( (handle_t *)&hMIBServer );
}

//**
//
// Call:        MprAdminMIBBufferFree
//
// Returns:     none
//
// Description: This is the DLL entrypoint for MIBBufferFree
//
DWORD
MprAdminMIBBufferFree(
    IN PVOID        pBuffer
)
{
    if ( pBuffer == NULL )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    MIDL_user_free( pBuffer );

    return( NO_ERROR );
}

//**
//
// Call:        MprAdminMIBEntryCreate
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RMIBEntryCreate
//
// Description: This is the DLL entrypoint for MIBEntryCreate
//
DWORD APIENTRY
MprAdminMIBEntryCreate(
    IN      MIB_SERVER_HANDLE       hMIBServer,
    IN      DWORD                   dwPid,
    IN      DWORD                   dwRoutingPid,
    IN      LPVOID                  lpEntry,
    IN      DWORD                   dwEntrySize
)
{
    DWORD                       dwRetCode;
    DIM_MIB_ENTRY_CONTAINER     InfoStruct;

    //
    // Make sure that all pointers passed in are valid
    //

    if ( lpEntry == NULL )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    try
    {
        InfoStruct.dwMibInEntrySize = dwEntrySize;

        InfoStruct.pMibInEntry  = lpEntry;

        InfoStruct.dwMibOutEntrySize = 0;
        InfoStruct.pMibOutEntry = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RMIBEntryCreate(hMIBServer,
                                    dwPid,
                                    dwRoutingPid,
                                    &InfoStruct );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminMIBEntryDelete
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RMIBEntryDelete
//
// Description: This is the DLL entrypoint for MIBEntryDelete
//
DWORD APIENTRY
MprAdminMIBEntryDelete(
    IN      MIB_SERVER_HANDLE       hMIBServer,
    IN      DWORD                   dwPid,
    IN      DWORD                   dwRoutingPid,
    IN      LPVOID                  lpEntry,
    IN      DWORD                   dwEntrySize
)
{
    DWORD                       dwRetCode;
    DIM_MIB_ENTRY_CONTAINER     InfoStruct;

    //
    // Make sure that all pointers passed in are valid
    //

    if ( lpEntry == NULL )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    try
    {
        InfoStruct.dwMibInEntrySize = dwEntrySize;

        InfoStruct.pMibInEntry = lpEntry;

        InfoStruct.dwMibOutEntrySize = 0;
        InfoStruct.pMibOutEntry      = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RMIBEntryDelete(hMIBServer,
                                    dwPid,
                                    dwRoutingPid,
                                    &InfoStruct );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminMIBEntrySet
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RMIBEntrySet
//
// Description: This is the DLL entrypoint for MIBEntrySet
//
DWORD APIENTRY
MprAdminMIBEntrySet(
    IN      MIB_SERVER_HANDLE       hMIBServer,
    IN      DWORD                   dwPid,
    IN      DWORD                   dwRoutingPid,
    IN      LPVOID                  lpEntry,
    IN      DWORD                   dwEntrySize
)
{
    DWORD                       dwRetCode;
    DIM_MIB_ENTRY_CONTAINER     InfoStruct;

    //
    // Make sure that all pointers passed in are valid
    //

    if ( lpEntry == NULL )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    try
    {
        InfoStruct.dwMibInEntrySize = dwEntrySize;

        InfoStruct.pMibInEntry = lpEntry;

        InfoStruct.dwMibOutEntrySize = 0;
        InfoStruct.pMibOutEntry      = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RMIBEntrySet(   hMIBServer,
                                    dwPid,
                                    dwRoutingPid,
                                    &InfoStruct );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminMIBEntryGet
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RMIBEntryGet
//
// Description: This is the DLL entrypoint for MIBEntryGet
//
DWORD APIENTRY
MprAdminMIBEntryGet(
    IN      MIB_SERVER_HANDLE       hMIBServer,
    IN      DWORD                   dwPid,
    IN      DWORD                   dwRoutingPid,
    IN      LPVOID                  lpInEntry,
    IN      DWORD                   dwInEntrySize,
    OUT     LPVOID *                lplpOutEntry,
    OUT     LPDWORD                 lpdwOutEntrySize
)
{
    DWORD                       dwRetCode;
    DIM_MIB_ENTRY_CONTAINER     InfoStruct;

    //
    // Make sure that all pointers passed in are valid
    //

    if ( lpInEntry == NULL )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    try
    {
        *lplpOutEntry     = NULL;
        *lpdwOutEntrySize = 0;

        InfoStruct.pMibInEntry = lpInEntry;
        InfoStruct.dwMibInEntrySize = dwInEntrySize;

        InfoStruct.dwMibOutEntrySize = 0;
        InfoStruct.pMibOutEntry      = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RMIBEntryGet(hMIBServer,
                                 dwPid,
                                 dwRoutingPid,
                                 &InfoStruct );

        if ( InfoStruct.pMibOutEntry != NULL )
        {
            *lplpOutEntry     = (LPVOID)(InfoStruct.pMibOutEntry);
            *lpdwOutEntrySize = InfoStruct.dwMibOutEntrySize;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminMIBEntryGetFirst
//
// Returns:     NO_ERROR    - success
//              ERROR_INVALID_PARAMETER
//              non-zero return codes from RMIBEntryGetFirst
//
// Description: This is the DLL entrypoint for MIBEntryGetFirst
//
DWORD APIENTRY
MprAdminMIBEntryGetFirst(
    IN      MIB_SERVER_HANDLE       hMIBServer,
    IN      DWORD                   dwPid,
    IN      DWORD                   dwRoutingPid,
    IN      LPVOID                  lpInEntry,
    IN      DWORD                   dwInEntrySize,
    OUT     LPVOID *                lplpOutEntry,
    OUT     LPDWORD                 lpdwOutEntrySize
)
{
    DWORD                       dwRetCode;
    DIM_MIB_ENTRY_CONTAINER     InfoStruct;

    //
    // Make sure that all pointers passed in are valid
    //

    if ( lpInEntry == NULL )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    try
    {
        *lplpOutEntry     = NULL;
        *lpdwOutEntrySize = 0;

        InfoStruct.pMibInEntry = lpInEntry;
        InfoStruct.dwMibInEntrySize = dwInEntrySize;

        InfoStruct.dwMibOutEntrySize = 0;
        InfoStruct.pMibOutEntry      = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RMIBEntryGetFirst(
                                hMIBServer,
                                dwPid,
                                dwRoutingPid,
                                &InfoStruct );

        if ( InfoStruct.pMibOutEntry != NULL )
        {
            *lplpOutEntry     = (LPVOID)(InfoStruct.pMibOutEntry);
            *lpdwOutEntrySize = InfoStruct.dwMibOutEntrySize;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminMIBEntryGetNext
//
// Returns:     NO_ERROR    - success
//              non-zero return codes from RMIBEntryGetNext
//
// Description: This is the DLL entrypoint for MIBEntryGetNext
//
DWORD APIENTRY
MprAdminMIBEntryGetNext(
    IN      MIB_SERVER_HANDLE       hMIBServer,
    IN      DWORD                   dwPid,
    IN      DWORD                   dwRoutingPid,
    IN      LPVOID                  lpInEntry,
    IN      DWORD                   dwInEntrySize,
    OUT     LPVOID *                lplpOutEntry,
    OUT     LPDWORD                 lpdwOutEntrySize
)
{
    DWORD                       dwRetCode;
    DIM_MIB_ENTRY_CONTAINER     InfoStruct;

    //
    // Make sure that all pointers passed in are valid
    //

    if ( lpInEntry == NULL )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    try
    {
        *lplpOutEntry     = NULL;
        *lpdwOutEntrySize = 0;

        InfoStruct.pMibInEntry = lpInEntry;
        InfoStruct.dwMibInEntrySize = dwInEntrySize;

        InfoStruct.pMibOutEntry      = NULL;
        InfoStruct.dwMibOutEntrySize = 0;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RMIBEntryGetNext(
                                hMIBServer,
                                dwPid,
                                dwRoutingPid,
                                &InfoStruct );

        if ( InfoStruct.pMibOutEntry != NULL )
        {
            *lplpOutEntry     = (LPVOID)(InfoStruct.pMibOutEntry);
            *lpdwOutEntrySize = InfoStruct.dwMibOutEntrySize;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminMIBGetTrapInfo
//
// Returns:     NO_ERROR    - success
//              non-zero return codes from RMIBGetTrapInfo
//
// Description: This is the DLL entrypoint for MIBGetTrapInfo
//
DWORD APIENTRY
MprAdminMIBGetTrapInfo(
    IN      MIB_SERVER_HANDLE       hMIBServer,
    IN      DWORD                   dwPid,
    IN      DWORD                   dwRoutingPid,
    IN      LPVOID                  lpInData,
    IN      DWORD                   dwInDataSize,
    OUT     LPVOID*                 lplpOutData,
    IN OUT  LPDWORD                 lpdwOutDataSize
)
{
    DWORD                       dwRetCode;
    DIM_MIB_ENTRY_CONTAINER     InfoStruct;

    //
    // Make sure that all pointers passed in are valid
    //

    if ( lpInData == NULL )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    try
    {
        *lplpOutData     = NULL;
        *lpdwOutDataSize = 0;

        InfoStruct.pMibInEntry = lpInData;
        InfoStruct.dwMibInEntrySize = dwInDataSize;

        InfoStruct.pMibOutEntry      = NULL;
        InfoStruct.dwMibOutEntrySize = 0;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RMIBGetTrapInfo(
                                hMIBServer,
                                dwPid,
                                dwRoutingPid,
                                &InfoStruct );

        if ( InfoStruct.pMibOutEntry != NULL )
        {
            *lplpOutData     = (LPVOID)(InfoStruct.pMibOutEntry);
            *lpdwOutDataSize = InfoStruct.dwMibOutEntrySize;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:        MprAdminMIBSetTrapInfo
//
// Returns:     NO_ERROR    - success
//              non-zero return codes from RMIBSetTrapInfo
//
// Description: This is the DLL entrypoint for MIBSetTrapInfo
//
DWORD APIENTRY
MprAdminMIBSetTrapInfo(
    IN      DWORD                   dwPid,
    IN      DWORD                   dwRoutingPid,
    IN      HANDLE                  hEvent,
    IN      LPVOID                  lpInData,
    IN      DWORD                   dwInDataSize,
    OUT     LPVOID*                 lplpOutData,
    IN OUT  LPDWORD                 lpdwOutDataSize
)
{
    DWORD                       dwRetCode;
    DIM_MIB_ENTRY_CONTAINER     InfoStruct;
    MIB_SERVER_HANDLE           hMIBServer;
    DWORD                       dwCurrentProcessId = GetCurrentProcessId();

    dwRetCode = MprAdminMIBServerConnect( NULL, &hMIBServer );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    if ( lpInData == NULL )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    //
    // Make sure that all pointers passed in are valid
    //

    try
    {
        *lplpOutData     = NULL;
        *lpdwOutDataSize = 0;

        InfoStruct.pMibInEntry = lpInData;
        InfoStruct.dwMibInEntrySize = dwInDataSize;

        InfoStruct.pMibOutEntry      = NULL;
        InfoStruct.dwMibOutEntrySize = 0;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	    return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept
    {
        dwRetCode = RMIBSetTrapInfo(
                                hMIBServer,
                                dwPid,
                                dwRoutingPid,
                                (ULONG_PTR) hEvent,
                                dwCurrentProcessId,
                                &InfoStruct );

        if ( InfoStruct.pMibOutEntry != NULL )
        {
            *lplpOutData     = (LPVOID)(InfoStruct.pMibOutEntry);
            *lpdwOutDataSize = InfoStruct.dwMibOutEntrySize;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    MprAdminMIBServerDisconnect( hMIBServer );

    return( dwRetCode );
}

DWORD APIENTRY
MprAdminConnectionEnum(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      DWORD                   dwLevel,
    OUT     LPBYTE *                lplpbBuffer,        // RAS_CONNECTION_0
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN      LPDWORD                 lpdwResumeHandle    OPTIONAL
)
{
    return( RasAdminConnectionEnum( hRasServer, dwLevel, lplpbBuffer,
                                    dwPrefMaxLen, lpdwEntriesRead,
                                    lpdwTotalEntries, lpdwResumeHandle ) );
}

DWORD APIENTRY
MprAdminPortEnum(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      DWORD                   dwLevel,
    IN      HANDLE                  hRasConnection,
    OUT     LPBYTE *                lplpbBuffer,        // RAS_PORT_0
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN      LPDWORD                 lpdwResumeHandle    OPTIONAL
)
{
    return( RasAdminPortEnum( hRasServer, dwLevel, hRasConnection, lplpbBuffer,
                              dwPrefMaxLen, lpdwEntriesRead, lpdwTotalEntries,
                              lpdwResumeHandle ) );
}

DWORD APIENTRY
MprAdminConnectionGetInfo(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      DWORD                   dwLevel,
    IN      HANDLE                  hRasConnection,
    OUT     LPBYTE *                lplpbBuffer
)
{
    return( RasAdminConnectionGetInfo( hRasServer, dwLevel, hRasConnection,
                                       lplpbBuffer ) );
}

DWORD APIENTRY
MprAdminPortGetInfo(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      DWORD                   dwLevel,
    IN      HANDLE                  hPort,
    OUT     LPBYTE *                lplpbBuffer
)
{
    return( RasAdminPortGetInfo( hRasServer, dwLevel, hPort, lplpbBuffer ) );
}

DWORD APIENTRY
MprAdminConnectionClearStats(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      HANDLE                  hRasConnection
)
{
    return( RasAdminConnectionClearStats( hRasServer, hRasConnection ) );
}

DWORD APIENTRY
MprAdminPortClearStats(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      HANDLE                  hPort
)
{
    return( RasAdminPortClearStats( hRasServer, hPort ) );
}

DWORD APIENTRY
MprAdminPortReset(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      HANDLE                  hPort
)
{
    return( RasAdminPortReset( hRasServer, hPort ) );
}

DWORD APIENTRY
MprAdminPortDisconnect(
    IN      RAS_SERVER_HANDLE       hRasServer,
    IN      HANDLE                  hPort
)
{
    return( RasAdminPortDisconnect( hRasServer, hPort ) );
}

DWORD APIENTRY
MprAdminInterfaceSetCredentials(
    IN      LPWSTR                  lpwsServer              OPTIONAL,
    IN      LPWSTR                  lpwsInterfaceName,
    IN      LPWSTR                  lpwsUserName            OPTIONAL,
    IN      LPWSTR                  lpwsDomainName          OPTIONAL,
    IN      LPWSTR                  lpwsPassword            OPTIONAL
)
{
    return 
        MprAdminInterfaceSetCredentialsInternal(
            lpwsServer,
            lpwsInterfaceName,
            lpwsUserName,
            lpwsDomainName,
            lpwsPassword);
}

DWORD APIENTRY
MprAdminInterfaceGetCredentials(
    IN      LPWSTR                  lpwsServer              OPTIONAL,
    IN      LPWSTR                  lpwsInterfaceName,
    IN      LPWSTR                  lpwsUserName            OPTIONAL,
    IN      LPWSTR                  lpwsPassword            OPTIONAL,
    IN      LPWSTR                  lpwsDomainName          OPTIONAL
)
{
    DWORD dwErr;

    dwErr = 
        MprAdminInterfaceGetCredentialsInternal(
            lpwsServer,
            lpwsInterfaceName,
            lpwsUserName,
            NULL,
            lpwsDomainName);

    if (dwErr == NO_ERROR)
    {
        if (lpwsPassword != NULL)
        {
            wcscpy(lpwsPassword, L"****************");
        }
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\compress.c ===
/******************************************************************\
*                     Microsoft Windows NT                         *
*               Copyright(c) Microsoft Corp., 1992                 *
\******************************************************************/

/*++

Filename:    COMPRESS.C

Description: Contains procedures to compress and decompress phone
             numbers stored in the user parms field in the UAS.

Note:
             The routines were originally developed to operate on
             Multi-byte strings.  A Unicode wrapper using wcstombs()
             and mbstowcs() functions was written around the original
             functions and so you see the malloc() and free() usage
             as well.  Both these routines should be rewritten to be
             native Unicode routines when time permits.

History:
   July 1,1991.    NarenG      Created original version.
   July 6,1992.    RamC        Ported to NT - removed several
                               header file includes and changed
                               memsetf to memset & strchrf to strchr
   June 4,1996.   RamC         Allow any alphanumeric character to be
                               specified in the Callback phone number.
--*/

#include <windows.h>
#include <string.h>
#include <lm.h>
#include <stdlib.h>
#include <memory.h>
#include <mprapi.h>
#include <usrparms.h>   // UP_LEN_DIAL
#include <raserror.h>
#include <rasman.h>
#include <rasppp.h>
#include <compress.h>

// some convenient defines

static CHAR * CompressMap = "() tTpPwW,-@*#";

#define UNPACKED_DIGIT     100
#define COMPRESS_MAP_BEGIN 110
#define COMPRESS_MAP_END   (COMPRESS_MAP_BEGIN + strlen(CompressMap))
#define UNPACKED_OTHER     (COMPRESS_MAP_END + 1)



USHORT
WINAPI
CompressPhoneNumber(
   IN  LPWSTR UncompNumber,
   OUT LPWSTR CompNumber
   )

/*

Routine Description:

    Will compress a phone number so that it may fit in the
    userparms field.


Arguments

    UncompNumber -  Pointer to the phone number that
                    will be compressed.

    CompNumber   -  Pointer to a buffer that is at least as long
                    as the Uncompressed number. On return
                    this will contain the compressed
                    phone number.

Return Value:

    0 if successful

    One of the following error codes otherwise:

        ERROR_BAD_CALLBACK_NUMBER - failure, if the Uncompressed number
                                   has invalid chars.
        ERROR_BAD_LENGTH         - failure, if the compressed
                                   phone number will not fit
                                  in the userparms field.

Algortithm Used:

    An attempt is made to fit the given string in half the number of
    bytes by packing two adjacent numbers (in the phone number) in
    one byte.  For example if the phone number is "8611824", instead
    of storing it in 8 bytes (including the trailing NULL), it is
    stored in 4 bytes.  '0' is special case because it cannot be a
    byte by itself - will be interpreted as the terminating NULL.
    So, if two zeros appear next to each other as in "96001234", the
    two zeros are stored as the value 100.  Also the special characters
    which are allowed in the phone number string -  "() tTpPwW,-@*#"
    are stored as 110 + the index position in the above string. So,
    the '(' character would be stored as 110 (110+0) and the letter
    't' as 113 (110+3).
*/

{
CHAR *  Uncompressed;
CHAR *  Compressed;
CHAR *  UncompressedPtr;
CHAR *  CompressedPtr;
CHAR *  CharPtr;
USHORT  Packed;        // Indicates if the current byte is in the
                       // process of being paired.

    if(!(Uncompressed = calloc(1, MAX_PHONE_NUMBER_LEN+1))) {
       return(ERROR_NOT_ENOUGH_MEMORY);
    }
    if(!(Compressed = calloc(1, MAX_PHONE_NUMBER_LEN+1))) {
       return(ERROR_NOT_ENOUGH_MEMORY);
    }
    CompressedPtr   = Compressed;
    UncompressedPtr = Uncompressed;

    // convert unicode string to multi byte string for compression

    wcstombs(Uncompressed, UncompNumber, MAX_PHONE_NUMBER_LEN);


    for( Packed = 0; *Uncompressed; Uncompressed++ ) {

        switch( *Uncompressed ) {

            case '0':

                if ( Packed ){

                    // Put zero as the second paired digit

                    if ( *Compressed ) {
                        *Compressed =  (UCHAR)(*Compressed * 10);
                        Compressed++;
                        Packed = 0;
                    }

                    // We have a zero, we cant put a second zero or that
                    // will be a null byte. So, we store the value
                    // UNPACKED_DIGIT to fake this.

                    else {

                    *Compressed = UNPACKED_DIGIT;
                    *(++Compressed) = 0;
                    Packed = 1;
                    }
                }
                else {
                    *Compressed = 0;
                    Packed = 1;
                }

                break;

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':

                // If this is the second digit that is going to be
                // packed into one byte

                if ( Packed ) {
                    *Compressed = (UCHAR)((*Compressed*10)+(*Uncompressed-'0'));
                    // we need to special case number 32 which maps to a blank
                    if(*Compressed == ' ' )
                        *Compressed = COMPRESS_MAP_END;
                    Compressed++;
                    Packed = 0;
                }
                else {

                    *Compressed += ( *Uncompressed - '0' );
                    Packed = 1;

                }

                break;

            case '(':
            case ')':
            case ' ':
            case 't':
            case 'T':
            case 'p':
            case 'P':
            case 'w':
            case 'W':
            case ',':
            case '-':
            case '@':
            case '*':
            case '#':

                // if the byte was packed then we unpack it

                if ( Packed ) {
                    *Compressed += UNPACKED_DIGIT;
                    ++Compressed;
                    Packed = 0;
                }

                if ((CharPtr=strchr(CompressMap, *Uncompressed)) == NULL) {
                    free(UncompressedPtr);
                    free(CompressedPtr);
                    return( ERROR_BAD_CALLBACK_NUMBER );
                }

                *Compressed = (UCHAR)(COMPRESS_MAP_BEGIN+
                                     (UCHAR)(CharPtr-CompressMap));
                Compressed++;
                break;

            default:

                // if the chracter is none of the above specially recognized 
                // characters then copy the value + UNPACKED_OTHER to make it 
                // possible to decompress at the other end. [ 6/4/96 RamC ]

                if ( Packed) {
                   *Compressed += UNPACKED_DIGIT;
                   ++Compressed;
                   Packed = 0;
                }
                *Compressed = *Uncompressed + UNPACKED_OTHER;
                Compressed++;
        }

    }

    free(UncompressedPtr);

    // If we are in the middle of packing something
    // then we unpack it

    if ( Packed )
        *Compressed += UNPACKED_DIGIT;

    // Check if it will fit in the userparms field or not

    if ( strlen( CompressedPtr ) > UP_LEN_DIAL ) {
        free(CompressedPtr);
        return( ERROR_BAD_LENGTH );
    }

    // convert to unicode string before returning

    mbstowcs(CompNumber, CompressedPtr, MAX_PHONE_NUMBER_LEN);

    free(CompressedPtr);

    return(0);

}


USHORT
DecompressPhoneNumber(
  IN  LPWSTR CompNumber,
  OUT LPWSTR DecompNumber
  )

/*++


Routine Description:

    Will decompress a phone number.

Arguments:

    CompNumber        - Pointer to a compressed phone number.
    DecompNumber      - Pointer to a buffer that is large enough to
                        hold the Decompressed number.

Return Value:

    0 on success

    ERROR_BAD_CALLBACK_NUMBER - failure, if the Compressed number
                               contains unrecognizable chars.

Algortithm Used:

    We just do the opposite of the algorithm used in CompressPhoneNumber.

--*/

{
CHAR * Decompressed;
CHAR * Compressed;
CHAR * DecompressedPtr;
CHAR * CompressedPtr;


    if(!(Decompressed = calloc(1, MAX_PHONE_NUMBER_LEN+1))) {
       return(ERROR_NOT_ENOUGH_MEMORY);
    }
    if(!(Compressed = calloc(1, MAX_PHONE_NUMBER_LEN+1))) {
       return(ERROR_NOT_ENOUGH_MEMORY);
    }
    DecompressedPtr = Decompressed;
    CompressedPtr   = Compressed;

    // convert unicode string to multi byte string for decompression

    wcstombs(Compressed, CompNumber, MAX_PHONE_NUMBER_LEN+1);

    for(; *Compressed; Compressed++, Decompressed++ ) {

        // If this byte is packed then we unpack it

        if ( (UINT)*Compressed < UNPACKED_DIGIT ) {
            *Decompressed = (UCHAR)(((*Compressed) / 10) + '0' );
            *(++Decompressed) = (UCHAR)( ((*Compressed) % 10) + '0' );
            continue;
        }

        // we need to special case number 32 which maps to a blank

        if ( (UINT)*Compressed == COMPRESS_MAP_END ) {
            *Decompressed = (UCHAR) '3';
            *(++Decompressed) = (UCHAR)'2';
            continue;
        }

        // the number is an unpacked digit

        if ( (UINT)*Compressed < COMPRESS_MAP_BEGIN ) {
            *Decompressed = (UCHAR)((*Compressed -(UCHAR)UNPACKED_DIGIT ) +
                            '0' );
            continue;
        }

        // Otherwise the byte was not packed

        if ( (UINT)*Compressed < UNPACKED_OTHER ) {
            *Decompressed = CompressMap[(*Compressed -
                                        (UCHAR)COMPRESS_MAP_BEGIN)];
            continue;
        }

        // otherwise the byte is an unpacked character  [ 6/4/96 RamC ]

        *Decompressed = *Compressed - UNPACKED_OTHER;
    }

    // convert to unicode string before returning

    mbstowcs(DecompNumber, DecompressedPtr, MAX_PHONE_NUMBER_LEN+1);

    free(DecompressedPtr);
    free(CompressedPtr);
    return( 0 );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\compress.h ===
/******************************************************************\
*                     Microsoft Windows NT                         *
*               Copyright(c) Microsoft Corp., 1992                 *
\******************************************************************/

/*
 *
 * Filename:	USRUTIL.H
 *
 * Description:	Contains the function prototypes for all RASADMIN API
 *              utility routines.
 *
 * History:     Janakiram Cherala (ramc)   7/6/92  
 *
 */

USHORT
WINAPI
CompressPhoneNumber( 
    IN  LPWSTR Uncompressed, 
    OUT LPWSTR Compressed 
    );

USHORT
DecompressPhoneNumber( 
    IN  LPWSTR Compressed, 
    OUT LPWSTR Decompressed 
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\dsrights.c ===
/*
    File:   dsrights.c

    Implements the mechanisms needed to grant ras servers the 
    rights in the DS that they need to operate.

    Paul Mayfield, 4/13/98
*/

#include "dsrights.h"
#include <mprapip.h>
#include <rtutils.h>

//
// The character that delimits machine names from domain 
// names.
//
static const WCHAR pszMachineDelimeter[]    = L"\\";

CRITICAL_SECTION DsrLock;
DWORD g_dwTraceId = 0;
DWORD g_dwTraceCount = 0;

//
// Initializes the trace mechanism
//
DWORD 
DsrTraceInit()
{
    EnterCriticalSection(&DsrLock);

    if (g_dwTraceCount == 0)
    {
        g_dwTraceId = TraceRegisterA("MprDomain");
    }

    g_dwTraceCount++;

    LeaveCriticalSection(&DsrLock);

    return NO_ERROR;
}

//
// Cleans up the trace mechansim
//
DWORD 
DsrTraceCleanup()
{
    EnterCriticalSection(&DsrLock);

    if (g_dwTraceCount != 0)
    {
        g_dwTraceCount--;

        if (g_dwTraceCount == 0)
        {
            TraceDeregisterA(g_dwTraceId);
        }
    }        

    LeaveCriticalSection(&DsrLock);

    return NO_ERROR;
}

//
// Sends debug trace and returns the given error
//
DWORD DsrTraceEx (
        IN DWORD dwErr, 
        IN LPSTR pszTrace, 
        IN ...) 
{
    va_list arglist;
    char szBuffer[1024], szTemp[1024];

    va_start(arglist, pszTrace);
    vsprintf(szTemp, pszTrace, arglist);
    va_end(arglist);

    sprintf(szBuffer, "Dsr: %s", szTemp);

    TracePrintfA(g_dwTraceId, szBuffer);

    return dwErr;
}

//
// Allocates memory for use with dsr functions
//
PVOID DsrAlloc(DWORD dwSize, BOOL bZero) {
    return GlobalAlloc (bZero ? GPTR : GMEM_FIXED, dwSize);
}

// 
// Free memory used by dsr functions
//
DWORD DsrFree(PVOID pvBuf) {
    GlobalFree(pvBuf);
    return NO_ERROR;
}    

// 
// Initializes the dcr library
//
DWORD 
DsrInit (
    OUT  DSRINFO * pDsrInfo,
    IN  PWCHAR pszMachineDomain,
    IN  PWCHAR pszMachine,
    IN  PWCHAR pszGroupDomain)
{
    DWORD dwErr, dwSize;
    HRESULT hr;
    WCHAR pszBuf[1024];

    // Validate parameters
    if (pDsrInfo == NULL)
        return ERROR_INVALID_PARAMETER;
    ZeroMemory(pDsrInfo, sizeof(DSRINFO));
    
    // Initialize Com
	hr = CoInitialize(NULL);
	if (FAILED (hr)) {
       	return DsrTraceEx(
       	        hr, 
       	        "DsrInit: %x from CoInitialize", 
       	        hr);
    }       	        
    
    // Generate the Group DN
    dwErr = DsrFindRasServersGroup(
                pszGroupDomain,
                &(pDsrInfo->pszGroupDN));
    if (dwErr != NO_ERROR)
        return dwErr;

    // Generate the Machine DN
    dwErr = DsrFindDomainComputer(
                pszMachineDomain,
                pszMachine,
                &(pDsrInfo->pszMachineDN));
    if (dwErr != NO_ERROR)
        return dwErr;
    
    return NO_ERROR;
}

// 
// Cleans up the dsr library
//
DWORD 
DsrCleanup (DSRINFO * pDsrInfo) 
{
    if (pDsrInfo) {
        DSR_FREE (pDsrInfo->pszGroupDN);
        DSR_FREE (pDsrInfo->pszMachineDN);
    }

    CoUninitialize();
        
    return NO_ERROR;
}

// 
// Establishes the given machine as being 
// or not being a ras server in the domain.
//
// Parameters:
//      pszMachine      Name of the machine
//      bEnable         Whether it should or 
//                      shouldn't be a ras server
//
DWORD DsrEstablishComputerAsDomainRasServer (
        IN PWCHAR pszDomain,
        IN PWCHAR pszMachine,
        IN BOOL bEnable) 
{
    DSRINFO DsrInfo, *pDsrInfo = &DsrInfo;
    PWCHAR pszMachineDomain = NULL;
    DWORD dwErr = NO_ERROR;

    DsrTraceEx(
        0, 
        "DsrEstablish...: entered: %S, %S, %x", 
        pszDomain,
        pszMachine, 
        bEnable);

    // Parse out the machine's domain.
    pszMachineDomain = pszMachine;
    pszMachine = wcsstr(pszMachine, pszMachineDelimeter);
    if (pszMachine == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }
    *pszMachine = (WCHAR)0;
    pszMachine++;
    
    do
    {
        // Intialize the Dsr library
        dwErr = DsrInit(
                    pDsrInfo, 
                    pszMachineDomain, 
                    pszMachine,
                    pszDomain);
        if (dwErr != NO_ERROR) 
        {
           	DsrTraceEx(dwErr, "DsrEstablish...: %x from DsrInit", dwErr);
           	break;
        }           	            

        // Attempt to add the machine from the "Computers" 
        // container
        dwErr = DsrGroupAddRemoveMember(
                    pDsrInfo->pszGroupDN, 
                    pDsrInfo->pszMachineDN, 
                    bEnable);
        if (dwErr == ERROR_ALREADY_EXISTS)                   
        {
            dwErr = NO_ERROR;
        }
        if (dwErr != NO_ERROR)
        {
            DsrTraceEx(dwErr, "DsrEstablish...: %x from Add/Rem", dwErr);
            break;
        }

    } while (FALSE);

    // Cleanup
    {
        DsrCleanup (pDsrInfo);
    }

    return dwErr;
}

//
// Returns whether the given machine is a member of the remote
// access servers group.
//
DWORD 
DsrIsMachineRasServerInDomain(
    IN  PWCHAR pszDomain,
    IN  PWCHAR pszMachine, 
    OUT PBOOL  pbIsRasServer) 
{
    DSRINFO DsrInfo, *pDsrInfo = &DsrInfo;
    PWCHAR pszMachineDomain = NULL;
    DWORD dwErr = NO_ERROR;

    DsrTraceEx(0, "DsrIsRasServerInDomain: entered: %S", pszMachine);
    
    // Parse out the machine's domain.
    pszMachineDomain = pszMachine;
    pszMachine = wcsstr(pszMachine, pszMachineDelimeter);
    if (pszMachine == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }
    *pszMachine = (WCHAR)0;
    pszMachine++;
    
    do
    {
        // Intialize the Dsr library
        dwErr = DsrInit(
                    pDsrInfo, 
                    pszMachineDomain, 
                    pszMachine,
                    pszDomain);
        if (dwErr != NO_ERROR) 
        {
            DsrTraceEx(dwErr, "DsrIsRasSvrInDom: %x from DsrInit", dwErr);
            break;
        }                    

        // Find out whether the machine is a member of the group
        dwErr = DsrGroupIsMember(
                    pDsrInfo->pszGroupDN, 
                    pDsrInfo->pszMachineDN, 
                    pbIsRasServer);
        if (dwErr != NO_ERROR) 
        {
            DsrTraceEx(dwErr, "DsrIsRasSrvInDom: %x from IsMemrGrp", dwErr);
            break;
        }
        
    } while (FALSE);

    // Cleanup
    {
        DsrCleanup (pDsrInfo);
    }

    return NO_ERROR;
}

//
// Prepares parameters for the DSR functions.  pszDomainComputer
// will be in form <domain>/computer.  pszDomain will point to a 
// valid domain.
//
DWORD 
GenerateDsrParameters(
    IN  PWCHAR pszDomain,
    IN  PWCHAR pszMachine,
    OUT PWCHAR *ppszDomainComputer,
    OUT PWCHAR *ppszGroupDomain)
{
    DWORD dwLen, dwErr = NO_ERROR;
    PWCHAR pszSlash = NULL;
    PDOMAIN_CONTROLLER_INFO pInfo = NULL;
    WCHAR pszTemp[MAX_COMPUTERNAME_LENGTH + 1];
    
    // Initailize
    *ppszDomainComputer = pszMachine;
    *ppszGroupDomain = pszDomain;

    do {
        // Lookup the current domain if none was specifed
        if ((pszDomain == NULL) || (wcslen(pszDomain) == 0)) {
            dwErr = DsGetDcName(
                        NULL, 
                        NULL,
                        NULL,
                        NULL,
                        DS_DIRECTORY_SERVICE_REQUIRED,
                        &pInfo);
            if (dwErr != NO_ERROR)
                break;

            // Copy the given domain name
            dwLen = wcslen(pInfo->DomainName) + 1;
            dwLen *= sizeof (WCHAR);
            *ppszGroupDomain = (PWCHAR) DsrAlloc(dwLen, FALSE);
            if (*ppszGroupDomain == NULL) {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            wcscpy(*ppszGroupDomain, pInfo->DomainName);
        }

        // Make sure that the machine name is in the form
        // domain/computer
        if (pszMachine)
            pszSlash = wcsstr(pszMachine, pszMachineDelimeter);
        if (!pszMachine || !pszSlash) {
            // Get the domain name if it isn't already 
            // gotten
            if (!pInfo) {
                dwErr = DsGetDcName(
                            NULL, 
                            NULL,
                            NULL,
                            NULL,
                            DS_DIRECTORY_SERVICE_REQUIRED,
                            &pInfo);
                if (dwErr != NO_ERROR)
                    break;
            }

            // Get the local computer name if no computer
            // name was specified
            if ((!pszMachine) || (wcslen(pszMachine) == 0)) {
                dwLen = sizeof(pszTemp) / sizeof(WCHAR);
                if (! GetComputerName(pszTemp, &dwLen)) {
                    dwErr = GetLastError();
                    break;
                }
                pszMachine = pszTemp;
            }

            // Allocate the buffer to return the computer name
            dwLen = wcslen(pInfo->DomainName) + wcslen(pszMachine) + 2;
            dwLen *= sizeof(WCHAR);
            *ppszDomainComputer = (PWCHAR) DsrAlloc(dwLen, FALSE);
            if (*ppszDomainComputer == NULL) {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            wsprintfW(
                *ppszDomainComputer, 
                L"%s%s%s", 
                pInfo->DomainName, 
                pszMachineDelimeter,
                pszMachine);
        }
        
    } while (FALSE);

    // Cleanup
    {
        if (pInfo)
            NetApiBufferFree(pInfo);
    }

    return dwErr;
}

//
// Establishes the given computer as a server in the domain.
// This function must be run under the context of a domain
// admin.
//
DWORD 
WINAPI 
MprAdminEstablishDomainRasServer (
    IN PWCHAR pszDomain,
    IN PWCHAR pszMachine,
    IN BOOL bEnable)
{
    return MprDomainRegisterRasServer(
                pszDomain,
                pszMachine,
                bEnable);
}

DWORD 
WINAPI 
MprAdminIsDomainRasServer (
    IN  PWCHAR pszDomain,
    IN  PWCHAR pszMachine,
    OUT PBOOL pbIsRasServer)
{
    return MprDomainQueryRasServer(
                pszDomain,
                pszMachine,
                pbIsRasServer);
}

//
// Establishes the given computer as a server in the domain.
// This function must be run under the context of a domain
// admin.
//
DWORD 
WINAPI 
MprDomainRegisterRasServer (
    IN PWCHAR pszDomain,
    IN PWCHAR pszMachine,
    IN BOOL bEnable)
{
    PWCHAR pszDomainComputer, pszGroupDomain;
    DWORD dwErr;

    do
    {
        DsrTraceInit();
        
        // Generate the parameters formatted so that
        // the dsr functions will accept them.
        dwErr = GenerateDsrParameters(
            pszDomain,
            pszMachine,
            &pszDomainComputer,
            &pszGroupDomain);
        if (dwErr != NO_ERROR)
        {
            break;
        }
            
        dwErr = DsrEstablishComputerAsDomainRasServer (
                    pszGroupDomain,
                    pszDomainComputer, 
                    bEnable);

    } while (FALSE);                    

    // Cleanup
    {
        if ((pszDomainComputer) && 
            (pszDomainComputer != pszMachine))
        {
            DsrFree(pszDomainComputer);
        }
        if ((pszGroupDomain) &&
            (pszGroupDomain != pszDomain))
        {            
            DsrFree(pszGroupDomain);
        }            

        DsrTraceCleanup();
    }

    return dwErr;
}

//
// Determines whether the given machine is an authorized ras
// server in the domain
//
DWORD 
WINAPI 
MprDomainQueryRasServer (
    IN  PWCHAR pszDomain,
    IN  PWCHAR pszMachine,
    OUT PBOOL pbIsRasServer)
{
    PWCHAR pszDomainComputer, pszGroupDomain;
    DWORD dwErr;

    do
    {
        DsrTraceInit();
    
        // Generate the parameters formatted so that
        // the dsr functions will accept them.
        dwErr = GenerateDsrParameters(
            pszDomain,
            pszMachine,
            &pszDomainComputer,
            &pszGroupDomain);
        if (dwErr != NO_ERROR)
        {
            break;
        }
        
        // Check the group membership
        dwErr = DsrIsMachineRasServerInDomain(
                    pszGroupDomain,
                    pszDomainComputer, 
                    pbIsRasServer);
                    
    } while (FALSE);                    

    // Cleanup
    {
        if ((pszDomainComputer) && 
            (pszDomainComputer != pszMachine))
        {
            DsrFree(pszDomainComputer);
        }
        if ((pszGroupDomain) &&
            (pszGroupDomain != pszDomain))
        {            
            DsrFree(pszGroupDomain);
        }            

        DsrTraceCleanup();
    }

    return dwErr;
}

//
// Enables NT4 Servers in the given domain
//
DWORD
WINAPI
MprDomainSetAccess(
    IN PWCHAR pszDomain,
    IN DWORD dwAccessFlags)
{
    DWORD dwErr;

    DsrTraceInit();
    
    dwErr = DsrDomainSetAccess(pszDomain, dwAccessFlags);

    DsrTraceCleanup();

    return dwErr;
}

//
// Discovers whether NT4 Servers in the given domain
// are enabled.
//
DWORD
WINAPI
MprDomainQueryAccess(
    IN PWCHAR pszDomain,
    IN LPDWORD lpdwAccessFlags)
{
    DWORD dwErr;

    DsrTraceInit();
    
    dwErr = DsrDomainQueryAccess(pszDomain, lpdwAccessFlags);

    DsrTraceCleanup();

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\guidmap.h ===
/*
	File	GuidMap.h

	Defines functions to map guid instances to descriptive names.  This 
	file will become obsolete when such Mike Miller adds this functionality
	to netcfg.

	Paul Mayfield, 8/25/97

	Copyright 1997, Microsoft Corporation.
*/	

#ifndef __guidmap_h
#define __guidmap_h

//
// Initialize the guid map for the given server
//
DWORD 
GuidMapInit ( 
    IN PWCHAR pszServer,
    OUT HANDLE * phGuidMap);

//
// Cleans up resources obtained through GuidMapInit
//
DWORD 
GuidMapCleanup ( 
    IN  HANDLE  hGuidMap,
    IN  BOOL    bFree
    );

//
// Derive the friendly name from the guid name
//
DWORD 
GuidMapGetFriendlyName ( 
    IN SERVERCB* pserver,
    IN PWCHAR pszGuidName, 
    IN DWORD dwBufferSize,
    OUT PWCHAR pszFriendlyName);

//
// Derive the guid name from the friendly name
//
DWORD 
GuidMapGetGuidName( 
    IN SERVERCB* pserver,
    IN PWCHAR pszFriendlyName, 
    IN DWORD dwBufferSize,
    OUT PWCHAR pszGuidName );

//
// States whether a mapping for the given guid name
// exists without actually providing the friendly
// name.  This is more efficient than GuidMapGetFriendlyName 
// when the friendly name is not required.
//
DWORD 
GuidMapIsAdapterInstalled(
    IN  HANDLE hGuidMap,
    IN  PWCHAR pszGuidName,
    OUT PBOOL  pfMappingExists);
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\guidmap.c ===
/*
	File	GuidMap.c

	Defines interface to map a guid interface name to an unique descriptive
	name describing that interface and vice versa.

	Paul Mayfield, 8/25/97

	Copyright 1997, Microsoft Corporation.
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>

#include <netcfgx.h>
#include <netcon.h>

#include "rtcfg.h"
#include "guidmap.h"
#include "enumlan.h"
#include "hashtab.h"

#define GUIDMAP_HASH_SIZE            101
#define GUIDMAP_FUNCTION_MAPFRIENDLY 0x1
#define GUIDMAP_FUNCTION_MAPGUID     0x2

//
// Structure defines the control block for a guid map
//
typedef struct _GUIDMAPCB
{
    PWCHAR pszServer;
    BOOL bNt40;
    EL_ADAPTER_INFO * pNodes;
    DWORD dwNodeCount;
    HANDLE hNameHashTable;
    HANDLE hGuidHashTable;
    BOOL bLoaded;

} GUIDMAPCB;

DWORD 
GuidMapSeedHashTable (
    OUT HANDLE * phTable,
    IN  HashTabHashFuncPtr pHashFunc,
    IN  HashTabKeyCompFuncPtr pCompFunc,
    IN  EL_ADAPTER_INFO * pNodes,
    IN  DWORD dwCount,
    IN  DWORD dwOffset);

ULONG 
GuidMapHashGuid (
    IN HANDLE hGuid);
    
ULONG 
GuidMapHashName (
    IN HANDLE hName);
    
int 
GuidMapCompGuids (
    IN HANDLE hGuid, 
    IN HANDLE hNameMapNode);
    
int 
GuidMapCompNames (
    IN HANDLE hName, 
    IN HANDLE hNameMapNode);

//
// Initialize the guid map for the given server
//
DWORD 
GuidMapInit ( 
    IN PWCHAR pszServer,
    OUT HANDLE * phGuidMap )
{
    GUIDMAPCB * pMapCb;

    // Validate params
    if (! phGuidMap)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the control block
    pMapCb = Malloc (sizeof (GUIDMAPCB));
    if (!pMapCb)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Initialize
    RtlZeroMemory (pMapCb, sizeof (GUIDMAPCB));
    pMapCb->pszServer = pszServer;

    *phGuidMap = (HANDLE)pMapCb;

    return NO_ERROR;
}

//
// Loads and prepares the guid map so that it can
// perform the given map function (a GUIDMAP_FUNCTION_XXX value).
//
DWORD GuidMapLoad (
    IN GUIDMAPCB * pMapCb,
    IN DWORD dwFunction)
{
    DWORD dwErr;

    // We've done all the work we need to if we aren't looking
    // at an nt5 machine
    if (pMapCb->bNt40)
    {
        return NO_ERROR;
    }

    // Load the guid map
    if (! pMapCb->bLoaded) 
    {
        dwErr = ElEnumLanAdapters ( 
                    pMapCb->pszServer,
                    &(pMapCb->pNodes),
                    &(pMapCb->dwNodeCount),
                    &(pMapCb->bNt40) );
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }

        pMapCb->bLoaded = TRUE;
    }

    // Seed the appropriate mapping hash table as needed
    if ((dwFunction == GUIDMAP_FUNCTION_MAPFRIENDLY)  &&
        (pMapCb->hGuidHashTable == NULL))
    {
        GuidMapSeedHashTable (  
            &(pMapCb->hGuidHashTable),
            GuidMapHashGuid,
            GuidMapCompGuids,
            pMapCb->pNodes,
            pMapCb->dwNodeCount,
            FIELD_OFFSET(EL_ADAPTER_INFO, guid));
    }
    else if ((dwFunction == GUIDMAP_FUNCTION_MAPGUID) &&
             (pMapCb->hNameHashTable == NULL))
    {
        GuidMapSeedHashTable (  
            &(pMapCb->hNameHashTable),
            GuidMapHashName,
            GuidMapCompNames,
            pMapCb->pNodes,
            pMapCb->dwNodeCount,
            FIELD_OFFSET(EL_ADAPTER_INFO, pszName));
    }

    return NO_ERROR;
}

//
// Cleans up resources obtained through GuidMapInit
//
DWORD 
GuidMapCleanup ( 
    IN  HANDLE  hGuidMap,
    IN  BOOL    bFree
    ) 
{
    GUIDMAPCB * pMap = (GUIDMAPCB*)hGuidMap;

    if (!pMap)
    {
        return ERROR_INVALID_HANDLE;
    }

    if (pMap->pNodes)
    {
        ElCleanup (pMap->pNodes, pMap->dwNodeCount);
    }

    if (pMap->hNameHashTable)
    {
        HashTabCleanup (pMap->hNameHashTable);
    }

    if (pMap->hGuidHashTable)
    {
        HashTabCleanup (pMap->hGuidHashTable);
    }

    RtlZeroMemory (pMap, sizeof(GUIDMAPCB));

    if(bFree)
    {
        Free (pMap);
    }

    return NO_ERROR;
}

//
// Hash function for guids -- sum up the guid and mod
//
ULONG 
GuidMapHashGuid (
    HANDLE hGuid) 
{
    DWORD dwSum = 0, * pdwCur;
    DWORD_PTR dwEnd = (DWORD_PTR)hGuid + sizeof(GUID);

    for (pdwCur = (DWORD*)hGuid; (DWORD_PTR)pdwCur < dwEnd; pdwCur++)
    {
        dwSum += *pdwCur;
    }

    return dwSum % GUIDMAP_HASH_SIZE;
}

//
// Hash function for names -- sum up the characters and mod
//
ULONG 
GuidMapHashName (
    HANDLE hName) 
{
    PWCHAR pszString = *((PWCHAR *)hName);
    DWORD dwSum = 0;

    while (pszString && *pszString) 
    {
        dwSum += towlower(*pszString);
        pszString++;
    }

    return dwSum % GUIDMAP_HASH_SIZE;
}

//
// Comparison function for guids to NAMEMAPNODES
//
int 
GuidMapCompGuids (
    IN HANDLE hGuid, 
    IN HANDLE hNameMapNode) 
{
    return memcmp (
            (GUID*)hGuid, 
            &(((EL_ADAPTER_INFO *)hNameMapNode)->guid), 
            sizeof(GUID));
}

//
// Comparison function for names to NAMEMAPNODES
//
int 
GuidMapCompNames (
    IN HANDLE hName, 
    IN HANDLE hNameMapNode) 
{
    return lstrcmpi(
            *((PWCHAR*)hName), 
            ((EL_ADAPTER_INFO *)hNameMapNode)->pszName);
}

//
// Seeds the given hash table.  Offset is the offset into the
// namemapnode of the key for insertion.
//
DWORD 
GuidMapSeedHashTable (
    OUT HANDLE * phTable,
    IN  HashTabHashFuncPtr pHashFunc,
    IN  HashTabKeyCompFuncPtr pCompFunc,
    IN  EL_ADAPTER_INFO * pNodes,
    IN  DWORD dwCount,
    IN  DWORD dwOffset)
{
    DWORD dwErr, i, dwHashSize = GUIDMAP_HASH_SIZE;

    // Initialize the hash table
    dwErr = HashTabCreate ( 
                dwHashSize,
                pHashFunc,
                pCompFunc,
                NULL,
                NULL,
                NULL,
                phTable );
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Add all of the nodes to the hash table
    for (i = 0; i < dwCount; i++) 
    {
        HashTabInsert ( 
            *phTable,
            (HANDLE)((DWORD_PTR)(&(pNodes[i])) + dwOffset),
            (HANDLE)(&(pNodes[i])) );
    }

    return NO_ERROR;
}

//
// Gets the name and status of a given adapter
//
DWORD
GuidMapLookupNameAndStatus(
    GUIDMAPCB* pMapCb, 
    GUID* pGuid, 
    PWCHAR* ppszName,
    DWORD* lpdwStatus) 
{
    EL_ADAPTER_INFO * pNode;
    DWORD dwErr;

    dwErr = HashTabFind ( 
                pMapCb->hGuidHashTable,
                (HANDLE)pGuid,
                (HANDLE*)&pNode );
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    *ppszName = pNode->pszName;
    *lpdwStatus = pNode->dwStatus;
    
    return NO_ERROR;
}

//
// Looks up a name given a guid
//
DWORD 
GuidMapLookupName (
    GUIDMAPCB * pMapCb, 
    GUID * pGuid, 
    PWCHAR * ppszName) 
{
    DWORD dwStatus;

    return GuidMapLookupNameAndStatus(pMapCb, pGuid, ppszName, &dwStatus);
}

//
// Looks up a guid given a name
//
DWORD 
GuidMapLookupGuid (
    IN GUIDMAPCB * pMapCb, 
    IN PWCHAR pszName, 
    GUID * pGuid) 
{
    EL_ADAPTER_INFO * pNode;
    DWORD dwErr;

    dwErr = HashTabFind ( 
                pMapCb->hNameHashTable,
                (HANDLE)&pszName,
                (HANDLE*)&pNode );
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    *pGuid = pNode->guid;
    return NO_ERROR;
}

//
//  Returns a pointer to the packet name portion of 
//  the interface name if it exists.
//
PWCHAR 
GuidMapFindPacketName(
    IN PWCHAR pszName) 
{
	PWCHAR res;

	if ((res = wcsstr(pszName, L"SNAP")) != NULL)
	{
		return res;
	}
	if ((res = wcsstr(pszName, L"EthII")) != NULL)
	{
		return res;
	}
	if ((res = wcsstr(pszName, L"802.2")) != NULL)
	{
		return res;
	}
	if ((res = wcsstr(pszName, L"802.3")) != NULL)
	{
		return res;
	}

	return NULL;
}

//
//  Takes in a friendly interface name and removes it's
//  [xxxx] packet type appending.
//
DWORD 
GuidMapParseOutPacketName (
    IN PWCHAR pszName,
    OUT PWCHAR pszNameNoPacket,
    OUT PWCHAR pszPacketName)
{
    PWCHAR pszPacket = GuidMapFindPacketName (pszName);
    int len;

    if (pszPacket) 
    {
        pszPacket--;
        len = (int) ((((DWORD_PTR)pszPacket) - 
                      ((DWORD_PTR)pszName))  / 
                      sizeof (WCHAR));
        lstrcpynW (pszNameNoPacket, pszName, len);
        pszNameNoPacket[len] = 0;
        pszPacket++;
        pszPacket[wcslen(pszPacket) - 1] = (WCHAR)0;
        lstrcpyW (pszPacketName, pszPacket);
    }
    else 
    {
        lstrcpyW (pszNameNoPacket, pszName);
        pszPacketName[0] = 0;
    }

    return NO_ERROR;
}

//
//	Generates the version of the interface as stored in the registry.  This
//  is done by finding the packet type if any and appending it to the
//  guid name.
//
DWORD 
GuidMapFormatGuidName(
    OUT PWCHAR pszDest,
    IN  DWORD  dwBufferSize,
    IN  PWCHAR pszGuidName,
    IN  PWCHAR pszPacketType)
{
    DWORD dwSize;
	
    // Upper case the guid name
    _wcsupr(pszGuidName);


    // Calculate the space required for storing pszGuidName, the opening and 
    // closing braces, and the terminating NULL 
    dwSize = (wcslen(pszGuidName) + 2 + 1)* sizeof (WCHAR);
    if ( pszPacketType[0] )
    {
        // add the space required to store the pszPacketType and "/"
        dwSize += (wcslen(pszPacketType) + 1) * sizeof (WCHAR);
    }
    if ( dwBufferSize < dwSize )
    {
        return ERROR_BUFFER_OVERFLOW;
    }


	// Generate the name
    if (pszPacketType[0])
    {
        wsprintfW(pszDest,L"{%s}/%s", pszGuidName, pszPacketType);
    }
    else
    {
        wsprintfW(pszDest,L"{%s}", pszGuidName);
    }

	return NO_ERROR;
}

//
//  Appends the packet type if any to the interface name.
//
DWORD 
GuidMapFormatFriendlyName (
    OUT PWCHAR pszDest,
    IN  DWORD  dwBufferSize,
    IN  PWCHAR pszFriendlyName,
    IN  PWCHAR pszGuidName)
{
	PWCHAR pszType = NULL;
	DWORD  dwSize;

	pszType = GuidMapFindPacketName(pszGuidName);

	// Calculate the space required for storing pszFriendlyName and the terminating NULL 
	dwSize = (wcslen(pszFriendlyName) + 1)* sizeof (WCHAR);
	if ( pszType )
	{
		// add the space required to store the pszType, the blank space, and the 
		// opening and closing square brackets
		dwSize += (wcslen(pszType) + 3) * sizeof (WCHAR);
	}
    if ( dwBufferSize < dwSize )
    {
        return ERROR_BUFFER_OVERFLOW;
    }

	if (pszType)
	{
		wsprintfW(pszDest,L"%s [%s]", pszFriendlyName, pszType);
    }
	else
	{
		wsprintfW(pszDest,L"%s", pszFriendlyName);
    }

    return NO_ERROR;
}

//
// Parses out the guid portion of an interface name
//
DWORD 
GuidMapGetGuidString(
    IN  PWCHAR pszName,
    OUT PWCHAR* ppszGuidString)
{
	PWCHAR pszBegin = NULL, pszEnd = NULL;
	PWCHAR pszRet = NULL;
	int i, length;
	DWORD dwErr = NO_ERROR;

    do
    {
        // Validate parameters
        //
    	if (!pszName || !ppszGuidString)
    	{
    		return ERROR_INVALID_PARAMETER;
        }

    	// Find out if this is a guid string
    	pszBegin = wcsstr(pszName, L"{");
    	pszEnd = wcsstr(pszName, L"}");

    	// If there is no guid portion, return success with a 
    	//null pszGuidString
    	if ((pszBegin == NULL) || (pszEnd == NULL)) 
    	{
    		*ppszGuidString = NULL;
    		break;
    	}

        // Check the format of the return
        //
    	if ((DWORD_PTR)pszBegin >= (DWORD_PTR)pszEnd)
    	{
    		dwErr = ERROR_CAN_NOT_COMPLETE;
    		break;
        }

        // Allocate the return value
        //
    	length = 41;
    	pszRet = (PWCHAR) Malloc(length * sizeof(WCHAR));
    	if (pszRet == NULL)
    	{
    	    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    		break;
        }

    	i=0;
    	pszBegin++;
    	while ((pszBegin != pszEnd) && (i < length)) 
    	{
    		pszRet[i++]=*pszBegin;
    		pszBegin++;
    	}
    	pszRet[i]=0;

    	*ppszGuidString = pszRet;
    	
    } while (FALSE);    	

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            if (pszRet)
            {
                Free(pszRet);
            }
        }
    }

	return dwErr;
}

//
// Derive the friendly name from the guid name
//
DWORD 
GuidMapGetFriendlyName (
    IN  SERVERCB *pserver,
    IN  PWCHAR pszGuidName,
    IN  DWORD  dwBufferSize,
    OUT PWCHAR pszFriendlyName )
{
    GUIDMAPCB * pMapCb = (GUIDMAPCB*)(pserver->hGuidMap);
	PWCHAR pszGuidString = NULL, pszNetmanName = NULL;
	DWORD dwErr = NO_ERROR;
	GUID Guid;

	// Sanity Check
	if (!pMapCb || !pszGuidName || !pszFriendlyName || !dwBufferSize)
	{
		return ERROR_INVALID_PARAMETER;
    }

    // Prepare the map for friendly name lookups
    dwErr = GuidMapLoad (pMapCb, GUIDMAP_FUNCTION_MAPFRIENDLY);
	if (dwErr != NO_ERROR)
	{
	    return dwErr;
	}

    // Nt40 machines require no mapping
	if (pMapCb->bNt40)
	{
	    return ERROR_NOT_FOUND;
	}

	do
	{
		// Get the guid string from the interface name
		dwErr = GuidMapGetGuidString(pszGuidName, &pszGuidString);
		if (dwErr != NO_ERROR)
		{
            break;
	    }

		// If there is no guid, there is no mapping
		if (! pszGuidString)
		{
		    dwErr = ERROR_NOT_FOUND;
		    break;
		}
		
        // Convert the guid string
        if (UuidFromStringW (pszGuidString, &Guid)!= RPC_S_OK) {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
	
		// Look up the descriptive name
		dwErr = GuidMapLookupName (pMapCb, &Guid, &pszNetmanName);
		if (dwErr != NO_ERROR)
		{
			break;
	    }

        // If the registry is corrupt, it is possible for an 
        // adapter with a null name to be mapped.  Taking this 
        // precaution will prevent an AV in this
        // case (shouldn't happen anyway)
        //
        if (pszNetmanName == NULL)
        {
            pszNetmanName = L"";
        }
		
        // Copy in the string
        dwErr = GuidMapFormatFriendlyName (
            pszFriendlyName, 
            dwBufferSize,
            pszNetmanName, 
            pszGuidName);
        if ( dwErr != NO_ERROR )
        {
        	break;
        }
		
	} while (FALSE);

	// Cleanup
	{
	    if (pszGuidString)
	    {
    		Free (pszGuidString);
        }
	}

	return dwErr;
}

//
// Derive the guid name from the friendly name
//
DWORD 
GuidMapGetGuidName (
    IN  SERVERCB *pserver,
    IN PWCHAR pszFriendlyName,
    IN DWORD dwBufferSize,
    OUT PWCHAR pszGuidName )
{
	WCHAR pszNoPacketName[1024], pszPacketDesc[64], *pszGuid = NULL;
    GUIDMAPCB * pMapCb = (GUIDMAPCB*)(pserver->hGuidMap);
	DWORD dwErr;
	GUID Guid;

    // Validate paramters
	if (!pMapCb || !pszFriendlyName || !pszGuidName || !dwBufferSize)
	{
		return ERROR_INVALID_PARAMETER;
    }

    // Prepare the map for guid name lookups
    dwErr = GuidMapLoad (pMapCb, GUIDMAP_FUNCTION_MAPGUID);
	if (dwErr != NO_ERROR)
	{
	    return dwErr;
	}

    // Nt40 machines require no mapping
	if (pMapCb->bNt40)
	{
	    return ERROR_NOT_FOUND;
	}

    // Remove the packet type from the friendly name
    GuidMapParseOutPacketName (
        pszFriendlyName, 
        pszNoPacketName, 
        pszPacketDesc);

    // If we don't have the name in the guid map, then
    // this must be a non lan interface.

    dwErr = GuidMapLookupGuid (pMapCb, pszNoPacketName, &Guid);

	if (dwErr != NO_ERROR)
	{
        return dwErr;
	}
	
	// Otherwise, return its Guid name
    do
    {
		if(RPC_S_OK != UuidToStringW (&Guid, &pszGuid))
		{
		    break;
		}
		
		if (pszGuid) 
		{
    		dwErr = GuidMapFormatGuidName(
    		    pszGuidName, 
    		    dwBufferSize,
    		    pszGuid, 
    		    pszPacketDesc);
    		if ( dwErr != NO_ERROR )
    		{
				if ( pszGuid )
				{
					RpcStringFreeW (&pszGuid);
					pszGuid = NULL;
				}
    			return dwErr;
    		}
		}
		
    } while (FALSE);
    
    // Cleanup
    {
        if (pszGuid)
        {
            RpcStringFreeW (&pszGuid);
        }
    }

	return NO_ERROR;
}

//
// States whether a mapping for the given guid name
// exists without actually providing the friendly
// name.  This is more efficient than GuidMapGetFriendlyName 
// when the friendly name is not required.
//
DWORD 
GuidMapIsAdapterInstalled(
    IN  HANDLE hGuidMap,
    IN  PWCHAR pszGuidName,
    OUT PBOOL  pfMappingExists)
{
    GUIDMAPCB * pMapCb = (GUIDMAPCB*)hGuidMap;
	PWCHAR pszGuidString = NULL, pszNetmanName = NULL;
	DWORD dwErr = NO_ERROR, dwSize, dwStatus = 0;
	GUID Guid;

	// Sanity Check
	if (!pMapCb || !pszGuidName)
	{
		return ERROR_INVALID_PARAMETER;
    }

    // Prepare the map for friendly name lookups
    dwErr = GuidMapLoad (pMapCb, GUIDMAP_FUNCTION_MAPFRIENDLY);
	if (dwErr != NO_ERROR)
	{
	    return dwErr;
	}

    // Nt40 machines require no mapping
	if (pMapCb->bNt40)
	{
	    *pfMappingExists = TRUE;
	    return NO_ERROR;
	}

	do
	{
		// Get the guid string from the interface name
		dwErr = GuidMapGetGuidString(pszGuidName, &pszGuidString);
		if (dwErr != NO_ERROR)
		{
			break;
	    }

		// If there is no guid, there is no mapping
		if (! pszGuidString)
		{
		    dwErr = ERROR_NOT_FOUND;
		    break;
		}
		
        // Convert the guid string
        if (UuidFromStringW (pszGuidString, &Guid)!= RPC_S_OK) {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
	
		// Look up the descriptive name
		dwErr = GuidMapLookupNameAndStatus (
		            pMapCb, 
		            &Guid, 
		            &pszNetmanName, 
		            &dwStatus);
		if ((dwErr == NO_ERROR)     && 
		    (pszNetmanName)         && 
		    (dwStatus != EL_STATUS_NOT_THERE))
		{
		    *pfMappingExists = TRUE;
	    }
	    else
	    {
		    *pfMappingExists = FALSE;
	    }
		
	} while (FALSE);

	// Cleanup
	{
	    if (pszGuidString)
	    {
    		Free (pszGuidString);
        }
	}

	return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\dsrights.h ===
/*
    File    dsrights.h

    header for project that establishes a ras server 
    in a domain.

    Paul Mayfield, 4/20/98
*/    

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <crypt.h>
#define INC_OLE2
#include <windows.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <raserror.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <locale.h>
#include <tchar.h>
#define SECURITY_WIN32
#include <sspi.h>

#include <activeds.h>
#include <adsi.h>
#include <ntdsapi.h>
#include <dsrole.h>
#include <dsgetdc.h>
#include <accctrl.h>
#include <aclapi.h>

#ifdef __cplusplus
extern "C" {
#endif

DWORD DsrTraceInit();
DWORD DsrTraceCleanup();

DWORD DsrTraceEx (DWORD dwErr, LPSTR pszTrace, ...);

#define DSR_ERROR(e) ((HRESULT_FACILITY((e)) == FACILITY_WIN32) ? HRESULT_CODE((e)) : (e));
#define DSR_FREE(s) if ((s)) DsrFree ((s))
#define DSR_RELEASE(s) if ((s)) (s)->Release();
#define DSR_BREAK_ON_FAILED_HR(_hr) {if (FAILED((_hr))) break;}

//
// Typedefs
//
typedef struct _DSRINFO 
{
    PWCHAR pszMachineDN;
    PWCHAR pszGroupDN;    
} DSRINFO;

//
// Memory management routines
//
PVOID 
DsrAlloc (
        IN DWORD dwSize, 
        IN BOOL bZero);
        
DWORD 
DsrFree (
        IN PVOID pvBuf);

//
// Searches given domain for a computer account 
// with the given name and returns its ADsPath
// if found.
//
DWORD 
DsrFindDomainComputer (
        IN  PWCHAR  pszDomain,
        IN  PWCHAR  pszComputer,
        OUT PWCHAR* ppszADsPath);

//
// Searches given domain for the well known 
// "RAS and IAS Servers" group and returns 
// its ADsPath if found.
//
DWORD 
DsrFindRasServersGroup (
        IN  PWCHAR  pszDomain,
        OUT PWCHAR* ppszADsPath);
        
//
// Adds or removes a given object from a given group.
//
DWORD 
DsrGroupAddRemoveMember(
        IN PWCHAR pszGroupDN,
        IN PWCHAR pszNewMemberDN,
        IN BOOL bAdd);

//
// Returns whether the given object is a member of
// the given group.
//
DWORD 
DsrGroupIsMember(
        IN  PWCHAR pszGroupDN, 
        IN  PWCHAR pszObjectName, 
        OUT PBOOL  pbIsMember);

// 
// Sets the ACES in the given domain to enable nt4 servers
//
DWORD
DsrDomainSetAccess(
    IN PWCHAR pszDomain,
    IN DWORD dwAccessFlags);

//
// Discovers whether security is such that nt4 ras servers
// can authenticate.
//
DWORD
DsrDomainQueryAccess(
    IN  PWCHAR pszDomain, 
    OUT LPDWORD lpdwAccessFlags);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\hashtab.c ===
/*
    File    HashTab.h

    Definitions for creating/dealing with hash tables.

    Paul Mayfield, 3/30/98
*/

#include "hashtab.h"

// Represents nodes in the binary tree
typedef struct _HTNODE {
    HANDLE hData;
    struct _HTNODE * pNext;
} HTNODE;

// Represents a binary tree
typedef struct _HASHTAB {
    HTNODE ** ppNodes;
    ULONG ulSize;
    HashTabHashFuncPtr pHash;
    HashTabKeyCompFuncPtr pCompKeyAndElem;
    HashTabAllocFuncPtr pAlloc;
    HashTabFreeFuncPtr pFree;
    HashTabFreeElemFuncPtr pFreeElem;
    ULONG dwCount;
    
} HASHTAB;

// Default allocator
PVOID HashTabAlloc (ULONG ulSize) {
    return RtlAllocateHeap (RtlProcessHeap(), 0, ulSize);
}

// Default freer
VOID HashTabFree (PVOID pvData) {
    RtlFreeHeap (RtlProcessHeap(), 0, pvData);
}

//
// Create a hash table
//
ULONG HashTabCreate (
        IN ULONG ulSize,
        IN HashTabHashFuncPtr pHash,
        IN HashTabKeyCompFuncPtr pCompKeyAndElem,
        IN OPTIONAL HashTabAllocFuncPtr pAlloc,
        IN OPTIONAL HashTabFreeFuncPtr pFree,
        IN OPTIONAL HashTabFreeElemFuncPtr pFreeElem,
        OUT HANDLE * phHashTab )
{
    HASHTAB * pTable;
    
    // Validate and initailize variables
    if (!pHash || !pCompKeyAndElem || !phHashTab)
        return ERROR_INVALID_PARAMETER;
        
    if (!pAlloc)
        pAlloc = HashTabAlloc;

    // Allocate the table structure
    pTable = (*pAlloc)(sizeof(HASHTAB));
    if (!pTable)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Initialize
    pTable->pHash = pHash;
    pTable->ulSize = ulSize;
    pTable->pCompKeyAndElem = pCompKeyAndElem;
    pTable->pAlloc = pAlloc;
    pTable->pFree = (pFree) ? pFree : HashTabFree;
    pTable->pFreeElem = pFreeElem;

    // Allocate the table
    pTable->ppNodes = (pAlloc)(sizeof(HTNODE*) * ulSize);
    if (!pTable->ppNodes) {
        (*(pTable->pFree))(pTable);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory (pTable->ppNodes, sizeof(HTNODE*) * ulSize);

    *phHashTab = (HANDLE)pTable;
    
    return NO_ERROR;
}

//
// Clean up the hash table.
//
ULONG 
HashTabCleanup (
    IN HANDLE hHashTab )
{
    HASHTAB * pTable = (HASHTAB*)hHashTab;
    HTNODE * pNode, * pNext;
    ULONG i;

    if (pTable == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    for (i = 0; i < pTable->ulSize; i++ ) 
    {
        if ((pNode = pTable->ppNodes[i]) != NULL) 
        {
            while (pNode) 
            {
                pNext = pNode->pNext;
                if (pTable->pFreeElem)
                {
                    (*(pTable->pFreeElem))(pNode->hData);
                }
                (*(pTable->pFree))(pNode);
                pNode = pNext;
            }
        }
    }

    (*(pTable->pFree))(pTable->ppNodes);
    (*(pTable->pFree))(pTable);
    
    return NO_ERROR;
}

//
// Insert an element in a hash table
//
ULONG HashTabInsert (
        IN HANDLE hHashTab,
        IN HANDLE hKey,
        IN HANDLE hData )
{
    HASHTAB * pTable = (HASHTAB*)hHashTab;
    HTNODE * pNode;
    ULONG ulIndex;
    
    // Validate Params
    if (!hHashTab || !hData)
        return ERROR_INVALID_PARAMETER;

    // Find out where the element goes
    ulIndex = (* (pTable->pHash))(hKey);
    if (ulIndex >= pTable->ulSize)
        return ERROR_INVALID_INDEX;

    // Allocate a new hash table node 
    pNode = (* (pTable->pAlloc))(sizeof (HTNODE));
    if (!pNode)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Insert the node into the appropriate location in the
    // hash table.
    pNode->pNext = pTable->ppNodes[ulIndex];
    pTable->ppNodes[ulIndex] = pNode;
    pNode->hData = hData;
    pTable->dwCount++;
  
    return NO_ERROR;
}

//
// Removes the data associated with the given key
//
ULONG HashTabRemove (
        IN HANDLE hHashTab,
        IN HANDLE hKey)
{
    HASHTAB * pTable = (HASHTAB*)hHashTab;
    HTNODE * pCur, * pPrev;
    ULONG ulIndex;
    int iCmp;
    
    // Validate Params
    if (!hHashTab)
        return ERROR_INVALID_PARAMETER;

    // Find out where the element should be 
    ulIndex = (* (pTable->pHash))(hKey);
    if (ulIndex >= pTable->ulSize)
        return ERROR_INVALID_INDEX;
    if (pTable->ppNodes[ulIndex] == NULL)
        return ERROR_NOT_FOUND;

    // If the element is at the start of the 
    // list, remove it and we're done.
    pCur = pTable->ppNodes[ulIndex];
    if ( (*(pTable->pCompKeyAndElem))(hKey, pCur->hData) == 0 ) {
        pTable->ppNodes[ulIndex] = pCur->pNext;
        if (pTable->pFreeElem)
            (*(pTable->pFreeElem))(pCur->hData);
        (*(pTable->pFree))(pCur);
        pTable->dwCount--;
        
        return NO_ERROR;
    }

    // Otherwise, loop through the list until we find a 
    // match.
    pPrev = pCur;
    pCur = pCur->pNext;
    while (pCur) {
        iCmp = (*(pTable->pCompKeyAndElem))(hKey, pCur->hData);
        if ( iCmp == 0 ) {
            pPrev->pNext = pCur->pNext;
            if (pTable->pFreeElem)
                (*(pTable->pFreeElem))(pCur->hData);
            (*(pTable->pFree))(pCur);
            pTable->dwCount--;
            
            return NO_ERROR;
         }
        pPrev = pCur;
        pCur = pCur->pNext;
    }

    return ERROR_NOT_FOUND;
}

//
// Search in the table for the data associated with the given key
// 
ULONG HashTabFind (
        IN HANDLE hHashTab,
        IN HANDLE hKey,
        OUT HANDLE * phData )
{
    HASHTAB * pTable = (HASHTAB*)hHashTab;
    HTNODE * pNode;
    ULONG ulIndex;
    
    // Validate Params
    if (!hHashTab || !phData)
        return ERROR_INVALID_PARAMETER;

    // Find out where the element goes
    ulIndex = (* (pTable->pHash))(hKey);
    if (ulIndex >= pTable->ulSize)
        return ERROR_INVALID_INDEX;

    // Search through the list at the given index
    pNode = pTable->ppNodes[ulIndex];
    while (pNode) {
        if ( (*(pTable->pCompKeyAndElem))(hKey, pNode->hData) == 0 ) {
            *phData = pNode->hData;
            return NO_ERROR;
        }
        pNode = pNode->pNext;
    }

    return ERROR_NOT_FOUND;
}

ULONG 
HashTabGetCount(
    IN  HANDLE hHashTab,
    OUT ULONG* lpdwCount)
{
    HASHTAB * pTable = (HASHTAB*)hHashTab;

    if (!lpdwCount || !hHashTab)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    *lpdwCount = pTable->dwCount;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\enumlan.h ===
/*
    File    netmanp.h

    Provides interface for obtaining guid to friendly name mappings.

    Paul Mayfield, 3/12/98

*/

#ifndef __mpradmin_netmanp_h
#define __mpradmin_netmanp_h

#ifdef __cplusplus
extern "C" {
#endif

//
// Definitions for possible hardware states for lan adapters.
// They corrospond to CM_PROB_* values.
//
#define EL_STATUS_OK            0x0
#define EL_STATUS_NOT_THERE     0x1
#define EL_STATUS_MOVED         0x2
#define EL_STATUS_DISABLED      0x3
#define EL_STATUS_HWDISABLED    0x4
#define EL_STATUS_OTHER         0x5

// Defines a structure that associates a guid with an
// friendly interface name
typedef struct _EL_ADAPTER_INFO 
{
    BSTR  pszName;
    GUID  guid;
    DWORD dwStatus;    // See EL_STATUS_*
    
} EL_ADAPTER_INFO;

//
//  Obtains the map of connection names to guids on the given server 
//  from its netman service.
//
//  Parameters:
//      pszServer:  Server on which to obtain map (NULL = local)
//      ppMap:      Returns array of EL_ADAPTER_INFO's
//      lpdwCount   Returns number of elements read into ppMap
//      pbNt40:     Returns whether server is nt4 installation
//
DWORD 
ElEnumLanAdapters( 
    IN  PWCHAR pszServer,
    OUT EL_ADAPTER_INFO ** ppMap,
    OUT LPDWORD lpdwNumNodes,
    OUT PBOOL pbNt40 );
                                
//
// Cleans up the buffer returned from ElEnumLanAdapters
//
DWORD 
ElCleanup( 
    IN EL_ADAPTER_INFO * pMap,
    IN DWORD dwCount );


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\enumlan.c ===
/*
    File    enumlan.c

    Implementation of functions to enumerate lan interfaces 
    on a given machine.  This implementation actually bypasses
    netman and gets the information using setup api's.

    Paul Mayfield, 5/13/98
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>

#include <netcfgx.h>
#include <netcon.h>
#include <setupapi.h>
#include <devguid.h>
#include <cfgmgr32.h>
#include <mprapi.h>

#include "rtcfg.h"
#include "enumlan.h"

#define EL_MAP_GROW_FACTOR 25

// 
// Determines whether a given machine is nt40
//
DWORD 
IsNt40Machine (
    IN      HKEY        hkeyMachine,
    OUT     PBOOL       pbIsNt40);

//
// Structure represents a growable array of name map nodes.
//
typedef struct _EL_NAMEMAP 
{
	DWORD dwNumNodes;
	EL_ADAPTER_INFO *pNodes;
} EL_NAMEMAP;	

//
// Structure contains data manipulated by ElIsNetcfgDevice
//
typedef struct _EL_ISNETCFGDEV_INFO
{
    EL_ADAPTER_INFO* pAdapter;      // IN OUT
    WCHAR pszPnpInstance[MAX_PATH]; // OUT
    
} EL_ISNETCFGDEV_INFO;

//
// Structure contains data manipulated by ElGetAdapterStatus
//
typedef struct _EL_ADAPTER_STATUS_INFO
{
    EL_ADAPTER_INFO* pAdapter;  // IN OUT
    HANDLE hkCmMachine;         // IN
    PWCHAR pszPnpInstance;      // IN
    
} EL_ADAPTER_STATUS_INFO;

//
// Defines a filter function (used by lan adapter enumeration)
//
typedef 
DWORD 
(*DevFilterFuncPtr)(
    HKEY, 
    HKEY, 
    HANDLE, 
    PBOOL);

//
// Stolen from netcfg project
//
#define IA_INSTALLED 1
const WCHAR c_szRegKeyInterfacesFromInstance[] = L"Ndi\\Interfaces";
const WCHAR c_szRegValueUpperRange[]           = L"UpperRange";
const WCHAR c_szBiNdis4[]                      = L"ndis4";
const WCHAR c_szBiNdis5[]                      = L"ndis5";
const WCHAR c_szBiNdisAtm[]                    = L"ndisatm";
const WCHAR c_szBiNdis1394[]                   = L"ndis1394";
const WCHAR c_szCharacteristics[]              = L"Characteristics";
const WCHAR c_szRegValueNetCfgInstanceId[]     = L"NetCfgInstanceID";
const WCHAR c_szRegValueInstallerAction[]      = L"InstallerAction";
const WCHAR c_szRegKeyConnection[]             = L"Connection";
const WCHAR c_szRegValueConName[]              = L"Name"; 
const WCHAR c_szRegValuePnpInstanceId[]        = L"PnpInstanceID";
const WCHAR c_szRegKeyComponentClasses[]       = 
                L"SYSTEM\\CurrentControlSet\\Control\\Network";

//
// Maps a CM_PROB_* value to a EL_STATUS_* value
//
DWORD
ElMapCmStatusToElStatus(
    IN  DWORD dwCmStatus,
    OUT LPDWORD lpdwElStatus)
{

    return NO_ERROR;    
}

// 
// Adapted version of HrIsLanCapableAdapterFromHkey determines 
// whether an adapter is lan capable based on its registry key.
//
DWORD 
ElIsLanAdapter(
    IN  HKEY hkMachine,
    IN  HKEY   hkey,
    OUT HANDLE hData,        
    OUT PBOOL pbIsLan)
{
    HKEY hkeyInterfaces;
    WCHAR pszBuf[256], *pszCur, *pszEnd;
    DWORD dwErr, dwType = REG_SZ, dwSize = sizeof(pszBuf);

    *pbIsLan = FALSE;

    // Open the interfaces key
    dwErr = RegOpenKeyEx( hkey, 
                          c_szRegKeyInterfacesFromInstance,
                          0, 
                          KEY_READ, 
                          &hkeyInterfaces);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    // Read in the upper range        
    dwErr = RegQueryValueExW (hkeyInterfaces, 
                              c_szRegValueUpperRange,
                              NULL,
                              &dwType,
                              (LPBYTE)pszBuf,
                              &dwSize);
    if (dwErr != ERROR_SUCCESS)
        return NO_ERROR;

    // See if this buffer has the magic strings in it
    pszCur = pszBuf;
    while (TRUE) {
        pszEnd = wcsstr(pszCur, L",");            
        if (pszEnd != NULL)
            *pszEnd = (WCHAR)0;
        if ((lstrcmpi (pszCur, c_szBiNdis4) == 0) ||
            (lstrcmpi (pszCur, c_szBiNdis5) == 0) ||
            (lstrcmpi (pszCur, c_szBiNdis1394) == 0) ||
            (lstrcmpi (pszCur, c_szBiNdisAtm) == 0))
        {
            *pbIsLan = TRUE;
            break;
        }
        if (pszEnd == NULL)
            break;
        else
            pszCur = pszEnd + 1;
    }
               
    RegCloseKey(hkeyInterfaces);
        
    return NO_ERROR;        
}

// 
// Filters netcfg devices.  If a device passes this filter
// it will have its guid and freindly name returned through
// the hData parameter (option user defined data).
//
DWORD 
ElIsNetcfgDevice(
    IN  HKEY hkMachine,
    IN  HKEY hkDev,
    OUT HANDLE hData,        
    OUT PBOOL pbOk)
{
    EL_ISNETCFGDEV_INFO* pInfo = (EL_ISNETCFGDEV_INFO*)hData;
    EL_ADAPTER_INFO *pNode = pInfo->pAdapter;
    GUID Guid = GUID_DEVCLASS_NET;
    WCHAR pszBuf[1024], pszPath[256], pszClassGuid[256];
    DWORD dwErr = NO_ERROR, dwType = REG_SZ, dwSize = sizeof(pszBuf), dwAction;
    HKEY hkeyNetCfg = NULL;

    *pbOk = FALSE;

    // Read in the netcfg instance
    dwErr = RegQueryValueExW (
                hkDev, 
                c_szRegValueNetCfgInstanceId,
                NULL,
                &dwType,
                (LPBYTE)pszBuf,
                &dwSize);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Generate path in registry for lookup
    StringFromGUID2(
        &Guid, 
        pszClassGuid, 
        sizeof(pszClassGuid));
    wsprintf(
        pszPath, 
        L"%s\\%s\\%s\\%s", 
        c_szRegKeyComponentClasses,
        pszClassGuid, 
        pszBuf,
        c_szRegKeyConnection);

    do
    {
        // Open the key
        dwErr = RegOpenKeyEx( 
                    hkMachine, 
                    pszPath,
                    0,
                    KEY_READ, 
                    &hkeyNetCfg);
        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }
            
        // Pass the filter
        *pbOk = TRUE;

        // Store the guid
        pszBuf[wcslen(pszBuf) - 1] = (WCHAR)0;
        if (UuidFromString(pszBuf + 1, &(pNode->guid)) != RPC_S_OK)
            return ERROR_NOT_ENOUGH_MEMORY;

        // Read in the adapter name
        //
        dwType = REG_SZ;
        dwSize = sizeof(pszBuf);
        dwErr = RegQueryValueEx( 
                    hkeyNetCfg,
                    c_szRegValueConName,
                    NULL,
                    &dwType,
                    (LPBYTE)pszBuf,
                    &dwSize);
        if (dwErr == ERROR_SUCCESS) 
        {
            pNode->pszName = SysAllocString(pszBuf);
            if (pNode->pszName == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }

        // Read in the adapter pnp instance id
        //
        dwType = REG_SZ;
        dwSize = sizeof(pInfo->pszPnpInstance);
        dwErr = RegQueryValueEx(
                    hkeyNetCfg,
                    c_szRegValuePnpInstanceId,
                    NULL, 
                    &dwType,
                    (LPBYTE)(pInfo->pszPnpInstance),
                    &dwSize);
        if (dwErr != ERROR_SUCCESS) 
        {
            break;
        }
        
    } while (FALSE);

    // Cleanup
    {
        if (hkeyNetCfg)
        {
            RegCloseKey(hkeyNetCfg);
        }
    }        

    return dwErr;
}

//
// Filters hidden devices
//
DWORD 
ElIsNotHiddenDevice (
    IN  HKEY hkMachine,
    IN  HKEY hkDev,
    OUT HANDLE hData,        
    OUT PBOOL pbOk)
{
    DWORD dwErr, dwType = REG_DWORD, 
          dwSize = sizeof(DWORD), dwChars;

    dwErr = RegQueryValueEx ( hkDev, 
                              c_szCharacteristics,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwChars,
                              &dwSize);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;
    
    *pbOk = !(dwChars & NCF_HIDDEN);

    return NO_ERROR;
}

//
// Filter that simply loads the adapter status
//
DWORD
ElGetAdapterStatus(
    IN  HKEY hkMachine,
    IN  HKEY hkDev,
    OUT HANDLE hData,        
    OUT PBOOL pbOk)
{
    EL_ADAPTER_STATUS_INFO* pInfo = (EL_ADAPTER_STATUS_INFO*)hData;
    DEVINST DevInst;
    CONFIGRET cr = CR_SUCCESS;
    ULONG ulStatus = 0, ulProblem = 0;

    // Validate parameters
    //
    if (pInfo == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    // Find the device
    //
    cr = CM_Locate_DevNode_ExW(
            &DevInst,
            pInfo->pszPnpInstance,
            CM_LOCATE_DEVNODE_NORMAL,
            pInfo->hkCmMachine);
    if (cr != CR_SUCCESS)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Get the device status
    //
    cr = CM_Get_DevNode_Status_Ex(
            &ulStatus,
            &ulProblem,
            DevInst,
            0,
            pInfo->hkCmMachine);
    if (cr != CR_SUCCESS)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Map CM's status to our own
    //
    switch (ulProblem)
    {
        // No problem, we're connected
        case 0:
            pInfo->pAdapter->dwStatus = EL_STATUS_OK;
            break;

        // Device not present
        case CM_PROB_DEVICE_NOT_THERE:
        case CM_PROB_MOVED:
             pInfo->pAdapter->dwStatus = EL_STATUS_NOT_THERE;
             break;

        // Device was disabled via Device Manager
        case CM_PROB_HARDWARE_DISABLED:
            pInfo->pAdapter->dwStatus = EL_STATUS_HWDISABLED;
            break;

        // Device was disconnected
        case CM_PROB_DISABLED:
            pInfo->pAdapter->dwStatus = EL_STATUS_DISABLED;
            break;

        // All other problems
        default:
            pInfo->pAdapter->dwStatus = EL_STATUS_OTHER;
            break;
    }

    // Make sure this device passes the filter
    //
    *pbOk = TRUE;
    
    return NO_ERROR;
}

// 
// Returns TRUE if the given device passes the filter.
// Returns FALSE otherwise.
//
BOOL 
ElDevicePassesFilter (
    IN HKEY hkMachine,
    IN HKEY hkDev,
    IN HANDLE hData,
    IN DevFilterFuncPtr pFilter)
{
    BOOL bOk = TRUE;
    DWORD dwErr;

    dwErr = (*pFilter)(hkMachine, hkDev, hData, &bOk);
    if ((dwErr == NO_ERROR) && (bOk == TRUE))
        return TRUE;

    return FALSE;        
}

//
// Allocates additional space in a EL_NAMEMAP
//
DWORD 
ElEnlargeMap (
    IN OUT EL_NAMEMAP * pMap, 
    DWORD dwAmount) 
{
	EL_ADAPTER_INFO * pNewNodes;
	DWORD dwNewSize, i;
	
    // Figure out the new size
    dwNewSize = pMap->dwNumNodes + dwAmount;

    // Resize the array
    pNewNodes = (EL_ADAPTER_INFO *) Malloc (dwNewSize * sizeof(EL_ADAPTER_INFO));
    if (!pNewNodes)
        return ERROR_NOT_ENOUGH_MEMORY;
    ZeroMemory(pNewNodes, dwNewSize * sizeof(EL_ADAPTER_INFO));

    // Initialize the arrays.  
    CopyMemory(pNewNodes, pMap->pNodes, pMap->dwNumNodes * sizeof(EL_ADAPTER_INFO));

    // Free old data if needed
    if (pMap->dwNumNodes)
        Free (pMap->pNodes);

    // Assign the new arrays
    pMap->pNodes = pNewNodes;
    pMap->dwNumNodes = dwNewSize;
    
    return NO_ERROR;
}

//
// Find out if given server is NT 4
//
DWORD 
ElIsNt40Machine (
    IN  PWCHAR pszMachine,
    OUT PBOOL pbNt40,
    OUT HKEY* phkMachine)
{
    DWORD dwErr;

    dwErr = RegConnectRegistry (
                pszMachine, 
                HKEY_LOCAL_MACHINE, 
                phkMachine);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    return IsNt40Machine (*phkMachine, pbNt40);
}


//
//  Obtains the map of connection names to guids on the given server 
//  from its netman service.
//
//  Parameters:
//      pszServer:  Server on which to obtain map (NULL = local)
//      ppMap:      Returns array of EL_ADAPTER_INFO's
//      lpdwCount   Returns number of elements read into ppMap
//      pbNt40:     Returns whether server is nt4 installation
//
DWORD 
ElEnumLanAdapters ( 
    IN  PWCHAR pszServer,
    OUT EL_ADAPTER_INFO ** ppMap,
    OUT LPDWORD lpdwNumNodes,
    OUT PBOOL pbNt40 )
{
    GUID DevGuid = GUID_DEVCLASS_NET;
    SP_DEVINFO_DATA Device;
    HDEVINFO hDevInfo = NULL;
    HKEY hkDev = NULL, hkMachine = NULL;
    DWORD dwErr = NO_ERROR, dwIndex, dwTotal, dwSize;
    EL_NAMEMAP Map;
    WCHAR pszMachine[512], pszTemp[512];
    HANDLE hkCmMachine = NULL;
    EL_ADAPTER_STATUS_INFO AdapterStatusInfo;
    EL_ISNETCFGDEV_INFO IsNetCfgDevInfo;
    CONFIGRET cr = CR_SUCCESS;
    PMPR_IPINIP_INTERFACE_0 pIpIpTable;
    DWORD                   dwIpIpCount;
    
	// Validate parameters
	if (!ppMap || !lpdwNumNodes || !pbNt40)
	{
		return ERROR_INVALID_PARAMETER;
    }
    *pbNt40 = FALSE;

    // Initialize
    //
    ZeroMemory(&Map, sizeof(EL_NAMEMAP));

    do
    {
        // Prepare the name of the computer
        wcscpy(pszMachine, L"\\\\");
        if (pszServer) 
        {
            if (*pszServer == L'\\')
            {
                wcscpy(pszMachine, pszServer);
            }
            else
            {
                wcscat(pszMachine, pszServer);
            }
        }
        else 
        {
            dwSize = sizeof(pszTemp) / sizeof(WCHAR);
            if (GetComputerName(pszTemp, &dwSize))
            {
                wcscat(pszMachine, pszTemp);
            }
            else
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }
    
        // Find out if we're talking about an nt40 machine
        dwErr = ElIsNt40Machine(pszMachine, pbNt40, &hkMachine);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // If it is, we're done -- no mapping
        if (*pbNt40) 
        {
    		*ppMap = NULL;
    		*lpdwNumNodes = 0;
    		dwErr = NO_ERROR;
    		break;
        }

        // Connect to the connection manager rpc instance
        //
        if (pszMachine)
        {
            cr = CM_Connect_MachineW(
                    pszMachine,
                    &hkCmMachine);
            if (cr != CR_SUCCESS)
            {
                dwErr = cr;
                break;
            }
        }            

        // Otherwise, read 'em in...
        hDevInfo = SetupDiGetClassDevsExW(
                        &DevGuid,
                        NULL,
                        NULL,
                        DIGCF_PRESENT | DIGCF_PROFILE,
                        NULL,
                        pszMachine,
                        NULL);
        if (hDevInfo == INVALID_HANDLE_VALUE) 
        {
    		*ppMap = NULL;
    		*lpdwNumNodes = 0;
    		dwErr = GetLastError();
    		break;
        }

        // Enumerate the devices
        dwTotal = 0;
        for (dwIndex = 0; ; dwIndex++) 
        {
            // Get the next device
            Device.cbSize = sizeof(SP_DEVINFO_DATA);
            if (! SetupDiEnumDeviceInfo(hDevInfo, dwIndex, &Device))
            {
                break;
            }

            // Get its registry key
            hkDev = SetupDiOpenDevRegKey(
                        hDevInfo, 
                        &Device, 
                        DICS_FLAG_GLOBAL, 
                        0,
                        DIREG_DRV, 
                        KEY_READ);
            if ((hkDev == NULL) || (hkDev == INVALID_HANDLE_VALUE))
            {
                continue;
            }

            if (Map.dwNumNodes <= dwTotal + 1)
            {
                ElEnlargeMap (&Map, EL_MAP_GROW_FACTOR);
            }

            // Set up the data to be used by the filters
            //
            ZeroMemory(&IsNetCfgDevInfo, sizeof(IsNetCfgDevInfo));
            ZeroMemory(&AdapterStatusInfo, sizeof(AdapterStatusInfo));
            IsNetCfgDevInfo.pAdapter = &(Map.pNodes[dwTotal]);
            AdapterStatusInfo.pAdapter = IsNetCfgDevInfo.pAdapter;
            AdapterStatusInfo.hkCmMachine = hkCmMachine;
            AdapterStatusInfo.pszPnpInstance = (PWCHAR)
                IsNetCfgDevInfo.pszPnpInstance;
            
            // Filter out the devices we aren't interested
            // in.
            if ((ElDevicePassesFilter (hkMachine, 
                                       hkDev, 
                                       0,
                                       ElIsLanAdapter))                 &&
                (ElDevicePassesFilter (hkMachine, 
                                       hkDev, 
                                       (HANDLE)&IsNetCfgDevInfo,
                                       ElIsNetcfgDevice))               &&
                (ElDevicePassesFilter (hkMachine, 
                                       hkDev, 
                                       0,
                                       ElIsNotHiddenDevice))            &&
                (ElDevicePassesFilter (hkMachine, 
                                       hkDev, 
                                       (HANDLE)&AdapterStatusInfo,
                                       ElGetAdapterStatus))
               )
            {
                dwTotal++;                        
            }

            RegCloseKey(hkDev);
        }

        //
        // Now read out the ip in ip interfaces
        //

        if(MprSetupIpInIpInterfaceFriendlyNameEnum(pszMachine,
                                                   (BYTE **)&pIpIpTable,
                                                   &dwIpIpCount) == NO_ERROR)
        {
            DWORD   i;

            //
            // Grow the map
            //

            ElEnlargeMap (&Map, dwIpIpCount);

          
            //
            // Copy out the interface info
            //
 
            for(i = 0; i < dwIpIpCount; i++)
            {
                Map.pNodes[dwTotal].pszName = SysAllocString(pIpIpTable[i].wszFriendlyName);

                Map.pNodes[dwTotal].guid = pIpIpTable[i].Guid;

                Map.pNodes[dwTotal].dwStatus = EL_STATUS_OK;

                dwTotal++;
            }
        }
                

        // Assign the return values
        *lpdwNumNodes = dwTotal;
        if (dwTotal)
        {
            *ppMap = Map.pNodes;
        }
        else 
        {
            ElCleanup(Map.pNodes, 0);
            *ppMap = NULL;
        }
        
    } while (FALSE);

    // Cleanup
    {
        if (hkMachine)
        {
            RegCloseKey(hkMachine);
        }
        if (hDevInfo)
        {
            SetupDiDestroyDeviceInfoList(hDevInfo);
        }
        if (hkCmMachine)
        {
            CM_Disconnect_Machine(hkCmMachine);
        }
    }

    return dwErr;
}

//
// Cleans up the buffer returned from ElEnumLanAdapters
//
DWORD 
ElCleanup (
    IN EL_ADAPTER_INFO * pMap, 
    IN DWORD dwCount)
{					 
	DWORD i;

	for (i = 0; i < dwCount; i++) {
		if (pMap[i].pszName)
			SysFreeString(pMap[i].pszName);
	}

	Free (pMap);
	
	return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\hashtab.h ===
/*
    File    HashTab.h

    Definitions for creating/dealing with hash tables.

    Paul Mayfield, 3/30/98
*/

#ifndef __HashTab_h
#define __HashTab_h

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <winerror.h>

#ifdef __cplusplus
extern "C" {
#endif

// Defines signiture of hash function.  Must return an index 
// between zero and the size passed into HashTabCreate.
typedef ULONG (* HashTabHashFuncPtr)(HANDLE hData);

// Defines a function type that compares a key to an element.  This is
// used for searches. Return same as strcmp.
typedef int (* HashTabKeyCompFuncPtr)(HANDLE hKey, HANDLE hData);

// Function prototype for allocation. If this is provided in a call to 
// HashTabCreate the hash table code will allocate using this function.
// Semantics of function are similar to malloc -- return NULL on failure.
typedef PVOID (* HashTabAllocFuncPtr)(ULONG ulSize);

// Function prototype for cleanup.  Similar to free.
typedef VOID (* HashTabFreeFuncPtr)(PVOID pvData);

// Function prototype for cleaning up elements.  If provided in a call
// to HashTabCreate, then it will be called once for each element when
// HashTabCleanup is called.
typedef VOID (* HashTabFreeElemFuncPtr)(HANDLE hData);

//
// Create a hash table
//
ULONG HashTabCreate (
        IN ULONG ulSize,
        IN HashTabHashFuncPtr pHash,
        IN HashTabKeyCompFuncPtr pCompKeyAndElem,
        IN OPTIONAL HashTabAllocFuncPtr pAlloc,
        IN OPTIONAL HashTabFreeFuncPtr pFree,
        IN OPTIONAL HashTabFreeElemFuncPtr pFreeElem,
        OUT HANDLE * phHashTab );

//
// Clean up the hash table.
// 
ULONG HashTabCleanup (
        IN HANDLE hHashTab );

//                
// Insert data in a hash table under the given key
//
ULONG HashTabInsert (
        IN HANDLE hHashTab,
        IN HANDLE hKey,
        IN HANDLE hData );

//
// Removes the data associated with the given key
//
ULONG HashTabRemove (
        IN HANDLE hHashTab,
        IN HANDLE hKey);

// 
// Search in the tree for the data associated with the given key
//
ULONG HashTabFind (
        IN HANDLE hHashTab,
        IN HANDLE hKey,
        OUT HANDLE * phData );

//
// Find out how many elements are stored in the hash table
//
ULONG HashTabGetCount(
        IN  HANDLE hHashTab,
        OUT ULONG* lpdwCount );
                
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\libmain.c ===
/*
    File    libmain.c

    Contains lib main for mprapi.dll

    Paul Mayfield, 5/7/98
*/

#include <windows.h>
#include "sdolib.h"

extern CRITICAL_SECTION DsrLock;
extern CRITICAL_SECTION CfgLock;

//
// Standard Win32 lib main function gets called
// as processes and threads attach and detach.
//
// Returns TRUE if successfull, false otherwise
//
BOOL MprLibMain(
        IN HANDLE hinstDll,
        IN DWORD fdwReason,
        IN LPVOID lpReserved)
{
    switch (fdwReason) {
        case DLL_PROCESS_ATTACH:
            try {
                InitializeCriticalSection(&DsrLock);
                InitializeCriticalSection(&CfgLock);
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                return FALSE;
            }
            
            DisableThreadLibraryCalls(hinstDll);
            break;

        case DLL_PROCESS_DETACH:
            DeleteCriticalSection(&DsrLock);
            DeleteCriticalSection(&CfgLock);
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\ports.c ===
/************************************************************************
*                                                                       *
*   ports.c --  port api's for mprapi.dll                               *
*                                                                       *
*   Copyright (c) 1991-1999, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/    

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <mprapi.h>
#include <mprapip.h>
#include <stdio.h>

// Constants in the registry
//
static const WCHAR pszRegkeyNetAdapters[] = 
    L"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}";

static const WCHAR pszRegkeyModems[] = 
    L"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E96D-E325-11CE-BFC1-08002BE10318}";

static const WCHAR pszRegkeyMdmconfig[] = 
    L"Clients\\Ras";
    
static const WCHAR pszRegvalDialinUsage[] = L"EnableForRas";
static const WCHAR pszRegvalRouterUsage[] = L"EnableForRouting";
static const WCHAR pszWanEndpoints[]      = L"WanEndpoints";

//
// Definitions that specify what registry key is being enumerated
//
#define MPRPORT_F_Adapters 1
#define MPRPORT_F_Modems   2

//
// Callback definition for function that will have ras ports
// enumerated to it.
//
typedef
DWORD
(* RTRUPG_PORT_ENUM_FUNC)(
    IN HKEY hkPort,
    IN HANDLE hData);

//
// Defines data provided to the PortGetConfigKey function
//
typedef struct _PORTGETCONFIGKEYDATA 
{
    DWORD dwRootId;                 // See PORT_REGKEY_* values
    RTRUPG_PORT_ENUM_FUNC pEnum;    // cb provided to PortEnumPorts
    HANDLE hData;                   // data provided to PortEnumPorts
    
} PORTGETCONFIGKEYDATA;

//
// Typedef for callback functions for enumerating registry sub keys.
// Return NO_ERROR to continue, error code to stop.
//
// See PortEnumRegistrySubKeys.
//
typedef 
DWORD
(*REG_KEY_ENUM_FUNC_PTR)(
    IN PWCHAR pszName,          // sub key name
    IN HKEY hKey,               // sub key
    IN HANDLE hData);

//
// Sends debug trace
//
DWORD 
PortTrace(
    IN LPSTR pszTrace, ...) 
{
#if DBG
    va_list arglist;
    char szBuffer[1024], szTemp[1024];

    va_start(arglist, pszTrace);
    vsprintf(szTemp, pszTrace, arglist);
    va_end(arglist);

    sprintf(szBuffer, "MprPort: %s\n", szTemp);

    OutputDebugStringA(szBuffer);
#endif

    return NO_ERROR;
}


//
// Allocation routine for port functions
//
PVOID 
PortAlloc (
    IN  DWORD dwSize,
    IN  BOOL bZero)
{
    return LocalAlloc ((bZero) ? LPTR : LMEM_FIXED, dwSize);
}

//
// Free routine for port functions
//
VOID 
PortFree (
    IN  PVOID pvData) 
{
    LocalFree (pvData);
}    

//
// Enumerates all of the registry subkeys of a given key
//
DWORD
PortEnumRegistrySubKeys(
    IN HKEY hkRoot,
    IN PWCHAR pszPath,
    IN REG_KEY_ENUM_FUNC_PTR pCallback,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR, i, dwNameSize = 0, dwCurSize = 0;
    DWORD dwCount = 0;
    HKEY hkKey = NULL, hkCurKey = NULL;
    PWCHAR pszName = NULL;
    BOOL bCloseKey = FALSE;

    do
    {
        if (pszPath)
        {
            bCloseKey = TRUE;
            // Open the key to enumerate
            //
            dwErr = RegOpenKeyExW(
                        hkRoot,
                        pszPath,
                        0,
                        KEY_ALL_ACCESS,
                        &hkKey);
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }     
        else
        {
            bCloseKey = FALSE;
            hkKey = hkRoot;
        }

        // Find out how many sub keys there are
        //
        dwErr = RegQueryInfoKeyW(
                    hkKey,
                    NULL,
                    NULL,
                    NULL,
                    &dwCount,
                    &dwNameSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL);
        if (dwErr != ERROR_SUCCESS)
        {
            return dwErr;
        }
        dwNameSize++;

        // Allocate the name buffer
        //
        pszName = (PWCHAR) PortAlloc(dwNameSize * sizeof(WCHAR), TRUE);
        if (pszName == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Loop through the keys
        //
        for (i = 0; i < dwCount; i++)
        {
            dwCurSize = dwNameSize;
            
            // Get the name of the current key
            //
            dwErr = RegEnumKeyExW(
                        hkKey, 
                        i, 
                        pszName, 
                        &dwCurSize, 
                        0, 
                        NULL, 
                        NULL, 
                        NULL);
            if (dwErr != ERROR_SUCCESS)
            {
                continue;
            }

            // Open the subkey
            //
            dwErr = RegOpenKeyExW(
                        hkKey,
                        pszName,
                        0,
                        KEY_ALL_ACCESS,
                        &hkCurKey);
            if (dwErr != ERROR_SUCCESS)
            {
                continue;
            }

            // Call the callback
            //
            dwErr = pCallback(pszName, hkCurKey, hData);
            RegCloseKey(hkCurKey);
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }            

    } while (FALSE);

    // Cleanup
    {
        if ((hkKey != NULL) && (bCloseKey))
        {
            RegCloseKey(hkKey);
        }
        if (pszName)
        {
            PortFree(pszName);
        }
    }

    return dwErr;
}


// 
// Sets the usage of the given port
//
DWORD
PortSetUsage(
    IN HKEY hkPort,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR, dwOne = 1;
    DWORD dwUsage = *((DWORD*)hData);
    PWCHAR pszVal = NULL;
    
    do
    {
        // Determine which value to set
        //
        if (dwUsage & MPRFLAG_PORT_Router)
        {
            pszVal = (PWCHAR)pszRegvalRouterUsage;
        }
        else if (dwUsage & MPRFLAG_PORT_Dialin)
        {
            pszVal = (PWCHAR)pszRegvalDialinUsage;
        }
        else
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        PortTrace("PortSetUsage: Setting: %ls", pszVal);
        
        // Set the value
        //
        dwErr = RegSetValueExW(
                    hkPort,
                    pszVal,
                    0,
                    REG_DWORD,
                    (BYTE*)&dwOne,
                    sizeof(dwOne));
        if (dwErr != NO_ERROR)
        {
            break;
        }

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

//
// Callback function for PortEnumRegistrySubKeys that finds the 
// key in the registry suitable to have its port usage manipulated.
//
DWORD
PortGetConfigKey(
    IN PWCHAR pszName,          // sub key name
    IN HKEY hKey,               // sub key
    IN HANDLE hData)
{
    PORTGETCONFIGKEYDATA* pData = (PORTGETCONFIGKEYDATA*)hData;
    HKEY hkChild = NULL;
    DWORD dwErr = NO_ERROR;

    PortTrace("PortGetConfigKey: Entered: %ls", pszName);

    switch (pData->dwRootId)
    {
        case MPRPORT_F_Adapters:
        {
            // We only want devices with WanEndPoints, otherwise
            // they aren't ras capable.
            //
            dwErr = RegQueryValueExW(
                        hKey,
                        (PWCHAR) pszWanEndpoints,
                        NULL,
                        NULL,
                        NULL,
                        NULL);
            if (dwErr != ERROR_SUCCESS)
            {   
                dwErr = NO_ERROR;
                break;
            }

            // Call the callback.
            pData->pEnum(hKey, pData->hData);
        }
        break;

        case MPRPORT_F_Modems:
        {
            DWORD dwDisposition;
            
            // Open the appropriate child key
            //
            dwErr = RegCreateKeyEx(
                        hKey,
                        pszRegkeyMdmconfig,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hkChild,
                        &dwDisposition);
            if (dwErr != ERROR_SUCCESS)
            {
                dwErr = NO_ERROR;
                break;
            }

            // Call the callback
            pData->pEnum(hkChild, pData->hData);
        }
        break;
    }

    // Cleanup
    {
        if (hkChild)
        {
            RegCloseKey(hkChild);
        }
    }

    return dwErr;
}

//
// Enumerates all ports
//
DWORD
PortEnumPorts(
    IN RTRUPG_PORT_ENUM_FUNC pEnum,
    IN DWORD dwPortFlags,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR;
    PORTGETCONFIGKEYDATA PortData, *pData = &PortData;

    PortTrace("PortEnumPorts entered");
    
    do
    {
        // Initialize
        ZeroMemory(pData, sizeof(PORTGETCONFIGKEYDATA));
        pData->pEnum = pEnum;
        pData->hData = hData;

        if (dwPortFlags & MPRPORT_F_Adapters)
        {
            // Set usage on the network adapters (pptp, l2tp will have 
            // their port usages set through this)
            //
            PortTrace("PortEnumPorts: Enumerating adapters:");
            pData->dwRootId = MPRPORT_F_Adapters;
            dwErr = PortEnumRegistrySubKeys(
                        HKEY_LOCAL_MACHINE,
                        (PWCHAR)pszRegkeyNetAdapters,
                        PortGetConfigKey,
                        (HANDLE)pData);
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }            

        if (dwPortFlags & MPRPORT_F_Modems)
        {
            // Set usage on modem devices
            //
            PortTrace("PortEnumPorts: Enumerating modems:");
            pData->dwRootId = MPRPORT_F_Modems;
            dwErr = PortEnumRegistrySubKeys(
                        HKEY_LOCAL_MACHINE,
                        (PWCHAR)pszRegkeyModems,
                        PortGetConfigKey,
                        (HANDLE)pData);
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }            
        
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

// 
// Sets all ports on the machine to the given usage
//
DWORD
APIENTRY
MprPortSetUsage(
    IN DWORD dwUsage)
{
    DWORD dwPortFlags = MPRPORT_F_Adapters | MPRPORT_F_Modems;

    if (dwUsage == MPRFLAG_PORT_NonVpnDialin)
    {
        dwPortFlags = MPRPORT_F_Modems;
        dwUsage = MPRFLAG_PORT_Dialin;
    }

    return PortEnumPorts(PortSetUsage, dwPortFlags, (HANDLE)&dwUsage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\rpcutil.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	rpcutil.c
//
// Description: Contains RPC utiliry routines.
//
// History:     May 11,1995.	NarenG		Created original version.
//

#include <nt.h>
#include <ntrtl.h>      // For ASSERT
#include <nturtl.h>     // needed for winbase.h
#include <windows.h>    // Win32 base API's
#include <rpc.h>
#include <ntseapi.h>
#include <dimsvcp.h>    // For DIM_SERVICE_NAME
#include <ntlsa.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <nturtl.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <dimsvc.h>

//**
//
// Call:	    DimRPCBind
//
// Returns:	    NO_ERROR			- success
//		        non-sero returns from RPC calls.
//
// Description: This routine is called when it is necessary to bind to a server.
//    		    The binding is done to allow impersonation by the server since 
//		        that is necessary for the API calls.
//
DWORD
DimRPCBind( 
	IN  LPWSTR 		        lpwsServerName, 
	OUT HANDLE *            phDimServer 
)
{
    RPC_STATUS RpcStatus;
    LPWSTR     lpwsStringBinding;

    RpcStatus = RpcStringBindingCompose( 
                                    NULL, 
				                    TEXT("ncacn_np"), 
				                    lpwsServerName,
                                    TEXT("\\PIPE\\ROUTER"),
			 	                    TEXT("Security=Impersonation Static True"),
				                    &lpwsStringBinding);

    if ( RpcStatus != RPC_S_OK ) 
    {
        return( RpcStatus );
    }

    RpcStatus = RpcBindingFromStringBinding( lpwsStringBinding, 
					                         (handle_t *)phDimServer );

    RpcStringFree( &lpwsStringBinding );

    if ( RpcStatus != RPC_S_OK ) 
    {
        return( RpcStatus );
    }

    return( NO_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\rpcbind.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	rpcbind.c
//
// Description: Contains the RPC bind and un-bind routines for the DIM 
//    		Admin. client-side APIs.
//
// History:
//	        June 11,1995.	NarenG		Created original version.
//

#include <nt.h>
#include <ntrtl.h>      // For ASSERT
#include <nturtl.h>     // needed for winbase.h
#include <windows.h>    // Win32 base API's
#include <rpc.h>
#include <ntseapi.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <nturtl.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#include "dimsvc_c.c"

//**
//
// Call:	DIM_HANDLE_bind
//
// Returns: 	The binding handle is returned to the stub routine.  If the
//	    	binding is unsuccessful, a NULL will be returned.
//
// Description: This routine will simply return what was passed to it. The
//		RPC runtime will pass it a handle of the binding that was
//		obtained by calling DimRpcBind.
//
handle_t
DIM_HANDLE_bind( 
    IN DIM_HANDLE hDimServer 
) 
{
    return( (handle_t)hDimServer );
}

//**
//
// Call:	DIM_HANDLE_unbind
//
// Returns:	none
//
// Description: Unbinds from the RPC interface.
//
void
DIM_HANDLE_unbind( 
    IN DIM_HANDLE hDimServer,
    IN handle_t   hBinding
)
{

    UNREFERENCED_PARAMETER( hDimServer );
    UNREFERENCED_PARAMETER( hBinding );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\infoapi.c ===
/*++

Copyright (c) 1997, Microsoft Corporation

Module Name:

    infoapi.c

Abstract:

    This module contains code for management of configuration information
    stored in RTR_INFO_BLOCK_HEADER structures.

Author:

    Abolade Gbadegesin (t-abolag)   6-August-1997

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <mprapi.h>
#include <mprerror.h>
#include <rtinfo.h>



DWORD APIENTRY
MprInfoCreate(
    IN DWORD dwVersion,
    OUT LPVOID* lplpNewHeader
    )
{
    PRTR_INFO_BLOCK_HEADER Header;
    PRTR_INFO_BLOCK_HEADER* NewHeader = (PRTR_INFO_BLOCK_HEADER*)lplpNewHeader;

    //
    // Validate parameters
    //

    if (!lplpNewHeader) { return ERROR_INVALID_PARAMETER; }
    *lplpNewHeader = NULL;

    //
    // Perform the requested allocation
    //

    *NewHeader =
        HeapAlloc(
            GetProcessHeap(),
            0,
            FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry)
            );
    if (!*NewHeader) { return ERROR_NOT_ENOUGH_MEMORY; }

    ZeroMemory(*NewHeader, FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry));

    //
    // Initialize the new header
    //

    (*NewHeader)->Version = dwVersion;
    (*NewHeader)->Size = FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry);
    (*NewHeader)->TocEntriesCount = 0;

    return NO_ERROR;

} // MprInfoCreate



DWORD APIENTRY
MprInfoDelete(
    IN LPVOID lpHeader
    )
{
    if (!lpHeader) { return ERROR_INVALID_PARAMETER; }
    HeapFree(GetProcessHeap(), 0, lpHeader);
 
    return NO_ERROR;

} // MprInfoDelete



DWORD APIENTRY
MprInfoRemoveAll(
    IN LPVOID lpHeader,
    OUT LPVOID* lplpNewHeader
    )
{
    PRTR_INFO_BLOCK_HEADER Header = (PRTR_INFO_BLOCK_HEADER)lpHeader;
    DWORD dwErr;

    //
    // Validate parameters
    //

    if (!lpHeader) { return ERROR_INVALID_PARAMETER; }

    //
    // Create the new header
    //

    dwErr = MprInfoCreate(Header->Version, lplpNewHeader);

    return dwErr;

} // MprInfoRemoveAll



DWORD APIENTRY
MprInfoDuplicate(
    IN LPVOID lpHeader,
    OUT LPVOID* lplpNewHeader
    )
{
    PRTR_INFO_BLOCK_HEADER Header = (PRTR_INFO_BLOCK_HEADER)lpHeader;

    //
    // Validate parameters
    //

    if (!lpHeader || !lplpNewHeader) { return ERROR_INVALID_PARAMETER; }
    *lplpNewHeader = NULL;

    //
    // Allocate a new block
    //

    *lplpNewHeader = HeapAlloc(GetProcessHeap(), 0, Header->Size);
    if (!*lplpNewHeader) { return ERROR_NOT_ENOUGH_MEMORY; }

    //
    // Make the copy
    //

    RtlCopyMemory(*lplpNewHeader, lpHeader, Header->Size);

    return NO_ERROR;

} // MprInfoDuplicate



DWORD APIENTRY
MprInfoBlockAdd(
    IN LPVOID lpHeader,
    IN DWORD dwInfoType,
    IN DWORD dwItemSize,
    IN DWORD dwItemCount,
    IN LPBYTE lpItemData,
    OUT LPVOID* lplpNewHeader
    )
{
    PRTR_INFO_BLOCK_HEADER Header = (PRTR_INFO_BLOCK_HEADER)lpHeader;
    PRTR_INFO_BLOCK_HEADER* NewHeader = (PRTR_INFO_BLOCK_HEADER*)lplpNewHeader;
    DWORD i;
    LPBYTE Offset;
    DWORD Size;

    //
    // Validate parameters
    //

    if (!lpHeader ||
        !lplpNewHeader ||
        MprInfoBlockExists(lpHeader, dwInfoType) ||
        ((dwItemSize * dwItemCount) && !lpItemData)
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    *lplpNewHeader = NULL;

    //
    // Work out the new size
    //

    Size = Header->Size;
    ALIGN_LENGTH(Size);
    Size += sizeof(RTR_TOC_ENTRY);
    ALIGN_LENGTH(Size);
    Size += dwItemSize * dwItemCount;
    ALIGN_LENGTH(Size);

    //
    // Allocate the new header
    //

    *lplpNewHeader = HeapAlloc(GetProcessHeap(), 0, Size);
    if (!*lplpNewHeader) { return ERROR_NOT_ENOUGH_MEMORY; }

    ZeroMemory(*lplpNewHeader, Size);


    //
    // Copy the old header's table of contents
    //

    RtlCopyMemory(
        *lplpNewHeader,
        lpHeader,
        FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry) +
        Header->TocEntriesCount * sizeof(RTR_TOC_ENTRY)
        );


    //
    // Initialize the new block's TOC entry as the last entry
    //

    (*NewHeader)->TocEntry[Header->TocEntriesCount].InfoType = dwInfoType;
    (*NewHeader)->TocEntry[Header->TocEntriesCount].InfoSize = dwItemSize;
    (*NewHeader)->TocEntry[Header->TocEntriesCount].Count = dwItemCount;

    ++(*NewHeader)->TocEntriesCount;


    //
    // Now copy the data for the old header's TOC entries
    //

    Offset = (LPBYTE)&(*NewHeader)->TocEntry[(*NewHeader)->TocEntriesCount];
    ALIGN_POINTER(Offset);

    for (i = 0; i < Header->TocEntriesCount; i++) {

        RtlCopyMemory(
            Offset,
            GetInfoFromTocEntry(Header, &Header->TocEntry[i]),
            Header->TocEntry[i].InfoSize * Header->TocEntry[i].Count
            );

        (*NewHeader)->TocEntry[i].Offset = (DWORD)(Offset - (LPBYTE)*NewHeader);

        Offset += Header->TocEntry[i].InfoSize * Header->TocEntry[i].Count;
        ALIGN_POINTER(Offset);
    }

    //
    // Copy the new user-supplied data
    //

    RtlCopyMemory(Offset, lpItemData, dwItemSize * dwItemCount);

    (*NewHeader)->TocEntry[i].Offset = (DWORD)(Offset - (LPBYTE)*NewHeader);

    Offset += dwItemSize * dwItemCount;
    ALIGN_POINTER(Offset);


    //
    // Set the total size of the new header
    //

    (*NewHeader)->Size = (DWORD)(Offset - (LPBYTE)*NewHeader);


    return NO_ERROR;

} // MprInfoBlockAdd



DWORD APIENTRY
MprInfoBlockRemove(
    IN      LPVOID                  lpHeader,
    IN      DWORD                   dwInfoType,
    OUT     LPVOID*                 lplpNewHeader
    )
{
    PRTR_INFO_BLOCK_HEADER Header = (PRTR_INFO_BLOCK_HEADER)lpHeader;
    PRTR_INFO_BLOCK_HEADER* NewHeader = (PRTR_INFO_BLOCK_HEADER*)lplpNewHeader;
    DWORD Index;
    DWORD i;
    DWORD j;
    LPBYTE Offset;
    DWORD Size;

    //
    // Validate parameters
    //

    if (!lpHeader || !lplpNewHeader) { return ERROR_INVALID_PARAMETER; }
    *lplpNewHeader = NULL;

    //
    // Find the block to be removed
    //

    for (Index = 0; Index < Header->TocEntriesCount; Index++) {
        if (Header->TocEntry[Index].InfoType == dwInfoType) { break; }
    }

    if (Index >= Header->TocEntriesCount) { return ERROR_INVALID_PARAMETER; }

    //
    // Work out the new size
    //

    Size = Header->Size;
    ALIGN_LENGTH(Size);
    Size -= sizeof(RTR_TOC_ENTRY);
    ALIGN_LENGTH(Size);
    Size -= Header->TocEntry[Index].InfoSize * Header->TocEntry[Index].Count;
    ALIGN_LENGTH(Size);

    //
    // Allocate the new header
    //

    *NewHeader = HeapAlloc(GetProcessHeap(), 0, Size);
    if (!*NewHeader) { return ERROR_NOT_ENOUGH_MEMORY; }

    ZeroMemory(*NewHeader, Size);

    //
    // Copy the old header's table of contents header
    //

    (*NewHeader)->Version = Header->Version;
    (*NewHeader)->TocEntriesCount = Header->TocEntriesCount - 1;

    //
    // Copy the actual TOC entries, leaving out the deleted one
    //

    for (i = 0, j = 0; i < Header->TocEntriesCount; i++) {

        if (i == Index) { continue; }

        RtlCopyMemory(
            &(*NewHeader)->TocEntry[j++],
            &Header->TocEntry[i],
            sizeof(RTR_TOC_ENTRY)
            );
    }

    //
    // Now copy the data for the old header's TOC entries,
    // again leaving out the deleted one's data
    //

    Offset = (LPBYTE)&(*NewHeader)->TocEntry[(*NewHeader)->TocEntriesCount];
    ALIGN_POINTER(Offset);

    for (i = 0, j = 0; i < Header->TocEntriesCount; i++) {

        if (i == Index) { continue; }

        RtlCopyMemory(
            Offset,
            GetInfoFromTocEntry(Header, &Header->TocEntry[i]),
            Header->TocEntry[i].InfoSize * Header->TocEntry[i].Count
            );

        (*NewHeader)->TocEntry[j++].Offset =
            (DWORD)(Offset - (LPBYTE)*NewHeader);

        Offset += Header->TocEntry[i].InfoSize * Header->TocEntry[i].Count;
        ALIGN_POINTER(Offset);
    }

    //
    // Set the total size of the new header
    //

    (*NewHeader)->Size = (DWORD)(Offset - (LPBYTE)*NewHeader);

    return NO_ERROR;

} // MprInfoBlockRemove



DWORD APIENTRY
MprInfoBlockSet(
    IN LPVOID lpHeader,
    IN DWORD dwInfoType,
    IN DWORD dwItemSize,
    IN DWORD dwItemCount,
    IN LPBYTE lpItemData,
    OUT LPVOID* lplpNewHeader
    )
{
    PRTR_INFO_BLOCK_HEADER Header = (PRTR_INFO_BLOCK_HEADER)lpHeader;
    PRTR_INFO_BLOCK_HEADER* NewHeader = (PRTR_INFO_BLOCK_HEADER*)lplpNewHeader;
    DWORD Index;
    DWORD i;
    DWORD j;
    LPBYTE Offset;
    DWORD Size;

    //
    // Validate parameters
    //

    if (!lpHeader ||
        !lplpNewHeader ||
        (dwItemCount && !dwItemSize) ||
        ((dwItemSize * dwItemCount) && !lpItemData)) {

        return ERROR_INVALID_PARAMETER;
    }
    *lplpNewHeader = NULL;

    //
    // Find the block to be changed
    //

    for (Index = 0; Index < Header->TocEntriesCount; Index++) {
        if (Header->TocEntry[Index].InfoType == dwInfoType) { break; }
    }

    if (Index >= Header->TocEntriesCount) { return ERROR_INVALID_PARAMETER; }

    //
    // Work out the new size
    //

    Size = Header->Size;
    ALIGN_LENGTH(Size);
    Size -= sizeof(RTR_TOC_ENTRY);
    ALIGN_LENGTH(Size);
    Size -= Header->TocEntry[Index].InfoSize * Header->TocEntry[Index].Count;
    ALIGN_LENGTH(Size);
    Size += sizeof(RTR_TOC_ENTRY);
    ALIGN_LENGTH(Size);
    Size += dwItemSize * dwItemCount;
    ALIGN_LENGTH(Size);

    //
    // Allocate the new header
    //

    *NewHeader = HeapAlloc(GetProcessHeap(), 0, Size);
    if (!*NewHeader) { return ERROR_NOT_ENOUGH_MEMORY; }

    ZeroMemory(*NewHeader, Size);

    //
    // Copy the old header's table of contents header
    //

    (*NewHeader)->Version = Header->Version;
    (*NewHeader)->TocEntriesCount = Header->TocEntriesCount;

    //
    // Copy the actual TOC entries, leaving out the changing one
    //

    for (i = 0, j = 0; i < Header->TocEntriesCount; i++) {

        if (i == Index) { continue; }

        RtlCopyMemory(
            &(*NewHeader)->TocEntry[j++],
            &Header->TocEntry[i],
            sizeof(RTR_TOC_ENTRY)
            );
    }

    //
    // Initialize the changing block's TOC entry as the last entry
    //

    (*NewHeader)->TocEntry[j].InfoType = dwInfoType;
    (*NewHeader)->TocEntry[j].InfoSize = dwItemSize;
    (*NewHeader)->TocEntry[j].Count = dwItemCount;

    //
    // Now copy the data for the old header's TOC entries,
    // similarly leaving out the changing one.
    //

    Offset = (LPBYTE)&(*NewHeader)->TocEntry[(*NewHeader)->TocEntriesCount];
    ALIGN_POINTER(Offset);

    for (i = 0, j = 0; i < Header->TocEntriesCount; i++) {

        if (i == Index) { continue; }

        RtlCopyMemory(
            Offset, GetInfoFromTocEntry(Header, &Header->TocEntry[i]),
            Header->TocEntry[i].InfoSize * Header->TocEntry[i].Count
            );

        (*NewHeader)->TocEntry[j++].Offset =
            (DWORD)(Offset - (LPBYTE)*NewHeader);

        Offset += Header->TocEntry[i].InfoSize * Header->TocEntry[i].Count;
        ALIGN_POINTER(Offset);
    }

    //
    // Copy the new user-supplied data
    //

    RtlCopyMemory(Offset, lpItemData, dwItemSize * dwItemCount);

    (*NewHeader)->TocEntry[j].Offset = (DWORD)(Offset - (LPBYTE)*NewHeader);

    Offset += dwItemSize * dwItemCount;
    ALIGN_POINTER(Offset);

    //
    // Set the total size of the changed header
    //

    (*NewHeader)->Size = (DWORD)(Offset - (LPBYTE)*NewHeader);

    return NO_ERROR;

} // MprInfoBlockSet



DWORD APIENTRY
MprInfoBlockFind(
    IN      LPVOID                  lpHeader,
    IN      DWORD                   dwInfoType,
    OUT     LPDWORD                 lpdwItemSize,
    OUT     LPDWORD                 lpdwItemCount,
    OUT     LPBYTE*                 lplpItemData
    )
{
    PRTR_INFO_BLOCK_HEADER Header = (PRTR_INFO_BLOCK_HEADER)lpHeader;
    DWORD i;

    //
    // Validate parameters
    //

    if (!lpHeader) { return ERROR_INVALID_PARAMETER; }


    //
    // Find the block requested
    //

    for (i = 0; i < Header->TocEntriesCount; i++) {

        if (Header->TocEntry[i].InfoType == dwInfoType) { break; }
    }

    if (i >= Header->TocEntriesCount) { return ERROR_NOT_FOUND; }

    //
    // The item was found; fill in fields requested by the caller.
    //

    if (lpdwItemSize) { *lpdwItemSize = Header->TocEntry[i].InfoSize; }
    if (lpdwItemCount) { *lpdwItemCount = Header->TocEntry[i].Count; }
    if (lplpItemData) {
        *lplpItemData = GetInfoFromTocEntry(Header, &Header->TocEntry[i]);
    }

    return NO_ERROR;

} // MprInfoBlockFind


DWORD APIENTRY
MprInfoBlockQuerySize(
    IN      LPVOID                  lpHeader
)
{
    PRTR_INFO_BLOCK_HEADER Header = (PRTR_INFO_BLOCK_HEADER)lpHeader;

    if(Header == NULL)
    {
        return 0;
    }

    return Header->Size;

} // MprInfoBlockQuerySize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\rtcfg.c ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation.
//
// File:    rtcfg.c
//
// History:
//  5/4/96  Abolade-Gbadegesin      Created.
//
// Contains implementation of functions which provide access
// to the persistent store of configuration for the router-servoce.
// Currently, the router-configuration is stored in the registry.
//
// The implementations of the APIs are presented first,
// followed by the private utility functions in alphabetical order.
//
// N.B.!!!!!!:
// When modifying this file, respect its coding conventions and organization.
//  * maintain the alphabetical ordering of the routines.
//  * remain within 80 characters per line
//  * indent in steps of 4 spaces
//  * all conditional-blocks should be within braces (even single statements)
//  * SLM doesn't charge by the byte; use whitespace and comments liberally,
//    and use long, thoroughly-descriptive names.
//  * try to rely on Win32 routines (e.g. lstrcmpi, WideCharToMultiByte, etc.).
// Any code which uses a different style (whatever its merits) should be put
// in a different file.
//============================================================================


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dim.h>
#include <mprapi.h>
#include <mprapip.h>
#include <mprerror.h>
#include "rtcfg.h"
#include "guidmap.h"
#include "hashtab.h"

//
// Locks down the mprconfig api's.
//
CRITICAL_SECTION CfgLock;
#define AcquireMprConfigLock() EnterCriticalSection(&CfgLock)
#define ReleaseMprConfigLock() LeaveCriticalSection(&CfgLock)

//
// Hash table of server CB's
//
HANDLE g_htabServers = NULL;
#define SERVERCB_HASH_SIZE 13

//
// Server structure signiture (27902)
//
#define SERVERCB_SIG    0x0000cfcb

//
// Local static strings, *in alphabetical order*.
//

const WCHAR c_szConfigVersion[]           = L"ConfigVersion";
const WCHAR c_szCurrentBuildNumber[]      = L"CurrentBuildNumber";
const WCHAR c_szDLLPath[]                 = L"DLLPath";
const WCHAR c_szDialoutHours[]            = L"DialoutHours";
const WCHAR c_szEmpty[]                   = L"";
const CHAR  c_szEmptyA[]                  =  "";
const WCHAR c_szEnabled[]                 = L"Enabled";
const WCHAR c_szFilterSets[]              = L"FilterSets";
const WCHAR c_szGlobalInFilter[]          = L"GlobalInFilter";
const WCHAR c_szGlobalInfo[]              = L"GlobalInfo";
const WCHAR c_szGlobalInterfaceInfo[]     = L"GlobalInterfaceInfo";
const WCHAR c_szGlobalOutFilter[]         = L"GlobalOutFilter";
const WCHAR c_szInFilterInfo[]            = L"InFilterInfo";
const WCHAR c_szInterfaceInfo[]           = L"InterfaceInfo";
const WCHAR c_szInterfaceName[]           = L"InterfaceName";
const WCHAR c_szInterfaces[]              = L"Interfaces";
const WCHAR c_szIP[]                      = L"IP";
const WCHAR c_szIPX[]                     = L"IPX";
const WCHAR c_szMpr[]                     = L".mpr";
const CHAR  c_szMprConfigA[]              =  "MprConfig";
const WCHAR c_szNullFilter[]              = L"NullFilter";
const WCHAR c_szNt40BuildNumber[]         = L"1381";
const WCHAR c_szOutFilterInfo[]           = L"OutFilterInfo";
const WCHAR c_szParameters[]              = L"Parameters";
const WCHAR c_szPhonebook[]               = L"Phonebook";
const WCHAR c_szProtocolId[]              = L"ProtocolId";
const WCHAR c_szRemoteAccess[]            = L"RemoteAccess";
const WCHAR c_szRouter[]                  = L"Router";
const WCHAR c_szRouterManagers[]          = L"RouterManagers";
const WCHAR c_szRouterPbkPath[]           =
    L"\\ADMIN$\\System32\\RAS\\Router.pbk";
const WCHAR c_szRouterType[]              = L"RouterType";
const WCHAR c_szRemoteSys32[]             = L"\\ADMIN$\\System32\\";
const WCHAR c_szStamp[]                   = L"Stamp";
const WCHAR c_szSystemCCSServices[]       =
    L"System\\CurrentControlSet\\Services";
const WCHAR c_szType[]                    = L"Type";
const WCHAR c_szUncPrefix[]               = L"\\\\";
const WCHAR c_szWinVersionPath[]          =
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";

//
// Defines call back function type for EnumLanInterfaces below
//

typedef DWORD
(*PENUMIFCALLBACKFUNC)(
    SERVERCB*,
    HKEY,
    DWORD
    );

typedef
HRESULT 
(APIENTRY* PINSTALLSERVERFUNC)();

//
// Local prototypes
//
DWORD 
FormatServerNameForMprCfgApis(
    IN  PWCHAR  pszServer, 
    OUT PWCHAR* ppszServer);

DWORD
ServerCbAdd(
    IN SERVERCB* pserver);

int 
ServerCbCompare(
    IN HANDLE hKey, 
    IN HANDLE hData);

DWORD
ServerCbDelete(
    IN SERVERCB* pserver);

DWORD 
ServerCbFind(
    IN  PWCHAR  pszServer, 
    OUT SERVERCB** ppServerCB);
    
ULONG 
ServerCbHash(
    IN HANDLE hData);

#define MprConfigServerValidateCb(_x) \
    (((_x) && ((_x)->dwSigniture == SERVERCB_SIG)) ? NO_ERROR : ERROR_INVALID_PARAMETER)

//----------------------------------------------------------------------------
// Function:    MprConfigServerInstall
//
// Presets any configuration values needed before starting the router service.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigServerInstall(
    IN DWORD dwLevel,
    IN PVOID pBuffer)
{
    HRESULT hr = S_OK;
    DWORD dwErr = NO_ERROR;
    HINSTANCE hLib = NULL;
    PINSTALLSERVERFUNC pInstall = NULL;

    if ((dwLevel != 0) || (pBuffer != NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    do
    {
        hLib = LoadLibraryW(L"mprsnap.dll");
        if (hLib == NULL)
        {
            dwErr = GetLastError();
            break;
        }

        pInstall = (PINSTALLSERVERFUNC) 
            GetProcAddress(hLib, "MprConfigServerInstallPrivate");    
        if (pInstall == NULL)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        hr = pInstall();
        dwErr = (HRESULT_FACILITY(hr) == FACILITY_WIN32) ? 
                HRESULT_CODE(hr)                         : 
                hr;
        
    } while (FALSE);

    // Cleanup
    //
    {
        if (hLib)
        {
            FreeLibrary(hLib);
        }
    }
    
    return dwErr;
}

//----------------------------------------------------------------------------
// Function:    MprConfigServerConnect
//
// Connects to the store for the router-service on 'lpwsServerName'.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigServerConnect(
    IN      LPWSTR                  lpwsServerName,
    OUT     HANDLE*                 phMprConfig
    )
{

    DWORD dwErr;
    SERVERCB* pserver = NULL;
    PWCHAR pszServerNameFmt = NULL;

    // Validate and initialzie
    //
    if (!phMprConfig) { return ERROR_INVALID_PARAMETER; } 

    *phMprConfig = NULL;

    dwErr = FormatServerNameForMprCfgApis(
                lpwsServerName, 
                &pszServerNameFmt);

    if (dwErr != NO_ERROR) { return dwErr; }
    

    // Get the lock
    //
    AcquireMprConfigLock();
    
    do {

        // 
        // See if a handle to the given server is already available
        //
        dwErr = ServerCbFind(pszServerNameFmt, &pserver);
        
        if (dwErr == NO_ERROR) 
        {
            pserver->dwRefCount++;
            *phMprConfig = (HANDLE)pserver;
            
            break;
        }

        if (dwErr != ERROR_NOT_FOUND) { break; }

        //
        // attempt to allocate a context block for the server
        //

        pserver = (SERVERCB*)Malloc(sizeof(*pserver));

        if (!pserver) 
        { 
            dwErr = ERROR_NOT_ENOUGH_MEMORY; 
            break;
        }

        //
        // initialize the context block allocated
        //

        ZeroMemory(pserver, sizeof(*pserver));

        InitializeListHead(&pserver->lhTransports);
        InitializeListHead(&pserver->lhInterfaces);
        pserver->lpwsServerName = pszServerNameFmt;
        pserver->dwRefCount = 1;
        pserver->dwSigniture = SERVERCB_SIG;

        // 
        // Initialize the guid to friendly name mapper
        //

        dwErr = GuidMapInit(pserver->lpwsServerName, &(pserver->hGuidMap));
        
        if (dwErr != NO_ERROR) { break; }

        //
        // see if the server-name was specified
        //

        if (!lpwsServerName || !*lpwsServerName) {

            //
            // no server-name (or empty server name), connect to local machine
            //

            pserver->hkeyMachine = HKEY_LOCAL_MACHINE;

            dwErr = NO_ERROR;
        }
        else {

            //
            // attempt to connect to the remote registry
            //
    
            dwErr = RegConnectRegistry(
                        lpwsServerName, HKEY_LOCAL_MACHINE,
                        &pserver->hkeyMachine
                        );

            //
            // if an error occurred, break
            //
    
            if (dwErr != NO_ERROR) { break; }
        }

        // Add the server to the global table
        //
        dwErr = ServerCbAdd(pserver);

        if (dwErr != NO_ERROR) { break; }
        
        *phMprConfig = (HANDLE)pserver;

        dwErr = NO_ERROR;

    } while(FALSE);


    //
    // an error occurred, so return
    //

    if (dwErr != NO_ERROR)
    {
        if (pserver != NULL) {
        
            MprConfigServerDisconnect((HANDLE)pserver);
        }
    }        

    ReleaseMprConfigLock();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MprConfigServerDisconnect
//
// Disconnects from the store for the router-service 'hMprConfig'.
// This closes all handles opened to by passing 'hMprConfig' 
// to the MprConfig APIs.
//----------------------------------------------------------------------------

VOID APIENTRY
MprConfigServerDisconnect(
    IN      HANDLE                  hMprConfig
    )
{

    SERVERCB* pserver;
    LIST_ENTRY *ple, *phead;

    pserver = (SERVERCB*)hMprConfig;

    if (MprConfigServerValidateCb(pserver) != NO_ERROR) { return; }

    // Get the lock
    //
    AcquireMprConfigLock();
    
    // Decrement the ref count
    //
    pserver->dwRefCount--;
    
    if (pserver->dwRefCount > 0) 
    { 
        ReleaseMprConfigLock();
        return; 
    }

    // Remove the SERVERCB from the global table
    //
    ServerCbDelete( pserver );
    
    ReleaseMprConfigLock();

    //
    // clean up all the transport objects
    //

    phead = &pserver->lhTransports;

    while (!IsListEmpty(phead)) {

        //
        // remove the first transport object
        //

        TRANSPORTCB* ptransport;

        ple = RemoveHeadList(phead);

        ptransport = CONTAINING_RECORD(ple, TRANSPORTCB, leNode);


        //
        // clean up the object
        //

        FreeTransport(ptransport);
    }


    //
    // clean up all the interface objects
    //

    phead = &pserver->lhInterfaces;

    while (!IsListEmpty(phead)) {

        //
        // remove the first interface object
        //

        INTERFACECB* pinterface;

        ple = RemoveHeadList(phead);

        pinterface = CONTAINING_RECORD(ple, INTERFACECB, leNode);


        //
        // clean up the object
        //

        FreeInterface(pinterface);
    }


    //
    // clean up the server object's registry keys
    //

    if (pserver->hkeyParameters) { RegCloseKey(pserver->hkeyParameters); }
    if (pserver->hkeyTransports) { RegCloseKey(pserver->hkeyTransports); }
    if (pserver->hkeyInterfaces) { RegCloseKey(pserver->hkeyInterfaces); }


    //
    // if connected to a remote registry, close the connection
    //

    if (pserver->hkeyMachine && pserver->hkeyMachine != HKEY_LOCAL_MACHINE) {
        RegCloseKey(pserver->hkeyMachine);
    }


    //
    // clean up the interface name mapper
    //
    if (pserver->hGuidMap != NULL) {
        GuidMapCleanup (pserver->hGuidMap, TRUE);
    }


    Free0(pserver->lpwsServerName);

    Free(pserver);

    return;
}



//----------------------------------------------------------------------------
// Function:    MprConfigBufferFree
//
// Frees a buffer allocated by a 'GetInfo' or 'Enum' call.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigBufferFree(
    IN      LPVOID                  pBuffer
    )
{

    Free0(pBuffer);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    MprConfigServerRestore
//
// Restores configuration saved by 'MprConfigServerBackup'.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigServerRestore(
    IN      HANDLE                  hMprConfig,
    IN      LPWSTR                  lpwsPath
    )
{

    INT length;
    DWORD dwErr;
    CHAR szKey[64];
    CHAR* pszFile;
    CHAR* pszValue;
    SERVERCB* pserver;
    WCHAR pwsLocalComputerName[128];
    DWORD dwLocalComputerSize = sizeof(pwsLocalComputerName) / sizeof(WCHAR);
    BOOL bRemote;

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock();

    dwErr = NO_ERROR;

    //
    // Record whether we are restoring the config of a remote machine
    //

    if (!GetComputerName(pwsLocalComputerName, &dwLocalComputerSize)) {
        ReleaseMprConfigLock();
        return ERROR_CAN_NOT_COMPLETE;
    }

    bRemote =
        (pserver->lpwsServerName != NULL) &&
        (*pserver->lpwsServerName != 0) &&
        (lstrcmpi(pserver->lpwsServerName, pwsLocalComputerName) != 0);

    //
    // We require full UNC path for remote load/save
    //

    if (bRemote) {
        ReleaseMprConfigLock();
        return ERROR_NOT_SUPPORTED;
#if 0
        if ((pserver->lpwsServerName == NULL) ||
            (*(pserver->lpwsServerName) == 0) ||
            (wcsncmp(lpwsPath, c_szUncPrefix, 2) != 0)) {             
            ReleaseMprConfigLock();
            return ERROR_BAD_PATHNAME;
        }
#endif
    }

    //
    // Make sure that the Parameters key, Interfaces key, and
    // RouterManagers key are open.
    //

    if (!pserver->hkeyInterfaces) {

        dwErr = AccessRouterSubkey(
                    pserver->hkeyMachine, c_szInterfaces, TRUE,
                    &pserver->hkeyInterfaces
                    );
    }

    if (!pserver->hkeyTransports) {

        dwErr = AccessRouterSubkey(
                    pserver->hkeyMachine, c_szRouterManagers, TRUE,
                    &pserver->hkeyTransports
                    );
    }

    if (!pserver->hkeyParameters) {

        dwErr = AccessRouterSubkey(
                    pserver->hkeyMachine, c_szParameters, TRUE,
                    &pserver->hkeyParameters
                    );
    }


    //
    // Allocate space to hold the full pathname to the .MPR file
    //

    length = lstrlen(lpwsPath) + lstrlen(c_szMpr) + 1;

    pszFile = Malloc(length * sizeof ( WCHAR ) );
    if (!pszFile) 
    { 
        ReleaseMprConfigLock();
        return ERROR_NOT_ENOUGH_MEMORY; 
    }


    //
    // Allocate space to hold the values to be read from the .MPR file
    //

    length = (lstrlen(lpwsPath)+lstrlen(c_szRouterManagers)+1)*sizeof(WCHAR);

    pszValue = Malloc( length );
    
    if (!pszValue) 
    { 
        ReleaseMprConfigLock();
        Free(pszFile); 
        return ERROR_NOT_ENOUGH_MEMORY; 
    }


    //
    // Enable the current process's backup privilege.
    //

    EnableBackupPrivilege(TRUE, SE_RESTORE_NAME);

    dwErr = NO_ERROR;

    do {
    
        wsprintfA(pszFile, "%ls%ls", lpwsPath, c_szMpr);

        // 
        // First check the version.  If there is no version data,
        // then this is a saved nt4 router config.  
        //
        wsprintfA(szKey, "%ls", c_szConfigVersion);
        GetPrivateProfileStringA(
            c_szMprConfigA, szKey, c_szEmptyA, pszValue, length, pszFile
            );
        if (strcmp(pszValue, c_szEmptyA) == 0) {
            dwErr = ERROR_ROUTER_CONFIG_INCOMPATIBLE;
            break;
        }
    
        //
        // Restore the registry keys
        //
    
        wsprintfA(szKey, "%ls", c_szParameters);
        GetPrivateProfileStringA(
            c_szMprConfigA, szKey, c_szEmptyA, pszValue, length, pszFile
            );
        dwErr = RegRestoreKeyA(pserver->hkeyParameters, pszValue, 0);

        wsprintfA(szKey, "%ls", c_szRouterManagers);
        GetPrivateProfileStringA(
            c_szMprConfigA, szKey, c_szEmptyA, pszValue, length, pszFile
            );
        dwErr = RegRestoreKeyA(pserver->hkeyTransports, pszValue, 0);

        wsprintfA(szKey, "%ls", c_szInterfaces);
        GetPrivateProfileStringA(
            c_szMprConfigA, szKey, c_szEmptyA, pszValue, length, pszFile
            );
        //dwErr = RegRestoreKeyA(pserver->hkeyInterfaces, pszValue, 0);
        dwErr = RestoreAndTranslateInterfaceKey(pserver, pszValue, 0);


        //
        // Restore the phonebook file
        //

        wsprintfA(szKey, "%ls", c_szPhonebook);
        GetPrivateProfileStringA(
            c_szMprConfigA, szKey, c_szEmptyA, pszValue, length, pszFile
            );

        {
            CHAR* pszTemp;
            INT   cchSize;

            cchSize = lstrlen(c_szUncPrefix) +
                      lstrlen(c_szRouterPbkPath) + 1;
            if (pserver->lpwsServerName) {
                cchSize += lstrlen(pserver->lpwsServerName);
            }
            else {
                cchSize += lstrlen(pwsLocalComputerName);
            }

            pszTemp = Malloc(cchSize * sizeof(WCHAR));
    
            if (!pszTemp) { dwErr = ERROR_NOT_ENOUGH_MEMORY; break; }

            if (pserver->lpwsServerName) {
                if (*(pserver->lpwsServerName) != L'\\') {
                    wsprintfA(
                        pszTemp, "\\\\%ls%ls", pserver->lpwsServerName,
                        c_szRouterPbkPath
                        );
                }
                else {
                    wsprintfA(
                        pszTemp, "%ls%ls", pserver->lpwsServerName,
                        c_szRouterPbkPath
                        );
                }
            }
            else {
                wsprintfA(
                    pszTemp, "\\\\%ls%ls", pwsLocalComputerName,
                    c_szRouterPbkPath
                    );
            }
    
            CopyFileA(pszValue, pszTemp, FALSE);

            Free(pszTemp);
        }

    } while(FALSE);

    //
    // Disable backup privileges
    //

    EnableBackupPrivilege(FALSE, SE_RESTORE_NAME);

    ReleaseMprConfigLock();
    
    Free(pszValue);
    Free(pszFile);

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    MprConfigServerBackup
//
// Backs up a router's configuration.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigServerBackup(
    IN      HANDLE                  hMprConfig,
    IN      LPWSTR                  lpwsPath
    )
{

    int length;
    DWORD dwErr;
    HANDLE hfile;
    BOOL bSuccess, bRemote;
    WCHAR *pwsBase, *pwsTemp, *pwsComputer;
    SERVERCB* pserver;
    WCHAR pwsLocalComputerName[128];
    DWORD dwLocalComputerSize = sizeof(pwsLocalComputerName) / sizeof(WCHAR);
    OSVERSIONINFO Version;

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock();
    
    dwErr = NO_ERROR;

    //
    // Record whether we are saving the config of a remote machine
    //

    if (!GetComputerName(pwsLocalComputerName, &dwLocalComputerSize)) {
        ReleaseMprConfigLock();
        return ERROR_CAN_NOT_COMPLETE;
    }

    bRemote =
        (pserver->lpwsServerName != NULL) &&
        (*(pserver->lpwsServerName) == 0) &&
        (lstrcmpi(pserver->lpwsServerName, pwsLocalComputerName) != 0);

    //
    // We require full UNC path for remote load/save
    //

    if (bRemote) {
        ReleaseMprConfigLock();
        return ERROR_NOT_SUPPORTED;
#if 0
        if ((pserver->lpwsServerName == NULL) ||
            (*(pserver->lpwsServerName) == 0) ||
            (wcsncmp(lpwsPath, c_szUncPrefix, 2) != 0)) {             
            ReleaseMprConfigLock();
            return ERROR_BAD_PATHNAME;
        }
#endif
    }

    //
    // Make sure that the Parameters key, Interfaces key, and
    // RouterManagers key are open.
    //

    if (!pserver->hkeyInterfaces) {

        dwErr = AccessRouterSubkey(
                    pserver->hkeyMachine, c_szInterfaces, TRUE,
                    &pserver->hkeyInterfaces
                    );
    }

    if (!pserver->hkeyTransports) {

        dwErr = AccessRouterSubkey(
                    pserver->hkeyMachine, c_szRouterManagers, TRUE,
                    &pserver->hkeyTransports
                    );
    }

    if (!pserver->hkeyParameters) {

        dwErr = AccessRouterSubkey(
                    pserver->hkeyMachine, c_szParameters, TRUE,
                    &pserver->hkeyParameters
                    );
    }


    //
    // Allocate enough space to hold any of the strings
    // to be constructed below
    //

    pwsBase = Malloc(
                (lstrlen(lpwsPath) + lstrlen(c_szRouterManagers) + 1) *
                sizeof(WCHAR)
                );
    if (!pwsBase) { ReleaseMprConfigLock(); return ERROR_NOT_ENOUGH_MEMORY; }

    //
    // Enable the current process's backup privileges
    //

    EnableBackupPrivilege(TRUE, SE_BACKUP_NAME);
    
    do {

        //
        // Save each key to a filename made from the specified name
        // See documentation for RegSaveKey and RegRestoreKey for information
        // on which 'lpwsPath' must not contain an extension.
        //
        // Save the 'Parameters' key
        //

        lstrcpy(pwsBase, lpwsPath);
        lstrcat(pwsBase, c_szParameters);
        DeleteFile(pwsBase);
        dwErr = RegSaveKey(pserver->hkeyParameters, pwsBase, NULL);
                  
        if (dwErr != NO_ERROR) { break; }
    
        //
        // Save the 'RouterManagers' key
        //
    
        lstrcpy(pwsBase, lpwsPath);
        lstrcat(pwsBase, c_szRouterManagers);
        DeleteFile(pwsBase);
        dwErr = RegSaveKey(pserver->hkeyTransports, pwsBase, NULL);
                  
        if (dwErr != NO_ERROR) { break; }
        
    
        //
        // Save the 'Interfaces' key
        //
    
        lstrcpy(pwsBase, lpwsPath);
        lstrcat(pwsBase, c_szInterfaces);
        DeleteFile(pwsBase);
        dwErr = TranslateAndSaveInterfaceKey (pserver, pwsBase, NULL);
    
        if (dwErr != NO_ERROR) { break; }
    
        //
        // Copy the phonebook file;
        // first we construct the path to the remote machine's phonebook file.
        //

        lstrcpy(pwsBase, lpwsPath);
        lstrcat(pwsBase, c_szPhonebook);

        // 
        // Construct the computer name 
        //

        if (pserver->lpwsServerName && *(pserver->lpwsServerName)) {
            pwsComputer =
                Malloc(
                    (lstrlen(pserver->lpwsServerName) + 3) * sizeof(WCHAR)
                    );
            lstrcpy(pwsComputer, c_szUncPrefix);
            lstrcat(pwsComputer, pserver->lpwsServerName);
        }
        else {
            pwsComputer =
                Malloc(
                    (lstrlen(pwsLocalComputerName) + 3) * sizeof(WCHAR)
                    );
            lstrcpy(pwsComputer, c_szUncPrefix);
            lstrcat(pwsComputer, pwsLocalComputerName);
        }

        pwsTemp = Malloc( 
                    (lstrlen(pwsComputer) + lstrlen(c_szRouterPbkPath) + 1) *
                    sizeof(WCHAR)
                    );

        if (!pwsTemp) { dwErr = ERROR_NOT_ENOUGH_MEMORY; break; }

        lstrcpy(pwsTemp, pwsComputer);
        lstrcat(pwsTemp, c_szRouterPbkPath);

        if (!(bSuccess = CopyFile(pwsTemp, pwsBase, FALSE))) {

            dwErr = GetLastError();

            if (dwErr == ERROR_FILE_NOT_FOUND) {

                hfile = CreateFile(
                            pwsBase, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL, NULL
                            );
        
                if (hfile == INVALID_HANDLE_VALUE) {
                    dwErr = GetLastError(); break;
                }
        
                CloseHandle(hfile);

                dwErr = NO_ERROR; bSuccess = TRUE;
            }
        }

        Free0(pwsComputer);
        Free(pwsTemp);

        if (!bSuccess) { break; }

    
        //
        // Create a file with the specified name and fill in information.
        //

        lstrcpy(pwsBase, lpwsPath);
        lstrcat(pwsBase, c_szMpr);

        hfile = CreateFile(
                    pwsBase, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL, NULL
                    );

        if (hfile == INVALID_HANDLE_VALUE) { dwErr = GetLastError(); break; }

        CloseHandle(hfile);

        //
        // Now write the '[MprConfig]' section of the file
        // The section looks like this:
        //
        //  [MprConfig]
        //  Parameters=<file>Parameters
        //  RouterManagers=<file>RouterManagers
        //  Interfaces=<file>Interfaces
        //  Phonebook=<file>Phonebook
        //  ConfigVersion=<build>              // NT 5 and on only
        //
        // What we pass to WritePrivateProfileSectionA is a NULL-separated
        // list of 4 strings.
        //
        // Note that the following uses ANSI strings, not Unicode.
        //

        {
            CHAR* psz;
            CHAR* pszTemp;
            CHAR* pszFile;

            //
            // Make an ANSI copy of the filename.
            // allocate len*sizeof ( WCHAR ) to be safe
            // otherwise this will break DBCS
            //

            pszFile = Malloc((lstrlen(pwsBase) + 1) * sizeof (WCHAR));
            if (!pszFile) { break; }

            wsprintfA(pszFile, "%ls", pwsBase);


            //
            // Allocate the list to be passed to WritePrivateProfileSection
            //

            length = 1;
            length += lstrlen(lpwsPath) + 2 * lstrlen(c_szParameters) + 2;
            length += lstrlen(lpwsPath) + 2 * lstrlen(c_szRouterManagers) + 2;
            length += lstrlen(lpwsPath) + 2 * lstrlen(c_szInterfaces) + 2;
            length += lstrlen(lpwsPath) + 2 * lstrlen(c_szPhonebook) + 2;
            length += 5                 + 2 * lstrlen(c_szConfigVersion) + 2;

            length = length * sizeof (WCHAR);

            pszTemp = Malloc(length);

            if (!pszTemp) {

                Free(pszFile); dwErr = ERROR_NOT_ENOUGH_MEMORY; break;
            }


            //
            // Fill the list with strings, one for each line in the final file
            //

            ZeroMemory(pszTemp, length);
            ZeroMemory(&Version, sizeof(Version));
            
            Version.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
            GetVersionEx(&Version);

            psz = pszTemp;
            wsprintfA(
                psz, "%ls=%ls%ls", c_szParameters, lpwsPath, c_szParameters
                );
            psz += lstrlenA(psz) + 1;
            wsprintfA(
                psz, "%ls=%ls%ls", c_szRouterManagers, lpwsPath,
                c_szRouterManagers
                );
            psz += lstrlenA(psz) + 1;
            wsprintfA(
                psz, "%ls=%ls%ls", c_szInterfaces, lpwsPath, c_szInterfaces
                );
            psz += lstrlenA(psz) + 1;
            wsprintfA(
                psz, "%ls=%ls%ls", c_szPhonebook, lpwsPath, c_szPhonebook
                );
            psz += lstrlenA(psz) + 1;
            wsprintfA(
                psz, "%ls=%d", c_szConfigVersion, Version.dwBuildNumber 
                );
                
            //
            // Commit the list of strings to the file
            //

            if (!WritePrivateProfileSectionA(
                    c_szMprConfigA, pszTemp, pszFile
                    )) {

                dwErr = GetLastError();
            }

            Free(pszTemp);
            Free(pszFile);
        }

    } while(FALSE);

    //
    // Disable backup privileges
    //

    EnableBackupPrivilege(FALSE, SE_BACKUP_NAME);
    
    ReleaseMprConfigLock();
    
    Free0(pwsBase);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MprConfigServerRefresh
//
// Reloads all loaded lists, and flushes all cached objects which are marked
// for deletion.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigServerRefresh(
    IN      HANDLE                  hMprConfig
    )
{

    DWORD dwErr;
    SERVERCB* pserver;
    TRANSPORTCB* ptransport;
    INTERFACECB* pinterface;
    IFTRANSPORTCB* piftransport;
    LIST_ENTRY *ple, *phead, *ple2, *phead2;

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock();
    
    //
    // If the router-level parameters are loaded, refresh them
    //

    if (pserver->bParametersLoaded) {

        dwErr = LoadParameters(pserver);

        if (dwErr != NO_ERROR) { ReleaseMprConfigLock(); return dwErr; }
    }


    //
    // If the transports-list is loaded, refresh it.
    //

    if (pserver->bTransportsLoaded) {

        dwErr = LoadTransports(pserver);

        if (dwErr != NO_ERROR) { ReleaseMprConfigLock(); return dwErr; }
    }


    //
    // If the interfaces-list is loaded, refresh it.
    //

    if (pserver->bInterfacesLoaded) {

        dwErr = LoadInterfaces(pserver);

        if (dwErr != NO_ERROR) { ReleaseMprConfigLock(); return dwErr; }


        //
        // Reload the interface-transports list for each interface
        // which has its interface-transports list loaded.
        //

        phead = &pserver->lhInterfaces;

        for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

            pinterface = CONTAINING_RECORD(ple, INTERFACECB, leNode);

            if (pinterface->bIfTransportsLoaded) {

                dwErr = LoadIfTransports(pinterface);

                if (dwErr != NO_ERROR) { ReleaseMprConfigLock(); return dwErr; }
            }
        }
    }


    //
    // Clean up all the transport objects marked for deletion
    //

    phead = &pserver->lhTransports;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        ptransport = CONTAINING_RECORD(ple, TRANSPORTCB, leNode);

        if (!ptransport->bDeleted) { continue; }

        //
        // Clean up the object, adjusting our list-pointer back by one.
        //

        ple = ple->Blink; RemoveEntryList(&ptransport->leNode);

        FreeTransport(ptransport);
    }


    //
    // Clean up all the interface objects marked for deletion
    //

    phead = &pserver->lhInterfaces;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pinterface = CONTAINING_RECORD(ple, INTERFACECB, leNode);

        if (pinterface->bDeleted) {

            //
            // Clean up the object, adjusting our list-pointer back by one.
            //
    
            ple = ple->Blink; RemoveEntryList(&pinterface->leNode);

            FreeInterface(pinterface);

            continue;
        }


        //
        // Clean up all the interface-transport objects marked for deletion
        //

        phead2 = &pinterface->lhIfTransports;

        for (ple2 = phead2->Flink; ple2 != phead2; ple2 = ple2->Flink) {

            piftransport = CONTAINING_RECORD(ple, IFTRANSPORTCB, leNode);

            if (!piftransport->bDeleted) { continue; }


            //
            // Clean up the object, adjusting the list-pointer back by one.
            //

            ple2 = ple2->Blink; RemoveEntryList(&piftransport->leNode);

            FreeIfTransport(piftransport);
        }
    }

    GuidMapCleanup (pserver->hGuidMap, TRUE);
    pserver->hGuidMap = NULL;

    // Now that we've cleaned it up, we have to reinitialize it
    // since the map gets overwritten (to all 0's) let's just
    // reinit the whole damned thing.
    GuidMapInit(pserver->lpwsServerName, &(pserver->hGuidMap));        

    ReleaseMprConfigLock();

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    MprConfigServerGetInfo
//
// Retrieves router-level information from the registry.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigServerGetInfo(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    OUT     LPBYTE*                 lplpBuffer
    )
{

    DWORD dwErr;
    SERVERCB *pserver;
    MPR_SERVER_0* pItem;

    if (!hMprConfig ||
        (dwLevel != 0) ||
        !lplpBuffer) { return ERROR_INVALID_PARAMETER; }

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock();

    //
    // If the parameters aren't loaded, load them now
    //

    if (!pserver->bParametersLoaded ||
        TimeStampChanged(
            pserver->hkeyParameters, &pserver->ftParametersStamp)) {

        dwErr = LoadParameters(pserver);

        if (dwErr != NO_ERROR) { ReleaseMprConfigLock(); return dwErr; }

        pserver->bParametersLoaded = TRUE;
    }


    *lplpBuffer = NULL;


    //
    // Allocate memory for the information
    //

    pItem = (MPR_SERVER_0*)Malloc(sizeof(*pItem));

    if (!pItem) { ReleaseMprConfigLock(); return ERROR_NOT_ENOUGH_MEMORY; }

    ZeroMemory(pItem, sizeof(*pItem));


    //
    // Copy the server-info from the context block
    //

    pItem->fLanOnlyMode =
        (pserver->fRouterType == 0x00000002) ? TRUE : FALSE;


    *lplpBuffer = (LPBYTE)pItem;

    ReleaseMprConfigLock(); 

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    MprConfigTransportCreate
//
// Adds a router-transport to the store for the router-service.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigTransportCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    IN      LPWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      LPWSTR                  lpwsDLLPath                 OPTIONAL,
    OUT     HANDLE*                 phRouterTransport
    )
{

    DWORD dwErr;
    SERVERCB *pserver;
    TRANSPORTCB* ptransport;
    LIST_ENTRY *ple, *phead;


    if (!phRouterTransport) {return ERROR_INVALID_PARAMETER;}

    *phRouterTransport = NULL;

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock();     

    //
    // If the list of transports is not loaded, load it
    //

    if (!pserver->bTransportsLoaded ||
        TimeStampChanged(
            pserver->hkeyTransports, &pserver->ftTransportsStamp)) {
    
        dwErr = LoadTransports(pserver);
    
        if (dwErr != NO_ERROR) { ReleaseMprConfigLock(); return dwErr; }

        pserver->bTransportsLoaded = TRUE;
    }


    //
    // Search the list of transports for the one to be created
    //

    ptransport = NULL;
    phead = &pserver->lhTransports;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        ptransport = CONTAINING_RECORD(ple, TRANSPORTCB, leNode);

        if (ptransport->bDeleted) { continue; }

        if (ptransport->dwTransportId >= dwTransportId) { break; }
    }


    //
    // If the transport already exists, do a SetInfo instead
    //

    if (ptransport && ptransport->dwTransportId == dwTransportId) {

        *phRouterTransport = (HANDLE)ptransport;

        dwErr = MprConfigTransportSetInfo(
                    hMprConfig,
                    *phRouterTransport,
                    pGlobalInfo,
                    dwGlobalInfoSize,
                    pClientInterfaceInfo,
                    dwClientInterfaceInfoSize,
                    lpwsDLLPath
                    );
                    
        ReleaseMprConfigLock(); 
        
        return dwErr;
    }


    //
    // Allocate a new context block
    //

    ptransport = (TRANSPORTCB*)Malloc(sizeof(*ptransport));

    if (!ptransport) { ReleaseMprConfigLock(); return ERROR_NOT_ENOUGH_MEMORY; }


    do {

        DWORD dwDisposition;
        const WCHAR *lpwsKey;
        WCHAR wszTransport[10];

        //
        // Initialize the transport context
        //

        ZeroMemory(ptransport, sizeof(*ptransport));

        ptransport->dwTransportId = dwTransportId;



        //
        // If the server doesn't have the RouterManagers key open, create it
        //

        if (!pserver->hkeyTransports) {

            dwErr = AccessRouterSubkey(
                        pserver->hkeyMachine, c_szRouterManagers, TRUE,
                        &pserver->hkeyTransports
                        );

            if (dwErr != NO_ERROR) { break; }
        }



        //
        // If the transport name is specified, use it as the key name;
        // otherwise, if the transport ID is recognized, use its string;
        // otherwise, convert the transport ID to a string and use that
        //

        if (lpwsTransportName && lstrlen(lpwsTransportName)) {
            lpwsKey = lpwsTransportName;
        }
        else
        if (dwTransportId == PID_IP) {
            lpwsKey = c_szIP;
        }
        else
        if (dwTransportId == PID_IPX) {
            lpwsKey = c_szIPX;
        }
        else {
    
            wsprintf(wszTransport, L"%d", dwTransportId);

            lpwsKey = wszTransport;
        }


        ptransport->lpwsTransportKey = StrDupW(lpwsKey);

        if (!ptransport->lpwsTransportKey) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY; break;
        }


        //
        // Create a key for the transport in the registry
        //

        dwErr = RegCreateKeyEx(
                    pserver->hkeyTransports, lpwsKey, 0, NULL, 0,
                    KEY_READ | KEY_WRITE | DELETE, NULL, &ptransport->hkey, &dwDisposition
                    );

        if (dwErr != NO_ERROR) { break; }


        //
        // Update the time-stamp for the 'RouterManagers' key
        // now that we have created a new subkey underneath it.
        //

        dwErr = UpdateTimeStamp(
                    pserver->hkeyTransports, &pserver->ftTransportsStamp
                    );


        //
        // So far, so good; put the context in the list of transports;
        // (the search done above told us the insertion point)
        //

        InsertTailList(ple, &ptransport->leNode);


        do {
    
            //
            // Set the transport ID
            //

            dwErr = RegSetValueEx(
                        ptransport->hkey, c_szProtocolId, 0, REG_DWORD,
                        (BYTE*)&dwTransportId, sizeof(dwTransportId)
                        );

            if (dwErr != NO_ERROR) { break; }

    
            //
            // Now call SetInfo to save the information
            //
    
            dwErr = MprConfigTransportSetInfo(
                        hMprConfig,
                        (HANDLE)ptransport,
                        pGlobalInfo,
                        dwGlobalInfoSize,
                        pClientInterfaceInfo,
                        dwClientInterfaceInfoSize,
                        lpwsDLLPath
                        );
    
        } while (FALSE);


        //
        // If that failed, remove everything and bail out
        //

        if (dwErr != NO_ERROR) {

            MprConfigTransportDelete(hMprConfig, (HANDLE)ptransport);
        
            ReleaseMprConfigLock(); 
            
            return dwErr;
        }


        //
        // Return successfully
        //

        *phRouterTransport = (HANDLE)ptransport;

        ReleaseMprConfigLock(); 
        
        return NO_ERROR;

    } while (FALSE);


    //
    // Something went wrong, so return
    //

    ReleaseMprConfigLock(); 
    
    FreeTransport(ptransport);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MprConfigTransportDelete
//
// Removes a router-transport to the store for the router-service
// After this call, 'hRouterTransport' is no longer a valid handle.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigTransportDelete(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport
    )
{

    DWORD dwErr;
    SERVERCB* pserver;
    TRANSPORTCB* ptransport;

    if (!hRouterTransport) { return ERROR_INVALID_PARAMETER; }

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock(); 
    
    ptransport = (TRANSPORTCB*)hRouterTransport;

    //
    // remove the transport from the list of transports
    //

    RemoveEntryList(&ptransport->leNode);


    //
    // if the server doesn't have the RouterManagers key open, open it
    //

    dwErr = NO_ERROR;

    if (!pserver->hkeyTransports) {

        dwErr = AccessRouterSubkey(
                    pserver->hkeyMachine, c_szRouterManagers, FALSE,
                    &pserver->hkeyTransports
                    );
    }


    //
    // remove the transport's key from the registry
    //

    if (dwErr == NO_ERROR) {
    
        dwErr = RegDeleteTree(
                    pserver->hkeyTransports, ptransport->lpwsTransportKey
                    );


        //
        // Update the time-stamp for the 'RouterManagers' key
        // now that we have deleted a subtree underneath it.
        //

        UpdateTimeStamp(pserver->hkeyTransports, &pserver->ftTransportsStamp);
    }


    //
    // clean up the transport object
    //

    FreeTransport(ptransport);

    ReleaseMprConfigLock();     

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MprConfigTransportGetHandle
//
// Retrieves a handle to a transport's configuration.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterTransport
    )
{

    DWORD i, dwErr;
    SERVERCB *pserver;
    TRANSPORTCB* ptransport;
    LIST_ENTRY *ple, *phead;


    if (!phRouterTransport) {return ERROR_INVALID_PARAMETER;}

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    *phRouterTransport = NULL;

    AcquireMprConfigLock();     


    //
    // If the list of transports is not loaded, load it
    //

    if (!pserver->bTransportsLoaded ||
        TimeStampChanged(
            pserver->hkeyTransports, &pserver->ftTransportsStamp)) {
    
        dwErr = LoadTransports(pserver);
    
        if (dwErr != NO_ERROR) { ReleaseMprConfigLock(); return dwErr; }

        pserver->bTransportsLoaded = TRUE;
    }


    //
    // Search the list of transports for the one requested
    //

    ptransport = NULL;
    phead = &pserver->lhTransports;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        ptransport = CONTAINING_RECORD(ple, TRANSPORTCB, leNode);

        if (ptransport->bDeleted) { continue; }

        if (ptransport->dwTransportId >= dwTransportId) { break; }
    }


    //
    // If the transport requested was found, return successfully
    //

    if (ptransport && ptransport->dwTransportId == dwTransportId) {

        *phRouterTransport = (HANDLE)ptransport;

        ReleaseMprConfigLock(); 
        
        return NO_ERROR;
    }

    ReleaseMprConfigLock(); 
    
    return ERROR_UNKNOWN_PROTOCOL_ID;
}




//----------------------------------------------------------------------------
// Function:    MprConfigTransportSetInfo
//
// Changes the cofiguration of a router-transport in the store.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigTransportSetInfo(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo,
    IN      DWORD                   dwClientInterfaceInfoSize,
    IN      LPWSTR                  lpwsDLLPath
    )
{

    DWORD dwErr;
    SERVERCB* pserver;
    TRANSPORTCB* ptransport;


    //
    // Validate parameters
    //

    if (!hRouterTransport) { return ERROR_INVALID_PARAMETER; }

    if (!pGlobalInfo &&
        !pClientInterfaceInfo &&
        !lpwsDLLPath) { return NO_ERROR; }

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock(); 
    
    ptransport = (TRANSPORTCB*)hRouterTransport;

    if (ptransport->bDeleted) { ReleaseMprConfigLock(); return ERROR_UNKNOWN_PROTOCOL_ID; }


    do {

        //
        // Set the GlobalInfo
        //
    
        if (pGlobalInfo) {

            dwErr = RegSetValueEx(
                        ptransport->hkey, c_szGlobalInfo, 0, REG_BINARY,
                        pGlobalInfo, dwGlobalInfoSize
                        );

            if (dwErr != NO_ERROR) { break; }
        }
    
    
        //
        // Set the ClientInterfaceInfo
        //
    
        if (pClientInterfaceInfo) {

            dwErr = RegSetValueEx(
                        ptransport->hkey, c_szGlobalInterfaceInfo, 0,
                        REG_BINARY, pClientInterfaceInfo,
                        dwClientInterfaceInfoSize
                        );

            if (dwErr != NO_ERROR) { break; }
        }



        //
        // Set the DLL path 
        //

        if (lpwsDLLPath) {

            DWORD dwSize = (lstrlen(lpwsDLLPath) + 1) * sizeof(WCHAR);

            dwErr = RegSetValueEx(
                        ptransport->hkey, c_szDLLPath, 0, REG_EXPAND_SZ,
                        (BYTE*)lpwsDLLPath, dwSize
                        );

            if (dwErr != NO_ERROR) { break; }
        }


        dwErr = NO_ERROR;
    
    } while(FALSE);

    ReleaseMprConfigLock(); 
    
    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MprConfigTransportGetInfo
//
// Reads the cofiguration of a router-transport from the store.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigTransportGetInfo(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport,
    IN  OUT LPBYTE*                 ppGlobalInfo                OPTIONAL,
    OUT     LPDWORD                 lpdwGlobalInfoSize          OPTIONAL,
    IN  OUT LPBYTE*                 ppClientInterfaceInfo       OPTIONAL,
    OUT     LPDWORD                 lpdwClientInterfaceInfoSize OPTIONAL,
    IN  OUT LPWSTR*                 lplpwsDLLPath               OPTIONAL
    )
{

    DWORD dwErr;
    SERVERCB* pserver;
    TRANSPORTCB* ptransport;


    //
    // Validate parameters
    //

    if (!hRouterTransport) { return ERROR_INVALID_PARAMETER; }

    if (!ppGlobalInfo &&
        !ppClientInterfaceInfo &&
        !lplpwsDLLPath) { return NO_ERROR; }

    if ((ppGlobalInfo && !lpdwGlobalInfoSize) ||
        (ppClientInterfaceInfo && !lpdwClientInterfaceInfoSize)) {
        return ERROR_INVALID_PARAMETER;
    }

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock(); 

    //
    // Initialize all parameters
    //

    if (ppGlobalInfo) { *ppGlobalInfo = NULL; }
    if (ppClientInterfaceInfo) { *ppClientInterfaceInfo = NULL; }
    if (lpdwGlobalInfoSize) { *lpdwGlobalInfoSize = 0; }
    if (lpdwClientInterfaceInfoSize) { *lpdwClientInterfaceInfoSize = 0; }
    if (lplpwsDLLPath) { *lplpwsDLLPath = NULL; }

    ptransport = (TRANSPORTCB*)hRouterTransport;

    if (ptransport->bDeleted) { ReleaseMprConfigLock(); return ERROR_UNKNOWN_PROTOCOL_ID; }

    do {

        DWORD dwType, dwSize;


        //
        // Retrieve the global info
        //

        if (ppGlobalInfo) {

            dwErr = QueryValue(
                        ptransport->hkey, c_szGlobalInfo, ppGlobalInfo,
                        lpdwGlobalInfoSize
                        );
    
            if (dwErr != NO_ERROR) { break; }
        }


        //
        // Retrieve the client-interface info
        //

        if (ppClientInterfaceInfo) {

            dwErr = QueryValue(
                        ptransport->hkey, c_szGlobalInterfaceInfo,
                        ppClientInterfaceInfo, lpdwClientInterfaceInfoSize
                        );
    
            if (dwErr != NO_ERROR) { break; }
        }



        //
        // Retrieve the DLL path
        //

        if (lplpwsDLLPath) {

            dwErr = QueryValue(
                        ptransport->hkey, c_szDLLPath, (LPBYTE*)lplpwsDLLPath,
                        &dwSize
                        );
    
            if (dwErr != NO_ERROR) { break; }
        }


        //
        // All went well, return successfully
        //

        ReleaseMprConfigLock(); 
        return NO_ERROR;


    } while(FALSE);


    //
    // An error occurred, free all parameters and return failure
    //

    if (ppGlobalInfo) {
        Free0(*ppGlobalInfo); *ppGlobalInfo = NULL; *lpdwGlobalInfoSize = 0;
    }
    if (ppClientInterfaceInfo) {
        Free0(*ppClientInterfaceInfo);
        *ppClientInterfaceInfo = NULL; *lpdwClientInterfaceInfoSize = 0;
    }
    if (lplpwsDLLPath) {
        Free0(*lplpwsDLLPath); *lplpwsDLLPath = NULL;
    }

    ReleaseMprConfigLock(); 
    
    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MprConfigTransportEnum
//
// Enumerates the configured router-transport in the router-service store.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigTransportEnum(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,     // MPR_TRANSPORT_0
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
    )
{

    SERVERCB* pserver;
    TRANSPORTCB* ptransport;
    LIST_ENTRY *ple, *phead, *pleStart;
    MPR_TRANSPORT_0 *pItem, *pItemTable;
    DWORD dwErr, i, dwStartIndex, dwItemCount, dwItemTotal;


    if ((dwLevel != 0) ||
        !lplpBuffer ||
        dwPrefMaxLen < sizeof(*pItem) ||
        !lpdwEntriesRead ||
        !lpdwTotalEntries) { return ERROR_INVALID_PARAMETER; }

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock(); 
    
    *lplpBuffer = NULL;
    *lpdwEntriesRead = 0;
    *lpdwTotalEntries = 0;


    //
    // See whether the enumeration is being continued or being begun.
    //

    if (lpdwResumeHandle && *lpdwResumeHandle) {

        //
        // A resumption handle is specified,
        // so we assume that our list of transports is up-to-date,
        // and we just count off the requested number of transports
        // from our list starting from the specified index.
        //
    
        dwStartIndex = *lpdwResumeHandle;
    }
    else {

        //
        // No resumption handle was specified, so we may need to read
        // all the router-managers in order to get 'lpdwTotalEntries' 
        //

        dwStartIndex = 0;

        if (!pserver->bTransportsLoaded ||
            TimeStampChanged(
                pserver->hkeyTransports, &pserver->ftTransportsStamp)) {

            dwErr = LoadTransports(pserver);
    
            if (dwErr != NO_ERROR) { ReleaseMprConfigLock(); return dwErr; }

            pserver->bTransportsLoaded = TRUE;
        }
    }


    //
    // Find the position in the list to start from 
    //

    phead = &pserver->lhTransports;

    for (i = 0, ple = phead->Flink;
         i < dwStartIndex && ple != phead; ple = ple->Flink) {
        ptransport = CONTAINING_RECORD(ple, TRANSPORTCB, leNode);
        if (!ptransport->bDeleted) { ++i; }
    }


    //
    // if there aren't enough items to complete the request, fail
    //

    if (ple == phead) { ReleaseMprConfigLock(); return ERROR_NO_MORE_ITEMS; }

    pleStart = ple;


    //
    // count off the number of items requested
    //

    dwItemCount = dwPrefMaxLen / sizeof(*pItemTable);

    for (i = 0; i < dwItemCount && ple != phead; ple = ple->Flink) {
        ptransport = CONTAINING_RECORD(ple, TRANSPORTCB, leNode);
        if (!ptransport->bDeleted) { ++i; }
    }

    dwItemCount = i;


    //
    // finish counting off, to get the total number of items
    //

    for ( ; ple != phead; ple = ple->Flink) {
        ptransport = CONTAINING_RECORD(ple, TRANSPORTCB, leNode);
        if (!ptransport->bDeleted) { ++i; }
    }

    dwItemTotal = i;


    //
    // we now have the number of items to be retrieved, so allocate space
    //

    pItemTable = (MPR_TRANSPORT_0*)Malloc(dwItemCount * sizeof(*pItem));

    if (!pItemTable) { ReleaseMprConfigLock(); return ERROR_NOT_ENOUGH_MEMORY; }

    ZeroMemory(pItemTable, dwItemCount * sizeof(*pItem));


    //
    // now fill in the items using the listed transport objects
    //

    for (i = 0, ple = pleStart; i < dwItemCount; ple = ple->Flink) {

        //
        // get the next transport-object in our list
        //

        ptransport = CONTAINING_RECORD(ple, TRANSPORTCB, leNode);

        if (ptransport->bDeleted) { continue; }


        //
        // fill in information for the corresponding array item
        //

        pItem = pItemTable + i++;

        pItem->dwTransportId = ptransport->dwTransportId;
        pItem->hTransport = (HANDLE)ptransport;
        if (ptransport->lpwsTransportKey) {
            lstrcpyn(
                pItem->wszTransportName, ptransport->lpwsTransportKey,
                MAX_TRANSPORT_NAME_LEN + 1
                );
        }
    }


    *lplpBuffer = (LPBYTE)pItemTable;
    *lpdwEntriesRead = dwItemCount;
    *lpdwTotalEntries = dwItemTotal;
    if (lpdwResumeHandle) { *lpdwResumeHandle = dwStartIndex + dwItemCount; }

    ReleaseMprConfigLock(); 

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    MprConfigInterfaceCreate
//
// Creates a router-interface in the router-service store.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigInterfaceCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer,
    OUT     HANDLE*                 phRouterInterface
    )
{

    INT cmp;
    DWORD dwErr;
    SERVERCB *pserver;
    INTERFACECB* pinterface;
    LIST_ENTRY *ple, *phead;
    DWORD dwDialoutHoursRestrictionLength = 0;
    MPR_INTERFACE_0 * pMprIf0 = (MPR_INTERFACE_0 *)lpbBuffer;
    MPR_INTERFACE_1 * pMprIf1 = (MPR_INTERFACE_1 *)lpbBuffer;

    if (( ( dwLevel != 0 ) && ( dwLevel != 1 ) ) ||
        !lpbBuffer ||
        !phRouterInterface) {return ERROR_INVALID_PARAMETER;}

    //
    // As of Whistler, ipip tunnels are not supported
    //
    if ( pMprIf0->dwIfType == ROUTER_IF_TYPE_TUNNEL1 )
    {
        return ERROR_NOT_SUPPORTED;
    }        

    *phRouterInterface = NULL;

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock(); 
    
    //
    // If the list of interfaces is not loaded, load it
    //

    if (!pserver->bInterfacesLoaded ||
        TimeStampChanged(
            pserver->hkeyInterfaces, &pserver->ftInterfacesStamp)) {
    
        dwErr = LoadInterfaces(pserver);
    
        if (dwErr != NO_ERROR) { ReleaseMprConfigLock(); return dwErr; }

        pserver->bInterfacesLoaded = TRUE;
    }


    //
    // Search the list of interfaces for the one to be created
    //

    cmp = 1;
    pinterface = NULL;
    phead = &pserver->lhInterfaces;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pinterface = CONTAINING_RECORD(ple, INTERFACECB, leNode);

        if (pinterface->bDeleted) { continue; }

        cmp = lstrcmpi( pinterface->lpwsInterfaceName, 
                        pMprIf0->wszInterfaceName);

        if (cmp >= 0) { break; }
    }


    //
    // If the interface already exists, return
    //

    if (pinterface && cmp == 0) {

        *phRouterInterface = (HANDLE)pinterface;

        ReleaseMprConfigLock(); 

        return NO_ERROR;
    }


    //
    // Allocate a new context block
    //

    pinterface = (INTERFACECB*)Malloc(sizeof(*pinterface));

    if (!pinterface) { 
        ReleaseMprConfigLock(); 
        return ERROR_NOT_ENOUGH_MEMORY; 
    }


    do {

        WCHAR *lpwsKey, wszKey[12];
        DWORD dwDisposition, dwKeyCount;


        //
        // Initialize the interface context
        //

        ZeroMemory(pinterface, sizeof(*pinterface));

        InitializeListHead(&pinterface->lhIfTransports);

        pinterface->dwIfType = (DWORD)pMprIf0->dwIfType;

        pinterface->fEnabled = (BOOL)pMprIf0->fEnabled;

        if ( ( pMprIf0->dwIfType == ROUTER_IF_TYPE_DEDICATED ) ||
             ( pMprIf0->dwIfType == ROUTER_IF_TYPE_INTERNAL ) )
        {
            if ( !pMprIf0->fEnabled )
            {
                dwErr = ERROR_INVALID_PARAMETER;

                break;
            }
        }

        //
        // Set dialout hours restriction if there was one
        //

        pinterface->lpwsDialoutHoursRestriction = NULL;

        if ( dwLevel == 1 )
        {
            if ( pMprIf1->lpwsDialoutHoursRestriction != NULL )
            {
                dwDialoutHoursRestrictionLength =  
                    MprUtilGetSizeOfMultiSz(
                        pMprIf1->lpwsDialoutHoursRestriction
                        );

                pinterface->lpwsDialoutHoursRestriction = 
                    (LPWSTR)Malloc(dwDialoutHoursRestrictionLength);

                if ( pinterface->lpwsDialoutHoursRestriction == NULL )
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;

                    break;
                }

                CopyMemory(
                    pinterface->lpwsDialoutHoursRestriction, 
                    pMprIf1->lpwsDialoutHoursRestriction,
                    dwDialoutHoursRestrictionLength
                    );
            }
        }

        //
        // Make a copy of the interface name
        //

        pinterface->lpwsInterfaceName = StrDupW(pMprIf0->wszInterfaceName);

        if (!pinterface->lpwsInterfaceName) {

            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            break;
        }

        //
        // If the server doesn't have the Interfaces key open, create it
        //

        if (!pserver->hkeyInterfaces) {

            dwErr = AccessRouterSubkey(
                        pserver->hkeyMachine, c_szInterfaces, TRUE,
                        &pserver->hkeyInterfaces
                        );

            if (dwErr != NO_ERROR) { break; }
        }

        //
        // We need to select a unique key-name for the interface's key.
        // We do so by getting the number 'N' of subkeys under 'Interfaces',
        // then checking for the existence of a key whose name
        // is the string-value of 'N'; if such a key exists, increment 'N'
        // and try again.
        //

        dwErr = RegQueryInfoKey(
                    pserver->hkeyInterfaces, NULL, NULL, NULL, &dwKeyCount,
                    NULL, NULL, NULL, NULL, NULL, NULL, NULL
                    );

        if (dwErr != NO_ERROR) { break; }

        for ( ; ; ++dwKeyCount) {

            //
            // Convert the count to a string
            //

            wsprintf(wszKey, L"%d", dwKeyCount);


            //
            // Attempt to create a key with the resulting name;
            //

            dwErr = RegCreateKeyEx(
                        pserver->hkeyInterfaces, wszKey, 0, NULL, 0,
                        KEY_READ | KEY_WRITE | DELETE, NULL, &pinterface->hkey, &dwDisposition
                        );
    
            if (dwErr != NO_ERROR) { break; }


            //
            // See if the key was created
            //

            if (dwDisposition == REG_CREATED_NEW_KEY) {

                //
                // We found a unique key-name;
                //

                break;
            }
            else {

                //
                // This key-name is already taken; clean up and keep looking.
                //

                RegCloseKey(pinterface->hkey);

                pinterface->hkey = NULL;
            }
        }
    
        if (dwErr != NO_ERROR) { break; }


        //
        // So far, so good; put the context in the list of interfaces;
        // (the search done above told us the insertion point)
        //

        InsertTailList(ple, &pinterface->leNode);


        //
        // At this point a new key has been created for the interface,
        // so update our timestamp on the 'Interfaces' key.
        //

        UpdateTimeStamp(pserver->hkeyInterfaces, &pserver->ftInterfacesStamp);


        //
        // Now we need to save the name of the key for the interface,
        // and write the 'InterfaceName' and 'Type' into the registry.
        // In the case of a failure, the interface's key needs to be removed,
        // and we do so by invoking 'MprConfigInterfaceDelete'.
        //

        do {

            //
            // Duplicate the key-name for the interface
            //

            pinterface->lpwsInterfaceKey = StrDupW(wszKey);

            if (!pinterface->lpwsInterfaceKey) {

                dwErr = ERROR_NOT_ENOUGH_MEMORY;

                break;
            }

    
            //
            // Save the interface name 
            //
    
            dwErr = RegSetValueEx(
                        pinterface->hkey, c_szInterfaceName, 0, REG_SZ,
                        (BYTE*)pMprIf0->wszInterfaceName,
                        (lstrlen(pMprIf0->wszInterfaceName) + 1) * sizeof(WCHAR)
                        );
    
            if (dwErr != NO_ERROR) { break; }
    
    
    
            //
            // Save the interface type
            //
    
            dwErr = RegSetValueEx(
                        pinterface->hkey, c_szType, 0, REG_DWORD,
                        (BYTE*)&(pMprIf0->dwIfType), 
                        sizeof(pMprIf0->dwIfType)
                        );
    
            if (dwErr != NO_ERROR) { break; }
    
            //
            // Save the enabled state
            //

            dwErr = RegSetValueEx(
                        pinterface->hkey, c_szEnabled, 0, REG_DWORD,
                        (BYTE*)&(pMprIf0->fEnabled), 
                        sizeof(pMprIf0->fEnabled)
                        );
    
            if (dwErr != NO_ERROR) { break; }

            if ( dwLevel == 1 ) 
            {
                if ( pMprIf1->lpwsDialoutHoursRestriction != NULL )
                {
                    //
                    // Set dialout hours restriction if there was one
                    //

                    dwErr = RegSetValueEx(
                        pinterface->hkey, c_szDialoutHours, 0, REG_MULTI_SZ,
                        (BYTE*)pMprIf1->lpwsDialoutHoursRestriction,
                        dwDialoutHoursRestrictionLength 
                        );

                    if (dwErr != NO_ERROR) { break; }
                }
            }
    
        } while (FALSE);


        //
        // If a failure occurred, remove everything and bail out
        //

        if (dwErr != NO_ERROR) {

            MprConfigInterfaceDelete(hMprConfig, (HANDLE)pinterface);

            ReleaseMprConfigLock();             

            return dwErr;
        }

        //
        // Clean out the guidmap
        //

        GuidMapCleanup (pserver->hGuidMap, FALSE);

        //
        // Return successfully
        //

        *phRouterInterface = (HANDLE)pinterface;

        ReleaseMprConfigLock(); 

        return NO_ERROR;

    } while (FALSE);


    //
    // Something went wrong, so return
    //

    FreeInterface(pinterface);

    ReleaseMprConfigLock(); 

    return dwErr;
}


//----------------------------------------------------------------------------
// Function:    MprConfigInterfaceDelete
//
// Deletes a router-interface from the router-service store.
// After this call, 'hRouterInterface' is no longer a valid handle.
// Any router-transport interface handles retrieved for this interface
// are also invalid.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigInterfaceDelete(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface 
    )
{

    DWORD dwErr;
    SERVERCB* pserver;
    INTERFACECB* pinterface;
    

    if (!hRouterInterface) { return ERROR_INVALID_PARAMETER; }

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock(); 

    pinterface = (INTERFACECB*)hRouterInterface;


    //
    // remove the interface from the list of interfaces
    //

    RemoveEntryList(&pinterface->leNode);


    //
    // if the server doesn't have the Interfaces key open, open it
    //

    dwErr = NO_ERROR;

    if (!pserver->hkeyInterfaces) {

        dwErr = AccessRouterSubkey(
                    pserver->hkeyMachine, c_szInterfaces, FALSE,
                    &pserver->hkeyInterfaces
                    );
    }


    //
    // remove the interface's key from the registry
    //

    if (dwErr == NO_ERROR) {
        
        dwErr = RegDeleteTree(
                    pserver->hkeyInterfaces, pinterface->lpwsInterfaceKey
                    );

        //
        // We've deleted a subkey of the 'Interfaces' key,
        // so update the time-stamp.
        //

        UpdateTimeStamp(pserver->hkeyInterfaces, &pserver->ftInterfacesStamp);
    }

    //
    // clean up the interface object
    //

    FreeInterface(pinterface);

    //
    // Clean out the guidmap
    //

    GuidMapCleanup (pserver->hGuidMap, FALSE);

    ReleaseMprConfigLock(); 

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MprConfigInterfaceGetHandle
//
// Retrieves a handle to the interface configuration.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigInterfaceGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      LPWSTR                  lpwsInterfaceName,
    OUT     HANDLE*                 phRouterInterface
    )
{

    INT cmp;
    DWORD i, dwErr;
    SERVERCB *pserver;
    INTERFACECB* pinterface;
    LIST_ENTRY *ple, *phead;


    if (!hMprConfig || !phRouterInterface) {return ERROR_INVALID_PARAMETER;}

    *phRouterInterface = NULL;

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock();     

    //
    // If the list of interfaces is not loaded, load it
    //

    if (!pserver->bInterfacesLoaded ||
        TimeStampChanged(
            pserver->hkeyInterfaces, &pserver->ftInterfacesStamp)) {
    
        dwErr = LoadInterfaces(pserver);
    
        if (dwErr != NO_ERROR) { ReleaseMprConfigLock(); return dwErr; }

        pserver->bInterfacesLoaded = TRUE;
    }


    //
    // Search the list of interfaces for the one requested
    //

    cmp = 1;
    pinterface = NULL;
    phead = &pserver->lhInterfaces;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pinterface = CONTAINING_RECORD(ple, INTERFACECB, leNode);

        if (pinterface->bDeleted) { continue; }

        cmp = lstrcmpi(pinterface->lpwsInterfaceName, lpwsInterfaceName);

        if (cmp >= 0) { break; }
    }


    //
    // If the interface requested was found, return successfully
    //

    if (pinterface && cmp == 0) {

        *phRouterInterface = (HANDLE)pinterface;

        ReleaseMprConfigLock(); 

        return NO_ERROR;
    }

    ReleaseMprConfigLock(); 

    return ERROR_NO_SUCH_INTERFACE;
}



//----------------------------------------------------------------------------
// Function:    MprConfigInterfaceGetInfo
//
// Retrieves information for an interface.
//----------------------------------------------------------------------------

DWORD
MprConfigInterfaceGetInfo(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,     // MPR_INTERFACE_*
    OUT     LPDWORD                 lpdwBufferSize
    )
{

    DWORD dwErr;
    SERVERCB* pserver;
    INTERFACECB* pinterface;
    MPR_INTERFACE_0 *pItem;
    DWORD dwDialoutHoursRestrictionLength = 0;
    BOOL bInstalled;

    if (!hRouterInterface ||
        ((dwLevel != 0) && (dwLevel != 1)) ||
        !lplpBuffer ||
        !lpdwBufferSize) { return ERROR_INVALID_PARAMETER; }

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock(); 

    pinterface = (INTERFACECB*)hRouterInterface;

    *lplpBuffer = NULL;
    *lpdwBufferSize = 0;

    if (pinterface->bDeleted) 
    {   
        ReleaseMprConfigLock(); 
        return ERROR_NO_SUCH_INTERFACE; 
    }

    //
    // Compute the amount of memory required for the information
    //

    if (dwLevel == 0) {
        *lpdwBufferSize = sizeof( MPR_INTERFACE_0 );
    }
    else
    if (dwLevel == 1) {

        if ((pinterface->dwIfType == ROUTER_IF_TYPE_DEDICATED) ||
            (pinterface->dwIfType == ROUTER_IF_TYPE_INTERNAL)) {
            ReleaseMprConfigLock(); 
            return ERROR_INVALID_PARAMETER;
        }

        dwDialoutHoursRestrictionLength =
            MprUtilGetSizeOfMultiSz(
                pinterface->lpwsDialoutHoursRestriction
                );

        *lpdwBufferSize =
            sizeof(MPR_INTERFACE_1) + dwDialoutHoursRestrictionLength;
    }

    //
    // Allocate space for the information
    //

    pItem = (MPR_INTERFACE_0*)Malloc( *lpdwBufferSize );

    if (!pItem) { ReleaseMprConfigLock(); return ERROR_NOT_ENOUGH_MEMORY; }

    ZeroMemory(pItem, *lpdwBufferSize );

    //
    // Copy the requested interface-info from the context block
    //

    if (dwLevel == 0 || dwLevel == 1) {

        lstrcpyn(
            pItem->wszInterfaceName, pinterface->lpwsInterfaceName,
            MAX_INTERFACE_NAME_LEN + 1
            );
        pItem->hInterface = (HANDLE)pinterface;
        pItem->dwIfType = (ROUTER_INTERFACE_TYPE)pinterface->dwIfType;
        pItem->fEnabled = pinterface->fEnabled;

        // 
        // Indicate any pnp info that we have if it's a LAN adpt.
        //
        if (pinterface->dwIfType == ROUTER_IF_TYPE_DEDICATED)
        {
            bInstalled = FALSE;
            dwErr = GuidMapIsAdapterInstalled(
                        pserver->hGuidMap,
                        pinterface->lpwsInterfaceName,
                        &bInstalled);
            if (!bInstalled)
            {
                pItem->dwConnectionState = ROUTER_IF_STATE_UNREACHABLE;
                pItem->fUnReachabilityReasons |= MPR_INTERFACE_NO_DEVICE;
            }
        }
    }

    if (dwLevel == 1) {

        MPR_INTERFACE_1 *pItem1 = (MPR_INTERFACE_1 *)pItem;

        if (pinterface->lpwsDialoutHoursRestriction) {

            CopyMemory(
                pItem1 + 1,
                pinterface->lpwsDialoutHoursRestriction,
                dwDialoutHoursRestrictionLength
                );

            pItem1->lpwsDialoutHoursRestriction =   
                (LPWSTR)(pItem1 + 1);
        }
    }

    *lplpBuffer = (LPBYTE)pItem;

    ReleaseMprConfigLock(); 

    return NO_ERROR;
}


//----------------------------------------------------------------------------
// Function:    MprConfigInterfaceSetInfo
//
// Changes the configuration for an interface.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigInterfaceSetInfo(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpBuffer
    )
{

    DWORD dwErr;
    SERVERCB* pserver;
    INTERFACECB* pinterface;
    MPR_INTERFACE_0 * pMprIf0 = (MPR_INTERFACE_0 *)lpBuffer;


    //
    // Validate parameters
    //

    if (!lpBuffer   ||
        ((dwLevel != 0) && (dwLevel != 1)) ||
        !hRouterInterface) { return ERROR_INVALID_PARAMETER; }

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock(); 

    pinterface = (INTERFACECB*)hRouterInterface;

    if (pinterface->bDeleted) { 
        ReleaseMprConfigLock(); 
        return ERROR_NO_SUCH_INTERFACE; 
    }

    do {


        if (dwLevel == 0 || dwLevel == 1) {
    
            if ((pMprIf0->dwIfType == ROUTER_IF_TYPE_DEDICATED) ||
                (pMprIf0->dwIfType == ROUTER_IF_TYPE_INTERNAL)) {
                if (!pMprIf0->fEnabled) {
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }
            }
    
            //
            // Set the enabled value
            //
    
            dwErr = RegSetValueEx(
                        pinterface->hkey, c_szEnabled, 0, REG_DWORD,
                        (LPBYTE)&pMprIf0->fEnabled,  sizeof(pMprIf0->fEnabled) 
                        );

            if (dwErr != NO_ERROR) { break; }
    
            pinterface->fEnabled = pMprIf0->fEnabled;
        }

        if (dwLevel == 1) {

            MPR_INTERFACE_1 * pMprIf1 = (MPR_INTERFACE_1 *)lpBuffer;
            LPWSTR lpwsDialoutHoursRestriction;
            DWORD dwDialoutHoursRestrictionLength = 0;

            if ((pinterface->dwIfType == ROUTER_IF_TYPE_DEDICATED) ||
                (pinterface->dwIfType == ROUTER_IF_TYPE_INTERNAL)) {
                dwErr = ERROR_INVALID_PARAMETER; break;
            }

            //
            // Set or remove the value
            //

            if (!pMprIf1->lpwsDialoutHoursRestriction) {
                dwErr = RegDeleteValue(pinterface->hkey, c_szDialoutHours);
            }
            else {
                dwDialoutHoursRestrictionLength =
                    MprUtilGetSizeOfMultiSz(
                        pMprIf1->lpwsDialoutHoursRestriction
                        );
    
                lpwsDialoutHoursRestriction = 
                    (LPWSTR)Malloc(dwDialoutHoursRestrictionLength);
    
                if (lpwsDialoutHoursRestriction == NULL) {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY; break;
                } 
    
                CopyMemory(
                    lpwsDialoutHoursRestriction,
                    pMprIf1->lpwsDialoutHoursRestriction,
                    dwDialoutHoursRestrictionLength
                    );
    
                //
                // Set dialout hours restriction if there was one
                //
    
                dwErr = RegSetValueEx(
                            pinterface->hkey, c_szDialoutHours, 0, REG_MULTI_SZ,
                            (BYTE*)pMprIf1->lpwsDialoutHoursRestriction,
                            dwDialoutHoursRestrictionLength
                            );
            }

            if (dwErr != NO_ERROR) {Free0(lpwsDialoutHoursRestriction); break;}

            //
            // Cache the current value on success
            //

            Free0(pinterface->lpwsDialoutHoursRestriction);
            pinterface->lpwsDialoutHoursRestriction =
                lpwsDialoutHoursRestriction;
        }

        dwErr = NO_ERROR;
    
    } while(FALSE);

    ReleaseMprConfigLock(); 

    return dwErr;
}

//----------------------------------------------------------------------------
// Function:    MprConfigInterfaceEnum
//
// Enumerates the configured router-interfaces.
//----------------------------------------------------------------------------
DWORD APIENTRY
MprConfigInterfaceEnum(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
    )
{

    SERVERCB* pserver;
    INTERFACECB* pinterface;
    LIST_ENTRY *ple, *phead, *pleStart;
    MPR_INTERFACE_0 *pItem, *pItemTable;
    DWORD dwErr, i, dwStartIndex, dwItemCount, dwItemTotal;


    if ((dwLevel != 0) ||
        !lplpBuffer ||
        dwPrefMaxLen < sizeof(*pItem) ||
        !lpdwEntriesRead ||
        !lpdwTotalEntries) { return ERROR_INVALID_PARAMETER; }

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock(); 

    *lplpBuffer = NULL;
    *lpdwEntriesRead = 0;
    *lpdwTotalEntries = 0;


    //
    // See whether the enumeration is being continued or being begun.
    //

    if (lpdwResumeHandle && *lpdwResumeHandle) {

        //
        // A resumption handle is specified,
        // so we assume that our list of interfaces is up-to-date,
        // and we just count off the requested number of interfaces
        // from our list starting from the specified index.
        //
    
        dwStartIndex = *lpdwResumeHandle;
    }
    else {

        //
        // No resumption handle was specified, so we may need to read
        // all the interfaces in order to get 'lpdwTotalEntries' 
        //

        dwStartIndex = 0;

        if (!pserver->bInterfacesLoaded ||
            TimeStampChanged(
                pserver->hkeyInterfaces, &pserver->ftInterfacesStamp)) {

            dwErr = LoadInterfaces(pserver);
    
            if (dwErr != NO_ERROR) { ReleaseMprConfigLock(); return dwErr; }

            pserver->bInterfacesLoaded = TRUE;
        }
    }


    //
    // Find the position in the list to start from 
    //

    phead = &pserver->lhInterfaces;

    for (i = 0, ple = phead->Flink;
         i < dwStartIndex && ple != phead; ple = ple->Flink) {
        pinterface = CONTAINING_RECORD(ple, INTERFACECB, leNode);
        if (!pinterface->bDeleted) { ++i; }
    }


    //
    // If there aren't enough items to complete the request, fail
    //

    if (ple == phead) { ReleaseMprConfigLock(); return ERROR_NO_MORE_ITEMS; }

    pleStart = ple;


    //
    // Count off the number of items requested
    //

    dwItemCount = dwPrefMaxLen / sizeof(*pItemTable);

    for (i = 0; i < dwItemCount && ple != phead; ple = ple->Flink) {
        pinterface = CONTAINING_RECORD(ple, INTERFACECB, leNode);
        if (!pinterface->bDeleted) { ++i; }
    }

    dwItemCount = i;


    //
    // Finish counting off, to get the total number of items
    //

    for ( ; ple != phead; ple = ple->Flink) {
        pinterface = CONTAINING_RECORD(ple, INTERFACECB, leNode);
        if (!pinterface->bDeleted) { ++i; }
    }

    dwItemTotal = i;


    //
    // We now have the number of items to be retrieved, so allocate space
    //

    pItemTable = (MPR_INTERFACE_0*)Malloc(dwItemCount * sizeof(*pItem));

    if (!pItemTable) { ReleaseMprConfigLock(); return ERROR_NOT_ENOUGH_MEMORY; }

    ZeroMemory(pItemTable, dwItemCount * sizeof(*pItem));


    //
    // Now fill in the items using the listed interface objects
    //

    for (i = 0, ple = pleStart; i < dwItemCount; ple = ple->Flink) {

        //
        // Get the next interface-object in our list
        //

        pinterface = CONTAINING_RECORD(ple, INTERFACECB, leNode);

        if (pinterface->bDeleted) { continue; }


        //
        // fill in information for the corresponding array item
        //

        pItem = pItemTable + i++;

        lstrcpyn(
            pItem->wszInterfaceName, pinterface->lpwsInterfaceName,
            MAX_INTERFACE_NAME_LEN + 1
            );
        pItem->hInterface = (HANDLE)pinterface;
        pItem->dwIfType = (ROUTER_INTERFACE_TYPE)pinterface->dwIfType;
        pItem->fEnabled = pinterface->fEnabled;
    }


    *lplpBuffer = (LPBYTE)pItemTable;
    *lpdwEntriesRead = dwItemCount;
    *lpdwTotalEntries = dwItemTotal;
    if (lpdwResumeHandle) { *lpdwResumeHandle = dwStartIndex + dwItemCount; }

    ReleaseMprConfigLock(); 

    return NO_ERROR;
}

//----------------------------------------------------------------------------
// Function:    MprConfigInterfaceTransportAdd
//
// Adds a router-transport to a router-interface in the store.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigInterfaceTransportAdd(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface, 
    IN      DWORD                   dwTransportId,
    IN      LPWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pInterfaceInfo,
    IN      DWORD                   dwInterfaceInfoSize,
    OUT     HANDLE*                 phRouterIfTransport
    )
{

    DWORD dwErr;
    SERVERCB *pserver;
    INTERFACECB* pinterface;
    IFTRANSPORTCB* piftransport;
    LIST_ENTRY *ple, *phead;


    if (!hRouterInterface ||
        !phRouterIfTransport) { return ERROR_INVALID_PARAMETER; }

    *phRouterIfTransport = NULL;

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock(); 

    pinterface = (INTERFACECB*)hRouterInterface;



    //
    // If the list of interface-transports is not loaded, load it
    //

    if (!pinterface->bIfTransportsLoaded ||
        TimeStampChanged(pinterface->hkey, &pinterface->ftStamp)) {
    
        dwErr = LoadIfTransports(pinterface);
    
        if (dwErr != NO_ERROR) { ReleaseMprConfigLock(); return dwErr; }

        pinterface->bIfTransportsLoaded = TRUE;
    }



    //
    // Search the list of interface-transports for the one to be created
    //

    piftransport = NULL;
    phead = &pinterface->lhIfTransports;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        piftransport = CONTAINING_RECORD(ple, IFTRANSPORTCB, leNode);

        if (piftransport->bDeleted) { continue; }

        if (piftransport->dwTransportId >= dwTransportId) { break; }
    }



    //
    // If the transport already exists, do a SetInfo instead
    //

    if (piftransport && piftransport->dwTransportId == dwTransportId) {
        DWORD dwErr2;

        *phRouterIfTransport = (HANDLE)piftransport;

        dwErr2 = MprConfigInterfaceTransportSetInfo(
                    hMprConfig,
                    hRouterInterface,
                    *phRouterIfTransport,
                    pInterfaceInfo,
                    dwInterfaceInfoSize
                    );

        ReleaseMprConfigLock(); 

        return dwErr2;
    }


    //
    // Allocate a new context block
    //

    piftransport = (IFTRANSPORTCB*)Malloc(sizeof(*piftransport));

    if (!piftransport) { 
        ReleaseMprConfigLock(); 
        return ERROR_NOT_ENOUGH_MEMORY; 
    }


    do {

        DWORD dwDisposition;
        const WCHAR *lpwsKey;
        WCHAR wszIfTransport[10];


        //
        // Initialize the transport context
        //

        ZeroMemory(piftransport, sizeof(*piftransport));

        piftransport->dwTransportId = dwTransportId;



        //
        // If the transport name is specified, use it as the key name;
        // otherwise, if it is a recognized transport, use a known name;
        // otherwise, convert the transport ID to a string and use that
        //

        if (lpwsTransportName && lstrlen(lpwsTransportName)) {
            lpwsKey = lpwsTransportName;
        }
        else
        if (dwTransportId == PID_IP) {
            lpwsKey = c_szIP;
        }
        else
        if (dwTransportId == PID_IPX) {
            lpwsKey = c_szIPX;
        }
        else {
    
            wsprintf(wszIfTransport, L"%d", dwTransportId);

            lpwsKey = wszIfTransport;
        }


        piftransport->lpwsIfTransportKey = StrDupW(lpwsKey);

        if (!piftransport->lpwsIfTransportKey) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY; break;
        }


        //
        // Create a key for the interface-transport in the registry
        //

        dwErr = RegCreateKeyEx(
                    pinterface->hkey, lpwsKey, 0, NULL, 0,
                    KEY_READ | KEY_WRITE | DELETE, NULL, &piftransport->hkey, &dwDisposition
                    );

        if (dwErr != NO_ERROR) { break; }


        //
        // Update the timestamp on the interface's key
        // now that a new subkey has been created under it.
        //

        UpdateTimeStamp(pinterface->hkey, &pinterface->ftStamp);



        //
        // Set the "ProtocolId" value for the interface transport
        //

        dwErr = RegSetValueEx(
                    piftransport->hkey, c_szProtocolId, 0, REG_DWORD,
                    (LPBYTE)&dwTransportId, sizeof(dwTransportId)
                    );


        //
        // So far, so good; put the context in the list of interface-transports;
        // (the search done above told us the insertion point)
        //

        InsertTailList(ple, &piftransport->leNode);


        //
        // Now call SetInfo to save the information
        //

        dwErr = MprConfigInterfaceTransportSetInfo(
                    hMprConfig,
                    hRouterInterface,
                    (HANDLE)piftransport,
                    pInterfaceInfo,
                    dwInterfaceInfoSize
                    );


        //
        // If that failed, remove everything and bail out
        //

        if (dwErr != NO_ERROR) {

            MprConfigInterfaceTransportRemove(
                hMprConfig,
                hRouterInterface,
                (HANDLE)piftransport
                );

            ReleaseMprConfigLock(); 

            return dwErr;
        }


        //
        // Return successfully
        //

        *phRouterIfTransport = (HANDLE)piftransport;

        ReleaseMprConfigLock(); 

        return NO_ERROR;

    } while (FALSE);


    //
    // Something went wrong, so return
    //

    FreeIfTransport(piftransport);

    ReleaseMprConfigLock(); 
    
    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MprConfigInterfaceTransportRemove
//
// Removes a router-transport from a router-interface in the store.
// After this call, 'hRouterIfTransport' is no longer a valid handle.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigInterfaceTransportRemove(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      HANDLE                  hRouterIfTransport
    )
{

    DWORD dwErr;
    SERVERCB* pserver;
    INTERFACECB* pinterface;
    IFTRANSPORTCB* piftransport;
    

    if (!hMprConfig ||
        !hRouterInterface ||
        !hRouterIfTransport) { return ERROR_INVALID_PARAMETER; }

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock(); 

    pinterface = (INTERFACECB*)hRouterInterface;
    piftransport = (IFTRANSPORTCB*)hRouterIfTransport;


    //
    // remove the interface-transport from the list of interface-transports
    //

    RemoveEntryList(&piftransport->leNode);


    //
    // remove the transport's key from the registry
    //

    dwErr = RegDeleteTree(
                pinterface->hkey, piftransport->lpwsIfTransportKey
                );


    //
    // Update the timestamp on the interface's key
    // now that a subkey has been deleted from under it.
    //

    UpdateTimeStamp(pinterface->hkey, &pinterface->ftStamp);
    

    //
    // clean up the transport object
    //

    FreeIfTransport(piftransport);

    ReleaseMprConfigLock(); 

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MprConfigInterfaceTransportGetHandle
//
// Retrieves a handle to a router-transport's interface configuration.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigInterfaceTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterIfTransport
    )
{

    DWORD i, dwErr;
    SERVERCB *pserver;
    INTERFACECB* pinterface;
    IFTRANSPORTCB* piftransport;
    LIST_ENTRY *ple, *phead;


    if (!hRouterInterface ||
        !phRouterIfTransport) { return ERROR_INVALID_PARAMETER; }

    *phRouterIfTransport = NULL;

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock(); 

    pinterface = (INTERFACECB*)hRouterInterface;

    if (pinterface->bDeleted) { 
        ReleaseMprConfigLock(); 
        return ERROR_NO_SUCH_INTERFACE; 
    }


    //
    // If the list of interface-transports is not loaded, load it
    //

    if (!pinterface->bIfTransportsLoaded ||
        TimeStampChanged(pinterface->hkey, &pinterface->ftStamp)) {
    
        dwErr = LoadIfTransports(pinterface);
    
        if (dwErr != NO_ERROR) { ReleaseMprConfigLock(); return dwErr; }

        pinterface->bIfTransportsLoaded = TRUE;
    }


    //
    // Search the list of interface-transports for the one requested
    //

    piftransport = NULL;
    phead = &pinterface->lhIfTransports;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        piftransport = CONTAINING_RECORD(ple, IFTRANSPORTCB, leNode);

        if (piftransport->bDeleted) { continue; }

        if (piftransport->dwTransportId >= dwTransportId) { break; }
    }


    //
    // If the interface-transport requested was found, return successfully
    //

    if (piftransport && piftransport->dwTransportId == dwTransportId) {

        *phRouterIfTransport = (HANDLE)piftransport;

        ReleaseMprConfigLock(); 

        return NO_ERROR;
    }

    ReleaseMprConfigLock(); 

    return ERROR_NO_SUCH_INTERFACE;
}



//----------------------------------------------------------------------------
// Function:    MprConfigInterfaceTransportGetInfo
//
// Reads the configuration of a router-transport for a router-interface.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigInterfaceTransportGetInfo(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      HANDLE                  hRouterIfTransport,
    IN  OUT LPBYTE*                 ppInterfaceInfo,
    OUT     LPDWORD                 lpdwInterfaceInfoSize
    )
{

    DWORD dwErr;
    SERVERCB* pserver;
    INTERFACECB* pinterface;
    IFTRANSPORTCB* piftransport;

    //
    // Validate parameters
    //

    if (!hRouterInterface ||
        !hRouterIfTransport) { return ERROR_INVALID_PARAMETER; }

    if (!ppInterfaceInfo) { return NO_ERROR; }

    if (ppInterfaceInfo &&
        !lpdwInterfaceInfoSize) { return ERROR_INVALID_PARAMETER; }


    //
    // Initialize all parameters
    //

    if (ppInterfaceInfo) { *ppInterfaceInfo = NULL; }
    if (lpdwInterfaceInfoSize) { *lpdwInterfaceInfoSize = 0; }

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock(); 

    pinterface = (INTERFACECB*)hRouterInterface;
    piftransport = (IFTRANSPORTCB*)hRouterIfTransport;


    if (pinterface->bDeleted || piftransport->bDeleted) {
        ReleaseMprConfigLock(); 
        return ERROR_NO_SUCH_INTERFACE;
    }

    do {

        DWORD dwType, dwSize;


        //
        // Retrieve the interface info
        //

        if (ppInterfaceInfo) {

            dwErr = QueryValue(
                        piftransport->hkey, c_szInterfaceInfo, ppInterfaceInfo,
                        lpdwInterfaceInfoSize
                        );
    
            if (dwErr != NO_ERROR) { break; }
        }


        //
        // All went well, return successfully
        //

        ReleaseMprConfigLock(); 
        
        return NO_ERROR;


    } while(FALSE);


    //
    // An error occurred, free all parameters and return failure
    //

    if (ppInterfaceInfo) {
        Free0(*ppInterfaceInfo);
        *ppInterfaceInfo = NULL; *lpdwInterfaceInfoSize = 0;
    }

    ReleaseMprConfigLock(); 

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MprConfigInterfaceTransportSetInfo
//
// Changes the configuration of a router-transport for a router-interface.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigInterfaceTransportSetInfo(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      HANDLE                  hRouterIfTransport,
    IN      LPBYTE                  pInterfaceInfo              OPTIONAL,
    IN      DWORD                   dwInterfaceInfoSize         OPTIONAL
    )
{

    DWORD dwErr;
    SERVERCB* pserver;
    INTERFACECB* pinterface;
    IFTRANSPORTCB* piftransport;


    //
    // Validate parameters
    //

    if (!hRouterInterface ||
        !hRouterIfTransport) { return ERROR_INVALID_PARAMETER; }

    if (!pInterfaceInfo) { return NO_ERROR; }

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock(); 

    pinterface = (INTERFACECB*)hRouterInterface;
    piftransport = (IFTRANSPORTCB*)hRouterIfTransport;


    if (pinterface->bDeleted || piftransport->bDeleted) {
        ReleaseMprConfigLock(); 
        return ERROR_NO_SUCH_INTERFACE;
    }

    do {

        //
        // Set the InterfaceInfo
        //
    
        if (pInterfaceInfo) {

            dwErr = RegSetValueEx(
                        piftransport->hkey, c_szInterfaceInfo, 0, REG_BINARY,
                        pInterfaceInfo, dwInterfaceInfoSize
                        );

            if (dwErr != NO_ERROR) { break; }
        }
    
    
        dwErr = NO_ERROR;
    
    } while(FALSE);

    ReleaseMprConfigLock(); 

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MprConfigInterfaceTransportEnum
//
// Enumerates the transports configured on a router-interface.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigInterfaceTransportEnum(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,     // MPR_IFTRANSPORT_0
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
    )
{

    SERVERCB* pserver;
    INTERFACECB* pinterface;
    IFTRANSPORTCB* piftransport;
    LIST_ENTRY *ple, *phead, *pleStart;
    MPR_IFTRANSPORT_0 *pItem, *pItemTable;
    DWORD dwErr, i, dwStartIndex, dwItemCount, dwItemTotal;


    if (!hRouterInterface ||
        (dwLevel != 0) ||
        !lplpBuffer ||
        dwPrefMaxLen < sizeof(*pItem) ||
        !lpdwEntriesRead ||
        !lpdwTotalEntries) { return ERROR_INVALID_PARAMETER; }

    pserver = (SERVERCB*)hMprConfig;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    AcquireMprConfigLock(); 

    pinterface = (INTERFACECB*)hRouterInterface;

    *lplpBuffer = NULL;
    *lpdwEntriesRead = 0;
    *lpdwTotalEntries = 0;


    //
    // See whether the enumeration is being continued or being begun.
    //

    if (lpdwResumeHandle && *lpdwResumeHandle) {

        //
        // A resumption handle is specified,
        // so we assume that our list of transports is up-to-date,
        // and we just count off the requested number of transports
        // from our list starting from the specified index.
        //
    
        dwStartIndex = *lpdwResumeHandle;
    }
    else {

        //
        // No resumption handle was specified, so we may need to read
        // all the interface-transports in order to get 'lpdwTotalEntries' 
        //

        dwStartIndex = 0;

        if (!pinterface->bIfTransportsLoaded ||
            TimeStampChanged(pinterface->hkey, &pinterface->ftStamp)) {

            dwErr = LoadIfTransports(pinterface);
    
            if (dwErr != NO_ERROR) { ReleaseMprConfigLock(); return dwErr; }

            pinterface->bIfTransportsLoaded = TRUE;
        }
    }


    //
    // Find the position in the list to start from 
    //

    phead = &pinterface->lhIfTransports;

    for (i = 0, ple = phead->Flink;
         i < dwStartIndex && ple != phead; ple = ple->Flink) {
        piftransport = CONTAINING_RECORD(ple, IFTRANSPORTCB, leNode);
        if (!piftransport->bDeleted) { ++i; }
    }


    //
    // If there aren't enough items to complete the request, fail
    //

    if (ple == phead) { ReleaseMprConfigLock(); return ERROR_NO_MORE_ITEMS; }

    pleStart = ple;


    //
    // Count off the number of items requested
    //

    dwItemCount = dwPrefMaxLen / sizeof(*pItemTable);

    for (i = 0; i < dwItemCount && ple != phead; ple = ple->Flink) {
        piftransport = CONTAINING_RECORD(ple, IFTRANSPORTCB, leNode);
        if (!piftransport->bDeleted) { ++i; }
    }

    dwItemCount = i;


    //
    // Finish counting off, to get the total number of items
    //

    for ( ; ple != phead; ple = ple->Flink) {
        piftransport = CONTAINING_RECORD(ple, IFTRANSPORTCB, leNode);
        if (!piftransport->bDeleted) { ++i; }
    }

    dwItemTotal = i;


    //
    // We now have the number of items to be retrieved, so allocate space
    //

    pItemTable = (MPR_IFTRANSPORT_0*)Malloc(dwItemCount * sizeof(*pItem));

    if (!pItemTable) { ReleaseMprConfigLock(); return ERROR_NOT_ENOUGH_MEMORY; }

    ZeroMemory(pItemTable, dwItemCount * sizeof(*pItem));


    //
    // Now fill in the items using the listed interface-transport objects
    //

    for (i = 0, ple = pleStart; i < dwItemCount; ple = ple->Flink) {

        //
        // Get the next interface-transport object in our list
        //

        piftransport = CONTAINING_RECORD(ple, IFTRANSPORTCB, leNode);

        if (piftransport->bDeleted) { continue; }


        //
        // Fill in information for the corresponding array item
        //

        pItem = pItemTable + i++;

        pItem->dwTransportId = piftransport->dwTransportId;
        pItem->hIfTransport = (HANDLE)piftransport;

        if (piftransport->lpwsIfTransportKey) {
            lstrcpyn(
                pItem->wszIfTransportName, piftransport->lpwsIfTransportKey,
                MAX_TRANSPORT_NAME_LEN + 1
                );
        }
    }


    *lplpBuffer = (LPBYTE)pItemTable;
    *lpdwEntriesRead = dwItemCount;
    *lpdwTotalEntries = dwItemTotal;
    if (lpdwResumeHandle) { *lpdwResumeHandle = dwStartIndex + dwItemCount; }

    ReleaseMprConfigLock(); 

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    MprConfigGetFriendlyName
//
// Returns a friendly name based on a guid name.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigGetFriendlyName(
    IN      HANDLE                  hMprConfig,
    IN      PWCHAR                  pszGuidName,
    OUT     PWCHAR                  pszBuffer,
    IN      DWORD                   dwBufferSize
    )
{

    SERVERCB* pserver = (SERVERCB*)hMprConfig;
    DWORD dwErr;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    //
    // Validate parameters
    //

    if (!pszGuidName || !pszBuffer) {
        return ERROR_INVALID_PARAMETER;
    }

    AcquireMprConfigLock(); 

    //
    // Return the mapping
    //

    dwErr =
        GuidMapGetFriendlyName(
            pserver,
            pszGuidName, 
            dwBufferSize,
            pszBuffer
            );

    ReleaseMprConfigLock();             
                                    
    return dwErr;
}                                    



//----------------------------------------------------------------------------
// Function:    MprConfigGetGuidName
//
// Returns a guid name based on a friendly name.
//----------------------------------------------------------------------------

DWORD APIENTRY
MprConfigGetGuidName(
    IN      HANDLE                  hMprConfig,
    IN      PWCHAR                  pszFriendlyName,
    OUT     PWCHAR                  pszBuffer,
    IN      DWORD                   dwBufferSize
    )
{    
    SERVERCB* pserver = (SERVERCB*)hMprConfig;
    DWORD dwErr;

    dwErr = MprConfigServerValidateCb(pserver);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Validate parameters
    if (!pszFriendlyName || !pszBuffer) {
        return ERROR_INVALID_PARAMETER;
    }

    AcquireMprConfigLock(); 

    // Return the mapping
    dwErr = GuidMapGetGuidName(
                pserver,
                pszFriendlyName, 
                dwBufferSize,
                pszBuffer
                );

    ReleaseMprConfigLock(); 

    return dwErr;
}                                   


//----------------------------------------------------------------------------
// Function:    AccessRouterSubkey
//
// Creates/opens a subkey of the Router service key on 'hkeyMachine'.
// When a key is created, 'lpwsSubkey' must be a child of the Router key.
//----------------------------------------------------------------------------

DWORD
AccessRouterSubkey(
    IN      HKEY        hkeyMachine,
    IN      LPCWSTR      lpwsSubkey,
    IN      BOOL        bCreate,
    OUT     HKEY*       phkeySubkey
    )
{

    HKEY hkeyRouter;
    LPWSTR lpwsPath;
    DWORD dwErr, dwSize, dwDisposition;
    BOOL bIsNt40;


    if (!phkeySubkey) { return ERROR_INVALID_PARAMETER; }

    *phkeySubkey = NULL;

    //
    // Find out whether we are adminstrating an nt40 machine as this will
    // affect the path we take in the registry.
    //

    if ((dwErr = IsNt40Machine(hkeyMachine, &bIsNt40)) != NO_ERROR) {
        return dwErr;
    }

    //
    // compute the length of the string "System\CCS\Services\RemoteAccess"
    //

    if (bIsNt40) {
        dwSize = lstrlen(c_szSystemCCSServices) + 1 + lstrlen(c_szRouter) + 1;
    }
    else {
        dwSize =
            lstrlen(c_szSystemCCSServices) + 1 + lstrlen(c_szRemoteAccess) + 1;
    }

    //
    // allocate space for the path
    //

    lpwsPath = (LPWSTR)Malloc(dwSize * sizeof(WCHAR));

    if (!lpwsPath) { return ERROR_NOT_ENOUGH_MEMORY; }

    if (bIsNt40) {
        wsprintf(lpwsPath, L"%s\\%s", c_szSystemCCSServices, c_szRouter);
    }
    else {
        wsprintf(lpwsPath, L"%s\\%s", c_szSystemCCSServices, c_szRemoteAccess);
    }

    hkeyRouter = NULL;

    do {

        //
        // open the router key
        //
    
        dwErr = RegOpenKeyEx(
                    hkeyMachine, lpwsPath, 0, KEY_READ | KEY_WRITE, &hkeyRouter
                    );
    
        if (dwErr != NO_ERROR) { break; }


        //
        // now create or open the specified subkey
        //

        if (!bCreate) { 

            dwErr = RegOpenKeyEx(
                        hkeyRouter, lpwsSubkey, 0, KEY_READ | KEY_WRITE, phkeySubkey
                        );
        }
        else {

            dwErr = RegCreateKeyEx(
                        hkeyRouter, lpwsSubkey, 0, NULL, 0, KEY_READ | KEY_WRITE,
                        NULL, phkeySubkey, &dwDisposition
                        );
        }

    
    } while(FALSE);

    if (hkeyRouter) { RegCloseKey(hkeyRouter); }

    Free(lpwsPath);

    return dwErr;
}


//----------------------------------------------------------------------------
// Function:    DeleteRegistryTree
//
// Delete the tree of registry values starting at hkRoot
//----------------------------------------------------------------------------

DWORD
DeleteRegistryTree(
    HKEY hkRoot
    )
{

    DWORD dwErr = NO_ERROR;
    DWORD dwCount, dwNameSize, dwDisposition, i, dwCurNameSize;
    PWCHAR pszNameBuf;
    HKEY hkTemp;
    
    //
    // Find out how many keys there are in the source
    //

    dwErr =
        RegQueryInfoKey(
            hkRoot, NULL,NULL,NULL, &dwCount, &dwNameSize, NULL, NULL, NULL,
            NULL, NULL, NULL
            );
    if (dwErr != ERROR_SUCCESS) { return dwErr; }
    
    dwNameSize++;

    do
    {
        //
        // Allocate the buffers
        //

        pszNameBuf = (PWCHAR)Malloc(dwNameSize * sizeof(WCHAR));

        if (!pszNameBuf) 
        { 
            dwErr = ERROR_NOT_ENOUGH_MEMORY; 
            break;
        }

        //
        // Loop through the keys -- deleting all subkey trees
        //

        for (i = 0; i < dwCount; i++) {

            dwCurNameSize = dwNameSize;

            //
            // Get the current source key 
            //

            dwErr =
                RegEnumKeyExW(
                    hkRoot, i, pszNameBuf, &dwCurNameSize, 0, NULL, NULL, NULL
                    );
            if (dwErr != ERROR_SUCCESS) { continue; }

            //
            // Open the subkey
            //

            dwErr =
                RegCreateKeyExW(
                    hkRoot, pszNameBuf, 0, NULL, REG_OPTION_NON_VOLATILE,
                    KEY_READ | KEY_WRITE | DELETE, NULL, &hkTemp, &dwDisposition
                    );
            if (dwErr != ERROR_SUCCESS) { continue; }

            //
            // Delete the subkey tree
            //

            DeleteRegistryTree(hkTemp);

            //
            // Close the temp handle
            //

            RegCloseKey(hkTemp);
        }

        //
        // Loop through the keys -- deleting all subkeys themselves
        //

        for (i = 0; i < dwCount; i++) {

            dwCurNameSize = dwNameSize;

            //
            // Get the current source key 
            //

            dwErr =
                RegEnumKeyExW(
                    hkRoot, 0, pszNameBuf, &dwCurNameSize, 0, NULL, NULL, NULL
                    );
            if (dwErr != ERROR_SUCCESS) { continue; }

            //
            // Delete the subkey tree
            //

            dwErr = RegDeleteKey(hkRoot, pszNameBuf);
        }

        dwErr = NO_ERROR;
        
    } while (FALSE);

    // Cleanup
    {
        if (pszNameBuf) { Free(pszNameBuf); }
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    EnableBackupPrivilege
//
// Enables/disables backup privilege for the current process.
//----------------------------------------------------------------------------

DWORD
EnableBackupPrivilege(
    IN      BOOL            bEnable,
    IN      LPWSTR          pszPrivilege
    )
{

    LUID luid;
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tp;
    BOOL bOk;

    //
    // We first have to try to get the token of the current
    // thread since if it is impersonating, adjusting the 
    // privileges of the process will have no effect.
    //

    bOk =
        OpenThreadToken(
            GetCurrentThread(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, TRUE,
            &hToken
            );
    if (bOk == FALSE) {
        //
        // There is no thread token -- open it up for the 
        // process instead.
        //
        OpenProcessToken(
            GetCurrentProcess(), 
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
            &hToken
            );
    }

    //
    // Get the LUID of the privilege
    //

    if (!LookupPrivilegeValue(NULL, pszPrivilege, &luid)) {
        DWORD dwErr = GetLastError();
        if(NULL != hToken)
        {
            CloseHandle(hToken);
        }
        return dwErr;
    }

    //
    // Adjust the token privileges
    //

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Commit changes to the system
    //

    if (!AdjustTokenPrivileges(
            hToken, !bEnable, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL
            )) {
        DWORD dwErr = GetLastError();
        if(NULL != hToken)
        {   
            CloseHandle(hToken);
        }
        return dwErr;
    }

    //
    // Even if AdjustTokenPrivileges succeeded (see MSDN) you still
    // need to verify success by calling GetLastError.
    //

    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
    {
        if(NULL != hToken)
        {   
            CloseHandle(hToken);
        }
        return ERROR_NOT_ALL_ASSIGNED;
    }

    if(NULL != hToken)
    {   
        CloseHandle(hToken);
    }
    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    EnumInterfaces
//
// Enumerates the interfaces in the given key and calls the given callback
// for each one.
//
//----------------------------------------------------------------------------

DWORD 
EnumLanInterfaces (
    IN SERVERCB*                pserver,
    IN HKEY                     hkInterfaces, 
    IN PENUMIFCALLBACKFUNC      pCallback,
    IN DWORD                    dwData
    )
{
    DWORD dwErr, dwType, dwTypeVal, dwSize, dwCount, i;
    HKEY hkCurIf = NULL;
    WCHAR pszKey[5], pszName[512], pszTranslation[512];

    //
    // Get the count of interfaces under this key
    //

    dwErr =
        RegQueryInfoKey(
            hkInterfaces, NULL, NULL, NULL, &dwCount, NULL, NULL, NULL, NULL,
            NULL, NULL, NULL
            );
    if (dwErr != ERROR_SUCCESS) { return dwErr; }

    //
    // Loop through the interfaces, changing names as needed
    //

    for (i = 0; i < dwCount; i++) {
        //
        // Get the key
        //
        wsprintfW(pszKey, L"%d", i);
        dwErr = RegOpenKeyEx(hkInterfaces, pszKey, 0, KEY_READ | KEY_WRITE, &hkCurIf);
        if (dwErr != ERROR_SUCCESS) { continue; }
        //
        // Call the callback if the type is correct
        //
        dwSize = sizeof (DWORD);
        dwErr =
            RegQueryValueEx(
                hkCurIf, c_szType, NULL, &dwType, (LPBYTE)&dwTypeVal, &dwSize
                );
        if ((dwErr == ERROR_SUCCESS) &&
            (dwTypeVal == ROUTER_IF_TYPE_DEDICATED)) {
            (*pCallback)(pserver, hkCurIf, dwData);
        }
        //
        // Close the key
        //
        RegCloseKey (hkCurIf);
    }
    
    return NO_ERROR;
}

//----------------------------------------------------------------------------
// Function:    FormatServerNameForMprCfgApis
//
// Generates a standard server name for use in the MprConfig api's.
//
// The lpwsServerName member of the SERVERCB struct will be in the format
// returned by this function.
//
// If pszServer references the local machine, NULL is returned.
// Otherwise, a server name is returned in the form "\\<server>"
//
//----------------------------------------------------------------------------
DWORD 
FormatServerNameForMprCfgApis(
    IN  PWCHAR  pszServer, 
    OUT PWCHAR* ppszServer)
{
    PWCHAR pszServerPlain = NULL, pszServerOut = NULL;
    WCHAR pszBuffer[512];
    DWORD dwSize;
    BOOL bOk;

    // Null or empty string is empty
    //
    if ((pszServer == NULL) || (*pszServer == L'\0'))
    {
        *ppszServer = NULL;
        return NO_ERROR;
    }

    // Find out the name of the server 
    //
    pszServerPlain = pszServer;
    if (*pszServer == L'\\')
    {
        if ((*(pszServer + 2) == L'\\') || (*(pszServer + 2) == L'\0'))
        {
            return ERROR_BAD_FORMAT;
        }

        pszServerPlain = pszServer + 2;
    }

    // At this point, pszServerPlain is the name of a server.
    // Find out the name of the local machine
    //
    dwSize = sizeof(pszBuffer) / sizeof(WCHAR);
    bOk = GetComputerNameExW(ComputerNameNetBIOS, pszBuffer, &dwSize);
    if (!bOk)
    {
        return GetLastError();
    }

    // If the referenced machine is the local machine, return NULL
    //
    if (lstrcmpi(pszServerPlain, pszBuffer) == 0)
    {
        *ppszServer = NULL;
        return NO_ERROR;
    }

    // Otherwise, return a formatted remote server name
    //
    pszServerOut = (PWCHAR) 
        Malloc((2 + wcslen(pszServerPlain) + 1) * sizeof(WCHAR));
    if (pszServerOut == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    wcscpy(pszServerOut, L"\\\\");
    wcscpy(pszServerOut + 2, pszServerPlain);
    *ppszServer = pszServerOut;

    return NO_ERROR;
}

//----------------------------------------------------------------------------
// Function:    FreeIfTransport
//
// Frees the context for an interface-transport.
// Assumes the interface-transport is no longer in any list.
//----------------------------------------------------------------------------

VOID
FreeIfTransport(
    IN      IFTRANSPORTCB*  piftransport
    )
{

    if (piftransport->hkey) { RegCloseKey(piftransport->hkey); }

    Free0(piftransport->lpwsIfTransportKey);

    Free(piftransport);
}



//----------------------------------------------------------------------------
// Function:    FreeInterface
//
// Frees the context for an interface.
// Assumes the interface is no longer in the list of interfaces.
//----------------------------------------------------------------------------

VOID
FreeInterface(
    IN      INTERFACECB*    pinterface
    )
{

    //
    // clean up all the interface's transport objects
    //

    LIST_ENTRY *ple, *phead;

    phead = &pinterface->lhIfTransports;

    while (!IsListEmpty(phead)) {

        //
        // retrieve the next interface-transport object
        //

        IFTRANSPORTCB* piftransport;

        ple = RemoveHeadList(phead);

        piftransport = CONTAINING_RECORD(ple, IFTRANSPORTCB, leNode);


        //
        // clean up the interface-transport object
        //

        FreeIfTransport(piftransport);
    }


    //
    // clean up the interface object
    //

    if (pinterface->hkey) { RegCloseKey(pinterface->hkey); }

    Free0(pinterface->lpwsInterfaceKey);

    Free0(pinterface->lpwsInterfaceName);

    Free0(pinterface->lpwsDialoutHoursRestriction);

    Free(pinterface);
}


//----------------------------------------------------------------------------
// Function:    FreeTransport
//
// Frees the context for a transport.
// Assumes the transport is no longer in the list of transports.
//----------------------------------------------------------------------------

VOID
FreeTransport(
    IN      TRANSPORTCB*    ptransport
    )
{

    if (ptransport->hkey) { RegCloseKey(ptransport->hkey); }

    Free0(ptransport->lpwsTransportKey);

    Free(ptransport);
}



//----------------------------------------------------------------------------
// Function:    GetLocalMachine
//
// Retrieves the name of the local machine (e.g. "\\MACHINE").
// Assumes the string supplied can hold MAX_COMPUTERNAME_LENGTH + 3 characters.
//----------------------------------------------------------------------------

VOID
GetLocalMachine(
    IN      LPWSTR      lpwszMachine
    )
{

    DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;

    lstrcpy(lpwszMachine, c_szUncPrefix);

    GetComputerName(lpwszMachine + 2, &dwSize);
}


//----------------------------------------------------------------------------
// Function:    IsNt40Machine
//
// Returns whether the given hkeyMachine belongs to an nt40 registry
//----------------------------------------------------------------------------

DWORD
IsNt40Machine (
    IN      HKEY        hkeyMachine,
    OUT     PBOOL       pbIsNt40
    )
{

    DWORD dwErr = NO_ERROR;
    DWORD dwType = REG_SZ, dwLength = 64 * sizeof(WCHAR);
    HKEY hkeyVersion;
    WCHAR pszBuildNumber[64];

    //
    // Validate and initialize
    //

    if (!pbIsNt40) { return ERROR_INVALID_PARAMETER; }

    *pbIsNt40 = FALSE;

    //
    // Open the windows version key
    //

    dwErr = RegOpenKeyEx(
                hkeyMachine, c_szWinVersionPath, 0, KEY_READ, &hkeyVersion
                );

    if (dwErr != NO_ERROR) { return dwErr; }

    do
    {

        //
        // Read in the current version key
        //

        dwErr = RegQueryValueEx (
                    hkeyVersion, c_szCurrentBuildNumber, NULL, &dwType,
                    (BYTE*)pszBuildNumber, &dwLength
                    );
        
        if (dwErr != NO_ERROR) 
        { 
            dwErr = NO_ERROR;
            break; 
        }

        if (lstrcmp (pszBuildNumber, c_szNt40BuildNumber) == 0) 
        {
            *pbIsNt40 = TRUE;
        }
        
    } while (FALSE);

    // Cleanup
    {
        RegCloseKey(hkeyVersion);
    }

    return dwErr;
}    


//----------------------------------------------------------------------------
// Function:    LoadIfTransports
//
// Loads all the transports added to an interface.
//----------------------------------------------------------------------------

DWORD
LoadIfTransports(
    IN      INTERFACECB*    pinterface
    )
{

    LPWSTR lpwsKey;
    HKEY hkeyIfTransport;
    IFTRANSPORTCB* piftransport;
    LIST_ENTRY *ple, *phead;
    DWORD i, dwErr, dwProtocolId, dwKeyCount, dwMaxKeyLength, dwType, dwLength;


    //
    // Any subkey of the Interfaces\<interface> key with a 'ProtocolId' value
    // is assumed to be a valid interface-transport.
    // Begin by marking all interfaces as 'deleted'.
    //

    phead = &pinterface->lhIfTransports;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        piftransport = CONTAINING_RECORD(ple, IFTRANSPORTCB, leNode);

        piftransport->bDeleted = TRUE;
    }


    //
    // Get information about the interface key
    //

    dwErr = RegQueryInfoKey(
                pinterface->hkey, NULL, NULL, NULL, &dwKeyCount,
                &dwMaxKeyLength, NULL, NULL, NULL, NULL, NULL, NULL
                );

    if (dwErr != NO_ERROR) { return dwErr; }

    if (!dwKeyCount) { return NO_ERROR; }


    //
    // Allocate space to hold the key-names to be enumerated
    //

    lpwsKey = (LPWSTR)Malloc((dwMaxKeyLength + 1) * sizeof(WCHAR));

    if (!lpwsKey) { return ERROR_NOT_ENOUGH_MEMORY; }


    //
    // Now enumerate the keys, creating interface-transport objects
    // for each key which contains a 'ProtocolId' value
    //

    for (i = 0; i < dwKeyCount; i++) {

        //
        // Get the next key name
        //

        dwLength = dwMaxKeyLength + 1;

        dwErr = RegEnumKeyEx(
                    pinterface->hkey, i, lpwsKey, &dwLength, NULL, NULL, NULL,
                    NULL
                    );

        if (dwErr != NO_ERROR) { break; }


        //
        // Open the key
        //

        dwErr = RegOpenKeyEx(
                    pinterface->hkey, lpwsKey, 0, KEY_READ | KEY_WRITE | DELETE,
                    &hkeyIfTransport
                    );

        if (dwErr != NO_ERROR) { continue; }

        do {
    
            //
            // See if the ProtocolId is present
            //
    
            dwLength = sizeof(dwProtocolId);
    
            dwErr = RegQueryValueEx(
                        hkeyIfTransport, c_szProtocolId, NULL, &dwType,
                        (BYTE*)&dwProtocolId, &dwLength
                        );
    
            if (dwErr != NO_ERROR) { dwErr = NO_ERROR; break; }
    
    
            //
            // The ProtocolId is present;
            // search for this interface-transport in the existing list
            //
    
            piftransport = NULL;
            phead = &pinterface->lhIfTransports;
    
            for (ple = phead->Flink; ple != phead; ple = ple->Flink) {
    
                piftransport = CONTAINING_RECORD(ple, IFTRANSPORTCB, leNode);

                if (piftransport->dwTransportId >= dwProtocolId) { break; }
            }
    
    
            //
            // If we found the interface-transport in our list, continue
            //
    
            if (piftransport && piftransport->dwTransportId == dwProtocolId) {

                piftransport->bDeleted = FALSE;

                // Free up the old key, it may have been deleted
                // (and readded).
                if (piftransport->hkey)
                    RegCloseKey(piftransport->hkey);
                piftransport->hkey = hkeyIfTransport; hkeyIfTransport = NULL;
                dwErr = NO_ERROR; break;
            }
    
    
            //
            // The interface-transport isn't listed; create an object for it
            //
    
            piftransport = Malloc(sizeof(*piftransport));
    
            if (!piftransport) { dwErr = ERROR_NOT_ENOUGH_MEMORY; break; }
    
            ZeroMemory(piftransport, sizeof(*piftransport));

            piftransport->dwTransportId = dwProtocolId;

    
            //
            // duplicate the name of the interface-transport's key
            //

            piftransport->lpwsIfTransportKey = StrDupW(lpwsKey);
    
            if (!piftransport->lpwsIfTransportKey) {
                Free(piftransport); dwErr = ERROR_NOT_ENOUGH_MEMORY; break;
            }
 
            piftransport->hkey = hkeyIfTransport; hkeyIfTransport = NULL;


            //
            // insert the interface-transport in the list;
            // the above search supplied the point of insertion
            //

            InsertTailList(ple, &piftransport->leNode);

            dwErr = NO_ERROR;

        } while(FALSE);

        if (hkeyIfTransport) { RegCloseKey(hkeyIfTransport); }

        if (dwErr != NO_ERROR) { break; }
    }

    Free(lpwsKey);


    //
    // Remove all objects still marked for deletion
    //

    phead = &pinterface->lhIfTransports;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        piftransport = CONTAINING_RECORD(ple, IFTRANSPORTCB, leNode);

        if (!piftransport->bDeleted) { continue; }


        //
        // Clean up the object, adjusting the list-pointer back by one.
        //

        ple = ple->Blink; RemoveEntryList(&piftransport->leNode);

        FreeIfTransport(piftransport);
    }

    UpdateTimeStamp(pinterface->hkey, &pinterface->ftStamp);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    LoadInterfaces
//
// Loads all the interfaces.
//----------------------------------------------------------------------------

DWORD
LoadInterfaces(
    IN      SERVERCB*       pserver
    )
{

    INT cmp;
    LPWSTR lpwsKey;
    HKEY hkeyInterface;
    INTERFACECB* pinterface;
    LIST_ENTRY *ple, *phead;
    WCHAR wszInterface[MAX_INTERFACE_NAME_LEN+1];
    DWORD i, dwErr, dwIfType, dwKeyCount, dwMaxKeyLength, dwType, dwLength;
    BOOL fEnabled, fAdapterInstalled;
    DWORD dwMaxValueLength;
    LPBYTE lpBuffer = NULL;

    //
    // Any subkey of the Interfaces key which has a 'Type' value
    // is assumed to be a valid interface.
    // Begin by marking all interfaces as 'deleted'.
    //

    phead = &pserver->lhInterfaces;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pinterface = CONTAINING_RECORD(ple, INTERFACECB, leNode);

        pinterface->bDeleted = TRUE;
    }


    //
    // Open the Interfaces key if it is not already open
    //

    if (!pserver->hkeyInterfaces) {

        //
        // If we cannot open the Interfaces key, assume it doesn't exist
        // and therefore that there are no interfaces.
        //

        dwErr = AccessRouterSubkey(
                    pserver->hkeyMachine, c_szInterfaces, FALSE,
                    &pserver->hkeyInterfaces
                    );

        if (dwErr != NO_ERROR) { return NO_ERROR; }
    }


    //
    // Get information about the Interfaces key;
    // we need to know how many subkeys it has and the maximum length
    // of all subkey-names
    //

    dwErr = RegQueryInfoKey(
                pserver->hkeyInterfaces, NULL, NULL, NULL, &dwKeyCount,
                &dwMaxKeyLength, NULL, NULL, NULL, NULL, NULL, NULL
                );

    if (dwErr != NO_ERROR) { return dwErr; }

    if (!dwKeyCount) { return NO_ERROR; }


    //
    // allocate space to hold the key-names to be enumerated
    //

    lpwsKey = (LPWSTR)Malloc((dwMaxKeyLength + 1) * sizeof(WCHAR));

    if (!lpwsKey) { return ERROR_NOT_ENOUGH_MEMORY; }


    //
    // Now we enumerate the keys, creating interface-objects
    // for each key which contains a 'Type' value
    //

    for (i = 0; i < dwKeyCount; i++) {

        //
        // Get the next key name
        //

        dwLength = dwMaxKeyLength + 1;

        dwErr = RegEnumKeyEx(
                    pserver->hkeyInterfaces, i, lpwsKey, &dwLength,
                    NULL, NULL, NULL, NULL
                    );

        if (dwErr != NO_ERROR) { break; }


        //
        // Open the key
        //

        dwErr = RegOpenKeyEx(
                    pserver->hkeyInterfaces, lpwsKey, 0, KEY_READ | KEY_WRITE | DELETE,
                    &hkeyInterface
                    );

        if (dwErr != NO_ERROR) { continue; }

        do {


            //
            // See if the InterfaceName is present
            //

            dwLength = sizeof(wszInterface);

            dwErr = RegQueryValueEx(
                        hkeyInterface, c_szInterfaceName, NULL, &dwType,
                        (BYTE*)&wszInterface, &dwLength
                        );

            if (dwErr != NO_ERROR) { dwErr = NO_ERROR; break; }

    
            //
            // See if the Type is present 
            //
    
            dwLength = sizeof(dwIfType);
    
            dwErr = RegQueryValueEx(
                        hkeyInterface, c_szType, NULL, &dwType,
                        (BYTE*)&dwIfType, &dwLength
                        );
    
            if (dwErr != NO_ERROR) { dwErr = NO_ERROR; break; }

            //
            // As of Whistler, ipip tunnels are not supported
            //
            if ( dwIfType == ROUTER_IF_TYPE_TUNNEL1 )
            {
                break;
            }

            //
            // See if the enabled is present
            //

            dwLength = sizeof(fEnabled);

            dwErr = RegQueryValueEx(
                        hkeyInterface, c_szEnabled, NULL, &dwType,
                        (BYTE*)&fEnabled, &dwLength
                        );

            if ( dwErr == ERROR_FILE_NOT_FOUND )
            {
                fEnabled = TRUE;

                dwErr = NO_ERROR;
            }

            if (dwErr != NO_ERROR) { dwErr = NO_ERROR; break; }

            //
            // The InterfaceName and Type are present;
            // search for this interface in the existing list
            //
    
            cmp = 1;
            pinterface = NULL;
            phead = &pserver->lhInterfaces;
    
            for (ple = phead->Flink; ple != phead; ple = ple->Flink) {
    
                pinterface = CONTAINING_RECORD(ple, INTERFACECB, leNode);
    
                cmp = lstrcmpi(pinterface->lpwsInterfaceName, wszInterface);

                if (cmp >= 0) { break; }
            }
    
    
            //
            // If we found the interface in our list, continue
            //
    
            if (pinterface && cmp == 0) {
                pinterface->bDeleted = FALSE;
                dwErr = NO_ERROR;

                // Use the new registry value (the old one may have
                // been replaced).
                if (pinterface->hkey)
                    RegCloseKey(pinterface->hkey);
                
                pinterface->hkey = hkeyInterface; hkeyInterface = NULL;
            }
            else {
        
                //
                // The interface isn't in our list; create an object for it
                //
        
                pinterface = Malloc(sizeof(*pinterface));
        
                if (!pinterface) { dwErr = ERROR_NOT_ENOUGH_MEMORY; break; }
        
                ZeroMemory(pinterface, sizeof(*pinterface));
    
        
                //
                // Duplicate the name of the interface's key
                // as well as the name of the interface itself
                //
    
                pinterface->lpwsInterfaceKey = StrDupW(lpwsKey);
        
                if (!pinterface->lpwsInterfaceKey) {
                    Free(pinterface); dwErr = ERROR_NOT_ENOUGH_MEMORY; break;
                }
     
                pinterface->lpwsInterfaceName = StrDupW(wszInterface);
    
                if (!pinterface->lpwsInterfaceName) {
                    Free(pinterface->lpwsInterfaceKey);
                    Free(pinterface); dwErr = ERROR_NOT_ENOUGH_MEMORY; break;
                }
    
                pinterface->fEnabled = fEnabled;
                pinterface->dwIfType = dwIfType;
                pinterface->hkey = hkeyInterface; hkeyInterface = NULL;
                InitializeListHead(&pinterface->lhIfTransports);
        
    
                //
                // insert the interface in the list;
                // the above search supplied the point of insertion
                //
    
                InsertTailList(ple, &pinterface->leNode);
            }

            //
            // Now read optional fields.
            //

            Free0(pinterface->lpwsDialoutHoursRestriction);
            pinterface->lpwsDialoutHoursRestriction = NULL;

            //
            // Load the dial-out hours restriction value.
            //

            dwErr = RegQueryInfoKey(
                        pinterface->hkey, NULL, NULL, NULL, NULL,
                        NULL, NULL, NULL, NULL, &dwMaxValueLength, NULL, NULL
                        );

            if (dwErr != NO_ERROR) { break; }

            lpBuffer = Malloc(dwMaxValueLength);

            if (!lpBuffer) { dwErr = ERROR_NOT_ENOUGH_MEMORY; break; }

            //
            // Read the 'DialoutHours'
            //

            dwLength = dwMaxValueLength;

            dwErr =
                RegQueryValueEx(
                    pinterface->hkey, c_szDialoutHours, NULL, &dwType,
                    (BYTE*)lpBuffer, &dwLength
                    );

            if (dwErr == NO_ERROR) {

                pinterface->lpwsDialoutHoursRestriction =
                    (LPWSTR)Malloc(dwLength);

                if (!pinterface->lpwsDialoutHoursRestriction) {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY; break;
                }

                CopyMemory(
                    pinterface->lpwsDialoutHoursRestriction, lpBuffer, dwLength
                    );
            }

            dwErr = NO_ERROR;

        } while(FALSE);

        if (hkeyInterface) { RegCloseKey(hkeyInterface); }

        Free0(lpBuffer); lpBuffer = NULL;

        if (dwErr != NO_ERROR) { break; }
    }

    Free(lpwsKey);


    //
    // Clean up all objects still marked for deletion
    //

    phead = &pserver->lhInterfaces;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        pinterface = CONTAINING_RECORD(ple, INTERFACECB, leNode);

        if (pinterface->bDeleted) {

            //
            // Clean up the object, adjusting our list-pointer back by one.
            //
    
            ple = ple->Blink; RemoveEntryList(&pinterface->leNode);

            FreeInterface(pinterface);

            continue;
        }
    }

    UpdateTimeStamp(pserver->hkeyInterfaces, &pserver->ftInterfacesStamp);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    LoadParameters
//
// Loads all the parameters.
//----------------------------------------------------------------------------

DWORD
LoadParameters(
    IN      SERVERCB*       pserver
    )
{

    LPWSTR lpwsKey;
    DWORD dwErr, dwLength, dwType;

    if (!pserver->hkeyParameters) {

        dwErr = AccessRouterSubkey(
                    pserver->hkeyMachine, c_szParameters, FALSE,
                    &pserver->hkeyParameters
                    );

        if (dwErr != NO_ERROR) { return NO_ERROR; }
    }

    dwLength = sizeof(pserver->fRouterType);

    dwErr = RegQueryValueEx(
                pserver->hkeyParameters, c_szRouterType, NULL, &dwType,
                (BYTE*)&pserver->fRouterType, &dwLength
                );

    if (dwErr != NO_ERROR) { return dwErr; }

    UpdateTimeStamp(pserver->hkeyParameters, &pserver->ftParametersStamp);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    LoadTransports
//
// Loads all the transports.
//----------------------------------------------------------------------------

DWORD
LoadTransports(
    IN      SERVERCB*       pserver
    )
{

    LPWSTR lpwsKey;
    HKEY hkeyTransport;
    TRANSPORTCB* ptransport;
    LIST_ENTRY *ple, *phead;
    DWORD i, dwErr, dwKeyCount, dwMaxKeyLength, dwProtocolId, dwType, dwLength;



    //
    // Any subkey of the RouterManagers key which has a 'ProtocolId' value
    // is assumed to be a valid transport.
    // Begin by marking all transports as 'deleted'
    //

    phead = &pserver->lhTransports;

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        ptransport = CONTAINING_RECORD(ple,TRANSPORTCB, leNode);

        ptransport->bDeleted = TRUE;
    }


    //
    // We will enumerate by calling RegEnumKeyEx repeatedly,
    // so open the transports key if it is not already open
    //

    if (!pserver->hkeyTransports) {

        //
        // If we cannot open the RouterManagers key, assume it doesn't exist
        // and therefore that there are no transports.
        //

        dwErr = AccessRouterSubkey(
                    pserver->hkeyMachine, c_szRouterManagers, FALSE,
                    &pserver->hkeyTransports
                    );

        if (dwErr != NO_ERROR) { return NO_ERROR; }
    }



    //
    // Get information about the RouterManagers key;
    // we need to know how many subkeys it has and
    // the maximum length of all subkey-names
    //

    dwErr = RegQueryInfoKey(
                pserver->hkeyTransports, NULL, NULL, NULL, &dwKeyCount,
                &dwMaxKeyLength, NULL, NULL, NULL, NULL, NULL, NULL
                );

    if (dwErr != NO_ERROR) { return dwErr; }

    if (!dwKeyCount) { return NO_ERROR; }


    //
    // allocate space to hold the key-names to be enumerated
    //

    lpwsKey = (LPWSTR)Malloc((dwMaxKeyLength + 1) * sizeof(WCHAR));

    if (!lpwsKey) { return ERROR_NOT_ENOUGH_MEMORY; }


    //
    // Now we enumerate the keys, creating transport-objects
    // for each key which contains a 'ProtocolId' value
    //

    for (i = 0; i < dwKeyCount; i++) {

        //
        // get the next key name
        //

        dwLength = dwMaxKeyLength + 1;

        dwErr = RegEnumKeyEx(
                    pserver->hkeyTransports, i, lpwsKey, &dwLength,
                    NULL, NULL, NULL, NULL
                    );

        if (dwErr != NO_ERROR) { break; }


        //
        // Open the key
        //

        dwErr = RegOpenKeyEx(
                    pserver->hkeyTransports, lpwsKey, 0, KEY_READ | KEY_WRITE | DELETE,
                    &hkeyTransport
                    );

        if (dwErr != NO_ERROR) { continue; }

        do {
    
            //
            // see if the protocol ID is present 
            //
    
            dwLength = sizeof(dwProtocolId);
    
            dwErr = RegQueryValueEx(
                        hkeyTransport, c_szProtocolId, NULL, &dwType,
                        (BYTE*)&dwProtocolId, &dwLength
                        );
    
            if (dwErr != NO_ERROR) { dwErr = NO_ERROR; break; }
    
    
            //
            // the protocol ID is present;
            // search for this protocol in the existing list
            //
    
            ptransport = NULL;
            phead = &pserver->lhTransports;
    
            for (ple = phead->Flink; ple != phead; ple = ple->Flink) {
    
                ptransport = CONTAINING_RECORD(ple,TRANSPORTCB, leNode);
    
                if (ptransport->dwTransportId >= dwProtocolId) { break; }
            }
    
    
            //
            // if we found the transport in our list, continue
            //
    
            if (ptransport && ptransport->dwTransportId == dwProtocolId) {

                ptransport->bDeleted = FALSE;

                // Use the new key, the old one may have been deleted
                if (ptransport->hkey)
                    RegCloseKey(ptransport->hkey);
                ptransport->hkey = hkeyTransport; hkeyTransport = NULL;
                dwErr = NO_ERROR;
                break;
            }
    
    
            //
            // The transport isn't in our list; create an object for it
            //
    
            ptransport = Malloc(sizeof(*ptransport));
    
            if (!ptransport) { dwErr = ERROR_NOT_ENOUGH_MEMORY; break; }

            ZeroMemory(ptransport, sizeof(*ptransport));
    
    
            //
            // duplicate the name of the transport's key
            //

            ptransport->lpwsTransportKey = StrDupW(lpwsKey);
    
            if (!ptransport->lpwsTransportKey) {
                Free(ptransport); dwErr = ERROR_NOT_ENOUGH_MEMORY; break;
            }
 
            ptransport->dwTransportId = dwProtocolId;
            ptransport->hkey = hkeyTransport; hkeyTransport = NULL;
    

            //
            // insert the transport in the list;
            // the above search supplied the point of insertion
            //

            InsertTailList(ple, &ptransport->leNode);

            dwErr = NO_ERROR;

        } while(FALSE);

        if (hkeyTransport) { RegCloseKey(hkeyTransport); }

        if (dwErr != NO_ERROR) { break; }
    }

    Free(lpwsKey);


    //
    // Clean up all objects still marked for deletion
    //

    for (ple = phead->Flink; ple != phead; ple = ple->Flink) {

        ptransport = CONTAINING_RECORD(ple, TRANSPORTCB, leNode);

        if (!ptransport->bDeleted) { continue; }

        //
        // Clean up the object, adjusting our list-pointer back by one.
        //

        ple = ple->Blink; RemoveEntryList(&ptransport->leNode);

        FreeTransport(ptransport);
    }

    UpdateTimeStamp(pserver->hkeyTransports, &pserver->ftTransportsStamp);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MapInterfaceNamesCb
//
// Changes the name of an interface
//----------------------------------------------------------------------------

DWORD
MapInterfaceNamesCb(
    IN SERVERCB*    pserver,
    IN HKEY         hkInterface, 
    IN DWORD        dwData
    )
{
    WCHAR pszName[512], pszTranslation[512];
    DWORD dwErr, dwType, dwSize;
    
    //
    // Map and change the name
    //

    dwSize = sizeof(pszName);
    dwErr =
        RegQueryValueEx(
            hkInterface, c_szInterfaceName, NULL, &dwType, (LPBYTE)pszName,
            &dwSize
            );
    if (dwErr == ERROR_SUCCESS) {
        if (dwData) {
            dwErr =
                MprConfigGetFriendlyName(
                    (HANDLE)pserver, 
                    pszName,
                    pszTranslation,
                    sizeof(pszTranslation)
                    );
        }
        else {
            dwErr =
                MprConfigGetGuidName(
                    (HANDLE)pserver, 
                    pszName,
                    pszTranslation,
                    sizeof(pszTranslation) 
                    );
        }
        if (dwErr == NO_ERROR) {
            RegSetValueEx(
                hkInterface,
                c_szInterfaceName,
                0,
                REG_SZ,
                (CONST BYTE*)pszTranslation,
                lstrlen(pszTranslation) * sizeof(WCHAR) + sizeof(WCHAR)
            );
        }
    }
    
    return NO_ERROR;        
}        




//----------------------------------------------------------------------------
// Function:    QueryValue
//
// Queries the 'hkey' for the value 'lpwsValue', allocating memory
// for the resulting data
//----------------------------------------------------------------------------

DWORD
QueryValue(
    IN      HKEY            hkey,
    IN      LPCWSTR         lpwsValue,
    IN  OUT LPBYTE*         lplpValue,
    OUT     LPDWORD         lpdwSize
    )
{

    DWORD dwErr, dwType;

    *lplpValue = NULL;
    *lpdwSize = 0;


    //
    // retrieve the size of the value; if this fails,
    // assume the value doesn't exist and return successfully
    //

    dwErr = RegQueryValueEx(
                hkey, lpwsValue, NULL, &dwType, NULL, lpdwSize
                );

    if (dwErr != NO_ERROR) { return NO_ERROR; }
 

    //
    // allocate space for the value
    //

    *lplpValue = (LPBYTE)Malloc(*lpdwSize);

    if (!lplpValue) { return ERROR_NOT_ENOUGH_MEMORY; }

    //
    // retrieve the data for the value
    //

    dwErr = RegQueryValueEx(
                hkey, lpwsValue, NULL, &dwType, *lplpValue, lpdwSize
                );

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    RegDeleteTree
//
// Removes an entire subtree from the registry.
//----------------------------------------------------------------------------

DWORD
RegDeleteTree(
    IN      HKEY        hkey,
    IN      LPWSTR      lpwsSubkey
    )
{

    HKEY hkdel;
    DWORD dwErr;
    PTSTR pszKey = NULL;


    //
    // open the key to be deleted
    //

    dwErr = RegOpenKeyEx(hkey, lpwsSubkey, 0, KEY_READ | KEY_WRITE | DELETE, &hkdel);

    if (dwErr != ERROR_SUCCESS) { return dwErr; }


    do {

        //
        // retrieve information about the subkeys of the key
        //

        DWORD i, dwSize;
        DWORD dwKeyCount, dwMaxKeyLength;

        dwErr = RegQueryInfoKey(
                    hkdel, NULL, NULL, NULL, &dwKeyCount, &dwMaxKeyLength,
                    NULL, NULL, NULL, NULL, NULL, NULL
                    );
        if (dwErr != ERROR_SUCCESS) { break; }


        //
        // Allocate enough space for the longest keyname
        //

        pszKey = Malloc((dwMaxKeyLength + 1) * sizeof(WCHAR));

        if (!pszKey) { dwErr = ERROR_NOT_ENOUGH_MEMORY; break; }


        //
        // Enumerate the subkeys
        //

        for (i = 0; i < dwKeyCount; i++) {

            //
            // Get the name of the 0'th subkey
            //

            dwSize = dwMaxKeyLength + 1;

            dwErr = RegEnumKeyEx(
                        hkdel, 0, pszKey, &dwSize, NULL, NULL, NULL, NULL
                        );

            if (dwErr != ERROR_SUCCESS) { continue; }


            //
            // Make recursive call to delete the subkey
            //

            dwErr = RegDeleteTree(hkdel, pszKey);
        }

    } while(FALSE);

    if (pszKey) { Free(pszKey); }

    RegCloseKey(hkdel);

    if (dwErr != ERROR_SUCCESS) { return dwErr; }

    //
    // At this point all subkeys should have been deleted,
    // and we can call the registry API to delete the argument key
    //

    return RegDeleteKey(hkey, lpwsSubkey);
}



//----------------------------------------------------------------------------
// Function:    RestoreAndTranslateInterfaceKey
//
// Restores the interfaces key from the given file and then maps lan interface
// names from friendly versions to their guid equivalents.
//
//----------------------------------------------------------------------------

DWORD 
RestoreAndTranslateInterfaceKey(
    IN SERVERCB*    pserver, 
    IN CHAR*        pszFileName, 
    IN DWORD        dwFlags
    )
{
    DWORD dwErr; 

    //
    // Restore the interfaces key from the given file
    //

    dwErr = RegRestoreKeyA(pserver->hkeyInterfaces, pszFileName, dwFlags);
    if (dwErr != NO_ERROR) { return dwErr; }

    //
    // Update the lan interface names
    //

    dwErr =
        EnumLanInterfaces(
            pserver, 
            pserver->hkeyInterfaces, 
            MapInterfaceNamesCb, 
            FALSE
            );
 
    return dwErr;
}

//----------------------------------------------------------------------------
// Function:    ServerCbAdd
//
// Adds a SERVERCB to the global table.
//
// Assumes lock on MprConfig api's is held
//----------------------------------------------------------------------------

DWORD
ServerCbAdd(
    IN SERVERCB* pServer)
{
    DWORD dwErr = NO_ERROR;

    // Create the global table if needed
    // 
    if (g_htabServers == NULL)
    {
        dwErr = HashTabCreate(
                    SERVERCB_HASH_SIZE,
                    ServerCbHash,
                    ServerCbCompare,
                    NULL,
                    NULL,
                    NULL,
                    &g_htabServers);
                    
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
    }

    // Add the SERVERCB
    //
    return HashTabInsert(
                g_htabServers,
                (HANDLE)pServer->lpwsServerName,
                (HANDLE)pServer);
}

//----------------------------------------------------------------------------
// Function:    ServerCbHash
//
// Compares a server name to a SERVERCB
//----------------------------------------------------------------------------

int 
ServerCbCompare(
    IN HANDLE hKey, 
    IN HANDLE hData)
{
    PWCHAR pszServer = (PWCHAR)hKey;
    SERVERCB* pServer = (SERVERCB*)hData;

    if (pszServer == NULL)
    {
        if (pServer->lpwsServerName == NULL)
        {
            return 0;
        }
        else
        {
            return -1;
        }
    }
    else if (pServer->lpwsServerName == NULL)
    {
        return 1;
    }

    return lstrcmpi(pszServer, pServer->lpwsServerName);
}

DWORD
ServerCbDelete(
    IN SERVERCB* pServer)
{
    DWORD dwErr, dwCount = 0;

    // Create the global table if needed
    // 
    if (g_htabServers == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Remove the SERVERCB
    //
    dwErr = HashTabRemove(
                g_htabServers,
                (HANDLE)pServer->lpwsServerName);
                
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Cleanup the hash table if needed
    //
    dwErr = HashTabGetCount(g_htabServers, &dwCount);

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    if (dwCount == 0)
    {
        HashTabCleanup(g_htabServers);
        g_htabServers = NULL;
    }
    
    return NO_ERROR; 
}

//----------------------------------------------------------------------------
// Function:    ServerCbFind
//
// Searches the global table of server control blocks for a SERVERCB that
// corrosponds to the given server.
//
// Return values:
//    NO_ERROR:         a matching SERVERCB was found
//    ERROR_NOT_FOUND:  a matching SERVERCB was not found
//    Standard error:   an error occurred
//
// Notes:
//    Assumes lock on the mpr config api's is held
//
//----------------------------------------------------------------------------
DWORD 
ServerCbFind(
    IN  PWCHAR  pszServer, 
    OUT SERVERCB** ppServerCB)
{
    // Create the global table if needed
    // 
    if (g_htabServers == NULL)
    {
        return ERROR_NOT_FOUND;
    }

    return HashTabFind(g_htabServers, (HANDLE)pszServer, (HANDLE*)ppServerCB);
}

//----------------------------------------------------------------------------
// Function:    ServerCbHash
//
// Hash function used to define the index of a bucket
// containing a SERVERCB based on a server name
//----------------------------------------------------------------------------

ULONG 
ServerCbHash(
    IN HANDLE hData)
{
    PWCHAR pszServer = (PWCHAR)hData;
    DWORD dwTotal = 0;

    while (pszServer && *pszServer)
    {
        dwTotal += (DWORD)(*pszServer);
        pszServer++;
    }

    return dwTotal % SERVERCB_HASH_SIZE;
}

//----------------------------------------------------------------------------
// Function:    StrDupW
//
// Returns a heap-allocated copy of the specified string.
//----------------------------------------------------------------------------

LPWSTR
StrDupW(
    IN      LPCWSTR      lpws
    )
{

    INT len;
    LPWSTR lpwsCopy;

    if (!lpws) { return NULL; }

    len = lstrlen(lpws) + 1;

    lpwsCopy = (LPWSTR)Malloc(len * sizeof(WCHAR));

    if (lpwsCopy) { lstrcpy(lpwsCopy, lpws); }

    return lpwsCopy;
}



//----------------------------------------------------------------------------
// Function:    TimeStampChanged
//
// Checks the current last-write-time for the given key,
// and returns TRUE if it is different from the given file-time.
// The new last-write-time is saved in 'pfiletime'.
//----------------------------------------------------------------------------

BOOL
TimeStampChanged(
    IN      HKEY            hkey,
    IN  OUT FILETIME*       pfiletime
    )
{

    DWORD dwErr;
    FILETIME filetime;


    //
    // Read the new last-write-time
    //

    dwErr = RegQueryInfoKey(
                hkey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                NULL, NULL, &filetime
                );

    if (dwErr != NO_ERROR) { return FALSE; }


    //
    // Perform the comparison of the times
    //

    return (CompareFileTime(&filetime, pfiletime) ? TRUE : FALSE);
}



//----------------------------------------------------------------------------
// Function:    TranslateAndSaveInterfaceKey
//
// Saves the interfaces key in the router's registry into the given file. All
// lan interfaces are stored with friendly interface names.
//
//----------------------------------------------------------------------------

DWORD 
TranslateAndSaveInterfaceKey(
    IN SERVERCB*                pserver, 
    IN PWCHAR                   pwsFileName, 
    IN LPSECURITY_ATTRIBUTES    lpSecurityAttributes
    )
{
    static const WCHAR pszTemp[] = L"BackupInterfaces";
    DWORD dwErr = NO_ERROR, dwDisposition;
    HKEY hkTemp = NULL;

    //
    // Enable restore privelege
    //

    EnableBackupPrivilege(TRUE, SE_RESTORE_NAME);
    
    //
    // Create a temporary key into which the saved router configuration 
    // can be loaded.
    //

    dwErr =
        RegCreateKeyExW(
            pserver->hkeyParameters, 
            pszTemp, 
            0, 
            NULL, 
            REG_OPTION_NON_VOLATILE,
            KEY_READ | KEY_WRITE | DELETE, 
            NULL,
            &hkTemp,
            &dwDisposition
            );
    if (dwErr != NO_ERROR) 
    { 
        return dwErr;
    }

    do
    {

        //
        // We only let one person at a time backup.  The disposition lets
        // us enforce this.
        //

        if (dwDisposition == REG_OPENED_EXISTING_KEY) {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        //
        // Save the interfaces key into the given file.
        //

        DeleteFile(pwsFileName);
        dwErr =
            RegSaveKey(
                pserver->hkeyInterfaces, pwsFileName, lpSecurityAttributes
                );
        if (dwErr != NO_ERROR) { break; }

        //
        // Restore the interfaces key into the temporary location
        //

        if ((dwErr = RegRestoreKey (hkTemp, pwsFileName, 0)) != NO_ERROR) {
            break;
        }

        DeleteFile(pwsFileName);

        //
        // Update the lan interface names
        //

        dwErr = EnumLanInterfaces(pserver, hkTemp, MapInterfaceNamesCb, TRUE);
        if (dwErr != NO_ERROR) { break; }

        //
        // Save the updated info into the given file
        //

        dwErr = RegSaveKey(hkTemp, pwsFileName, lpSecurityAttributes);
        if (dwErr != NO_ERROR) { break; }
        
    } while (FALSE);

    // Cleanup
    {

        //
        // Delete, close, and remove the temporary key
        //

        if (hkTemp) {
            DeleteRegistryTree(hkTemp);
            RegCloseKey(hkTemp);
            RegDeleteKey(pserver->hkeyParameters, pszTemp);
        }

        //
        // Disable restore privelege
        //

        EnableBackupPrivilege(FALSE, SE_RESTORE_NAME);
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    UpdateTimeStamp
//
// Creates (or updates) a value named 'Stamp' under the given key,
// and saves the last-write-time for the key in 'pfiletime'.
//----------------------------------------------------------------------------

DWORD
UpdateTimeStamp(
    IN      HKEY            hkey,
    OUT     FILETIME*       pfiletime
    )
{

    DWORD dwErr, dwValue = 0;


    //
    // Set the 'Stamp' value under the 'hkey'
    //

    dwErr = RegSetValueEx(
                hkey, c_szStamp, 0, REG_DWORD, (BYTE*)&dwValue, sizeof(dwValue)
                );

    if (dwErr != NO_ERROR) { return dwErr; }


    //
    // Read the new last-write-time
    //

    dwErr = RegQueryInfoKey(
                hkey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                NULL, pfiletime
                );

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\sdolib.h ===
/*
    File    sdolib.h

    Provides a simple library for dealing with SDO's to 
    set ras user related settings.

    Paul Mayfield, 5/7/98
*/

#ifndef __mprapi_sdolib_h
#define __mprapi_sdolib_h

//
// Initialize and cleanup the sdo library
//
DWORD SdoInit (
        OUT PHANDLE phSdo);

//
// Frees resources held by the SDO library
DWORD SdoCleanup (
        IN HANDLE hSdo);

//
// Connects to an SDO server
//
DWORD SdoConnect (
        IN  HANDLE hSdo,
        IN  PWCHAR pszServer,
        IN  BOOL bLocal,
        OUT PHANDLE phServer);

// 
// Disconnects from an SDO server
// 
DWORD SdoDisconnect (
        IN HANDLE hSdo,
        IN HANDLE hServer);

//        
// Opens an Sdo user for manipulation
//
DWORD SdoOpenUser(
        IN  HANDLE hSdo,
        IN  HANDLE hServer,
        IN  PWCHAR pszUser,
        OUT PHANDLE phUser);

//        
// Closes an Sdo user
//
DWORD SdoCloseUser(
        IN  HANDLE hSdo,
        IN  HANDLE hUser);

// 
// Commits changes made to user
//
DWORD SdoCommitUser(
        IN HANDLE hSdo,
        IN HANDLE hUser,
        IN BOOL bCommit);
        
// 
// SDO equivalent of MprAdminUserGetInfo 
//
DWORD SdoUserGetInfo (
        IN  HANDLE hSdo,
        IN  HANDLE hUser,
        IN  DWORD dwLevel,
        OUT LPBYTE pRasUser);

//
// SDO equivalent of MprAdminUserSetInfo
//        
DWORD SdoUserSetInfo (
        IN  HANDLE hSdo,
        IN  HANDLE hUser,
        IN  DWORD dwLevel,
        IN  LPBYTE pRasUser);

//
// Opens the default profile
//
DWORD SdoOpenDefaultProfile(
        IN  HANDLE hSdo,
        IN  HANDLE hServer,
        OUT PHANDLE phProfile);

//
// Closes a profile
//
DWORD SdoCloseProfile(
        IN HANDLE hSdo,
        IN HANDLE hProfile);
        
//
// Sets data in the profile.
//
DWORD SdoSetProfileData(
        IN HANDLE hSdo,
        IN HANDLE hProfile, 
        IN DWORD dwFlags);

// 
// Read information from the given profile
//
DWORD SdoGetProfileData(
        IN  HANDLE hSdo,
        IN  HANDLE hProfile,
        OUT LPDWORD lpdwFlags);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\dim\admindll\sdolib.c ===
/*
    File:   sdo.c

    Function to interact with the SDO's

    Paul Mayfield, 5/7/98
*/

#include <windows.h>
#include <mprapi.h>
#include <mprapip.h>
#include <stdio.h>
#include <ole2.h>
#include "sdoias.h"
#include "sdolib.h"
#include "sdowrap.h"
#include "dialinusr.h"

const DWORD dwFramed = RAS_RST_FRAMED;
const DWORD dwFramedCallback = RAS_RST_FRAMEDCALLBACK;

#define SDO_ERROR(e)                                                     \
    ((HRESULT_FACILITY((e)) == FACILITY_WIN32) ? HRESULT_CODE((e)) : (e));
    
#define SDO_PROPERTY_IS_EMPTY(_pVar) (V_VT((_pVar)) == VT_EMPTY)

// Definitions
#define SDO_MAX_AUTHS                       7

DWORD
SdoSetProfileToForceEncryption(
    IN HANDLE hSdo, 
    IN HANDLE hProfile,
    IN BOOL bStrong);
    
//
// Sends debug trace and returns the given error
//
DWORD SdoTraceEx (DWORD dwErr, LPSTR pszTrace, ...) {
#if DBG
    va_list arglist;
    char szBuffer[1024], szTemp[1024];

    va_start(arglist, pszTrace);
    vsprintf(szTemp, pszTrace, arglist);
    va_end(arglist);

    sprintf(szBuffer, "Sdo: %s", szTemp);

    OutputDebugStringA(szBuffer);
#endif

    return dwErr;
}

//
// Allocation routine for sdo functions
//
PVOID SdoAlloc (
        IN  DWORD dwSize,
        IN  BOOL bZero)
{
    return LocalAlloc ((bZero) ? LPTR : LMEM_FIXED, dwSize);
}

//
// Free routine for sdo functions
//
VOID SdoFree (
        IN  PVOID pvData) 
{
    LocalFree (pvData);
}    

//
// Releases any resources aquired by loading the SDO library.
//
DWORD SdoUnloadLibrary (
        IN  HANDLE hData) 
{
    return NO_ERROR;
}

//
// Loads the library that utilizes SDO's
//
DWORD SdoLoadLibrary (
        IN  HANDLE hData) 
{
    return NO_ERROR;
}

typedef struct _tagSDOINFO
{
    BOOL bComCleanup;    
} SDOINFO;

//
// Initialize and cleanup the sdo library
//
DWORD SdoInit (
        OUT PHANDLE phSdo)
{
    DWORD dwErr = NO_ERROR;
    HRESULT hr = S_OK;
    SDOINFO* pInfo = NULL;
    BOOL bCom = FALSE;

    SdoTraceEx (0, "SdoInit: entered.\n");

    //For whistler bug 397815
    //We have to modify the CoIntialize() and CoUnitialize() 
    //to avoid AV in rasdlg!netDbClose()
    //
    
    // Validate parameters
    //
    if ( NULL == phSdo )
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Initialize
    //
    *phSdo = NULL;            

    do
    {
        // Load in the sdo library
        dwErr = SdoLoadLibrary(NULL);
        if (NO_ERROR != dwErr )
        {
            SdoTraceEx(dwErr, "SdoInit: unabled to load library\n");
            break;
        }

        // Initialize Com
        //
        hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);
        if ( RPC_E_CHANGED_MODE == hr )
        {
            hr = CoInitializeEx (NULL, COINIT_APARTMENTTHREADED);
        }
        
        if (FAILED(hr))
        {
            dwErr = HRESULT_CODE(hr);
            break;
        }
        bCom = TRUE;

        pInfo = SdoAlloc(sizeof(SDOINFO), TRUE);
        if (pInfo == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        pInfo->bComCleanup = bCom;
        *phSdo = (HANDLE)pInfo;
        
    } while (FALSE);

    // Cleanup
    //
    {
        if ( NO_ERROR!= dwErr )
        {
            if (pInfo)
            {
                SdoFree(pInfo);
            }
            if (bCom)
            {
                CoUninitialize();
            }
        }
    }
    
    return dwErr;
}

//
// Frees resources held by the SDO library
DWORD SdoCleanup (
        IN HANDLE hSdo)
{
    DWORD dwErr;
    SDOINFO* pInfo = (SDOINFO*)hSdo;
    
    SdoTraceEx (0, "SdoCleanup: entered.\n");

    if ( NULL == pInfo )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    // Unload the sdo library
    if ((dwErr = SdoUnloadLibrary(NULL)) != NO_ERROR)
        SdoTraceEx (dwErr, "SdoCleanup: %x on unload.\n", dwErr);

    // Unititialize com
    if (pInfo->bComCleanup)
    {
        CoUninitialize();
    }        
    SdoFree(pInfo);

    return NO_ERROR;
}

//
// Connects to an SDO server
//
DWORD SdoConnect (
        IN  HANDLE hSdo,
        IN  PWCHAR pszServer,
        IN  BOOL bLocal,
        OUT PHANDLE phServer)
{
    BSTR bstrComputer = NULL;
    HRESULT hr;
    
    SdoTraceEx (0, "SdoConnect: entered %S, %d\n", 
                pszServer, bLocal);

    // Prepare a correctly formatted version of the server
    // name -- NULL for local, no "\\" for remote.
    if (pszServer) {
        WCHAR pszLocalComputer[1024];
        DWORD dwSize = sizeof(pszLocalComputer) / sizeof(WCHAR);

        if (*pszServer == 0)
            bstrComputer = NULL;
        else if (*pszServer == '\\')
        {
            bstrComputer = SysAllocString(pszServer + 2);
            if (bstrComputer == NULL)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        {
            bstrComputer = SysAllocString(pszServer);
            if (bstrComputer == NULL)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        if ((bstrComputer) && 
            (GetComputerName(pszLocalComputer, &dwSize))) 
        {
            if (lstrcmpi (pszLocalComputer, bstrComputer) == 0) {
                SysFreeString(bstrComputer);
                bstrComputer = NULL;
            }
        }
    }            
    else
        bstrComputer = NULL;

    hr = SdoWrapOpenServer(
                bstrComputer,
                bLocal,
                phServer);
    if (FAILED (hr))
        SdoTraceEx (0, "SdoConnect: %x on OpenServer(%S) \n", 
                    hr, bstrComputer);

    if (bstrComputer)                        
        SysFreeString(bstrComputer);

    if (FAILED (hr))
        return hr;
    
    return NO_ERROR;
}

// 
// Disconnects from an SDO server
// 
DWORD SdoDisconnect (
        IN HANDLE hSdo,
        IN HANDLE hServer)
{
    SdoTraceEx (0, "SdoDisconnect: entered\n");

    return SdoWrapCloseServer(hServer);
}

//        
// Opens an Sdo user for manipulation
//
DWORD SdoOpenUser(
        IN  HANDLE hSdo,
        IN  HANDLE hServer,
        IN  PWCHAR pszUser,
        OUT PHANDLE phUser)
{
    DWORD dwErr;
    BSTR bstrUser;

    // Initailize the strings for COM                                
    bstrUser = SysAllocString(pszUser);
    if (bstrUser == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Open the user's Sdo object
    dwErr = SdoWrapOpenUser(
                hServer,
                bstrUser, 
                phUser);
                
    if (dwErr != NO_ERROR)
        SdoTraceEx (0, "SdoOpenUser: %x on OpenUser(%S)\n", dwErr, bstrUser);
                    
    // Cleanup
    SysFreeString(bstrUser);
                
    if (dwErr != NO_ERROR)
        return dwErr;
        
    return NO_ERROR;
}

//        
// Closes an Sdo user
//
DWORD SdoCloseUser(
        IN  HANDLE hSdo,
        IN  HANDLE hUser)
{
    if (hUser != NULL)
        return SdoWrapClose(hUser);
        
    return ERROR_INVALID_PARAMETER;        
}    

//
// Commits an Sdo user
//
DWORD SdoCommitUser(
        IN HANDLE hSdo,
        IN HANDLE hUser,
        IN BOOL bCommit)
{
    if (hUser != NULL)
    {
        return SdoWrapCommit(hUser, bCommit);
    }
        
    return ERROR_INVALID_PARAMETER;        
}

// 
// SDO equivalent of MprAdminUserGetInfo 
//
DWORD SdoUserGetInfo (
        IN  HANDLE hSdo,
        IN  HANDLE hUser,
        IN  DWORD dwLevel,
        OUT LPBYTE pRasUser)
{
    RAS_USER_0* pUserInfo = (RAS_USER_0*)pRasUser;
    VARIANT var, vCallback, vSavedCb;
    DWORD dwErr, dwCallback;
    HRESULT hr;

    // Validate -- we only handle level 0
    if ((!hUser) || (dwLevel != 0 && dwLevel != 1) || (!pUserInfo))
        return ERROR_INVALID_PARAMETER;

    // Initialize
    pUserInfo->bfPrivilege = 0;
    dwCallback = RAS_RST_FRAMED;
    
    // Read in the service type
    VariantInit (&var);
    hr = SdoWrapGetAttr(
                hUser, 
                PROPERTY_USER_SERVICE_TYPE, 
                &var);
    if (FAILED (hr))
    {
        return SdoTraceEx (hr, "SdoUserGetInfo: %x on GetAttr ST\n", hr);
    }
    // If the service type doesn't exist, return 
    // set defaults.
    if (SDO_PROPERTY_IS_EMPTY(&var))
    {
        pUserInfo->bfPrivilege |= RASPRIV_NoCallback;
        wcscpy (pUserInfo->wszPhoneNumber, L"");
    }
    else
    {
        // Assign the callback flags from the service type
        dwCallback = V_I4(&var);
    }            
    VariantClear (&var);

    // Readin the dialin flag
    hr = SdoWrapGetAttr(
            hUser, 
            PROPERTY_USER_ALLOW_DIALIN, 
            &var);
    if (FAILED (hr))
    {
        return SdoTraceEx (hr, "SdoUserGetInfo: %x on GetAttr DI\n", hr);
    }
    if (dwLevel == 1)
    {
        if (SDO_PROPERTY_IS_EMPTY(&var))
        {
            pUserInfo->bfPrivilege |= RASPRIV_DialinPolicy;
        }
        else if ((V_VT(&var) == VT_BOOL) && (V_BOOL(&var) == VARIANT_TRUE))
        {
            pUserInfo->bfPrivilege |= RASPRIV_DialinPrivilege;
        }
    }
    else if ((V_VT(&var) == VT_BOOL) && (V_BOOL(&var) == VARIANT_TRUE))
    {
        pUserInfo->bfPrivilege |= RASPRIV_DialinPrivilege;
    }

    // Read in the callback number and saved callback number
    VariantInit(&vCallback);
    VariantInit(&vSavedCb);
    hr = SdoWrapGetAttr(
            hUser, PROPERTY_USER_RADIUS_CALLBACK_NUMBER, &vCallback);
    if (FAILED (hr))
    {
        return SdoTraceEx (hr, "SdoUserGetInfo: %x on GetAttr CB\n", hr);
    }
    hr = SdoWrapGetAttr(
            hUser, PROPERTY_USER_SAVED_RADIUS_CALLBACK_NUMBER, &vSavedCb);
    if (FAILED (hr))
    {
        return SdoTraceEx (hr, "SdoUserGetInfo: %x on GetAttr SCB\n", hr);
    }

    // If there was a callback number, then this is definately, 
    // admin assigned callback
    if ( (V_VT(&vCallback) == VT_BSTR)      &&
         (V_BSTR(&vCallback)) )
    {
        pUserInfo->bfPrivilege |= RASPRIV_AdminSetCallback;
    }

    // Otherwise, the service type will tell us whether we have 
    // caller settable callback or none.
    else 
    {
        if (dwCallback == RAS_RST_FRAMEDCALLBACK)
            pUserInfo->bfPrivilege |= RASPRIV_CallerSetCallback;
        else
            pUserInfo->bfPrivilege |= RASPRIV_NoCallback;
    }

    // Now, assign the callback number accordingly
    if (pUserInfo->bfPrivilege & RASPRIV_AdminSetCallback)
    {
        wcscpy (pUserInfo->wszPhoneNumber, V_BSTR(&vCallback));
    }
    else if ((V_VT(&vSavedCb) == VT_BSTR) && (V_BSTR(&vSavedCb)))
    {
        wcscpy (pUserInfo->wszPhoneNumber, V_BSTR(&vSavedCb));
    }
    else
    {
        wcscpy (pUserInfo->wszPhoneNumber, L"");
    }

    VariantClear (&vSavedCb);
    VariantClear (&vCallback);

    return NO_ERROR;
}

//
// SDO equivalent of MprAdminUserSetInfo
//        
DWORD SdoUserSetInfo (
        IN  HANDLE hSdo,
        IN  HANDLE hUser,
        IN  DWORD dwLevel,
        IN  LPBYTE pRasUser)
{
    RAS_USER_0* pUserInfo = (RAS_USER_0*)pRasUser;
    DWORD dwErr, dwCallback, dwCallbackId, dwSize, dwCbType;
    VARIANT var;
    HRESULT hr;

    // Validate -- we only handle level 0
    if ((!hUser) || (dwLevel != 0 && dwLevel != 1) || (!pUserInfo))
        return ERROR_INVALID_PARAMETER;

    // Initialize
    VariantInit (&var);
    dwCallback = 0;

    // Assign dialin flags
    if (!!(pUserInfo->bfPrivilege & RASPRIV_DialinPrivilege))
    {
        V_VT(&var) = VT_BOOL;
        V_BOOL(&var) = VARIANT_TRUE;
    }
    else
    {
        V_VT(&var) = VT_BOOL;
        V_BOOL(&var) = VARIANT_FALSE;
    }
    if (dwLevel == 1)
    {
        if (!!(pUserInfo->bfPrivilege & RASPRIV_DialinPolicy))
        {
            V_VT(&var) = VT_EMPTY;    
        }
    }        
    
    hr = SdoWrapPutAttr(
            hUser, 
            PROPERTY_USER_ALLOW_DIALIN, 
            &var);
    if (FAILED (hr))
    {
        SdoTraceEx (hr, "SdoUserSetInfo: %x on PutAttr DI\n", hr);
    }
    VariantClear(&var);        

    // Assign the callback mode and read in the 
    // callback number
    dwCbType = VT_EMPTY;
    if (pUserInfo->bfPrivilege & RASPRIV_AdminSetCallback) 
    {
        dwCbType = VT_I4;
        dwCallback = RAS_RST_FRAMEDCALLBACK;
        dwCallbackId = PROPERTY_USER_RADIUS_CALLBACK_NUMBER;
    }
    else if (pUserInfo->bfPrivilege & RASPRIV_CallerSetCallback) 
    {
        dwCbType = VT_I4;
        dwCallback = RAS_RST_FRAMEDCALLBACK;
        dwCallbackId = PROPERTY_USER_SAVED_RADIUS_CALLBACK_NUMBER;
    }
    else 
    {
        dwCbType = VT_EMPTY;
        dwCallback = RAS_RST_FRAMED;
        dwCallbackId = PROPERTY_USER_SAVED_RADIUS_CALLBACK_NUMBER;
    }

    // Write out the callback number
    if (wcslen (pUserInfo->wszPhoneNumber) > 0) 
    {
        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = SysAllocString (pUserInfo->wszPhoneNumber);
        if (V_BSTR(&var) == NULL)
        {
            return E_OUTOFMEMORY;
        }

        hr = SdoWrapPutAttr(hUser, dwCallbackId, &var);
        SysFreeString (V_BSTR(&var));
        if (FAILED (hr))
            return SdoTraceEx (hr, "SdoUserSetInfo: %x on PutAttr CB\n", hr);
    }            

    // Write out the callback policy
    VariantInit(&var);
    V_VT(&var) = (USHORT)dwCbType;
    if (V_VT(&var) != VT_EMPTY)
    {
        V_I4(&var) = dwCallback;
    }
    hr = SdoWrapPutAttr(hUser, PROPERTY_USER_SERVICE_TYPE, &var);
    if (FAILED (hr))
    {
        return SdoTraceEx (hr, "SdoUserSetInfo: %x on PutAttr ST\n", hr);
    }

    // Remove the appropriate callback attribute
    dwCallbackId = (dwCallbackId == PROPERTY_USER_RADIUS_CALLBACK_NUMBER) ?
                    PROPERTY_USER_SAVED_RADIUS_CALLBACK_NUMBER        :
                    PROPERTY_USER_RADIUS_CALLBACK_NUMBER;
    hr = SdoWrapRemoveAttr(hUser, dwCallbackId);
    if (FAILED (hr))
    {
        return SdoTraceEx (hr, "SdoUserSetInfo: %x on RemoveAttr CB\n", hr);
    }

    return NO_ERROR;
}

//
// Opens the default profile
//
DWORD SdoOpenDefaultProfile(
        IN  HANDLE hSdo,
        IN  HANDLE hServer,
        OUT PHANDLE phProfile)
{
    SdoTraceEx (0, "SdoOpenDefaultProfile: entered\n");

    if (phProfile == NULL)
        return ERROR_INVALID_PARAMETER;
    
    return SdoWrapOpenDefaultProfile(hServer, phProfile);
}

//
// Closes a profile
//
DWORD SdoCloseProfile(
        IN HANDLE hSdo,
        IN HANDLE hProfile)
{
    SdoTraceEx (0, "SdoCloseProfile: entered\n");

    if (hProfile == NULL)
        return ERROR_INVALID_PARAMETER;
    
    return SdoWrapCloseProfile(hProfile);
}

// 
// Converts a 1 demensional safe array of variant dwords
// into an a array of dwords and a count
//
HRESULT SdoConvertSafeArrayDw (
        IN  SAFEARRAY * pArray, 
        OUT LPDWORD lpdwAuths, 
        OUT LPDWORD lpdwAuthCount)
{
    LONG lDim, lLBound, lRBound, lCount, i;
    HRESULT hr;
    VARIANT var;
    
    // Validate
    if (!pArray || !lpdwAuths || !lpdwAuthCount)
        return ERROR_INVALID_PARAMETER;

    // Verify dimensions
    lDim = (DWORD)SafeArrayGetDim(pArray);
    if (lDim != 1)
        return ERROR_INVALID_PARAMETER;

    // Get the bounds
    hr = SafeArrayGetLBound(pArray, 1, &lLBound);
    if (FAILED (hr))
        return hr;
    hr = SafeArrayGetUBound(pArray, 1, &lRBound);
    if (FAILED (hr))
        return hr;
    lCount = (lRBound - lLBound) + 1;
    *lpdwAuthCount = (DWORD)lCount;
    if (lCount == 0)
        return NO_ERROR;

    // Loop through
    for (i = 0; i < lCount; i++) {
        hr = SafeArrayGetElement(pArray, &i, (VOID*)&var);
        if (FAILED (hr))
           continue;
        lpdwAuths[i] = V_I4(&var);
    }

    return S_OK;
}

// 
// Converts a 1 demensional array of dwords to a
// safe array of variant dwords.
//
HRESULT SdoCovertDwToSafeArray(
        IN  SAFEARRAY ** ppArray, 
        OUT LPDWORD lpdwAuths, 
        OUT DWORD dwAuthCount)
{
    HRESULT hr;
    SAFEARRAY * pArray;
    SAFEARRAYBOUND rgsabound[1];
    LONG i;
    VARIANT var;
    
    // Validate
    if (!lpdwAuths || !ppArray)
        return E_INVALIDARG;

    // Create the new array
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = dwAuthCount;
    pArray = SafeArrayCreate(VT_VARIANT, 1, rgsabound);    

    // Fill in the array values
    for (i = 0; i < (LONG)dwAuthCount; i++) {
        hr = SafeArrayGetElement(pArray, &i, (VOID*)&var);
        if (FAILED (hr))
           continue;
        V_VT(&var) = VT_I4;
        V_I4(&var) = lpdwAuths[i];
        hr = SafeArrayPutElement(pArray, &i, (VOID*)&var);
        if (FAILED (hr))
            return hr;
    }

    *ppArray = pArray;

    return S_OK;
}

//
// Sets data in the profile.
//
DWORD SdoSetProfileData(
        IN HANDLE hSdo,
        IN HANDLE hProfile, 
        IN DWORD dwFlags)
{
    DWORD dwAuthCount, dwAuths[SDO_MAX_AUTHS];
    VARIANT varEp, varEt, varAt;
    HRESULT hr;
    
    SdoTraceEx (0, "SdoSetProfileData: entered\n");

    if ((dwFlags & MPR_USER_PROF_FLAG_FORCE_STRONG_ENCRYPTION) ||
        (dwFlags & MPR_USER_PROF_FLAG_FORCE_ENCRYPTION))
    {
        return SdoSetProfileToForceEncryption(
                    hSdo, 
                    hProfile,
                    !!(dwFlags & MPR_USER_PROF_FLAG_FORCE_STRONG_ENCRYPTION));
    }

    // Initialize
    VariantInit (&varEp);
    VariantInit (&varEt);
    VariantInit (&varAt);

    do 
    {
        // Set the encryption policy
        V_VT(&varEp) = VT_I4;
        if (dwFlags & MPR_USER_PROF_FLAG_SECURE)
        {
            V_I4(&varEp) = RAS_EP_REQUIRE;
        }
        else
        {
            V_I4(&varEp) = RAS_EP_ALLOW;
        }

        // Set the encryption type
        V_VT(&varEt) = VT_I4;
        if (dwFlags & MPR_USER_PROF_FLAG_SECURE)
        {
            V_I4(&varEt) = (RAS_ET_BASIC | RAS_ET_STRONGEST | RAS_ET_STRONG);
        }
        else 
        {
            V_I4(&varEt) = (RAS_ET_BASIC | RAS_ET_STRONGEST | RAS_ET_STRONG);
        }

        // Set the authentication types
        if (dwFlags & MPR_USER_PROF_FLAG_SECURE) 
        {
            dwAuthCount = 4;
            dwAuths[0] = IAS_AUTH_MSCHAP;
            dwAuths[1] = IAS_AUTH_MSCHAP2;
            dwAuths[2] = IAS_AUTH_MSCHAP_CPW;
            dwAuths[3] = IAS_AUTH_MSCHAP2_CPW;
        }
        else 
        { 
            dwAuthCount = 5;
            dwAuths[0] = IAS_AUTH_MSCHAP;
            dwAuths[1] = IAS_AUTH_MSCHAP2;
            dwAuths[2] = IAS_AUTH_PAP;
            dwAuths[3] = IAS_AUTH_MSCHAP_CPW;
            dwAuths[4] = IAS_AUTH_MSCHAP2_CPW;
        }
        V_VT(&varAt) = VT_ARRAY | VT_VARIANT;
        hr = SdoCovertDwToSafeArray(
                &(V_ARRAY(&varAt)), 
                dwAuths, 
                dwAuthCount);
        if (FAILED (hr))
        {
            break;
        }

        // Set the values in the profile
        hr = SdoWrapSetProfileValues(
                hProfile, 
                &varEp,
                &varEt,
                &varAt);
        if (FAILED (hr))
        {
            break;
        }
        
    } while (FALSE);

    // Cleanup
    {
        VariantClear(&varEp);
        VariantClear(&varEt);
        VariantClear(&varAt);
    }

    return SDO_ERROR(hr);
}

//
// Sets a profile to force strong encryption
//
DWORD
SdoSetProfileToForceEncryption(
    IN HANDLE hSdo, 
    IN HANDLE hProfile,
    IN BOOL bStrong)
{
    VARIANT varEp, varEt;
    HRESULT hr = S_OK;
    
    SdoTraceEx (0, "SdoSetProfileToForceEncryption: entered (%d)\n", !!bStrong);

    // Initialize
    VariantInit (&varEp);
    VariantInit (&varEt);

    do 
    {
        // Set the encryption policy
        V_VT(&varEp) = VT_I4;
        V_I4(&varEp) = RAS_EP_REQUIRE;

        // Set the encryption type
        V_VT(&varEt) = VT_I4;
        if (bStrong)
        {
            V_I4(&varEt) = RAS_ET_STRONGEST;
        }
        else
        {
            V_I4(&varEt) = RAS_ET_BASIC | RAS_ET_STRONG | RAS_ET_STRONGEST;
        }

        // Write out the values
        // Set the values in the profile
        hr = SdoWrapSetProfileValues(
                hProfile, 
                &varEp,
                &varEt,
                NULL);
        if (FAILED (hr))
        {
            break;
        }
        
    } while (FALSE);

    // Cleanup
    {
        VariantClear(&varEp);
        VariantClear(&varEt);
    }

    return SDO_ERROR(hr);
}

// 
// Read information from the given profile
//
DWORD SdoGetProfileData(
        IN HANDLE hSdo,
        IN HANDLE hProfile,
        OUT LPDWORD lpdwFlags)
{
    VARIANT varEp, varEt, varAt;
    HRESULT hr = S_OK;
    DWORD dwEncPolicy, 
          dwAuthCount, 
          dwAuths[SDO_MAX_AUTHS], 
          i, 
          dwEncType;
    
    SdoTraceEx (0, "SdoGetProfileData: entered\n");

    // Initialize
    ZeroMemory(dwAuths, sizeof(dwAuths));
    VariantInit(&varEp);
    VariantInit(&varEt);
    VariantInit(&varAt);

    do 
    {
        // Read in the encryption values
        hr = SdoWrapGetProfileValues(hProfile, &varEp, &varEt, &varAt);
        if (FAILED (hr))
        {
            break;
        }

        // Parse the encryption policy
        if (SDO_PROPERTY_IS_EMPTY(&varEp))
        {
            dwEncPolicy = RAS_DEF_ENCRYPTIONPOLICY;
        }
        else
        {
            dwEncPolicy = V_I4(&varEp);
        }

        // Parse the encryption type
        if (SDO_PROPERTY_IS_EMPTY(&varEt))
        {
            dwEncType = RAS_DEF_ENCRYPTIONTYPE;
        }
        else
        {
            dwEncType = V_I4(&varEt);
        }

        // Parse in the allowed authentication types
        if (SDO_PROPERTY_IS_EMPTY(&varAt)) 
        {
            dwAuthCount = 1;
            dwAuths[0] = RAS_DEF_AUTHENTICATIONTYPE;
        }
        else 
        {
            hr = SdoConvertSafeArrayDw (
                    V_ARRAY(&varAt), 
                    dwAuths, 
                    &dwAuthCount);
            if (FAILED (hr))
            {
                break;
            }
        }

        // If the encryption type has been mucked with
        // then we can't tell if we're secure.
        if (dwEncType != (RAS_ET_STRONG | 
                          RAS_ET_STRONGEST   | 
                          RAS_ET_BASIC))
        {
            *lpdwFlags = MPR_USER_PROF_FLAG_UNDETERMINED;
        }

        else 
        {
            // If the encryption policy forces encryption
            // then we're secure if the only authentication 
            // types are MSCHAP v1 or 2.
            if (dwEncPolicy == RAS_EP_REQUIRE) 
            {
                *lpdwFlags = MPR_USER_PROF_FLAG_SECURE;
                for (i = 0; i < dwAuthCount; i++) 
                {
                    if ((dwAuths[i] != IAS_AUTH_MSCHAP) &&
                        (dwAuths[i] != IAS_AUTH_MSCHAP2) &&
                        (dwAuths[i] != IAS_AUTH_MSCHAP