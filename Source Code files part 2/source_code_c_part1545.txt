e.
 ***************************************************************************/

STATIC MMRESULT waveOpen(UINT      DeviceType,
                         DWORD     id,
                         DWORD_PTR dwUser,
                         DWORD_PTR dwParam1,
                         DWORD_PTR dwParam2)
{
    PWAVEALLOC     pClient;  // pointer to client information structure
    MMRESULT mRet;
    BOOL Result;
    DWORD BytesReturned;
    LPWAVEFORMATEX Format;

    Format = (LPWAVEFORMATEX)((LPWAVEOPENDESC)dwParam1)->lpFormat;

    // dwParam1 contains a pointer to a WAVEOPENDESC
    // dwParam2 contains wave driver specific flags in the LOWORD
    // and generic driver flags in the HIWORD

    //
    // If it's only a query to check if the device supports our format
    // we :
    //     Open the device
    //     Test the format
    //     Close the device
    //

    if (dwParam2 & WAVE_FORMAT_QUERY) {
        HANDLE hDev;

        //
        // See if we can open our device
        // Only open for read (this should always work for our devices
        // unless there are system problems).
        //

        mRet = sndOpenDev(DeviceType,
                           id,
                           &hDev,
                           GENERIC_READ);

        if (mRet != MMSYSERR_NOERROR) {
            return mRet;
        }

        //
        // Check the format
        //
        Result = DeviceIoControl(
                        hDev,
                        IOCTL_WAVE_QUERY_FORMAT,
                        (PVOID)Format,
                        Format->wFormatTag == WAVE_FORMAT_PCM ?
                            sizeof(PCMWAVEFORMAT) :
                            sizeof(WAVEFORMATEX) + Format->cbSize,
                                                     // Input buffer size
                        NULL,                        // Output buffer
                        0,                           // Output buffer size
                        &BytesReturned,
                        NULL);


        //
        // Only a query so close the device
        //

        CloseHandle(hDev);

        return Result ? MMSYSERR_NOERROR :
               GetLastError() == ERROR_NOT_SUPPORTED ? WAVERR_BADFORMAT :
                                                sndTranslateStatus();
    }

    //
    // See if we've got this device already in our list (in
    // which case we have a thread and events for it already made)
    //

    EnterCriticalSection(&mmDrvCritSec);

    for (pClient = WaveHandleList;
         pClient != NULL;
         pClient = pClient->Next) {
        if (pClient->DeviceNumber == id &&
            pClient->DeviceType == DeviceType) {
            //
            // We already have a thread and resources for this device
            //

            if (pClient->hDev != INVALID_HANDLE_VALUE) {
                //
                // Someone else is using it!
                //

                LeaveCriticalSection(&mmDrvCritSec);
                return MMSYSERR_ALLOCATED;
            }
            break;
        }
    }

    //
    // allocate my per-client structure and zero it (LPTR).
    //

    if (pClient == NULL) {
        pClient = (PWAVEALLOC)HeapAlloc(hHeap, 0, sizeof(WAVEALLOC));
        if (pClient == NULL) {
            LeaveCriticalSection(&mmDrvCritSec);
            return MMSYSERR_NOMEM;
        }

        dprintf2(("Creating new device resource for device id %d, type %s",
                 id,
                 DeviceType == WaveInDevice ? "Wave Input" : "Wave Output"));

        memset((PVOID)pClient, 0, sizeof(WAVEALLOC));

        //
        // Add it to the list
        //
        pClient->DeviceNumber = id;
        pClient->DeviceType = DeviceType;
        pClient->Next = WaveHandleList;
        WaveHandleList = pClient;
    }


    //
    // and fill it with info
    //

    pClient->dwCallback  = ((LPWAVEOPENDESC)dwParam1)->dwCallback;
    pClient->dwInstance  = ((LPWAVEOPENDESC)dwParam1)->dwInstance;
    pClient->hWave       = ((LPWAVEOPENDESC)dwParam1)->hWave;
    pClient->dwFlags     = (DWORD)dwParam2;

    pClient->hDev = INVALID_HANDLE_VALUE;

    pClient->DeviceQueue = NULL;
    pClient->NextBuffer  = NULL;
    pClient->BufferPosition = 0;
    pClient->BytesOutstanding = 0;
    pClient->LoopHead    = NULL;
    pClient->LoopCount   = 0;

    //
    // See if we can open our device
    // We could get ERROR_BUSY if someone else is has the device open
    // for writing.
    //

    mRet = sndOpenDev(DeviceType,
                       id,
                       &pClient->hDev,
                       (GENERIC_READ | GENERIC_WRITE));

    if (mRet != MMSYSERR_NOERROR) {

        WinAssert(pClient->hDev == INVALID_HANDLE_VALUE);
        LeaveCriticalSection(&mmDrvCritSec);
        return mRet;
    }


    //
    // make sure we can handle the format and set it.
    //

    Result = DeviceIoControl(
                 pClient->hDev,
                 IOCTL_WAVE_SET_FORMAT,
                 (PVOID)Format,
                 Format->wFormatTag == WAVE_FORMAT_PCM ?
                     sizeof(PCMWAVEFORMAT) :
                     sizeof(WAVEFORMATEX) + Format->cbSize,
                 NULL,                        // Output buffer
                 0,                           // Output buffer size
                 &BytesReturned,
                 NULL);


    if (!Result) {
        CloseHandle(pClient->hDev);
        pClient->hDev = INVALID_HANDLE_VALUE;
        LeaveCriticalSection(&mmDrvCritSec);
        return GetLastError() == ERROR_NOT_SUPPORTED ? WAVERR_BADFORMAT :
                                                sndTranslateStatus();
    }

    LeaveCriticalSection(&mmDrvCritSec);

    //
    // Create our event for synchronization with the kernel driver
    //

    if (!pClient->Event) {
        pClient->Event = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (pClient->Event == NULL) {
            waveCleanUp(pClient);
            return MMSYSERR_NOMEM;
        }
        //
        // Create our event for our thread to wait on
        //

        pClient->AuxEvent1 = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!pClient->AuxEvent1) {
            waveCleanUp(pClient);
            return MMSYSERR_NOMEM;
        }
        //
        // Create our event for waiting for the auxiliary thread
        //

        pClient->AuxEvent2 = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!pClient->AuxEvent2) {
            waveCleanUp(pClient);
            return MMSYSERR_NOMEM;
        }

        //
        // Create our auxiliary thread for sending buffers to the driver
        // and collecting Apcs
        //

        mRet = mmTaskCreate((LPTASKCALLBACK)waveThread,
                            &pClient->ThreadHandle,
                            (DWORD_PTR)pClient);

        if (mRet != MMSYSERR_NOERROR) {
            waveCleanUp(pClient);
            return MMSYSERR_NOMEM;
        }

        //
        // Make sure the thread has really started
        //

        WaitForSingleObject(pClient->AuxEvent2, INFINITE);
    }

    //
    // give the client my driver dw
    //
    {
        PWAVEALLOC *pUserHandle;
        pUserHandle = (PWAVEALLOC *)dwUser;
        *pUserHandle = pClient;
    }

    //
    // sent client his OPEN callback message
    //
    waveCallback(pClient, DeviceType == WaveOutDevice ? WOM_OPEN : WIM_OPEN, 0L);

    return MMSYSERR_NOERROR;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveCleanUp | Free resources for a wave device
 *
 * @parm PWAVEALLOC | pClient | Pointer to a WAVEALLOC structure describing
 *      resources to be freed.
 *
 * @rdesc There is no return value.
 *
 * @comm If the pointer to the resource is NULL then the resource has not
 *     been allocated.
 ***************************************************************************/
STATIC void waveCleanUp(PWAVEALLOC pClient)
{
    EnterCriticalSection(&mmDrvCritSec);
    if (pClient->hDev != INVALID_HANDLE_VALUE) {
        CloseHandle(pClient->hDev);
        pClient->hDev = INVALID_HANDLE_VALUE;
    }
    if (pClient->AuxEvent1) {
        CloseHandle(pClient->AuxEvent1);
        pClient->AuxEvent1 = NULL;
    }
    if (pClient->AuxEvent2) {
        CloseHandle(pClient->AuxEvent2);
        pClient->AuxEvent2 = NULL;
    }
    if (pClient->Event) {
        CloseHandle(pClient->Event);
        pClient->Event = NULL;
    }
    LeaveCriticalSection(&mmDrvCritSec);
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | waveWrite | Pass a new buffer to the Auxiliary thread for
 *       a wave device.
 *
 * @parm LPWAVEHDR | pHdr | Pointer to a wave buffer
 *
 * @parm PWAVEALLOC | pClient | The data associated with the logical wave
 *     device.
 *
 * @rdesc A MMSYS... type return code for the application.
 *
 * @comm The buffer flags are set and the buffer is passed to the auxiliary
 *     device task for processing.
 ***************************************************************************/
STATIC MMRESULT waveWrite(LPWAVEHDR pHdr, PWAVEALLOC pClient)
{
    //
    // Put the request at the end of our queue.
    //
    pHdr->dwFlags |= WHDR_INQUEUE;
    pHdr->dwFlags &= ~WHDR_DONE;
    pClient->AuxParam.pHdr = pHdr;
    return waveThreadCall(WaveThreadAddBuffer, pClient);
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | waveSetState | Set a wave device to a given state
 *     This function is executed on the Auxiliary thread to synchronize
 *     correctly.
 *
 * @parm PWAVEALLOC | pClient | The data associated with the logical wave
 *     output device.
 *
 * @parm ULONG | State | The new state
 *
 * @rdesc A MMSYS... type return code for the application.
 ***************************************************************************/
STATIC MMRESULT waveSetState(PWAVEALLOC pClient, ULONG State)
{
    return sndSetHandleData(pClient->hDev,
                            sizeof(State),
                            &State,
                            IOCTL_WAVE_SET_STATE,
                            pClient->Event);
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveBlockFinished | This function sets the done bit and invokes
 *     the callback function if there is one.
 *
 * @parm LPWAVEHDR | lpHdr | Far pointer to the header.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
STATIC void waveBlockFinished(LPWAVEHDR lpHdr, DWORD MsgId)
{
    PWAVEALLOC pWav;

    D3(("blkfin: lpHdr = %x", lpHdr));
    // Clear our private flag
    lpHdr->dwFlags &= ~WHDR_COMPLETE;

    // We are giving the block back to the application.  The header is no
    // longer in our queue, so we reset the WHDR_INQUEUE bit.  Also, we
    // clear our driver specific bit and cauterize the lpNext pointer.
    lpHdr->dwFlags &= ~WHDR_INQUEUE;
    lpHdr->lpNext = NULL;

    pWav = (PWAVEALLOC)(lpHdr->reserved);

    // set the 'done' bit - note that some people poll this bit.
    lpHdr->dwFlags |= WHDR_DONE;

    // invoke the callback function
    waveCallback(pWav, MsgId, (DWORD_PTR)lpHdr);
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | waveThreadCall | Set the function for the thread to perform
 *     and 'call' the thread using the event pair mechanism.
 *
 * @parm WAVETHREADFUNCTION | Function | The function to perform
 *
 * @parm PWAVEALLOC | Our logical device data
 *
 * @rdesc An MMSYS... type return value suitable for returning to the
 *      application
 *
 * @comm The AuxParam field in the device data is the 'input' to
 *      the function processing loop in WaveThread().
 ***************************************************************************/
STATIC MMRESULT waveThreadCall(WAVETHREADFUNCTION Function, PWAVEALLOC pClient)
{
    //
    // Trap any failures
    //
    WinAssert(pClient->hDev != INVALID_HANDLE_VALUE);

    //
    // Set the function code
    //
    pClient->AuxFunction = Function;

    //
    // Kick off the thread
    //
    SetEvent(pClient->AuxEvent1);

    //
    // Wait for it to complete
    //
    WaitForSingleObject(pClient->AuxEvent2, INFINITE);

    //
    // Return the return code that our task set.
    //
    return pClient->AuxReturnCode;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | wavePartialApc | Called when a partial buffer is complete.
 *
 * @parm DWORD | BytesTransferred | Not relevant to us
 *
 * @parm LPOVERLAPPED | pOverLapped | Overlapped structure for this callback
 *
 * @rdesc None
 *
 * @comm The IO status block is freed and the BytesOutstanding count
 *       used to limit the buffers we have locked down is updated (we
 *       know here that parital buffers are all the same size).
 *       Also the byte count for a recording buffer is updated.
 ***************************************************************************/
STATIC void wavePartialOvl(DWORD dwErrorCode, DWORD BytesTransferred, LPOVERLAPPED pOverlapped)
{
    LPWAVEHDR pHdr;
    PWAVEALLOC pClient;

    pHdr = ((PWAVEOVL)pOverlapped)->WaveHdr;
    D3(("wavePartialOvl: pHdr = %x", pHdr));

    pClient = (PWAVEALLOC)pHdr->reserved;

    //
    // We can't trust the IO system to return our buffers in the right
    // order so we set a flag in the buffer but only complete buffers
    // at the FRONT of the queue which have the flag set.  In fact
    // we don't process the stuff here - leave that for when we
    // exit the wait because calling the client's callback can
    // do nasty things inside and Apc routine
    //

    WinAssert(pHdr->dwFlags & WHDR_INQUEUE);
    WinAssert(!(pHdr->dwFlags & WHDR_COMPLETE));

    //
    // Recalculate how many bytes are outstanding on the device
    //

    pClient->BytesOutstanding -= MAX_BUFFER_SIZE;

    //
    // Work out how much was recorded if we're a recording device
    //

    if (pClient->DeviceType == WaveInDevice) {
        pHdr->dwBytesRecorded += BytesTransferred;
    }

    //
    // Free our Iosb
    //

    HeapFree(hHeap, 0, (LPSTR)pOverlapped);

}



/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveOvl | Called when a (user) buffer is complete.
 *
 * @parm DWORD | BytesTransferred | Not relevant to us
 *
 * @parm LPOVERLAPPED | pOverLapped | Overlapped structure for this callback
 *
 * @parm PIO_STATUS_BLOCK | The Io status block we used
 *
 * @rdesc None
 *
 * @comm The IO status block is freed and the BytesOutstanding count
 *       used to limit the buffers we have locked down is updated (we
 *       know here that parital buffers are all the same size so we
 *       can compute the size of the 'last' buffer for a given user buffer).
 *       Also the byte count for a recording buffer is updated.
 *       The user buffer is marked as 'DONE'.
 ***************************************************************************/
STATIC void waveOvl(DWORD dwErrorCode, DWORD BytesTransferred, LPOVERLAPPED pOverlapped)
{
    PWAVEHDR pHdr;
    PWAVEALLOC pClient;

    pHdr = ((PWAVEOVL)pOverlapped)->WaveHdr;
    D3(("waveOvl: pHdr = %x", pHdr));
    pClient = (PWAVEALLOC)pHdr->reserved;

    //
    // We can't trust the IO system to return our buffers in the right
    // order so we set a flag in the buffer but only complete buffers
    // at the FRONT of the queue which have the flag set.  In fact
    // we don't process the stuff here - leave that for when we
    // exit the wait because calling the client's callback can
    // do nasty things inside and Apc routine
    //

    WinAssert(pHdr->dwFlags & WHDR_INQUEUE);
    WinAssert(!(pHdr->dwFlags & WHDR_COMPLETE));

    //
    // Mark buffer as done unless we're doing more loops with it
    //
    pHdr->dwFlags |= WHDR_COMPLETE;

    //
    // It's now our duty to see if there were some old loops lying
    // around earlier in the queue which are vestiges of old loops.
    //

    if (pHdr->dwFlags & WHDR_BEGINLOOP) {
        PWAVEHDR pHdrSearch;
        for (pHdrSearch = pClient->DeviceQueue ;
             pHdrSearch != pHdr ;
             pHdrSearch = pHdrSearch->lpNext) {
            WinAssert(pHdrSearch != NULL);
            pHdrSearch->dwFlags |= WHDR_COMPLETE;
        }
    }
    //
    // Recalculate how many bytes are outstanding on the device
    //

    if (pHdr->dwBufferLength) {
        pClient->BytesOutstanding -= (pHdr->dwBufferLength - 1) %
                                         MAX_BUFFER_SIZE + 1;
    }

    //
    // Work out how much was recorded if we're a recording device
    //

    if (pClient->DeviceType == WaveInDevice) {
        pHdr->dwBytesRecorded += BytesTransferred;
    }

    //
    // Free our Iosb
    //

    HeapFree(hHeap, 0, (LPSTR)pOverlapped);

}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | waveLoopOvl | Called when a (user) buffer is complete.
 *                               but the buffer was need for more loops.
 *
 * @parm DWORD | BytesTransferred | Not relevant to us
 *
 * @parm LPOVERLAPPED | pOverLapped | Overlapped structure for this callback
 *
 * @rdesc None
 *
 * @comm Same as waveApc but the buffer is not marked complete.
 ***************************************************************************/
STATIC void waveLoopOvl(DWORD dwErrorCode, DWORD BytesTransferred, LPOVERLAPPED pOverlapped)
{
    DWORD dwFlags;
    PWAVEHDR pHdr;

    D3(("waveLoopOvl"));
    pHdr = ((PWAVEOVL)pOverlapped)->WaveHdr;

    //
    // Do it this way to avoid falling into a hole if the Apcs are
    // in the wrong order !!!
    //
    dwFlags = pHdr->dwFlags;
    waveOvl(dwErrorCode, BytesTransferred, pOverlapped);
    pHdr->dwFlags = dwFlags;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | waveBreakOvl | Used to chase out a buffer to break a loop.
 *
 * @parm DWORD | BytesTransferred | Not relevant to us
 *
 * @parm LPOVERLAPPED | pOverLapped | Overlapped structure for this callback
 *
 * @rdesc None
 *
 * @comm Mark the relevant buffer complete
 ***************************************************************************/
STATIC void waveBreakOvl(DWORD dwErrorCode, DWORD BytesTransferred, LPOVERLAPPED pOverlapped)
{
    D3(("waveBreakOvl"));
    ((PWAVEOVL)pOverlapped)->WaveHdr->dwFlags |= WHDR_COMPLETE;
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveStart | Send more buffers to the device if possible
 *
 * @parm PWAVEALLOC | pClient | The client's handle data
 *
 * @rdesc There is no return code.
 *
 * @comm  The routine is called both when new buffers become available
 *        or when old buffers or parital buffers are completed so
 *        that device can accept more data.
 *
 *        No more that MAX_WAVE_BYTES in buffers no bigger than
 *        MAX_BUFFER_SIZE are to be outstanding on the device at
 *        any one time.
 *
 *        An additional complication is that we have to process loops
 *        which means (among other things) that the SAME BUFFER may
 *        appear multiple times in the driver's list (as different
 *        requests).  There are no loops for input devices.
 *        Loop buffers complete with Apcs which do not complete them
 *        (except for the final loop iteration) which means that if
 *        we decide unexpectedly to finish a loop (ie by waveOutBreakLoop)
 *        we must 'chase' the loop out with an artificial buffer to
 *        get our Apc going.
 *
 ***************************************************************************/
STATIC MMRESULT waveStart(PWAVEALLOC pClient)
{
    DWORD dwSize;
    BOOL Result;

    //
    // See if we can fit any more data on the device
    //

    WinAssert(pClient->hDev != INVALID_HANDLE_VALUE);

    while (pClient->NextBuffer) {
        PWAVEHDR pHdr;

        pHdr = pClient->NextBuffer;

        WinAssert(pClient->DeviceQueue != NULL);
                WinAssert(!(pHdr->dwFlags & (WHDR_DONE | WHDR_COMPLETE)));

        dwSize = pHdr->dwBufferLength - pClient->BufferPosition;
        if (dwSize > MAX_BUFFER_SIZE) {
            dwSize = MAX_BUFFER_SIZE;
        }

        if (dwSize + pClient->BytesOutstanding <= MAX_WAVE_BYTES) {
            //
            // OK - we can fit another buffer in
            //
            // Don't have our overlay structure on the stack for an
            // ASYNCHRONOUS IO !   Otherwise the IO subsystem will overwrite
            // somebody else's data when the operation completes
            //
            PWAVEOVL pWaveOvl;

            if (pClient->BufferPosition == 0) {
                //
                // Start of new buffer
                // See if the buffer is the start of a new loop
                // (Check not continuation of old one)
                //
                if (pClient->NextBuffer &&
                    (pClient->NextBuffer->dwFlags & WHDR_BEGINLOOP) &&
                    pClient->NextBuffer != pClient->LoopHead) {

                    pClient->LoopHead = pClient->NextBuffer;

                    pClient->LoopCount = pClient->NextBuffer->dwLoops;

                    //
                    // Loop count is number of times to play
                    //
                    if (pClient->LoopCount > 0) {
                        pClient->LoopCount--;
                    }
                }
                //
                // See if the loop is actually finished
                //
                if (pClient->LoopCount == 0) {
                    pClient->LoopHead = NULL;
                }

            }

            pWaveOvl = (PWAVEOVL)HeapAlloc(hHeap, 0, sizeof(*pWaveOvl));

            if (pWaveOvl == NULL) {
                return MMSYSERR_NOMEM;
            }

            memset((PVOID)pWaveOvl, 0, sizeof(*pWaveOvl));

            pWaveOvl->WaveHdr = pHdr;

            if (pClient->DeviceType == WaveOutDevice) {
                Result =  WriteFileEx(
                              pClient->hDev,
                                (PBYTE)pHdr->lpData +        // Output buffer
                                    pClient->BufferPosition,
                              dwSize,
                              (LPOVERLAPPED)pWaveOvl,      // Overlap structure
                              pHdr->dwBufferLength !=
                                  pClient->BufferPosition + dwSize ?
                                  wavePartialOvl :
                                  NULL != pClient->LoopHead ?
                                      waveLoopOvl :
                                      waveOvl);            // Overlap callback
            } else {
                Result =  ReadFileEx(
                              pClient->hDev,
                                (PBYTE)pHdr->lpData +        // Output buffer
                                    pClient->BufferPosition,
                              dwSize,
                              (LPOVERLAPPED)pWaveOvl,      // Overlap structure
                              pHdr->dwBufferLength !=
                                  pClient->BufferPosition + dwSize ?
                                  wavePartialOvl :
                                  NULL != pClient->LoopHead ?
                                      waveLoopOvl :
                                      waveOvl);            // Overlap callback
            }

            dprintf3(("Sent %u wave bytes to device, return code %8X",
                     dwSize, GetLastError()));

            if (!Result && GetLastError() != ERROR_IO_PENDING) {

                        //
                        // Free the Iosb since we won't be getting any callbacks
                        //
                        HeapFree(hHeap, 0, (LPSTR)pWaveOvl);

                //
                // If the driver has not got any bytes outstanding then
                // everything may grind to a halt so release everything
                // here and notify 'completion' (ie mark all buffers
                // complete).  This is unsatisfactory but there's no
                // way of telling the application what happenend.
                //

                if (pClient->BytesOutstanding == 0) {

                    //
                    // This will cause acknowlegements to be made when
                    // waveCompleteBuffers is run
                    //
                    waveFreeQ(pClient);
                }
                return sndTranslateStatus();

            } else {
                //
                // We successfully queued the buffer
                // Update our local data
                //
                pClient->BytesOutstanding += dwSize;
                pClient->BufferPosition += dwSize;
                if (pClient->BufferPosition == pHdr->dwBufferLength) {
                    //
                    // Finished this buffer - move on to the next
                    //
                    if (!pClient->LoopHead ||
                        !(pHdr->dwFlags & WHDR_ENDLOOP)) {
                        //
                        // Not end of in a loop so we can free this buffer
                        //
                        pClient->NextBuffer = pHdr->lpNext;

                    } else {
                        //
                        // Finished a loop
                        //
                        if (pClient->LoopCount != 0) {
                            pClient->LoopCount--;
                            pClient->NextBuffer = pClient->LoopHead;
                        } else {
                            //
                            // Someone's tried to kill us.  We have
                            // to 'chase out' the start of this loop
                            // so send a dummy (NULL) packet at the
                            // back of the driver's queue
                            //

                            pClient->DummyWaveOvl.WaveHdr = pClient->LoopHead;

                            Result =
                                WriteFileEx(
                                    pClient->hDev,
                                    (PVOID)pHdr->lpData,
                                    0,
                                    &pClient->DummyWaveOvl.Ovl, // Static for async
                                    waveBreakOvl);

                            if (Result || GetLastError() == ERROR_IO_PENDING) {
                                pClient->LoopHead = NULL; // Loop complete
                                pClient->NextBuffer = pHdr->lpNext;
                            }
                        }
                    }
                    pClient->BufferPosition = 0;
                }
            }
            {
            //    /* Before we go home, let's just touch ONE page - if there is one */
            //    PBYTE pb = (PBYTE)pHdr->lpData + pClient->BufferPosition;
            //    pb = ((DWORD)pb & 0xFFFFF000) + 0x1000;  /* find page start of next page */
            //
            //    if ( (PBYTE)pHdr->lpData + pHdr->dwBufferLength > pb )
            //        PreTouch( pb, 1, FALSE);

            //    /* Before we go home, let's just try to pre-touch that which we will soon want */
            //    PreTouch( (PBYTE)pHdr->lpData + pClient->BufferPosition
            //            , pHdr->dwBufferLength - pClient->BufferPosition
            //            , FALSE
            //            );
            }

        } else {
            //
            // Cannot fit any more bytes in at the moment
            //

//            /* Before we go home, let's just try to pre-touch that which we will soon want */
//            PreTouch( (PBYTE)pHdr->lpData + pClient->BufferPosition
//                    , pHdr->dwBufferLength - pClient->BufferPosition
//                    , FALSE
//                    );

            /* NOW go home! */
            break;
        }
    }
    return MMSYSERR_NOERROR;
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveCompleteBuffers | Buffer completion routine.  This completes
 *     the work of the Apc routine at below Apc priority.  This gets
 *     round the nasty situations arising when the user's callback
 *     causes more apcs to run (I strongly suspect this is a kernel
 *     bug).
 *
 * @parm PWAVEALLOC | pClient | The client's handle data
 *
 * @rdesc There is no return code.
 ***************************************************************************/
STATIC void waveCompleteBuffers(PWAVEALLOC pClient)
{
    //
    // Process buffers from the front of our queue unless we're in
    // a loop
    //

    while (pClient->DeviceQueue &&
           (pClient->DeviceQueue->dwFlags & WHDR_COMPLETE)) {

        PWAVEHDR pHdr;

        pHdr = pClient->DeviceQueue;
        //
        // Release buffer
        //
        pClient->DeviceQueue = pHdr->lpNext;


        //
        // Complete our buffer - note - this can cause another
        // buffer to be marked as complete if the client's
        // callback runs into an alertable wait.
        //

        waveBlockFinished(pHdr,
                          pClient->DeviceType == WaveOutDevice ?
                          WOM_DONE : WIM_DATA);
    }

    //
    // We might be able to start some more output at this point
    //

    waveStart(pClient);
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveFreeQ | Mark all outstanding buffers complete
 *
 * @parm PWAVEALLOC | pClient | The client's handle data
 *
 * @rdesc There is no return code.
 ***************************************************************************/
STATIC void waveFreeQ(PWAVEALLOC pClient)
{
    PWAVEHDR pHdr;
    for (pHdr = pClient->DeviceQueue;
         pHdr != NULL;
         pHdr = pHdr->lpNext) {
        pHdr->dwFlags |= WHDR_COMPLETE;
    }
        //
        // Tidy up next buffer
        //
        pClient->NextBuffer = NULL;
        pClient->BufferPosition = 0;
}

#if 0
typedef struct {
        LPBYTE Addr;
        DWORD  Len;
} PRETOUCHTHREADPARM;

/* asynchronous pre-toucher thread */
DWORD PreToucher(DWORD dw)
{
    PRETOUCHTHREADPARM * pttp;

    int iSize;
    BYTE * pb;

    pttp = (PRETOUCHTHREADPARM *) dw;
    iSize = pttp->Len;
    pb = pttp->Addr;

    LocalFree(pttp);

    while (iSize>0) {
        volatile BYTE b;
        b = *pb;
        pb += 4096;    // move to next page.  Are they ALWAYS 4096?
        iSize -= 4096; // and count it off
    }
    dprintf(("All pretouched!"));
    return 0;
}
#endif //0

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | waveThread | Wave device auxiliary thread.
 *
 * @parm LPVOID | lpParameter | The thread parameter.  In our case this is a
 *     pointer to our wave device data.
 *
 * @rdesc Thread return code.
 ***************************************************************************/
STATIC DWORD waveThread(LPVOID lpParameter)
{
    PWAVEALLOC pClient;
    BOOL Terminate;
//  DWORD dwThread;                   // garbage


    Terminate = FALSE;

    pClient = (PWAVEALLOC)lpParameter;

    //
    // Set our thread to high priority so we don't fail to pass
    // new buffers to the device
    //

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    //
    // We start by waiting for something signalling that we've started
    // and waiting for something to do.
    //

    SetEvent(pClient->AuxEvent2);
    WaitForSingleObject(pClient->AuxEvent1, INFINITE);

    //
    // Now we're going
    //

    for (;;) {
        WinAssert(pClient->hDev != INVALID_HANDLE_VALUE);

        //
        // Decode function number to perform
        //

        switch (pClient->AuxFunction) {
        case WaveThreadAddBuffer:
            //
            // Intialize bytes recorded
            //
            if (pClient->DeviceType == WaveInDevice) {
                pClient->AuxParam.pHdr->dwBytesRecorded = 0;
            }

            //
            // Add the buffer to our list
            //
            {
                LPWAVEHDR *pHdrSearch;

                pClient->AuxParam.pHdr->lpNext = NULL;

                pHdrSearch = &pClient->DeviceQueue;
                while (*pHdrSearch) {
                    pHdrSearch = &(*pHdrSearch)->lpNext;
                }

                *pHdrSearch = pClient->AuxParam.pHdr;
            }
//          {
//               PRETOUCHTHREADPARM * pttp;
//
//               pttp = LocalAlloc(LMEM_FIXED,8);
//
//               if (pttp!=NULL) {
//                   pttp->Addr = pClient->AuxParam.pHdr->lpData;
//                   pttp->Len = pClient->AuxParam.pHdr->dwBufferLength;
//                   CreateThread(NULL, 0, PreToucher, pttp, 0, &dwThread);
//               }
//          }
//          Would need to declutter the system by WAITing for dead threads at some point???

            //
            // See if we can send more to the driver
            //
            if (pClient->NextBuffer == NULL) {
                pClient->NextBuffer = pClient->AuxParam.pHdr;
                pClient->BufferPosition = 0;
            }


//            /* Before we waveStart, let's just try to pre-touch that which we will soon want */
//            {
//                PWAVEHDR pHdr = pClient->NextBuffer;
//                DWORD dwTick = GetTickCount();
//                PreTouch( (PBYTE)pHdr->lpData + pClient->BufferPosition
//                        , pHdr->dwBufferLength - pClient->BufferPosition
//                        , TRUE
//                        );
//                dprintf(("pre-touched out to limit. Took %d mSec", GetTickCount()-dwTick));
//            }

            pClient->AuxReturnCode = waveStart(pClient);
            break;

        case WaveThreadSetState:
            //
            // We have to make sure at least ONE buffer gets
            // completed if we're doing input and it's input.
            //



            //
            // Set Device state.  By issuing state changes on THIS
            // thread the calling thread can be sure that all Apc's
            // generated by buffer completions will complete
            // BEFORE this function completes.
            //

            pClient->AuxReturnCode =
                waveSetState(pClient, pClient->AuxParam.State);


            //
            // Free the rest of our buffers if we're resetting
            //

            if (pClient->AuxParam.State == WAVE_DD_RESET) {
                //
                // Cancel any loops
                //
                pClient->LoopHead = NULL;

                //
                // This function must ALWAYS succeed
                // Note that waveSetState closes the device on failure
                //
                pClient->AuxReturnCode = MMSYSERR_NOERROR;

                //
                // Check this worked (even if the driver's OK the
                // IO subsystem can fail)
                //
                WinAssert(pClient->BytesOutstanding == 0);

                //
                // Free all buffers
                //
                waveFreeQ(pClient);

            } else {
                if (pClient->DeviceType == WaveInDevice &&
                    pClient->AuxReturnCode == MMSYSERR_NOERROR) {

                    if (pClient->AuxParam.State == WAVE_DD_STOP) {
                        //
                        // We're sort of stuck - we want to complete this
                        // buffer but we've got it tied up in the device
                        // We'll reset it here although this erroneously
                        // sets the position to 0
                        //
                        if (pClient->DeviceQueue) {
                            while (!(pClient->DeviceQueue->dwFlags & WHDR_COMPLETE) &&
                                   pClient->BytesOutstanding != 0) {
                                waveSetState(pClient, WAVE_DD_RECORD);
                                pClient->AuxReturnCode =
                                    waveSetState(pClient, WAVE_DD_STOP);
                                if (pClient->AuxReturnCode != MMSYSERR_NOERROR) {
                                    break;
                                }
                            }
                            if (pClient->AuxReturnCode == MMSYSERR_NOERROR) {
                                pClient->DeviceQueue->dwFlags |= WHDR_COMPLETE;
                                                                //
                                                                // Tidy up next buffer
                                                                //
                                                                if (pClient->NextBuffer ==
                                                                    pClient->DeviceQueue) {
                                                                        pClient->NextBuffer =
                                                                            pClient->DeviceQueue->lpNext;
                                                                    pClient->BufferPosition = 0;
                                                            }
                            }
                        }
                    } else {
                        //
                        // If recording restore some buffers if necessary
                        //
                        if (pClient->AuxParam.State == WAVE_DD_RECORD) {
                            pClient->AuxReturnCode = waveStart(pClient);
                        }
                    }
                }
            }
            break;

        case WaveThreadGetData:
            {
                pClient->AuxReturnCode =
                    sndGetHandleData(pClient->hDev,
                                     pClient->AuxParam.GetSetData.DataLen,
                                     pClient->AuxParam.GetSetData.pData,
                                     pClient->AuxParam.GetSetData.Function,
                                     pClient->Event);
            }
            break;

        case WaveThreadSetData:
            {
                pClient->AuxReturnCode =
                    sndSetHandleData(pClient->hDev,
                                     pClient->AuxParam.GetSetData.DataLen,
                                     pClient->AuxParam.GetSetData.pData,
                                     pClient->AuxParam.GetSetData.Function,
                                     pClient->Event);
            }
            break;

        case WaveThreadBreakLoop:
            if (pClient->LoopHead) {
                //
                // If we're in a loop then exit the loop at the
                // end of the next iteration.
                //

                pClient->LoopCount = 0;
            }
            pClient->AuxReturnCode = MMSYSERR_NOERROR;
            break;

        case WaveThreadClose:
            //
            // Try to complete.
            // If we're completed all our buffers then we can.
            // otherwise we can't
            //
            if (pClient->DeviceQueue == NULL) {
                pClient->AuxReturnCode = MMSYSERR_NOERROR;
            } else {
                pClient->AuxReturnCode = WAVERR_STILLPLAYING;
            }
            break;

        case WaveThreadTerminate:
            Terminate = TRUE;
            break;


        default:
            WinAssert(FALSE);   // Invalid call
            break;
        }
        //
        // Trap invalid callers
        //
        pClient->AuxFunction = WaveThreadInvalid;

                //
                // See if any Apcs need completing
                //
                waveCompleteBuffers(pClient);

        //
        // Complete ? - don't set the event here.
        //
        if (Terminate) {
            return 1;
        }

        //
        // Release the thread caller
        //
        SetEvent(pClient->AuxEvent2);

        //
        // Wait for more !
        //

        while (WaitForSingleObjectEx(pClient->AuxEvent1, INFINITE, TRUE) ==
                   WAIT_IO_COMPLETION) {
                waveCompleteBuffers(pClient);
        }
    }

    return 1;      // Satisfy the compiler !
}



/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveCallback | This calls DriverCallback for a WAVEHDR.
 *
 * @parm PWAVEALLOC | pWave | Pointer to wave device.
 *
 * @parm DWORD | msg | The message.
 *
 * @parm DWORD | dw1 | message DWORD (dw2 is always set to 0).
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void waveCallback(PWAVEALLOC pWave, DWORD msg, DWORD_PTR dw1)
{

    // invoke the callback function, if it exists.  dwFlags contains
    // wave driver specific flags in the LOWORD and generic driver
    // flags in the HIWORD

    if (pWave->dwCallback)
        DriverCallback(pWave->dwCallback,       // user's callback DWORD
                       HIWORD(pWave->dwFlags),  // callback flags
                       (HDRVR)pWave->hWave,     // handle to the wave device
                       msg,                     // the message
                       pWave->dwInstance,       // user's instance data
                       dw1,                     // first DWORD
                       0L);                     // second DWORD
}



/****************************************************************************

    This function conforms to the standard Wave input driver message proc
    (widMessage), which is documented in mmddk.d.

****************************************************************************/
DWORD APIENTRY widMessage(DWORD id, DWORD msg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
    PWAVEALLOC pInClient;
    MMRESULT mRet;

    switch (msg) {

        case WIDM_GETNUMDEVS:
            D2(("WIDM_GETNUMDEVS"));
            return sndGetNumDevs(WaveInDevice);

        case WIDM_GETDEVCAPS:
            D2(("WIDM_GETDEVCAPS"));
            return waveGetDevCaps(id, WaveInDevice, (LPBYTE)dwParam1,
                                  (DWORD)dwParam2);

        case WIDM_OPEN:
            D2(("WIDM_OPEN"));
            return waveOpen(WaveInDevice, id, dwUser, dwParam1, dwParam2);

        case WIDM_CLOSE:
            D2(("WIDM_CLOSE"));
            pInClient = (PWAVEALLOC)dwUser;

            //
            // Call our task to see if it's ready to complete
            //
            mRet = waveThreadCall(WaveThreadClose, pInClient);
            if (mRet != MMSYSERR_NOERROR) {
                return mRet;
            }

            waveCallback(pInClient, WIM_CLOSE, 0L);

            //
            // Close our device
            //
            if (pInClient->hDev != INVALID_HANDLE_VALUE) {
                CloseHandle(pInClient->hDev);
                EnterCriticalSection(&mmDrvCritSec);
                pInClient->hDev = INVALID_HANDLE_VALUE;
                LeaveCriticalSection(&mmDrvCritSec);
            }

            return MMSYSERR_NOERROR;

        case WIDM_ADDBUFFER:
            D2(("WIDM_ADDBUFFER"));
            WinAssert(dwParam1 != 0);
            WinAssert(!(((LPWAVEHDR)dwParam1)->dwFlags & ~(WHDR_INQUEUE|WHDR_DONE|WHDR_PREPARED|WHDR_BEGINLOOP|WHDR_ENDLOOP)));

            ((LPWAVEHDR)dwParam1)->dwFlags &= (WHDR_INQUEUE|WHDR_DONE|WHDR_PREPARED);

            WinAssert(((LPWAVEHDR)dwParam1)->dwFlags & WHDR_PREPARED);

            // check if it's been prepared
            if (!(((LPWAVEHDR)dwParam1)->dwFlags & WHDR_PREPARED))
                return WAVERR_UNPREPARED;

            WinAssert(!(((LPWAVEHDR)dwParam1)->dwFlags & WHDR_INQUEUE));

            // if it is already in our Q, then we cannot do this
            if ( ((LPWAVEHDR)dwParam1)->dwFlags & WHDR_INQUEUE )
                return ( WAVERR_STILLPLAYING );

            // store the pointer to my WAVEALLOC structure in the wavehdr
            pInClient = (PWAVEALLOC)dwUser;
            ((LPWAVEHDR)dwParam1)->reserved = (DWORD_PTR)(LPSTR)pInClient;

            return waveWrite((LPWAVEHDR)dwParam1, pInClient);

        case WIDM_STOP:
            D2(("WIDM_PAUSE"));
            pInClient = (PWAVEALLOC)dwUser;
            pInClient->AuxParam.State = WAVE_DD_STOP;
            return waveThreadCall(WaveThreadSetState, pInClient);

        case WIDM_START:
            D2(("WIDM_RESTART"));
            pInClient = (PWAVEALLOC)dwUser;
            pInClient->AuxParam.State = WAVE_DD_RECORD;
            return waveThreadCall(WaveThreadSetState, pInClient);

        case WIDM_RESET:
            D2(("WIDM_RESET"));
            pInClient = (PWAVEALLOC)dwUser;
            pInClient->AuxParam.State = WAVE_DD_RESET;
            return waveThreadCall(WaveThreadSetState, pInClient);

        case WIDM_GETPOS:
            D2(("WIDM_GETPOS"));
            pInClient = (PWAVEALLOC)dwUser;
            return waveGetPos(pInClient, (LPMMTIME)dwParam1, (DWORD)dwParam2);

        default:
            return MMSYSERR_NOTSUPPORTED;
    }

    //
    // Should not get here
    //

    WinAssert(0);
    return MMSYSERR_NOTSUPPORTED;
}

/****************************************************************************

    This function conforms to the standard Wave output driver message proc
    (wodMessage), which is documented in mmddk.h.

****************************************************************************/
DWORD APIENTRY wodMessage(DWORD id, DWORD msg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
    PWAVEALLOC pOutClient;
    MMRESULT mRet;

    switch (msg) {
        case WODM_GETNUMDEVS:
            D2(("WODM_GETNUMDEVS"));
            return sndGetNumDevs(WaveOutDevice);

        case WODM_GETDEVCAPS:
            D2(("WODM_GETDEVCAPS"));
            return waveGetDevCaps(id, WaveOutDevice, (LPBYTE)dwParam1,
                                  (DWORD)dwParam2);

        case WODM_OPEN:
            D2(("WODM_OPEN"));
            return waveOpen(WaveOutDevice, id, dwUser, dwParam1, dwParam2);

        case WODM_CLOSE:
            D2(("WODM_CLOSE"));
            pOutClient = (PWAVEALLOC)dwUser;

            //
            // Call our task to see if it's ready to complete
            //
            mRet = waveThreadCall(WaveThreadClose, pOutClient);
            if (mRet != MMSYSERR_NOERROR) {
                return mRet;
            }

            waveCallback(pOutClient, WOM_CLOSE, 0L);

            //
            // Close our device
            //
            if (pOutClient->hDev != INVALID_HANDLE_VALUE) {
                CloseHandle(pOutClient->hDev);

                EnterCriticalSection(&mmDrvCritSec);
                pOutClient->hDev = INVALID_HANDLE_VALUE;
                LeaveCriticalSection(&mmDrvCritSec);
            }

            return MMSYSERR_NOERROR;

        case WODM_WRITE:
            D2(("WODM_WRITE"));
            WinAssert(dwParam1 != 0);
            WinAssert(!(((LPWAVEHDR)dwParam1)->dwFlags &
                     ~(WHDR_INQUEUE|WHDR_DONE|WHDR_PREPARED|
                       WHDR_BEGINLOOP|WHDR_ENDLOOP)));

            ((LPWAVEHDR)dwParam1)->dwFlags &=
                (WHDR_INQUEUE|WHDR_DONE|WHDR_PREPARED|
                 WHDR_BEGINLOOP|WHDR_ENDLOOP);

            WinAssert(((LPWAVEHDR)dwParam1)->dwFlags & WHDR_PREPARED);

            // check if it's been prepared
            if (!(((LPWAVEHDR)dwParam1)->dwFlags & WHDR_PREPARED))
                return WAVERR_UNPREPARED;

            WinAssert(!(((LPWAVEHDR)dwParam1)->dwFlags & WHDR_INQUEUE));

            // if it is already in our Q, then we cannot do this
            if ( ((LPWAVEHDR)dwParam1)->dwFlags & WHDR_INQUEUE )
                return ( WAVERR_STILLPLAYING );

            // store the pointer to my WAVEALLOC structure in the wavehdr
            pOutClient = (PWAVEALLOC)dwUser;
            ((LPWAVEHDR)dwParam1)->reserved = (DWORD_PTR)(LPSTR)pOutClient;

            return waveWrite((LPWAVEHDR)dwParam1, pOutClient);


        case WODM_PAUSE:
            D2(("WODM_PAUSE"));
            pOutClient = (PWAVEALLOC)dwUser;
            pOutClient->AuxParam.State = WAVE_DD_STOP;
            return waveThreadCall(WaveThreadSetState, pOutClient);

        case WODM_RESTART:
            D2(("WODM_RESTART"));
            pOutClient = (PWAVEALLOC)dwUser;
            pOutClient->AuxParam.State = WAVE_DD_PLAY;
            return waveThreadCall(WaveThreadSetState, pOutClient);

        case WODM_RESET:
            D2(("WODM_RESET"));
            pOutClient = (PWAVEALLOC)dwUser;
            pOutClient->AuxParam.State = WAVE_DD_RESET;
            return waveThreadCall(WaveThreadSetState, pOutClient);

        case WODM_BREAKLOOP:
            pOutClient = (PWAVEALLOC)dwUser;
            D2(("WODM_BREAKLOOP"));
            return waveThreadCall(WaveThreadBreakLoop, pOutClient);


        case WODM_GETPOS:
            D2(("WODM_GETPOS"));
            pOutClient = (PWAVEALLOC)dwUser;
            return waveGetPos(pOutClient, (LPMMTIME)dwParam1, (DWORD)dwParam2);

        case WODM_SETPITCH:
            D2(("WODM_SETPITCH"));
            pOutClient = (PWAVEALLOC)dwUser;
            pOutClient->AuxParam.GetSetData.pData = (PBYTE)&dwParam1;
            pOutClient->AuxParam.GetSetData.DataLen = sizeof(DWORD);
            pOutClient->AuxParam.GetSetData.Function = IOCTL_WAVE_SET_PITCH;
            return waveThreadCall(WaveThreadSetData, pOutClient);

        case WODM_SETVOLUME:
            D2(("WODM_SETVOLUME"));
            //pOutClient = (PWAVEALLOC)dwUser;
            //pOutClient->AuxParam.GetSetData.pData = *(PBYTE *)&dwParam1;
            //pOutClient->AuxParam.GetSetData.DataLen = sizeof(DWORD);
            //pOutClient->AuxParam.GetSetData.Function = IOCTL_WAVE_SET_VOLUME;
            //return waveThreadCall(WaveThreadSetData, pOutClient);

            {
                //
                // Translate to device volume structure
                //

                WAVE_DD_VOLUME Volume;
                Volume.Left = LOWORD(dwParam1) << 16;
                Volume.Right = HIWORD(dwParam1) << 16;

                return sndSetData(WaveOutDevice, id, sizeof(Volume),
                                  (PBYTE)&Volume, IOCTL_WAVE_SET_VOLUME);
            }


        case WODM_SETPLAYBACKRATE:
            D2(("WODM_SETPLAYBACKRATE"));
            pOutClient = (PWAVEALLOC)dwUser;
            pOutClient->AuxParam.GetSetData.pData = (PBYTE)&dwParam1;
            pOutClient->AuxParam.GetSetData.DataLen = sizeof(DWORD);
            pOutClient->AuxParam.GetSetData.Function =
                IOCTL_WAVE_SET_PLAYBACK_RATE;
            return waveThreadCall(WaveThreadSetData, pOutClient);

        case WODM_GETPITCH:
            D2(("WODM_GETPITCH"));
            pOutClient = (PWAVEALLOC)dwUser;
            pOutClient->AuxParam.GetSetData.pData = (PBYTE)dwParam1;
            pOutClient->AuxParam.GetSetData.DataLen = sizeof(DWORD);
            pOutClient->AuxParam.GetSetData.Function = IOCTL_WAVE_GET_PITCH;
            return waveThreadCall(WaveThreadGetData, pOutClient);

        case WODM_GETVOLUME:
            D2(("WODM_GETVOLUME"));
            //pOutClient = (PWAVEALLOC)dwUser;
            //pOutClient->AuxParam.GetSetData.pData = *(PBYTE *)&dwParam1;
            //pOutClient->AuxParam.GetSetData.DataLen = sizeof(DWORD);
            //pOutClient->AuxParam.GetSetData.Function = IOCTL_WAVE_GET_VOLUME;
            //return waveThreadCall(WaveThreadGetData, pOutClient);

            {
                //
                // Translate to device volume structure
                //

                WAVE_DD_VOLUME Volume;
                DWORD rc;

                rc = sndGetData(WaveOutDevice, id, sizeof(Volume),
                                (PBYTE)&Volume, IOCTL_WAVE_GET_VOLUME);

                if (rc == MMSYSERR_NOERROR) {
                    *(LPDWORD)dwParam1 =
                        (DWORD)MAKELONG(HIWORD(Volume.Left),
                                        HIWORD(Volume.Right));
                }

                return rc;
            }

        case WODM_GETPLAYBACKRATE:
            D2(("WODM_GETPLAYBACKRATE"));
            pOutClient = (PWAVEALLOC)dwUser;
            pOutClient->AuxParam.GetSetData.pData = (PBYTE)dwParam1;
            pOutClient->AuxParam.GetSetData.DataLen = sizeof(DWORD);
            pOutClient->AuxParam.GetSetData.Function =
                IOCTL_WAVE_GET_PLAYBACK_RATE;
            return waveThreadCall(WaveThreadGetData, pOutClient);

        default:
            return MMSYSERR_NOTSUPPORTED;
    }

    //
    // Should not get here
    //

    WinAssert(0);
    return MMSYSERR_NOTSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\alloc.c ===
/* ---File: alloc.c -------------------------------------------------------
 *
 *  Description:
 *    Contains memory allocation routines.
 *
 *    This document contains confidential/proprietary information.
 *    Copyright (c) 1990-1994 Microsoft Corporation, All Rights Reserved.
 *
 * Revision History:
 *
 * ---------------------------------------------------------------------- */
/* Notes -

    Global Functions:

        AllocMem () -
        AllocStr () -
        FreeMem () -
        FreeStr () -
        ReallocMem () -

 */

#include <windows.h>
#include "mplayer.h"


#ifdef _DEBUG

LPVOID AllocMem( DWORD cb )

/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LPDWORD  pMem;
    DWORD    cbNew;

    cbNew = cb + 2 * sizeof( DWORD );

    if( cbNew & 3 )
        cbNew += sizeof( DWORD ) - ( cbNew & 3 );

    pMem = (LPDWORD)LocalAlloc (LPTR | LMEM_ZEROINIT, cbNew );

    if( !pMem )
    {
        DPF0( "LocalAlloc failed.\n" );
        return NULL;
    }

    *pMem=cb;

    *(LPDWORD)( (LPBYTE)pMem + cbNew - sizeof( DWORD ) ) = 0xdeadbeef;

    DPF4( "Allocated %d bytes @%08x\n", cbNew, pMem );

    return (LPVOID)( pMem + 1 );
}


VOID FreeMem( LPVOID pMem, DWORD cb )
{
    DWORD   cbNew;
    LPDWORD pNewMem;

    if( !pMem )
        return;

    pNewMem = pMem;
    pNewMem--;

    cbNew = *pNewMem + 2 * sizeof( DWORD );

    if( cbNew & 3 )
        cbNew += sizeof( DWORD ) - ( cbNew & 3 );

    /* Check that the size the caller thinks the block is tallies with
     * the size we placed before beginning of the block, and that the
     * end of the block has our signature:
     */
    if( ( cb && ( *pNewMem != cb ) ) || /* If cb == 0, don't worry about this check */
      ( *(LPDWORD)( (LPBYTE)pNewMem + cbNew - sizeof( DWORD ) ) != 0xdeadbeef ) )
    {
        DPF0( "Corrupt Memory detected freeing block: %0lx\n", pNewMem );
#ifdef DEBUG
        DebugBreak();
#endif
    }

    memset( pNewMem, 0xFE, cbNew );   // Mark frEEd blocks

    DPF4( "Freed %d bytes @%08x\n", cbNew, pNewMem );

    LocalFree((HANDLE) pNewMem );
}


LPVOID ReallocMem( LPVOID lpOldMem, DWORD cbOld, DWORD cbNew )
{
    LPVOID lpNewMem;

    lpNewMem = AllocMem( cbNew );

    if( lpOldMem )
    {
        if( lpNewMem )
        {
            memcpy( lpNewMem, lpOldMem, min( cbNew, cbOld ) );
        }

        FreeMem( lpOldMem, cbOld );
    }

    return lpNewMem;
}

#endif // debug


LPTSTR AllocStr( LPTSTR lpStr )

/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    lpStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LPTSTR lpMem;

    if( !lpStr )
        return NULL;

    lpMem = AllocMem( STRING_BYTE_COUNT( lpStr ) );

    if( lpMem )
        lstrcpy( lpMem, lpStr );

    return lpMem;
}


VOID FreeStr( LPTSTR lpStr )
{
    FreeMem( lpStr, STRING_BYTE_COUNT( lpStr ) );
}


VOID ReallocStr( LPTSTR *plpStr, LPTSTR lpStr )
{
    FreeStr( *plpStr );
    *plpStr = AllocStr( lpStr );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\alloc.h ===
#ifdef _DEBUG
 LPVOID AllocMem( DWORD cb );
 VOID   FreeMem( LPVOID pMem, DWORD cb );
 LPVOID ReallocMem( LPVOID lpOldMem, DWORD cbOld, DWORD cbNew );
#else
 #define AllocMem(cb)            (LPVOID)LocalAlloc(LPTR | LMEM_ZEROINIT, cb)
 #define FreeMem(ptr,cb)           (VOID)LocalFree((HANDLE)ptr)
 #define ReallocMem(ptr,cbo,cbn) (LPVOID)LocalReAlloc((HANDLE)ptr, cbn, LMEM_ZEROINIT | LMEM_MOVEABLE)
#endif

 LPTSTR AllocStr( LPTSTR lpStr );
 VOID FreeStr( LPTSTR lpStr );
 VOID ReallocStr( LPTSTR *plpStr, LPTSTR lpStr );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\avocado.c ===
#include <windows.h>

// initguid.h requires this.
//
#ifdef MTN
#pragma warning(disable: 4103)  // used #pragma pack to change alignment (on Chicago)
#endif
#include <ole2.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>

// due to the previous header, including this causes the DEFINE_GUID
// definitions in the following header(s) to actually allocate data.
//
#include <oleguid.h>
#include <coguid.h>

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\arrow.c ===
/*-----------------------------------------------------------------------------+
| ARROW.C                                                                      |
|                                                                              |
| Control panel arrow code - stolen from WINCOM                                |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32/WIN16 Common code                        |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include <stdlib.h>
#include "mplayer.h"

#define SHIFT_TO_DOUBLE 1
#define DOUBLECLICK     0
#define POINTSPERARROW  3
#define ARROWXAXIS      15
#define ARROWYAXIS      15

POINT ArrowUp[POINTSPERARROW] = {7,1, 3,5, 11,5};
POINT ArrowDown[POINTSPERARROW] = {7,13, 3,9, 11,9};

static    BOOL      bRight;
static    RECT      rUp, rDown;
static    LPRECT    lpUpDown;
static    FARPROC   lpArrowProc;
static    HANDLE    hParent;
BOOL      fInTimer;


#define TEMP_BUFF_SIZE    32

#define SENDSCROLL(hwnd, msg, a, b, h)           \
        SendMessage(hwnd, msg, (UINT_PTR)MAKELONG(a,b), (LONG_PTR)(h))

#define SCROLLMSG(hwndTo, msg, code, hwndId)                                     \
                          SENDSCROLL(hwndTo, msg, code, GETWINDOWID(hwndId), hwndId)



UINT NEAR PASCAL UpOrDown()
{
    LONG pos;
    UINT retval;
    POINT pt;

    pos = GetMessagePos();
    LONG2POINT(pos,pt);
    if (PtInRect((LPRECT)&rUp, pt))
        retval = SB_LINEUP;
    else if (PtInRect((LPRECT)&rDown, pt))
        retval = SB_LINEDOWN;
    else
        retval = (UINT)(-1);      /* -1, because SB_LINEUP == 0 */

    return(retval);
}



UINT FAR PASCAL ArrowTimerProc(HANDLE hWnd, UINT wMsg, short nID, DWORD dwTime)
{
    UINT wScroll;

    if ((wScroll = UpOrDown()) != -1)
    {
        if (bRight == WM_RBUTTONDOWN)
            wScroll += SB_PAGEUP - SB_LINEUP;
        SCROLLMSG( hParent, WM_VSCROLL, wScroll, hWnd);
    }
/* Don't need to call KillTimer(), because SetTimer will reset the right one */
    SetTimer(hWnd, nID, 50, (TIMERPROC)lpArrowProc);
    return(0);
}


void InvertArrow(HANDLE hArrow, UINT wScroll)
{
    HDC hDC;

    lpUpDown = (wScroll == SB_LINEUP) ? &rUp : &rDown;
    hDC = GetDC(hArrow);
    ScreenToClient(hArrow, (LPPOINT)&(lpUpDown->left));
    ScreenToClient(hArrow, (LPPOINT)&(lpUpDown->right));
    InvertRect(hDC, lpUpDown);
    ClientToScreen(hArrow, (LPPOINT)&(lpUpDown->left));
    ClientToScreen(hArrow, (LPPOINT)&(lpUpDown->right));
    ReleaseDC(hArrow, hDC);
    ValidateRect(hArrow, lpUpDown);
    return;
}


LONG_PTR FAR PASCAL _EXPORT ArrowControlProc(HWND hArrow, unsigned message,
                                         WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    RECT        rArrow;
    HBRUSH      hbr;
    short       fUpDownOut;
    UINT        wScroll;

    switch (message) {
/*
        case WM_CREATE:
            break;

        case WM_DESTROY:
            break;
*/

        case WM_MOUSEMOVE:
            if (!bRight)  /* If not captured, don't worry about it */
                break;

            if (lpUpDown == &rUp)
                fUpDownOut = SB_LINEUP;
            else if (lpUpDown == &rDown)
                fUpDownOut = SB_LINEDOWN;
            else
                fUpDownOut = -1;

            switch (wScroll = UpOrDown()) {
                case SB_LINEUP:
                    if (fUpDownOut == SB_LINEDOWN)
                        InvertArrow(hArrow, SB_LINEDOWN);

                    if (fUpDownOut != SB_LINEUP)
                        InvertArrow(hArrow, wScroll);

                    break;

                case SB_LINEDOWN:
                    if (fUpDownOut == SB_LINEUP)
                        InvertArrow(hArrow, SB_LINEUP);

                    if (fUpDownOut != SB_LINEDOWN)
                        InvertArrow(hArrow, wScroll);

                    break;

                default:
                    if (lpUpDown) {
                        InvertArrow(hArrow, fUpDownOut);
                        lpUpDown = 0;
                    }
                }

                break;

        case WM_RBUTTONDOWN:
        case WM_LBUTTONDOWN:
            if (bRight)
                break;

            bRight = message;
            SetCapture(hArrow);
            hParent = GetParent(hArrow);
            GetWindowRect(hArrow, (LPRECT) &rUp);
            CopyRect((LPRECT)&rDown, (LPRECT) &rUp);
            rUp.bottom = (rUp.top + rUp.bottom) / 2;
            rDown.top = rUp.bottom + 1;
            wScroll = UpOrDown();
            InvertArrow(hArrow, wScroll);
#if SHIFT_TO_DOUBLE
            if (wParam & MK_SHIFT) {
                if (message != WM_RBUTTONDOWN)
                    goto ShiftLClick;
                else
                    goto ShiftRClick;
            }
#endif
            if (message == WM_RBUTTONDOWN)
                wScroll += SB_PAGEUP - SB_LINEUP;

            SCROLLMSG(hParent, WM_VSCROLL, wScroll, hArrow);

            lpArrowProc = MakeProcInstance((FARPROC) ArrowTimerProc,ghInst);
            SetTimer(hArrow, GETWINDOWID(hArrow), 200, (TIMERPROC)lpArrowProc);

            break;

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
            if ((bRight - WM_LBUTTONDOWN + WM_LBUTTONUP) == (int)message) {
                bRight = 0;
                ReleaseCapture();
                if (lpUpDown)
                    InvertArrow(hArrow,(UINT)(lpUpDown==&rUp)?
                                                        SB_LINEUP:SB_LINEDOWN);
                if (lpArrowProc) {
                    SCROLLMSG(hParent, WM_VSCROLL, SB_ENDSCROLL, hArrow);
                    KillTimer(hArrow, GETWINDOWID(hArrow));
                    ReleaseCapture();
                    lpArrowProc = 0;
                }
            }
            break;

        case WM_LBUTTONDBLCLK:
ShiftLClick:
            wScroll = UpOrDown() + SB_TOP - SB_LINEUP;
            SCROLLMSG(hParent, WM_VSCROLL, wScroll, hArrow);
            SCROLLMSG(hParent, WM_VSCROLL, SB_ENDSCROLL, hArrow);

            break;

        case WM_RBUTTONDBLCLK:
ShiftRClick:
            wScroll = UpOrDown() + SB_THUMBPOSITION - SB_LINEUP;
            SCROLLMSG(hParent, WM_VSCROLL, wScroll, hArrow);
            SCROLLMSG(hParent, WM_VSCROLL, SB_ENDSCROLL, hArrow);
/*
            hDC = GetDC(hArrow);
            InvertRect(hDC, (LPRECT) &rArrow);
            ReleaseDC(hArrow, hDC);
            ValidateRect(hArrow, (LPRECT) &rArrow);
*/
            break;

        case WM_PAINT:
            BeginPaint(hArrow, &ps);
            GetClientRect(hArrow, (LPRECT) &rArrow);
            hbr = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
            FillRect(ps.hdc, (LPRECT)&rArrow, hbr);
            DeleteObject(hbr);
            hbr = SelectObject(ps.hdc, GetStockObject(BLACK_BRUSH));
            SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWFRAME));
            SetMapMode(ps.hdc, MM_ANISOTROPIC);

            MSetViewportOrg(ps.hdc, rArrow.left, rArrow.top);
            MSetViewportExt(ps.hdc, rArrow.right - rArrow.left,
                                                    rArrow.bottom - rArrow.top);
            MSetWindowOrg(ps.hdc, 0, 0);
            MSetWindowExt(ps.hdc, ARROWXAXIS, ARROWYAXIS);
            MMoveTo(ps.hdc, 0, (ARROWYAXIS / 2));
            LineTo(ps.hdc, ARROWXAXIS, (ARROWYAXIS / 2));
/*
            Polygon(ps.hdc, (LPPOINT) Arrow, 10);
*/
            Polygon(ps.hdc, (LPPOINT) ArrowUp, POINTSPERARROW);
            Polygon(ps.hdc, (LPPOINT) ArrowDown, POINTSPERARROW);
            SelectObject(ps.hdc, hbr);

            EndPaint(hArrow, &ps);

            break;

        default:
            return(DefWindowProc(hArrow, message, wParam, lParam));

            break;
        }

    return(0L);
}


BOOL FAR PASCAL ArrowInit(HANDLE hInst)
{
	static SZCODE aszComArrow[] = TEXT("ComArrow");
    WNDCLASS wcArrow;

    wcArrow.lpszClassName = aszComArrow;
    wcArrow.hInstance     = hInst;
    wcArrow.lpfnWndProc   = ArrowControlProc;
    wcArrow.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wcArrow.hIcon         = NULL;
    wcArrow.lpszMenuName  = NULL;
    wcArrow.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wcArrow.style         = CS_HREDRAW | CS_VREDRAW;
#if DOUBLECLICK
    wcArrow.style         |= CS_DBLCLKS;
#endif
    wcArrow.cbClsExtra    = 0;
    wcArrow.cbWndExtra    = 0;

    if (!RegisterClass(&wcArrow))
        return FALSE;

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\bltprop.h ===
/*-----------------------------------------------------------------------------+
| BLTPROP.H                                                                    |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Created                                                  |
|                                                                              |
+-----------------------------------------------------------------------------*/

#define     RED       0
#define     GREEN     1
#define     BLUE      2

#define     GrayThresh  128
#define     LoThresh    128
#define     HiThresh    192

#define     Mask0    0x01
#define     Mask1    0x02
#define     Mask2    0x04
#define     Mask3    0x08
#define     Mask4    0x10
#define     Mask5    0x20
#define     Mask6    0x40
#define     Mask7    0x80
#define     MaskAll  0xFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\ctrls.c ===
/*-----------------------------------------------------------------------------+
| TOOLBAR.C                                                                    |
|                                                                              |
| Contains the code which implements the toolbar and its buttons.              |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include <string.h>
#include <shellapi.h>

#include "toolbar.h"
#include "mpole.h"
#include "mplayer.h"

#ifndef COLOR_BTNFACE
    #define COLOR_BTNFACE           15
    #define COLOR_BTNSHADOW         16
    #define COLOR_BTNTEXT           18
#endif

extern void FAR cdecl dprintf(LPSTR szFormat, ...);

extern HWND ghwndApp;
extern HWND ghwndToolbar;
extern HWND ghwndFSArrows;


/*
    Variables
*/

HBRUSH hbrGray = NULL;                 // Gray for text

HBRUSH hbrButtonFace;
HBRUSH hbrButtonShadow;
HBRUSH hbrButtonText;
HBRUSH hbrButtonHighLight;
HBRUSH hbrWindowFrame;
HBRUSH hbrWindowColour;

DWORD  rgbButtonHighLight;
DWORD  rgbButtonFocus;
DWORD  rgbButtonFace;
DWORD  rgbButtonText;
DWORD  rgbButtonShadow;
DWORD  rgbWindowFrame;
DWORD  rgbWindowColour;

TBBUTTON tbBtns[TB_NUM_BTNS + MARK_NUM_BTNS + ARROW_NUM_BTNS] =
{
    {BTN_PLAY,  IDT_PLAY,   TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {BTN_PAUSE, IDT_PAUSE,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {BTN_STOP,  IDT_STOP,   TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {BTN_EJECT, IDT_EJECT,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {BTN_HOME,  IDT_HOME,   TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {BTN_RWD,   IDT_RWD,    TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {BTN_FWD,   IDT_FWD,    TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {BTN_END,   IDT_END,    TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {-1,        0,          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    {BTN_MARKIN,    IDT_MARKIN,     TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {BTN_MARKOUT,   IDT_MARKOUT,    TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {ARROW_PREV,    IDT_ARROWPREV,     TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    {ARROW_NEXT,    IDT_ARROWNEXT,     TBSTATE_ENABLED, TBSTYLE_BUTTON, 0}
};

int BtnIndex[TB_NUM_BTNS + MARK_NUM_BTNS + ARROW_NUM_BTNS];

static int iBtnOffset[3] = {0,TB_NUM_BTNS, TB_NUM_BTNS+MARK_NUM_BTNS};


WNDPROC fnTBWndProc = NULL;
WNDPROC fnStatusWndProc = NULL;

/*
    ControlInit( hInst )

    This is called when the application is first loaded into
    memory.  It performs all initialization.

    Arguments:
        hInst    instance handle of current instance

    Returns:
        TRUE if successful, FALSE if not
*/

BOOL
FAR PASCAL
ControlInit(
HANDLE hInst)

{
    long        patGray[4];
    HBITMAP     hbmGray;
    int         i;

    /* initialize the brushes */

        for (i=0; i < 4; i++)
            patGray[i] = 0xAAAA5555L;   //  0x11114444L; // lighter gray

        hbmGray = CreateBitmap(8, 8, 1, 1, patGray);
        hbrGray = CreatePatternBrush(hbmGray);
        if (hbmGray)
            DeleteObject(hbmGray);

        rgbButtonFace       = GetSysColor(COLOR_BTNFACE);
        rgbButtonShadow     = GetSysColor(COLOR_BTNSHADOW);
        rgbButtonText       = GetSysColor(COLOR_BTNTEXT);
        rgbButtonHighLight  = GetSysColor(COLOR_BTNHIGHLIGHT);
        rgbButtonFocus      = GetSysColor(COLOR_BTNTEXT);
        rgbWindowFrame      = GetSysColor(COLOR_WINDOWFRAME);
        rgbWindowColour     = GetSysColor(COLOR_WINDOW);

        if (rgbButtonFocus == rgbButtonFace)
                rgbButtonFocus = rgbButtonText;

        hbrButtonFace       = CreateSolidBrush(rgbButtonFace);
        hbrButtonShadow     = CreateSolidBrush(rgbButtonShadow);
        hbrButtonText       = CreateSolidBrush(rgbButtonText);
        hbrButtonHighLight  = CreateSolidBrush(rgbButtonHighLight);
        hbrWindowFrame      = CreateSolidBrush(rgbWindowFrame);
        hbrWindowColour     = CreateSolidBrush(rgbWindowColour);

        if (((UINT_PTR)hbrWindowFrame  &      // fail if any of them are NULL ???
             (UINT_PTR)hbrButtonShadow &
             (UINT_PTR)hbrButtonText   &
             (UINT_PTR)hbrButtonHighLight &
             (UINT_PTR)hbrWindowFrame) == (UINT_PTR)0)


            return FALSE;
    return TRUE;
}

/*
    ControlCleanup()

    Delete the brushes we've been using
*/

void FAR PASCAL ControlCleanup(void)
{
        DeleteObject(hbrGray);
        DeleteObject(hbrButtonFace);
        DeleteObject(hbrButtonShadow);
        DeleteObject(hbrButtonText);
        DeleteObject(hbrButtonHighLight);
        DeleteObject(hbrWindowFrame);
        DeleteObject(hbrWindowColour);

#if 0
        DeleteObject(hbTBMain);
        DeleteObject(hbTBMark);
        DeleteObject(hbTBArrows);
#endif
}


BOOL FAR PASCAL toolbarInit(void)
{
    int i;

    InitCommonControls();

    for(i = 0; i < TB_NUM_BTNS + MARK_NUM_BTNS + ARROW_NUM_BTNS; i++)
        BtnIndex[i] = -1;
    return TRUE;
}


LONG_PTR FAR PASCAL SubClassedTBWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch(wMsg)
    {
    case WM_SIZE:
        return 0;

    case WM_STARTTRACK:
        switch(wParam)
        {
        case IDT_RWD:
        case IDT_FWD:
        case IDT_ARROWPREV:
        case IDT_ARROWNEXT:
            PostMessage(ghwndApp, WM_COMMAND, wParam, REPEAT_ID);
            SetTimer(hwnd, (UINT_PTR)ghwndApp, MSEC_BUTTONREPEAT, NULL);
        }
        return 0;

    case WM_ENDTRACK:
        switch(wParam)
        {
        case IDT_RWD:
        case IDT_FWD:
        case IDT_ARROWPREV:
        case IDT_ARROWNEXT:
            KillTimer(hwnd, wParam);
            SendMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_ENDTRACK, (LPARAM)hwnd);
        }
        return 0;

    case WM_TIMER:
        {
            WPARAM cmd;

            if (wParam != (WPARAM)ghwndApp)
                break;
            if (hwnd == ghwndToolbar)
            {
                if(SendMessage(hwnd, TB_ISBUTTONPRESSED, tbBtns[BTN_RWD].idCommand, 0L))
                    cmd = IDT_RWD;
                else if(SendMessage(hwnd, TB_ISBUTTONPRESSED, tbBtns[BTN_FWD].idCommand, 0L))
                    cmd = IDT_FWD;
                else
                    return 0;

                PostMessage(ghwndApp, WM_COMMAND, cmd, REPEAT_ID);
                return 0;
            }
            else
            if (hwnd == ghwndFSArrows)
            {
                if(SendMessage(hwnd, TB_ISBUTTONPRESSED, tbBtns[TB_NUM_BTNS+MARK_NUM_BTNS+ARROW_PREV].idCommand, 0L))
                    cmd = IDT_ARROWPREV;
                else if(SendMessage(hwnd, TB_ISBUTTONPRESSED, tbBtns[TB_NUM_BTNS+MARK_NUM_BTNS+ARROW_NEXT].idCommand, 0L))
                    cmd = IDT_ARROWNEXT;
                else
                    return 0;

                PostMessage(ghwndApp, WM_COMMAND, cmd, REPEAT_ID);
                return 0;
            }
            KillTimer(hwnd, wParam);
            return 0;
        }
    }
    return CallWindowProc(fnTBWndProc, hwnd, wMsg, wParam, lParam);
}

void SubClassTBWindow(HWND hwnd)
{
    if (!fnTBWndProc)
        fnTBWndProc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
    if (hwnd)
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)SubClassedTBWndProc);
}

#ifndef CCS_NODIVIDER
/* For NT: */
#define CCS_NODIVIDER   0
#endif
HWND FAR PASCAL toolbarCreateMain(HWND hwndParent)
{
    HWND hwnd;

    hwnd =  CreateToolbarEx(hwndParent,
                            WS_VISIBLE|WS_CHILD|WS_CLIPSIBLINGS|TBSTYLE_BUTTON|TBSTYLE_TOOLTIPS|
                                CCS_NODIVIDER,
                            IDT_TBMAINCID, 8,
                            ghInst, IDR_TOOLBAR, NULL, 0, 16, 16, 16, 16, sizeof(TBBUTTON));

    if (hwnd)
        SubClassTBWindow(hwnd);
    return hwnd;
}

HWND FAR PASCAL toolbarCreateMark(HWND hwndParent)
{
    HWND hwnd;

    hwnd =  CreateToolbarEx(hwndParent,
                            WS_VISIBLE|WS_CHILD|WS_CLIPSIBLINGS|TBSTYLE_BUTTON|TBSTYLE_TOOLTIPS|
                                CCS_NODIVIDER,
                            IDT_TBMARKCID, 2,
                            ghInst, IDR_MARK, NULL, 0, 17, 16, 17, 16, sizeof(TBBUTTON));

    if (hwnd)
        SubClassTBWindow(hwnd);
    return hwnd;
}

HWND FAR PASCAL toolbarCreateArrows(HWND hwndParent)
{
    HWND hwnd;

    hwnd =  CreateToolbarEx(hwndParent,
                            WS_VISIBLE|WS_CHILD|WS_CLIPSIBLINGS|TBSTYLE_BUTTON|TBSTYLE_TOOLTIPS|
                                CCS_NODIVIDER,
                            IDT_TBARROWSCID,
                            2,
                            ghInst,
                            IDR_ARROWS,
                            NULL,
                            0,
                            4,
                            7,
                            4,
                            7,
                            sizeof(TBBUTTON));

    if (hwnd)
        SubClassTBWindow(hwnd);
    return hwnd;
}


/***************************************************************************/
/* toolbarStateFromButton: This fn is called by the parent application     */
/*                         to get the state of a button.  It will only     */
/*                         return DOWN, or UP or GRAYED as opposed to      */
/*                         toolbarFullStateFromButton which could return   */
/*                         FULLDOWN.                                       */
/***************************************************************************/
BOOL FAR PASCAL toolbarStateFromButton(HWND hwnd, int iButton, int tbIndex)
{
    int idBtn;
    int pos;

    pos = BtnIndex[iBtnOffset[tbIndex] + iButton];
    if (pos == -1)
        return FALSE;

    idBtn = tbBtns[iBtnOffset[tbIndex] + iButton].idCommand;
    return (BOOL)SendMessage(hwnd, TB_ISBUTTONENABLED, (WPARAM)idBtn, 0L);
}



/***************************************************************************/
/* toolbarAddTool:  Add a button to this toolbar.  Sort them by leftmost   */
/*                  position in the window (for tabbing order).            */
/*                  Return FALSE for an error.                             */
/***************************************************************************/
BOOL FAR PASCAL toolbarAddTool(HWND hwnd, int iButton, int tbIndex, int iState)
{
    TBBUTTON tb;

    tb = tbBtns[iBtnOffset[tbIndex] + iButton];
    if (iState)
        tb.fsState |= TBSTATE_ENABLED;
    else
        tb.fsState &= ~TBSTATE_ENABLED;

    if(!SendMessage(hwnd, TB_ADDBUTTONS, (WPARAM)1, (LPARAM)(const TBBUTTON FAR *)&tb))
        return FALSE;
    BtnIndex[iBtnOffset[tbIndex] + iButton] =
        (int)SendMessage(hwnd, TB_BUTTONCOUNT, 0, 0L) - 1;
    return TRUE;
}

BOOL FAR PASCAL toolbarSwapTools(HWND hwnd, int iButton, int jButton, int tbIndex)
{
    int pos;
    TBBUTTON tb;
    int newBut, oldBut;

    pos = BtnIndex[iBtnOffset[tbIndex] + iButton];
    if (pos == -1)
    {
        pos = BtnIndex[iBtnOffset[tbIndex] + jButton];
        if (pos == -1)
            return FALSE;
        newBut = iButton;
        oldBut = jButton;
    }
    else
    {
        newBut = jButton;
        oldBut = iButton;
    }

    SendMessage(hwnd, TB_DELETEBUTTON, (WPARAM)pos, 0L);
    BtnIndex[iBtnOffset[tbIndex] + oldBut] = -1;

    tb = tbBtns[iBtnOffset[tbIndex] + newBut];

    if(!SendMessage(hwnd, TB_INSERTBUTTON, (WPARAM)pos, (LPARAM)(const TBBUTTON FAR *)&tb))
        return FALSE;
    BtnIndex[iBtnOffset[tbIndex] + newBut] = pos;
    return TRUE;

}


/***************************************************************************/
/* toolbarModifyState:  Given a button ID on the toolbar, change its       */
/*                      state.                                             */
/*                      returns FALSE for an error or if no such button    */
/***************************************************************************/
BOOL FAR PASCAL toolbarModifyState(HWND hwnd, int iButton, int tbIndex, int iState)
{
    int idBtn;
    int pos;

    pos = BtnIndex[iBtnOffset[tbIndex] + iButton];
    if (pos == -1)
        return FALSE;

    idBtn = tbBtns[iBtnOffset[tbIndex] + iButton].idCommand;

    SendMessage(hwnd, TB_PRESSBUTTON,  (WPARAM)idBtn, 0L); //unpress button first. commctrl bug
    if (idBtn == IDT_STOP)
    {
         SendMessage(hwnd, TB_PRESSBUTTON,  (WPARAM)IDT_HOME, 0L);
         SendMessage(hwnd, TB_PRESSBUTTON,  (WPARAM)IDT_END, 0L);
         SendMessage(hwnd, TB_PRESSBUTTON,  (WPARAM)IDT_FWD, 0L);
         SendMessage(hwnd, TB_PRESSBUTTON,  (WPARAM)IDT_RWD, 0L);
    }
    if (!iState)
         SendMessage(hwnd, TB_PRESSBUTTON,  (WPARAM)IDT_EJECT, 0L);
    SendMessage(hwnd, TB_ENABLEBUTTON, (WPARAM)idBtn, (LPARAM)MAKELONG(iState, 0));
    return TRUE;
}

/***************************************************************************/
/* toolbarSetFocus :  Set the focus in the toolbar to the specified button.*/
/*                    If it's gray, it'll set focus to next ungrayed btn.  */
/***************************************************************************/
BOOL FAR PASCAL toolbarSetFocus(HWND hwnd, int iButton)
{
    int pos;

    if ((hwnd != ghwndToolbar) || (iButton != BTN_PLAY && iButton != BTN_PAUSE))
        return TRUE;

    pos = BtnIndex[iButton];
    if (pos != -1)
        return TRUE;

    toolbarSwapTools(hwnd, iButton, 1-iButton, TBINDEX_MAIN);

    return TRUE;
}

LONG_PTR FAR PASCAL SubClassedStatusWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch(wMsg)
    {
    case WM_SIZE:
        return 0;
    }
    return CallWindowProc(fnStatusWndProc, hwnd, wMsg, wParam, lParam);
}

void SubClassStatusWindow(HWND hwnd)
{
    if (!fnStatusWndProc)
        fnStatusWndProc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
    if (hwnd)
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)SubClassedStatusWndProc);
}



/* SBS_SIZEGRIP isn't defined for NT!! */
#ifndef SBS_SIZEGRIP
#define SBS_SIZEGRIP 0
#endif

HWND CreateStaticStatusWindow(HWND hwndParent, BOOL fSizeGrip)
{
    HWND hwnd;

    hwnd = CreateStatusWindow(WS_CHILD|WS_VISIBLE|(fSizeGrip ? 0 : CCS_NOMOVEY),
                                TEXT(""), hwndParent, IDT_STATUSWINDOWCID);

    if (hwnd)
        SubClassStatusWindow(hwnd);
    return hwnd;
}

BOOL WriteStatusMessage(HWND hwnd, LPTSTR szMsg)
{
    TCHAR Text[64];
    SIZE  StatusTextExtent;
    LONG  StatusTextWidth;
    BOOL  rc;

    Text[0] = TEXT('\0');
    GetWindowText(hwnd, Text, CHAR_COUNT(Text));
    if (lstrcmp(szMsg, Text) == 0)
        return TRUE;

    GetStatusTextExtent(ghwndStatic, &StatusTextExtent);

    StatusTextWidth = StatusTextExtent.cy;

    rc = (BOOL)SendMessage(hwnd, SB_SETTEXT, (WPARAM)0, (LPARAM)szMsg);

    GetStatusTextExtent(ghwndStatic, &StatusTextExtent);

    if (StatusTextWidth != StatusTextExtent.cy)
        Layout();

    return rc;
}

BOOL GetStatusTextExtent(HWND hwnd, LPSIZE pTextExtent)
{
    HDC    hdc;
    HFONT  hfontOld;
    TCHAR  Text[64];

    hdc = GetDC(NULL);
    if (hdc == NULL)
        return FALSE;

    Text[0] = TEXT('\0');

    GetWindowText(hwnd, Text, CHAR_COUNT(Text));

    hfontOld = SelectObject(hdc, (HFONT)SendMessage(hwnd, WM_GETFONT, 0, 0));

    GetTextExtentPoint32(hdc, Text, STRLEN(Text), pTextExtent);

    SelectObject(hdc, hfontOld);

    ReleaseDC(NULL, hdc);

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\bltprop.c ===
/*-----------------------------------------------------------------------------+
| BLTPROP.C                                                                    |
|                                                                              |
| Emulates the 16 bit BLTPROP.ASM for WIN32                                    |
|                                                                              |
| (C) Copyright Microsoft Corporation 1993.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
| 21-Oct-1992 MikeTri  Created                                                  |
| 09-Apr-1993 GeraintD Added error propagation
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include <stdlib.h>
#include "mplayer.h"
#include "bltprop.h"


/*
 * 256 colour to 16 colour dithering by error propagation
 *
 * This function takes an 8-bit DIB using 256 colours and converts
 * it to a DIB that uses only 16 distinct colours.
 *
 * We take a pixel and convert it to one of the 16 standard vga colours
 * by taking each component and comparing it against a low and high
 * threshold. Less than the low gets 0 of that component; between low
 * and high gets an intensity of 128, and above the high threshold gets
 * an intensity of 255 for that component. (the standard 16 colours
 * have the 8 combinations of 0 or 128 for each component, and the
 * 8 combinations of 0 or 255 for each component - there are no colours
 * combining intensities of 255 and 128). So if any of our colours
 * are above the high threshold, we use 255 for any non-0 intensity.
 * We also have 2 grey levels that are picked out if all colour intensities
 * are less than a given threshold.
 *
 * The conversion is done by building an 8-bit value with bits set to
 * indicate if each component is above either of the two thresholds,
 * and then using this as a palette index. We thus use an output colour
 * table that contains 256 entries, though only 16 distinct colours.
 *
 * Having converted the pixel into the new palette index, we calculate the
 * difference for each r,g,b component between the original and the final
 * colour. We then add a fraction of this error to the adjacent pixels
 * along, down and diagonally. These error values are added to the
 * red, green and blue values for the adjacent pixels before comparing
 * against the thresholds in the colour conversion process.
 */


/*
 * y error propagation - this contains the error for each component that
 * we wish to pass to the line below. Thus there is one entry for each
 * colour component for each pixel. The same max line length is assumed
 * in the win-16 version.
 */
#define MAXBITMAPWIDTH 	1500
typedef struct _colour_error {
    int red_error;
    int green_error;
    int blue_error;
} colour_error, *pcolour_error;

colour_error y_error[MAXBITMAPWIDTH];

/*
 * we take the difference between the actual and desired components,
 * multiply up by SCALE_UP, and then pass the result divided by SCALE_X
 * to both the pixel across and below, and divided by SCALE_Z to the pixel
 * diagonally across and below. (Below of course, means further down the
 * DIB, and therefore higher up the screen)
 */
#define SCALE_UP	8
#define SCALE_X		32
#define SCALE_Z		64



/*
 * The final pixel has the following form:
 *
 *          bits 7x543210
 *               | ||||||
 *               | |||||+-- set iff RED   > HiThresh
 *               | ||||+--- set iff RED   > LoThresh
 *               | |||+---- set iff GREEN > HiThresh
 *               | ||+----- set iff GREEN > LoThresh
 *               | |+------ set iff BLUE  > HiThresh
 *               | +------- set iff BLUE  > LoThresh
 *               +--------- set iff all colors > GrayThresh
 */

#define RED_HITHRESH	0x01
#define RED_LOTHRESH	0x02
#define GREEN_HITHRESH	0x04
#define GREEN_LOTHRESH	0x08
#define BLUE_HITHRESH	0x10
#define BLUE_LOTHRESH	0x20
#define GRAY_THRESH	0x80

#define ALL_HITHRESH	(RED_HITHRESH | GREEN_HITHRESH | BLUE_HITHRESH)
#define ALL_LOTHRESH	(RED_LOTHRESH | GREEN_LOTHRESH | BLUE_LOTHRESH)

/*
 * convert a palette index in the above threshold format into the
 * rgb component values.
 */
RGBQUAD
ThresholdToRGB(int PalIndex)
{
    RGBQUAD rgbq;
    BYTE RGBVal;

    /* Special case greys */

    if (PalIndex == (GRAY_THRESH | ALL_LOTHRESH)) {

    	rgbq.rgbRed = rgbq.rgbGreen = rgbq.rgbBlue = 0xc0;

    } else if (PalIndex == GRAY_THRESH) {

	rgbq.rgbRed = rgbq.rgbGreen = rgbq.rgbBlue = 0x80;

    } else {

	rgbq.rgbRed = 0;
	rgbq.rgbGreen = 0;
	rgbq.rgbBlue = 0;

	/*
	 * if any components are above hi-threshold, then
	 * use the high threshold for all non-zero components; otherwise
	 * use the low threshold for all non-zero components.
	 */
	if (PalIndex & ALL_HITHRESH) {
	    RGBVal = 0xff;
	} else {
	    RGBVal = 0x80;
	}

	if (PalIndex & (RED_HITHRESH | RED_LOTHRESH)) {
	    rgbq.rgbRed = RGBVal;
	}

	if (PalIndex & (GREEN_HITHRESH | GREEN_LOTHRESH)) {
	    rgbq.rgbGreen = RGBVal;
	}

	if (PalIndex & (BLUE_HITHRESH | BLUE_LOTHRESH)) {
	    rgbq.rgbBlue = RGBVal;
	}
    }

    return (rgbq);

}


/*
 * copy a dib from pbSrc to pbDst reducing to 16 distinct colours
 */
void FAR PASCAL BltProp(LPBITMAPINFOHEADER pbiSrc,
                        LPBYTE pbSrc,
                        UINT SrcX,
                        UINT SrcY,
                        UINT SrcXE,
                        UINT SrcYE,
                        LPBITMAPINFOHEADER pbiDst,
                        LPBYTE pbDst,
                        UINT DstX,
                        UINT DstY)
{
    UINT    count, row, column;
    BYTE    TempByte;
    BYTE    ColourTableIndex;

    int    RedVal;
    int    GreenVal;
    int    BlueVal;
    colour_error x_error, z_error;
    int scaled_error, scaled_x, scaled_z;
    RGBQUAD rgbq;

    LPBITMAPINFO ColourTable;


    DPF2("BltProp");




    /*
     * clear the y_error to zero at start of bitmap
     */
    for (count = 0; count < SrcXE; count++) {
	y_error[count].red_error = 0;
	y_error[count].green_error = 0;
	y_error[count].blue_error = 0;
    }



/*****************************************************************************\
 *
 * Loop through the bitmap picking up the pixel r,g,b values, adjust for
 * the error propagated and then compare the components against the two
 * threshold values. The resulting byte has the following form:
 *
 *          bits 7x543210
 *               | ||||||
 *               | |||||+-- set iff RED   > HiThresh
 *               | ||||+--- set iff RED   > LoThresh
 *               | |||+---- set iff GREEN > HiThresh
 *               | ||+----- set iff GREEN > LoThresh
 *               | |+------ set iff BLUE  > HiThresh
 *               | +------- set iff BLUE  > LoThresh
 *               +--------- set iff all colors > GrayThresh
 *
 * This is an index into the 256-entry colour table generated below (that
 * uses only 16 distinct colours).
 *
 * After creating the correct colour, we calculate the difference between
 * this colour and the original, and propagate that error forwards and down.
 *
\*****************************************************************************/


    /* offset source, dest pointers by SrcX rows */
    pbSrc += (SrcY * pbiSrc->biWidth) + SrcX;
    pbDst += (DstY * pbiDst->biWidth) + DstX;
    ColourTable = (LPBITMAPINFO)pbiSrc;

    for (row=0; row < SrcYE ; row++) {

	/* clear x error for start of row */
	x_error.red_error = 0;
	x_error.green_error = 0;
	x_error.blue_error = 0;
	z_error.red_error = 0;
	z_error.green_error = 0;
	z_error.blue_error = 0;


        for (column = 0; column < SrcXE; column++) {

	    /* pick up the source palette index and get rgb components */
            ColourTableIndex = *pbSrc++;
	    RedVal = ColourTable->bmiColors[ColourTableIndex].rgbRed;
	    GreenVal = ColourTable->bmiColors[ColourTableIndex].rgbGreen;
	    BlueVal = ColourTable->bmiColors[ColourTableIndex].rgbBlue;

	    /* add on error - x-error is propagated from
	     * previous column. y-error is passed down from pixel above.
	     * z-error is passed diagonally and has already been added
	     * into y-error for this pixel.
	     */
	    RedVal += x_error.red_error + y_error[column].red_error;
	    GreenVal += x_error.green_error + y_error[column].green_error;
	    BlueVal += x_error.blue_error + y_error[column].blue_error;

	    /*
	     * As we move along the line, y_error[] for the pixels
	     * ahead of us contains the error to be added to the pixels
	     * on this row. y_error[] for the pixels we have done contains
	     * the error to be propagated to those pixels on the row
	     * below.
	     *
	     * Now that we have picked up the error for this pixel, we
	     * can start accumulating errors for this column on the
	     * row below. We start with the z_error from the previous pixel
	     * and then add in (later) the y_error from the current pixel.
	     */
	    y_error[column] = z_error;



            TempByte = 0x00; // Our "new" bitmap entry, once it has been munged

	    /*
	     * set threshold bits for each component based on adjusted colours
	     */

	    if (RedVal > LoThresh) {
		TempByte |= RED_LOTHRESH;
		if (RedVal > HiThresh){
		    TempByte |= RED_HITHRESH;
		}
	    }
	    if (GreenVal > LoThresh) {
		TempByte |= GREEN_LOTHRESH;
		if (GreenVal > HiThresh){
		    TempByte |= GREEN_HITHRESH;
		}
	    }
	    if (BlueVal > LoThresh) {
		TempByte |= BLUE_LOTHRESH;
		if (BlueVal > HiThresh){
		    TempByte |= BLUE_HITHRESH;
		}
	    }

	    /* set grey scale bit if all colours > grey threshold */
	    if (
		(RedVal > GrayThresh)
		&& (BlueVal > GrayThresh)
		&& (GreenVal > GrayThresh)
	       ) {
		    TempByte |= GRAY_THRESH;
	    }

	    /* we now have palette index into new colour table */
            *pbDst++ = TempByte;

	    /*
	     * calculate difference for each component between
	     * desired colour (after error adjustment) and actual
	     * colour. Remember to add in to the y-error, since this
	     * already contains the z_error from the previous cell.
	     * Hold the z_error for this cell, since we can't add this
	     * to the next y_error until we have used it for the next cell
	     * on this row.
	     *
	     * do the scaling on the absolute values and then
	     * put the sign back in afterwards - to make sure
	     * we handle small negative numbers ok.
	     */
	    rgbq = ThresholdToRGB(TempByte);

	    scaled_error = (RedVal - rgbq.rgbRed) * SCALE_UP;
	    scaled_x = abs(scaled_error) / SCALE_X;
	    scaled_z = abs(scaled_error) / SCALE_Z;
	    x_error.red_error = (scaled_error > 0) ? scaled_x : -scaled_x;
	    z_error.red_error = (scaled_error > 0) ? scaled_z : -scaled_z;
	    y_error[column].red_error += x_error.red_error;


	    scaled_error = (GreenVal - rgbq.rgbGreen) * SCALE_UP;
	    scaled_x = abs(scaled_error) / SCALE_X;
	    scaled_z = abs(scaled_error) / SCALE_Z;
	    x_error.green_error = (scaled_error > 0) ? scaled_x : -scaled_x;
	    z_error.green_error = (scaled_error > 0) ? scaled_z : -scaled_z;
	    y_error[column].green_error += x_error.green_error;

	    scaled_error = (BlueVal - rgbq.rgbBlue) * SCALE_UP;
	    scaled_x = abs(scaled_error) / SCALE_X;
	    scaled_z = abs(scaled_error) / SCALE_Z;
	    x_error.blue_error = (scaled_error > 0) ? scaled_x : -scaled_x;
	    z_error.blue_error = (scaled_error > 0) ? scaled_z : -scaled_z;
	    y_error[column].blue_error += x_error.blue_error;


        }

	/* advance source and dest pointers from end of rectangle to start of
	 * next line
	 */
	pbSrc += pbiSrc->biWidth - SrcXE;
	pbDst += pbiDst->biWidth - SrcXE;
    }

    DPF2("BltProp - finished first loop");
/*****************************************************************************\
 *
 * This part generates a new output colour table entry that is accessed by the
 * modified bitmap generated above, and updates the destination DIB colour
 * table with that new entry.
 *
\*****************************************************************************/

    ColourTable = (LPBITMAPINFO)pbiDst;

    for (count=0; count<256; count++ ) {


/* Update the original colour table within the destination DIB */

        ColourTable->bmiColors[count] = ThresholdToRGB(count);

    }
    DPF2("BltProp - finished second loop");
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\bltprop.asm ===
PAGE    ,132
        TITLE   BltProp.asm
        NAME    BltProp

?WIN = 0
?PLM = 1

.286

.xlist
        include cmacros.inc
        include windows.inc
.list

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends

MAXWIDTH = 1500

externA  __AHINCR

sBegin DATA

;;externW     sColorsOut
;;externW     GrayThresh
;;externW     LoThresh
;;externW     HiThresh
;;externW     Prop
;;externW     Mult

GrayThresh  dw      128            ; 135
LoThresh    dw      128            ; 120
HiThresh    dw      192            ; 200
Prop        dw      8              ; 6
Mult        dw      32, 32, 32     ; 28, 28, 28

usPalMult   DW      3 * 256 DUP (?)

sCol        DW      0

v           DW      3 DUP (?)
val         DW      3 DUP (?)
errx        DW      3 DUP (?)
errz        DW      3 DUP (?)
erry        DW      3 * MAXWIDTH DUP (?)


; the output Color Table
;
;      The pixel values that index this table are generated by PropImage
;      as follows:
;
;          bits 7x543210
;               | ||||||
;               | |||||+-- set iff RED   > HiThresh
;               | ||||+--- set iff RED   > LoThresh
;               | |||+---- set iff GREEN > HiThresh
;               | ||+----- set iff GREEN > LoThresh
;               | |+------ set iff BLUE  > HiThresh
;               | +------- set iff BLUE  > LoThresh
;               +--------- set iff all colors > GrayThresh
;
;      The color values map to the appropriate 16 colors of the standard
;      palette.
;
;      0        - LoThresh     0
;      LoThresh - HiThresh     128
;      HiThresh - 255          255
;
;       As usual the magic grays are special cased
;

dwrgb   macro   n

        red    = 0
        green  = 0
        blue   = 0

        if n and 010101b
            rgbval = 0FFh
        else
            rgbval = 080h
        endif

        if n and 000011b
            red = rgbval
        endif

        if n and 001100b
            green = rgbval
        endif

        if n and 110000b
            blue = rgbval
        endif

        if n eq 0AAh
            red   = 0C0h
            green = 0C0h
            blue  = 0C0h
        endif

        if n eq 080h
            red   = 080h
            green = 080h
            blue  = 080h
        endif

        dw  red,green,blue

        endm

sColorsOut label word

        n = 0
        rept    256
            dwrgb n
            n = n + 1
        endm


sEnd DATA


sBegin CODE
        assumes  ds,DATA
        assumes  ss,DATA
        assumes  cs,CODE

;-------------------------------------------------------------------------;
;
; BltProp
;
;   Does error proagation on a input 8 bpp DIB producing a 8 bpp DIB
;   that only uses 16 colors.
;
;   assumes SS == DS !!
;
; Entry:
;
; Returns:
;       AX = 1
; Error Returns:
;       AX = 0  if error
; Registers Preserved:
;       SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;
;-------------------------------------------------------------------------;

cProc   BltProp, <FAR, PUBLIC, PASCAL>, <ds,si,di>

        parmD   pbiSrc      ; BITMAP info for source DIB
        parmD   pbSrc       ; Source bits pointer
        parmW   SrcX        ; Source X offset
        parmW   SrcY        ; Source Y offset
        parmW   SrcXE       ; Source X extent
        parmW   SrcYE       ; Source Y extent
        parmD   pbiDst      ; BITMAP info for destination DIB
        parmD   pbDst       ; Destination bits pointer
        parmW   DstX        ; Destination X offset
        parmW   DstY        ; Destination Y offset

        localW  cbScanSrc   ; width of a source scanline
        localW  cbScanDst

        localW  cbIncS      ; next scan
        localW  cbIncD
cBegin
        mov     ax,ds
        mov     es,ax
        lea     di,erry                 ; clear out erry[]
        xor     ax,ax
        mov     cx,3 * MAXWIDTH
        rep     stosb

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;
; pre-multiply the input palette by the intensity multipliers
;
; for (row = 0; row < cColorsIn; ++row)
;    for (clr = 0; clr < 3; ++clr)
;        usPalMult[row][2-clr] = rcbmIn.argbColor[row][clr] * Mult[2-clr] / 32;
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;

        les     di,pbiSrc                   ; es:[di] --> source BITMAPINFO

        mov     ax,word ptr es:[di].biWidth ; DWORD align bitmap width
        add     ax,3
        and     ax,not 3
        mov     cbScanSrc,ax

        add     di,word ptr es:[di].biSize  ; es:[di] --> color table

        lea     si,usPalMult                ; ds:[si] --> usPalMult
        mov     cx,256

PalMulLoop:

        xor     bx,bx

irp     rgbX, <rgbRed,rgbGreen,rgbBlue>
        xor     ah,ah
        mov     al,es:[di].&rgbX
        mul     Mult[bx]
        shr     ax,5
        mov     ds:[si+bx],ax
        add     bx,2
endm
        add     si,6
        add     di,4

        loop    PalMulLoop

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;
; fill in the destination color table
;
;    for (inx = 0; inx < 256; ++inx)
;        for (clr = 0; clr < 3; ++clr)
;            rcbmOut.argbColor[inx][clr] = (BYTE)sColorsOut[inx][2-clr];
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;

        les     di,pbiDst                   ; es:[di] --> destination BITMAPINFO

        mov     ax,word ptr es:[di].biWidth ; DWORD align bitmap width
        add     ax,3
        and     ax,not 3
        mov     cbScanDst,ax

        add     di,word ptr es:[di].biSize  ; es:[di] --> color table

        lea     si,sColorsOut               ; ds:[si] --> sColorsOut
        mov     cx,256

sColorsOutLoop:
        lodsw
        mov     es:[di].rgbRed  ,al

        lodsw
        mov     es:[di].rgbGreen,al

        lodsw
        mov     es:[di].rgbBlue ,al

        add     di,4

        loop    sColorsOutLoop

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;
;   caclulate amount to add to source/dest pointer to get the the next scanline
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
        mov     bx,SrcXE

        mov     ax,cbScanSrc
        sub     ax,bx                   ; cbIncS = source ptr inc ea. row
	mov	cbIncS,ax

        mov     ax,cbScanDst
        sub     ax,bx                   ; cbIncD = dest ptr inc ea. row
        mov     cbIncD,ax

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;
;   caclulate the source/dest bitmap pointers
;
;   ds:si   --> source bitmap bits  (pbSrc + cbScanSrc * SrcY + SrcX)
;   es:di   --> dest bitmap bits    (pbDst + cbScanDst * DstY + DstX)
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;

        mov     ax, DstY                ; ax = start scan
        mul     cbScanDst               ; ax *= size of a scanline
        add     ax, DstX                ; ax += X offset
        adc     dx, 0                   ; dx = segment number

        mov     di, ax                  ; set di = offset into segment
        add     di, pbDst.off

        mov     ax,dx                   ; set es = segment
        mov     bx,__AHINCR
        mul     bx
        add     ax, pbDst.sel

        mov     es,ax
;
        mov     ax, SrcY                ; ax = start scan
        mul     cbScanSrc               ; ax *= size of a scanline
        add     ax, SrcX                ; ax += X offset
        adc     dx, 0                   ; dx = segment number

        mov     si, ax                  ; set si = offset into segment
        add     si, pbSrc.off

        mov     ax,dx                   ; set ds = segment
        mov     bx,__AHINCR
        mul     bx
        add     ax, pbSrc.sel

        mov     ds,ax

        assume  ds:nothing

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;
;   start a new row
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;

RowLoop:
	xor	ax,ax			; clear X error for start of line
	mov	errx,ax
	mov	errx+2,ax
	mov	errx+4,ax
	mov	errz,ax 		; clear Z error for start of line
	mov	errz+2,ax
	mov	errz+4,ax

        mov     ax,SrcXE                ; sCol = number of cols to do
	mov	sCol,ax
	xor	bx,bx			; (bx) = initial column number

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;
;   start of the column loop
;
;   MOTE: bp is used in this loop!!! stack locals are not accessable.
;
;       es:di --> dest bits
;       ds:si --> source bits
;       bx    =   Current column # * 6
;       bp    =   is *NOT* stack frame
;       ss    =   DGROUP
;
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;

        push    bp
ColLoop:
        lodsb                           ; get a source BYTE
	xor	ah,ah			; (ax) = dib color
	add	ax,ax			; (ax) = 2 * dib color
	mov	bp,ax			; (bp) = 2 * dib color
	add	ax,ax			; (ax) = 4 * dib color
	add	bp,ax			; (bp) = 6 * dib color (usPalMult index)

	mov	cx,80H			; CL = lointens (MSB flag)
	xor	ax,ax			; AL = output value

irpc color,<420>
	mov	dx,errz[color]		; move previous Z error to next Y
	xchg	dx,erry[bx+color]	;    and get this Y error
	add	dx,usPalMult[bp+color]	; desired intensity of this color
	add	dx,errx[color]		; plus X error
	mov	v[color],dx		; save for ClrLoop2

	cmp	LoThresh,dx		; above low threshold?
	lahf				; set bit for this color accordingly
	rol	ax,1
	cmp	HiThresh,dx		; above high threshold?
	lahf				; set bit for this color accordingly
	rol	ax,1
	cmp	GrayThresh,dx		; above gray threshold?
	lahf				; AND together gray requirements
	and	cl,ah
endm
	or	al,cl			; compose value

;	(al) =	Output color value
;	(bx) =	Column number * 6
;	(ss) =	DGROUP

        stosb                           ; write a dest byte

	xor	ah,ah
	add	ax,ax
	mov	bp,ax
	add	ax,ax
	add	bp,ax			; BP = input value * 6 (usPalMult index)

	cmp	Prop,0
      ;;jz	NoProp

irpc	color,<420>
	mov	ax,v[color]		; compute error for this color
	sub	ax,sColorsOut[bp+color]
	imul	Prop
	xor	ax,dx			; ABS error
	sub	ax,dx	;;
	shr	ax,5			; / 32
	mov	cx,ax
	shr	cx,1			; / 64 for Z
	xor	ax,dx			; unABS error
	sub	ax,dx	;;
	xor	cx,dx			; unABS error
	sub	cx,dx	;;
	add	erry[bx+color],ax	; add Y error to previous Z
	mov	errx[color],ax		; set X error
	mov	errz[color],cx		; set Z error
endm

;	We get weird, below, trying to allow the common jump cases to fall
;	through.  Since ColLoop is so large, we will use the dead space
;	after the unconditional jump to hide out-of-line code


NoProp:
        or      si,si
        jz      fixSSeg

fixDOff:
        or      di,di
        jz      fixDSeg

EndColLoop:
	add	bx,6
	dec	sCol
	jz	ColLoopDone
	jmp	ColLoop

fixSSeg:
        mov     ax,ds
        add     ax,__AHINCR
        mov     ds,ax
	jmp	fixDOff

fixDSeg:
        mov     ax,es
        add     ax,__AHINCR
        mov     es,ax
	jmp	EndColLoop
ColLoopDone:

;	End Weirdness.

        pop     bp                      ; it is safe to use locals now

        add     si,cbIncS
        jnc     @f
        mov     ax,ds
        add     ax,__AHINCR
        mov     ds,ax
@@:
        add     di,cbIncD
        jnc     @f
        mov     ax,es
        add     ax,__AHINCR
        mov     es,ax
@@:
        dec     SrcYE
	jz	@F
	jmp	RowLoop
@@:

cEnd

sEnd CODE

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\cdrag.c ===
/*---------------------------------------------------------------------------
|   CDRAG.C
|   This file has the interfaces for the object transferred through the
|   Clipboard or through a Drag-Drop. These interfaces unlike the interfaces
|   implemented in the file OBJ.C transfer the state of the object at
|   Edit->Copy time or Drag-Drop time. The interfaces in OBJ.C transfer the
|   real-time Object Data.
|
|   Created by: Vij Rajarajan (VijR)
+---------------------------------------------------------------------------*/
#define SERVERONLY
#include <windows.h>
#include <windowsx.h>
#include "mpole.h"
#include "mplayer.h"

#include <malloc.h>

#define OLESTDDELIM "!"
#define STGM_SALL (STGM_READWRITE | STGM_SHARE_EXCLUSIVE)

HANDLE GetMetafilePict (VOID);
SCODE SaveMoniker (LPSTREAM lpstream);
HANDLE PASCAL GetDib (VOID);

HANDLE  ghClipData = NULL;  /*  Holds the  data handle at the time of Copy */
HANDLE  ghClipMetafile = NULL;  /*  to clipboard */
HANDLE  ghClipDib = NULL;

/* Global flag to indicate OLE was initialized for drag.
 * This happens on a separate thread from the main window,
 * so we need to initialize and uninitialize independently.
 */
BOOL    gfOleInitForDrag = FALSE;

extern LPDATAOBJECT gpClipboardDataObject;

/**************************************************************************
*   CutOrCopyObject
*   Sets the clipboard with the IDataObject interface of the lpdoc
*   object passed as the argument. The function also saves a snapshot of
*   the state of the object in the globals ghClipMetafile, ghClipData,
*   and ghClipDib.
**************************************************************************/
void CutOrCopyObj (LPDOC lpdoc)
{
    LPDATAOBJECT lpDataObj;

    lpDataObj = (LPDATAOBJECT)CreateClipDragDataObject(lpdoc,TRUE);

    if (lpDataObj != NULL) {
        if (ghClipData)
            GLOBALFREE(ghClipData);
        if (ghClipMetafile) {
            {
            // note that ghClipMetafile is set deep in PictureFromDib and contains
            // a handle to a windows metafile. Clean this up properly here. There may
            // be other memory/handle leaks caused by this coding of the metafile handle elsewhere.
            // SteveZ
               LPMETAFILEPICT pmfp;
               BOOL bReturn;
               DWORD dw;
               pmfp = (LPMETAFILEPICT)GLOBALLOCK(ghClipMetafile);
               bReturn = DeleteMetaFile(pmfp->hMF);
               if (!bReturn) {
                  dw = GetLastError();
               }
               GLOBALUNLOCK(ghClipMetafile);
            }
            GLOBALFREE(ghClipMetafile);
		}
        if (ghClipDib)
            GLOBALFREE(ghClipDib);
        ghClipData = GetLink();
        ghClipMetafile = GetMetafilePict();
        ghClipDib = GetDib();
        OleSetClipboard(lpDataObj);
        IDataObject_Release(lpDataObj);
        gpClipboardDataObject = lpDataObj;
    }
}


/**************************************************************************
*   CreateClipDragDataObject:
*   This function returns an initialized instance of the CLIPDRAGDATA data
*   structure. fClipData = TRUE if the object is for the clipboard and
*   = FALSE if the object is for Drag-Drop operation.
**************************************************************************/
LPCLIPDRAGDATA CreateClipDragDataObject(LPDOC lpdoc, BOOL fClipData)
{
    LPCLIPDRAGDATA lpclipdragdata;

    lpclipdragdata = malloc( sizeof(CLIPDRAGDATA) );

    if (lpclipdragdata == NULL)
    {
        DPF0("Malloc failed in CreateClipDragDataObject\n");
        return NULL;
    }

    lpclipdragdata->m_IDataObject.lpVtbl = &clipdragVtbl;
    lpclipdragdata->lpClipDragEnum = NULL;

    lpclipdragdata->m_IDropSource.lpVtbl = &dropsourceVtbl;
    lpclipdragdata->m_IDataObject.lpclipdragdata = lpclipdragdata;
    lpclipdragdata->m_IDropSource.lpclipdragdata = lpclipdragdata;
    lpclipdragdata->lpdoc = lpdoc;
    lpclipdragdata->cRef    = 1;
    lpclipdragdata->fClipData   = fClipData;

    return lpclipdragdata;
}

/**************************************************************************
*   DoDrag:
*   Initiates the Drag-Drop operation.
**************************************************************************/
void DoDrag(void)
{
    DWORD       dwEffect;
    LPCLIPDRAGDATA  lpclipdragdata;

    if (!InitOLE(&gfOleInitForDrag, NULL))
    {
        DPF0("Initialization of OLE FAILED!!  Can't do drag.\n");
        return;
    }

    lpclipdragdata = CreateClipDragDataObject ((LPDOC)&docMain, FALSE);

    if (lpclipdragdata)
    {
        HRESULT hr;

        hr = (HRESULT)DoDragDrop((IDataObject FAR*)&lpclipdragdata->m_IDataObject,
                        (IDropSource FAR*)&lpclipdragdata->m_IDropSource,
                        DROPEFFECT_COPY, &dwEffect);

        DPF("DoDragDrop returned %s\n", hr == S_OK ? "S_OK" : hr == DRAGDROP_S_DROP ? "DRAGDROP_S_DROP" : hr == DRAGDROP_S_CANCEL ? "DRAGDROP_S_CANCEL" : hr == E_OUTOFMEMORY ? "E_OUTOFMEMORY" : hr == E_UNEXPECTED ? "E_UNEXPECTED" : "<?>");

        IDataObject_Release((IDataObject *)&lpclipdragdata->m_IDataObject);
    }
}

void CleanUpDrag(void)
{
    if (gfOleInitForDrag)
    {
        DPF("Uninitializing OLE for thread %d\n", GetCurrentThreadId());
        CoDisconnectObject((LPUNKNOWN)&docMain, 0);
        OleUninitialize();
        gfOleInitForDrag = FALSE;
    }
}

/**************************************************************************
*   GetObjectDescriptorData:
*   Packages an ObjectDescriptor data structure.
**************************************************************************/
HGLOBAL GetObjectDescriptorData(
    CLSID     clsid,
    DWORD     dwAspect,
    SIZEL     sizel,
    POINTL    pointl,
    DWORD     dwStatus,
    LPTSTR    lpszFullUserTypeName,
    LPTSTR    lpszSrcOfCopy
)
{
    HGLOBAL            hMem = NULL;
    IBindCtx   FAR    *pbc = NULL;
    LPOBJECTDESCRIPTOR lpOD;
    DWORD              dwObjectDescSize, dwFullUserTypeNameLen, dwSrcOfCopyLen;
    DWORD              Offset;

    // Get the length of Full User Type Name:
    dwFullUserTypeNameLen = STRING_BYTE_COUNT_NULLOK(lpszFullUserTypeName);
    dwFullUserTypeNameLen *= (sizeof(WCHAR) / sizeof(TCHAR));

    // Get the Source of Copy string and its length:
    dwSrcOfCopyLen = STRING_BYTE_COUNT_NULLOK(lpszSrcOfCopy);
    dwSrcOfCopyLen *= (sizeof(WCHAR) / sizeof(TCHAR));

    if (lpszSrcOfCopy == NULL) {
       // No src moniker so use user type name as source string.
       lpszSrcOfCopy  = lpszFullUserTypeName;
       dwSrcOfCopyLen = dwFullUserTypeNameLen;
    }

    // Allocate space for OBJECTDESCRIPTOR and the additional string data
    dwObjectDescSize = sizeof(OBJECTDESCRIPTOR);
    hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE,
                       dwObjectDescSize
                       + dwFullUserTypeNameLen
                       + dwSrcOfCopyLen);
    if (NULL == hMem)
        goto error;

    lpOD = (LPOBJECTDESCRIPTOR)GLOBALLOCK(hMem);

    if(!lpOD)
        goto error;

    // Set offset to copy strings at end of the object descriptor:
    Offset = dwObjectDescSize;

    // Set the FullUserTypeName offset and copy the string
    if (lpszFullUserTypeName)
    {
        lpOD->dwFullUserTypeName = Offset;
#ifdef UNICODE
        lstrcpy((LPWSTR)(((LPBYTE)lpOD)+Offset), lpszFullUserTypeName);
#else
        AnsiToUnicodeString(lpszFullUserTypeName, (LPWSTR)(((LPBYTE)lpOD)+Offset), -1);
#endif
        Offset += dwFullUserTypeNameLen;
    }
    else lpOD->dwFullUserTypeName = 0;  // zero offset indicates that string is not present

    // Set the SrcOfCopy offset and copy the string
    if (lpszSrcOfCopy)
    {
        lpOD->dwSrcOfCopy = Offset;
#ifdef UNICODE
        lstrcpy((LPWSTR)(((LPBYTE)lpOD)+Offset), lpszSrcOfCopy);
#else
        AnsiToUnicodeString(lpszSrcOfCopy, (LPWSTR)(((LPBYTE)lpOD)+Offset), -1);
#endif
    }
    else lpOD->dwSrcOfCopy = 0;  // zero offset indicates that string is not present

    // Initialize the rest of the OBJECTDESCRIPTOR
    lpOD->cbSize       = dwObjectDescSize + dwFullUserTypeNameLen + dwSrcOfCopyLen;
    lpOD->clsid        = clsid;
    lpOD->dwDrawAspect = dwAspect;
    lpOD->sizel        = sizel;
    lpOD->pointl       = pointl;
    lpOD->dwStatus     = dwStatus;

    GLOBALUNLOCK(hMem);
    return hMem;

error:
   if (hMem)
   {
       GLOBALUNLOCK(hMem);
       GLOBALFREE(hMem);
   }
   return NULL;
}



/**************************************************************************
***************   IUnknown INTERFACE INPLEMENTATION.
**************************************************************************/
STDMETHODIMP    ClipDragUnknownQueryInterface (
    LPCLIPDRAGDATA    lpclipdragdata, // data object ptr
    REFIID            riidReq,        // IID required
    LPVOID FAR *      lplpUnk         // pre for returning the interface
)
{
    if ( IsEqualIID(riidReq, &IID_IDataObject) ||  IsEqualIID(riidReq, &IID_IUnknown) )
    {
        *lplpUnk = (LPVOID) lpclipdragdata;
    }
    else if ( IsEqualIID(riidReq, &IID_IDropSource))
    {
        *lplpUnk = (LPVOID) &lpclipdragdata->m_IDropSource;
    }
    else
    {
        *lplpUnk = (LPVOID) NULL;
        RETURN_RESULT(E_NOINTERFACE);
    }

    DPF("ClipDragAddRef: cRef = %d\n", lpclipdragdata->cRef + 1);
    lpclipdragdata->cRef++;
    return NOERROR;
}


STDMETHODIMP_(ULONG)    ClipDragUnknownAddRef(
    LPCLIPDRAGDATA      lpclipdragdata     // data object ptr
)
{
    DPF("ClipDragAddRef: cRef = %d\n", lpclipdragdata->cRef + 1);

    return ++lpclipdragdata->cRef;
}


STDMETHODIMP_(ULONG)    ClipDragUnknownRelease (
    LPCLIPDRAGDATA lpclipdragdata
)
{
    DPF("ClipDragRelease: cRef = %d\n", lpclipdragdata->cRef - 1);

    if ( --lpclipdragdata->cRef != 0 )
        return lpclipdragdata->cRef;

    free(lpclipdragdata);

    return 0;
}


/**************************************************************************
******************   IDataObject INTERFACE IMPLEMENTATION.
**************************************************************************/
STDMETHODIMP    ClipDragQueryInterface (
    LPDATAOBJECT      lpDataObj,      // data object ptr
    REFIID            riidReq,        // IID required
    LPVOID FAR *      lplpUnk         // pre for returning the interface
)
{
    DPF("ClipDragQueryInterface\n");

    return
        ClipDragUnknownQueryInterface (
            (LPCLIPDRAGDATA)  (( struct CDataObject FAR* )lpDataObj)->lpclipdragdata ,
            riidReq,
            lplpUnk
        );
}


STDMETHODIMP_(ULONG)    ClipDragAddRef(
    LPDATAOBJECT      lpDataObj      // data object ptr
)
{
    return
        ClipDragUnknownAddRef (
            (LPCLIPDRAGDATA)  (( struct CDataObject FAR* )lpDataObj)->lpclipdragdata
        );
}


STDMETHODIMP_(ULONG)    ClipDragRelease (
    LPDATAOBJECT      lpDataObj      // data object ptr
)
{
    return
        ClipDragUnknownRelease (
            (LPCLIPDRAGDATA)  (( struct CDataObject FAR* )lpDataObj)->lpclipdragdata
        );
}



/* Routines called by ClipDragGetData, one for each format supported:
 */
HRESULT ClipDragGetData_EmbedSource(
    LPCLIPDRAGDATA lpclipdragdata,
    LPSTGMEDIUM    lpMedium
);
HRESULT ClipDragGetData_ObjectDescriptor(
    LPCLIPDRAGDATA lpclipdragdata,
    LPSTGMEDIUM    lpMedium
);
HRESULT ClipDragGetData_MetafilePict(
    LPCLIPDRAGDATA lpclipdragdata,
    LPSTGMEDIUM    lpMedium
);
HRESULT ClipDragGetData_DIB(
    LPCLIPDRAGDATA lpclipdragdata,
    LPSTGMEDIUM    lpMedium
);

/**************************************************************************
*   ClipDragGetData:
*   Returns the saved snapshot of the Object in the required format,
*   if available. If not, returns the current snapshot.  We still write
*   out the OLE1 embedding to maintain backward compatibility.
**************************************************************************/
STDMETHODIMP    ClipDragGetData (
    LPDATAOBJECT lpDataObj,
    LPFORMATETC  lpformatetc,
    LPSTGMEDIUM  lpMedium
)
{
    LPCLIPDRAGDATA lpclipdragdata;
    SCODE          scode;
    STGMEDIUM      stgm;
    CLIPFORMAT     cfFormat;
    DWORD          tymed;

    DPF("ClipDragGetData\n");

    if (lpMedium == NULL)
        RETURN_RESULT( E_FAIL);

    VERIFY_LINDEX(lpformatetc->lindex);

    memset(&stgm, 0, sizeof stgm);

    lpclipdragdata = (LPCLIPDRAGDATA) lpDataObj;

    cfFormat = lpformatetc->cfFormat;
    tymed    = lpformatetc->tymed;

    if ((cfFormat == cfEmbedSource) && (tymed & TYMED_ISTORAGE))
        scode = ClipDragGetData_EmbedSource(lpclipdragdata, &stgm);

    else if ((cfFormat == cfObjectDescriptor) && (tymed & TYMED_HGLOBAL))
        scode = ClipDragGetData_ObjectDescriptor(lpclipdragdata, &stgm);

    else if ((cfFormat == CF_METAFILEPICT) && (tymed & TYMED_MFPICT))
        scode = ClipDragGetData_MetafilePict(lpclipdragdata, &stgm);

    else if ((cfFormat == CF_DIB) && (tymed & TYMED_HGLOBAL))
        scode = ClipDragGetData_DIB(lpclipdragdata, &stgm);

    else
        scode = DATA_E_FORMATETC;

    if (scode == S_OK)
        *lpMedium = stgm;

    RETURN_RESULT(scode);
}

#ifdef DEBUG
BOOL WriteOLE2Class( )
{
    HKEY  hKey;
    TCHAR Data[8];
    DWORD Size;
    BOOL  rc = FALSE;

    if( RegOpenKeyEx( HKEY_CLASSES_ROOT, TEXT( "MPlayer\\Debug" ), 0,
                      KEY_READ, &hKey ) == ERROR_SUCCESS )
    {
        if( RegQueryValueEx( hKey, TEXT( "WriteOLE2Class" ), NULL, NULL,
                             (LPBYTE)&Data, &Size ) == ERROR_SUCCESS )
        {
            if( Data[0] == TEXT( 'y' ) || Data[0] == TEXT( 'Y' ) )
                rc = TRUE;
        }

        RegCloseKey( hKey );
    }

    return rc;
}
#endif


/*
 *
 */
HRESULT ClipDragGetData_EmbedSource(
    LPCLIPDRAGDATA lpclipdragdata,
    LPSTGMEDIUM    lpMedium
)
{
    SCODE    scode;
    LPSTREAM lpstm = NULL;
    LPWSTR   lpszUserType;
    HANDLE   hGlobal = NULL;
    DWORD_PTR    nNativeSz;
    ULONG    cbWritten;

    scode = GetScode(StgCreateDocfile(NULL, /* Create temporary compound file */
                                      STGM_CREATE | STGM_SALL | STGM_DELETEONRELEASE,
                                      0,    /* Reserved */
                                      &lpMedium->pstg));

    if (scode != S_OK)
        RETURN_RESULT(scode);

    lpMedium->tymed          = TYMED_ISTORAGE;
    lpMedium->pUnkForRelease = NULL;

    //Mark the Object as OLE1.
#ifdef UNICODE
    lpszUserType = gachClassRoot;
#else
    lpszUserType = AllocateUnicodeString(gachClassRoot);
    if (!lpszUserType)
        RETURN_RESULT(E_OUTOFMEMORY);
#endif

#ifdef DEBUG
    if(WriteOLE2Class())
    {
        DPF("ClipDragGetData_EmbedSource: Writing OLE2 class ID\n");
        scode = GetScode(WriteClassStg(lpMedium->pstg, &CLSID_MPLAYER));
    }
    else
#endif
    scode = GetScode(WriteClassStg(lpMedium->pstg, &CLSID_OLE1MPLAYER));

    if (scode != S_OK)
        RETURN_RESULT(scode);

    scode = GetScode(WriteFmtUserTypeStg(lpMedium->pstg, cfMPlayer, lpszUserType));
#ifndef UNICODE
    FreeUnicodeString(lpszUserType);
#endif
    if (scode != S_OK)
        RETURN_RESULT(scode);

    //Write to \1Ole10Native stream so that this will be readable by OLE1 Mplayer
    scode = GetScode(IStorage_CreateStream(lpMedium->pstg,sz1Ole10Native,
                     STGM_CREATE | STGM_SALL,0,0,&lpstm));

    if (scode != S_OK)
        RETURN_RESULT(scode);

    //Duplicate the handle we have saved.
    if(lpclipdragdata->fClipData && ghClipData)
        hGlobal = OleDuplicateData(ghClipData, cfEmbedSource, 0);
    else
        hGlobal = GetLink();

    if (!hGlobal)
    {
        GLOBALFREE(hGlobal);
        RETURN_RESULT(E_OUTOFMEMORY);
    }

    nNativeSz = GlobalSize(hGlobal);
    lpclipdragdata->lpdoc->native = GLOBALLOCK(hGlobal);
    if(!lpclipdragdata->lpdoc->native)
    {
        GLOBALUNLOCK(hGlobal);
        GLOBALFREE(hGlobal);
        RETURN_RESULT(E_OUTOFMEMORY);   /* What's the right error here? */
    }

    scode = GetScode(IStream_Write(lpstm,&nNativeSz,4,&cbWritten));

    if (scode != S_OK)
        RETURN_RESULT(scode);

    scode = GetScode(IStream_Write(lpstm,lpclipdragdata->lpdoc->native,
                                   (ULONG)nNativeSz,&cbWritten));

    if (cbWritten != nNativeSz)
        scode = E_FAIL  ;

    IStream_Release(lpstm);
    GLOBALUNLOCK(hGlobal);
    GLOBALFREE(hGlobal);
    lpstm = NULL;

    RETURN_RESULT(scode);
}

/*
 *
 */
HRESULT ClipDragGetData_ObjectDescriptor(
    LPCLIPDRAGDATA lpclipdragdata,
    LPSTGMEDIUM    lpMedium
)
{
    SIZEL   sizel;
    POINTL  pointl;
    TCHAR   displayname[256];
    LPTSTR  lpszdn = (LPTSTR)displayname;
    HGLOBAL hobjdesc;
    DWORD   dwStatus = 0;
	static  SZCODE aszDispFormat[] = TEXT("%"TS" : %"TS"");

    DPF("\n^^^^^^CDGetdata: OBJECTDESC");
    sizel.cx = extWidth;
    sizel.cy = extHeight;
    pointl.x = pointl.y = 0;
    wsprintf(displayname, aszDispFormat, (LPTSTR)gachClassRoot, (LPTSTR)gachWindowTitle);

#ifdef DEBUG
    if(WriteOLE2Class())
    {
        DPF("ClipDragGetData_ObjectDescriptor: Getting OLE2 class\n");
        hobjdesc = GetObjectDescriptorData(CLSID_MPLAYER, DVASPECT_CONTENT,
                                           sizel, pointl, dwStatus, lpszdn, lpszdn);
    }
    else
#endif
    hobjdesc = GetObjectDescriptorData(CLSID_OLE1MPLAYER, DVASPECT_CONTENT,
                                       sizel, pointl, dwStatus, lpszdn, lpszdn);

    if (hobjdesc)
    {
        lpMedium->hGlobal = hobjdesc;
        lpMedium->tymed = TYMED_HGLOBAL;
        lpMedium->pUnkForRelease = NULL;
        return NOERROR;
    }

    RETURN_RESULT(E_OUTOFMEMORY);
}

/*
 *
 */
HRESULT ClipDragGetData_MetafilePict(
    LPCLIPDRAGDATA lpclipdragdata,
    LPSTGMEDIUM    lpMedium
)
{
    SCODE scode;

    lpMedium->tymed = TYMED_MFPICT;

    if(lpclipdragdata->fClipData && ghClipMetafile)
        lpMedium->hGlobal = OleDuplicateData(ghClipMetafile, CF_METAFILEPICT, 0);
    else
        lpMedium->hGlobal = GetMetafilePict();

    if (lpMedium->hGlobal == NULL)
        scode = E_OUTOFMEMORY;
    else
        scode = S_OK;

    lpMedium->pUnkForRelease = NULL;

    RETURN_RESULT(scode);
}

/*
 *
 */
HRESULT ClipDragGetData_DIB(
    LPCLIPDRAGDATA lpclipdragdata,
    LPSTGMEDIUM    lpMedium
)
{
    SCODE scode;

    lpMedium->tymed = TYMED_HGLOBAL;

    if(lpclipdragdata->fClipData && ghClipDib)
        lpMedium->hGlobal = OleDuplicateData(ghClipDib, CF_DIB, 0);
    else
        /* We must make sure GetDib() happens on the main thread,
         * because otherwise MCI complains.
         */
        lpMedium->hGlobal = (HANDLE)SendMessage(ghwndApp, WM_GETDIB, 0, 0);

    if (lpMedium->hGlobal == NULL)
        scode = E_OUTOFMEMORY;
    else
        scode = S_OK;

    lpMedium->pUnkForRelease = NULL;

    RETURN_RESULT(scode);
}


/**************************************************************************
*   ClipDragGetDataHere:
*   Make the embedding by writing into the Stream Mplayer3EmbedSource.
*
**************************************************************************/
STDMETHODIMP    ClipDragGetDataHere (
    LPDATAOBJECT lpDataObj,
    LPFORMATETC  lpformatetc,
    LPSTGMEDIUM  lpMedium
)
{
    LPCLIPDRAGDATA  lpclipdragdata;
    HANDLE      hGlobal = NULL;
    DWORD_PTR   nNativeSz;
    LPTSTR      lpnative;
    ULONG       cbWritten;

    DPF("ClipDragGetDataHere\n");

    if (lpMedium == NULL)
        RETURN_RESULT(E_FAIL);

    VERIFY_LINDEX(lpformatetc->lindex);

    lpclipdragdata = (LPCLIPDRAGDATA) lpDataObj;

    if (lpformatetc->cfFormat == cfEmbedSource)
    {
        SCODE       scode;
        LPSTREAM    lpstm = NULL;
        LPWSTR      lpszUserType;

            if (lpMedium->tymed != TYMED_ISTORAGE)
            RETURN_RESULT(DATA_E_FORMATETC);

#ifdef UNICODE
        lpszUserType = gachClassRoot;
#else
        lpszUserType = AllocateUnicodeString(gachClassRoot);
        if (!lpszUserType)
            RETURN_RESULT(E_OUTOFMEMORY);
#endif
        //Mark the object as OLE1 MPlayer object for backward compatibility:
#ifdef DEBUG
        if(WriteOLE2Class())
        {
            DPF("ClipDragGetDataHere: Writing OLE2 class ID\n");
            scode = GetScode(WriteClassStg(lpMedium->pstg, &CLSID_MPLAYER));
        }
        else
#endif
        scode = GetScode(WriteClassStg(lpMedium->pstg, &CLSID_OLE1MPLAYER));

        if (scode != S_OK)
            RETURN_RESULT(scode);

        scode = GetScode(WriteFmtUserTypeStg(lpMedium->pstg, cfMPlayer, lpszUserType));
#ifndef UNICODE
        FreeUnicodeString(lpszUserType);
#endif
        if (scode != S_OK)
            RETURN_RESULT(scode);

        //Write to the \1Ole10Native stream so the object will be readable by OLE1 Mplayer
        if ((scode = GetScode(IStorage_CreateStream(lpMedium->pstg,
                                                    sz1Ole10Native,
                                                    STGM_CREATE | STGM_SALL,
                                                    0, 0, &lpstm))) != S_OK)
                RETURN_RESULT(scode);

        //Duplicate and give out the handle we have saved.
        if(lpclipdragdata->fClipData && ghClipData)
            hGlobal = OleDuplicateData(ghClipData, cfEmbedSource, 0);
        else
            hGlobal = GetLink();

        if (!hGlobal)
        {
            RETURN_RESULT(E_OUTOFMEMORY);
        }

        nNativeSz = GlobalSize(hGlobal);
        lpnative = GLOBALLOCK(hGlobal);
        if (!lpnative)
        {
            GLOBALUNLOCK(hGlobal);
            GLOBALFREE(hGlobal);
            RETURN_RESULT(E_OUTOFMEMORY);
        }

        scode = GetScode(IStream_Write(lpstm,&nNativeSz,4,&cbWritten));

        scode = GetScode(IStream_Write(lpstm,lpnative,(ULONG)nNativeSz,&cbWritten));
        if (cbWritten != nNativeSz) scode = E_FAIL  ;

        IStream_Release(lpstm);
        GLOBALUNLOCK(hGlobal);
        GLOBALFREE(hGlobal);
        RETURN_RESULT( scode);
    } else
        RETURN_RESULT(DATA_E_FORMATETC);
}



STDMETHODIMP    ClipDragQueryGetData (
    LPDATAOBJECT lpDataObj,
    LPFORMATETC  lpformatetc
)
{
    DPF("ClipDragQueryGetData\n");

    if (lpformatetc->cfFormat == cfEmbedSource ||
        lpformatetc->cfFormat == CF_METAFILEPICT ||
        lpformatetc->cfFormat == CF_DIB ||
        lpformatetc->cfFormat == cfObjectDescriptor
    )

    return NOERROR;
    else
    RETURN_RESULT(DATA_E_FORMATETC);
}


STDMETHODIMP    ClipDragGetCanonicalFormatEtc(
    LPDATAOBJECT lpDataObj,
    LPFORMATETC  lpformatetc,
    LPFORMATETC  lpformatetcOut
)
{
    DPF("ClipDragGetCanonicalFormatEtc\n");

    RETURN_RESULT(DATA_S_SAMEFORMATETC);
}


STDMETHODIMP        ClipDragSetData (
    LPDATAOBJECT lpDataObj,
    LPFORMATETC  lpformatetc,
    LPSTGMEDIUM  lpmedium,
    BOOL         fRelease
)
{
    DPF("ClipDragSetData\n");

    RETURN_RESULT(E_NOTIMPL);
}

STDMETHODIMP ClipDragEnumFormatEtc(
    LPDATAOBJECT         lpDataObj,
    DWORD                dwDirection,
    LPENUMFORMATETC FAR* ppenumFormatEtc
){
    LPCLIPDRAGENUM lpclipdragenum;

    if (ppenumFormatEtc != NULL)
        *ppenumFormatEtc = NULL;

    lpclipdragenum = _fmalloc(sizeof(CLIPDRAGENUM));
    if (lpclipdragenum == NULL)
    RETURN_RESULT(E_OUTOFMEMORY);

    lpclipdragenum->lpVtbl          = &ClipDragEnumVtbl;
    lpclipdragenum->cRef            = 1;
    lpclipdragenum->lpClipDragData  = (LPCLIPDRAGDATA) lpDataObj;
    lpclipdragenum->cfNext          = cfEmbedSource;

    lpclipdragenum->lpClipDragData->lpClipDragEnum = lpclipdragenum;
    *ppenumFormatEtc = (LPENUMFORMATETC) lpclipdragenum;
    return NOERROR;
}


STDMETHODIMP ClipDragAdvise(
    LPDATAOBJECT LPDATAOBJect,
    FORMATETC FAR* pFormatetc,
    DWORD advf,
    IAdviseSink FAR* pAdvSink,
    DWORD FAR* pdwConnection
)
{
    RETURN_RESULT(E_NOTIMPL);
}

STDMETHODIMP ClipDragUnadvise(
    LPDATAOBJECT LPDATAOBJect,
    DWORD dwConnection
)
{
    RETURN_RESULT(E_NOTIMPL);
}

STDMETHODIMP ClipDragEnumAdvise(
    LPDATAOBJECT LPDATAOBJect,
    LPENUMSTATDATA FAR* ppenumAdvise
)
{
    RETURN_RESULT(E_NOTIMPL);
}


/**************************************************************************
****************   IDropSource INTERFACE IMPLEMENTAION.
**************************************************************************/
STDMETHODIMP    DropSourceQueryInterface (
    LPDROPSOURCE      lpdropsource,    // data object ptr
    REFIID            riidReq,        // IID required
    LPVOID FAR *      lplpUnk         // pre for returning the interface
)
{
    return
        ClipDragUnknownQueryInterface (
            (LPCLIPDRAGDATA) ( ( struct CDropSource FAR* )lpdropsource)->lpclipdragdata ,
            riidReq,
            lplpUnk
        );
}


STDMETHODIMP_(ULONG)    DropSourceAddRef(
    LPDROPSOURCE      lpdropsource      // data object ptr
)
{
    return
        ClipDragUnknownAddRef (
            (LPCLIPDRAGDATA) ( ( struct CDropSource FAR* )lpdropsource)->lpclipdragdata
        );
}


STDMETHODIMP_(ULONG)    DropSourceRelease (
    LPDROPSOURCE      lpdropsource      // data object ptr
)
{
    return
        ClipDragUnknownRelease (
            (LPCLIPDRAGDATA) ( ( struct CDropSource FAR* )lpdropsource)->lpclipdragdata
        );
}

STDMETHODIMP    DropSourceQueryContinueDrag (
    LPDROPSOURCE      lpdropsource,     // data object ptr
    BOOL              fEscapePressed,
    DWORD          grfKeyState
)
{

    if (fEscapePressed)
    {
        DPF("DropSourceQueryContinueDrag: fEscapePressed\n");
        RETURN_RESULT( DRAGDROP_S_CANCEL);
    }
    else if (!(grfKeyState & MK_LBUTTON))
    {
        DPF("DropSourceQueryContinueDrag: !(grfKeyState & MK_LBUTTON)\n");
        RETURN_RESULT(DRAGDROP_S_DROP);
    }
    else
        return NOERROR;
}


STDMETHODIMP    DropSourceGiveFeedback (
    LPDROPSOURCE      lpsropsource,      // data object ptr
    DWORD             dwEffect
)
{
    DPF("DropSourceGiveFeedback\n");

    RETURN_RESULT(DRAGDROP_S_USEDEFAULTCURSORS);
}


/**************************************************************************
*************   IEnumFormatEtc INTERFACE IMPLEMENTATION.
**************************************************************************/
STDMETHODIMP ClipDragEnumQueryInterface
(
LPENUMFORMATETC lpEnumFormatEtc,  // Enumerator object ptr
REFIID          riidReq,          // IID required
LPVOID FAR*     lplpUnk           // pre for returning the interface
)
{
    LPCLIPDRAGENUM lpClipDragEnum;

    DPF("ClipDragEnumQueryInterface\n");

    lpClipDragEnum = (LPCLIPDRAGENUM) lpEnumFormatEtc;

    if (IsEqualIID(riidReq, &IID_IEnumFORMATETC) || IsEqualIID(riidReq, &IID_IUnknown)) {
    *lplpUnk = (LPVOID) lpClipDragEnum;
    lpClipDragEnum->cRef++;
    return NOERROR;
    } else {
        *lplpUnk = (LPVOID) NULL;
    RETURN_RESULT( E_NOINTERFACE);
    }
}


STDMETHODIMP_(ULONG) ClipDragEnumAddRef
(
LPENUMFORMATETC lpEnumFormatEtc   // Enumerator object ptr
)
{
    LPCLIPDRAGENUM lpClipDragEnum;

    lpClipDragEnum = (LPCLIPDRAGENUM) lpEnumFormatEtc;

    return ++lpClipDragEnum->cRef;
}


STDMETHODIMP_(ULONG) ClipDragEnumRelease
(
LPENUMFORMATETC lpEnumFormatEtc   // Enumerator object ptr
)
{
    LPCLIPDRAGENUM lpClipDragEnum;

    lpClipDragEnum = (LPCLIPDRAGENUM) lpEnumFormatEtc;

    if (--lpClipDragEnum->cRef != 0)
    return lpClipDragEnum->cRef;

    // Remove Data object pointer (if one exists) to this
    //
    if (lpClipDragEnum->lpClipDragData != NULL)
    lpClipDragEnum->lpClipDragData->lpClipDragEnum = NULL;

    _ffree(lpClipDragEnum);

    return 0;
}


STDMETHODIMP ClipDragEnumNext
(
LPENUMFORMATETC lpEnumFormatEtc,  // Enumerator object ptr
ULONG celt,                       // Number of items requested
FORMATETC FAR rgelt[],            // Buffer for retuend items
ULONG FAR* pceltFetched           // Number of items returned
)
{
    LPCLIPDRAGENUM lpClipDragEnum;
    int ce;
    LPFORMATETC pfe;

    DPF("ClipDragEnumNext\n");

    lpClipDragEnum = (LPCLIPDRAGENUM) lpEnumFormatEtc;

    if (pceltFetched != NULL)
        *pceltFetched = 0;

    if (lpClipDragEnum->lpClipDragData == NULL) // data object gone
    RETURN_RESULT( E_FAIL);

    pfe = rgelt;
    pfe->lindex = DEF_LINDEX;


    for (ce = (int) celt; ce > 0 && lpClipDragEnum->cfNext != 0; ce--) {

    if (lpClipDragEnum->cfNext == cfEmbedSource) {

            pfe->cfFormat = cfEmbedSource;
        pfe->ptd = NULL;
        pfe->dwAspect = DVASPECT_CONTENT;
            pfe->tymed = TYMED_ISTORAGE;
            pfe++;

        lpClipDragEnum->cfNext = CF_METAFILEPICT;
        }
    else
    if (lpClipDragEnum->cfNext == CF_METAFILEPICT) {

            pfe->cfFormat = CF_METAFILEPICT;
            pfe->ptd = NULL;
            pfe->dwAspect = DVASPECT_CONTENT;
        pfe->tymed = TYMED_MFPICT;
            pfe++;
        lpClipDragEnum->cfNext = CF_DIB; //0;
    }
    else
    if (lpClipDragEnum->cfNext == CF_DIB) {

        pfe->cfFormat = CF_DIB;
            pfe->ptd = NULL;
            pfe->dwAspect = DVASPECT_CONTENT;
        pfe->tymed = TYMED_HGLOBAL;
            pfe++;
        lpClipDragEnum->cfNext = cfObjectDescriptor; //0;
    }

    else
    if (lpClipDragEnum->cfNext == cfObjectDescriptor) {

        pfe->cfFormat = cfObjectDescriptor;
            pfe->ptd = NULL;
        pfe->dwAspect = DVASPECT_CONTENT;
        pfe->tymed = TYMED_HGLOBAL;
            pfe++;
        lpClipDragEnum->cfNext = 0;
    }

    }

    if (pceltFetched != NULL)
        *pceltFetched = celt - ((ULONG) ce) ;

    RETURN_RESULT( (ce == 0) ? S_OK : S_FALSE);
}


STDMETHODIMP ClipDragEnumSkip
(
LPENUMFORMATETC lpEnumFormatEtc,  // Enumerator object ptr
ULONG celt                        // Number of elements to skip
)
{
    LPCLIPDRAGENUM lpClipDragEnum;

    DPF("ClipDragEnumSkip\n");

    lpClipDragEnum = (LPCLIPDRAGENUM) lpEnumFormatEtc;

    if (lpClipDragEnum->lpClipDragData == NULL) // data object gone
    RETURN_RESULT( E_FAIL);

    if (lpClipDragEnum->cfNext == cfEmbedSource)
    {
    if (celt == 1)
        lpClipDragEnum->cfNext = CF_METAFILEPICT;
    else if (celt == 2)
        lpClipDragEnum->cfNext = CF_DIB;
    else if (celt == 3)
        lpClipDragEnum->cfNext = cfObjectDescriptor;
    else if (celt > 3)
        goto ReturnFalse;
    }
    else
    if (lpClipDragEnum->cfNext == CF_METAFILEPICT)
    {
    if (celt == 1)
        lpClipDragEnum->cfNext = CF_DIB;
    else if (celt == 2)
        lpClipDragEnum->cfNext = cfObjectDescriptor;
    else if (celt > 2)
        goto ReturnFalse;
    }
    else
    if (lpClipDragEnum->cfNext == CF_DIB)
    {
    if (celt == 1)
        lpClipDragEnum->cfNext = cfObjectDescriptor;
    else if (celt > 1)
        goto ReturnFalse;
    }
    else
    if (lpClipDragEnum->cfNext == cfObjectDescriptor)
    {
    if (celt > 0)
        goto ReturnFalse;
    }
    else
    {
ReturnFalse:
    RETURN_RESULT(S_FALSE);
    }
    return NOERROR;
}


STDMETHODIMP ClipDragEnumReset
(
LPENUMFORMATETC lpEnumFormatEtc   // Enumerator object ptr
)
{
    LPCLIPDRAGENUM lpClipDragEnum;

    DPF("ClipDragEnumReset\n");

    lpClipDragEnum = (LPCLIPDRAGENUM) lpEnumFormatEtc;

    if (lpClipDragEnum->lpClipDragData == NULL) // data object gone
    RETURN_RESULT( E_FAIL);

    lpClipDragEnum->cfNext = cfEmbedSource;

    return NOERROR;
}


STDMETHODIMP     ClipDragEnumClone
(
LPENUMFORMATETC lpEnumFormatEtc,  // Enumerator object ptr
LPENUMFORMATETC FAR* ppenum
)
{
    DPF("ClipDragEnumClone\n");

    if (ppenum != NULL)
        *ppenum = NULL;

    RETURN_RESULT( E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\dynalink.h ===
/*-----------------------------------------------------------------------------+
| DYNALINK.H                                                                   |
|                                                                              |
| (C) Copyright Microsoft Corporation 1994.  All rights reserved.              |
|                                                                              |
| This file contains definitions and macros which allow the transparent        |
| loading and calling of APIs which are dynamically rather than statically     |
| linked.                                                                      |
|                                                                              |
|                                                                              |
| Revision History                                                             |
|    July 1994 Andrew Bell created                                             |
|                                                                              |
+-----------------------------------------------------------------------------*/

typedef struct _PROC_INFO
{
    LPCSTR  Name;
    FARPROC Address;
}
PROC_INFO, *PPROC_INFO;

BOOL LoadLibraryAndProcs(LPTSTR pLibrary, PPROC_INFO pProcInfo, HMODULE *phLibrary);

#define PROCS_LOADED( pProcInfo ) ( (pProcInfo)[0].Address != NULL )
#define LOAD_IF_NEEDED( Library, ProcInfo, phLibrary ) ( PROCS_LOADED( ProcInfo ) ||   \
                                    LoadLibraryAndProcs( Library, ProcInfo, phLibrary ) )

extern TCHAR szComDlg32[];
extern TCHAR szMPR[];
extern TCHAR szOLE32[];

extern HMODULE hComDlg32;
extern HMODULE hMPR;
extern HMODULE hOLE32;

extern PROC_INFO ComDlg32Procs[];
extern PROC_INFO MPRProcs[];
extern PROC_INFO OLE32Procs[];

#ifdef UNICODE
#define GetOpenFileNameW              (LOAD_IF_NEEDED(szComDlg32, ComDlg32Procs, &hComDlg32),\
                                       (*ComDlg32Procs[0].Address))
#else
#define GetOpenFileNameA              (LOAD_IF_NEEDED(szComDlg32, ComDlg32Procs, &hComDlg32),\
                                       (*ComDlg32Procs[0].Address))
#endif

#ifdef UNICODE
/* This assumes that WNetGetUniversalName will always be the first to be called.
 */
#define WNetGetUniversalNameW         (LOAD_IF_NEEDED(szMPR, MPRProcs, &hMPR),   \
                                       (*MPRProcs[0].Address))
#define WNetGetConnectionW            (*MPRProcs[1].Address)
#define WNetGetLastErrorW             (*MPRProcs[2].Address)
#else
#define WNetGetUniversalNameA         (LOAD_IF_NEEDED(szMPR, MPRProcs, &hMPR),   \
                                       (*MPRProcs[0].Address))
#define WNetGetConnectionA            (*MPRProcs[1].Address)
#define WNetGetLastErrorA             (*MPRProcs[2].Address)
#endif

/* OleInitialize must always be called before before any of the
 * other APIs.
 */
#define CLSIDFromProgID               (*OLE32Procs[0].Address)
#define CoCreateInstance              (*OLE32Procs[1].Address)
#define CoDisconnectObject            (*OLE32Procs[2].Address)
#define CoGetMalloc                   (*OLE32Procs[3].Address)
#define CoRegisterClassObject         (*OLE32Procs[4].Address)
#define CoRevokeClassObject           (*OLE32Procs[5].Address)
#define CreateDataAdviseHolder        (*OLE32Procs[6].Address)
#define CreateFileMoniker             (*OLE32Procs[7].Address)
#define CreateOleAdviseHolder         (*OLE32Procs[8].Address)
#define DoDragDrop                    (*OLE32Procs[9].Address)
#define IsAccelerator                 (*OLE32Procs[10].Address)
#define OleCreateMenuDescriptor       (HOLEMENU)(*OLE32Procs[11].Address)
#define OleDestroyMenuDescriptor      (*OLE32Procs[12].Address)
#define OleDuplicateData              (HANDLE)(*OLE32Procs[13].Address)
#define OleFlushClipboard             (*OLE32Procs[14].Address)
#define OleGetClipboard               (*OLE32Procs[15].Address)
#define OleInitialize                 (LOAD_IF_NEEDED(szOLE32, OLE32Procs, &hOLE32),    \
                                       (*OLE32Procs[16].Address))
#define OleIsCurrentClipboard         (*OLE32Procs[17].Address)
#define OleSetClipboard               (*OLE32Procs[18].Address)
#define OleTranslateAccelerator       (*OLE32Procs[19].Address)
#define OleUninitialize               (*OLE32Procs[20].Address)
#define StgCreateDocfile              (*OLE32Procs[21].Address)
#define WriteClassStg                 (*OLE32Procs[22].Address)
#define WriteFmtUserTypeStg           (*OLE32Procs[23].Address)
#ifndef IsEqualGUID
#define IsEqualGUID                   (*OLE32Procs[24].Address)
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\dynalink.c ===
/*-----------------------------------------------------------------------------+
| DYNALINK.H                                                                   |
|                                                                              |
| (C) Copyright Microsoft Corporation 1994.  All rights reserved.              |
|                                                                              |
| This file contains static PROC_INFO structures listing APIs called in each   |
| dynamically linked DLL.                                                      |
|                                                                              |
|                                                                              |
| Revision History                                                             |
|    July 1994 Andrew Bell created                                             |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include "mplayer.h"

TCHAR szComDlg32[] = TEXT("ComDlg32");
TCHAR szMPR[]      = TEXT("MPR");
TCHAR szOLE32[]    = TEXT("OLE32");

HMODULE hComDlg32;
HMODULE hMPR;
HMODULE hOLE32;

PROC_INFO ComDlg32Procs[] =
{
#ifdef UNICODE
    "GetOpenFileNameW",         0,
#else
    "GetOpenFileNameA",         0,
#endif
    NULL,                       0
};

PROC_INFO MPRProcs[] =
{
#ifdef UNICODE
    "WNetGetUniversalNameW",    0,
    "WNetGetConnectionW",       0,
    "WNetGetLastErrorW",        0,
#else
    "WNetGetUniversalNameA",    0,
    "WNetGetConnectionA",       0,
    "WNetGetLastErrorA",        0,
#endif
    NULL,                       0
};

PROC_INFO OLE32Procs[] =
{
    "CLSIDFromProgID",          0,
    "CoCreateInstance",         0,
    "CoDisconnectObject",       0,
    "CoGetMalloc",              0,
    "CoRegisterClassObject",    0,
    "CoRevokeClassObject",      0,
    "CreateDataAdviseHolder",   0,
    "CreateFileMoniker",        0,
    "CreateOleAdviseHolder",    0,
    "DoDragDrop",               0,
    "IsAccelerator",            0,
    "OleCreateMenuDescriptor",  0,
    "OleDestroyMenuDescriptor", 0,
    "OleDuplicateData",         0,
    "OleFlushClipboard",        0,
    "OleGetClipboard",          0,
    "OleInitialize",            0,
    "OleIsCurrentClipboard",    0,
    "OleSetClipboard",          0,
    "OleTranslateAccelerator",  0,
    "OleUninitialize",          0,
    "StgCreateDocfile",         0,
    "WriteClassStg",            0,
    "WriteFmtUserTypeStg",      0,
#ifndef IsEqualGUID
    /* This is now a macro on Daytona!
     */
    "IsEqualGUID",              0,
#endif
    NULL,                       0
};


BOOL LoadLibraryAndProcs(LPTSTR pLibrary, PPROC_INFO pProcInfo, HMODULE *phLibrary)
{
    HMODULE    hLibrary;
    PPROC_INFO p;

#ifdef DEBUG
    if (PROCS_LOADED(pProcInfo))
    {
        DPF0("Attempt to load %s when already loaded\n", pLibrary);
        return TRUE;
    }
#endif

    hLibrary = LoadLibrary(pLibrary);

    if (hLibrary == NULL)
    {
        Error1(ghwndApp, IDS_CANTLOADLIB, pLibrary);
        ExitProcess(0);
    }

    p = pProcInfo;

    while (p->Name)
    {
        p->Address = GetProcAddress(hLibrary, p->Name);

        if (p->Address == NULL)
        {
            Error2(ghwndApp, IDS_CANTFINDPROC, p->Name, pLibrary);
            ExitProcess(0);
        }

        p++;
    }

    *phLibrary = hLibrary;

    return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\errprop.h ===
/*-----------------------------------------------------------------------------+
| ERRORPROP.H                                                                  |
|                                                                              |
| Interactive error propagation bitmap enhancement program.                    |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#define MAXPROP     16
#define MAXMULT     64

typedef struct {
    short   GrayThresh;
    short   LoThresh;
    short   HiThresh;
    short   Prop;
    short   Mult[3];
} ERRPROPPARAMS;

typedef ERRPROPPARAMS NEAR *PERRPROPPARAMS;

int  SetDIBitsErrProp(HDC hdc,HBITMAP hbm,WORD nStart,WORD nScans,LPBYTE lpBits,LPBITMAPINFO lpbi,WORD wUsage);
void SetErrPropParams(PERRPROPPARAMS pErrProp);
void GetErrPropParams(PERRPROPPARAMS pErrProp);

extern void FAR PASCAL BltProp(LPBITMAPINFOHEADER lpbiSrc, LPBYTE pbSrc, UINT SrcX, UINT SrcY, UINT SrcXE, UINT SrcYE,
                               LPBITMAPINFOHEADER lpbiDst, LPBYTE pbDst, UINT DstX, UINT DstY);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\errorbox.c ===
/*-----------------------------------------------------------------------------+
| ERRORBOX.C                                                                   |
|                                                                              |
| Routines for dealing with Resource-string based messages                     |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
| 15-Oct-1992 LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>           // needed for va_list stuff
#include <stdarg.h>          // needed for va_list stuff

#include "mplayer.h"

/*
 * @doc    INTERNAL
 *
 * @func short | ErrorResBox | This function displays a message box using
 * program resource error strings.
 *
 * @parm    HWND | hwnd | Specifies the message box parent window.
 *
 * @parm    HANDLE | hInst | Specifies the instance handle of the module
 * that contains the resource strings specified by <p idAppName> and
 * <p idErrorStr>.  If this value is NULL, the instance handle is
 * obtained from <p hwnd> (in which case <p hwnd> may not be NULL).
 *
 * @parm        WORD | flags | Specifies message box types controlling the
 * message box appearance.  All message box types valid for <f MessageBox> are
 * valid.
 *
 * @parm    WORD | idAppName | Specifies the resource ID of a string that
 * is to be used as the message box caption.
 *
 * @parm    WORD | idErrorStr | Specifies the resource ID of a error
 * message format string.  This string is of the style passed to
 * <f wsprintf>, containing the standard C argument formatting
 * characters.  Any procedure parameters following <p idErrorStr> will
 * be taken as arguments for this format string.
 *
 * @parm    arguments | [ arguments, ... ] | Specifies additional
 * arguments corresponding to the format specification given by
 * <p idErrorStr>.  All string arguments must be FAR pointers.
 *
 * @rdesc    Returns the result of the call to <f MessageBox>.  If an
 * error occurs, returns zero.
 *
 * @comm    This is a variable arguments function, the parameters after
 * <p idErrorStr> being taken for arguments to the <f printf> format
 * string specified by <p idErrorStr>.  The string resources specified
 * by <p idAppName> and <p idErrorStr> must be loadable using the
 * instance handle <p hInst>.  If the strings cannot be
 * loaded, or <p hwnd> is not valid, the function will fail and return
 * zero.
 *
 */
#define STRING_SIZE 256

void PositionMsgID(PTSTR szMsg, HANDLE hInst, UINT iErr)
{
    PTSTR psz;
    TCHAR szMplayerMsgID[16];
    TCHAR szTmp[STRING_SIZE];
    TCHAR szFmt[STRING_SIZE];

    if (!LoadString(hInst, IDS_MSGFORMAT, szFmt, STRING_SIZE))
        	return;
    if (!iErr)
    {
        for (psz = szMsg; psz && *psz && *psz != TEXT(' '); psz++)
    	    ;
	if (*psz == TEXT(' '))
	{
	    *psz++ = TEXT('\0');
	    wsprintf((LPTSTR)szTmp, (LPTSTR)szFmt, (LPTSTR)psz, (LPTSTR)szMsg);
	}
	else
	    return;
    }
    else
    {
    	wsprintf((LPTSTR)szMplayerMsgID, TEXT("MPLAYER%3.3u"), iErr);
    	wsprintf((LPTSTR)szTmp, (LPTSTR)szFmt, (LPTSTR)szMsg, (LPTSTR)szMplayerMsgID);
    }

    lstrcpy((LPTSTR)szMsg, (LPTSTR)szTmp);
}

short FAR cdecl ErrorResBox(HWND hwnd, HANDLE hInst, UINT flags,
            UINT idAppName, UINT idErrorStr, ...)
{
    TCHAR       sz[STRING_SIZE];
    TCHAR       szFmt[STRING_SIZE];
    UINT        w;
    va_list va;

    /* We're going away... bringing a box up will crash */
    if (gfInClose)
	return 0;

    if (hInst == NULL) {
        if (hwnd == NULL)
            hInst = ghInst;
        else
            hInst = GETHWNDINSTANCE(hwnd);
    }

    w = 0;

    if (!sz || !szFmt)
        goto ExitError;    // no mem, get out

    if (!LOADSTRINGFROM(hInst, idErrorStr, szFmt))
        goto ExitError;

    va_start(va, idErrorStr);
    wvsprintf(sz, szFmt, va);
    va_end(va);

    if (flags == MB_ERROR)
        if (idErrorStr == IDS_DEVICEERROR)
            PositionMsgID(sz, hInst, 0);
        else
            PositionMsgID(sz, hInst, idErrorStr);

    if (!LOADSTRINGFROM(hInst, idAppName, szFmt))
            goto ExitError;

    if (gfErrorBox) {
            DPF("*** \n");
            DPF("*** NESTED ERROR: '%"DTS"'\n", (LPTSTR)sz);
            DPF("*** \n");
            return 0;
    }

//  BlockServer();
    gfErrorBox++;

    /* Don't own this error box if we are not visible... eg. PowerPoint will
       hard crash.                                 */
    if (!IsWindowVisible(ghwndApp) || gfPlayingInPlace) {
        DPF("Bring error up as SYSTEMMODAL because PowerPig crashes in slide show\n");
        hwnd = NULL;
        flags |= MB_SYSTEMMODAL;
    }

    w = MessageBox(hwnd, sz, szFmt,
    flags);
    gfErrorBox--;
//  UnblockServer();

    if (gfErrorDeath) {
            DPF("*** Error box is gone ok to destroy window\n");
            PostMessage(ghwndApp, gfErrorDeath, 0, 0);
    }

ExitError:

    return (short)w;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\ctrls.h ===
#define TOOLGROW        8                // power of 2

#define IDC_TOOLBAR   189                // wParam sent to Parent

//
//  Init routine, will register the various classes.
//
BOOL FAR PASCAL ControlInit (HANDLE hInst);
void FAR PASCAL ControlCleanup (void);


extern HBRUSH hbrGray;
extern HBRUSH hbrButtonFace;
extern HBRUSH hbrButtonShadow;
extern HBRUSH hbrButtonText;
extern HBRUSH hbrButtonHighLight;
extern HBRUSH hbrWindowFrame;
extern HBRUSH hbrWindowColour;

extern DWORD  rgbButtonHighLight;
extern DWORD  rgbButtonFocus;
extern DWORD  rgbButtonFace;
extern DWORD  rgbButtonText;
extern DWORD  rgbButtonShadow;
extern DWORD  rgbWindowFrame;
extern DWORD  rgbWindowColour;
#if 0
extern HBITMAP hbTBMain;
extern HBITMAP hbTBMark;
extern HBITMAP hbTBArrows;
#endif



#define TB_FIRST            -1
#define TB_LAST             -2

#define BTN_PLAY            0
#define BTN_PAUSE           1
#define BTN_STOP            2
#define BTN_EJECT           3
#define BTN_HOME            4
#define BTN_RWD             5
#define BTN_FWD             6
#define BTN_END             7
#define BTN_SEP             8
#define TB_NUM_BMPS         9
#define TB_NUM_BTNS         9


#define ARROW_PREV          0
#define ARROW_NEXT          1
#define ARROW_NUM_BMPS      3
#define ARROW_NUM_BTNS      2

#define BTN_MARKIN          0
#define BTN_MARKOUT         1
#define MARK_NUM_BMPS       2
#define MARK_NUM_BTNS       2

#define BTNST_GRAYED        0
#define BTNST_UP            1
#define BTNST_DOWN          2

#define TBINDEX_MAIN        0
#define TBINDEX_MARK        1
#define TBINDEX_ARROWS      2


/* bitmap resources */
#define IDR_TOOLBAR         101
#define IDR_ARROWS          102
#define IDR_MARK            103


#define IDT_TBMAINCID       301
#define IDT_TBMARKCID       302
#define IDT_TBARROWSCID     303
#define IDT_STATUSWINDOWCID 304

#define IDT_PLAY                501
#define IDT_PAUSE               502
#define IDT_STOP                503
#define IDT_EJECT               504
#define IDT_HOME                505
#define IDT_RWD                 506
#define IDT_FWD                 507
#define IDT_END                 508
#define IDT_MARKIN              509
#define IDT_MARKOUT             510
#define IDT_ARROWPREV           511
#define IDT_ARROWNEXT           512

#define MSEC_BUTTONREPEAT   200        // milliseconds for auto-repeat
#define REPEAT_ID           200

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\dlgs.c ===
/*-----------------------------------------------------------------------------+
| DLGS.C                                                                       |
|                                                                              |
| Routines to handle selection range display                                   |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

//#undef NOSCROLL        // SB_* and scrolling routines
//#undef NOWINOFFSETS    // GWL_*, GCL_*, associated routines
//#undef NOCOLOR         // color stuff
//#include <string.h>
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include "mplayer.h"
#include "stdlib.h"

extern    UINT    gwCurScale;

TCHAR aszHelpFile[] = TEXT("MPLAYER.HLP");

/*
 * FUNCTION PROTOTYPES
 */
INT_PTR FAR PASCAL _EXPORT setselDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR FAR PASCAL _EXPORT optionsDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR FAR PASCAL _EXPORT mciDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

/*--------------------------------------------------------------+
| ******************* PUBLIC FUNCTIONS ************************ |
+--------------------------------------------------------------*/
/*--------------------------------------------------------------+
| setselDialog - bring up the dialog for Set Selection          |
|                                                               |
+--------------------------------------------------------------*/
BOOL FAR PASCAL setselDialog(HWND hwnd)
{
    FARPROC fpfn;

    frameboxInit(ghInst, ghInstPrev);

    fpfn = MakeProcInstance((FARPROC)setselDlgProc, ghInst);

    DialogBox(ghInst, TEXT("SetSelection"), hwnd, (DLGPROC)fpfn);

    return TRUE;                // should we check return value?
}

static BOOL    sfNumLastChosen;
static BOOL    sfInUpdate = FALSE;
/*--------------------------------------------------------------+
| setselDlgProc - dialog procedure for Set Selection dialog     |
|                                                               |
+--------------------------------------------------------------*/
INT_PTR PASCAL _EXPORT setselDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int     iItem;
    DWORD_PTR   fr, fr2, frIn, frOut, frMarkIn, frMarkOut, frCurrent;
    TCHAR   ach[80];
    LPTSTR  lpsz = (LPTSTR)ach;
    static int aKeyWordIds[] = {
				   IDC_EDITALL,  IDH_SELECT_ALL,
				   IDC_EDITNONE, IDH_SELECT_NONE,
				   IDC_EDITSOME, IDH_SELECT_FROM,
				   IDC_EDITFROM, IDH_SELECT_FROM,
				   IDC_ETTEXT,   IDH_SELECT_FROM,
				   IDC_EDITTO,   IDH_SELECT_FROM,
				   IDC_ESTEXT,   IDH_SELECT_FROM,
				   IDC_EDITNUM,  IDH_SELECT_FROM,
				   0, 0
			       };

    frMarkIn = frIn = SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0);
    frMarkOut = frOut = SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0);
    frCurrent = SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0);

    switch(msg){
	case WM_INITDIALOG:
	    if (gwCurScale == ID_TIME) {
		LOADSTRING(IDS_TIMEMODE, ach);
		SetWindowText(hwnd, lpsz);
	    } else if (gwCurScale == ID_FRAMES) {
		LOADSTRING(IDS_FRAMEMODE, ach);
		SetWindowText(hwnd, lpsz);
	    } else {
		LOADSTRING(IDS_TRACKMODE, ach);
		SetWindowText(hwnd, lpsz);
	    }

	/* Always put something here - if no selection, use the cur frame */
	    if (frMarkIn == -1 || frMarkOut == -1) {
		SetDlgItemInt(hwnd, IDC_EDITFROM, (UINT)frCurrent, FALSE);
		SetDlgItemInt(hwnd, IDC_EDITTO, (UINT)frCurrent, FALSE);
		SetDlgItemInt(hwnd, IDC_EDITNUM, 0, FALSE);
	    } else {
		SetDlgItemInt(hwnd, IDC_EDITFROM, (UINT)frMarkIn, FALSE);
		SetDlgItemInt(hwnd, IDC_EDITTO, (UINT)frMarkOut, FALSE);
		SetDlgItemInt(hwnd, IDC_EDITNUM, (UINT)(frMarkOut - frMarkIn), FALSE);
	    }

	    if (frMarkIn == -1 || frMarkOut == -1) {
		/* turn on the NONE radio button */
		CheckRadioButton(hwnd, IDC_EDITALL, IDC_EDITNONE, IDC_EDITNONE);
	    } else if(frMarkIn == gdwMediaStart &&
		frMarkOut == gdwMediaStart + gdwMediaLength){
		/* turn on the ALL button, it is all selected */
		CheckRadioButton(hwnd, IDC_EDITALL, IDC_EDITNONE, IDC_EDITALL);
	    } else {
		/* turn on the From/To portion */
		CheckRadioButton(hwnd, IDC_EDITALL, IDC_EDITNONE, IDC_EDITSOME);
	    }

	    return TRUE;

	case WM_CONTEXTMENU:
	    {
		int i;
		for (i = 0; aKeyWordIds[i]; i+=2)
		    if (aKeyWordIds[i] == GetDlgCtrlID((HWND)wParam))
			break;
		if (aKeyWordIds[i] == 0)
		    break;

		WinHelp((HWND)wParam, aszHelpFile, HELP_CONTEXTMENU, (UINT_PTR)(LPVOID)aKeyWordIds);
		return TRUE;
	    }

	case WM_HELP:
	    {
		int i;

		for (i = 0; aKeyWordIds[i]; i+=2)
		    if (aKeyWordIds[i] == ((LPHELPINFO)lParam)->iCtrlId)
			break;
		if (aKeyWordIds[i] == 0)
		    break;

		WinHelp(((LPHELPINFO)lParam)->hItemHandle, aszHelpFile,
			HELP_WM_HELP, (UINT_PTR)(LPVOID)aKeyWordIds);
		return TRUE;
	    }

	case WM_COMMAND:
	    switch(LOWORD(wParam)){
		WORD Code;
		BOOL OK;

		case IDOK:
		    /* We hit this AFTER we press OK on the selection box */

		    /* Make sure box we're editing loses focus before we */
		    /* execute, so values will be set properly.          */
		    SetFocus(GetDlgItem(hwnd, IDOK));
		    if (IsDlgButtonChecked(hwnd, IDC_EDITALL)) {
			/* this is the All: case */
			frIn = gdwMediaStart;
			frOut = gdwMediaStart + gdwMediaLength;
		    } else if (IsDlgButtonChecked(hwnd, IDC_EDITNONE)){
			/* this is the None: case */
			frIn = frOut = (DWORD)(-1);
		    } else {
			/* this is the From: To: case */
			iItem = 0;

			frIn = GetDlgItemInt(hwnd, IDC_EDITFROM, &OK, FALSE);

			if (!OK)
			    iItem = IDC_EDITFROM;    // we misbehaved
			else {

			    frOut = GetDlgItemInt(hwnd, IDC_EDITTO, &OK, FALSE);

			    if (!OK)
				iItem = IDC_EDITTO;
			}
			if ((!OK)
			    || (frOut < frIn)
			    || ((long)frIn < (long)gdwMediaStart)
			    || (frOut > gdwMediaStart + gdwMediaLength)) {
			    if (!iItem && (long)frIn < (long)gdwMediaStart)
				iItem = IDC_EDITFROM; // who misbehaved?
			    else if (!iItem)
				iItem = IDC_EDITTO;
//                   Don't beep -- Lose focus message already beeped
//                          MessageBeep(MB_ICONEXCLAMATION);
		    /* Illegal values, display msg box  */
			    ErrorResBox(hwnd, ghInst,
					MB_ICONEXCLAMATION | MB_OK,
					IDS_APPNAME, IDS_FRAMERANGE);
		    /* Prevent box from ending */
		    /* select offending value */
			    SetFocus(GetDlgItem(hwnd, iItem));

			    SendMessage(GetDlgItem(hwnd, iItem),
					EM_SETSEL, 0, (LPARAM)-1);

			    return TRUE;
			}
		    }
		    SendMessage(ghwndTrackbar, TBM_SETSELSTART, (WPARAM)FALSE, frIn);
		    SendMessage(ghwndTrackbar, TBM_SETSELEND, (WPARAM)TRUE, frOut);
		    DirtyObject(TRUE);
		    EndDialog(hwnd, TRUE);
		    break;

		case IDCANCEL:
		    EndDialog(hwnd, FALSE);
		    break;

		case IDC_EDITALL:
		    CheckRadioButton(hwnd, IDC_EDITALL,
				     IDC_EDITNONE, IDC_EDITALL);
		    break;

		case IDC_EDITNONE:
		    CheckRadioButton(hwnd, IDC_EDITALL,
				     IDC_EDITNONE, IDC_EDITNONE);
		    break;

		case IDC_EDITSOME:
		    CheckRadioButton(hwnd, IDC_EDITALL,
				    IDC_EDITNONE, IDC_EDITSOME);

		    /* put the focus on the FROM box */
		    SetFocus(GetDlgItem(hwnd, IDC_EDITFROM));
		    break;

		case IDC_EDITNUM:
		    /* turn on the FROM box if it isn't */
		    Code = GET_WM_COMMAND_CMD(wParam, lParam);

		    if (!IsDlgButtonChecked(hwnd, IDC_EDITSOME))
		    {
			SetFocus(GetDlgItem(hwnd, IDC_EDITSOME));
			CheckRadioButton(hwnd, IDC_EDITALL,
					IDC_EDITNONE, IDC_EDITSOME);
		    }

		    if (!sfInUpdate && Code == EN_KILLFOCUS) {
			sfNumLastChosen = TRUE;
			goto AdjustSomething;
		    }
		    break;

		case IDC_EDITTO:
		    /* turn on the FROM box if it isn't */
		    Code = GET_WM_COMMAND_CMD(wParam, lParam);

		    if (!IsDlgButtonChecked(hwnd, IDC_EDITSOME))
		    {
			SetFocus(GetDlgItem(hwnd, IDC_EDITSOME));
			CheckRadioButton(hwnd, IDC_EDITALL,
					IDC_EDITNONE, IDC_EDITSOME);
			
		    }

		    if (!sfInUpdate && Code == EN_KILLFOCUS) {
			sfNumLastChosen = FALSE;
			goto AdjustSomething;
		    }
		    break;

		case IDC_EDITFROM:
		    /* turn on the FROM box if it isn't */
		    Code = GET_WM_COMMAND_CMD(wParam, lParam);

		    if (!IsDlgButtonChecked(hwnd, IDC_EDITSOME))
		    {
			CheckRadioButton(hwnd, IDC_EDITALL,
					IDC_EDITNONE, IDC_EDITSOME);
			if (GetFocus() != GetDlgItem(hwnd, IDC_EDITSOME))
				SetFocus(GetDlgItem(hwnd, IDC_EDITSOME));

		    }

		    if (!sfInUpdate && Code == EN_KILLFOCUS) {
			sfNumLastChosen = FALSE;
			goto AdjustSomething;
		    }
		    break;

AdjustSomething:
		    sfInUpdate = TRUE;

		    fr = GetDlgItemInt(hwnd, IDC_EDITFROM, &OK, FALSE);

		    if (!OK)
			MessageBeep(MB_ICONEXCLAMATION);
		    else {
			if ((long)fr < (long)gdwMediaStart) {
			    MessageBeep(MB_ICONEXCLAMATION);
			    fr = gdwMediaStart;
			}
			if (fr > gdwMediaStart + gdwMediaLength) {
			    MessageBeep(MB_ICONEXCLAMATION);
			    fr = gdwMediaStart + gdwMediaLength;
			}

		    // We have to do this in time format, or if fr changed

			SetDlgItemInt(hwnd, IDC_EDITFROM, (UINT)fr, FALSE);

			if (sfNumLastChosen) {
			    /* They changed the number of frames last, */
			    /* so keep it constant.                    */
AdjustTo:
			    fr2 = GetDlgItemInt(hwnd, IDC_EDITNUM, &OK, FALSE);

			    if (!OK)
				MessageBeep(MB_ICONEXCLAMATION);
			    else {
				if (fr + fr2 > gdwMediaStart + gdwMediaLength) {
				    MessageBeep(MB_ICONEXCLAMATION);
				    fr2 = gdwMediaStart + gdwMediaLength - fr;
				}

//                               if (fr2 < 0)
//                                   fr2 = 0;

			// We have to do this in time format, or if fr changed

				SetDlgItemInt(hwnd, IDC_EDITNUM, (UINT)fr2, FALSE);
				SetDlgItemInt(hwnd, IDC_EDITTO, (UINT)(fr + fr2), FALSE);
			    }
			} else {
			    /* They changed a frame number last, */
			    /* so vary the number of frames      */

			    fr2 = GetDlgItemInt(hwnd, IDC_EDITTO, &OK, FALSE);

			    if (!OK)
				MessageBeep(MB_ICONEXCLAMATION);
			    else {
				if (fr2 < fr) {
				/* Set TO = FROM */
				SetDlgItemInt(hwnd, IDC_EDITNUM, 0, FALSE);
				goto AdjustTo;
			    }

			    if (fr2 > gdwMediaStart + gdwMediaLength) {
				MessageBeep(MB_ICONEXCLAMATION);
				fr2 = gdwMediaStart + gdwMediaLength;
			    }

			    SetDlgItemInt(hwnd, IDC_EDITNUM, (UINT)(fr2 - fr), FALSE);

			    // must redraw for time mode or if fr2 changed
			    SetDlgItemInt(hwnd, IDC_EDITTO, (UINT)fr2, FALSE);
			}
		    }
		}

		sfInUpdate = FALSE;
		return TRUE;

		break;
	    }
	    break;

	}
	return FALSE;
}

/*--------------------------------------------------------------+
| optionsDialog - bring up the dialog for Options               |
|                                                               |
+--------------------------------------------------------------*/
BOOL FAR PASCAL optionsDialog(HWND hwnd)
{
    FARPROC fpfn;
#if 0
    DWORD   ThreadId;
    DWORD   WindowThreadId;
#endif

    fpfn = MakeProcInstance((FARPROC)optionsDlgProc, ghInst);

#if 0
    Problem:

    When in-place editing, bring up the Options (or other) dialog,
    then bring another app into the foreground.  If you now click on
    our container, you just get a beep.  You can get back using the
    Task List.

    I can't get it to work with AttachThreadInput, but I'm not even
    sure that this should be the server's responsibility.  It's the
    container that's receiving the mouse clicks.

    I haven't had any word from the OLE guys on this question.

    if (gfOle2IPEditing)
    {
	ThreadId = GetCurrentThreadId( );
	WindowThreadId = GetWindowThreadProcessId(ghwndCntr, NULL);
	AttachThreadInput(WindowThreadId, ThreadId, TRUE);
    }
#endif

    DialogBox(ghInst, TEXT("Options"), hwnd, (DLGPROC)fpfn);

#if 0
    if (gfOle2IPEditing)
	AttachThreadInput(ThreadId, WindowThreadId, FALSE);
#endif

    return TRUE;    // should we check return value?
}

/*--------------------------------------------------------------+
| optionsDlgProc - dialog procedure for Options dialog          |
|                                                               |
+--------------------------------------------------------------*/
INT_PTR FAR PASCAL _EXPORT optionsDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    UINT w;
    HDC  hdc;
    static int aKeyWordIds[] =
    {
	OPT_AUTORWD,     IDH_OPT_AUTO,
	OPT_AUTOREP,     IDH_OPT_REPEAT,
	IDC_OLEOBJECT,   IDH_OPT_CAPTCONTROL,
	OPT_BAR,         IDH_OPT_CAPTCONTROL,
	OPT_BORDER,      IDH_OPT_BORDER,
	OPT_PLAY,        IDH_OPT_PLAYCLIENT,
	OPT_DITHER,      IDH_OPT_DITHER,
	IDC_CAPTIONTEXT, IDH_OPT_CAPTION,
	IDC_TITLETEXT,   IDH_OPT_CAPTION,
	0  , 0
    };

    switch(msg){
	case WM_INITDIALOG:
	    /* Take advantage of the fact that the button IDS are the */
	    /* same as the bit fields.                                */
	    for (w = OPT_FIRST; w <= OPT_LAST; w <<= 1)
		CheckDlgButton(hwnd, w, gwOptions & w);

	    /* Enable and Fill the Title Text */
	    /* limit this box to CAPTION_LEN chars of input */
	    SendMessage(GetDlgItem(hwnd, IDC_TITLETEXT), EM_LIMITTEXT,
			(WPARAM)CAPTION_LEN, 0L);
	    SendMessage(hwnd, WM_COMMAND, (WPARAM)OPT_BAR, 0L);

	    hdc = GetDC(NULL);
	    if (!(GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) ||
		!(gwDeviceType & DTMCI_CANWINDOW)) {
		CheckDlgButton(hwnd, OPT_DITHER, FALSE);
		EnableWindow(GetDlgItem(hwnd, OPT_DITHER), FALSE);

#if 0
		CheckDlgButton(hwnd, OPT_USEPALETTE, FALSE);
		EnableWindow(GetDlgItem(hwnd, OPT_USEPALETTE), FALSE);
#endif
	    }
	    ReleaseDC(NULL, hdc);
	    return TRUE;

	case WM_CONTEXTMENU:
	    {
		WinHelp((HWND)wParam, aszHelpFile, HELP_CONTEXTMENU, (UINT_PTR)(LPVOID)aKeyWordIds);
		return TRUE;
	    }
	case WM_HELP:
	    {
		int i;

		for (i = 0; aKeyWordIds[i]; i+=2)
		    if (aKeyWordIds[i] == ((LPHELPINFO)lParam)->iCtrlId)
			break;
		
		WinHelp(((LPHELPINFO)lParam)->hItemHandle, aszHelpFile,
			HELP_WM_HELP, (UINT_PTR)(LPVOID)aKeyWordIds);
		return TRUE;
	    }

	case WM_COMMAND:
	    switch(LOWORD(wParam)){
		BOOL f;

		case IDOK:
		    /* Change auto-repeat on the fly:
		     * If the auto-repeat option has changed
		     * and we're playing right now, toggle
		     * the appropriate global option and call
		     * PlayMCI().  This will update things.
		     * Note that if we are currently playing
		     * a selection, this causes the whole clip
		     * to be played.  Is there any way round this?
		     */
		    if ((gwStatus == MCI_MODE_PLAY)
		       &&(((gwOptions & OPT_AUTOREP) == OPT_AUTOREP)
			 != (BOOL)IsDlgButtonChecked(hwnd, OPT_AUTOREP)))
		    {
			gwOptions ^= OPT_AUTOREP;
			PlayMCI(0,0);
		    }

		    gwOptions &= OPT_SCALE;    // keep the Scale Mode

		    /* Take advantage of the fact that the button IDS are the */
		    /* same as the bit fields.                                */
		    for (w = OPT_FIRST; w <= OPT_LAST; w <<= 1)
			if (IsDlgButtonChecked(hwnd, w))
			    gwOptions |= w;

		    if (IsDlgButtonChecked(hwnd, OPT_BAR))
		    {
			GetWindowText(GetDlgItem(hwnd, IDC_TITLETEXT),
				      gachCaption, CHAR_COUNT(gachCaption));

			if (gachCaption[0])
			    gwOptions |= OPT_TITLE;
			else
			    gwOptions &= ~OPT_TITLE;
		    }

		    DirtyObject(FALSE);
		    EndDialog(hwnd, TRUE);
		    break;

		case IDCANCEL:
		    EndDialog(hwnd, FALSE);
		    break;

		case OPT_BAR:
		    f = IsDlgButtonChecked(hwnd, OPT_BAR);
		    EnableWindow(GetDlgItem(hwnd, IDC_CAPTIONTEXT), f);
		    EnableWindow(GetDlgItem(hwnd, IDC_TITLETEXT), f);

		    if(f) {
			SetWindowText(GetDlgItem(hwnd, IDC_TITLETEXT), gachCaption);
		    } else {
			GetWindowText(GetDlgItem(hwnd, IDC_TITLETEXT),
				      gachCaption, CHAR_COUNT(gachCaption));
			SetWindowText(GetDlgItem(hwnd, IDC_TITLETEXT), TEXT(""));
		    }

		    break;
	    }
    }
    return FALSE;
}


/*--------------------------------------------------------------+
| mciDialog - bring up the dialog for MCI Send Command          |
|                                                               |
+--------------------------------------------------------------*/
BOOL FAR PASCAL mciDialog(HWND hwnd)
{
    FARPROC fpfn;

    fpfn = MakeProcInstance((FARPROC)mciDlgProc, ghInst);
    DialogBox(ghInst, MAKEINTATOM(DLG_MCICOMMAND), hwnd, (DLGPROC)fpfn);

    return TRUE;    // should we check return value?
}


/* StripLeadingAndTrailingWhiteSpace
 *
 * Removes blanks at the beginning and end of the string.
 *
 * Parameters:
 *
 *     pIn - Pointer to the beginning of the string
 *
 *     InLen - Length of the input string.  If 0, the length will be checked.
 *
 *     pOutLen - Pointer to a buffer to receive the length of the output string.
 *
 * Return:
 *
 *     Pointer to the output string.
 *
 * Remarks:
 *
 *     If InLen == *pOutLen, the string has not changed.
 *
 *     This routine is destructive: all trailing white space is converted
 *     to NULLs.
 *
 *
 * Andrew Bell, 4 January 1995
 */
LPTSTR StripLeadingAndTrailingWhiteSpace(LPTSTR pIn, DWORD InLen, LPDWORD pOutLen)
{
    LPTSTR pOut = pIn;
    DWORD  Len = InLen;

    if (Len == 0)
	Len = lstrlen(pIn);

    /* Strip trailing blanks:
     */
    while ((Len > 0) && (pOut[Len - 1] == TEXT(' ')))
    {
	pOut[Len - 1] = TEXT('\0');
	Len--;
    }

    /* Strip leading blanks:
     */
    while ((Len > 0) && (*pOut == TEXT(' ')))
    {
	pOut++;
	Len--;
    }

    if (pOutLen)
	*pOutLen = Len;

    return pOut;
}


INT_PTR FAR PASCAL _EXPORT mciDlgProc(HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam)
{
    TCHAR   ach[MCI_STRING_LENGTH];
    UINT    w;
    DWORD   dw;
    LPTSTR  pStrip;
    DWORD   NewLen;

    switch (msg)
    {
	case WM_INITDIALOG:
	    SendDlgItemMessage(hwnd, IDC_MCICOMMAND, EM_LIMITTEXT, CHAR_COUNT(ach) -1, 0);
	    return TRUE;

	case WM_COMMAND:
	    switch (LOWORD(wParam))
	    {
		case IDOK:
		    w = GetDlgItemText(hwnd, IDC_MCICOMMAND, ach, CHAR_COUNT(ach));

		    /* Strip off any white space at the start of the command,
		     * otherwise we get an MCI error.  Remove it from the
		     * end also.
		     */
		    pStrip = StripLeadingAndTrailingWhiteSpace(ach, w, &NewLen);

		    if (w > NewLen)
		    {
			SetDlgItemText(hwnd, IDC_MCICOMMAND, pStrip);
			w = GetDlgItemText(hwnd, IDC_MCICOMMAND, ach, CHAR_COUNT(ach));
		    }

		    if (w == 0)
			break;

		    SendDlgItemMessage(hwnd, IDC_MCICOMMAND, EM_SETSEL, 0, (LPARAM)-1);

		    dw = SendStringMCI(ach, ach, CHAR_COUNT(ach));

		    if (dw != 0)
		    {
			mciGetErrorString(dw, ach, CHAR_COUNT(ach));
//                        Error1(hwnd, IDS_DEVICEERROR, (LPTSTR)ach);
		    }

		    SetDlgItemText(hwnd, IDC_RESULT, ach);

		    break;

		case IDCANCEL:
		    EndDialog(hwnd, FALSE);
		    break;
	    }
	    break;
    }

    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\doverb.c ===
/*---------------------------------------------------------------------------
|   DOVERB.C
|   This file is used to be called server.c in the OLE1 versions of MPlayer.
|   This file has the ReallyDoVerb function which is called by the the
|   OLE DoVerb method. This file also has some functions to do the
|   InPlace activation in OLE1 apps.
|
|   Modified for OLE2 By:   Vij Rajarajan (VijR)
+---------------------------------------------------------------------------*/
#define SERVERONLY
#include <windows.h>
#include <mmsystem.h>
#include <shellapi.h>

#undef _MAX_PATH             // ??? someone hacking?
#undef _MAX_DIR              // ??? someone hacking?
#undef _MAX_FNAME            // ??? someone hacking?
#undef _MAX_EXT              // ??? someone hacking?

#include "ctrls.h"
#include "mpole.h"
#include "mplayer.h"
#include "toolbar.h"
#include "ole2ui.h"

#define OLE_OK S_OK
#define NOVERB 1000

extern HANDLE   ghInst;
extern HWND ghwndFocus;     //  Who had focus when we went inactive
extern HWND     ghwndFocusSave;         // saved focus window
extern HOOKPROC fpMouseHook;            // Mouse hook proc address.

extern UINT     gwPlaybarHeight;        //tell playbar how tall to make
                                        //itself so it covers the title
DWORD           gdwPosition;
LONG            glCurrentVerb = NOVERB;
BOOL               gfBrokenLink = FALSE;
static BOOL     gfMouseUpSeen = FALSE;     // OK to close play in place?
static BOOL     gfKeyStateUpSeen = FALSE;  // OK to close play in place?
extern HMODULE  hMciOle;

/*
** These functions are exported from mciole32.dll.
**
*/
typedef BOOL (*LPINSTALLHOOK)( HWND, DWORD );
typedef BOOL (*LPREMOVEHOOK)( VOID );

LPINSTALLHOOK       fpInstallHook;
LPREMOVEHOOK        fpRemoveHook;
BOOL                fHookInstalled = FALSE;

char                aszInstallHook[]       = "InstallHook";
char                aszRemoveHook[]        = "RemoveHook";


/* Height of picture given to client to be pasted */
static UINT  gwPastedHeight;
static DWORD gwOldOptions;
static DWORD gwOldHeight;

TCHAR gachFile[_MAX_PATH];
static int   gerr;
static HWND  ghwndClient = NULL;
static RECT  grcClient;
BOOL   gfOle1Client = FALSE;

WNDPROC      gfnMCIWndProc;
HWND         ghwndSubclass;


BOOL    SkipInPlaceEdit = FALSE;     //TRUE if we are just reactivating
BOOL    gfSeenPBCloseMsg;            //TRUE if the subclasses PlayBack WIndow Proc
                                     //has seen the WM_CLOSE message
HWND    ghwndFocusSave;              //Who had the focus when we were activated.?

#define abs(x) ((x) < 0 ? -(x) : (x))
#ifndef GetWS
#define GetWS(hwnd)     GetWindowLongPtr(hwnd, GWL_STYLE)
#define PutWS(hwnd, f)  SetWindowLongPtr(hwnd, GWL_STYLE, f)
#define TestWS(hwnd,f)  (GetWS(hwnd) & f)
#define SetWS(hwnd, f)  PutWS(hwnd, GetWS(hwnd) | f)
#define ClrWS(hwnd, f)  PutWS(hwnd, GetWS(hwnd) & ~(f))
#endif

static  SZCODE aszAppName[]           = TEXT("MPlayer");


STATICFN BOOL FileExists(LPTSTR szFile, LPTSTR szFullName, int iLen);
STATICFN BOOL NetParseFile(LPTSTR szFile, LPTSTR szDrive, LPTSTR szPath);

HPALETTE FAR PASCAL CreateSystemPalette(void);
void TransferTools(HWND hwndToolWindow);

#ifdef DEBUG
BOOL ShowAppWindow(int nCmdShow)
{
    return ShowWindow(ghwndApp, nCmdShow);
}
#define SHOWAPPWINDOW(nCmdShow) ShowAppWindow(nCmdShow)
#else
#define SHOWAPPWINDOW(nCmdShow) ShowWindow(ghwndApp, nCmdShow)
#endif

/*************************************************************************
* DirtyObject(BOOL fDocStgChangeOnly) - mark the "object" dirty,
* ie has been changed.
*
* We set the gfDirty flag to TRUE and iff we are a embedded object tell
* the client we have changed by sending a SendDocMsg(OLE_CHANGED).
* fDocStgChangeOnly is TRUE if the change would affect the Embedding if there
* is one but not appearence of the object i.e. the Metafile.
* OLE_CHANGED message is sent only if fDocStgChangeOnly is FALSE;
***************************************************************************/
void DirtyObject(BOOL fDocStgChangeOnly)
{
    //
    // NOTE we want to send OLE_CHANGED even if selection has changed
    //

    if (gfOle2IPEditing && ((gwOptions & OPT_BAR) != (gwOldOptions &OPT_BAR)) && !fDocStgChangeOnly)
    {
        RECT rc;
        BOOL fCanWindow = gwDeviceType & DTMCI_CANWINDOW;

        if (fCanWindow)
        {
            GetWindowRect(ghwndApp, (LPRECT)&rc);
            OffsetRect((LPRECT)&rc, -rc.left, -rc.top);

            /* rc contains the coordinates of the current app window.
             * If we have a playbar, we must allow space for it:
             */
            if ((gwOptions & OPT_BAR) && !(gwOldOptions &OPT_BAR))
            {
                /* Add bar */
                Layout();
                gwPlaybarHeight = TOOLBAR_HEIGHT;
            }
            else if(!(gwOptions & OPT_BAR) && (gwOldOptions &OPT_BAR))
            {
                /* Remove bar */
                Layout();
                gwPlaybarHeight = 0;
            }
        }
        else
        {
            HBITMAP hbm;
            BITMAP  bm;

            GetWindowRect(ghwndIPHatch, (LPRECT)&rc);
            if (gwOptions & OPT_BAR)
                gwPlaybarHeight = TOOLBAR_HEIGHT;
            else
                gwPlaybarHeight = 0;

            hbm =   BitmapMCI();
            GetObject(hbm,sizeof(bm),&bm);
            rc.bottom = rc.top + bm.bmHeight;
            rc.right = rc.left + bm.bmWidth;
            DeleteObject(hbm);

            MapWindowPoints(NULL,ghwndCntr,(LPPOINT)&rc, (UINT)2);

            DPF("IOleInPlaceSite::OnPosRectChange %d, %d, %d, %d\n", rc);
            if (!gfInPPViewer)
                IOleInPlaceSite_OnPosRectChange(docMain.lpIpData->lpSite, &rc);
        }
    }

    if (gwOptions != gwOldOptions)
    {
        gwOldOptions = gwOptions;
        if (gfEmbeddedObject && !fDocStgChangeOnly)
            SendDocMsg(&docMain, OLE_CHANGED);
    }

    if (gfDirty /* IsObjectDirty() */)
        return;

    fDocChanged=gfDirty = TRUE;
    gfValidCaption = FALSE;
}


/**************************************************************************
 IsObjectDirty() - Object is dirty if the dirty flag is set or the selection
           has changed since we last cleaned or the Metafile has
           changed

***************************************************************************/
BOOL FAR PASCAL IsObjectDirty(void)
{
    // don't let anyone insert an empty mplayer into a document
    if (gwDeviceID == (UINT)0)
        return FALSE;

    return (gfDirty
           || glSelStart != (long)SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0L)
        || glSelEnd != (long)SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0L)

/// I don't see this.  This line results in the Update Object dialog coming
/// up when it shouldn't.  What has it got to do with metafiles?
/// ??? || gdwPosition != (DWORD)SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0L)

        );
}

/**************************************************************************
 CleanObject() - mark the "object" clean.
***************************************************************************/

void CleanObject(void)
{
    if (!IsObjectDirty())
        return;

    fDocChanged = gfDirty = FALSE;

    /* Reset selection globals so we can see if they changed */
    glSelStart = (long)SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0L);
    glSelEnd = (long)SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0L);
    gdwPosition = (DWORD)SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0L);

    gfValidCaption = FALSE;
}

/**************************************************************************
//## Just parses the play etc options in the embedded object
//## description string
***************************************************************************/
SCODE FAR PASCAL ParseOptions(LPSTR pOpt)
{
#ifdef UNICODE
    DWORD       OptLen;
#endif
    PTSTR       pT, pSave;
    int         c;

    if (pOpt == NULL || *pOpt == 0)
        return OLE_OK;

#ifdef UNICODE
    OptLen = ANSI_STRING_BYTE_COUNT( pOpt );

    pT = AllocMem( OptLen * sizeof( TCHAR ) );

    if (pT == NULL)
        return E_OUTOFMEMORY;

    MultiByteToWideChar( CP_ACP,
                         MB_PRECOMPOSED,
                         pOpt,
                         OptLen,
                         pT,
                         OptLen );
#else
    pT = pOpt;
#endif

    pSave = pT;                      // wasn't NULL terminated before

    for (c = 0; *pT && c < 5; pT++)  // change 1st 5 ','s to '\0'
    if (*pT == TEXT(','))
    {
        c++;
        *pT = TEXT('\0');
    }

    pT = pSave;                 // restore back to beginning

    pT += STRLEN(pT) + 1;      // skip over Device Name

    gwOptions = ATOI(pT);
    gwCurScale = (gwOptions & OPT_SCALE);

/* Can't set selection now because Media isn't initialized (UpdateMCI) */

    pT += STRLEN(pT) + 1;
    glSelStart = ATOL(pT);      // remember start of selection for later

    pT += STRLEN(pT) + 1;
    glSelEnd = ATOL(pT);        // remember end of selection for later

    pT += STRLEN(pT) + 1;
    // remember position in a global so we can Seek later!!
    gdwPosition = ATOL(pT);

/* Maybe there is the original height of the picture given to the client in */
/* here hidden in the Position string after a semicolon.                    */
/* Old versions of Mplayer didn't have any such thing.                      */
    for (; *pT && *pT != TEXT(';'); pT++);
    if (*pT == TEXT(';'))
    {
        pT++;
        gwPastedHeight = (UINT)ATOL(pT);
    }
    else
        gwPastedHeight = 0;

    pT += STRLEN(pT) + 1;
    lstrcpy(gachCaption, pT);

#ifdef UNICODE
    FreeMem( pSave, OptLen * sizeof( TCHAR ) );
#endif

    return OLE_OK;
}


/**************************************************************************
//## Used to find the parent window of the window handle passed till the
//## window handle is a top level handle
***************************************************************************/
HWND TopWindow(HWND hwnd)
{
    HWND hwndP;

    while ((hwndP = GetParent(hwnd)) != NULL)
        hwnd = hwndP;

    return hwnd;
}

/**************************************************************************
***************************************************************************/
void FAR PASCAL SetEmbeddedObjectFlag(BOOL flag)
{
    TCHAR ach[60];
    TCHAR achText[_MAX_PATH];

    gfEmbeddedObject = flag;
    srvrMain.fEmbedding = flag;

    if (!ghMenu)
        return;

    /*** First fix the Close/Update menu item ***/

    LOADSTRING(flag ? IDS_UPDATE : IDS_CLOSE, ach);
    if (flag)
    wsprintf(achText, ach, (LPTSTR)FileName(szClientDoc));
    else
        lstrcpy(achText, ach);

    /* Menu option will either say "Close" or "Update" (for embedded obj) */
    /* and for update, will have the doc name in the text.                */
    ModifyMenu(ghMenu, IDM_CLOSE, MF_BYCOMMAND, IDM_CLOSE, achText);

    /*** Now fix the Exit menu item ***/
    LOADSTRING(flag ? IDS_EXITRETURN : IDS_EXIT, ach);
    if (flag)
    wsprintf(achText, ach, (LPTSTR)FileName(szClientDoc));
    else
        lstrcpy(achText, ach);

    /* Menu option will either say "Close" or "Update" (for embedded obj) */
    /* and for update, will have the doc name in the text.                */
    ModifyMenu(ghMenu, IDM_EXIT, MF_BYCOMMAND, IDM_EXIT, achText);

    DrawMenuBar(ghwndApp);  /* Can't hurt... */
}


/**************************************************************************
//## MORE STUFF FOR PLAY IN PLACE, should disappear in OLE2.
//VIJR: Nope. Still needed for playing inplace in OLE1 clients.
***************************************************************************/
void PASCAL DinkWithWindowStyles(HWND hwnd, BOOL fRestore)
{
    #define MAX_DINK    80
    static  LONG_PTR    lStyleSave[MAX_DINK];
    static  HWND        hwndSave[MAX_DINK];
    static  int         nSave;
    int                 i;
    HWND                hwndT;
    RECT                rc, rcT;

    if (!TestWS(hwnd, WS_CHILD))
        return;

    if (fRestore)
        for (i=0; i<nSave; i++)
        {
            if(IsWindow(hwndSave[i])) {
               ClrWS(hwndSave[i],WS_CLIPSIBLINGS|WS_CLIPCHILDREN);
               SetWS(hwndSave[i],lStyleSave[i] & (WS_CLIPSIBLINGS|WS_CLIPCHILDREN));
            }
        }
    else
    {
        //
        // walk all the siblings that intersect us and set CLIPSIBLINGS
        //
        i = 0;

        GetWindowRect(hwnd, &rc);

        for (hwndT = GetWindow(hwnd, GW_HWNDFIRST);
             hwndT;
             hwndT = GetWindow(hwndT, GW_HWNDNEXT))
        {
            GetWindowRect(hwndT, &rcT);
            if (IntersectRect(&rcT, &rcT, &rc))
            {
                lStyleSave[i] = GetWS(hwndT);
                hwndSave[i] = hwndT;
                SetWS(hwndT,WS_CLIPSIBLINGS|WS_CLIPCHILDREN);

                if (++i == MAX_DINK-4)
                    break;
            }
        }

        //
        // walk up the window chain, making sure we get clipped from our
        // parent(s).
        //
        for (hwndT = hwnd; hwndT; hwndT = GetParent(hwndT))
        {
            lStyleSave[i] = GetWS(hwndT);
            hwndSave[i] = hwndT;
            if(IsWindow(hwndT))
                SetWS(hwndT,WS_CLIPSIBLINGS|WS_CLIPCHILDREN);

            if (++i == MAX_DINK)
                break;
        }

        nSave = i;
    }
}

#define SLASH(c)     ((c) == TEXT('/') || (c) == TEXT('\\'))

/**************************************************************************
 FileName  - return a pointer to the filename part of szPath
             with no preceding path.
***************************************************************************/
LPTSTR FAR FileName(LPCTSTR lszPath)
{
    LPCTSTR   lszCur;

    for (lszCur = lszPath + STRLEN(lszPath); lszCur > lszPath && !SLASH(*lszCur) && *lszCur != TEXT(':');)
        lszCur = CharPrev(lszPath, lszCur);
    if (lszCur == lszPath)
        return (LPTSTR)lszCur;
    else
        return (LPTSTR)(lszCur + 1);
}


/**************************************************************************
//## This function should be handled by OLE2
//VIJR: Nope. Still needed for playing inplace in OLE1 clients.
***************************************************************************/

void FAR PASCAL PlayInPlace(HWND hwndApp, HWND hwndClient, LPRECT prc)
{
    if (gfPlayingInPlace)           // this is bad
        return;

    DPF("Using Child window for playback\n");
    SetWS(hwndApp, WS_CHILD);
    SetParent(hwndApp, hwndClient);
    if(!(gfOle2IPEditing || gfOle2IPPlaying))
        DinkWithWindowStyles(hwndApp, FALSE);

    if(!gfOle2IPEditing)
        gfPlayingInPlace = TRUE;
    if(gfOle2IPPlaying)
        MapWindowPoints(NULL,hwndClient,(LPPOINT)prc,2);

    /* For OLE2, now calls MoveWindow in DoInPlaceEdit (inplace.c).
     * This fixes 23429, window positioning in Word.
     */
    if(!(gfOle2IPEditing || gfOle2IPPlaying))
    {
        SetWindowPos(hwndApp, HWND_TOP,
                        prc->left,prc->top,
                        prc->right  - prc->left,
                        prc->bottom - prc->top,
                        SWP_NOACTIVATE);
    }

    if(!gfOle2IPPlaying)      // OLE1 Clients
    {
        /*
        ** On NT we have to install a global mouse HookProc which has to
        ** in a DLL.  Also we have to tell the DLL which process/thread we are
        ** interested in, therefore let the DLL install the HookProc.  When the
        ** HookProc detects an "interesting" mouse message it stops the
        ** device from playing.  However, the device "stopping" function is
        ** inside mplayer, so we have to export it so that the HookProc can
        ** call it.
        */
        if ( hMciOle ) {

            fpInstallHook = (LPINSTALLHOOK)GetProcAddress( hMciOle,
                                                           aszInstallHook );
            fpRemoveHook = (LPREMOVEHOOK)GetProcAddress( hMciOle,
                                                         aszRemoveHook );
        }
        else {
            fpInstallHook = NULL;
            fpRemoveHook = NULL;
        }


        // Is the key down at this INSTANT ???  Then wait until it comes up before
        // we allow GetAsyncKeyState to make us go away
        gfMouseUpSeen =   !((GetAsyncKeyState(VK_LBUTTON) & 0x8000) ||
                                    (GetAsyncKeyState(VK_RBUTTON) & 0x8000));
        // Is GetKeyState saying it's down?  If so, wait until GetKeyState returns
        // up before we let GetKeyState kill us.
        gfKeyStateUpSeen= !(GetKeyState(VK_LBUTTON) || GetKeyState(VK_RBUTTON));

#ifdef DEBUG
        if ( fHookInstalled ) {

            DPF( "Hook already installed\n" );
            DebugBreak();
        }
#endif

        if ( fpInstallHook ) {

            DWORD wow_thread_id = 0L;

            /*
            ** This is a HACK.  If the client applications is a WOW app the
            ** HIWORD of the window handle will be 0x0000 or 0xFFFF.
            ** Chandan tells me that on Daytona the HIWORD could be
            ** either of the above.
            */
            if ( HIWORD(hwndClient) == 0x0000 || HIWORD(hwndClient) == 0xFFFF) {
                wow_thread_id = GetWindowThreadProcessId( hwndClient, NULL );
            }

            fHookInstalled = (*fpInstallHook)( ghwndApp, wow_thread_id );
        }
    }

    ghwndFocusSave = GetFocus();
}

//This function is new for OLE2. It sets the container window as
//our window's (actually the hatch window's) parent and positions the window
void FAR PASCAL EditInPlace(HWND hwndApp, HWND hwndClient, LPRECT prc)
{
    RECT rc;

    rc = *prc;

    SetWS(hwndApp, WS_CHILD);
    SetParent(hwndApp, hwndClient);

    ScreenToClient(hwndClient,(LPPOINT)&rc);
    ScreenToClient(hwndClient,(LPPOINT)&rc+1);
    if(gwDeviceType & DTMCI_CANWINDOW)
    {
       /* Sometimes the position (though not the size) of this rectangle
        * gets messed up (most reliably in PowerPoint 7).
        * I can't figure out why this is happening (see the nightmarish
        * code in ReallyDoVerb() to get a flavour of what happens).
        * But it turns out that this call is unnecessary in any case,
        * since the window has already been positioned properly in
        * IPObjSetObjectRects().
        * I suspect there's a lot of surplus window-positioning code,
        * but now isn't the time to start making major changes.
        * This is the minimal change that makes things work.
        */
		//This fixes NTRaid bug #236641 in Excel. AND bug #247393 in Word
		//Sometimes there is confusion between who the parent is. mplay32 sets the document
		//window as the parent and the rectangle sent in SetObjectRects might not be with respect to
		//the document window (this might happen when the document window is not in the maximized state). 
		//In this function we know the parent and the rectangle in that parent. Setting
		//the position here places our OLE object as the client requires. This change is even safe in 
		//terms of introducing regressions.
       SetWindowPos(hwndApp, HWND_TOP,
            rc.left, rc.top,
            rc.right - rc.left,
            rc.bottom - rc.top,
            SWP_NOACTIVATE | SWP_FRAMECHANGED);
    }
    else if(gwDeviceID)
        SetWindowPos(hwndApp, HWND_TOP,
            rc.left,rc.top,
            rc.right - rc.left,
            rc.bottom - rc.top,
            SWP_SHOWWINDOW);
    else
    SetWindowPos(hwndApp, HWND_TOP,
            rc.left,rc.top,
            rc.right - rc.left,
            rc.bottom - rc.top,
            SWP_HIDEWINDOW);

    ghwndFocusSave = GetFocus();

	//Set the focus for the parent.
	if((gwDeviceID == (UINT)0) && IsWindow(hwndClient))
	{
		SetFocus(hwndClient);
	}
}


/**************************************************************************
//##  This is called to end PlayInPlace and make sure that the window goes
//## away and the also to manage the palette stuff (May go away in OLE2)
//## This function should be handled by OLE2
***************************************************************************/

void FAR PASCAL EndPlayInPlace(HWND hwndApp)
{
    HWND hwndP;
    HWND hwndT;

    if (!gfPlayingInPlace || !IsWindow(hwndApp))
        return;

    /* Do this BEFORE hiding our window and BEFORE we do anything that */
    /* might yield so client can't redraw with the wrong styles set.   */
    if (!(gfOle2IPEditing || gfOle2IPPlaying))
        DinkWithWindowStyles(hwndApp, TRUE);

    gfPlayingInPlace = FALSE;

    /*
    ** Tell mciole32.dll to remove its mouse HookProc.
    */

    if ( fHookInstalled && fpRemoveHook ) {

        fHookInstalled = !(*fpRemoveHook)();
    }

    if (gfOle2IPPlaying)
        hwndP = ghwndCntr;
    else
        hwndP = GetParent(hwndApp);

    //
    //  If we have the focus, then restore it to who used to have it.
    //  ACK!! If the person who used to have it is GONE, we must give it away
    //  to somebody (who choose our parent) because our child can't
    //  keep the focus without making windows crash hard during the WM_DESTROY
    //  (or maybe later whenever it feels like crashing at some random time).
    //  See bug #8634.
    //
    if (((hwndT = GetFocus()) != NULL) && GetWindowTask(hwndT) == MGetCurrentTask) {
        if (IsWindow(ghwndFocusSave))
            SetFocus(ghwndFocusSave);
    else
        SetFocus(hwndP);
    }

    if (!hwndP ||
        (gwOptions & OPT_BAR) ||
        (gwOptions & OPT_BORDER) ||
        (gwOptions & OPT_AUTORWD))
    {

        // hide the aplication window

        SetWindowPos(hwndApp, NULL, 0, 0, 0, 0,
            SWP_NOZORDER|SWP_NOSIZE|SWP_NOMOVE|SWP_HIDEWINDOW|SWP_NOACTIVATE);
    }
    else
    {
        //
        // hide our window, but don't redraw it will look
        // like we are still on the last frame.
        //
        // this is when we are playing in place, and there is
        // no playbar, and no rewind
        //
        // this is for Playing a AVI in a PowerPoint slide
        // without redraw problems.
        //

        SetWindowPos(hwndApp, NULL, 0, 0, 0, 0,
            SWP_NOREDRAW|SWP_NOZORDER|SWP_NOSIZE|SWP_NOMOVE|
            SWP_HIDEWINDOW|SWP_NOACTIVATE);
    }

    SetParent(hwndApp, NULL);
    ClrWS(hwndApp, WS_CHILD);

    if (hwndP && gfParentWasEnabled)
        EnableWindow(hwndP, TRUE);

    //
    // set either the owner or the WS_CHILD bit so it will
    // not act up because we have the palette bit set and cause the
    // desktop to steal the palette.
    //
    SetWS(hwndApp, WS_CHILD);

}

//If we were InPlace editing restore the windows state.
void FAR PASCAL EndEditInPlace(HWND hwndApp)
{
    HWND hwndP;
    HWND hwndT;

    if (!gfOle2IPEditing || !IsWindow(hwndApp))
        return;

    /* Do this BEFORE hiding our window and BEFORE we do anything that */
    /* might yield so client can't redraw with the wrong styles set.   */
    DinkWithWindowStyles(hwndApp, TRUE);

    gfOle2IPEditing = FALSE;

    if (gfOle2IPPlaying)
    hwndP = ghwndCntr;
    else
    hwndP = GetParent(hwndApp);

    //
    //  If we have the focus, then restore it to who used to have it.
    //  ACK!! If the person who used to have it is GONE, we must give it away
    //  to somebody (who choose our parent) because our child can't
    //  keep the focus without making windows crash hard during the WM_DESTROY
    //  (or maybe later whenever it feels like crashing at some random time).
    //  See bug #8634.
    //
    if (((hwndT = GetFocus()) != NULL) && GetWindowTask(hwndT) == MGetCurrentTask) {
        if (IsWindow(ghwndFocusSave))
            SetFocus(ghwndFocusSave);
    else
        if (IsWindow(hwndP))
            SetFocus(hwndP);
    }

    if (!IsWindow(hwndP) ||
        (gwOptions & OPT_BAR) ||
        (gwOptions & OPT_BORDER) ||
    (gwOptions & OPT_AUTORWD))
    {
        // hide the aplication window
        SetWindowPos(hwndApp, NULL, 0, 0, 0, 0,
            SWP_NOZORDER|SWP_NOSIZE|SWP_NOMOVE|SWP_HIDEWINDOW|SWP_NOACTIVATE);
    }
    else
    {
        //
        // hide our window, but don't redraw it will look
        // like we are still on the last frame.
        //
        // this is when we are playing in place, and there is
        // no playbar, and no rewind
        //
        // this is for Playing a AVI in a PowerPoint slide
        // without redraw problems.
        //
        SetWindowPos(hwndApp, NULL, 0, 0, 0, 0,
            SWP_NOREDRAW|SWP_NOZORDER|SWP_NOSIZE|SWP_NOMOVE|
            SWP_HIDEWINDOW|SWP_NOACTIVATE);
    }

    SetParent(hwndApp, NULL);
    ClrWS(hwndApp, WS_CHILD);

    if (IsWindow(hwndP) && gfParentWasEnabled)
        EnableWindow(hwndP, TRUE);

    //
    // set either the owner or the WS_CHILD bit so it will
    // not act up because we have the palette bit set and cause the
    // desktop to steal the palette.
    //
    SetWS(hwndApp, WS_CHILD);

}




/* Tell the user that something's amiss with a network call.
 * For network-specific errors, call WNetGetLastError,
 * otherwise see if it's a system error.
 */
void DisplayNetError(DWORD Error)
{
    DWORD  ErrorCode;           // address of error code
    TCHAR  szDescription[512];  // address of string describing error
    TCHAR  szProviderName[64];  // address of buffer for network provider name

    if (Error == ERROR_EXTENDED_ERROR)
    {
        if (WNetGetLastError(&ErrorCode, szDescription, CHAR_COUNT(szDescription),
                             szProviderName, CHAR_COUNT(szProviderName)) == NO_ERROR)
        {
            Error1(ghwndApp, IDS_NETWORKERROR, szDescription);
            return;
        }
    }
    else
    {
        if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, Error, 0,
                          szDescription, CHAR_COUNT(szDescription), NULL) > 0)
        {
            Error1(ghwndApp, IDS_NETWORKERROR, szDescription);
            return;
        }
    }

    /* If all else fails:
     */
    Error(ghwndApp, IDS_UNKNOWNNETWORKERROR);
}



/**************************************************************************
    convert a file name to a fully qualifed path name, if the file
    exists on a net drive the UNC name is returned.
***************************************************************************/

STATICFN BOOL NetParseFile(LPTSTR szFile, LPTSTR szDrive, LPTSTR szPath)
{
    BYTE   UNBuffer[(MAX_PATH * sizeof(TCHAR)) + sizeof(UNIVERSAL_NAME_INFO)];
    DWORD  UNBufferSize = sizeof UNBuffer;
    DWORD_PTR  Error;
    LPTSTR pUniversalName;

    //
    // Turn into a fully qualified path name
    //
    if (!FileExists(szFile, szPath, MAX_PATH))
        return FALSE;

    //
    // if the file is not drive based (probably UNC)
    //
    if (szPath[1] != TEXT(':'))
        return TRUE;

    Error = WNetGetUniversalName(szDrive, UNIVERSAL_NAME_INFO_LEVEL,
                                 UNBuffer, &UNBufferSize);

    if (Error == ERROR_NOT_SUPPORTED)
    {
        /* This means that the network provider doesn't support
         * UNC conventions.  Give WNetGetConnection a try.
         * Note: dynalink.h assumes that WNetGetUniversalName
         * will always be called before WNetGetConnection.
         */
        UNBufferSize = CHAR_COUNT(UNBuffer);

        Error = WNetGetConnection(szDrive, (LPTSTR)UNBuffer, &UNBufferSize);

        if (Error == NO_ERROR)
        {
            /* What does the following mean?  It was in the original code.
             */
            if (!SLASH(UNBuffer[0]) || !SLASH(UNBuffer[1]))
                return TRUE;

            lstrcat((LPTSTR)UNBuffer, szPath+2);
            lstrcpy(szPath, (LPTSTR)UNBuffer);

            return TRUE;
        }
    }


    if (Error != NO_ERROR)
    {
        DisplayNetError((DWORD)Error);

        return FALSE;
    }

    pUniversalName = ((LPUNIVERSAL_NAME_INFO)UNBuffer)->lpUniversalName;

    lstrcat(pUniversalName, szPath+2);
    lstrcpy(szPath, pUniversalName);

    return TRUE;
}

/**************************************************************************
    Get the data that represents the currently open MCI file/device. as
    a link. MPlayer links look like this:
        MPLAYER|<filename>!<MCIDevice> [selection]
//## This is the opposite of parse options and sets the data string to be
//## embedded in the OLE object.
    Note we store the data in an ANSI string, regardless of whether we're
    compiled as a Unicode app, for Daytona/Chicago/OLE1/OLE2 compatibility.
***************************************************************************/
HANDLE GetLink( VOID )
{
    TCHAR       szFileName[MAX_PATH];
    TCHAR       szFullName[MAX_PATH];
    TCHAR       szDevice[40];
    TCHAR       szDrive[4];
    HANDLE      h;
    LPSTR       p;  /* NOT LPTSTR */
    int         len;
    int         lenAppName;
    int         lenFullName;

    lstrcpy(szFileName,gachFileDevice);
    lstrcpy(szFullName,gachFileDevice);

    //
    // convert the filename into a UNC file name, if it exists on the net
    //
    if (gwDeviceType & DTMCI_FILEDEV)
    {
        if (szFileName[1] == TEXT(':'))
        {
            /* This is a file name with a drive letter.
             * Find out if it's redirected:
             */
            szDrive[0] = szFileName[0];
            szDrive[1] = szFileName[1];
            szDrive[2] = TEXT('\\');    // GetDriveType requires the root.
            szDrive[3] = TEXT('\0');    // Null-terminate.

            if ((szDrive[1] == TEXT(':')) && GetDriveType(szDrive) == DRIVE_REMOTE)
            {
                szDrive[2] = TEXT('\0');    // Zap backslash.
                if (!NetParseFile(szFileName, szDrive, szFullName))
                    return NULL;
            }
        }
    }
    else if (gwDeviceType & DTMCI_SIMPLEDEV)
    {
        szFullName[0] = 0;
    }

    if (gwCurDevice == 0)
        GetDeviceNameMCI(szDevice, BYTE_COUNT(szDevice));
    else
        lstrcpy(szDevice, garMciDevices[gwCurDevice].szDevice);

#ifdef UNICODE
    // length of the string in bytes != length of the string in characters
    lenAppName  = WideCharToMultiByte(CP_ACP, 0, aszAppName, -1, NULL, 0, NULL, NULL) - 1;
    lenFullName = WideCharToMultiByte(CP_ACP, 0, szFullName, -1, NULL, 0, NULL, NULL) - 1;
#else
    lenAppName  = STRLEN(aszAppName);
    lenFullName = STRLEN(szFullName);
#endif

    /* How much data will we be writing? */
#ifdef UNICODE
    // length of the string in bytes != length of the string in characters
    len = 9 +                    // all the delimeters
          lenAppName +
          lenFullName +
          WideCharToMultiByte(CP_ACP, 0, szDevice, -1, NULL, 0, NULL, NULL)-1 +
          5 + 10 + 10 + 10 +     // max length of int and long strings
          WideCharToMultiByte(CP_ACP, 0, gachCaption, -1, NULL, 0, NULL, NULL)-1;
#else
    len = 9 +                    // all the delimeters
          lenAppName +
          lenFullName +
          STRLEN(szDevice) +
          5 + 10 + 10 + 10 +     // max length of int and long strings
          STRLEN(gachCaption);
#endif

    h = GlobalAlloc(GMEM_DDESHARE|GMEM_ZEROINIT, len * sizeof(CHAR));
    if (!h)
        return NULL;
    p = GLOBALLOCK(h);

    /* This string must have two terminating null characters.
     * The GlobalAlloc GMEM_ZEROINIT flag should ensure this.
     */
#ifdef UNICODE
    wsprintfA(p, "%ws%c%ws%c%ws%c%d%c%d%c%d%c%d%c%d%c%ws",
#else
    wsprintfA(p, "%s%c%s%c%s%c%d%c%d%c%d%c%d%c%d%c%s",
#endif
        aszAppName,
        '*',          // placeholder
        szFullName,
        '*',          // placeholder
        szDevice, ',',
        (gwOptions & ~OPT_SCALE) | gwCurScale, ',',
        (long)SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0L), ',',
        (long)SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0L), ',',
        (long)SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0L), ';',
        // new parameter snuck in since initial version
        // Height of picture we're giving the client - w/o caption
        grcSize.bottom - grcSize.top, ',',
        gachCaption);

    /* Replace *'s with NULL characters  (wsprintf doesn't accept
     * 0 as a replacement parameter for %c):
     */
    p[lenAppName] = '\0';
    p[lenAppName + 1 + lenFullName] = '\0';

    DPF("Native data %hs has been created\n", p);

    GLOBALUNLOCK(h);

    return h;
}


/****************************************************************************
 AttachDir - Take the path part of szPath, append the
             filename part of szName, and return it as szResult.
****************************************************************************/
STATICFN void AttachDir(LPTSTR szResult, LPTSTR szPath, LPTSTR szName)
{
    lstrcpy(szResult, szPath);
    lstrcpy(FileName(szResult), FileName(szName));
}

/****************************************************************************
 DOS share has a bug.  If the file we're testing for existence is open
 already by someone else, we have to give it the same flag for SHARE as
 the other person is using.  So we have to try both on and off.  Only one
 of these will return TRUE but if one of them does, the file exists.  Also
 we have to try with SHARE first, because the test without share might
 give a system modal error box!!!
//## Check to see if DOS 7 has this bug or is it fixed

 Parameter iLen is the number of characters in the szFullName buffer
****************************************************************************/
STATICFN BOOL FileExists(LPTSTR szFile, LPTSTR szFullName, int iLen)
{
    DWORD  rc;
    LPTSTR pFilePart;

    rc = SearchPath(NULL,       /* Default path search order */
                    szFile,
                    NULL,       /* szFile includes extension */
                    (DWORD)iLen,
                    szFullName,
                    &pFilePart);

    if(rc > (DWORD)iLen)
    {
        DPF0("Buffer passed to FileExists is of insufficient length\n");
    }

    return (BOOL)rc;
}

/****************************************************************************
 FindRealFileName - If szFile isn't valid, try searching
                    client directory for it, or anywhere on
                    the path, or bringing up a locate dlg.
                    Set szFile to the valid path name.
//## This function is used to repair broken links

 Parameter iLen is the number of characters in the szFile buffer
****************************************************************************/
BOOL FindRealFileName(LPTSTR szFile, int iLen)
{
    TCHAR           achFile[_MAX_PATH + 1];  /* file or device name buffer  */

    /* This isn't a file device, so don't do anything */
    if (!szFile || *szFile == 0)
        return TRUE;

    /* The file name we've been given is valid, so do nothing. */
    //!!! what about share
    if (FileExists(szFile, achFile, iLen))
    {
        lstrcpy(szFile, achFile);
        return TRUE;
    }

    DPF("FindRealFileName: Can't find file '%"DTS"'\n", szFile);

#if 0
    /* This could never have worked: */
    /* Look for the file in the directory of the client doc */
    AttachDir(achFile, gachDocTitle, szFile);

    DPF("FindRealFileName: ...Looking for '%"DTS"'\n", (LPTSTR)achFile);

    if (FileExists(achFile, szFile, iLen))
        return TRUE;
#endif

    DPF("FindRealFileName: ...Looking on the $PATH\n");

    /* Look for the file anywhere */
    lstrcpy(achFile, FileName(szFile));
    if (FileExists(achFile, szFile, iLen))
        return TRUE;

    return FALSE;
}

/**************************************************************************
*   SubClassedMCIWndProc:
*   This the WndProc function used to sub-class the Play Back window.
*   This function is used to trap the drag-drops and also
*   to route the WM_CLOSE to the IDM_CLOSE of Mplayer.
**************************************************************************/
LONG_PTR FAR PASCAL SubClassedMCIWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL fDragCapture = FALSE;
    static RECT rcWin;
    POINT       pt;
    LONG_PTR    lRc;

    switch(wMsg)
    {
    case WM_LBUTTONDOWN:
//        break; // Disable drag from MPlayer!  It's broken.
        if (!gfOle2IPEditing)
        {
            fDragCapture = TRUE;
            SetCapture(hwnd);
            GetClientRect(hwnd, (LPRECT)&rcWin);
            MapWindowPoints(hwnd, NULL, (LPPOINT)&rcWin, 2);
        }
        break;

    case WM_LBUTTONUP:
        if (!fDragCapture)
            break;

        fDragCapture = FALSE;
        ReleaseCapture();
        break;

    case WM_MOUSEMOVE:
        if (!fDragCapture)
            break;

        LONG2POINT(lParam, pt);
        MapWindowPoints(hwnd, NULL, &pt, 1);

        if (!PtInRect((LPRECT)&rcWin, pt))
        {
            ReleaseCapture();
            DoDrag();
            fDragCapture = FALSE;
        }

        SetCursor(LoadCursor(ghInst,MAKEINTRESOURCE(IDC_DRAG)));

        break;

    case WM_CLOSE:
        if (gfSeenPBCloseMsg || gfOle2IPEditing || gfOle2IPPlaying) {
            lRc = CallWindowProc(gfnMCIWndProc, hwnd, wMsg, wParam, lParam);
        } else {
            gfSeenPBCloseMsg = TRUE;
            PostMessage(ghwndApp,WM_COMMAND,IDM_CLOSE,0L);
            lRc = 0L;
        }
        CleanUpDrag();

        return lRc;

    case WM_DESTROY:
        ghwndSubclass = NULL;
        CleanUpDrag();
        break;

    case WM_ACTIVATE:
        /* Get the app's main window somewhere it can be seen
         * if the MCI window gets activated:
         */
        if (((WORD)wParam != 0) && !IsIconic(ghwndApp))
        {
            SetWindowPos(ghwndApp, hwnd, 0, 0, 0, 0,
                         SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
        }
        break;
    }

    return CallWindowProc(gfnMCIWndProc, hwnd, wMsg, wParam, lParam);
}

/**************************************************************************
*   SubClassMCIWindow:
*   This function sub-classes the Play Back window by hooking in
*   SubClassedMCIWndProc function.
**************************************************************************/
void SubClassMCIWindow(void)
{

    HWND hwndMCI;

    hwndMCI = GetWindowMCI();
    if(!IsWindow(hwndMCI))
        return;
    if (gfnMCIWndProc != NULL && IsWindow(ghwndSubclass)) {
        SetWindowLongPtr(ghwndSubclass, GWLP_WNDPROC, (LONG_PTR)gfnMCIWndProc);
    }
    gfnMCIWndProc = (WNDPROC)GetWindowLongPtr(hwndMCI, GWLP_WNDPROC);
    if (hwndMCI)
        SetWindowLongPtr(hwndMCI, GWLP_WNDPROC, (LONG_PTR)SubClassedMCIWndProc);
    ghwndSubclass = hwndMCI;
    gfSeenPBCloseMsg = FALSE;

#ifdef CHICAGO_PRODUCT
    SendMessage(hwndMCI, WM_SETICON, FALSE,
                (LPARAM)GetIconForCurrentDevice(GI_SMALL, IDI_DDEFAULT));
    SetWindowText(hwndMCI, gachCaption);
#endif
}


INT_PTR FAR PASCAL FixLinkDialog(LPTSTR szFile, LPTSTR szDevice, int iLen);

/* ANSI-to-Unicode version of lstrcpyn:
 *
 * Zero terminates the buffer in case it isn't long enough,
 * then maps as many characters as will fit into the Unicode buffer.
 *
 */
#define LSTRCPYNA2W(strW, strA, buflen)    \
    strW[buflen-1] = L'\0',                                             \
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,                        \
                         (strA), min( strlen( strA )+1, (buflen)-1 ),   \
                         (strW), ((buflen)-1) )


/**************************************************************************
* ItemSetData(LPBYTE p): This function is left over from OLE1 days, but is
* very important because the embedded data is still the same. This function
* parses the embedded data and opens the appropriate device/file and sets
* everything in motion. "p" is the pointer memory block having the embedded
* data.
* Note we store the data in an ANSI string, regardless of whether we're
* compiled as a Unicode app, for Daytona/Chicago/OLE1/OLE2 compatibility.
**************************************************************************/
SCODE ItemSetData(LPBYTE p)
{
    LPSTR pSave, pT;
    LPSTR szFile, szDevice;
    CHAR  ach[40];
    TCHAR achFile[_MAX_PATH];
    TCHAR achCaption[_MAX_PATH];
    LPTSTR pDevice;
    SCODE scode = E_FAIL;

    if (p && *p != 0)
    {
        szFile   = p + strlen(p) + 1;      // pick off the Filename
        p = szFile + strlen(szFile) + 1;
        pSave = p;
        szDevice = ach;                 // copy over Device name and
        for (pT = ach; *p && *p != ',';)        // NULL terminate it (it ends
            *pT++ = *p++;               // with a ',' right now).
        *pT = '\0';


        /* It is OK for szFile and szDevice to be empty, since we may have
         * a Media Clip object with no device or file selected
         */
        DPF("%hs|%hs!%hs\n", p, szFile, szDevice);


        CloseMCI(TRUE);         // nuke old gachCaption
        scode = ParseOptions(pSave);   // this will set new gachCaption

        if (scode != S_OK)
            return scode;

            // If this file doesn't exist, we won't continue setting data, we
            // will succeed and get out, and do it later, because we can't
            // bring up a dialog right now because clients like WinWord
            // won't dispatch any msgs.

#ifdef UNICODE
        LSTRCPYNA2W(achFile, szFile, CHAR_COUNT(achFile));
#else
        lstrcpyn(achFile, szFile, CHAR_COUNT(achFile));
#endif

        // Check for  file existence. if the filename we were given is bad,
        // try and find it somewhere on the disk

#ifdef UNICODE
        pDevice = AllocateUnicodeString(szDevice);
        if (!pDevice)
            return E_OUTOFMEMORY;
#else
        pDevice = szDevice;
#endif

        if (FindRealFileName(achFile, CHAR_COUNT(achFile)))
        {
            lstrcpy(achCaption, gachCaption);  //Save caption.

            if (OpenMciDevice(achFile, pDevice))
            {
                /* Set the selection to what we parsed in ParseOptions. */
                SendMessage(ghwndTrackbar, TBM_SETSELSTART, 0, glSelStart);
                SendMessage(ghwndTrackbar, TBM_SETSELEND, 0, glSelEnd);
            }
            lstrcpy(gachCaption, achCaption);   //Restore Caption
        }
        else if (FixLinkDialog(achFile, pDevice, sizeof(achFile)) )
        {
            if (OpenMciDevice(achFile, pDevice))
            {
                /* Set the selection to what we parsed in ParseOptions. */
                SendMessage(ghwndTrackbar, TBM_SETSELSTART, 0, glSelStart);
                SendMessage(ghwndTrackbar, TBM_SETSELEND, 0, glSelEnd);
                gfBrokenLink = TRUE;
            }
        }
        else
            scode = E_FAIL;
    }
#ifdef UNICODE
    FreeUnicodeString(pDevice);
#endif

    return scode;
}


/**************************************************************************
* UpdateObject() - handle the update of the object
* If the object has changed in content or appearance a message is
* sent to the container.
***************************************************************************/

void UpdateObject(void)
{
    LONG lPos;

    if((gfOle2IPPlaying || gfPlayingInPlace) && !fDocChanged)
        return;

    if (IsWindow(ghwndTrackbar))
        lPos = (LONG)SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0L);
    else
        lPos = -1;


    if (gfEmbeddedObject &&
        (fDocChanged || ((lPos >= 0) && (lPos != (LONG)gdwPosition)
         && (gwDeviceType & DTMCI_CANWINDOW))))
    {
        //
        //  Some clients (e.g. Excel 3.00 and PowerPoint 1.0) don't
        //  handle saved notifications; they expect to get an
        //  OLE_CLOSED message.
        //
        //  We will send an OLE_CLOSED message right before we
        //  revoke the DOC iff gfDirty == -1 (see FileNew()).
        //
        if ((lPos >= 0) && (lPos != (LONG)gdwPosition) && (gwDeviceType & DTMCI_CANWINDOW))
        {
            gdwPosition = (DWORD)lPos;
            SendDocMsg((LPDOC)&docMain,OLE_CHANGED);
        }

        if (fDocChanged)
            SendDocMsg(&docMain, OLE_SAVEOBJ);
    }
}



/**************************************************************************
* int FAR PASCAL ReallyDoVerb: This is the main function in the server stuff.
* This function used to implement the PlayInPlace in OLE1. Most of the code
* has not been changed and has been used to munge the MPlayer for EditInPlace
* in OLE2. For OLE2 this function calls DoInPlaceEdit to get the containers
* hwnd and Object rectangle. For OLE1 clients the rectangle is still got
* from the OleQueryObjPos funtion in mciole.dll. A new twist in the PlayVerb
* is that if we are just hidden in a deactivated state we just reappear
* and play instead of PlayingInPlace without the toolbars etc. This function
* is also called when reactivating, deactivating etc. The BOOL SkipInPlaceEdit
* is used to avoid redoing all the stuff if we are just reactivating.
***************************************************************************/
int FAR PASCAL  ReallyDoVerb (
LPDOC   lpobj,
LONG        verb,
LPMSG       lpmsg,
LPOLECLIENTSITE lpActiveSite,
BOOL         fShow,
BOOL         fActivate)
{
    BOOL    fWindowWasVisible = IsWindowVisible(ghwndApp);

    int     dx,dy;
    HWND    hwndClient;
    HWND    hwndT;
    RECT    rcSave;
    RECT    rcClient;
    RECT    rc;
    LONG    err;
    SCODE   sc;
    HPALETTE hpal;
    HDC     hdc;
    INT     xTextExt;
    int     yOrig, yNow, xOrig, ytitleNow, xtitleOrig, xNow;
    int     xIndent = 0; // Avoid warning C4701: local variable 'xIndent'
                         // may be used without having been initialized
    int     wWinNow;
    HWND    hwndMCI;

    int     Result = S_OK;

    DPFI("VERB = %d\n", verb);

    /* MSProject assumes that our primary verb is Edit; in fact it's Play.
     * So when we're called with the default verb, make sure we've loaded
     * something from storage and, if not, do the Edit thing.
     *
     * Nope, that doesn't work, because if you insert an object, deactivate
     * it and then play it, PSLoad hasn't been called.  A better bet is
     * to check whether we have a current device.
     */
    if (gfRunWithEmbeddingFlag && gwDeviceType == 0)
    {
        if (verb == OLEIVERB_PRIMARY)
        {
            DPF("Primary Verb called without current device -- changing verb to Edit...\n");
            verb = verbEdit;
        }
    }

    /* If a Media Clip is currently open, the user can give the focus back
     * to the container and issue another verb or double-click the object.
     * If this happens, set the focus back to the open object.
     *
     * We don't need to worry about resetting fObjectOpen, since the server
     * shuts down when the user exits and returns to the container.
     */
    if (gfOle2Open)
    {
        SetFocus(ghwndApp);
        return S_OK;
    }


    // This is the first verb we are seeing. So the container must
    // have the focus. Save it so that we can return it later.
    if (glCurrentVerb == NOVERB)
        ghwndFocusSave = GetFocus();
    if (verb == OLEIVERB_PRIMARY && !gfOle2IPEditing && (glCurrentVerb != verbEdit))
    {
        EnableMenuItem((HMENU)GetMenu(ghwndApp), IDM_CLOSE,   MF_GRAYED);
    }

    glCurrentVerb = verb;

    //
    // dont even try to nest things.
    //
    if (gfPlayingInPlace && verb != OLEIVERB_HIDE)
        return OLE_OK;

    if (gfBrokenLink)
    {
        PostMessage(ghwndApp, WM_SEND_OLE_CHANGE, 0, 0L);
        gfBrokenLink = FALSE;
    }

    //We are just reactivating. Don't do through all the steps again.
    if (gfOle2IPEditing)
        SkipInPlaceEdit = TRUE;

    // Make sure the timer's doing the right thing:
    gfAppActive = ( verb != OLEIVERB_HIDE );

    // NTVDM can get into a spin if we have too meany TIMER messages,
    // so make sure we don't have any if there's no device.
    if (gwDeviceID)
        EnableTimer( gfAppActive );
    else
        EnableTimer( FALSE );

    if (verb == OLEIVERB_PRIMARY)
    {
        gfOle1Client = FALSE;

        //We are already up but deactivated. Just come up and play.
        if (gfOle2IPEditing)
        {
            if (!(gwDeviceType & DTMCI_CANWINDOW))
            {
                Result = ReallyDoVerb(lpobj, verbEdit, lpmsg, lpActiveSite, fShow, fActivate);
                PostMessage(ghwndApp, WM_COMMAND, ID_PLAYSEL, 0); // play selection
            }
            else
            {
                ClrWS(ghwndApp, WS_THICKFRAME|WS_CAPTION|WS_SYSMENU|WS_MINIMIZEBOX|WS_MAXIMIZEBOX|WS_BORDER);

                err = GetScode(DoInPlaceEdit(lpobj, lpmsg, lpActiveSite, verbEdit, &hwndClient,
                          &rcClient));
                if (err)
                {
                    SHOWAPPWINDOW(SW_HIDE);
                    PostMessage(ghwndApp,WM_CLOSE,0,0);
                    return((int)err);
                }

                gfInPlaceResize = TRUE;
                rcClient = gInPlacePosRect;
                MapWindowPoints(NULL,ghwndCntr,(LPPOINT)&rcClient,2);

                DPF("IOleInPlaceSite::OnPosRectChange %d, %d, %d, %d\n", rcClient);
                if (!gfInPPViewer)
                    IOleInPlaceSite_OnPosRectChange(docMain.lpIpData->lpSite, &rcClient);

                toolbarSetFocus(ghwndToolbar, BTN_PLAY);
                SetFocus(ghwndToolbar);
                PostMessage(ghwndApp, WM_COMMAND, ID_PLAYSEL, 0); // play selection
            }
        }

        else
        {
            if(gwDeviceID == (UINT)0)       //Play without a device !?!!!
            {
                PostMessage(ghwndApp, WM_CLOSE, 0, 0L);
                sc = E_FAIL;
                return (int)sc;
            }

            // if the device can't window and the user does not want a playbar
            // dont play in place - just start the media and run invisible.
            //
            if (!(gwDeviceType & DTMCI_CANWINDOW) && !(gwOptions & OPT_BAR))
                gwOptions &= ~OPT_PLAY;


            //  Select the palette in right now on behalf of the active
            //  window, so USER will think it is palette aware.
            //
            //  any palette will do we dont even have to realize it!!
            //
            if (((hpal = PaletteMCI()) != NULL) && ((hwndT = GetActiveWindow()) != NULL))
            {
                hdc = GetDC(hwndT);
                hpal = SelectPalette(hdc, hpal, FALSE);
                        SelectPalette(hdc, hpal, FALSE);
                        ReleaseDC(hwndT, hdc);
            }

            if (ghwndClient)
            {
                hwndClient = ghwndClient;
                err = gerr;
                rcClient = grcClient;
                ghwndClient = NULL;
            }

            else
            {
                err = GetScode(DoInPlaceEdit(lpobj, lpmsg, lpActiveSite, verb, &hwndClient,
                                             &rcClient));

                if (err != S_OK)
                {
                    err = OleQueryObjPos(lpobj, &hwndClient, &rcClient, NULL);

                    if (err == S_OK)
                    {
                        gfOle1Client = TRUE;
                        ghwndCntr = hwndClient;
                    }
                }
                else
                {
                    if (gwOptions & OPT_TITLE)
                    gwOptions |= OPT_BAR;
                    else
                    gwOptions &= ~OPT_BAR;
                }
            }


            /* We want to play in place and we can.              */
            /* If we're a link, not an embedded object, and there was an instance*/
            /* of MPlayer up when we said "Play" that was already editing this  */
            /* file, we don't want to play in place... we'll just play in that  */
            /* instance.    We can tell this by the fact that our main MPlayer     */
            /* window is already visible.                        */

            if ((err == S_OK)
             && (!gfOle1Client
              || (gwOptions & OPT_PLAY))    /* Ignore Play in client doc for OLE2 clients */
             && (gfOle2IPPlaying
              || (IsWindow(hwndClient)
               && IsWindowVisible(hwndClient)
               && !fWindowWasVisible)))
            {
                rc = grcSize;    // default playback window size for this movie

                /* If we can't window, or something's wrong, use ICON size */
                if (IsRectEmpty(&rc))
                SetRect(&rc, 0, 0, GetSystemMetrics(SM_CXICON),
                GetSystemMetrics(SM_CYICON));

                /* rcSave is the area for the MCI window above the control bar */
                /* (if we have one).                                           */
                /* rcClient is the area of the MCI window (0 based) to play in.*/
                /* Control bar may be longer than picture, so rcClient may be  */
                /* smaller than rcSave.                                        */
                rcSave = rcClient;    // remember stretched size

                /* Make rcClient 0 based from rcSave */
                rcClient.left = 0;
                rcClient.right = rcSave.right - rcSave.left;
                rcClient.top = 0;
                rcClient.bottom = rcSave.bottom - rcSave.top;

                /* Assume playbar will be regular height for now */

                if (gwOptions & OPT_BAR)
                    gwPlaybarHeight = TOOLBAR_HEIGHT;
                else
                    gwPlaybarHeight = 0;

                //
                // munge rectangle to account for a title in the picture
                // and the fact that picture is centred above title.
                // Remember, it's been stretched around.
                //
                if (gwOptions & OPT_TITLE)
                {
                    SIZE Size;

                    hdc = GetDC(NULL);

                    if (ghfontMap)
                        SelectObject(hdc, ghfontMap);

                    GetTextExtentPoint32(hdc, gachCaption,
                                         STRLEN(gachCaption), &Size);
                    xTextExt = Size.cx;

                    ReleaseDC(NULL, hdc);

                    yOrig = rc.bottom - rc.top;
                    xOrig = rc.right - rc.left;
                    xtitleOrig = max(xTextExt + 4, xOrig);
                    yNow    = rcClient.bottom - rcClient.top;
                    xNow    = rcClient.right - rcClient.left;
                    ytitleNow = (int)((long)yNow - ((long)yOrig * yNow)
                                / (yOrig + TITLE_HEIGHT));
                    /* for windowed devices, center the playback area above the */
                    /* control bar if the control bar is longer.            */
                    if (gwDeviceType & DTMCI_CANWINDOW)
                    {
                                wWinNow =(int)((long)xOrig * (long)xNow / (long)xtitleOrig);
                                xIndent = (xNow - wWinNow) / 2;
                                rcClient.left += xIndent;
                                rcClient.right = rcClient.left + wWinNow;
                    }

                    // Align top of control bar with the top of the title bar.
                    // The control bar (if there) will appear under rcSave.
                    rcClient.bottom = rcClient.top + yNow - ytitleNow;
                    rcSave.bottom = rcSave.top + yNow - ytitleNow;

                    /* When we make the playbar, make it cover the title */
                            /* if the caption was stretched taller than ordinary.*/
                    if (gwOptions & OPT_BAR)
                        gwPlaybarHeight = max(ytitleNow, TOOLBAR_HEIGHT);
                }

                /* Enforce a minimum width for the control bar */
                if ((gwOptions & OPT_BAR) &&
                    (rcSave.right - rcSave.left < 3 * GetSystemMetrics(SM_CXICON)))
                {
                    rcSave.right = rcSave.left + 3 * GetSystemMetrics(SM_CXICON);
                    if (gwDeviceType & DTMCI_CANWINDOW)
                        xIndent = TRUE; // force SetWindowMCI to be called to
                                        // avoid stretching to this new size.
                }

                if (gwDeviceType & DTMCI_CANWINDOW)
                {
                    //  THIS CODE IS USED TO AVOID SLOW PLAYBACK
                    //  If we've only stretched a bit, don't stretch at all.
                    //  We might be off a bit due to rounding problems.
                    //
                    dx = (rcClient.right - rcClient.left) - (rc.right - rc.left);
                    dy = (rcClient.bottom - rcClient.top) - (rc.bottom - rc.top);

                    if (dx && abs(dx) <= 2)
                    {
                        rcClient.right = rcClient.left + (rc.right - rc.left);
                        // Fix Save rect too
                        rcSave.right = rcSave.left + (rc.right - rc.left);
                    }

                    if (dy && abs(dy) <= 2)
                    {
                        rcClient.bottom = rcClient.top + (rc.bottom - rc.top);
                        // Fix Save rect, too.
                        rcSave.bottom = rcSave.top + (rc.bottom - rc.top);
                    }
                    //
                    // Try to get the right palette from the client.  If our
                    // presentation data was dithered, or the user asked us to
                    // always use the object palette, then ignore any client
                    // palette.
                    //
#ifdef DEBUG
                    if (GetProfileInt(TEXT("options"), TEXT("UseClientPalette"),
                                      !(gwOptions & OPT_USEPALETTE)))
                        gwOptions &= ~OPT_USEPALETTE;
                    else
                        gwOptions |= OPT_USEPALETTE;
#endif
                    if (!(gwOptions & OPT_USEPALETTE)&& !(gwOptions & OPT_DITHER))
                    {
                        //
                        // Try to get a OWNDC Palette of the client.  PowerPoint
                        // uses a PC_RESERVED palette in "SlideShow" mode, so
                        // we must use its exact palette.
                        //
                        hdc = GetDC(ghwndCntr);
                        hpal = SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);
                        SelectPalette(hdc, hpal, FALSE);
                        ReleaseDC(ghwndCntr, hdc);

                        if (hpal == NULL || hpal==GetStockObject(DEFAULT_PALETTE))
                        {
                            /* Assume client realized the proper palette for us */

                            if (ghpalApp)
                                DeleteObject(ghpalApp);

                            hpal = ghpalApp = CreateSystemPalette();
                        }
                        else
                            DPF("Using clients OWNDC palette\n");

                        if (hpal)
                            SetPaletteMCI(hpal);
                    }
                    else
                        DPF("Using MCI Object's normal palette\n");
                }

                else
                {
                    //
                    // for non window devices, just have the playbar show up!
                    // so use a zero height MCI Window area.
                    //
                    rcSave.top = rcSave.bottom;
                }

                //
                // if we are not in small mode, get there now
                //
                if (!gfPlayOnly)
                {
                    SHOWAPPWINDOW(SW_HIDE);
                    gfPlayOnly = TRUE;
                    SizeMPlayer();
                }

                ClrWS(ghwndApp, WS_THICKFRAME|WS_CAPTION|WS_SYSMENU|WS_MINIMIZEBOX|WS_MAXIMIZEBOX|WS_BORDER);

                if (gwOptions & OPT_BORDER)
                    SetWS(ghwndApp, WS_BORDER);

                /* Set the size of Mplayer to have enough space for the MCI */
                /* playback area and a playbar and the non-client area.     */

                rcSave.bottom += gwPlaybarHeight;

                AdjustWindowRect(&rcSave, (DWORD)GetWS(ghwndApp), FALSE);

                if (!(gwDeviceType & DTMCI_CANWINDOW))
                {
                    rcSave.left += 2*GetSystemMetrics(SM_CXBORDER);
                    rcSave.right -= 2*GetSystemMetrics(SM_CXBORDER);
                }

                PlayInPlace(ghwndApp, hwndClient, &rcSave);

                if (!gfOle2IPEditing)
                    gfCloseAfterPlaying = TRUE;

                fShow = FALSE;
                fActivate = FALSE;

                /* become visible */
                SHOWAPPWINDOW(SW_SHOW);

                /* Remember to play the video in the rcClient area of rcSave */
                if ((gwDeviceType & DTMCI_CANWINDOW) &&
                    (gwOptions & OPT_TITLE) && xIndent != 0)
                    SetDestRectMCI(&rcClient);

                /* Let keyboard interface work on control bar, and let the  */
                /* accelerators go through.                                 */
                toolbarSetFocus(ghwndToolbar, BTN_PLAY);
                SetFocus(ghwndToolbar);

                /* We won't play in place - use a popup window or nothing. */
            }
            else
            {
                /* If we want a playbar, then use MPlayer reduced mode to play. */
                /* If we don't want one, then don't show mplayer's window -     */
                /* we'll just use the default MCI window (for a windowed device)*/
                /* or nothing for a non-windowed device.  If we stole an already*/
                /* running instance of mplayer, we must use it and not run      */
                /* silently.                                                    */

                DPF("DoVerb: Not is play in place stuff ");
                if ((gwOptions & OPT_BAR) || fWindowWasVisible)
                {
                    DPF("Using Toplevel window for playback\n");

                    /* go to our little miniature version */
                    if (!gfPlayOnly && !fWindowWasVisible)
                    {
                        gwPlaybarHeight = TOOLBAR_HEIGHT;
                        gfPlayOnly = TRUE;
                        SizeMPlayer();
                    }

                    fShow = fActivate = TRUE;
                    gfCloseAfterPlaying = !fWindowWasVisible;

                }
                else
                {
                            DPF("Running silently\n");

                    if (!fWindowWasVisible)
                                SetWindowMCI(NULL);
                    // make sure we're using default MCI win

                    fShow = fActivate = FALSE;
                    // DIE when you are done playing
                    gfCloseAfterPlaying = TRUE; // we're invisible, so close auto.
                }
            }

            Yield();    // If play goes to full screen mode, PowerPig will
            Yield();    // time out and put up errors thinking we didn't play.
            PostMessage(ghwndApp, WM_COMMAND, ID_PLAYSEL, 0); // play selection
        }
    }
    else if (verb == verbEdit ||
             verb == verbOpen ||
             verb == OLEIVERB_OPEN ||
             verb == OLEIVERB_SHOW ||
             verb == OLEIVERB_INPLACEACTIVATE ||
             verb == OLEIVERB_UIACTIVATE)
    {
        gfOle1Client = FALSE;
#ifdef DEBUG
        switch(verb)
        {
        case verbEdit: DPFI("VERBEDIT\r\n");break;
        case OLEIVERB_SHOW: DPFI("OLEIVERB_SHOW\r\n");break;
        case OLEIVERB_INPLACEACTIVATE: DPFI("OLEIVERB_IPACTIVATE\r\n");break;
        case OLEIVERB_UIACTIVATE: DPFI("OLEIVERB_UIACTIVATE\r\n");break;
        }
#endif
        // If we are already playing inside an Icon, then restore..
        hwndMCI = GetWindowMCI();
        if (IsWindow(hwndMCI) && IsIconic(hwndMCI))
            SendMessage(hwndMCI, WM_SYSCOMMAND, SC_RESTORE, 0L);

        // If we come up empty, it's OK to be in OPEN or NOT_READY mode
        // and don't try to seek anywhere.
        if (gwDeviceID)
        {
            switch (gwStatus)
            {
            case MCI_MODE_OPEN:
            case MCI_MODE_NOT_READY:
                Error(ghwndApp, IDS_CANTPLAY);
                break;

            default:
                // Seek to the position we were when we copied.
                // Stop first.
                if (StopMCI())
                {
                    // fix state so Seek recognizes we're stopped
                    gwStatus = MCI_MODE_STOP;
                    SeekMCI(gdwPosition);
                }

                break;
            }
        }

        // Let UpdateDisplay set focus properly by saying we're invalid
        // FORCES UPDATE
        gwStatus = (UINT)(-1);
        if (((hpal = PaletteMCI()) != NULL) && ((hwndT = GetActiveWindow()) != NULL))
        {
             hdc = GetDC(hwndT);
             hpal = SelectPalette(hdc, hpal, FALSE);
             SelectPalette(hdc, hpal, FALSE);
             ReleaseDC(hwndT, hdc);
        }

        if (verb == verbOpen || verb == OLEIVERB_OPEN)
        {
            DoInPlaceDeactivate(lpobj);
            gfOle2IPEditing = FALSE;
            gfPlayOnly = FALSE;
            SetWindowPos(ghwndApp, NULL, 0, 0, 0, 0,
                SWP_NOZORDER|SWP_NOSIZE|SWP_NOMOVE|SWP_HIDEWINDOW|SWP_NOACTIVATE);
            SetParent(ghwndApp, NULL);
            PutWS(ghwndApp, WS_THICKFRAME | WS_OVERLAPPED | WS_CAPTION |
                            WS_CLIPCHILDREN | WS_SYSMENU | WS_MINIMIZEBOX);
            TransferTools(ghwndApp);

            if (lpobj->lpoleclient) /* This is NULL if it's the first verb issued to a link */
                IOleClientSite_OnShowWindow(lpobj->lpoleclient, TRUE);
            SendMessage(ghwndTrackbar, TBM_SHOWTICS, TRUE, FALSE);
            gfOle2Open = TRUE;  /* This global is referenced in SizeMPlayer */
            SizeMPlayer();
            SHOWAPPWINDOW(SW_SHOW);
        }
        else if((err = GetScode(DoInPlaceEdit(lpobj, lpmsg, lpActiveSite, verb, &hwndClient,
                    &rcClient))) !=S_OK)
        {
            err = OleQueryObjPos(lpobj, &hwndClient, &rcClient, NULL);
            if (err == S_OK)
            {
                gfOle1Client = TRUE;
            }

            gfOle2IPEditing = FALSE;

            if (gfPlayOnly)
            {
                gfPlayOnly = FALSE;
                SizeMPlayer();
            }
        }
        else
        {
            if (gwOptions & OPT_TITLE)
                gwOptions |= OPT_BAR;
            else
                gwOptions &= ~OPT_BAR;
        }

        if (gfOle2IPEditing && SkipInPlaceEdit)
        {
            gfInPlaceResize = TRUE;
            if(!(gwDeviceType & DTMCI_CANWINDOW) && (gwOptions & OPT_BAR))
            {
                yNow  = rcClient.bottom - rcClient.top;

                if (gwOldHeight)
                {
                    ytitleNow = (int)((long)yNow * gwPlaybarHeight/gwOldHeight);
                    gwPlaybarHeight = max(ytitleNow, TOOLBAR_HEIGHT);
                    gwOldHeight = yNow;
                    rcClient.top = rcClient.bottom - gwPlaybarHeight;
                }
                else
                {
                    gwPlaybarHeight = TOOLBAR_HEIGHT;
                    rcClient.top = rcClient.bottom - gwPlaybarHeight;
                    ytitleNow = rcClient.bottom - rcClient.top;
                    gwOldHeight = yNow;
                }
            }
            if(!(gwDeviceType & DTMCI_CANWINDOW) && !(gwOptions & OPT_BAR))
                rcClient.bottom = rcClient.top = rcClient.left = rcClient.right = 0;

            EditInPlace(ghwndApp, hwndClient, &rcClient);
            Layout();
        }

        else
        if (gfOle2IPEditing && gwDeviceID == (UINT)0 && IsWindow(ghwndFrame))
            EditInPlace(ghwndApp, hwndClient, &rcClient);

        if(gfOle2IPEditing && gwDeviceID != (UINT)0 && !SkipInPlaceEdit)
        {
            gwOldOptions = gwOptions;
            rc = grcSize;   // default playback window size for this movie

            /* If we can't window, or something's wrong, use ICON size */
            if (IsRectEmpty(&rc))
                SetRect(&rc, 0, 0, GetSystemMetrics(SM_CXICON),
            GetSystemMetrics(SM_CYICON));

            /* rcSave is the area for the MCI window above the control bar */
            /* (if we have one).                                           */
            /* rcClient is the area of the MCI window (0 based) to play in.*/
            /* Control bar may be longer than picutre, so rcClient may be  */
            /* smaller than rcSave.                                        */
            rcSave = rcClient;    // remember stretched size

            /* Make rcClient 0 based from rcSave */
            rcClient.left = 0;
            rcClient.right = rcSave.right - rcSave.left;
            rcClient.top = 0;
            rcClient.bottom = rcSave.bottom - rcSave.top;

            /* Assume playbar will be regular height for now */
            if (gwOptions & OPT_BAR)
                gwPlaybarHeight = TOOLBAR_HEIGHT;
            else
                gwPlaybarHeight = 0;

            //
            // munge rectangle to account for a title in the picture
            // and the fact that picture is centred above title.
            // Remember, it's been stretched around.
            //

            if (gwOptions & OPT_TITLE)
            {
                SIZE Size;

                hdc = GetDC(NULL);

                if (ghfontMap)
                    SelectObject(hdc, ghfontMap);

                GetTextExtentPoint32(hdc, gachCaption,
                                     STRLEN(gachCaption), &Size);
                xTextExt = Size.cx;

                ReleaseDC(NULL, hdc);
                if (gwPastedHeight && !(gwDeviceType & DTMCI_CANWINDOW) )
                    yOrig = gwPastedHeight;
                else
                    yOrig = rc.bottom - rc.top;
                xOrig = rc.right - rc.left;
                xtitleOrig = max(xTextExt + 4, xOrig);
                yNow  = rcClient.bottom - rcClient.top;
                xNow  = rcClient.right - rcClient.left;
                if (gwDeviceType & DTMCI_CANWINDOW)
                    ytitleNow = TITLE_HEIGHT;
                else
                {
                    ytitleNow = (int)((long)yNow - ((long)yOrig * yNow)
                                / (yOrig + TITLE_HEIGHT));
                    gwOldHeight = yNow;
                }

                /* for windowed devices, center the playback area above the */
                /* control bar if the control bar is longer.                */
                if (gwDeviceType & DTMCI_CANWINDOW)
                {
                    wWinNow =(int)((long)xOrig * (long)xNow / (long)xtitleOrig);
                    xIndent = (xNow - wWinNow) / 2;
                    rcClient.left += xIndent;
                    rcClient.right = rcClient.left + wWinNow;
                }

                // Align top of control bar with the top of the title bar.
                // The control bar (if there) will appear under rcSave.
                rcClient.bottom = rcClient.top + yNow - ytitleNow;
                rcSave.bottom = rcSave.top + yNow - ytitleNow;

                /* When we make the playbar, make it cover the title */
                /* if the caption was stretched taller than ordinary.*/
                if (gwOptions & OPT_BAR)
                    gwPlaybarHeight = max(ytitleNow, TOOLBAR_HEIGHT);
            }

            /* Enforce a minimum width for the control bar */
#if 0
            /* No, don't, because this screws up PowerPoint, which is usually
             * scaled.  If anything, it would be better to hide the control bar
             * under these circumstances.
             */
            if ((gwOptions & OPT_BAR) &&
                (rcSave.right - rcSave.left < 3 * GetSystemMetrics(SM_CXICON)))
            {
                rcSave.right = rcSave.left + 3 * GetSystemMetrics(SM_CXICON);
                if (gwDeviceType & DTMCI_CANWINDOW)
                    xIndent = TRUE;     // force SetWindowMCI to be called to
                                        // avoid stretching to this new size.
            }
#endif

            if (!(gwOptions & OPT_USEPALETTE)&& !(gwOptions & OPT_DITHER))
            {
                //
                // try to get a OWNDC Palette of the client, PowerPoint
                // uses a PC_RESERVED palette in "SlideShow" mode. so
                // we must use it's exact palette.
                //
                hdc = GetDC(ghwndCntr);
                hpal = SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE),
                                    FALSE);
                SelectPalette(hdc, hpal, FALSE);
                ReleaseDC(ghwndCntr, hdc);

                if (hpal == NULL || hpal==GetStockObject(DEFAULT_PALETTE))
                {
                    /* Assume client realized the proper palette for us */

                    if (ghpalApp)
                        DeleteObject(ghpalApp);

                    hpal = ghpalApp = CreateSystemPalette();
                }
                else
                    DPF("Using clients OWNDC palette\n");

                if (hpal)
                    SetPaletteMCI(hpal);
            }

            else
                DPF("Using MCI Object's normal palette\n");

            ClrWS(ghwndApp, WS_THICKFRAME|WS_CAPTION|WS_SYSMENU|WS_MINIMIZEBOX|WS_MAXIMIZEBOX|WS_BORDER);

            if (gwOptions & OPT_BORDER)
                SetWS(ghwndApp, WS_BORDER);

            /* Set the size of Mplayer to have enough space for the MCI */
            /* playback area and a playbar and the non-client area.     */

            rcSave.bottom += gwPlaybarHeight;
            if(!(gwDeviceType & DTMCI_CANWINDOW) && (gwOptions & OPT_BAR))
                rcSave.top = rcSave.bottom - gwPlaybarHeight;

            AdjustWindowRect(&rcSave, (DWORD)GetWS(ghwndApp), FALSE);
            if(!(gwDeviceType & DTMCI_CANWINDOW) && !(gwOptions & OPT_BAR))
                    rcSave.bottom = rcSave.top = rcSave.left = rcSave.right = 0;

                EditInPlace(ghwndApp, hwndClient, &rcSave);
            /* become visible */
            SHOWAPPWINDOW(SW_SHOW);

            /* Remember to play the video in the rcClient area of rcSave */

            if ((gwDeviceType & DTMCI_CANWINDOW) &&
               (gwOptions & OPT_TITLE) && xIndent != 0)
                    SetDestRectMCI(&rcClient);
        }
    }

    else
    if (verb == verbOpen || verb == OLEIVERB_OPEN)
    {
        DPFI("\n*verbopen");
        DoInPlaceDeactivate(lpobj);

        if (gwDeviceID)
            return ReallyDoVerb(lpobj, verbEdit, lpmsg, lpActiveSite, fShow, fActivate);
    }

    else
    if (verb == OLEIVERB_HIDE)
    {
        DPFI("\n*^*^* OLEVERB_HIDE *^*^");
        DoInPlaceDeactivate(lpobj);
        return S_OK;
    }

    else
    if (verb > 0)
    {
        Result = ReallyDoVerb(lpobj, OLEIVERB_PRIMARY, lpmsg, lpActiveSite, fShow, fActivate);

        if (Result = S_OK)
            Result = OLEOBJ_S_INVALIDVERB;
    }

    else
        return E_NOTIMPL;


    if (fShow )
    {
        if (ghwndMCI || !gfOle2IPEditing)
            SHOWAPPWINDOW(SW_SHOW);

        /* MUST BE A POST or palette realization will not happen properly */
        if (IsIconic(ghwndApp))
            SendMessage(ghwndApp, WM_SYSCOMMAND, SC_RESTORE, 0L);
    }
    if (fActivate )
    {
        BringWindowToTop (ghwndApp);  // let WM_ACTIVATE put client
        SetActiveWindow (ghwndApp);   // underneath us
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\fixreg.h ===
/*-----------------------------------------------------------------------------+
| FIXREG.H                                                                     |
|                                                                              |
| (C) Copyright Microsoft Corporation 1994.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    10-Aug-1994 Lauriegr Created.                                             |
|                                                                              |
+-----------------------------------------------------------------------------*/

/* Call this with the hwnd that you want a WM_BADREG message posted to
   It will check the registry.  No news is good news.
   It does the work on a separate thread, so this should return quickly.
*/
void BackgroundRegCheck(HWND hwnd);

/* Insert the good values into the regtistry
   Call this if you get a WM_BADREG back from BackgroundRegCheck.
*/
BOOL SetRegValues(void);

/* Ignore the registry check
*/
BOOL IgnoreRegCheck(void);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\helpids.h ===
#define IDH_MPLYR_CS_MEDIA_PLAYER_FILE_OPEN			4287
#define IDH_MPLYR_CS_MEDIA_PLAYER_FILE_CLOSE			4288
#define IDH_MPLYR_CS_MEDIA_PLAYER_FILE_EXIT			4289
#define IDH_MPLYR_CS_MEDIA_PLAYER_EDIT_COPY_OBJECT		4290
#define IDH_MPLYR_CS_MEDIA_PLAYER_EDIT_OPTIONS			4291
#define IDH_MPLYR_CS_MEDIA_PLAYER_EDIT_SELECTION		4292
#define IDH_MPLYR_CS_MEDIA_PLAYER_DEVICE_PROPERTIES		4293
#define IDH_MPLYR_CS_MEDIA_PLAYER_DEVICE_VOLUME_CONTROL		4294
#define IDH_MPLYR_CS_MEDIA_PLAYER_SCALE_TIME			4295
#define IDH_MPLYR_CS_MEDIA_PLAYER_SCALE_FRAMES			4296
#define IDH_MPLYR_CS_MEDIA_PLAYER_SCALE_TRACKS			4297
#define IDH_MPLYR_CS_MEDIA_PLAYER_HELP_HELP_TOPICS		4298
#define IDH_MPLYR_CS_MEDIA_PLAYER_HELP_ABOUT			4299
#define IDH_OPT_AUTO                   				4300
#define IDH_OPT_CAPTION              				4301
#define IDH_OPT_BORDER                 				4302
#define IDH_OPT_PLAYCLIENT             				4303
#define IDH_OPT_DITHER             				4304
#define IDH_SELECT_SELECT          				4305
#define IDH_OPT_REPEAT             				4306
#define IDH_OPT_CAPTCONTROL        				4307
#define IDH_SELECT_ALL              				4308
#define IDH_SELECT_NONE              				4309
#define IDH_SELECT_FROM              				4310
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\fixreg.c ===
/*-----------------------------------------------------------------------------+
| FIXREG.C                                                                     |
|                                                                              |
| Publisher and Video For Windows make evil changes to the registry            |
| when they are installed.  Look for these changes.  If they are spotted       |
| then put up a message box to warn the user and offer the user the chance to  |
| correct them (i.e. stuff our version back in)                                |
|                                                                              |
| (C) Copyright Microsoft Corporation 1994.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    10-Aug-1994 Lauriegr Created.                                             |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include "mplayer.h"
#include "fixreg.h"
#include "registry.h"

/* The idea is to call CheckRegValues(hinst) on a separate thread
   (sort of backgroundy thing) and have it just die
   quietly if there's no problem.  If on the other hand there is a problem
   then we need to get the message box up - and it's a VERY BAD IDEA to
   try to put a message box up on anything other than the thread that's doing
   all the UI (otherwise ScottLu will get you with a weasle word - guaranteed).

   So the background thread should PostMessage (Post, don't Send - more weasles)
   to the main thread a message to say "WM_BADREG".  The main thread should then
   wack up the dialog box by calling FixRegValues.

   Suggested coding in main thread:

       BackgroundRegCheck(hwndmain);

   in window proc for hwndmain:
       case WM_HEYUP:
          // if ( IDOK == MessageBox(hwnd, text, appname, MB_OKCANCEL) )
          if ( IDOK == ErrorResBox(hwnd, NULL, MB_OKCANCEL, IDS_APPNAME, IDS_BADREG) )
              if (!SetRegValues())
                  Error(ghwndApp, IDS_FIXREGERROR);
*/

/* This is a reg setting to disable the check. */
extern  SZCODE aszOptionsSection[];
static  SZCODE aszIgnoreRegistryCheck[]   = TEXT("Ignore Registry Check");

/* These are the things we check up.

   First define them as static strings, since the compiler's not smart enough
   to spot common strings.

   NOTE - these values are NOT LOCALISED, except for the ones that are.
*/

#ifdef CHICAGO_PRODUCT
#define APPNAME TEXT("mplayer.exe")
#define WINDIR  TEXT("%s\\")  // To be replaced by Windows directory
LPTSTR pWindowsDirectory = NULL;
#else
#define APPNAME TEXT("mplay32.exe")
#define WINDIR
#endif
TCHAR szMPlayer[]                = TEXT("MPlayer");
TCHAR szMPlayer_CLSID[]          = TEXT("MPlayer\\CLSID");
TCHAR szMPOLE2GUID[]             = TEXT("{00022601-0000-0000-C000-000000000046}");
TCHAR szMPCLSID_OLE1GUID[]       = TEXT("CLSID\\{0003000E-0000-0000-C000-000000000046}");
TCHAR szMPStdExecute_Server[]    = TEXT("MPlayer\\protocol\\StdExecute\\server");
TCHAR szAppName[]                = WINDIR APPNAME;
TCHAR szMPShell_Open_Command[]   = TEXT("MPlayer\\shell\\open\\command");
TCHAR szAppName_Play_Close[]     = WINDIR APPNAME TEXT(" /play /close %1");
TCHAR szMPlayer_insertable[]     = TEXT("MPlayer\\insertable");
TCHAR szEmpty[]                  = TEXT("");
TCHAR szMPStdFileEdit_Handler[]  = TEXT("MPlayer\\protocol\\StdFileEditing\\handler");
#ifdef CHICAGO_PRODUCT
TCHAR szMCIOLE[]                 = WINDIR TEXT("mciole.dll");
#else
TCHAR szMCIOLE16[]               = TEXT("mciole16.dll");
TCHAR szMPStdFileEdit_Hand32[]   = TEXT("MPlayer\\protocol\\StdFileEditing\\handler32");
TCHAR szMCIOLE32[]               = TEXT("mciole32.dll");
#endif
TCHAR szMPStdFileEdit_Package[]  = TEXT("MPlayer\\protocol\\StdFileEditing\\PackageObjects");
TCHAR szMPStdFileEdit_Server[]   = TEXT("MPlayer\\protocol\\StdFileEditing\\server");
TCHAR szMPStdFileEdit_verb_0[]   = TEXT("MPlayer\\protocol\\StdFileEditing\\verb\\0");
TCHAR szMPStdFileEdit_verb_1[]   = TEXT("MPlayer\\protocol\\StdFileEditing\\verb\\1");

/* That sleazebag Publisher setup even farts around with these new settings!!
 */
TCHAR szAVIStdFileEdit_Server[]  = TEXT("AVIFile\\protocol\\StdFileEditing\\server");
TCHAR szMIDStdFileEdit_Server[]  = TEXT("MIDFile\\protocol\\StdFileEditing\\server");
TCHAR szServerAVI[]              = WINDIR APPNAME TEXT(" /avi");
TCHAR szServerMID[]              = WINDIR APPNAME TEXT(" /mid");

/* The following ones DO need to be localised.

   They will be loaded in CheckRegValues.
 */
#define RES_STR_LEN 40  /* Should be enough as a maximum resource string. */
TCHAR szMediaClip[RES_STR_LEN];  // IDS_CLASSROOT in resources
TCHAR sz_Play[RES_STR_LEN];      // IDS_PLAYVERB in resources
TCHAR sz_Edit[RES_STR_LEN];      // IDS_EDITVERB in resources

TCHAR szAviFile[] = TEXT("AVIFile");
TCHAR szMidFile[] = TEXT("MIDFile");


/* Array of registry value-data pairs to check:
 */
LPTSTR RegValues[] =
{
    szMPlayer,                szMediaClip,
    szMPlayer_CLSID,          szMPOLE2GUID,
    szMPCLSID_OLE1GUID,       szMediaClip,
    szMPStdExecute_Server,    szAppName,
    szMPShell_Open_Command,   szAppName_Play_Close,
    szMPlayer_insertable,     szEmpty,
#ifdef CHICAGO_PRODUCT
    szMPStdFileEdit_Handler,  szMCIOLE,
#else
    szMPStdFileEdit_Handler,  szMCIOLE16,
    szMPStdFileEdit_Hand32,   szMCIOLE32,
#endif
    szMPStdFileEdit_Package,  szEmpty,
    szMPStdFileEdit_Server,   szAppName,
    szMPStdFileEdit_verb_0,   sz_Play,
    szMPStdFileEdit_verb_1,   sz_Edit,

    aszKeyAVI,                szAviFile,
    aszKeyMID,                szMidFile,
    aszKeyRMI,                szMidFile,

    szAVIStdFileEdit_Server,  szServerAVI,
    szMIDStdFileEdit_Server,  szServerMID
};


#ifdef CHICAGO_PRODUCT

/* AllocWindowsDirectory
 *
 * Dynamically allocates a string containing the Windows directory.
 * This may be freed using FreeStr().
 *
 */
LPTSTR AllocWindowsDirectory()
{
    UINT   cchWinPath;
    LPTSTR pWindowsDirectory = NULL;

    cchWinPath = GetWindowsDirectory(NULL, 0);

    if (cchWinPath > 0)
    {
        if (pWindowsDirectory = AllocMem(cchWinPath * sizeof(TCHAR)))
        {
            cchWinPath = GetWindowsDirectory(pWindowsDirectory, cchWinPath);

            if (cchWinPath == 0)
            {
                /* Unlikely, but check anyway:
                 */
                DPF0("GetWindowsDiretory failed: Error %d\n", GetLastError());

                *pWindowsDirectory = TEXT('\0');
            }
        }
    }

    return pWindowsDirectory;
}

#endif


/* Check that a REG_SZ value in the registry has the value that it should do
   Return TRUE if it does, FALSE if it doesn't.
*/
BOOL CheckRegValue(HKEY RootKey, LPTSTR KeyName, LPTSTR ShouldBe)
{
    DWORD Type;
    TCHAR Data[100];
    DWORD cData = sizeof(Data);
    LONG lRet;
    HKEY hkey;


    if (ERROR_SUCCESS!=RegOpenKeyEx( RootKey
                                   , KeyName
                                   , 0  /* reserved */
                                   , KEY_QUERY_VALUE
                                   , &hkey
                                   )
       )
        return FALSE;  /* couldn't even open the key */


    lRet=RegQueryValueEx( hkey
                        , NULL /* ValueName */
                        , NULL  /* reserved */
                        , &Type
                        , (LPBYTE)Data
                        , &cData
                        );

    RegCloseKey(hkey);  /* no idea what to do if this fails */

    if (ERROR_SUCCESS!=lRet) return FALSE;  /* couldn't query it */

    /*  Data, cData and Type give the data, length and type */
    if (Type!=REG_SZ) return FALSE;
    lRet = lstrcmpi(Data,ShouldBe);  /* capture lRet to make debug easier */
    return 0==lRet;

} /* CheckRegValue */


/* check the registry for anything evil.  Return TRUE if it's OK else FALSE */
BOOL CheckRegValues(void)
{
    HKEY HCL = HKEY_CLASSES_ROOT;  /* save typing! */

    /* Now just check that the OLE2 class ID is correct
     */
    if( !CheckRegValue( HCL, szMPlayer_CLSID, szMPOLE2GUID ) )
        return FALSE;

    /* Running the old MPlayer on Chicago also screws up the
     * file-extension associations, so make sure they haven't changed:
     */
    if( !CheckRegValue( HCL, aszKeyAVI, szAviFile ) )
        return FALSE;

    return TRUE;

} /* CheckRegValues */


/* start this thread to get the registry checked out.
   hwnd is typed as a LPVOID because that's what CreateThread wants.
*/
DWORD WINAPI RegCheckThread(LPVOID hwnd)
{
   if (!CheckRegValues())
       PostMessage((HWND)hwnd, WM_BADREG, 0, 0);

   return 0;   /* end of thread! */
}


/* Call this with the hwnd that you want a WM_BADREG message posted to
   It will check the registry.  No news is good news.
   It does the work on a separate thread, so this should return quickly.
*/
void BackgroundRegCheck(HWND hwnd)
{
    HANDLE hThread;
    DWORD thid;
    hThread = CreateThread( NULL /* no special security */
                          , 0    /* default stack size */
                          , RegCheckThread
                          , (LPVOID)hwnd
                          , 0 /* start running at once */
                          , &thid
                          );
    if (hThread!=NULL) CloseHandle(hThread);  /* we don't need this any more */

    /* Else we're in some sort of trouble - dunno what to do.
       Can't think of an intelligible message to give to the user.
       Too bad.  Creep home quietly.
    */

} /* BackgroundRegCheck */


/* returns TRUE if it worked.  Dunno what to do if it didn't

*/
BOOL SetRegValue(HKEY RootKey, LPTSTR KeyName, LPTSTR ValueName, LPTSTR ShouldBe)
{
    HKEY hkey;

    if (ERROR_SUCCESS!=RegOpenKeyEx( RootKey
                                   , KeyName
                                   , 0  /* reserved */
                                   , KEY_SET_VALUE
                                   , &hkey
                                   )
       ) {
        /* Maybe the key has been DELETED - we've seen that */
        DWORD dwDisp;
        if (ERROR_SUCCESS!=RegCreateKeyEx( RootKey
                                         , KeyName
                                         , 0  /* reserved */
                                         , TEXT("") /* class */
                                         , REG_OPTION_NON_VOLATILE
                                         , KEY_SET_VALUE
                                         , NULL   /* SecurityAttributes */
                                         , &hkey
                                         , &dwDisp
                                       )
           ) /* well we're really in trouble */
           return FALSE;
        else /* So now it exists, but we now have to open it */
            if (ERROR_SUCCESS!=RegOpenKeyEx( RootKey
                                           , KeyName
                                           , 0  /* reserved */
                                           , KEY_SET_VALUE
                                           , &hkey
                                           )
               ) /* Give up */
                   return FALSE;

    }


    if (ERROR_SUCCESS!=RegSetValueEx( hkey
                                    , ValueName
                                    , 0  /* reserved */
                                    , REG_SZ
                                    , (LPBYTE)ShouldBe
                                    , (lstrlen(ShouldBe)+1)*sizeof(TCHAR)  /* BYTES */
                                    )
       )
        return FALSE;    /* couldn't set it */

    if ( ERROR_SUCCESS!=RegCloseKey(hkey) )
        /* no idea what to do!*/   ;    /* couldn't set it */

    /* I'm NOT calling RegFlushKey.  They'll get there eventually */

    return TRUE;

} /* SetRegValue */


/* Update the registry with the correct values.  Return TRUE if everything succeeds */
BOOL SetRegValues(void)
{
    HKEY HCL = HKEY_CLASSES_ROOT;  /* save typing! */
    DWORD i;
#ifdef CHICAGO_PRODUCT
    TCHAR Buffer[MAX_PATH+40];
#endif

    if( !( LOADSTRING( IDS_CLASSROOT, szMediaClip )
        && LOADSTRING( IDS_PLAYVERB, sz_Play )
        && LOADSTRING( IDS_EDITVERB, sz_Edit ) ) )
        /* If any of the strings fails to load, forget it:
         */
        return TRUE;

#ifdef CHICAGO_PRODUCT
    if (pWindowsDirectory == NULL)
    {
        if ((pWindowsDirectory = AllocWindowsDirectory()) == NULL)
            return TRUE;
    }
#endif

    for( i = 0; i < ( sizeof RegValues / sizeof *RegValues ); i+=2 )
    {
        /* Do a check to see whether this one needs changing,
         * to avoid gratuitous changes, and to avoid the slim chance
         * that an unnecessary SetRegValue might fail:
         */
#ifdef CHICAGO_PRODUCT
        /* Do substitution of Windows directory, if required.
         * This simply copies the value to the buffer unchanged
         * if it doesn't contain a replacement character.
         */
        wsprintf(Buffer, RegValues[i+1], pWindowsDirectory);

        if( !CheckRegValue( HCL, RegValues[i], Buffer ) )
#else
        if( !CheckRegValue( HCL, RegValues[i], RegValues[i+1] ) )
#endif
        {
#ifdef CHICAGO_PRODUCT
            DPF("Fixing the registry: Value - %"DTS"; Data - %"DTS"\n", RegValues[i], Buffer);
            if( !SetRegValue( HCL, RegValues[i], NULL, Buffer ) )
#else
            DPF("Fixing the registry: Value - %"DTS"; Data - %"DTS"\n", RegValues[i], RegValues[i+1]);
            if( !SetRegValue( HCL, RegValues[i], NULL, RegValues[i+1] ) )
#endif
                return FALSE;
        }
    }

#ifdef CHICAGO_PRODUCT
    FreeStr (pWindowsDirectory);
#endif

    return TRUE;

} /* SetRegValues */

BOOL IgnoreRegCheck()
{
    DWORD fIgnore = 0L;
    ReadRegistryData(aszOptionsSection
                     , aszIgnoreRegistryCheck
                     , NULL
                     , (LPBYTE)&fIgnore
                     , sizeof fIgnore);

    return (fIgnore != 0L);

} /* IgnoreRegCheck */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\hatch.c ===
/*
 * HATCH.C
 *
 * Miscellaneous API's to generate hatch window for in-place active
 * objects. This is part of the OLE 2.0 User Interface Support Library.
 *
 * Copyright (c)1993 Microsoft Corporation, All Right Reserved
 */

#define STRICT  1
#include <windows.h>
#ifdef MTN
#pragma warning(disable: 4103)  // used #pragma pack to change alignment (on Chicago)
#endif
#include <ole2.h>
#include "mplayer.h"
#include "ole2ui.h"

// offsets in the extra bytes stored with the hatch window
#define EB_HATCHWIDTH       (0 * sizeof(INT))
#define EB_HATCHRECT_LEFT   (1 * sizeof(INT))
#define EB_HATCHRECT_TOP    (2 * sizeof(INT))
#define EB_HATCHRECT_RIGHT  (3 * sizeof(INT))
#define EB_HATCHRECT_BOTTOM (4 * sizeof(INT))
#define EB_HATCHRECT_HANDLE (5 * sizeof(INT))

// class name of hatch window
static TCHAR szHatchWindow[] = TEXT("Hatch Window");

// local function prototypes
LRESULT FAR PASCAL _EXPORT HatchWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam);

/*
 * HatchRegisterClass
 *
 * Purpose:
 *  Register the hatch window
 *
 * Parameters:
 *  hInst           Process instance
 *
 * Return Value:
 *  TRUE            if successful
 *  FALSE           if failed
 *
 */
STDAPI_(BOOL) RegisterHatchWindowClass(HINSTANCE hInst)
{
    WNDCLASS wc;

    // Register Hatch Window Class
    wc.style = CS_BYTEALIGNWINDOW;
    wc.lpfnWndProc = HatchWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 6 * sizeof(int);    // extra bytes stores
                                        //     uHatchWidth
                                        //     rcHatchRect
    wc.hInstance = hInst;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = szHatchWindow;

    if (!RegisterClass(&wc))
        return FALSE;
    else
        return TRUE;
}


/*
 * CreateHatchWindow
 *
 * Purpose:
 *  Create the hatch window
 *
 * Parameters:
 *  hWndParent          parent of hatch window
 *  hInst               instance handle
 *
 * Return Value:
 *  pointer to hatch window         if successful
 *  NULL                            if failed
 *
 */
STDAPI_(HWND) CreateHatchWindow(HWND hWndParent, HINSTANCE hInst)
{
    HWND         hWnd;

    if (!hWndParent || !hInst)
        return NULL;

    hWnd = CreateWindowEx(
        gfdwFlagsEx,
        szHatchWindow,
        szHatchWindow,
        WS_CHILDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
        0, 0, 0, 0,
        hWndParent,
        (HMENU)NULL,
        hInst,
        0L
    );

    if (!hWnd)
        return NULL;

    return hWnd;
}

/*
 *  GetHatchWidth
 *
 *  Purpose:
 *      Get width of hatch border
 *
 *  Parameters:
 *      hWndHatch       hatch window handle
 *
 *  Return Value:
 *      width of the hatch border
 */
STDAPI_(UINT) GetHatchWidth(HWND hWndHatch)
{
    if (!IsWindow(hWndHatch))
        return 0;

    return (UINT)GETWINDOWUINT(hWndHatch, EB_HATCHWIDTH);
}

/*
 *  GetHatchRect
 *
 *  Purpose:
 *      Get hatch rect. this is the size of the hatch window if it were
 *      not clipped by the ClipRect.
 *
 *  Parameters:
 *      hWndHatch       hatch window handle
 *      lprcHatchRect   hatch rect
 *
 *  Return Value:
 *      none
 */
STDAPI_(void) GetHatchRect(HWND hWndHatch, LPRECT lprcHatchRect)
{
    if (!IsWindow(hWndHatch)) {
        SetRect(lprcHatchRect, 0, 0, 0, 0);
        return;
    }

    lprcHatchRect->left = GETWINDOWUINT(hWndHatch, EB_HATCHRECT_LEFT);
    lprcHatchRect->top = GETWINDOWUINT(hWndHatch, EB_HATCHRECT_TOP);
    lprcHatchRect->right = GETWINDOWUINT(hWndHatch, EB_HATCHRECT_RIGHT);
    lprcHatchRect->bottom = GETWINDOWUINT(hWndHatch, EB_HATCHRECT_BOTTOM);
}


/* SetHatchRect
 *
 *
 *  Purpose:
 *      Store hatch rect with HatchRect window.
 *      this rect is the size of the hatch window if it were
 *      not clipped by the ClipRect.
 *
 *  Parameters:
 *      hWndHatch       hatch window handle
 *      lprcHatchRect   hatch rect
 *
 *  Return Value:
 *      none
 */
STDAPI_(void) SetHatchRect(HWND hWndHatch, LPRECT lprcHatchRect)
{
    if (!IsWindow(hWndHatch))
        return;

    SETWINDOWUINT(hWndHatch, EB_HATCHRECT_LEFT, lprcHatchRect->left);
    SETWINDOWUINT(hWndHatch, EB_HATCHRECT_TOP, lprcHatchRect->top);
    SETWINDOWUINT(hWndHatch, EB_HATCHRECT_RIGHT, lprcHatchRect->right);
    SETWINDOWUINT(hWndHatch, EB_HATCHRECT_BOTTOM, lprcHatchRect->bottom);
    SETWINDOWUINT(hWndHatch, EB_HATCHRECT_HANDLE, 0);
}


/* SetHatchWindowSize
 *
 *
 *  Purpose:
 *      Move/size the HatchWindow correctly given the rect required by the
 *      in-place server object window and the lprcClipRect imposed by the
 *      in-place container. both rect's are expressed in the client coord.
 *      of the in-place container's window (which is the parent of the
 *      HatchWindow).
 *
 *      OLE2NOTE: the in-place server must honor the lprcClipRect specified
 *      by its in-place container. it must NOT draw outside of the ClipRect.
 *      in order to achieve this, the hatch window is sized to be
 *      exactly the size that should be visible (rcVisRect). the
 *      rcVisRect is defined as the intersection of the full size of
 *      the HatchRect window and the lprcClipRect.
 *      the ClipRect could infact clip the HatchRect on the
 *      right/bottom and/or on the top/left. if it is clipped on the
 *      right/bottom then it is sufficient to simply resize the hatch
 *      window. but if the HatchRect is clipped on the top/left then
 *      in-place server document window (child of HatchWindow) must be moved
 *      by the delta that was clipped. the window origin of the
 *      in-place server window will then have negative coordinates relative
 *      to its parent HatchWindow.
 *
 *  Parameters:
 *      hWndHatch       hatch window handle
 *      lprcIPObjRect   full size of in-place server object window
 *      lprcClipRect    clipping rect imposed by in-place container
 *      lpptOffset      offset required to position in-place server object
 *                      window properly. caller should call:
 *                          OffsetRect(&rcObjRect,lpptOffset->x,lpptOffset->y)
 *
 *  Return Value:
 *      none
 */
STDAPI_(void) SetHatchWindowSize(
        HWND        hWndHatch,
        LPCRECT     lprcIPObjRect,
        LPCRECT     lprcClipRect,
        LPPOINT     lpptOffset,
        BOOL        handle
)
{
    RECT        rcHatchRect;
    RECT        rcVisRect;
    UINT        uHatchWidth;
    POINT       ptOffset;

    if (!IsWindow(hWndHatch))
        return;

    rcHatchRect = *lprcIPObjRect;
    uHatchWidth = GetHatchWidth(hWndHatch);

    if (uHatchWidth > 0) // If it's 0, we're hiding the hatch window
        InflateRect((LPRECT)&rcHatchRect, uHatchWidth + 1, uHatchWidth + 1);

    IntersectRect((LPRECT)&rcVisRect, (LPRECT)&rcHatchRect, lprcClipRect);
    MoveWindow(
            hWndHatch,
            rcVisRect.left,
            rcVisRect.top,
            rcVisRect.right-rcVisRect.left,
            rcVisRect.bottom-rcVisRect.top,
            TRUE    /* fRepaint */
    );

    InvalidateRect(hWndHatch, NULL, TRUE);

    ptOffset.x = -rcHatchRect.left + (rcHatchRect.left - rcVisRect.left);
    ptOffset.y = -rcHatchRect.top + (rcHatchRect.top - rcVisRect.top);

    /* convert the rcHatchRect into the client coordinate system of the
    **    HatchWindow itself
    */
    OffsetRect((LPRECT)&rcHatchRect, ptOffset.x, ptOffset.y);

    SetHatchRect(hWndHatch, (LPRECT)&rcHatchRect);

    // calculate offset required to position in-place server doc window
    lpptOffset->x = ptOffset.x;
    lpptOffset->y = ptOffset.y;

//  No size handles:
//  SETWINDOWUINT(hWndHatch, EB_HATCHRECT_HANDLE, handle);
}


/*
 *  HatchWndProc
 *
 *  Purpose:
 *      WndProc for hatch window
 *
 *  Parameters:
 *      hWnd
 *      Message
 *      wParam
 *      lParam
 *
 *  Return Value:
 *      message dependent
 */
LRESULT FAR PASCAL _EXPORT HatchWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
    int nBorderWidth;

    switch (Message) {

        case WM_CREATE:
            nBorderWidth = GetProfileInt(
                TEXT("windows"),
                TEXT("oleinplaceborderwidth"),
                DEFAULT_HATCHBORDER_WIDTH
            );
            SETWINDOWUINT(hWnd, EB_HATCHWIDTH, nBorderWidth);
            break;

        case WM_PAINT:
        {
            HDC hDC;
            PAINTSTRUCT ps;
            RECT rcHatchRect;

            nBorderWidth = GetHatchWidth(hWnd);
            hDC = BeginPaint(hWnd, &ps);

            GetHatchRect(hWnd, (LPRECT)&rcHatchRect);
            OleUIDrawShading(&rcHatchRect, hDC, OLEUI_SHADE_BORDERIN,
                    nBorderWidth);
            InflateRect((LPRECT)&rcHatchRect, -nBorderWidth, -nBorderWidth);
	        if (GETWINDOWUINT(hWnd,EB_HATCHRECT_HANDLE))
		        OleUIDrawHandles(&rcHatchRect, hDC, OLEUI_HANDLES_OUTSIDE,
                                 nBorderWidth+1, TRUE);

            EndPaint(hWnd, &ps);
            break;
        }


        case WM_ERASEBKGND:
            /* If the hatch is hidden, don't bother erasing the background,
             * since the media clip will fill it in.
             */
            if (GETWINDOWUINT(hWnd, EB_HATCHWIDTH) == 0)
                return 1;

            /* Fall through ... */

        default:
            return DefWindowProc(hWnd, Message, wParam, lParam);
    }

    return 0L;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\framebox.h ===
/*-----------------------------------------------------------------------------+
| FRAMEBOX.H                                                                   |
|                                                                              |
| Header file for the FrameBox routines.                                       |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

/* function prototypes */
BOOL FAR PASCAL frameboxInit(HANDLE hInst, HANDLE hPrev);
LONG_PTR FAR PASCAL frameboxSetText(HWND hwnd, LPTSTR lpsz);


/* special messages for FrameBox */
/* Edit box messages go up to WM_USER+34, so this doesn't conflict */
#define FBOX_SETMAXFRAME    (WM_USER+100)





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\framebox.c ===
/*-----------------------------------------------------------------------------+
| FRAMEBOX.C                                                                   |
|                                                                              |
| Code to handle the frame edit boxes for MPlayer.                             |
|                                                                              |
| This code handles the edit box that goes between time, track &               |
| frame view.  When a FrameBox is created we will create an                    |
| Edit box and spin arrows for it.  By checking the                            |
| <gwCurScale> flag we will display text in either frame, track                |
| or in time mode.  The displayed time mode will be HH:MM:SS.ss                |
| Track mode is TT HH:MM:SS or maybe TT MM:SS or something.                    |
| GETTEXT will return a frame number in frame mode or a millisec               |
| value in time or track mode.                                                 |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "mplayer.h"
#include "framebox.h"

extern  int gInc;        // amount spin arrows inc/dec by

#define SPINARROWWIDTH 6 /* In dialog base units */

#define IDC_EDITBOX    5000
#define IDC_SPINARROW  5001

// extra fields in window instance data
#define GWI_EDITBOX     (0 * sizeof(INT)) // edit box window handle
#define GWI_SPINARROWS  (1 * sizeof(INT)) // spinarrow window handle
#define GWL_MAXFRAME    (2 * sizeof(INT)) // max frame value
#define GWI_ALLOCATE    (2 * sizeof(INT) + sizeof(LONG)) // number of BYTEs to allocate

#define GETEDITBOXWND(hwnd) (HWND)GetWindowLongPtr (hwnd, GWI_EDITBOX)
#define GETSPINARRWND(hwnd) (HWND)GetWindowLongPtr (hwnd, GWI_SPINARROWS)

#define SETEDITBOXWND(hwnd, hwndEdit) \
        SETWINDOWUINT(hwnd, GWI_EDITBOX, hwndEdit)
#define SETSPINARRWND(hwnd, hwndArr) \
        SETWINDOWUINT(hwnd, GWI_SPINARROWS, hwndArr)

#define HILIGHTEDITBOX(hwnd) \
        SendMessage(GETEDITBOXWND(hwnd), EM_SETSEL, (WPARAM)0, (LPARAM)(UINT)-1);

#define GETMAXFRAME(hwnd)   (DWORD)GetWindowLongPtr(hwnd, GWL_MAXFRAME)
#define SETMAXFRAME(hwnd, l) SetWindowLongPtr(hwnd, GWL_MAXFRAME, (LONG_PTR)l)

// internal functions
LONG_PTR FAR PASCAL _EXPORT frameboxWndProc(HWND hwnd, unsigned wMsg, WPARAM wParam, LPARAM lParam);

LONG_PTR NEAR PASCAL  frameboxiSetText(HWND hwnd, LPTSTR lpsz);
LONG_PTR NEAR PASCAL  frameboxiGetText(HWND hwnd, UINT_PTR wStrLen, LPTSTR lpsz);
LONG_PTR NEAR PASCAL  frameboxiArrowEdit(HWND hwnd, WPARAM wParam, LONG_PTR lParam);

// strings
TCHAR   szFrameBoxClass[] = TEXT("aviframebox");


/*--------------------------------------------------------------+
| ******************** EXTERNAL FUNCTIONS ********************* |
+--------------------------------------------------------------*/
/*--------------------------------------------------------------+
| frameboxInit() - initialize by registering our class.         |
|                  NOTE: Even if we return FALSE, nobody should |
|                  care, because we don't register these classes|
|                  at AppInit time, but on demand, so only the  |
|                  first call will succeed.  Complain to Todd.  |
|                  (DM).                                        |
|                                                               |
+--------------------------------------------------------------*/
BOOL FAR PASCAL frameboxInit(HANDLE hInst, HANDLE hPrev)
{
  WNDCLASS    cls;

  if (1) {
      cls.hCursor           = LoadCursor(NULL, IDC_ARROW);
      cls.hIcon             = NULL;
      cls.lpszMenuName      = NULL;
      cls.lpszClassName     = szFrameBoxClass;
      cls.hbrBackground     = (HBRUSH)(COLOR_WINDOW + 1);
      cls.hInstance         = ghInst;
      cls.style             = CS_HREDRAW | CS_VREDRAW;
      cls.lpfnWndProc       = frameboxWndProc;
      cls.cbClsExtra        = 0;
      cls.cbWndExtra        = GWI_ALLOCATE;  // room for stuff

      if (!RegisterClass(&cls))
          return FALSE;

      if (!ArrowInit(hInst))
          return FALSE;
  }
  return TRUE;
}

/*--------------------------------------------------------------+
| frameboxSetText() - set the text for the window passed in     |
|                     <hwnd>.                                   |
|                                                               |
+--------------------------------------------------------------*/
LONG_PTR FAR PASCAL frameboxSetText(HWND hwnd, LPTSTR lpsz)
{
    LONG_PTR    l;
    TCHAR       achTimeString[20];
    BOOL        fFrameFormat = (gwCurScale == ID_FRAMES);
    UINT        wCurScaleSave = gwCurScale;

    if (fFrameFormat || *lpsz == TEXT('\0')){
        /* we are in frame format - this is easy and all we need*/
        /* to do is to return what is in the Edit box           */
         l = SendMessage(hwnd, WM_SETTEXT, (WPARAM)0, (LPARAM)lpsz);
    } else {
        /* we are in time/track format - need to convert to a time string */
        /* based on the msec value we have been passed in.                */
        DWORD_PTR        dwmSecs;

        /* get into local buffer */
        lstrcpy((LPTSTR)achTimeString, (LPTSTR)lpsz);
        dwmSecs = (DWORD_PTR)ATOL(achTimeString);

        /* It's meaningless to print track style numbers for the length of  */
        /* the selection, so use ordinary time mode.                        */
        if (GetParent(hwnd) ==
                GetDlgItem(GetParent(GetParent(hwnd)), IDC_EDITNUM))
            gwCurScale = ID_TIME;

        FormatTime(dwmSecs, (LPTSTR)achTimeString, NULL, FALSE);
        gwCurScale = wCurScaleSave;

        /* send it to the control */
        l = SendMessage(hwnd,
                        WM_SETTEXT,
                        (WPARAM)0,
                        (LPARAM)(LPTSTR)achTimeString);
    }
    return l;
}


/*--------------------------------------------------------------+
| *********************** WINDOW PROC ************************* |
+--------------------------------------------------------------*/
/*--------------------------------------------------------------+
| frameboxWndProc - window process to handle the FrameBox       |
|                                                               |
+--------------------------------------------------------------*/
LONG_PTR FAR PASCAL _EXPORT frameboxWndProc(HWND hwnd, unsigned wMsg,
                                        WPARAM wParam, LPARAM lParam)
{
    HWND        hwndNew;
    RECT        rc;
    UINT        wArrowWidth;

    switch(wMsg){
        case WM_CREATE:
            /* create the Edit box and the spin arrows for this */
            /* FrameBox window.                                 */
            GetClientRect(hwnd, (LPRECT)&rc);

            /* Calculate arrow width in pixels */
            wArrowWidth = ((SPINARROWWIDTH * LOWORD(GetDialogBaseUnits()))
                                            / 4) - 1;

            /* create the edit box */

            hwndNew = CreateWindowEx(gfdwFlagsEx,
                                     TEXT("edit"),
                                     TEXT(""),
                                     WS_CHILD|WS_TABSTOP|ES_LEFT|WS_BORDER,
                                     0,
                                     0,
                                     rc.right - wArrowWidth,
                                     rc.bottom,
                                     hwnd,
                                     (HMENU)IDC_EDITBOX,
                                     GETHWNDINSTANCE(hwnd),
                                     0L);

            if (!hwndNew){
                return 0L;
            }
            SETEDITBOXWND(hwnd, hwndNew);

            /* limit this box to 15 chars of input */
            SendMessage(hwndNew, EM_LIMITTEXT, (WPARAM)15, (LPARAM)0L);
            ShowWindow(hwndNew, SW_SHOW);


            /* create the spin arrows */

            hwndNew = CreateWindowEx(gfdwFlagsEx,
                                     TEXT("comarrow"),
                                     TEXT(""),
                                     WS_CHILD|WS_TABSTOP|WS_BORDER,
                                     rc.right - wArrowWidth,
                                     0,
                                     wArrowWidth,
                                     rc.bottom,
                                     hwnd,
                                     (HMENU)IDC_SPINARROW,
                                     GETHWNDINSTANCE(hwnd),
                                     0L);

            if (!hwndNew){
                return 0L;
            }
            SETSPINARRWND(hwnd, hwndNew);
            ShowWindow(hwndNew, SW_SHOW);

            /* set the max to be the end of the media by default */
            SETMAXFRAME(hwnd, (DWORD)(gdwMediaStart + gdwMediaLength));
            break;


        case WM_DESTROY:
            /* Delete the Edit box and the spin arrows */
            DestroyWindow(GETEDITBOXWND(hwnd));
            DestroyWindow(GETSPINARRWND(hwnd));
            break;

        case WM_SETFONT:
            return SendMessage(GETEDITBOXWND(hwnd), wMsg, wParam, lParam);

        case WM_SETFOCUS:
            /* when we get the focus just send it on to the edit control */
            SetFocus(GETEDITBOXWND(hwnd));
            break;

        case WM_SETTEXT:
            /* set the text which is a frame number or time in  */
            /* msec to be a frame or time mode string           */
            return frameboxiSetText(hwnd, (LPTSTR)lParam);

        case WM_GETTEXT:
            /* get the text from the Edit box and translate to a */
            /* frame number or time in msec.                     */
            return frameboxiGetText(hwnd, wParam, (LPTSTR)lParam);

        case WM_VSCROLL:
            /* handle the scrolling via spin arrows */
            return frameboxiArrowEdit(hwnd, wParam, lParam);

        case WM_COMMAND:
            switch (LOWORD(wParam) ){
                case IDC_EDITBOX:
                    // route editbox messages back to our parent

                    SendMessage(GetParent(hwnd),
                                WM_COMMAND,
                                GETWINDOWID(hwnd),
                                lParam);

                    break;
            }
            break;

        case EM_SETSEL:
            /* Perhaps we should only let this through if the caller
            ** is trying to select the entire contents of the edit box,
            ** because otherwise we'll have to map the range.
            */
            SendMessage(GETEDITBOXWND(hwnd), wMsg, wParam, lParam);
            break;

#pragma message("Should we be supporting other EM_* messages?")

        /* handle special case messages for the FrameBox control */
        case FBOX_SETMAXFRAME:
            /* set the max frames to allow spin arrows to go */
            SETMAXFRAME(hwnd, lParam);
            break;

        default:
            return(DefWindowProc(hwnd, wMsg, wParam, lParam));
            break;

    }
    return (0L);
}

/*--------------------------------------------------------------+
| ******************** INTERNAL FUNCTIONS ********************* |
+--------------------------------------------------------------*/
/*--------------------------------------------------------------+
| frameboxiSetText() - handle setting the text depending on if  |
|                        we are in time or frame format.        |
|                                                               |
+--------------------------------------------------------------*/
LONG_PTR NEAR PASCAL  frameboxiSetText(HWND hwnd, LPTSTR lpsz)
{
    LONG_PTR l;

/* We want to set the text even if it's identical because someone might */
/* have typed 03 06:00 and if track 3 if only 4 minutes long we want it */
/* to change to 04 02:00.  Clever, eh?                                  */
#if 0
    TCHAR ach[12];

    /* see if we are setting the same string as what is there  */
    /* and just don't do it if so to avoid flicker.            */
    l = frameboxiGetText(hwnd, CHAR_COUNT(ach), (LPTSTR)ach);
    if (lstrcmp((LPTSTR)ach, lpsz) == 0)
        goto HighLight;
#endif

    /* call generic function to handle this */
    l = frameboxSetText(GETEDITBOXWND(hwnd), lpsz);

#if 0
HighLight:
#endif
    /* now let's highlight the whole thing */
    HILIGHTEDITBOX(hwnd);

    return l;
}


#define IsCharNumeric( ch ) ( IsCharAlphaNumeric( ch ) && !IsCharAlpha( ch ) )

/*--------------------------------------------------------------+
| frameboxiGetText() - handle getting the text depending on if  |
|                      we are in time or frame format. Either   |
|                      returns a frame number or msec number    |
|                      depending on the mode.                   |
|                                                               |
+--------------------------------------------------------------*/
LONG_PTR NEAR PASCAL  frameboxiGetText(HWND hwnd, UINT_PTR wStrLen, LPTSTR lpsz)
{
    UINT    wCurScaleSave = gwCurScale;

    if (gwCurScale == ID_FRAMES) {
        LPTSTR   p;
        LPTSTR   pStart;
        UINT     w;

        /* we are in frame format - this is easy and all we need*/
        /* to do is to return what is in the Edit box           */
        if (GetWindowText(GETEDITBOXWND(hwnd), lpsz, (int)wStrLen) == 0)
            goto LB_Error;

        /* cut through leading white space */
        for (pStart = lpsz; *pStart == TEXT(' ') || *pStart == TEXT('\t'); pStart++)
            ;

        /* now rip out trailing white space */
        if (*pStart) {    // don't backtrack before beginning of string
            for (p=pStart; *p; p++)
                ;
            for (--p; *p == TEXT(' ') || *p == TEXT('\t'); --p)
                ;
            *++p = TEXT('\0');
        }

        // make sure digits only were entered
        for (p=pStart, w=0; *p; p++, w++)
            if (!IsCharNumeric(*p))
                goto LB_Error;

        // copy over only the part you need and return #chars
        lstrcpy(lpsz, pStart);
        return w;

    } else {
        /* we are in time or track format - we need to convert the time */
        /* to msec.                                                     */
        PTSTR   pStart;         // pointer to achTime buffer
        TCHAR   achTime[20];    // buffer for time string (input)
        DWORD   dwmSecs;        // total mSecs for this thing */
        TCHAR   *pDelim;        // pointer to next delimeter
        TCHAR   *p;             // general pointer
        DWORD   dwTrack = 0;    // track number
        DWORD   dwHours = 0;    // # of hours
        DWORD   dwMins = 0;     // # of minutes
        DWORD   dwSecs = 0;     // # of seconds
        DWORD    wmsec = 0;      // # hundredths
        DWORD    w;

        /* It's meaningless to use track style numbers for the length of    */
        /* the selection, so use ordinary time mode.                        */
        if (hwnd == GetDlgItem(GetParent(hwnd), IDC_EDITNUM))
            gwCurScale = ID_TIME;

        /* get the string from the edit box */
        SendMessage(GETEDITBOXWND(hwnd),
                    WM_GETTEXT,
                    (WPARAM)CHAR_COUNT(achTime),
                    (LPARAM)(LPTSTR) achTime);

        if (achTime[0] == TEXT('\0'))
            goto LB_Error;       // bad char so error out

        /* go past any white space up front */
        for (pStart = achTime; *pStart == TEXT(' ') || *pStart == TEXT('\t'); pStart++)
            ;

        /* now rip out trailing white space */
        if (*pStart) {          // don't backtrack before beginning of string
            for (p=pStart; *p; p++)
                ;
            for (--p; *p == TEXT(' ') || *p == TEXT('\t'); --p)
                ;
            *++p = TEXT('\0');
        }

        /* We're in track mode so peel the track number off the front */
        if (gwCurScale == ID_TRACKS) {

            /* First non-digit better be a space */
            for (p = pStart; *p && *p != TEXT(' '); p++){
                if (!IsCharNumeric(*p))
                    goto LB_Error;    // bad char so error out
            }

            /* It is, so just grab the first numeric and use the rest of */
            /* the string as the time.                                   */
            dwTrack = ATOI(pStart);
            if ((int)dwTrack < (int)gwFirstTrack || dwTrack >= gwFirstTrack +
                                                                gwNumTracks)
                goto LB_Error;

            /* Now bypass the spaces between track number and time */
            pStart = p;
            while (*pStart == TEXT(' '))
                pStart++;

            /* There is nothing after the track number.  Use it. */
            if (*pStart == TEXT('\0'))
                goto MAKETOTAL;

        }

        /* rip through the whole string and look for illegal chars */
        for (p = pStart; *p ; p++){
            if (!IsCharNumeric(*p) && *p != chDecimal && *p != chTime)
                goto LB_Error;       // bad char so error out
        }

/*
 * The reason for the slightly odd "if" statements of the form:
 *
 *       if (pDelim) {
 *           if (*pDelim){
 *
 * is because strchr(...) returns an offset OR NULL. As this is then promptly
 * dereferenced to see what character (if any) is there we have a problem.
 * Win16 is allows this sort of thing, but Win32
 * will generate an address exception post haste...
 *
 * Hence we try to do it properly.
 *
 */

        /* go find the milliseconds portion if it exists */
        pDelim = STRCHR(pStart, chDecimal);
        if (pDelim) {
            if (*pDelim){
                p = STRRCHR(pStart, chDecimal);
                if (pDelim != p){
                    goto LB_Error;       // string has > 1 '.', return error
                }
                p++;                     // move up past delim
                if (STRLEN(p) > 3)
                    *(p+3) = TEXT('\0'); // knock off all but thousandths
                wmsec = ATOI(p);         // get the fractional part
                if (STRLEN(p) == 1)     // adjust to a millisecond value
                    wmsec *= 100;
                if (STRLEN(p) == 2)
                    wmsec *= 10;
                *pDelim = TEXT('\0');    // null out this terminator
            }
        }

        /* try and find seconds */
        pDelim = STRRCHR(pStart, chTime);    // get last ':'
        if (pDelim) {
            if (*pDelim)
                p = (pDelim+1);
            else
                p = pStart;
            dwSecs = ATOI(p);

            if (*pDelim)
                *pDelim = TEXT('\0');
            else
                goto MAKETOTAL;
        } else {
            p = pStart;
            dwSecs = ATOI(p);

            goto MAKETOTAL;
        }

        /* go and get the minutes part */
        pDelim = STRRCHR(pStart, chTime);
        if (pDelim) {
            if (*pDelim)
                p = (pDelim + 1);
            else {
                p = pStart;
                dwMins = ATOI(p);
            }
        } else {
            p = pStart;
            dwMins = ATOI(p);
        }

        if (pDelim)
            if (*pDelim)
                *pDelim = TEXT('\0');
            else
                goto MAKETOTAL;
        else
            goto MAKETOTAL;


        /* get the hours */
        p = pStart;
        dwHours = ATOI(p);

MAKETOTAL:
        /* now we've got the hours, minutes, seconds and any        */
        /* fractional part.  Time to build up the total time        */

        dwSecs += (dwHours * 3600);   // add in hours worth of seconds
        dwSecs += (dwMins * 60);      // add in minutes worth of seconds
        dwmSecs = (dwSecs * 1000L) + wmsec;

        /* For track mode, this is an offset into a track, so add track start */
        if (gwCurScale == ID_TRACKS) {
            dwmSecs += gadwTrackStart[dwTrack - 1];
        }

        /* build this into a string */
        wsprintf(achTime, TEXT("%ld"), dwmSecs);
        w = STRLEN(achTime);

        if (wCurScaleSave)
            gwCurScale = wCurScaleSave;

        /* copy to user buffer and return */
        lstrcpy(lpsz, achTime);
        return w;

LB_Error:
        gwCurScale = wCurScaleSave;
        return LB_ERR;
    }
}


/*--------------------------------------------------------------+
| frameboxiArrowEdit() - handle the spin arrows for msec mode.  |
|                                                               |
+--------------------------------------------------------------*/
LONG_PTR NEAR PASCAL  frameboxiArrowEdit(HWND hwnd, WPARAM wParam, LONG_PTR lParam)
{
        TCHAR        achTime[20];
        DWORD        dwmSecs, dwStart, dwEnd;

        if (hwnd == GetDlgItem(GetParent(hwnd), IDC_EDITNUM)) {
            dwStart = 0;
            dwEnd = gdwMediaLength;
        } else {
            dwStart = gdwMediaStart;
            dwEnd = GETMAXFRAME(hwnd);
        }

        frameboxiGetText(hwnd, CHAR_COUNT(achTime), (LPTSTR)achTime);
        dwmSecs = ATOL(achTime);
        if (LOWORD(wParam) == SB_LINEUP){
            if ((long)dwmSecs >= (long)dwStart - gInc &&
                                (long)dwmSecs < (long)dwEnd) {
                dwmSecs += gInc;
                wsprintf(achTime, TEXT("%ld"), dwmSecs);
                /* bring focus here NOW! so update works */
                SendMessage(hwnd,
                            WM_NEXTDLGCTL,
                            (WPARAM)GETEDITBOXWND(hwnd),
                            (LPARAM)1L);
                frameboxSetText(GETEDITBOXWND(hwnd), (LPTSTR)achTime);
                /* now let's highlight the whole thing */

                HILIGHTEDITBOX(hwnd);

            } else
                MessageBeep(MB_ICONEXCLAMATION);
        } else if (LOWORD(wParam) == SB_LINEDOWN){
            if ((long)dwmSecs > (long)dwStart &&
                        (long)dwmSecs <= (long)dwEnd + gInc) {
                if ((long)dwmSecs - gInc < (long)dwStart)
                    dwmSecs = dwStart;
                else
                    dwmSecs -= gInc;
                wsprintf(achTime, TEXT("%ld"), dwmSecs);
                /* bring focus here NOW! so update works */
                SendMessage(hwnd,
                            WM_NEXTDLGCTL,
                            (WPARAM)GETEDITBOXWND(hwnd),
                            (LPARAM)1L);
                frameboxSetText(GETEDITBOXWND(hwnd), (LPTSTR)achTime);
                /* now let's highlight the whole thing */

                HILIGHTEDITBOX(hwnd);

            } else
                MessageBeep(MB_ICONEXCLAMATION);
        }
        // now update the world by sending the proper message

        SendMessage(GetParent(hwnd),
                    WM_COMMAND,
                    (WPARAM)MAKELONG((WORD)GETWINDOWID(hwnd), EN_KILLFOCUS),
                    (LPARAM)hwnd);

        return dwmSecs;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\init.c ===
/*-----------------------------------------------------------------------------+
| INIT.C                                                                       |
|                                                                              |
| This file houses the discardable code used at initialisation time. Among     |
| other things, this code reads .INI information and looks for MCI devices.    |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

/* include files */

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <stdlib.h>

#include <shellapi.h>
#include "mpole.h"
#include "mplayer.h"
#include "toolbar.h"
#include "registry.h"

DWORD   gfdwFlagsEx;

static SZCODE   aszMPlayer[]          = TEXT("MPlayer");

extern char szToolBarClass[];  // toolbar class

/*
 * Static variables
 *
 */

HANDLE  ghInstPrev;

TCHAR   gachAppName[40];            /* string holding the name of the app.    */
TCHAR   gachClassRoot[48];     /* string holding the name of the app. */
TCHAR   aszNotReadyFormat[48];
TCHAR   aszReadyFormat[48];
TCHAR   aszDeviceMenuSimpleFormat[48];
TCHAR   aszDeviceMenuCompoundFormat[48];
TCHAR   gachOpenExtension[5] = TEXT("");/* Non-null if a device extension passed in */
TCHAR   gachOpenDevice[128] = TEXT(""); /* Non-null if a device extension passed in */
TCHAR   gachProgID[128] = TEXT("");
CLSID   gClsID;
CLSID   gClsIDOLE1Compat;           /* For writing to IPersist - may be MPlayer's   */
                                    /* OLE1 class ID or same as gClsID.             */

TCHAR   gszMPlayerIni[40];          /* name of private .INI file              */
TCHAR   gszHelpFileName[_MAX_PATH]; /* name of the help file                  */
TCHAR   gszHtmlHelpFileName[_MAX_PATH]; /* name of the html help file         */

PTSTR   gpchFilter;                 /* GetOpenFileName() filter */
PTSTR   gpchInitialDir;             /* GetOpenFileName() initial directory */

RECT    grcSave;    /* size of mplayer before shrunk to */
                    /* play only size.                  */

int 	giDefWidth;

extern BOOL gfSeenPBCloseMsg;       //TRUE if the subclasses PlayBack WIndow Proc
                                    //has seen the WM_CLOSE message
////////////////////////////////////////////
// these strings *must* be in DGROUP!
static TCHAR    aszNULL[]       = TEXT("");
static TCHAR    aszAllFiles[]   = TEXT("*.*");
////////////////////////////////////////////

// strings for registration database - also referenced from fixreg.c
SZCODE aszKeyMID[]      = TEXT(".mid");
SZCODE aszKeyRMI[]      = TEXT(".rmi");
SZCODE aszKeyAVI[]      = TEXT(".avi");
SZCODE aszKeyMMM[]      = TEXT(".mmm");
SZCODE aszKeyWAV[]      = TEXT(".wav");

static  SZCODE aszFormatExts[]   = TEXT("%s;*.%s");
static  SZCODE aszFormatExt[]    = TEXT("*.%s");
static  SZCODE aszFormatFilter[] = TEXT("%s (%s)");
static  SZCODE aszPositionFormat[]= TEXT("%d,%d,%d,%d");

static  SZCODE aszSysIniTime[]      = TEXT("SysIni");
static  SZCODE aszDisplayPosition[] = TEXT("DisplayPosition");
        SZCODE aszOptionsSection[]  = TEXT("Options");
static  SZCODE aszShowPreview[]     = TEXT("ShowPreview");
static  SZCODE aszWinIni[]          = TEXT("win.ini");
        SZCODE aszIntl[]            = TEXT("intl");
        TCHAR  chDecimal            = TEXT('.');   /* localised in AppInit, GetIntlSpecs */
        TCHAR  chTime               = TEXT(':');   /* localised in AppInit, GetIntlSpecs */
        TCHAR  chLzero              = TEXT('1');

static SZCODE   gszWinIniSection[]  = TEXT("MCI Extensions"); /* section name in WIN.INI*/
static SZCODE   aszSystemIni[]      = TEXT("SYSTEM.INI");

#ifdef CHICAGO_PRODUCT
static SZCODE   gszSystemIniSection[] = TEXT("MCI");
#else
static SZCODE   gszSystemIniSection[] = MCI_SECTION;
#endif

static SZCODE   aszBlank[] = TEXT(" ");

static SZCODE   aszDecimalFormat[] = TEXT("%d");
static SZCODE   aszTrackClass[] = TEXT("MPlayerTrackMap");

extern HMENU    ghMenu;                      /* handle to main menu           */
extern HMENU    ghDeviceMenu;                /* handle to the Device menu     */
extern UINT     gwCurScale;                  /* current scale style           */
extern HANDLE   hAccel;
extern int      gcAccelEntries;


/* private function prototypes */
void  NEAR PASCAL QueryDevices(void);
void  NEAR PASCAL BuildDeviceMenu(void);
void  NEAR PASCAL ReadDefaults(void);
void  NEAR PASCAL BuildFilter(void);
BOOL PostOpenDialogMessage(void);

extern  BOOL InitServer(HWND, HANDLE);
extern  BOOL InitInstance (HANDLE);

/**************************************************************************

ScanCmdLine  checks first for the following options
-----------
    Open
    Play Only
    Close After Playing
    Embedded (play as a server)
    If the embedded flag is set, then the play only is also set.
    It then removes these options from the cmd line
    If no filename is present then turn close option off, and set the play
    option to have the same value as the embedded option
    If /WAVE, /MIDI or /VFW is specified along with /file,
    the file extension must match, otherwise the app exits.


MPLAYER command options.

        MPLAYER [/open] [/play] [/close] [/embedding] [/WAV] [/MID] [/AVI] [file]

            /open       open file if specified, otherwise put up dialog.
            /play       play file right away.
            /close      close after playing. (only valid with /play)
            /embedding  run as an OLE server.
            /WAV        open a wave file \
            /MID        open a midi file  > Valid with /open
            /AVI        open an AVI file /
            [file]      file or device to open.

***************************************************************************/

static  SZCODE aszEmbedding[]         = TEXT("Embedding");
static  SZCODE aszPlayOnly[]          = TEXT("Play");
static  SZCODE aszClose[]             = TEXT("Close");
static  SZCODE aszOpen[]              = TEXT("Open");
static  SZCODE aszWAVE[]              = TEXT("WAVE");
static  SZCODE aszMIDI[]              = TEXT("MIDI");
static  SZCODE aszVFW[]               = TEXT("VFW");

BOOL NEAR PASCAL ScanCmdLine(LPTSTR szCmdLine)
{
    int         i;
    TCHAR       buf[100];
    LPTSTR      sz=szCmdLine;

    gfPlayOnly = FALSE;
    gfCloseAfterPlaying = FALSE;
    gfRunWithEmbeddingFlag = FALSE;

    while (*sz == TEXT(' '))
        sz++;

    while (*sz == TEXT('-') || *sz == TEXT('/')) {

        for (i=0,sz++; *sz && *sz != TEXT(' ') && (i < 99); buf[i++] = *sz++)
            ;
        buf[i++] = 0;

        if (!lstrcmpi(buf, aszPlayOnly)) {
            gfPlayOnly = TRUE;
        }

        if (!lstrcmpi(buf, aszOpen))
            gfOpenDialog = TRUE;

        /* Check for open option, but accept only the first: */

        if (!gachOpenDevice[0]
           && (GetProfileString(gszWinIniSection, buf, aszNULL, gachOpenDevice,
                                CHAR_COUNT(gachOpenDevice)) > 0))
        {
            /* Take a copy of the extension, which we will use to find stuff
             * in the registry relating to OLE:
             */
            gachOpenExtension[0] = TEXT('.');
            lstrcpy(&gachOpenExtension[1], buf);
        }

        if (!lstrcmpi(buf, aszClose))
            gfCloseAfterPlaying = TRUE;

        if (!lstrcmpi(buf, aszEmbedding))
            gfRunWithEmbeddingFlag = TRUE;

        if (gfRunWithEmbeddingFlag) {
            gfPlayOnly = TRUE;
        }

        while (*sz == TEXT(' '))
            sz++;
    }

    /*
    ** Do we have a long file name with spaces in it ?
    ** This is most likely to have come from the FileMangler.
    ** If so copy the file name without the quotes.
    */
    if ( *sz == TEXT('\'') || *sz == TEXT('\"') ) {

        TCHAR ch = *sz;   // Remember which quote character it was
        // According to the DOCS " is invalid in a filename...

        i = 0;
        /* Move over the initial quote, then copy the filename */
        while ( *++sz && *sz != ch ) {

            szCmdLine[i++] = *sz;
        }

        szCmdLine[i] = TEXT('\0');

    }
    else {

        lstrcpy( szCmdLine, sz );     // remove options
    }

    // It's assumed that OLE2 servers don't accept file name
    // with -Embedding.
    // (Not doing this caused Win95 bug 4096 with OLE1 apps,
    // because MPlayer loaded the file, and, in the meantime,
    // OLE called PFLoad, resulting in OpenMCI being called
    // recursively.)
    if (gfRunWithEmbeddingFlag)
        szCmdLine[0] = TEXT('\0');

    //
    // if there's /play, make sure there's /open
    // (this may affect the checks below)
    //
    if (gfPlayOnly && !gfRunWithEmbeddingFlag)
        gfOpenDialog = TRUE;

    //
    // if no file specifed ignore the /play option
    //
    if (szCmdLine[0] == 0 && !gfOpenDialog) {
        gfPlayOnly = gfRunWithEmbeddingFlag;
    }

    //
    // if file specifed ignore the /open option
    //
    if (szCmdLine[0] != 0) {
        gfOpenDialog = FALSE;
    }

    if (!gfPlayOnly && szCmdLine[0] == 0)
        gfCloseAfterPlaying = FALSE;

    SetEvent(heventCmdLineScanned);

    return gfRunWithEmbeddingFlag;
}


BOOL ResolveIfLink(PTCHAR szFileName);


BOOL ProgIDFromExtension(LPTSTR szExtension, LPTSTR szProgID, DWORD BufSize /* in BYTES */)
{
    DWORD Status;
    HKEY  hkeyExtension;
    BOOL  rc = FALSE;
    DWORD Type;
    DWORD Size;

    Status = RegOpenKeyEx( HKEY_CLASSES_ROOT, szExtension, 0,
                           KEY_READ, &hkeyExtension );

    if (Status == NO_ERROR)
    {
        Size = BufSize;

        Status = RegQueryValueEx( hkeyExtension,
                                  aszNULL,
                                  0,
                                  &Type,
                                  (LPBYTE)szProgID,
                                  &Size );

        if (Status == NO_ERROR)
        {
            rc = TRUE;
        }
        else
        {
            DPF0("Couldn't find ProgID for extension %"DTS"\n", szExtension);
        }

        RegCloseKey(hkeyExtension);
    }

    return rc;
}


BOOL GetClassNameFromProgID(LPTSTR szProgID, LPTSTR szClassName, DWORD BufSize /* in BYTES */)
{
    DWORD Status;
    HKEY  hkeyProgID;
    BOOL  rc = FALSE;
    DWORD Type;
    DWORD Size;

    Status = RegOpenKeyEx( HKEY_CLASSES_ROOT, szProgID, 0,
                           KEY_READ, &hkeyProgID );

    if (Status == NO_ERROR)
    {
        Size = BufSize;

        Status = RegQueryValueEx( hkeyProgID,
                                  aszNULL,
                                  0,
                                  &Type,
                                  (LPBYTE)szClassName,
                                  &Size );

        if (Status == NO_ERROR)
        {
            DPF1("Found Class Name %"DTS" for ProgID %"DTS"\n", szClassName, szProgID);
            rc = TRUE;
        }
        else
        {
            DPF0("Couldn't find Class Name for ProgID %"DTS"\n", szProgID);
        }

        RegCloseKey(hkeyProgID);
    }

    return rc;
}


/**************************************************************************
***************************************************************************/
BOOL FAR PASCAL ProcessCmdLine(HWND hwnd, LPTSTR szCmdLine)
{
    BOOL   f;
    LPTSTR lp;
    SCODE  status;
    CLSID  ClsID;
    LPWSTR pUnicodeProgID;

    if (gfRunWithEmbeddingFlag)
    {
        srvrMain.cRef++;

        gClsID = CLSID_MPLAYER;
        gClsIDOLE1Compat = CLSID_OLE1MPLAYER;

        if (*gachOpenExtension)
        {
            /* We accept as a parameter the extension of a registered type.
             * If we can find a corresponding Prog ID in the registry and
             * a class ID, we register ourselves with that class ID:
             */
            if(ProgIDFromExtension(gachOpenExtension, gachProgID, CHAR_COUNT(gachProgID)))
            {
#ifndef UNICODE
                pUnicodeProgID = AllocateUnicodeString(gachProgID);
#else
                pUnicodeProgID = gachProgID;
#endif
                if (CLSIDFromProgID(pUnicodeProgID, &ClsID) == S_OK)
                {
                    /* No OLE1 compatibility for this class:
                     */
                    gClsID = gClsIDOLE1Compat = ClsID;
                }
                else
                {
                    DPF0("Couldn't get CLSID for %"DTS"\n", gachProgID);
                }
#ifndef UNICODE
                FreeUnicodeString(pUnicodeProgID);
#endif
            }
        }

        if (*gachProgID)
            GetClassNameFromProgID(gachProgID, gachClassRoot, CHAR_COUNT(gachClassRoot));
        else
            LOADSTRING(IDS_CLASSROOT, gachClassRoot);

        status = GetScode(CoRegisterClassObject(&gClsID, (IUnknown FAR *)&srvrMain,
                                                CLSCTX_LOCAL_SERVER,
                                                REGCLS_SINGLEUSE, &srvrMain.dwRegCF));

        DPF("CoRegisterClassObject\n");
        srvrMain.cRef--;
        if (status  != S_OK)
        {
            DPF0("CoRegisterClassObject failed with error %08x\n", status);

            return FALSE;
        }
    }
    else
        InitNewDocObj(&docMain);

    if (gfRunWithEmbeddingFlag)
        SetEmbeddedObjectFlag(TRUE);

    if (*szCmdLine != 0)
    {
        HCURSOR    hcurPrev;

        InitDeviceMenu();
        hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));
        WaitForDeviceMenu();
        SetCursor(hcurPrev);

        ResolveIfLink(szCmdLine);

        /* Change trailing white space to \0 because mci barfs on filenames */
        /* with trailing whitespace.                                        */
        for (lp = szCmdLine; *lp; lp++);
        for (lp--; *lp == TEXT(' ') || *lp == TEXT('\t'); *lp = TEXT('\0'), lp--);

        f = OpenMciDevice(szCmdLine, NULL);

        if (f)
            CreateDocObjFromFile(szCmdLine, &docMain);

        if (gfRunWithEmbeddingFlag && !f) {
            DPF0("Error opening link, quiting...");
            PostMessage(ghwndApp, WM_CLOSE, 0, 0);
        }

        SetMPlayerIcon();

        return f;
    }

    return TRUE;
}


/**************************************************************************
***************************************************************************/

/* At time of writing, this stuff isn't in Daytona;
 */
#ifndef WS_EX_LEFTSCROLLBAR
#define WS_EX_LEFTSCROLLBAR   0
#define WS_EX_RIGHT           0
#define WS_EX_RTLREADING      0
#endif

BOOL FAR PASCAL AppInit(HANDLE hInst, HANDLE hPrev, LPTSTR szCmdLine)
{
    WNDCLASS    cls;    /* window class structure used for initialization     */
    TCHAR       ach[80];
    HCURSOR     hcurPrev;           /* the pre-hourglass cursor   */

    /* Get the debug level from the WIN.INI [Debug] section. */

#ifdef DEBUG
     if(__iDebugLevel == 0) // So we can set it in the debugger
          __iDebugLevel = GetProfileIntA("Debug", "MPlayer", 0);
      DPF("debug level %d\n", __iDebugLevel);
#endif

    DPF("AppInit: cmdline = '%"DTS"'\n", (LPTSTR)szCmdLine);

    /* Save the instance handle in a global variable for later use. */

    ghInst     = hInst;


    /* Retrieve the RTL state of the binary */

    LOADSTRING(IDS_IS_RTL, ach);
    gfdwFlagsEx = (ach[0] == TEXT('1')) ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0;

    LOADSTRING(IDS_MPLAYERWIDTH, ach);
    giDefWidth = ATOI(ach);
    if (giDefWidth <= 0)	//bogus
    	giDefWidth = DEF_WIDTH;

    /* Retrieve the name of the application and store it in <gachAppName>. */

    if (!LOADSTRING(IDS_APPNAME, gachAppName))
        return Error(ghwndApp, IDS_OUTOFMEMORY);

    LOADSTRING(IDS_DEVICEMENUCOMPOUNDFORMAT, aszDeviceMenuCompoundFormat);
    LOADSTRING(IDS_DEVICEMENUSIMPLEFORMAT, aszDeviceMenuSimpleFormat);
    LOADSTRING(IDS_NOTREADYFORMAT, aszNotReadyFormat);
    LOADSTRING(IDS_READYFORMAT, aszReadyFormat);
    LoadStatusStrings();

    //
    // read needed things from the [Intl] section of WIN.INI
    //
    GetIntlSpecs();

    /* Enable / disable the buttons, and display everything */
    /* unless we were run as an OLE server....*/

    ScanCmdLine(szCmdLine);
    gszCmdLine = szCmdLine;

    //Truncate if string is longer than MAX_PATH after ScanCmdLine()
    // due to the inability to handle longer strings in following modules
    if (STRLEN(gszCmdLine) >= MAX_PATH)
    {
        gszCmdLine[MAX_PATH - 1] = TEXT('\0');
    }

    if (!toolbarInit() ||
        !InitMCI(hPrev, hInst)    ||
        !ControlInit (hInst)) {

        Error(NULL, IDS_OUTOFMEMORY);
        return FALSE;
    }

    if (!(hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(MPLAYERACCEL)))) {
        Error(NULL, IDS_OUTOFMEMORY);
        return FALSE;
    }

    /* This rather obscure call is to get the number of entries
     * in the accelerator table to pass to IsAccelerator.
     * It isn't entirely obvious why IsAccelerator needs to be
     * told how many entries there are.
     */
    if (gfRunWithEmbeddingFlag)
        gcAccelEntries = CopyAcceleratorTable(hAccel, NULL, 0);

    /* Make the dialog box's icon identical to the MPlayer icon */

    hiconApp = LoadIcon(ghInst, MAKEINTRESOURCE(APPICON));

    if (!hPrev) {

        cls.lpszClassName   = aszTrackClass;
        cls.lpfnWndProc     = fnMPlayerTrackMap;
        cls.style           = CS_VREDRAW;
        cls.hCursor         = LoadCursor(NULL,IDC_ARROW);
        cls.hIcon           = NULL;
        cls.lpszMenuName    = NULL;
        cls.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1);
        cls.hInstance       = ghInst;
        cls.cbClsExtra      = 0;
        cls.cbWndExtra      = 0;

        RegisterClass(&cls);

        /*
         * Initialize and register the "MPlayer" class.
         *
         */
        cls.lpszClassName   = aszMPlayer;
        cls.lpfnWndProc     = MPlayerWndProc;
        cls.style           = CS_VREDRAW;
        cls.hCursor         = LoadCursor(NULL,IDC_ARROW);
        cls.hIcon           = hiconApp;
        cls.lpszMenuName    = NULL;
        cls.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1);
        cls.hInstance       = ghInst;
        cls.cbClsExtra      = 0;
        cls.cbWndExtra      = DLGWINDOWEXTRA;

        RegisterClass(&cls);
    }

    // set ghInstPrev to the handle of the first mplayer instance by
    // FindWindow (hPrev will always be NULL). This global is checked
    // by window positioning code to behave differently for the second
    // and subsequent instances - so make sure it is NULL in the first case
    // and non-null in the others.
    // note we can't check for the window title, only the class, since
    // in play-only mode, the window title is *just* the name of the file.
    ghInstPrev = FindWindow(aszMPlayer, NULL);


    /*
     * Retain a pointer to the command line parameter string so that the player
     * can automatically open a file or device if one was specified on the
     * command line.
     *
     */

    if(!InitInstance (hInst))
        return FALSE;

    gwHeightAdjust = 2 * GetSystemMetrics(SM_CYFRAME) +
                     GetSystemMetrics(SM_CYCAPTION) +
                     GetSystemMetrics(SM_CYBORDER) +
                     GetSystemMetrics(SM_CYMENU);

    /* create the main (control) window                   */


    ghwndApp = CreateWindowEx(gfdwFlagsEx,
                              aszMPlayer,
                              gachAppName,
                              WS_THICKFRAME | WS_OVERLAPPED | WS_CAPTION |
                              WS_CLIPCHILDREN | WS_SYSMENU | WS_MINIMIZEBOX,
                              CW_USEDEFAULT,
                              0,
                              giDefWidth,
                              MAX_NORMAL_HEIGHT + gwHeightAdjust,
                              NULL,   // no parent
                              NULL,   // use class menu
                              hInst,  // instance
                              NULL);  // no data
    if (!ghwndApp) {
        DPF0("CreateWindowEx failed for main window: Error %d\n", GetLastError());
        return FALSE;
    }

    DPF("\n**********After create set\n");
/****
  Removed from WM_CREATE so that it can be called similar to the way sdemo1
  i.e. after the create window call has completed
      May be completely unnecessary
*****/

    /* Process dragged and dropped file */
    DragAcceptFiles(ghwndApp, TRUE);

    /* We will check that this has been filled in before calling
     * CoDisconnectObject.  It should be non-null if an instance of the OLE
     * server has been created.
     */
    docMain.hwnd = NULL;

    /* Initialize the OLE server if appropriate.
     * If we don't initialize OLE here, a Copy will cause it to be initialized:
     */
    if (gfRunWithEmbeddingFlag)
    {
        if (InitOLE(&gfOleInitialized, &lpMalloc))
            InitServer(ghwndApp, ghInst);
        else
            return FALSE;
    }

    if (!gfRunWithEmbeddingFlag && (!gfPlayOnly || gszCmdLine[0]==0) && !gfOpenDialog)
    {
        ShowWindow(ghwndApp,giCmdShow);
        if (giCmdShow != SW_SHOWNORMAL)
            Layout();
        UpdateDisplay();
        UpdateWindow(ghwndApp);
    }

    /* Show the 'Wait' cursor in case this takes a long time */

    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    /*
     * Read the SYSTEM.INI and MPLAYER.INI files to see what devices
     * are available.
     */
    if (gfPlayOnly)
        garMciDevices[0].wDeviceType  = DTMCI_CANPLAY | DTMCI_FILEDEV;

    //
    // this may open a file....
    //

    if (!ProcessCmdLine(ghwndApp,gszCmdLine)) {
        DPF0("ProcessCmdLine failed\n");
        return FALSE;
    }

    /* Restore the original cursor */
    if (hcurPrev)
        SetCursor(hcurPrev);


    /* Check for options to put up initial dialog etc.:
     */
    if (gfOpenDialog)
    {
        if (!PostOpenDialogMessage())
        {
            PostMessage(ghwndApp, WM_CLOSE, 0, 0);
            return FALSE;
        }
    }


    /* The "Play" button should have the focus initially */

    if (!gfRunWithEmbeddingFlag && !gfOpenDialog)
    {
        //SetFocus(ghwndToolbar); //setting focus messes up the menu access
								  //using the ALT key

                                // HACK!!! Want play button
        if (gfPlayOnly) {

            if (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW)) {
                gfPlayOnly = FALSE;
                SizeMPlayer();
            }

            ShowWindow(ghwndApp,giCmdShow);

            if (giCmdShow != SW_SHOWNORMAL)
                Layout();

            /* stop any system sound from playing so the MCI device
               can have it HACK!!!! */
            sndPlaySound(NULL, 0);

            if (gwDeviceID)
                PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAY, 0);
        }
    }

    return TRUE;
}


/* PostOpenDialogMessage
 *
 * This routine is called if /open was in the command line.
 * If there was also an open option (/MIDI, /VFW or /WAVE in the command line,
 * it causes an Open dialog to be displayed, as would appear via the Device menu.
 * Otherwise it simulates File.Open.
 *
 * When this is called, the main window is hidden.  The window must be made
 * visible when the dialog is dismissed.  Calling CompleteOpenDialog(TRUE)
 * will achieve this.
 *
 * Returns TRUE if a message was posted, otherwise FALSE.
 *
 *
 * Global variables referenced:
 *
 *     gachOpenExtension
 *     ghwndApp
 *
 *
 * Andrew Bell, 1 July 1994
 *
 */
BOOL PostOpenDialogMessage( )
{
    BOOL Result = TRUE;

    InitDeviceMenu();
    WaitForDeviceMenu();

    if (*gachOpenExtension)
    {
        if (gwNumDevices)
        {
            /* If we've got here, the user specified a device, and that's
             * the only one the Device menu lists, so go ahead and open it:
             */
            PostMessage(ghwndApp, WM_COMMAND, IDM_DEVICE0 + 1, 0);
        }
        else
        {
            /* Couldn't find a device.  Put up an error message then close
             * MPlayer down:
             */
            SendMessage(ghwndApp, WM_NOMCIDEVICES, 0, 0);

            Result = FALSE;
        }
    }
    else
    {
        /* No option specified, so put up the generic open dialog:
         */
        PostMessage(ghwndApp, WM_COMMAND, IDM_OPEN, 0);
    }

    return Result;
}


/* CompleteOpenDialog
 *
 * This should be called after the initial Open dialog (i.e. if gfOpenDialog
 * is TRUE).  It makes MPlayer visible if a file was selected, otherwise posts
 * a close message to the app.
 *
 *
 * Global variables referenced:
 *
 *     ghwndApp
 *     gfOpenDialog
 *     gfPlayOnly
 *
 *
 * Andrew Bell, 1 July 1994
 */
VOID FAR PASCAL CompleteOpenDialog(BOOL FileSelected)
{
    if (FileSelected)
    {
        /* We were invoked with /open, and came up invisible.
         * Now make ourselves visible:
         */
        gfOpenDialog = FALSE; // Used on init only
        ShowWindow(ghwndApp, SW_SHOWNORMAL);
        if (gfPlayOnly)
            PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAY, 0);
    }
    else
    {
        /* We were invoked with /open, and user cancelled
         * out of the open dialog.
         */
        PostMessage(ghwndApp, WM_CLOSE, 0, 0);
    }
}



void SubClassTrackbarWindow();
void CreateControls()
{
    int         i;

    #define APP_NUMTOOLS 7

    static  int aiButton[] = { BTN_PLAY, BTN_STOP,BTN_EJECT,
                               BTN_HOME, BTN_RWD, BTN_FWD,BTN_END};

    /*
     * CREATE THE CONTROLS NEEDED FOR THE CONTROL PANEL DISPLAY
     * in the proper order so tabbing z-order works logically
     */

/******* Make the Track bar ********/

    if (!ghwndTrackbar)
    ghwndTrackbar = CreateWindowEx(gfdwFlagsEx,
                             TRACKBAR_CLASS,
                             NULL,
                             TBS_ENABLESELRANGE |
                             (gfPlayOnly ? TBS_BOTH | TBS_NOTICKS : 0 ) |
                             WS_CLIPSIBLINGS | WS_CHILD | WS_VISIBLE | WS_TABSTOP,
                             0,
                             0,
                             0,
                             0,
                             ghwndApp,
                             NULL,
                             ghInst,
                             NULL);


    SubClassTrackbarWindow();


/******* Make the TransportButtons Toolbar ********/
    if (!ghwndToolbar) {

    ghwndToolbar =  toolbarCreateMain(ghwndApp);
#if 0 //VIJR-TB

    CreateWindowEx(gfdwFlagsEx,
                   szToolBarClass,
                   NULL,
                   WS_CHILD | WS_VISIBLE | WS_TABSTOP |
                   WS_CLIPSIBLINGS,
                   0,
                   0,
                   0,
                   0,
                   ghwndApp,
                   NULL,
                   ghInst,
                   NULL);
#endif
        /* set the bitmap and button size to be used for this toolbar */
#if 0 //VIJR-TB
        pt.x = BUTTONWIDTH;
        pt.y = BUTTONHEIGHT;
        toolbarSetBitmap(ghwndToolbar, ghInst, IDBMP_TOOLBAR, pt);
#endif
        for (i = 0; i < 2; i++) {
            toolbarAddTool(ghwndToolbar, aiButton[i], TBINDEX_MAIN, BTNST_UP);
        }
    }

    /* Create a font for use in the track map and embedded object captions. */

    if (ghfontMap == NULL) {
        LOGFONT lf;
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), (LPVOID)&lf,
                             0);
        ghfontMap = CreateFontIndirect(&lf);
    }

/******* we have been here before *******/
    if (ghwndFSArrows)
        return;

/******* add more buttons to the toolbar ******/
    for (i = 2; i < APP_NUMTOOLS; i++) {
        if (i==3)
            toolbarAddTool(ghwndToolbar, BTN_SEP, TBINDEX_MAIN, 0);
        toolbarAddTool(ghwndToolbar, aiButton[i], TBINDEX_MAIN, BTNST_UP);
    }

/******* load menus ********/
    /* Set up the menu system for this dialog */
    if (ghMenu == NULL)
        ghMenu = LoadMenu(ghInst, aszMPlayer);

    ghDeviceMenu = GetSubMenu(ghMenu, 2);

/******* Make the Arrows for the Scrollbar Toolbar ********/

    // No tabstop, because arrows would steal focus from thumb
    ghwndFSArrows = toolbarCreateArrows(ghwndApp);
#if 0 //VIJR-TB

    CreateWindowEx(gfdwFlagsEx,
                   szToolBarClass,
                   NULL,
                   WS_CLIPSIBLINGS | WS_CHILD|WS_VISIBLE,
                   0,
                   0,
                   0,
                   0,
                   ghwndApp,
                   NULL,
                   ghInst,
                   NULL);
#endif
    /* set the bmp and button size to be used for this toolbar*/
    toolbarAddTool(ghwndFSArrows, ARROW_PREV, TBINDEX_ARROWS, BTNST_UP);
    toolbarAddTool(ghwndFSArrows, ARROW_NEXT, TBINDEX_ARROWS, BTNST_UP);

/******* Make the Mark In / Mark Out toolbar ********/

    ghwndMark =  toolbarCreateMark(ghwndApp);
#if 0 //VIJR-TB
    CreateWindowEx(gfdwFlagsEx,
                   szToolBarClass,
                   NULL,
                   WS_TABSTOP | WS_CLIPSIBLINGS | WS_CHILD |
                   WS_VISIBLE,
                   0,
                   0,
                   0,
                   0,
                   ghwndApp,
                   NULL,
                   ghInst,
                   NULL);
#endif
    /* set the bmp and button size to be used for this toolbar */
    toolbarAddTool(ghwndMark, BTN_MARKIN, TBINDEX_MARK, BTNST_UP);
    toolbarAddTool(ghwndMark, BTN_MARKOUT, TBINDEX_MARK, BTNST_UP);

/******* Make the Map ********/
    ghwndMap =
    CreateWindowEx(gfdwFlagsEx,
                   TEXT("MPlayerTrackMap"),
                   NULL,
                   WS_GROUP | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
                   0,
                   0,
                   0,
                   0,
                   ghwndApp,
                   NULL,
                   ghInst,
                   NULL);

#if DBG
    if( ghwndMap == NULL)
    {
        DPF0( "CreateWindowEx(MPlayerTrackMap, ...) failed: Error %d\n", GetLastError());
    }
#endif

/******* Make the Static Text ********/

    ghwndStatic = CreateStaticStatusWindow(ghwndApp, FALSE);
#if 0    //VIJR-SB
    CreateWindowEx(gfdwFlagsEx,
                   TEXT("SText"),
                   NULL,
                   WS_GROUP | WS_CHILD | WS_VISIBLE |
                   WS_CLIPSIBLINGS | SS_LEFT,
                   0,
                   0,
                   0,
                   0,
                   ghwndApp,
                   NULL,
                   ghInst,
                   NULL);
#endif
////SetWindowText(ghwndStatic, TEXT("Scale: Time (hh:mm)"));

    SendMessage(ghwndStatic, WM_SETFONT, (UINT_PTR)ghfontMap, 0);
}

void FAR PASCAL InitMPlayerDialog(HWND hwnd)
{
    ghwndApp = hwnd;

    CreateControls();

    /* Get the name of the Help and ini file */

    LOADSTRING(IDS_INIFILE, gszMPlayerIni);
    LOADSTRING(IDS_HELPFILE,gszHelpFileName);
    LOADSTRING(IDS_HTMLHELPFILE,gszHtmlHelpFileName);

    ReadDefaults();


}


/* Use a default size or the size we pass in to size mplayer.
 * For PlayOnly version, this size is the MCI Window Client size.
 * For regular mplayer, this is the full size of the main window.
 * If we are inplace editing do the same as for PLayOnly.
 */
void FAR PASCAL SetMPlayerSize(LPRECT prc)
{
    RECT rc;
    UINT w=SWP_NOMOVE;

    if (prc && !IsRectEmpty(prc))
        rc = *prc;
    else if (gfPlayOnly || gfOle2IPEditing)
        rc = grcSize;
    else
        SetRect(&rc, 0, 0, giDefWidth, DEF_HEIGHT);

    //
    //  if the passed rectangle has a non zero (left,top) move MPlayer
    //  also (ie remove the SWP_NOMOVE flag)
    //
    if (rc.left != 0 || rc.top != 0)
        w = 0;

    if (gfPlayOnly || gfOle2IPEditing) {
        if (IsRectEmpty(&rc)) {
            GetClientRect(ghwndApp, &rc);
            rc.bottom = 0;
        }

        rc.bottom += TOOLBAR_HEIGHT;

        AdjustWindowRect(&rc,
                         (DWORD)GetWindowLongPtr(ghwndApp, GWL_STYLE),
                         GetMenu(ghwndApp) != NULL);
    }
    else
       if (gfWinIniChange)
       AdjustWindowRect(&rc,
                         (DWORD)GetWindowLongPtr(ghwndApp, GWL_STYLE),
             GetMenu(ghwndApp) != NULL);

    SetWindowPos(ghwndApp,
                 HWND_TOP,
                 rc.left,
                 rc.top,
                 rc.right-rc.left,
                 rc.bottom-rc.top,
                 w | SWP_NOZORDER | SWP_NOACTIVATE);
}


/* InitDeviceMenuThread
 *
 * This is now executed as a separate thread.
 * On completion, sets the event so that the File and Device menus
 * can be accessed.
 * If, after querying the devices, we find none, post a message to
 * the main window to inform it.
 */
void InitDeviceMenuThread(LPVOID pUnreferenced)
{
    UNREFERENCED_PARAMETER(pUnreferenced);

    /* Wait until the command line has been scanned:
     */
    WaitForSingleObject(heventCmdLineScanned, INFINITE);

    /* We don't need this event any more:
     */
    CloseHandle(heventCmdLineScanned);

    if (ghMenu == NULL) {
        ghMenu = LoadMenu(ghInst, aszMPlayer);
        ghDeviceMenu = GetSubMenu(ghMenu, 2);
    }

    QueryDevices();
    BuildDeviceMenu();
    BuildFilter();

    if (gwDeviceID)
        FindDeviceMCI();

    SetEvent(heventDeviceMenuBuilt);

    if (gwNumDevices == 0)
        PostMessage(ghwndApp, WM_NOMCIDEVICES, 0, 0);

    ExitThread(0);
}

/* InitDeviceMenu
 *
 * Initialize and build the Devices menu.
 *
 * This now spins off a separate thread to enable the UI to come up
 * more quickly.  This is especially important when there is a slow
 * CD device installed, though crappy CD drivers which run single threaded
 * at dispatch level will still give performance degradation.
 *
 * If the user selects either the File or the Device menu, the UI
 * must wait until the device menu has been built.  Typically this
 * should not be longer than about 2 seconds after the app started.
 *
 */
void FAR PASCAL InitDeviceMenu()
{
    DWORD       ThreadID;
    HANDLE      hThread;
    static BOOL CalledOnce = FALSE;

    /* This should only ever be called by the main thread, so we don't need
     * to protect access to CalledOnce:
     */
    if (CalledOnce == FALSE)
    {
        CalledOnce = TRUE;

#ifdef DEBUG
        if (WaitForSingleObject(heventDeviceMenuBuilt, 0) == WAIT_OBJECT_0)
            DPF0("Expected heventDeviceMenuBuilt to be non-signaled\n");
#endif
        hThread = CreateThread(NULL,    /* Default security attributes */
                               0,       /* Stack size same as primary thread's */
                               (LPTHREAD_START_ROUTINE)InitDeviceMenuThread,
                               NULL,    /* Parameter to start routine */
                               0,       /* Thread runs immediately */
                               &ThreadID);

        if(hThread)
            CloseHandle(hThread);
        else
        {
            DPF0("CreateThread failed");

            /* This is unlikely to happen, but the only thing to do
             * is set the event, so that the UI doesn't hang.
             */
            SetEvent(heventDeviceMenuBuilt);

            /* What if SetEvent failed?!
             */
        }
    }
}


/* WaitForDeviceMenu
 *
 * This routine calls MsgWaitForMultipleObjects instead of WaitForSingleObject
 * because some MCI devices do things like realizing palettes, which may
 * require some messages to be dispatched.  Otherwise we can hit a deadlock.
 *
 * Andrew Bell (andrewbe), 8 April 1995
 */
void WaitForDeviceMenu()
{
    DWORD Result;

    while ((Result = MsgWaitForMultipleObjects(1,
                                               &heventDeviceMenuBuilt,
                                               FALSE,
                                               INFINITE,
                                               QS_ALLINPUT)) != WAIT_OBJECT_0)
    {
        MSG msg;

        if (Result == (DWORD)-1)
        {
            DPF0("MsgWaitForMultipleObjects failed: Error %d\n", GetLastError());
            return;
        }

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            DispatchMessage(&msg);
    }
}



/*
 * SizeMPlayer()
 *
 */
void FAR PASCAL SizeMPlayer()
{
    RECT        rc;
    HWND        hwndPB;

    if(!gfOle2IPEditing)
        CreateControls();

    if (gfPlayOnly) {

        /* Remember our size before we shrink it so we can go back to it. */
        GetWindowRect(ghwndApp, &grcSave);

        SetMenu(ghwndApp, NULL);

        SendMessage(ghwndTrackbar, TBM_CLEARTICS, FALSE, 0);

        /* Next preserve the current size of the window as the size */
        /* for the new built-in MCI window.                         */

        if ((hwndPB = GetWindowMCI()) != NULL) {
            if (IsIconic(hwndPB))
                ShowWindow(hwndPB, SW_RESTORE);

            GetClientRect(hwndPB, &rc);
            ClientToScreen(hwndPB, (LPPOINT)&rc);
            ClientToScreen(hwndPB, (LPPOINT)&rc+1);
            ShowWindowMCI(FALSE);
        } else {        // not a windowed device?
            SetRectEmpty(&rc);
        }

        if (ghwndMap) {

            //If we are inplace editing set the toolbar control states appropriately.
            if(!gfOle2IPEditing) {

                ShowWindow(ghwndMap, SW_HIDE);
                ShowWindow(ghwndMark, SW_HIDE);
                ShowWindow(ghwndFSArrows, SW_HIDE);
                ShowWindow(ghwndStatic, SW_HIDE);
                ShowWindow(ghwndTrackbar, SW_SHOW);

                toolbarModifyState(ghwndToolbar, BTN_EJECT, TBINDEX_MAIN, BTNST_GRAYED);
                toolbarModifyState(ghwndToolbar, BTN_HOME, TBINDEX_MAIN, BTNST_GRAYED);
                toolbarModifyState(ghwndToolbar, BTN_END, TBINDEX_MAIN, BTNST_GRAYED);
                toolbarModifyState(ghwndToolbar, BTN_RWD, TBINDEX_MAIN, BTNST_GRAYED);
                toolbarModifyState(ghwndToolbar, BTN_FWD, TBINDEX_MAIN, BTNST_GRAYED);
                toolbarModifyState(ghwndMark, BTN_MARKIN, TBINDEX_MARK, BTNST_GRAYED);
                toolbarModifyState(ghwndMark, BTN_MARKOUT, TBINDEX_MARK, BTNST_GRAYED);
                toolbarModifyState(ghwndFSArrows, ARROW_PREV, TBINDEX_ARROWS, BTNST_GRAYED);
                toolbarModifyState(ghwndFSArrows, ARROW_NEXT, TBINDEX_ARROWS, BTNST_GRAYED);

            } else {

                ShowWindow(ghwndMap, SW_SHOW);
                ShowWindow(ghwndMark, SW_SHOW);
                ShowWindow(ghwndFSArrows, SW_SHOW);
                ShowWindow(ghwndStatic, SW_SHOW);
            }
        }

        SendMessage(ghwndTrackbar, TBM_SHOWTICS, FALSE, FALSE);
        CreateWindowMCI();
        SetMPlayerSize(&rc);

    } else {

        if (ghwndMCI) {
            GetClientRect(ghwndMCI, &rc);
            ClientToScreen(ghwndMCI, (LPPOINT)&rc);
            ClientToScreen(ghwndMCI, (LPPOINT)&rc+1);

            /*
            **  Make sure our hook proc doesn't post IDM_CLOSE!
            **  The WM_CLOSE message will set the playback window back
            **  to the video playback window by calling SetWindowMCI(NULL);
            */
            gfSeenPBCloseMsg = TRUE;
            SendMessage(ghwndMCI, WM_CLOSE, 0, 0);
            /*
            **  Subclass the real video window now.  This will also set
            **  gfSeenPBCloseMsg to FALSE.
            */
            SubClassMCIWindow();


        } else {

            GetWindowRect(ghwndApp,&rc);
            OffsetRect(&grcSave, rc.left - grcSave.left,
                                 rc.top - grcSave.top);
            SetRectEmpty(&rc);
        }

        SendMessage(ghwndTrackbar, TBM_SHOWTICS, TRUE, FALSE);
        ShowWindow(ghwndMap, SW_SHOW);
        ShowWindow(ghwndMark, SW_SHOW);
        ShowWindow(ghwndStatic, SW_SHOW);

        /* If we remembered a size, use it, else use default */
        SetMPlayerSize(&grcSave);

        InvalidateRect(ghwndStatic, NULL, TRUE);    // why is this necessary?

        if (gwDeviceID && (gwDeviceType & DTMCI_CANWINDOW)) {

        /* make the playback window the size our MCIWindow was and */
        /* show the playback window and stretch to it ?            */

            if (!IsRectEmpty(&rc))
                PutWindowMCI(&rc);

            SmartWindowPosition(GetWindowMCI(), ghwndApp, gfOle2Open);

            ShowWindowMCI(TRUE);
            SetForegroundWindow(ghwndApp);
        }

        ShowWindow(ghwndFSArrows, SW_SHOW);
    }

    InvalidateRect(ghwndApp, NULL, TRUE);
    gfValidCaption = FALSE;

    gwStatus = (UINT)(-1);          // force a full update
    UpdateDisplay();
}


/*
 * pKeyBuf = LoadProfileKeys(lszProfile, lszSection)
 *
 * Load the keywords from the <szSection> section of the Windows profile
 * file named <szProfile>.  Allocate buffer space and return a pointer to it.
 * On failure, return NULL.
 *
 * The INT pointed to by pSize will be filled in with the size of the
 * buffer returned, so that checks for corruption can be made when it's freed.
 */

PTSTR NEAR PASCAL LoadProfileKeys(

LPTSTR   lszProfile,                 /* the name of the profile file to access */
LPTSTR   lszSection,                 /* the section name to look under         */
PUINT    pSize)
{
    PTSTR   pKeyBuf;                /* pointer to the section's key list      */
    PTSTR   pKeyBufNew;
    UINT    wSize;                  /* the size of <pKeyBuf>                  */

////DPF("LoadProfileKeys('%"DTS"', '%"DTS"')\n", (LPTSTR) lszProfile, (LPTSTR)lszSection);

    /*
     * Load all keynames present in the <lszSection> section of the profile
     * file named <lszProfile>.
     *
     */

    wSize = 256;                    /* make a wild initial guess */
    pKeyBuf = NULL;                 /* the key list is initially empty */

    do {
        /* (Re)alloc the space to load the keynames into */

        if (pKeyBuf == NULL)
            pKeyBuf = AllocMem(wSize);
        else {
            pKeyBufNew = ReallocMem( (HANDLE)pKeyBuf, wSize, wSize + 256);
            if (NULL == pKeyBufNew) {
                FreeMem((HANDLE)pKeyBuf, wSize);
            }
            pKeyBuf = pKeyBufNew;
            wSize += 256;
        }

        if (pKeyBuf == NULL)        /* the (re)alloc failed */
            return NULL;

        /*
         * THIS IS A WINDOWS BUG!!!  It returns size minus two!!
         * (The same feature is present in Windows/NT)
         */

    } while (GetPrivateProfileString(lszSection, NULL, aszNULL, pKeyBuf, wSize/sizeof(TCHAR),
        lszProfile) >= (wSize/sizeof(TCHAR) - 2));

    if (pSize)
        *pSize = wSize;

    return pKeyBuf;
}



/*
 * QueryDevices(void)
 *
 * Find out what devices are available to the player. and initialize the
 * garMciDevices[] array.
 *
 */
void NEAR PASCAL QueryDevices(void)
{
    PTSTR   pch;
    PTSTR   pchDevices;
    PTSTR   pchExtensions;
    PTSTR   pchDevice;
    PTSTR   pchExt;

    TCHAR   ach[1024];  /*1024 is the maximum buffer size for a wsprintf call*/

    UINT    wDeviceType;    /* Return value from DeviceTypeMCI() */

    INT     DevicesSize;
    INT     ExtensionsSize;

    if (gwNumDevices > 0)
        return;

    /*
     * make device zero be the autoopen device.
     * its device name will be "" and the files it supports will be "*.*"
     */
    LOADSTRING(IDS_ALLFILES, ach);

    garMciDevices[0].wDeviceType  = DTMCI_CANPLAY | DTMCI_FILEDEV;
    garMciDevices[0].szDevice     = aszNULL;
    garMciDevices[0].szDeviceName = AllocStr(ach);
    garMciDevices[0].szFileExt    = aszAllFiles;

    gwNumDevices = 0;

    /* Load the SYSTEM.INI [MCI] section */

    /* If the user specified a device to open, build a string containing
     * that device alone, and don't bother looking in the registry
     * (or system.ini in the case of Win95) for the MCI devices.
     */
    if (*gachOpenDevice)
    {
        LPTSTR pDevice;
        DWORD DeviceLength;

        pDevice = gachOpenDevice;
        DeviceLength = STRING_BYTE_COUNT(pDevice);
        DevicesSize = ((DeviceLength + 1) * sizeof *pchDevice);

        if (pchDevices = AllocMem(DevicesSize))
            CopyMemory(pchDevices, pDevice, DevicesSize);
    }
    else
    {
        pchDevices = AllocMem(DevicesSize = 256);
        if (pchDevices)
            QueryDevicesMCI(pchDevices, DevicesSize);
    }

    pchExtensions = LoadProfileKeys(aszWinIni, gszWinIniSection, &ExtensionsSize);

    if (pchExtensions == NULL || pchDevices == NULL) {
        DPF("unable to load extensions section\n");
        if (pchExtensions)
            FreeMem(pchExtensions, ExtensionsSize);
        if (pchDevices)
            FreeMem(pchDevices, DevicesSize);
        return;
    }

    /*
     *  Search through the list of device names found in SYSTEM.INI, looking for
     *  keywords; if profile was not found, then *gpSystemIniKeyBuf == 0
     *
     *  in SYSTEM.INI:
     *
     *      [MCI]
     *          device = driver.drv
     *
     *  in WIN.INI:
     *
     *      [MCI Extensions]
     *          xyz = device
     *
     *  in MPLAYER.INI:
     *
     *      [Devices]
     *          device = <device type>, <device name>
     *
     *  NOTE: The storage of device information in MPLAYER.INI has been nuked
     *        for NT - it may speed things up, but where we are changing
     *        devices regularly after initial setup this is a pain, as deleting
     *        the INI file regularly gets stale real quick.
     *
     */
    for (pchDevice = pchDevices;
        *pchDevice;
        pchDevice += STRLEN(pchDevice)+1) {

        //
        // we have no info in MPLAYER.INI about this device, so load it and
        // ask it.
        //
        wDeviceType = DeviceTypeMCI(pchDevice, ach, CHAR_COUNT(ach));

        //
        // if we don't like this device, don't store it
        //
        if (wDeviceType == DTMCI_ERROR ||
            wDeviceType == DTMCI_IGNOREDEVICE ||
            !(wDeviceType & DTMCI_CANPLAY)) {

            continue;
        }

        gwNumDevices++;
        garMciDevices[gwNumDevices].wDeviceType  = wDeviceType;
        garMciDevices[gwNumDevices].szDevice     = AllocStr(pchDevice);
        garMciDevices[gwNumDevices].szDeviceName = AllocStr(ach);
        garMciDevices[gwNumDevices].szFileExt    = NULL;

        //
        // now look in the [mci extensions] section in WIN.INI to find
        // out the files this device deals with.
        //
        for (pchExt = pchExtensions; *pchExt; pchExt += STRLEN(pchExt)+1) {
            GetProfileString(gszWinIniSection, pchExt, aszNULL, ach, CHAR_COUNT(ach));

            if (lstrcmpi(ach, pchDevice) == 0) {
                if ((pch = garMciDevices[gwNumDevices].szFileExt) != NULL) {
                    wsprintf(ach, aszFormatExts, (LPTSTR)pch, (LPTSTR)pchExt);
                    CharLowerBuff(ach, STRLEN(ach)); // Make sure it's lower case so
                                                     // we can use STRSTR if necessary.
                    FreeStr((HANDLE)pch);
                    garMciDevices[gwNumDevices].szFileExt = AllocStr(ach);
                }
                else {
                    wsprintf(ach, aszFormatExt, (LPTSTR)pchExt);
                    CharLowerBuff(ach, STRLEN(ach));
                    garMciDevices[gwNumDevices].szFileExt = AllocStr(ach);
                }
            }
        }

    //
    // !!!only do this if the device deals with files.
    //
        if (garMciDevices[gwNumDevices].szFileExt == NULL &&
           (garMciDevices[gwNumDevices].wDeviceType & DTMCI_FILEDEV))
            garMciDevices[gwNumDevices].szFileExt = aszAllFiles;

#ifdef DEBUG
        DPF1("Device:%"DTS"; Name:%"DTS"; Type:%d; Extension:%"DTS"\n",
             (LPTSTR)garMciDevices[gwNumDevices].szDevice,
             (LPTSTR)garMciDevices[gwNumDevices].szDeviceName,
                     garMciDevices[gwNumDevices].wDeviceType,
             garMciDevices[gwNumDevices].szFileExt
             ? (LPTSTR)garMciDevices[gwNumDevices].szFileExt
             : aszNULL);
#endif
    }

    /* all done with the system.ini keys so free them */
    FreeMem(pchDevices, DevicesSize);
    FreeMem(pchExtensions, ExtensionsSize);
}



/*
 *  BuildDeviceMenu()
 *
 *  Insert all devices into the device menu, we only want devices that
 *  support the MCI_PLAY command.
 *
 *  Add "..." to the menu for devices that support files.
 *
 */
void NEAR PASCAL BuildDeviceMenu()
{
    int i;
    TCHAR ach[128];

    if (gwNumDevices == 0)
        return;

    DeleteMenu(ghDeviceMenu, IDM_NONE, MF_BYCOMMAND);


    //
    // start at device '1' because device 0 is the auto open device
    //
    for (i=1; i<=(int)gwNumDevices; i++) {
        //
        //  we only care about devices that can play!
        //
        if (!(garMciDevices[i].wDeviceType & DTMCI_CANPLAY))
            continue;

        if (garMciDevices[i].wDeviceType & DTMCI_SIMPLEDEV)
            wsprintf(ach, aszDeviceMenuSimpleFormat, i, (LPTSTR)garMciDevices[i].szDeviceName);
        else if (garMciDevices[i].wDeviceType & DTMCI_FILEDEV)
            wsprintf(ach, aszDeviceMenuCompoundFormat, i, (LPTSTR)garMciDevices[i].szDeviceName);
        else
            continue;

        InsertMenu(ghDeviceMenu, i-1, MF_STRING|MF_BYPOSITION, IDM_DEVICE0+i, ach);
    }
}

/*
 *  BuildFilter()
 *
 *  build the filter to be used with GetOpenFileName()
 *
 *  the filter will look like this...
 *
 *      DEVICE1 (*.111)
 *      DEVICE2 (*.222)
 *
 *      DEVICEn (*.333)
 *
 *      All Files (*.*)
 *
 */
void NEAR PASCAL BuildFilter()
{
    UINT  w;
    PTSTR pch;
    PTSTR pchFilterNew;
#define INITIAL_SIZE    ( 8192 * sizeof( TCHAR ) )

    pch = gpchFilter = AllocMem( INITIAL_SIZE ); //!!!

    if (gpchFilter == NULL)
        return; //!!!

    for (w=1; w<=gwNumDevices; w++)
    {
        if (garMciDevices[w].wDeviceType == DTMCI_ERROR ||
            garMciDevices[w].wDeviceType == DTMCI_IGNOREDEVICE)
            continue;

       	if (garMciDevices[w].wDeviceType & DTMCI_FILEDEV ||
			lstrcmpi(TEXT("CDAudio"), garMciDevices[w].szDevice) == 0) //Hack!!! This will list *.cda files
																	   //in the open dialog box. MCI by itself
																	   //does not handle playing of *.cda files
																	   //but media player does locally.

        {
            wsprintf(pch, aszFormatFilter,
                (LPTSTR)garMciDevices[w].szDeviceName,
                (LPTSTR)garMciDevices[w].szFileExt);
            pch += STRLEN(pch)+1;
            lstrcpy(pch, garMciDevices[w].szFileExt);
            pch += STRLEN(pch)+1;
        }
        else
        {
            lstrcpy(pch, garMciDevices[w].szDeviceName);
            pch += STRLEN(pch)+1;
            lstrcpy(pch, aszBlank);
            pch += STRLEN(pch)+1;
        }
    }

    //
    //  now add "All Files" (device 0) last
    //
    wsprintf(pch, aszFormatFilter, (LPTSTR)garMciDevices[0].szDeviceName, (LPTSTR)garMciDevices[0].szFileExt);
    pch += STRLEN(pch)+1;
    lstrcpy(pch, garMciDevices[0].szFileExt);
    pch += STRLEN(pch)+1;

    //
    // all done!
    //
    *pch++ = 0;

    //
    // realloc this down to size
    //
    pchFilterNew = ReallocMem( gpchFilter,
                               INITIAL_SIZE,
                               (UINT)(pch-gpchFilter)*sizeof(*pch) );
    if (NULL == pchFilterNew) {
        FreeMem(gpchFilter, 0);
    }
    gpchFilter = pchFilterNew;
}

/* Call every time we open a different device to get the default options */
void FAR PASCAL ReadOptions(void)
{
    TCHAR ach[20];

    if (gwDeviceID == (UINT)0)
        return;

    /* Get the options and scale style to be used for this device */

    GetDeviceNameMCI(ach, BYTE_COUNT(ach));

    ReadRegistryData(aszOptionsSection, ach, NULL, (LPBYTE)&gwOptions, sizeof gwOptions);

    if (gwOptions == 0)
        gwOptions |= OPT_BAR | OPT_TITLE | OPT_BORDER;

    gwOptions |= OPT_PLAY;   /* Always default to play in place. */

    gwCurScale = gwOptions & OPT_SCALE;

    switch (gwCurScale) {
        case ID_TIME:
        case ID_FRAMES:
        case ID_TRACKS:
            break;

        default:
            /* Default CD scale to tracks rather than time.
             * Much more sensible:
             */
            if ((gwDeviceType & DTMCI_DEVICE) == DTMCI_CDAUDIO)
                gwCurScale = ID_TRACKS;
            else
                gwCurScale = ID_TIME;
            break;
    }
}

/*
 * ReadDefaults()
 *
 * Read the user defaults from the MPLAYER.INI file.
 *
 */
void NEAR PASCAL ReadDefaults(void)
{
    TCHAR       sz[20];
    TCHAR       *pch;
    int         x,y,w,h;
    UINT        f;

    *sz = TEXT('\0');

    ReadRegistryData(aszOptionsSection, aszDisplayPosition, NULL, (LPBYTE)sz, BYTE_COUNT(sz));

    x = ATOI(sz);

    pch = sz;
    while (*pch && *pch++ != TEXT(','))
        ;

    if (*pch) {
        y = ATOI(pch);

        while (*pch && *pch++ != TEXT(','))
            ;

        if (*pch) {
            w = ATOI(pch);

            while (*pch && *pch++ != TEXT(','))
                ;

            if (*pch) {
                h = ATOI(pch);

                f = SWP_NOACTIVATE | SWP_NOZORDER;

                if (w == 0 || h == 0)
                    f |= SWP_NOSIZE;

                if (!ghInstPrev && x >= 0 && y >= 0
                    && x < GetSystemMetrics(SM_CXSCREEN)
                    && y < GetSystemMetrics(SM_CYSCREEN)) {
                    SetWindowPos(ghwndApp, NULL, x, y, w, h, f);
                    // Remember this so even if we come up in teeny mode and
                    // someone exits, it'll have these numbers to save
                    SetRect(&grcSave, x, y, x + w, y + h);
                } else {
                    SetWindowPos(ghwndApp, NULL, 0, 0, w, h, f | SWP_NOMOVE);
                }
            }
        }
    }
}


/* Call every time we close a device to save its options */
void FAR PASCAL WriteOutOptions(void)
{
    if (gwCurDevice) {
        /* Put the scale in the proper bits of the Options */
        gwOptions = (gwOptions & ~OPT_SCALE) | gwCurScale;

        WriteRegistryData(aszOptionsSection,
                garMciDevices[gwCurDevice].szDevice, REG_DWORD, (LPBYTE)&gwOptions, sizeof gwOptions);
    }
}


void FAR PASCAL WriteOutPosition(void)
{
    TCHAR               sz[20];
    WINDOWPLACEMENT     wp;

    //
    // Only the first instance will save settings.
    // Play only mode will save the remembered rect for when it was in
    // regular mode.  If no rect is remembered, don't write anything.
    //
    if (ghInstPrev || (gfPlayOnly && grcSave.left == 0))
        return;

    /* Save the size it was when it was Normal because the next time */
    /* MPlayer comes up, it won't be in reduced mode.                */
    /* Only valid if some number has been saved.                     */
    if (gfPlayOnly)
        wp.rcNormalPosition = grcSave;
    else {
        wp.length = sizeof(WINDOWPLACEMENT);
        GetWindowPlacement(ghwndApp, &wp);
    }

    wsprintf(sz, aszPositionFormat,
                wp.rcNormalPosition.left,
                wp.rcNormalPosition.top,
                wp.rcNormalPosition.right - wp.rcNormalPosition.left,
                wp.rcNormalPosition.bottom - wp.rcNormalPosition.top);

    WriteRegistryData(aszOptionsSection, aszDisplayPosition, REG_SZ, (LPBYTE)sz, STRING_BYTE_COUNT(sz));
}


BOOL FAR PASCAL GetIntlSpecs()
{
    TCHAR szTmp[2];

    szTmp[0] = chDecimal;
    szTmp[1] = 0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, szTmp, CHAR_COUNT(szTmp));
    chDecimal = szTmp[0];

    szTmp[0] = chTime;
    szTmp[1] = 0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, szTmp, CHAR_COUNT(szTmp));
    chTime = szTmp[0];

    szTmp[0] = chLzero;
    szTmp[1] = 0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ILZERO, szTmp, CHAR_COUNT(szTmp));
    chLzero = szTmp[0];

    return TRUE;
}

/*----------------------------------------------------------------------------*\
|   SmartWindowPosition (HWND hWndDlg, HWND hWndShow)
|
|   Description:
|       This function attempts to position a dialog box so that it
|       does not obscure the hWndShow window. This function is
|       typically called during WM_INITDIALOG processing.
|
|   Arguments:
|       hWndDlg         handle of the soon to be displayed dialog
|       hWndShow        handle of the window to keep visible
|
|   Returns:
|       1 if the windows overlap and positions were adjusted
|       0 if the windows don't overlap
|
\*----------------------------------------------------------------------------*/
void FAR PASCAL SmartWindowPosition (HWND hWndDlg, HWND hWndShow, BOOL fForce)
{
    RECT rc, rcDlg, rcShow;
    int iHeight, iWidth;

    int dxScreen = GetSystemMetrics(SM_CXSCREEN);
    int dyScreen = GetSystemMetrics(SM_CYSCREEN);

    if (hWndDlg == NULL || hWndShow == NULL)
        return;

    GetWindowRect(hWndDlg, &rcDlg);
    GetWindowRect(hWndShow, &rcShow);
    InflateRect (&rcShow, 5, 5); // allow a small border
    if (fForce || IntersectRect(&rc, &rcDlg, &rcShow)){
        /* the two do intersect, now figure out where to place  */
        /* this dialog window.  Try to go below the Show window */
        /* first and then to the right, top and left.           */

        /* get the size of this dialog */
        iHeight = rcDlg.bottom - rcDlg.top;
        iWidth = rcDlg.right - rcDlg.left;

        if ((rcShow.top - iHeight - 1) > 0){
                /* will fit on top, handle that */
                rc.top = rcShow.top - iHeight - 1;
                rc.left = (((rcShow.right - rcShow.left)/2) + rcShow.left)
                            - (iWidth/2);
        } else if ((rcShow.bottom + iHeight + 1) <  dyScreen){
                /* will fit on bottom, go for it */
                rc.top = rcShow.bottom + 1;
                rc.left = (((rcShow.right - rcShow.left)/2) + rcShow.left)
                        - (iWidth/2);
        } else if ((rcShow.right + iWidth + 1) < dxScreen){
                /* will fit to right, go for it */
                rc.left = rcShow.right + 1;
                rc.top = (((rcShow.bottom - rcShow.top)/2) + rcShow.top)
                            - (iHeight/2);
        } else if ((rcShow.left - iWidth - 1) > 0){
                /* will fit to left, do it */
                rc.left = rcShow.left - iWidth - 1;
                rc.top = (((rcShow.bottom - rcShow.top)/2) + rcShow.top)
                            - (iHeight/2);
        } else {
                /* we are hosed, they cannot be placed so that there is */
                /* no overlap anywhere. */
                /* just leave it alone */

                rc = rcDlg;
        }

        /* make any adjustments necessary to keep it on the screen */
        if (rc.left < 0)
                rc.left = 0;
        else if ((rc.left + iWidth) > dxScreen)
                rc.left = dxScreen - iWidth;

        if (rc.top < 0)
                rc.top = 0;
        else if ((rc.top + iHeight) > dyScreen)
                rc.top = dyScreen - iHeight;

        SetWindowPos(hWndDlg, NULL, rc.left, rc.top, 0, 0,
                SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);

        return;
    } // if the windows overlap by default
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\math.c ===
/*-----------------------------------------------------------------------------+
| MATH.C                                                                       |
|                                                                              |
| Written to provide MulDiv32 for the Win32 version of MPlayer2                |
|                                                                              |
| Multiplies two 32 bit values and then divides the result by a third          |
| 32 bit value with full 64 bit precision                                      |
| N.B.  NOT TRUE.  However it is good enough for general MPlayer use.          |
|                                                                              |
| lResult = (lNumber * lNumerator) / lDenominator with correct rounding        |
|                                                                              |
| Entry:                                                                       |
|       lNumber      = number to multiply by nNumerator                        |
|       lNumerator   = number to multiply by nNumber                           |
|       lDenominator = number to divide the multiplication result by.          |
|                                                                              |
| Returns:                                                                     |
|       result of multiplication and division.                                 |
|                                                                              |
| (This is less accurate than the Win16 ASM version as it cannot be written in |
| ASM (for portability reasons) and NT doesn't yet support 64 bit arithmetic)  |
| This file houses the discardable code used at initialisation time. Among     |
| other things, this code reads .INI information and looks for MCI devices.    |
|                                                                              |
|                                                                              |
| NOTE:  This code is NOT safe when the intermediate result becomes negative   |
|        or overflows.  However it is simple, quick, and safe for a wide       |
|        number of uses within MPLayer.                                        |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
| 21-Oct-1992 MikeTri Created by "cloning" MATH.ASM                            |
|                                                                              |
+------------------------------------------------------------------------------+
|                                                                              |
| Original MulDiv32 PseudoCode                                                 |
| ============================                                                 |
|                                                                              |
| long FAR PASCAL muldiv32(long, long, long)                                   |
| long l;                                                                      |
| long Numer;                                                                  |
| long Denom;                                                                  |
| {                                                                            |
|                                                                              |
|   Sign = sign of Denom;   // Sign will keep track of final sign //           |
|                                                                              |
|                                                                              |
|   if (Denom < 0)                                                             |
|   {                                                                          |
|        negate Denom;      // make sure Denom is positive //                  |
|   }                                                                          |
|                                                                              |
|   if (l < 0)                                                                 |
|   {                                                                          |
|        negate l;          // make sure l is positive //                      |
|   }                                                                          |
|                                                                              |
|   make Sign reflect any sign change;                                         |
|                                                                              |
|                                                                              |
|   if (Numer < 0)                                                             |
|   {                                                                          |
|        negate Numer;      // make sure Numer is positive //                  |
|   }                                                                          |
|                                                                              |
|   make Sign reflect any sign change;                                         |
|                                                                              |
|   Numer *= l;                                                                |
|   Numer += (Denom/2);     // adjust for rounding //                          |
|                                                                              |
|   if (overflow)           // check for overflow, and handle divide by zero //|
|   {                                                                          |
|        jump to md5;                                                          |
|   }                                                                          |
|                                                                              |
|   result = Numer/Denom;                                                      |
|                                                                              |
|   if (overflow)           // check again to see if overflow occured //       |
|   {                                                                          |
|        jump to md5;                                                          |
|   }                                                                          |
|                                                                              |
|   if (Sign is negative)   // put sign on the result //                       |
|   {                                                                          |
|        negate result;                                                        |
|   }                                                                          |
|                                                                              |
|md6:                                                                          |
|   return(result);                                                            |
|                                                                              |
|md5:                                                                          |
|   DX = 7FFF;              // indicate overflow by //                         |
|   AX = 0xFFFF             // return largest integer //                       |
|   if (Sign is negative)                                                      |
|   {                                                                          |
|        DX = 0x8000;       // with correct sign //                            |
|        AX = 0x0000;                                                          |
|   }                                                                          |
|                                                                              |
|   jump to md6;                                                               |
| }                                                                            |
\-----------------------------------------------------------------------------*/

#include <windows.h>

LONG FAR PASCAL muldiv32(long l, long Numer, long Denom)
{
    return( (l*Numer)/Denom);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\inplace.c ===
/*---------------------------------------------------------------------------
|   INPLACE.C
|   This file has the InPlace activation related interfaces and functions.
|   This file has the function DoInPlaceEdit which initiaites the server side
|   operations for InPlace activation.
|
|   Created By: Vij Rajarajan (VijR)
+---------------------------------------------------------------------------*/
#define SERVERONLY
#include <windows.h>
#include <windowsx.h>
#include "mpole.h"
#include <mmsystem.h>

#include "mplayer.h"
#include "toolbar.h"
#include "ole2ui.h"

#define DEF_HATCH_SZ 4                      //Width of the hatch marks
#define EW_HATCH_HANDLE 10                  //GetWindowWord offset to check
                                            //if resize handle needed in hatch window

//#define DUMMY_TOOLBAR_WIDTH 58              //Width of dummy toolbar transferred during play.
#define DUMMY_TOOLBAR_WIDTH 0               //Width of dummy toolbar transferred during play.

HWND      ghwndIPHatch = NULL;              //Hatch window surrounding object.
HWND      ghwndIPToolWindow;                //The toolwindow appearing on top
HWND      ghwndIPScrollWindow;              //Tool window appearing at bottom with tthe scrollbar
                                            //if the container does not give us space on top.
HMENU       ghInPlaceMenu;

POINT   gHatchOffset;
WNDPROC gfnHatchWndProc = NULL;

BOOL gfOle2Open = FALSE;
BOOL gfOle2IPEditing = FALSE;
BOOL gfOle2IPPlaying = FALSE;
BOOL gfInPlaceResize  = FALSE;               //TRUE: We have resized when InPlace
BOOL gfTopAndBottomTool = TRUE;              // We have toolbars both on top and bottom
RECT gInPlacePosRect;                        //Our position in the container.
HWND ghwndCntr;                              //Container
HWND ghwndFrame = NULL;                      //Frame of the container.
int toolbarwidth;
BOOL gfPosRectChange = FALSE;
RECT gPrevPosRect;

BOOL    gfInPPViewer;           /* Hack to stop PowerPoint Viewer crashing */

extern TCHAR    szToolBarClass[];
extern HMENU    ghDeviceMenu;         /* handle to the Device menu     */
extern UINT     gwPlaybarHeight;        //tell playbar how tall to make
                                        //itself so it covers the title
void AllocInPlaceDataBlock (LPDOC lpdoc);
void FreeInPlaceDataBlock (LPDOC lpdoc);
void DeactivateTools(LPDOC lpdoc);
HRESULT ActivateTools(LPDOC lpdoc, BOOL fPlayOnly);
void InPlaceCreateControls(BOOL fPlayOnly);
LONG_PTR FAR PASCAL SubClassedHatchWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);



/**************************************************************************
*   TransferTools:
*   This function changes parents and positions the toolbar buttons
*   from the main Mplayer window to the toolbar window/windows we will
*   display in the client.
***************************************************************************/
void TransferTools(HWND hwndToolWindow)
{
    SetParent(ghwndToolbar, hwndToolWindow);
    MoveWindow(ghwndToolbar, 5,0,7*BUTTONWIDTH+15,TOOL_WIDTH,TRUE);
    SetParent(ghwndMark, hwndToolWindow);
    MoveWindow(ghwndMark, 7*BUTTONWIDTH+16,0,2*BUTTONWIDTH+15,TOOL_WIDTH,TRUE);
    SetParent(ghwndFSArrows, hwndToolWindow);
    MoveWindow(ghwndFSArrows, 9*BUTTONWIDTH+16+10+3,0,toolbarwidth-9*BUTTONWIDTH-25,TOOL_WIDTH,TRUE);
    if(!ghwndMCI) {
        toolbarModifyState(ghwndToolbar, BTN_EJECT, TBINDEX_MAIN, BTNST_GRAYED);
        toolbarModifyState(ghwndToolbar, BTN_STOP, TBINDEX_MAIN, BTNST_GRAYED);
        toolbarModifyState(ghwndToolbar, BTN_PLAY, TBINDEX_MAIN, BTNST_GRAYED);
        toolbarModifyState(ghwndMark, BTN_MARKIN, TBINDEX_MARK, BTNST_GRAYED);
        toolbarModifyState(ghwndMark, BTN_MARKOUT, TBINDEX_MARK, BTNST_GRAYED);
        toolbarModifyState(ghwndFSArrows, ARROW_PREV, TBINDEX_ARROWS, BTNST_GRAYED);
        toolbarModifyState(ghwndFSArrows, ARROW_NEXT, TBINDEX_ARROWS, BTNST_GRAYED);
    }
    if(hwndToolWindow == ghwndApp)
    {
        SetParent(ghwndTrackbar,ghwndApp);
        SetParent(ghwndMap,ghwndApp);
    }
}



/**************************************************************************
*   ActivateTools:
*   This function negotiates for toolbar space with the client. If possible
*   one broad toolbar is placed at the top of the client, if not the
*   toolbar is split and one is placed on top and other at bottom. If even
*   that is not possible then the function fails. The top toolbar window is
*   ghwndIPToolWindow and the bottom one is ghwndIPScrollWindow (because it
*   has the scrolling trackbar.
*
*   fPlayOnly is TRUE if we are just going to play. In that case a dummy, empty
*   tool bar is transferred.  No, we don't want anything.  But we have to
*   negotiate space, even empty space, otherwise Word doesn't think we're
*   in-place active.
***************************************************************************/
HRESULT ActivateTools(LPDOC lpdoc, BOOL fPlayOnly)
{
    RECT rect, size;
    SCODE sc;


    size.left = 0;
    size.top = 0;
    size.bottom = 0;
    size.right = 0;
    IOleInPlaceFrame_GetBorder(lpdoc->lpIpData->lpFrame, &rect);
    if (fPlayOnly)
        size.top = DUMMY_TOOLBAR_WIDTH; /* This is now 0 - no toolbar space needed */
    else
        size.top = 3*TOOL_WIDTH+1;
    size.bottom = 0;
    sc = GetScode(IOleInPlaceFrame_RequestBorderSpace(lpdoc->lpIpData->lpFrame,
                                                      &size));
    if (sc == S_OK)
    {
        size.bottom = size.left = size.right = 0;
        if (fPlayOnly)
            size.top = DUMMY_TOOLBAR_WIDTH;
        else
            size.top = 3*TOOL_WIDTH+1;

        sc = GetScode(IOleInPlaceFrame_SetBorderSpace(lpdoc->lpIpData->lpFrame,
                                                      &size));
        if (sc != S_OK)
            goto ToolBottom;

        IOleInPlaceFrame_GetBorder(lpdoc->lpIpData->lpFrame, &rect);

        IOleInPlaceFrame_GetWindow (lpdoc->lpIpData->lpFrame, &ghwndFrame);

        if (GetParent(ghwndIPToolWindow) != ghwndFrame)
            SetParent(ghwndIPToolWindow, ghwndFrame);

        if (!fPlayOnly)
            MoveWindow(ghwndIPToolWindow, rect.left, rect.top,
                       toolbarwidth, 3*TOOL_WIDTH+1, TRUE);
        else
            return NOERROR;  /* That's all folks, if we're just playing. */

        if(ghwndIPToolWindow != GetParent(ghwndTrackbar))
        {
            SetParent(ghwndTrackbar,ghwndIPToolWindow);
            SetWindowPos(ghwndTrackbar, NULL,3,TOOL_WIDTH+2,
                 11*BUTTONWIDTH+15,FSTRACK_HEIGHT,SWP_NOZORDER | SWP_NOACTIVATE);
            SetParent(ghwndMap,ghwndIPToolWindow);
            SetWindowPos(ghwndMap, NULL,3,TOOL_WIDTH+FSTRACK_HEIGHT+2+2,
                 11*BUTTONWIDTH+50,MAP_HEIGHT,SWP_NOZORDER | SWP_NOACTIVATE);
        }
        ShowWindow(ghwndIPToolWindow, SW_SHOW);
        ShowWindow(ghwndMark, SW_SHOW);
        ShowWindow(ghwndFSArrows, SW_SHOW);

        gfTopAndBottomTool = FALSE;
        return NOERROR;

    }
    else
    {
ToolBottom:
        if (!fPlayOnly)
        {
            size.top = TOOL_WIDTH+1;
            size.bottom = 2*TOOL_WIDTH+1;
        }
        else
        {
            ShowWindow(ghwndFSArrows, SW_HIDE);
            ShowWindow(ghwndStatic, SW_HIDE);
            ShowWindow(ghwndMark, SW_HIDE);
            return NOERROR;
        }
        sc = GetScode(IOleInPlaceFrame_RequestBorderSpace(lpdoc->lpIpData->lpFrame,
                                                          &size));
        size.left = size.right = 0;
        size.top = TOOL_WIDTH+1;
        size.bottom = 2*TOOL_WIDTH+1;
        if (sc != S_OK)
            goto error;

        sc = GetScode(IOleInPlaceFrame_SetBorderSpace(lpdoc->lpIpData->lpFrame,
                                                      &size));
        if (sc != S_OK)
            goto error;

        IOleInPlaceFrame_GetBorder(lpdoc->lpIpData->lpFrame, &rect);

        if (GetParent(ghwndIPToolWindow) != ghwndFrame)
        {
            SetParent(ghwndIPToolWindow, ghwndFrame);
            SetParent(ghwndIPScrollWindow, ghwndFrame);
        }

        if(ghwndIPScrollWindow != GetParent(ghwndTrackbar))
        {
            SetParent(ghwndTrackbar,ghwndIPScrollWindow);
            SetWindowPos(ghwndTrackbar, NULL,3,4,
                         11*BUTTONWIDTH+15,FSTRACK_HEIGHT,SWP_NOZORDER | SWP_NOACTIVATE);
            SetParent(ghwndMap,ghwndIPScrollWindow);
            SetWindowPos(ghwndMap, NULL,3,FSTRACK_HEIGHT+4+2,
                         11*BUTTONWIDTH+50,MAP_HEIGHT,SWP_NOZORDER | SWP_NOACTIVATE);
        }

        MoveWindow(ghwndIPToolWindow, rect.left, rect.top,
            toolbarwidth, TOOL_WIDTH+1, TRUE);
        ShowWindow(ghwndIPToolWindow, SW_SHOW);
        MoveWindow(ghwndIPScrollWindow, rect.left,rect.bottom-2*TOOL_WIDTH,//-1,
                toolbarwidth,2*TOOL_WIDTH+1,TRUE);
        ShowWindow(ghwndIPScrollWindow, SW_SHOW);
        gfTopAndBottomTool = TRUE;
        return NOERROR;
    }
error:
    RETURN_RESULT(sc);
}


/**************************************************************************
*   DeactivateTools:
*   Hides the toolbars.
***************************************************************************/
void DeactivateTools(LPDOC lpdoc)
{
    ShowWindow(ghwndIPToolWindow, SW_HIDE);
    SetParent(ghwndIPToolWindow, NULL);
    if (gfTopAndBottomTool)
    {
        ShowWindow(ghwndIPScrollWindow, SW_HIDE);
        SetParent(ghwndIPScrollWindow, NULL);
    }
}




/**************************************************************************
************   IOleInPlaceObject INTERFACE IMPLEMENTATION.
***************************************************************************/
//Delegate to the common IUnknown implementation.
STDMETHODIMP IPObjQueryInterface (
LPOLEINPLACEOBJECT  lpIPObj,        // inplace object ptr
REFIID              riidReq,        // IID required
LPVOID FAR *        lplpUnk         // pre for returning the interface
)
{
    return UnkQueryInterface((LPUNKNOWN)lpIPObj, riidReq, lplpUnk);
}


STDMETHODIMP_(ULONG) IPObjAddRef(
LPOLEINPLACEOBJECT  lpIPObj         // inplace object ptr
)
{
    return UnkAddRef((LPUNKNOWN) lpIPObj);
}


STDMETHODIMP_(ULONG) IPObjRelease(
LPOLEINPLACEOBJECT  lpIPObj         // inplace object ptr
)
{
    return UnkRelease((LPUNKNOWN) lpIPObj);
}


STDMETHODIMP IPObjGetWindow(
LPOLEINPLACEOBJECT  lpIPObj,        // inplace object ptr
HWND FAR*           lphwnd          // window handle of the object
)
{
    DPF("IPObjGetWindow\n");
    *lphwnd = docMain.hwnd;
    return NOERROR;
}


STDMETHODIMP IPObjContextSensitiveHelp(
LPOLEINPLACEOBJECT  lpIPObj,        // inplace object ptr
BOOL                fEnable
)
{
    //Not very useful at this time.

    LPDOC lpdoc;

    lpdoc = ((struct COleInPlaceObjectImpl FAR*)lpIPObj)->lpdoc;
    lpdoc->lpIpData->fInContextHelpMode = fEnable;
    return NOERROR;
}


STDMETHODIMP     IPObjInPlaceDeactivate(
LPOLEINPLACEOBJECT  lpIPObj        // inplace object ptr
)
{
    LPDOC         lpdoc;
    LPINPLACEDATA lpIpData;
    static int    EntryCount;   /* OLE sometimes calls us recursively. */

    DPF("IPObjInPlaceDeactivate\n");

    if (EntryCount++ == 0)
    {
        lpdoc = ((struct COleInPlaceObjectImpl FAR*)lpIPObj)->lpdoc;
        lpIpData = lpdoc->lpIpData;

        if (lpIpData)
        {
            // This stops PowerPoint crashing, since it forces UpdateObject
            // to send change notification when there's an empty Media Clip.
            if (gwDeviceID == 0)
                fDocChanged = TRUE;

            //Make sure the container has the correct metafile before we are hidden
            UpdateObject();
            IOleInPlaceObject_UIDeactivate ((LPOLEINPLACEOBJECT)&lpdoc->m_InPlace);

            if (lpIpData && lpIpData->lpSite)
            {
                if (!gfInPPViewer)
                    IOleInPlaceSite_OnInPlaceDeactivate (lpIpData->lpSite);

                IOleInPlaceSite_Release (lpIpData->lpSite);
            }

            FreeInPlaceDataBlock (lpdoc);
        }
    }
    else
    {
        /* This sometimes happens during the above OnInPlaceDeactivate call,
         * which resulted in an access violation because the data block had
         * been freed when the call returned.
         * According to the OLE guys, apps should guard against this.
         */
        DPF("Attempt to re-enter IPObjInPlaceDeactivate\n");
    }

    --EntryCount;

    /* Dontcha just love these global variables!
     */
    gfOle2IPEditing = FALSE;
    gfOle2IPPlaying = FALSE;
    gfPlayingInPlace = FALSE;

    return NOERROR;
}

//Hide our inplace UI.
STDMETHODIMP     IPObjUIDeactivate(
LPOLEINPLACEOBJECT  lpIPObj        // inplace object ptr
)
{
    LPDOC   lpdoc;

    DPF("IPObjUIDeactivate\n");
    lpdoc = ((struct COleInPlaceObjectImpl FAR*)lpIPObj)->lpdoc;

    if (!(lpdoc->lpIpData && lpdoc->lpIpData->lpFrame))
        return NOERROR;

    IOleInPlaceFrame_SetMenu (lpdoc->lpIpData->lpFrame, NULL, NULL, lpdoc->hwnd);
    // clear inplace-state

    IOleInPlaceFrame_SetActiveObject (lpdoc->lpIpData->lpFrame, NULL, NULL);

    if (lpdoc->lpIpData->lpUIWindow)
        IOleInPlaceUIWindow_SetActiveObject (lpdoc->lpIpData->lpUIWindow, NULL, NULL);

    if(gfOle2IPPlaying)
        PostMessage(ghwndApp, WM_COMMAND, ID_STOP, 0L);

    /* We could also be playing if we're in-place editing:
     */
    else if(gfOle2IPEditing && (gwStatus == MCI_MODE_PLAY || gwStatus == MCI_MODE_SEEK))
        PostMessage(ghwndApp, WM_COMMAND, ID_STOP, 0L);

    ShowWindow(ghwndIPHatch,SW_HIDE);

    DeactivateTools(lpdoc);
    DisassembleMenus (lpdoc);

    if (lpdoc->lpIpData->lpUIWindow) {
        IOleInPlaceUIWindow_Release (lpdoc->lpIpData->lpUIWindow);
        lpdoc->lpIpData->lpUIWindow = NULL;
    }

    if (lpdoc->lpIpData->lpFrame) {
        IOleInPlaceFrame_Release (lpdoc->lpIpData->lpFrame);
        lpdoc->lpIpData->lpFrame = NULL;
    }

    // Set the parent back to hwndClient window
    SetParent(ghwndIPHatch,NULL);
    gPrevPosRect.left = gPrevPosRect.top =gPrevPosRect.right = gPrevPosRect.bottom = 0;
    lpdoc->hwndParent = NULL;

    if (!gfInPPViewer)
        IOleInPlaceSite_OnUIDeactivate (lpdoc->lpIpData->lpSite, FALSE);

    return NOERROR;
}

/**************************************************************************
*   IPObjSetObjectRects:
*   The client specifies our window position and size. Move our
*   window accordingly. Also size the Hatch window to fit around the
*   ghwndApp. If the change is very small compared to the previous
*   size ignore and return. This account for slop speeds things up.
***************************************************************************/
STDMETHODIMP     IPObjSetObjectRects(
LPOLEINPLACEOBJECT  lpIPObj,        // inplace object ptr
LPCRECT             lprcPosRect,
LPCRECT             lprcVisRect
)
{
    LPDOC   lpdoc;
    RECT rc;

    GetWindowRect(ghwndApp, (LPRECT)&rc);

    DPFI("\n*IPObjSetObjectRects");
    DPFI("\n^^^^^^^^ LPRECPOSRECT:  %d, %d, %d, %d ^^^^\n", *lprcPosRect);
    DPFI("\n^^^^^^^^ PREVRECT:  %d, %d, %d, %d ^^^^\n", gPrevPosRect);
    DPFI("\n^^^^^^^^ HWNDRECT:  %d, %d, %d, %d ^^^^\n", rc);

    lpdoc = ((struct COleInPlaceObjectImpl FAR*)lpIPObj)->lpdoc;
    if (!ghwndIPHatch || (ghwndCntr != GetParent(ghwndIPHatch)))
        return NOERROR;
    if (!(lpdoc->lpIpData))
        return NOERROR;

    rc = *lprcPosRect;

    if (!(gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW)))
        SetHatchWindowSize(ghwndIPHatch, (LPRECT)&rc,lprcVisRect, (LPPOINT)&gHatchOffset,TRUE);
    else
        SetHatchWindowSize(ghwndIPHatch, (LPRECT)&rc,lprcVisRect, (LPPOINT)&gHatchOffset,FALSE);


    if(!(gwDeviceType & DTMCI_CANWINDOW) && (gwOptions & OPT_BAR))
        rc.top = rc.bottom - gwPlaybarHeight;
    if(!(gwDeviceType & DTMCI_CANWINDOW) && !(gwOptions & OPT_BAR))
        rc.bottom = rc.top = rc.left = rc.right = 0;
    MapWindowPoints(ghwndCntr,ghwndIPHatch,(LPPOINT)&rc, 2);
    gfPosRectChange = TRUE;

    if (gwDeviceID)
        MoveWindow(lpdoc->hwnd, rc.left, rc.top,
            rc.right - rc.left,
            rc.bottom - rc.top, TRUE);
    else
        MoveWindow(lpdoc->hwnd, rc.left, rc.top,
            rc.right - rc.left,
            rc.bottom - rc.top, FALSE);

    GetWindowRect(lpdoc->hwnd, &gInPlacePosRect);
    gPrevPosRect = *lprcPosRect;

    /* I've commented out the below line, because PowerPoint calls
     * SetObjectRects after we deactivate, and this was causing the
     * MPlayer window to reappear when it was supposed to be hidden.
     * This line seems to have been superfluous in any case.
     */
//  ShowWindow(ghwndIPHatch,SW_SHOW);

    return NOERROR;
}

//We don't have an Undo state.
STDMETHODIMP     IPObjReactivateAndUndo(
LPOLEINPLACEOBJECT  lpIPObj        // inplace object ptr
)
{
    RETURN_RESULT(INPLACE_E_NOTUNDOABLE);
}



/**************************************************************************
**************   IOleInPlaceActiveObject INTERFACE IMPLEMENTATION.
***************************************************************************/
//delegate to the common IUnknown implementation.
STDMETHODIMP IPActiveQueryInterface (
LPOLEINPLACEACTIVEOBJECT    lpIPActive,     // inplace active object ptr
REFIID                      riidReq,        // IID required
LPVOID FAR *                lplpUnk         // pre for returning the interface
)
{
    return UnkQueryInterface((LPUNKNOWN)lpIPActive, riidReq, lplpUnk);
}


STDMETHODIMP_(ULONG) IPActiveAddRef(
LPOLEINPLACEACTIVEOBJECT    lpIPActive      // inplace active object ptr
)
{
    return UnkAddRef((LPUNKNOWN) lpIPActive);
}


STDMETHODIMP_(ULONG) IPActiveRelease (
LPOLEINPLACEACTIVEOBJECT    lpIPActive      // inplace active object ptr
)
{
    return UnkRelease((LPUNKNOWN) lpIPActive);
}


STDMETHODIMP IPActiveGetWindow(
LPOLEINPLACEACTIVEOBJECT    lpIPActive,     // inplace active object ptr
HWND FAR*                   lphwnd          // window handle of the object
)
{
    DPF("IPActiveGetWindow\n");
    *lphwnd = ghwndIPHatch;
    return NOERROR;
}

//Not very useful at this time.
STDMETHODIMP IPActiveContextSensitiveHelp(
LPOLEINPLACEACTIVEOBJECT    lpIPActive,     // inplace active object ptr
BOOL                        fEnable
)
{
    LPDOC lpdoc;

    lpdoc = ((struct COleInPlaceActiveObjectImpl FAR*)lpIPActive)->lpdoc;
    lpdoc->lpIpData->fInContextHelpMode = fEnable;
    return NOERROR;
}



STDMETHODIMP IPActiveTranslateAccelerator(
LPOLEINPLACEACTIVEOBJECT    lpIPActive,     // inplace active object ptr
LPMSG                       lpmsg
)
{
    // This will never be called because this server is implemented as an EXE
    RETURN_RESULT(S_FALSE);
}

STDMETHODIMP IPActiveOnFrameWindowActivate(
LPOLEINPLACEACTIVEOBJECT    lpIPActive,     // inplace active object ptr
BOOL                        fActivate
)
{
    DPF("IPActiveOnFrameWindowActivate = %d **\r\n", (int)fActivate);
    if (gwStatus == MCI_MODE_PAUSE)
            PostMessage(ghwndApp, WM_COMMAND, ID_STOP, 0L);

    return NOERROR;
}


//If activating show the toolbar and menu. If not hide the toolbar and menu.
STDMETHODIMP IPActiveOnDocWindowActivate(
LPOLEINPLACEACTIVEOBJECT    lpIPActive,     // inplace active object ptr
BOOL                        fActivate
)
{
    LPDOC   lpdoc;
    RECT rc;
    DPF("IPActiveOnDocWindowActivate\n");
    lpdoc = ((struct COleInPlaceActiveObjectImpl FAR*)lpIPActive)->lpdoc;
    GetWindowRect(lpdoc->hwnd, &rc);
    ScreenToClient(lpdoc->hwndParent, (POINT FAR *)&rc);
    ScreenToClient(lpdoc->hwndParent, (POINT FAR *)&(rc.right));
    if (fActivate) {

        if(gfOle2IPEditing)
        {
            ActivateTools(lpdoc,FALSE);
            TransferTools(ghwndIPToolWindow);
        }
        else
        {
            ActivateTools(lpdoc,TRUE);
            TransferTools(ghwndApp);
        }

        Layout();

        IOleInPlaceFrame_SetMenu (lpdoc->lpIpData->lpFrame,
                                  lpdoc->lpIpData->hmenuShared,
                                  lpdoc->lpIpData->holemenu,
                                  lpdoc->hwnd);
    }
    else {
        DeactivateTools(lpdoc);
        if(gfOle2IPPlaying)
            PostMessage(ghwndApp, WM_COMMAND, ID_STOP, 0L);
        IOleInPlaceFrame_SetMenu (lpdoc->lpIpData->lpFrame,
                                  NULL, NULL, lpdoc->hwnd);
    }
    return NOERROR;
}

//If we have a toolwindow at the bottom reposition that window to match
//the new frame window size.
STDMETHODIMP IPActiveResizeBorder(
LPOLEINPLACEACTIVEOBJECT    lpIPActive,     // inplace active object ptr
LPCRECT                     lprectBorder,
LPOLEINPLACEUIWINDOW        lpIPUiWnd,
BOOL                        fFrameWindow
)
{
    DPF("IPActiveResizeBorder\n");

    if (fFrameWindow)
    {
    LPDOC lpdoc;

    lpdoc = ((struct COleInPlaceActiveObjectImpl FAR*)lpIPActive)->lpdoc;
    if (gfTopAndBottomTool && (GetParent(ghwndIPScrollWindow) != NULL))
        MoveWindow(ghwndIPScrollWindow, lprectBorder->left,lprectBorder->bottom-2*TOOL_WIDTH,
                toolbarwidth,2*TOOL_WIDTH+1,TRUE);

    }
    return NOERROR;
}

STDMETHODIMP IPActiveEnableModeless(
LPOLEINPLACEACTIVEOBJECT    lpIPActive,     // inplace active object ptr
BOOL                        fEnable
)
{
    return NOERROR;
}


/**************************************************************************
*   DoInplaceEdit:
*   This is the function that initiates the InPlace activation from the
*   server side. It sets up the InPlace data structures required by us,
*   makes sure that the client supports the required interfaces and
*   can provide the space we require. It also prepares the toolbar to be
*   displayed and the layout of the Mplayer window.
***************************************************************************/
STDMETHODIMP DoInPlaceEdit(
LPDOC           lpdoc,
LPMSG           lpmsg,
LPOLECLIENTSITE lpActiveSite,
LONG        verb,
HWND    FAR * lphwnd,
LPRECT  lprect
)
{
    SCODE            error = S_OK;
    LPOLEINPLACESITE lpIPSite;
    RECT             rcPos;
    RECT             rcVis;
    RECT             hatchrc;
    LPWSTR           lpObjName;

    if (!(lpdoc->lpoleclient))
        RETURN_RESULT( E_FAIL);

    if (!(lpdoc->lpIpData))
    {
        if ((error = GetScode(IOleClientSite_QueryInterface(
                        lpdoc->lpoleclient,
                        &IID_IOleInPlaceSite,
                        (void FAR* FAR*) &lpIPSite))) != S_OK)
            RETURN_RESULT( error);

        if ((error = GetScode(IOleInPlaceSite_CanInPlaceActivate(lpIPSite))) != S_OK)
            goto errActivate;

        if (!gfInPPViewer)
            IOleInPlaceSite_OnInPlaceActivate(lpIPSite);

        AllocInPlaceDataBlock (lpdoc);
        lpdoc->lpIpData->lpSite = lpIPSite;
    }

    if ((error = GetScode(IOleInPlaceSite_GetWindow (lpdoc->lpIpData->lpSite, &lpdoc->hwndParent))) != S_OK)
        goto errRtn;

    if (!(lpdoc->hwndParent))
        goto errRtn;

    if (!gfInPPViewer)
        IOleInPlaceSite_OnUIActivate(lpdoc->lpIpData->lpSite);

    if ((error = GetScode(IOleInPlaceSite_GetWindowContext(
                                lpdoc->lpIpData->lpSite,
                                &lpdoc->lpIpData->lpFrame,
                                &lpdoc->lpIpData->lpUIWindow,
                                &rcPos, &rcVis,
                                &lpdoc->lpIpData->frameInfo))) != S_OK)
        goto errRtn;

#ifdef LATER
    if (gscaleInitXY[SCALE_X].denom)
    {
        gscaleInitXY[SCALE_X].num   = (rcPos.right - rcPos.left) * HIMETRIC_PER_INCH / giXppli;
        gscaleInitXY[SCALE_Y].num   = (rcPos.bottom - rcPos.top) * HIMETRIC_PER_INCH / giYppli;

        DPF0("Scale: %d%c X %d%c (%d/%d X %d/%d)\n",
             gscaleInitXY[SCALE_X].num * 100 / gscaleInitXY[SCALE_X].denom, '%',
             gscaleInitXY[SCALE_Y].num * 100 / gscaleInitXY[SCALE_Y].denom, '%',
             gscaleInitXY[SCALE_X].num,
             gscaleInitXY[SCALE_X].denom,
             gscaleInitXY[SCALE_Y].num,
             gscaleInitXY[SCALE_Y].denom);
    }
#endif

#ifdef UNICODE
    lpObjName = gachClassRoot;
#else
    lpObjName = AllocateUnicodeString(gachClassRoot);
    if (!lpObjName)
        RETURN_RESULT(E_OUTOFMEMORY);
#endif /* UNICODE */

    IOleInPlaceFrame_SetActiveObject (lpdoc->lpIpData->lpFrame,
                                      (LPOLEINPLACEACTIVEOBJECT) &lpdoc->m_IPActive,
                                      lpObjName);
    if (lpdoc->lpIpData->lpUIWindow) {
        IOleInPlaceUIWindow_SetActiveObject (lpdoc->lpIpData->lpUIWindow,
                                             (LPOLEINPLACEACTIVEOBJECT) &lpdoc->m_IPActive,
                                             lpObjName);
    }

#ifndef UNICODE
    FreeUnicodeString(lpObjName);
#endif

    ghwndCntr = lpdoc->hwndParent;

    //Create and initialize the hatch window to surround the Mplayer window.
    if (!ghwndIPHatch)
    {
        RegisterHatchWindowClass(ghInst);
        if ( !(ghwndIPHatch = CreateHatchWindow(lpdoc->hwndParent,ghInst)))
            goto errRtn;
        gfnHatchWndProc = (WNDPROC)GetWindowLongPtr(ghwndIPHatch, GWLP_WNDPROC);
        SetWindowLongPtr(ghwndIPHatch, GWLP_WNDPROC, (LONG_PTR)SubClassedHatchWndProc);
    }


    SetParent(ghwndIPHatch, ghwndCntr);

	SetFocus(ghwndIPHatch);

    CopyRect(&hatchrc, &rcPos);

#define EB_HATCHWIDTH       (0 * sizeof(INT))
    if (verb == OLEIVERB_PRIMARY)
    {
        /* I don't want to show the hatch window on play, because it looks
         * really bad in PowerPoint.  Can't make it invisible, because
         * the app window is its child, and it inherits the flag.
         * Instead, just make it of zero width.
         */
        SETWINDOWUINT(ghwndIPHatch, EB_HATCHWIDTH, 0);
    }
    else
    {
        SETWINDOWUINT(ghwndIPHatch, EB_HATCHWIDTH, DEF_HATCH_SZ);
        InflateRect(&hatchrc, DEF_HATCH_SZ, DEF_HATCH_SZ);
    }


    SetHatchRect(ghwndIPHatch,(LPRECT)&hatchrc);


    *lphwnd = ghwndIPHatch;

    //If we are going to Play inplace, do the minimum stuff and return.
    if (verb == OLEIVERB_PRIMARY)
    {
        gfOle2IPPlaying = TRUE;

        GetWindowRect(ghwndCntr,(LPRECT)&rcVis);
        MapWindowPoints(NULL,ghwndCntr,(LPPOINT)&rcVis, 2);
        SetHatchWindowSize(ghwndIPHatch, (LPRECT)&rcPos,(LPRECT)&rcVis, (LPPOINT)&gHatchOffset,FALSE);
        MoveWindow(ghwndApp, 0, 0, rcPos.right  - rcPos.left, rcPos.bottom - rcPos.top, TRUE);
        InPlaceCreateControls(TRUE);
        ActivateTools(lpdoc, TRUE);
        TransferTools(ghwndApp);

        ClientToScreen(lpdoc->hwndParent, (LPPOINT)&rcPos);
        ClientToScreen(lpdoc->hwndParent, (LPPOINT)&rcPos+1);

        lpdoc->hwndParent = NULL;

/* MENU STUFF */
        /* We have to set the menus even if we're only playing, because otherwise
         * Word doesn't believe we're in-place active, and doesn't send us any
         * deactivation notification when the user clicks outside us.
         */
        AssembleMenus (lpdoc, TRUE);

        if ((error = GetScode(IOleInPlaceFrame_SetMenu (lpdoc->lpIpData->lpFrame,
                                lpdoc->lpIpData->hmenuShared,
                                lpdoc->lpIpData->holemenu,
                                lpdoc->hwnd))) != S_OK)
                goto errRtn;
/* END MENU STUFF */

        *lprect = rcPos;

        ShowWindow(ghwndIPHatch, SW_SHOW);
        return NOERROR;
    }

    //Edit InPlace.


    if (!(gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW)))
        //No resize handles.
        SetHatchWindowSize(ghwndIPHatch, (LPRECT)&rcPos,(LPRECT)&rcVis, (LPPOINT)&gHatchOffset,TRUE);
    else
        //There will be resize handles.
        SetHatchWindowSize(ghwndIPHatch, (LPRECT)&rcPos,(LPRECT)&rcVis, (LPPOINT)&gHatchOffset,FALSE);

    gfOle2IPEditing = TRUE;

    if (!SkipInPlaceEdit)           //don't layout and transfer the tools
    {                                // if we are just reactivating.
        DestroyWindow(ghwndStatic);
        ghwndStatic = CreateStaticStatusWindow(ghwndApp, FALSE);
        SendMessage(ghwndStatic, WM_SETFONT, (UINT_PTR)ghfontMap, 0);
        Layout();
        InPlaceCreateControls(FALSE);
    }

    else
        SetParent (lpdoc->hwnd, ghwndIPHatch);

    TransferTools(ghwndIPToolWindow);

    if ((error = GetScode(AssembleMenus (lpdoc, FALSE))) != S_OK)
        goto errRtn;

    ShowWindow (lpdoc->hwnd, SW_HIDE);
    // currently we are not using the pane

    // prevent OnDataChange() notification
    lpdoc->lpIpData->fNoNotification = FALSE;

    if ((error = GetScode(IOleInPlaceFrame_SetMenu (lpdoc->lpIpData->lpFrame,
                            lpdoc->lpIpData->hmenuShared,
                            lpdoc->lpIpData->holemenu,
                            lpdoc->hwnd))) != S_OK)
            goto errRtn;

    if ((error = GetScode(ActivateTools(lpdoc,FALSE))) != S_OK)
            goto errRtn;

    ShowWindow(ghwndIPHatch,SW_SHOW);
    ShowWindow(ghwndMCI,SW_SHOW);

    ClientToScreen(lpdoc->hwndParent, (LPPOINT)&rcPos);
    ClientToScreen(lpdoc->hwndParent, (LPPOINT)&rcPos+1);

    *lprect = rcPos;
    if (SkipInPlaceEdit)
        OffsetRect(&gInPlacePosRect,rcPos.left-gInPlacePosRect.left,
                rcPos.top-gInPlacePosRect.top);

    else
        gInPlacePosRect = rcPos;
    return NOERROR;

errRtn:
    DoInPlaceDeactivate(lpdoc);
    TransferTools(ghwndApp);
    RETURN_RESULT(error);

errActivate:
    IOleInPlaceSite_Release(lpIPSite);

    FreeInPlaceDataBlock (lpdoc);
    RETURN_RESULT( error);
}

#if 0
HMENU GetInPlaceMenu(void)
{
    if (ghInPlaceMenu)
    return GetSubMenu(ghInPlaceMenu,0);
    else
    {
        ghInPlaceMenu = LoadMenu(ghInst, TEXT("InPlaceMenu"));
        return GetSubMenu(ghInPlaceMenu,0);
    }
}
#endif

/**************************************************************************
*   AssembleMenus:
*   This function merges our menu with that of the client.
***************************************************************************/
STDMETHODIMP AssembleMenus (LPDOC lpdoc, BOOL fPlayOnly)
{

    HMENU       hmenuMain = ghMenu;
    HMENU       hmenuEditPopup = GetSubMenu(hmenuMain, menuposEdit);
    HMENU       hmenuDevicePopup = GetSubMenu(hmenuMain, menuposDevice);
    HMENU       hmenuScalePopup = GetSubMenu(hmenuMain, menuposScale);
    //HMENU       hmenuCommandPopup = GetInPlaceMenu();
    HMENU       hmenuHelpPopup = GetSubMenu(hmenuMain, menuposHelp);

    HMENU       hmenuShared;
    LONG FAR*   lpMenuWidths;
    SCODE       error = S_OK;
    UINT        uPos;
    UINT        uPosStart;
    static TCHAR szEdit[40] = TEXT("");
    static TCHAR szInsert[40] = TEXT("");
    static TCHAR szScale[40] = TEXT("");
    //static TCHAR szCommand[40] = TEXT("");
    static TCHAR szHelp[40] = TEXT("");

    if (szEdit[0] == TEXT('\0'))
    {
        LOADSTRING(IDS_EDITMENU, szEdit);
        LOADSTRING(IDS_INSERTMENU, szInsert);
        LOADSTRING(IDS_SCALEMENU, szScale);
        //LOADSTRING(IDS_COMMANDMENU, szCommand);
        LOADSTRING(IDS_HELPMENU, szHelp);
    }

    lpMenuWidths = lpdoc->lpIpData->menuWidths.width;
    hmenuShared = CreateMenu();
    if((error = GetScode(IOleInPlaceFrame_InsertMenus (lpdoc->lpIpData->lpFrame,
                            hmenuShared, &lpdoc->lpIpData->menuWidths))) !=S_OK)
    {
        if (hmenuShared)
            DestroyMenu(hmenuShared);
        RETURN_RESULT( error);
    }

    if(fPlayOnly)
    {
        /* No server menu items if we're only playing:
         */
        lpMenuWidths[1] = lpMenuWidths[3] = lpMenuWidths[5] = 0;
    }
    else
    {
        uPos = (UINT)lpMenuWidths[0]; /* # of menus in the FILE group */
        uPosStart = uPos;

        InsertMenu (hmenuShared, (WORD)uPos,
                MF_BYPOSITION | MF_POPUP, (UINT_PTR)hmenuEditPopup, szEdit);
        uPos++;

        lpMenuWidths[1] = uPos - uPosStart;

        /* Insert OBJECT group menus */

        uPos += (UINT)lpMenuWidths[2];
        uPosStart = uPos;

        InsertMenu (hmenuShared, (WORD)uPos,
                MF_BYPOSITION | MF_POPUP, (UINT_PTR)hmenuDevicePopup, szInsert);
        uPos++;
        InsertMenu (hmenuShared, (WORD)uPos,
                MF_BYPOSITION | MF_POPUP, (UINT_PTR)hmenuScalePopup,  szScale);
        uPos++;
        //InsertMenu (hmenuShared, (WORD)uPos,
        //        MF_BYPOSITION | MF_POPUP, (UINT)hmenuCommandPopup,    szCommand);
        //uPos++;
        lpMenuWidths[3] = uPos - uPosStart;

        /* Insert HELP group menus */

        uPos += (UINT) lpMenuWidths[4]; /* # of menus in WINDOW group */
        uPosStart = uPos;

        InsertMenu (hmenuShared, (WORD)uPos, MF_BYPOSITION | MF_POPUP, (UINT_PTR)hmenuHelpPopup,
                szHelp);
        uPos++;

        lpMenuWidths[5] = uPos - uPosStart;
    }

    if(!(lpdoc->lpIpData->holemenu = OleCreateMenuDescriptor (hmenuShared,
                            &lpdoc->lpIpData->menuWidths)))
         RETURN_RESULT( E_OUTOFMEMORY);

    lpdoc->lpIpData->hmenuShared = hmenuShared;
    RETURN_RESULT( error);
}

//Removes our menu from the shared menu,
STDMETHODIMP DisassembleMenus (LPDOC lpdoc)
{

    HMENU   hmenuMain = ghMenu;
    HMENU   hmenuEditPopup = GetSubMenu(hmenuMain, menuposEdit);
    HMENU   hmenuDevicePopup = GetSubMenu(hmenuMain, menuposDevice);
    HMENU   hmenuScalePopup = GetSubMenu(hmenuMain, menuposScale);
    //HMENU   hmenuCommandPopup = GetInPlaceMenu();
    HMENU   hmenuHelpPopup = GetSubMenu(hmenuMain, menuposHelp);
    HMENU   hmenuTmp;
    HMENU   hmenuShared = lpdoc->lpIpData->hmenuShared;
    int     i, n, cnt;
    SCODE   error = S_OK;

    OleDestroyMenuDescriptor (lpdoc->lpIpData->holemenu);
    lpdoc->lpIpData->holemenu = NULL;

    if(!(lpdoc->lpIpData->hmenuShared))
         RETURN_RESULT( error);
    n = GetMenuItemCount(hmenuShared);
    cnt = 0;
    i = 0;
    while (i < n) {
        hmenuTmp = GetSubMenu(hmenuShared, i);
        if (hmenuTmp == hmenuEditPopup
                || hmenuTmp == hmenuDevicePopup
                || hmenuTmp == hmenuHelpPopup
                //|| hmenuTmp == hmenuCommandPopup
                || hmenuTmp == hmenuScalePopup  ) {
            RemoveMenu (hmenuShared, i, MF_BYPOSITION);
            ++cnt;
            if (cnt == 4) { // added 3 (4 if command menu included) popup menus.
                break;
            }
            --n;
        }
        else
            ++i;
    }

    IOleInPlaceFrame_RemoveMenus (lpdoc->lpIpData->lpFrame,
                                  lpdoc->lpIpData->hmenuShared);
    DestroyMenu(lpdoc->lpIpData->hmenuShared);
    lpdoc->lpIpData->hmenuShared = NULL;
    RETURN_RESULT( error);
}


void AllocInPlaceDataBlock (LPDOC lpdoc)
{
    // When this app is ready to support mutiple objects (documents), these
    // structures should be allocated dynamically one per object.

    static INPLACEDATA  IpData;

    lpdoc->lpIpData = (LPINPLACEDATA) &IpData;
    lpdoc->lpIpData->lpFrame = NULL;
    lpdoc->lpIpData->lpUIWindow = NULL;
    lpdoc->lpIpData->fInContextHelpMode = FALSE;
}


void FreeInPlaceDataBlock (LPDOC lpdoc)
{
    lpdoc->lpIpData = NULL;
}


void DoInPlaceDeactivate (LPDOC lpdoc)
{
    if (!(lpdoc->lpIpData))
        return;
    ShowWindow(ghwndApp,SW_HIDE);
    IOleInPlaceObject_InPlaceDeactivate ((LPOLEINPLACEOBJECT)&lpdoc->m_InPlace);
}


/**************************************************************************
*   ToolWndProc:
*   This is the Window proc for the ToolWindow/Windows we will be trasnferring
*   to the client window. Some messages are routed to the MPlayer main window
*   to ensure proper operation.
***************************************************************************/
LONG_PTR FAR PASCAL ToolWndProc (HWND hwnd, unsigned message, WPARAM wparam,
                LPARAM lparam)
{
    switch(message)
    {
    case WM_COMMAND:
        PostMessage(ghwndApp,WM_COMMAND,
        wparam,lparam);
        break;
    case WM_NEXTDLGCTL:
    case WM_CTLCOLOR:
    case WM_HSCROLL:
        return (SendMessage(ghwndApp,message,wparam,lparam));
    default:
        return DefWindowProc(hwnd,message,wparam,lparam);
    }

    return 0;
}

/**************************************************************************
*   RegisterToolWinClasses:
*   Register the WindowClasses for the Toolbar windows we use to display
*    in the client document.
***************************************************************************/
BOOL RegisterToolWinClasses()
{
    WNDCLASS  wc;


    wc.lpszClassName = TEXT("ObjTool");
    wc.lpfnWndProc   = ToolWndProc;
    wc.style         = 0;
    wc.hInstance     = ghInst;
    wc.hIcon         = NULL;
    wc.cbClsExtra    = 4;
    wc.cbWndExtra    = 0;
    wc.lpszMenuName  = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);

    if (!RegisterClass(&wc))
        return FALSE;

    return TRUE;
}



/**************************************************************************
*   InPlaceCreateControls:
*   This function creates the toolbar windows we will display in the client
*   and transfers the tool button to these windows by changing parents
*   and repositioning them.
*   If fPlayOnly is true all we need is a Dummy toolbar to fill space on
*   the top of the container. Don't transfer the tools.
***************************************************************************/
void InPlaceCreateControls(BOOL fPlayOnly)
{
    RECT    rc;

    if(IsWindow(ghwndIPToolWindow))
        return;
    RegisterToolWinClasses();
    GetWindowRect(GetDesktopWindow(),&rc);
    toolbarwidth =  2*(rc.right - rc.left);
    IOleInPlaceFrame_GetWindow (docMain.lpIpData->lpFrame, &ghwndFrame);

    ghwndIPToolWindow = CreateWindowEx(gfdwFlagsEx,
                                       TEXT("ObjTool"),
                                       NULL,
                                       WS_CHILD | WS_BORDER,
                                       0, 0,
                                       toolbarwidth,
                                       3*TOOL_WIDTH+1,
                                       ghwndFrame,
                                       NULL,
                                       ghInst,
                                       NULL);

    ShowWindow(ghwndIPToolWindow, SW_HIDE);
    if (fPlayOnly)
        return;

    ghwndIPScrollWindow = CreateWindowEx(gfdwFlagsEx,
                                         TEXT("ObjTool"),
                                         NULL,
                                         WS_CHILD | WS_BORDER,
                                         0, 0,
                                         toolbarwidth,
                                         3*TOOL_WIDTH+1,
                                         ghwndFrame,
                                         NULL,
                                         ghInst,
                                         NULL);

    ShowWindow(ghwndIPScrollWindow, SW_HIDE);
}




/**************************************************************************
*   SubClassedHatchWndProc:
*   The Hatch Window is created in the OLE2UI.LIB. The window proc
*   is also specified there. But in order to do things like resizing
*   the Mplayer when the handles in the hatch window are dragged
*   we need to subclass the window.
***************************************************************************/
LONG_PTR FAR PASCAL SubClassedHatchWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL fCapture = FALSE;
    static RECT hatchRC;
    RECT rc;
    static POINT ptLast;
    POINT pt;
    HDC hdcDeskTop;
    HPEN hpenOld;
    HBRUSH hbrushOld;
    int nropOld;
    int nBkOld;
    HPEN hpen;
    static int dL,dR, dT, dB;
    static int left, right, top, bottom;


    switch(wMsg)
    {
    case WM_LBUTTONDOWN:    //Check to see if the click is on the resize handles.
                            //If yes then capture the mouse.

        if(!GETWINDOWUINT(ghwndIPHatch,EW_HATCH_HANDLE))
            break;

        if(gfOle2IPPlaying)
            break;

        GetHatchRect(ghwndIPHatch, &hatchRC);

        pt.x = (int)(SHORT)LOWORD(lParam);
        pt.y = (int)(SHORT)HIWORD(lParam);

        left = right = top = bottom = 0;

        rc.left = hatchRC.left;
        rc.top = hatchRC.top;
        rc.right = rc.left + DEF_HATCH_SZ + 1;
        rc.bottom = rc.top + DEF_HATCH_SZ + 1;

        if(PtInRect((LPRECT)&rc,pt))
        left = top = 1;

        rc.top = hatchRC.top+(hatchRC.bottom-hatchRC.top-DEF_HATCH_SZ-1)/2;
        rc.bottom = rc.top + DEF_HATCH_SZ + 1;

        if(PtInRect((LPRECT)&rc,pt))
        left = 1;

        rc.top = hatchRC.bottom-DEF_HATCH_SZ-1;
        rc.bottom = rc.top + DEF_HATCH_SZ + 1;

        if(PtInRect((LPRECT)&rc,pt))
        {
        bottom = 1;
        left = 1;
        }

        rc.left = hatchRC.right - DEF_HATCH_SZ-1;
        rc.right = rc.left + DEF_HATCH_SZ + 1;
        if(PtInRect((LPRECT)&rc,pt))
        {
        bottom = 1;
        right = 1;
        }
        rc.top = hatchRC.top+(hatchRC.bottom-hatchRC.top-DEF_HATCH_SZ-1)/2;
        rc.bottom = rc.top + DEF_HATCH_SZ + 1;
        if(PtInRect((LPRECT)&rc,pt))
        right = 1;

        rc.top = hatchRC.top;
        rc.bottom = rc.top + DEF_HATCH_SZ + 1;
        if(PtInRect((LPRECT)&rc,pt))
        {
        top = 1;
        right = 1;
        }

        rc.left = hatchRC.left + (hatchRC.right - hatchRC.left - DEF_HATCH_SZ-1)/2;
        rc.right = rc.left + DEF_HATCH_SZ + 1;
        if(PtInRect((LPRECT)&rc,pt))
        top = 1;

        rc.top = hatchRC.bottom-DEF_HATCH_SZ-1;
        rc.bottom = rc.top + DEF_HATCH_SZ + 1;
        if(PtInRect((LPRECT)&rc,pt))
        bottom = 1;

        if (!(left || right || top || bottom))
        break;
        fCapture = TRUE;
        SetCapture(hwnd);
        ptLast = pt;
        MapWindowPoints(hwnd,NULL,(LPPOINT)&hatchRC,2);
        dL = dR = dT = dB = 0;
        hpen = CreatePen(PS_DASH, 1, 0x00000000);

        hdcDeskTop = GetDC(NULL);
        hpenOld = SelectObject (hdcDeskTop, hpen);
        hbrushOld = SelectObject (hdcDeskTop,
            GetStockObject(HOLLOW_BRUSH));
        nropOld = GetROP2(hdcDeskTop);
        SetROP2(hdcDeskTop, R2_NOT);
        nBkOld = GetBkMode(hdcDeskTop);
        SetBkMode(hdcDeskTop, TRANSPARENT);

        Rectangle(hdcDeskTop, hatchRC.left+dL, hatchRC.top+dT,
            hatchRC.right+dR, hatchRC.bottom+dB);


        SetBkMode(hdcDeskTop, nBkOld);
        SetROP2(hdcDeskTop, nropOld);
        SelectObject(hdcDeskTop, hbrushOld);
        SelectObject(hdcDeskTop, hpenOld);
        DeleteObject (hpen);
        ReleaseDC(NULL, hdcDeskTop);

        break;

    case WM_MOUSEMOVE:          //If we have the capture draw the resize rectangles.
        if (!fCapture)
        break;
        else {

            pt.x = (int)(SHORT)LOWORD(lParam);
            pt.y = (int)(SHORT)HIWORD(lParam);

        hpen = CreatePen(PS_DASH, 1, 0x00000000);

        hdcDeskTop = GetDC(NULL);
        hpenOld = SelectObject (hdcDeskTop, hpen);
        hbrushOld = SelectObject (hdcDeskTop,
            GetStockObject(HOLLOW_BRUSH));
        nropOld = GetROP2(hdcDeskTop);
        SetROP2(hdcDeskTop, R2_NOT);
        nBkOld = GetBkMode(hdcDeskTop);
        SetBkMode(hdcDeskTop, TRANSPARENT);

        Rectangle(hdcDeskTop, hatchRC.left+dL, hatchRC.top+dT,
            hatchRC.right+dR, hatchRC.bottom+dB);

        dL = dR = pt.x - ptLast.x;
        dT = dB = pt.y - ptLast.y;
        dL *= left;
        dR *= right;
        dT *= top;
        dB *= bottom;

        Rectangle(hdcDeskTop, hatchRC.left+dL, hatchRC.top+dT,
            hatchRC.right+dR, hatchRC.bottom+dB);

        SetBkMode(hdcDeskTop, nBkOld);
        SetROP2(hdcDeskTop, nropOld);
        SelectObject(hdcDeskTop, hbrushOld);
        SelectObject(hdcDeskTop, hpenOld);
        if (hpen)
            DeleteObject (hpen);
        ReleaseDC(NULL, hdcDeskTop);
        }

        break;

    case WM_LBUTTONUP:  //release capture and resize.
        if (!fCapture)
        break;
        else {
        hpen = CreatePen(PS_DASH, 1, 0x00000000);

        hdcDeskTop = GetDC(NULL);
        hpenOld = SelectObject (hdcDeskTop, hpen);
        hbrushOld = SelectObject (hdcDeskTop,
            GetStockObject(HOLLOW_BRUSH));
        nropOld = GetROP2(hdcDeskTop);
        SetROP2(hdcDeskTop, R2_NOT);
        nBkOld = GetBkMode(hdcDeskTop);
        SetBkMode(hdcDeskTop, TRANSPARENT);

        Rectangle(hdcDeskTop, hatchRC.left+dL, hatchRC.top+dT,
            hatchRC.right+dR, hatchRC.bottom+dB);


        SetBkMode(hdcDeskTop, nBkOld);
        SetROP2(hdcDeskTop, nropOld);
        SelectObject(hdcDeskTop, hbrushOld);
        SelectObject(hdcDeskTop, hpenOld);
        DeleteObject (hpen);
        ReleaseDC(NULL, hdcDeskTop);
        ReleaseCapture();
        }
        fCapture = FALSE;

        GetWindowRect(ghwndApp,&hatchRC);
        hatchRC.left += dL;
        hatchRC.right += dR;
        hatchRC.top += dT;
        hatchRC.bottom += dB;
        MapWindowPoints(NULL,ghwndCntr,(LPPOINT)&hatchRC, 2);

        if (gwStatus != MCI_MODE_STOP)
            PostMessage(ghwndApp, WM_COMMAND, ID_STOP, 0L);

        // Negotiate with client for space. We accept the size specified by client.
        DPFI("Hatch Resize: Before OnPosRectChange: %d, %d, %d, %d\r\n", hatchRC);
        if (!gfInPPViewer)
            IOleInPlaceSite_OnPosRectChange(docMain.lpIpData->lpSite, &hatchRC);

        SendDocMsg((LPDOC)&docMain, OLE_CHANGED);

        break;

    case WM_PAINT:
    {
        HDC hdc;
        HDC hdcmem;
        RECT rcH;
        HBITMAP hbm;
        BITMAP bm;

        if(ghwndMCI)
        break;
        CallWindowProc(gfnHatchWndProc, hwnd, wMsg, wParam, lParam);
        hdc = GetDC(hwnd);
        GetHatchRect(hwnd, (LPRECT)&rcH);
        InflateRect((LPRECT)&rcH,-DEF_HATCH_SZ,-DEF_HATCH_SZ);
        hbm = BitmapMCI();

        hdcmem = CreateCompatibleDC(hdc);
        if(!hdcmem)
            return(E_FAIL);
        SelectObject(hdcmem,hbm);
        GetObject(hbm,sizeof(bm),(LPVOID)&bm);
        StretchBlt(hdc,rcH.left,rcH.top,rcH.right-rcH.left,rcH.bottom-rcH.top,hdcmem,
               0,0,bm.bmWidth,bm.bmHeight,SRCCOPY);
        DeleteDC(hdcmem);
        ReleaseDC(ghwndIPHatch,hdc);


        return 0L;

        }

    }
    return CallWindowProc(gfnHatchWndProc, hwnd, wMsg, wParam, lParam);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\math.asm ===
page    ,132
;---------------------------Module-Header-------------------------------;
; Module Name: MATH.ASM
;
; Contains FIXED point math routines.
;
; Created:  Sun 30-Aug-1987 19:28:30
; Author: Charles Whitmer [chuckwh]
;
; Copyright (c) 1987  Microsoft Corporation
;-----------------------------------------------------------------------;

?WIN	= 0
?PLM	= 1
?NODATA = 0

        PMODE = 1

        .xlist
        include cmacros.inc
        include windows.inc
        .list

        externA __WinFlags

UQUAD   struc
uq0     dw      ?
uq1     dw      ?
uq2     dw      ?
uq3     dw      ?
UQUAD	ends

;       The following two equates are just used as shorthand
;       for the "word ptr" and "byte ptr" overrides.

wptr    equ     word ptr
bptr    equ     byte ptr

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

EAXtoDXAX   macro
        shld    edx,eax,16      ; move HIWORD(eax) to dx
        endm

DXAXtoEAX   macro
        ror     eax,16          ; xchg HIWORD(eax) and LOWORD(eax)
        shrd    eax,edx,16      ; move LOWORD(edx) to HIWORD(eax)
        endm

neg32       macro hi, lo
        neg lo
        adc hi,0                ; carry set unless lo zero
        neg hi
        endm

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
	assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; long muldiv32(long, long, long)
;
; multiples two 32 bit values and then divides the result by a third
; 32 bit value with full 64 bit presision
;
; lResult = (lNumber * lNumerator) / lDenominator with correct rounding
;
; Entry:
;       lNumber = number to multiply by nNumerator
;       lNumerator = number to multiply by nNumber
;       lDenominator = number to divide the multiplication result by.
;   
; Returns:
;       DX:AX = result of multiplication and division.
;
; Error Returns:
;       none
; Registers Preserved:
;       DS,ES,SI,DI
; History:
;   Fri 05-Oct-1990 -by- Rob Williams [Robwi] 
;   Behavior consistent with MulDiv16 routine (signed, no int 0 on overflow)
;   Stole muldiv16 psuedocode
;
;   Wed 14-June-1990 -by-  Todd Laney [ToddLa]
;   converted it to 386/286 code. (by checking __WinFlags)
;
;   Tue 08-May-1990 -by-  Rob Williams [Robwi]
;   Wrote it.
;
;----------------------------Pseudo-Code--------------------------------;
; long FAR PASCAL muldiv32(long, long, long)
; long l;
; long Numer;
; long Denom;
; {
;
;   Sign = sign of Denom;   // Sign will keep track of final sign //
;
;
;   if (Denom < 0)
;   {
;	negate Denom;	// make sure Denom is positive //
;   }
;
;   if (l < 0)
;   {
;	negate l;	// make sure l is positive //
;   }
;
;   make Sign reflect any sign change;
;
;
;   if (Numer < 0)
;   {
;	negate Numer;	// make sure Numer is positive //
;   }
;
;   make Sign reflect any sign change;
;
;   Numer *= l;
;   Numer += (Denom/2); // adjust for rounding //
;
;   if (overflow)   // check for overflow, and handle divide by zero //
;   {
;	jump to md5;
;   }
;
;   result = Numer/Denom;
;
;   if (overflow)   // check again to see if overflow occured //
;   {
;	jump to md5;
;   }
;
;   if (Sign is negative)   // put sign on the result //
;   {
;	negate result;
;   }
;
;md6:
;   return(result);
;
;md5:
;   DX = 7FFF;	    // indicate overflow by //
;   AX = 0xFFFF     // return largest integer //
;   if (Sign is negative)
;   {
;	DX = 0x8000;	// with correct sign //
;	AX = 0x0000;	
;   }
;
;   jump to md6;
; }
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   muldiv32,<PUBLIC,FAR,NODATA,NONWIN>,<>
;       ParmD  lNumber
;       ParmD  lNumerator
;       ParmD  lDenominator
cBegin	<nogen>
	mov	ax,__WinFlags
        test    ax,WF_CPU286+WF_CPU086+WF_CPU186
        jz      md32_1
        jmp     NEAR PTR muldiv32_286
md32_1:
        errn$   muldiv32_386
cEnd    <nogen>

cProc   muldiv32_386,<PUBLIC,FAR,NODATA,NONWIN>,<>
        ParmD   lNumber
        ParmD   lNumerator
        ParmD   lDenominator
cBegin
        .386


        mov     ebx,lDenominator    ; get the demoninator
        mov     ecx,ebx	            ; ECX holds the final sign in hiword
        or      ebx,ebx             ; ensure the denominator is positive
        jns     md386_1
        neg     ebx

md386_1:
        mov     eax,lNumber         ; get the long we are multiplying
        xor     ecx,eax	            ; make ECX reflect any sign change
        or      eax,eax             ; ensure the long is positive
        jns     md386_2
        neg     eax

md386_2:
        mov     edx,lNumerator      ; get the numerator
        xor     ecx,edx	            ; make ECX reflect any sign change
        or      edx,edx             ; ensure the numerator is positive
        jns     md386_3
        neg     edx

md386_3:
        mul     edx                 ; multiply
        mov     cx,bx               ; get half of the demoninator to adjust for rounding
        sar     ebx,1               
        add     eax,ebx             ; adjust for possible rounding error
        adc     edx,0               ; this is really a long addition
        sal     ebx,1               ; restore the demoninator
        or      bx,cx               ; fix bottom bit
        cmp     edx,ebx             ; check for overflow
        jae     md386_5                 ; (ae handles /0 case)
        div     ebx                 ; divide
        or      eax,eax             ; If sign is set, then overflow occured
        js      md386_5                 ; Overflow.
        or      ecx,ecx             ; put the sign on the result
        jns     md386_6
        neg     eax

md386_6:
        EAXtoDXAX                   ; convert eax to dx:ax for 16 bit programs

        .286
cEnd 
        .386

md386_5:
        mov     eax,7FFFFFFFh       ; return the largest integer
        or      ecx,ecx             ; with the correct sign
        jns     md386_6
        not     eax
        jmp     md386_6

        .286

cProc   muldiv32_286,<PUBLIC,FAR,NODATA,NONWIN>,<di,si>
        ParmD  lNumber             
        ParmD  lNumerator
        ParmD  lDenominator
        LocalW wSign

cBegin

        mov     dx,lDenominator.hi      ; get the demoninator
        mov     si,dx	                ; SI holds the final sign 
        or      dx,dx                   ; ensure the denominator is positive
        jns     md286_1
        neg32   dx, lDenominator.lo
        mov     lDenominator.hi, dx


md286_1:
        mov     ax,lNumber.lo           ; get the long we are multiplying
        mov     dx,lNumber.hi           
        xor     si,dx	                ; make ECX reflect any sign change
        or      dx,dx                   ; ensure the long is positive
        jns     md286_2
        neg32   dx, ax

md286_2:
        mov     bx,lNumerator.lo        ; get the numerator
        mov     cx,lNumerator.hi        ; get the numerator
        xor     si,cx	                ; make ECX reflect any sign change
        or      cx,cx                   ; ensure the numerator is positive
        jns     md286_3
        neg32   cx, bx

md286_3:
        mov     wSign, si               ; save sign
        call    dmul                    ; multiply (result in dx:cx:bx:ax)
        mov     si, lDenominator.hi
        mov     di, lDenominator.lo
        sar     si, 1                   ; get half of the demoninator 
        rcr     di, 1                   ; to adjust for rounding
        add     ax, di                  ; adjust for possible rounding error
        adc     bx, si
        adc     cx, 0
        adc     dx, 0                   ; this is really a long addition

        sal     di, 1                   ; restore the demoninator
        rcl     si, 1

        or      di, lDenominator.lo     ; fix bottom bit

        cmp     dx, si                  ; begin overflow check (unsigned for div 0 check)
        ja      md286_5                 ; overflow
        jb      md286_7                 ; no overflow
        cmp     cx, di       
        jae     md286_5                 ; overflow

md286_7:
        call    qdiv                    ; DX:AX is quotient     
        or      dx,dx                   ; If sign is set, then overflow occured
        js      md286_5                 ; Overflow.
        mov     cx, wSign
        or      cx,cx                   ; put the sign on the result
        jns     md286_6
        neg32   dx,ax

md286_6:

cEnd

md286_5:
        mov     cx, wSign
        mov     ax, 0FFFFh              ; return the largest integer
        mov     dx, 7FFFh
        or      cx, cx                  ; with the correct sign
        jns     md286_6
        not     dx
        not     ax
        jmp     md286_6


;---------------------------Public-Routine------------------------------;
; idmul
;
; This is an extended precision multiply routine, intended to emulate
; 80386 imul instruction.
;
; Entry:
;       DX:AX = LONG
;       CX:BX = LONG
; Returns:
;       DX:CX:BX:AX = QUAD product
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 23:47:02  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   idmul,<PUBLIC,NEAR>,<si,di>
        localQ  qTemp
cBegin

; put one argument in safe registers

        mov     si,dx
        mov     di,ax

; do the low order unsigned product

        mul     bx
        mov     qTemp.uq0,ax
        mov     qTemp.uq1,dx

; do the high order signed product

        mov     ax,si
        imul    cx
        mov     qTemp.uq2,ax
        mov     qTemp.uq3,dx

; do a mixed product

        mov     ax,si
        cwd
        and     dx,bx
        sub     qTemp.uq2,dx            ; adjust for sign bit
        sbb     qTemp.uq3,0
        mul     bx
        add     qTemp.uq1,ax
        adc     qTemp.uq2,dx
        adc     qTemp.uq3,0

; do the other mixed product

        mov     ax,cx
        cwd
	and	dx,di
        sub     qTemp.uq2,dx
        sbb     qTemp.uq3,0
        mul     di

; pick up the answer

        mov     bx,ax
        mov     cx,dx
        xor     dx,dx

        mov     ax,qTemp.uq0
        add     bx,qTemp.uq1
        adc     cx,qTemp.uq2
        adc     dx,qTemp.uq3
cEnd

;---------------------------Public-Routine------------------------------;
; dmul
;
; This is an extended precision multiply routine, intended to emulate
; 80386 mul instruction.
;
; Entry:
;       DX:AX = LONG
;       CX:BX = LONG
; Returns:
;       DX:CX:BX:AX = QUAD product
; Registers Destroyed:
;       none
; History:
;  Tue 02-Feb-1988 10:50:44  -by-  Charles Whitmer [chuckwh]
; Copied from idmul and modified.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   dmul,<PUBLIC,NEAR>,<si,di>
        localQ  qTemp
cBegin

; put one argument in safe registers

        mov     si,dx
        mov     di,ax

; do the low order product

        mul     bx
        mov     qTemp.uq0,ax
        mov     qTemp.uq1,dx

; do the high order product

        mov     ax,si
        mul     cx
        mov     qTemp.uq2,ax
        mov     qTemp.uq3,dx

; do a mixed product

        mov     ax,si
        mul     bx
        add     qTemp.uq1,ax
        adc     qTemp.uq2,dx
        adc     qTemp.uq3,0

; do the other mixed product

        mov     ax,cx
        mul     di

; pick up the answer

        mov     bx,ax
        mov     cx,dx
        xor     dx,dx
        mov     ax,qTemp.uq0
        add     bx,qTemp.uq1
        adc     cx,qTemp.uq2
        adc     dx,qTemp.uq3
cEnd

;---------------------------Public-Routine------------------------------;
; iqdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit IDIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two signed numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; This routine just keeps track of the signs and calls qdiv to do the
; real work.
;
; Entry:
;       DX:CX:BX:AX = QUAD Numerator
;       SI:DI       = LONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       DI,SI
; History:
;  Tue 26-Jan-1988 02:49:19  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;

WIMP    equ     1

IQDIV_RESULT_SIGN       equ     1
IQDIV_REM_SIGN          equ     2

        assumes ds,nothing
        assumes es,nothing

cProc   iqdiv,<PUBLIC,NEAR>
        localB  flags
cBegin
        mov     flags,0

; take the absolute value of the denominator

        or      si,si
        jns     denominator_is_cool
        xor     flags,IQDIV_RESULT_SIGN
        neg     di
        adc     si,0
        neg     si
denominator_is_cool:

; take the absolute value of the denominator

        or      dx,dx
        jns     numerator_is_cool
        xor     flags,IQDIV_RESULT_SIGN + IQDIV_REM_SIGN
        not     ax
        not     bx
        not     cx
        not     dx
        add     ax,1
        adc     bx,0
        adc     cx,0
        adc     dx,0
numerator_is_cool:

; do the unsigned division

        call    qdiv
ifdef WIMP
        jo      iqdiv_exit
endif

; check for overflow

        or      dx,dx
        jns     have_a_bit_to_spare
ifdef WIMP
        mov     ax,8000h
        dec     ah
        jmp     short iqdiv_exit
else
        int     0                       ; You're toast, Jack!
endif
have_a_bit_to_spare:

; negate the result, if required

        test    flags,IQDIV_RESULT_SIGN
        jz      result_is_done
        neg     ax
        adc     dx,0
        neg     dx
result_is_done:

; negate the remainder, if required

        test    flags,IQDIV_REM_SIGN
        jz      remainder_is_done
        neg     bx
        adc     cx,0
        neg     cx
remainder_is_done:
iqdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; qdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit DIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two unsigned numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; Entry:
;       DX:CX:BX:AX = UQUAD Numerator
;       SI:DI       = ULONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 00:02:09  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   qdiv,<PUBLIC,NEAR>,<si,di>
        localQ  uqNumerator
        localD  ulDenominator
        localD  ulQuotient
        localW  cShift
cBegin

; stuff the quad word into local memory

        mov     uqNumerator.uq0,ax
        mov     uqNumerator.uq1,bx
        mov     uqNumerator.uq2,cx
        mov     uqNumerator.uq3,dx


; check for overflow

qdiv_restart:
        cmp     si,dx
        ja      qdiv_no_overflow
        jb      qdiv_overflow
        cmp     di,cx
        ja      qdiv_no_overflow
qdiv_overflow:
ifdef WIMP
        mov     ax,8000h
        dec     ah
        jmp     qdiv_exit
else
        int     0                       ; You're toast, Jack!
        jmp     qdiv_restart
endif
qdiv_no_overflow:

; check for a zero Numerator

        or      ax,bx
        or      ax,cx
        or      ax,dx
        jz      qdiv_exit_relay         ; quotient = remainder = 0

; handle the special case when the denominator lives in the low word

        or      si,si
        jnz     not_that_special

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=0):DI

        cmp     di,1                    ; separate out the trivial case
        jz      div_by_one
        xchg    dx,cx                   ; CX = remainder.hi = 0
        mov     ax,bx
        div     di
        mov     bx,ax                   ; BX = quotient.hi
        mov     ax,uqNumerator.uq0
        div     di                      ; AX = quotient.lo
        xchg    bx,dx                   ; DX = quotient.hi, BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit_relay:
        jmp     qdiv_exit

; calculate (DX=0):(CX=0):BX:uqNumerator.uq0 / (SI=0):(DI=1)

div_by_one:
        xchg    dx,bx                   ; DX = quotient.hi, BX = remainder.lo = 0
        mov     ax,uqNumerator.uq0      ; AX = quotient.lo
        jmp     qdiv_exit
not_that_special:

; handle the special case when the denominator lives in the high word

        or      di,di
        jnz     not_this_special_either

; calculate DX:CX:BX:uqNumerator.uq0 / SI:(DI=0)

        cmp     si,1                    ; separate out the trivial case
        jz      div_by_10000h
        mov     ax,cx
        div     si
        mov     cx,ax                   ; CX = quotient.hi
        mov     ax,bx
        div     si                      ; AX = quotient.lo
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
        jmp     qdiv_exit

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=1):(DI=0)

div_by_10000h:
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi = 0
        mov     ax,bx                   ; AX = quotient.lo
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
        jmp     qdiv_exit
not_this_special_either:

; normalize the denominator

        mov     dx,si
        mov     ax,di
        call    ulNormalize             ; DX:AX = normalized denominator
        mov     cShift,cx               ; CX < 16
        mov     ulDenominator.lo,ax
        mov     ulDenominator.hi,dx


; shift the Numerator by the same amount

        jcxz    numerator_is_shifted
        mov     si,-1
        shl     si,cl
        not     si                      ; SI = mask
        mov     bx,uqNumerator.uq3
        shl     bx,cl
        mov     ax,uqNumerator.uq2
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq3,bx
        xor     ax,di
        mov     bx,uqNumerator.uq1
        rol     bx,cl
        mov     di,si
        and     di,bx
        or      ax,di
        mov     uqNumerator.uq2,ax
        xor     bx,di
        mov     ax,uqNumerator.uq0
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq1,bx
        xor     ax,di
        mov     uqNumerator.uq0,ax
numerator_is_shifted:

; set up registers for division

        mov     dx,uqNumerator.uq3
        mov     ax,uqNumerator.uq2
        mov     di,uqNumerator.uq1
        mov     cx,ulDenominator.hi
        mov     bx,ulDenominator.lo

; check for case when Denominator has only 16 bits

        or      bx,bx
        jnz     must_do_long_division
        div     cx
        mov     si,ax
        mov     ax,uqNumerator.uq1
        div     cx
        xchg    si,dx                   ; DX:AX = quotient
        mov     di,uqNumerator.uq0      ; SI:DI = remainder (shifted)
        jmp     short unshift_remainder
must_do_long_division:

; do the long division, part IZ@NL@%

        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      first_division_is_safe
        mov     ulQuotient.hi,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short first_adjuster
first_division_is_safe:
        div     cx
        mov     ulQuotient.hi,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     first_adjuster_done     ; The remainder is UNSIGNED!  We have
first_adjuster:                         ; to use the carry flag to keep track
        dec     ulQuotient.hi           ; of the sign.  The adjuster loop
        add     di,bx                   ; watches for a change to the carry
        adc     si,cx                   ; flag which would indicate a sign
        jnc     first_adjuster          ; change IF we had more bits to keep
first_adjuster_done:                    ; a sign in.

; do the long division, part II

        mov     dx,si
        mov     ax,di
        mov     di,uqNumerator.uq0
        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      second_division_is_safe
        mov     ulQuotient.lo,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short second_adjuster
second_division_is_safe:
        div     cx
        mov     ulQuotient.lo,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     second_adjuster_done
second_adjuster:
        dec     ulQuotient.lo
        add     di,bx
        adc     si,cx
        jnc     second_adjuster
second_adjuster_done:
        mov     ax,ulQuotient.lo
        mov     dx,ulQuotient.hi

; unshift the remainder in SI:DI

unshift_remainder:
        mov     cx,cShift
        jcxz    remainder_unshifted
        mov     bx,-1
        shr     bx,cl
        not     bx
        shr     di,cl
        ror     si,cl
        and     bx,si
        or      di,bx
        xor     si,bx
remainder_unshifted:
        mov     cx,si
        mov     bx,di
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; ulNormalize
;
; Normalizes a ULONG so that the highest order bit is 1.  Returns the
; number of shifts done.  Also returns ZF=1 if the ULONG was zero.
;
; Entry:
;       DX:AX = ULONG
; Returns:
;       DX:AX = normalized ULONG
;       CX    = shift count
;       ZF    = 1 if the ULONG is zero, 0 otherwise
; Registers Destroyed:
;       none
; History:
;  Mon 25-Jan-1988 22:07:03  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   ulNormalize,<PUBLIC,NEAR>
cBegin

; shift by words

        xor     cx,cx
        or      dx,dx
        js      ulNormalize_exit
        jnz     top_word_ok
        xchg    ax,dx
        or      dx,dx
        jz      ulNormalize_exit        ; the zero exit
        mov     cl,16
        js      ulNormalize_exit
top_word_ok:

; shift by bytes

        or      dh,dh
        jnz     top_byte_ok
        xchg    dh,dl
        xchg    dl,ah
        xchg    ah,al
        add     cl,8
        or      dh,dh
        js      ulNormalize_exit
top_byte_ok:

; do the rest by bits

        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
ulNormalize_exit:
cEnd

sEnd   CodeSeg

       end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\mci.c ===
/*-----------------------------------------------------------------------------+
| MCI.C                                                                        |
|                                                                              |
| This file contains the routines which the media player uses to interact with |
| the Media Control Interface (MCI).                                           |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#undef NOGDICAPMASKS           // CC_*, LC_*, PC_*, CP_*, TC_*, RC_
#undef NOSCROLL
#undef NOWINOFFSETS
#undef NODRAWTEXT

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <stdlib.h>
#include <shellapi.h>
#include "digitalv.h"
#include "mpole.h"
#include "mplayer.h"
#include "ctrls.h"
#include "errprop.h"
#include "utils.h"

#ifndef MCI_MCIAVI_PLAY_WINDOW
// force MCIAVI to play windowed in play in place
#define MCI_MCIAVI_PLAY_WINDOW                0x01000000L
#endif

// gets the name of the current device
STATICDT SZCODE   aszInfoProduct[]    = TEXT("info zyzsmag product");
STATICDT SZCODE   aszMMPName[]    = TEXT("Microsoft Multimedia Movie Player");

//#ifdef CHICAGO_PRODUCT
#define NEW_MCI_DIALOG
//#endif

#ifdef NEW_MCI_DIALOG

STATICDT SZCODE	  aszMCIAVIOpt[] =	TEXT("Software\\Microsoft\\Multimedia\\Video For Windows\\MCIAVI");
STATICDT SZCODE   aszDefVideoOpt[] = TEXT("DefaultOptions");

//
// !!! Caution.  These are stolen from \MCIAVI\graphic.h and are registry values
// for MCIAVI.
//
#define MCIAVIO_ZOOMBY2			0x00000100L
#define MCIAVIO_1QSCREENSIZE		0x00010000L
#define MCIAVIO_2QSCREENSIZE		0x00020000L
#define MCIAVIO_3QSCREENSIZE		0x00040000L
#define MCIAVIO_MAXWINDOWSIZE		0x00080000L
#define MCIAVIO_DEFWINDOWSIZE		0x00000000L
#define MCIAVIO_WINDOWSIZEMASK		0x000f0000L

#endif /* NEW_MCI_DIALOG */

extern HMENU    ghMenu;

/*
 * global variables
 *
 * <gwDeviceID> is the MCI device ID of the currently-open device, or NULL
 * if no device is open.  <gdwMediaLength> is the length of the entire medium
 * in milliseconds.  If <gwDeviceID> is not NULL, then:
 *   -- <gwNumTracks> is the number of tracks on the medium, or 0 if the
 *      medium doesn't support tracks
 *   -- <gwFirstTrack> is the number of the first track, currently constrained
 *      to be 0 or 1.
 *   -- <gadwTrackStart> is an array; the i-th element specifies the position
 *      of track i (starting from track 0), in milliseconds from the beginning
 *      of the medium
 *   -- <gfCanEject> is TRUE if the medium can be ejected
 *
 */

UINT            gwDeviceID;            /* MCI device ID of the current device */
UINT            gwDeviceType;          /* DTMCI_ flags of current device      */
DWORD           gdwMediaLength;        /* length in msec of the entire medium */
DWORD           gdwMediaStart;         /* start time in msec of medium        */
UINT            gwNumTracks;           /* # of tracks in the medium           */
UINT            gwFirstTrack;          /* # of first track                    */
DWORD NEAR *    gadwTrackStart;        /* array of track start positions      */
DWORD           gdwLastSeekToPosition; /* Last requested seek position        */
int extHeight;
int extWidth;

STATICDT SZCODE   aszMPlayerAlias[]     = TEXT("zyzsmag");
STATICDT SZCODE   aszStatusCommand[]    = TEXT("status zyzsmag mode");
STATICDT SZCODE   aszStatusWindow[]     = TEXT("status zyzsmag window handle");
STATICDT SZCODE   aszWindowShow[]       = TEXT("window zyzsmag state show");
STATICDT SZCODE   aszWindowHide[]       = TEXT("window zyzsmag state hide");
STATICDT SZCODE   aszSeekExactOn[]      = TEXT("set zyzsmag seek exactly on");
STATICDT SZCODE   aszSeekExactOff[]     = TEXT("set zyzsmag seek exactly off");
STATICDT SZCODE   aszSeekExact[]        = TEXT("status zyzsmag seek exactly");

STATICDT SZCODE   aszMCI[]              = MCI_SECTION;

extern UINT     gwCurScale;            // either ID_FRAMES, ID_TIME, ID_TRACKS

//#define MCI_CONFIG  0x900          // these are not found in MMSYSTEM.H
//#define MCI_TEST    0x00000020L

HWND            ghwndMCI = NULL;        /* current window for window objects */
#ifdef NEW_MCI_DIALOG
RECT            grcInitSize = { 0, 0, 0, 0 };
#endif
RECT            grcSize;                /* size of MCI object */
BOOL            gfInPlayMCI = FALSE;
extern WNDPROC  gfnMCIWndProc;
extern HWND     ghwndSubclass;



/* Status mapping stuff:
 */
typedef struct _MCI_STATUS_MAPPING
{
    WORD    Mode;
    WORD    ResourceID;
    LPTSTR  pString;
}
MCI_STATUS_MAPPING, *PMCI_STATUS_MAPPING;

MCI_STATUS_MAPPING MCIStatusMapping[] =
{
    { MCI_MODE_NOT_READY,   IDS_SSNOTREADY,     NULL },
    { MCI_MODE_STOP,        IDS_SSSTOPPED,      NULL },
    { MCI_MODE_PLAY,        IDS_SSPLAYING,      NULL },
    { MCI_MODE_RECORD,      IDS_SSRECORDING,    NULL },
    { MCI_MODE_SEEK,        IDS_SSSEEKING,      NULL },
    { MCI_MODE_PAUSE,       IDS_SSPAUSED,       NULL },
    { MCI_MODE_OPEN,        IDS_SSOPEN,         NULL },
    { MCI_VD_MODE_PARK,     IDS_SSPARKED,       NULL },
    { 0,                    IDS_SSUNKNOWN,      NULL }
};

static TCHAR szNULL[] = TEXT("");

/* Devices we know about, as they appear in system.ini, or the registry:
 */
SZCODE szCDAudio[]     = TEXT("cdaudio");
SZCODE szVideoDisc[]   = TEXT("videodisc");
SZCODE szSequencer[]   = TEXT("sequencer");
SZCODE szVCR[]         = TEXT("vcr");
SZCODE szWaveAudio[]   = TEXT("waveaudio");
SZCODE szAVIVideo[]    = TEXT("avivideo");


STRING_TO_ID_MAP DevToDevIDMap[] =
{
    { szCDAudio,    DTMCI_CDAUDIO   },
    { szVideoDisc,  DTMCI_VIDEODISC },
    { szSequencer,  DTMCI_SEQUENCER },
    { szVCR,        DTMCI_VCR       },
    { szWaveAudio,  DTMCI_WAVEAUDIO },
    { szAVIVideo,   DTMCI_AVIVIDEO  }
};


void LoadStatusStrings(void);
STATICFN BOOL NEAR PASCAL CheckErrorMCI(DWORD dwRet);
extern LPTSTR FAR FileName(LPCTSTR szPath);

HPALETTE CopyPalette(HPALETTE hpal);
HANDLE   PictureFromBitmap(HBITMAP hbm, HPALETTE hpal);
HANDLE   FAR PASCAL PictureFromDib(HANDLE hdib, HPALETTE hpal);
HANDLE   FAR PASCAL DibFromBitmap(HBITMAP hbm, HPALETTE hpal);



LONG_PTR FAR PASCAL _EXPORT MCIWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

//
// we will either send every command with a MCI_NOTIFY, or we will
// not.
//

  #define F_NOTIFY  MCI_NOTIFY
//#define F_NOTIFY  0

BOOL FAR PASCAL InitMCI(HANDLE hPrev, HANDLE hInst)
{
    if (!hPrev)
    {
        WNDCLASS cls;

        cls.lpszClassName   = MCI_WINDOW_CLASS;
        cls.lpfnWndProc     = (WNDPROC)MCIWndProc;
        cls.style           = CS_HREDRAW | CS_VREDRAW | CS_SAVEBITS |
                              CS_DBLCLKS;
        cls.hCursor         = LoadCursor(NULL,IDC_ARROW);
        cls.hIcon           = NULL;
        cls.lpszMenuName    = NULL;
        cls.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1);
        cls.hInstance       = hInst;
        cls.cbClsExtra      = 0;
        cls.cbWndExtra      = 0;

        if (!RegisterClass(&cls))
            return FALSE;
    }

    LoadStatusStrings();

    return TRUE;
}


/* LoadStatusStrings
 *
 * Fixes up the status-mapping table with pointers to strings loaded
 * from resources.  This need be called only on initialisation.
 *
 * 2 February 1994, andrewbe, hardly at all based on the original.
 */
void LoadStatusStrings(void)
{
    int   i;
    TCHAR Buffer[80];

    for( i = 0; i < sizeof(MCIStatusMapping) / sizeof(*MCIStatusMapping); i++ )
    {
        if( LOADSTRING( MCIStatusMapping[i].ResourceID, Buffer ) )
        {
            MCIStatusMapping[i].pString = AllocStr( Buffer );

            if( MCIStatusMapping[i].pString == NULL )
            {
                MCIStatusMapping[i].pString = szNULL;
            }
        }
        else
        {
            DPF0( "LoadStatusStrings failed to load string ID %d\n", MCIStatusMapping[i].ResourceID );

            MCIStatusMapping[i].pString = szNULL;
        }
    }
}



/* MapModeToStatusString
 *
 * Given an MCI mode, scans the mapping table to find the corresponding string.
 * In the event that an unknown mode is passed in (which shouldn't really happen),
 * the last string in the mapping table is returned.
 *
 * 2 February 1994, andrewbe
 */
LPTSTR MapModeToStatusString( WORD Mode )
{
    int i;

    for( i = 0; i < sizeof(MCIStatusMapping) / sizeof(*MCIStatusMapping); i++ )
    {
        if( MCIStatusMapping[i].Mode == Mode )
        {
            return MCIStatusMapping[i].pString;
        }
    }

    /* The following assumes that the last in the array of status mappings
     * contains a pointer to the "(unknown)" string:
     */
    return MCIStatusMapping[sizeof(MCIStatusMapping) / sizeof(*MCIStatusMapping) - 1].pString;
}


/******************************Public*Routine******************************\
* IsCdromTrackAudio
*
* Filched from CD Player
*
\**************************************************************************/
BOOL IsCdromTrackAudio(
    MCIDEVICEID DevHandle,
    int iTrackNumber)
{
    MCI_STATUS_PARMS mciStatus;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );
    mciStatus.dwItem = MCI_CDA_STATUS_TYPE_TRACK;
    mciStatus.dwTrack = iTrackNumber + 1;

    mciSendCommand( DevHandle, MCI_STATUS, MCI_STATUS_ITEM | MCI_TRACK,
                    (DWORD_PTR)(LPVOID)&mciStatus);

    return mciStatus.dwReturn == MCI_CDA_TRACK_AUDIO;
}


/* IsCdromDataOnly
 *
 * It seems that MCICDA can handle CDs with some audio tracks, so just check
 * whether there is at least one audio track.
 *
 */
BOOL IsCdromDataOnly()
{
    MCI_STATUS_PARMS mciStatus;
    DWORD            dw;
    DWORD            iTrack;
    DWORD_PTR            NumTracks;

    /* gwNumTracks is set in UpdateMCI, but it hasn't been called
     * at this stage in the proceedings, and I'm not about to start
     * changing the order that things are done and bring this whole
     * flimsy edifice tumbling down.
     */
    ZeroMemory( &mciStatus, sizeof(mciStatus) );
    mciStatus.dwItem = MCI_STATUS_NUMBER_OF_TRACKS;
    dw = mciSendCommand(gwDeviceID, MCI_STATUS, MCI_STATUS_ITEM,
                        (DWORD_PTR)&mciStatus);

    /* Do NOT set gwNumtracks here, because this will result in an
     * access violation in CalcTicsOfDoom.  What a nightmare!
     */
    NumTracks = mciStatus.dwReturn;

    /* If there was an error or there are no tracks, let's hope MCICDA
     * will throw a wobbly.
     */
    if (dw != 0 || NumTracks == 0)
        return FALSE;

    /* Now run through the tracks until we find an audio one:
     */
    for (iTrack = 0; iTrack < NumTracks - 1; iTrack++)
    {
        if (IsCdromTrackAudio(gwDeviceID, iTrack))
            return FALSE;
    }

    return TRUE;
}


#ifdef NEW_MCI_DIALOG
//
// Read the MCIAVI playback options from the registry
//
DWORD ReadOptionsFromReg(void)
{
	HKEY hkVideoOpt;
	DWORD dwType;
	DWORD dwOpt;
	DWORD cbSize;

    if(RegCreateKey(HKEY_CURRENT_USER, (LPTSTR)aszMCIAVIOpt,  &hkVideoOpt))
		return 0 ;

    cbSize = sizeof(DWORD);
    if (RegQueryValueEx(hkVideoOpt, (LPTSTR)aszDefVideoOpt, NULL, &dwType,
		(LPBYTE)&dwOpt,&cbSize ))
    {
	dwOpt = 0;
	RegSetValueEx(hkVideoOpt, (LPTSTR)aszDefVideoOpt, 0, REG_DWORD,
		(LPBYTE)&dwOpt, sizeof(DWORD));
    }
	RegCloseKey(hkVideoOpt);
    return dwOpt;
}

//
// Obey the registry default sizing of Zoom by 2 and Fixed screen %.  Takes the
// registry values for MCIAVI and a rect, and either zooms it by 2 or replaces
// it with a constant size or leaves it alone.
//
void FAR PASCAL AlterRectUsingDefaults(LPRECT lprc)
{
        DWORD dwOptions;

	// This is only an MCIAVI hack.
	if ((gwDeviceType & DTMCI_DEVICE) != DTMCI_AVIVIDEO)
	    return;

	dwOptions = ReadOptionsFromReg();

	if (dwOptions & MCIAVIO_ZOOMBY2)
	    SetRect(lprc, 0, 0, lprc->right*2, lprc->bottom*2);

	else if (dwOptions & MCIAVIO_WINDOWSIZEMASK) {
		lprc->right = GetSystemMetrics (SM_CXSCREEN);
       		lprc->bottom = GetSystemMetrics (SM_CYSCREEN);
		switch(dwOptions & MCIAVIO_WINDOWSIZEMASK)
		{
		    case MCIAVIO_1QSCREENSIZE:
			SetRect(lprc, 0, 0, lprc->right/4, lprc->bottom/4);
			break;
		    case MCIAVIO_2QSCREENSIZE:
			SetRect(lprc, 0, 0, lprc->right/2, lprc->bottom/2);
			break;
		    case MCIAVIO_3QSCREENSIZE:
			SetRect(lprc, 0, 0, lprc->right*3/4, lprc->bottom*3/4);
			break;
		    case MCIAVIO_MAXWINDOWSIZE:
			SetRect(lprc, 0, 0, lprc->right, lprc->bottom);
			break;
		}
	}
}

#endif /* NEW_MCI_DIALOG */

/*
 * fOK = OpenMCI(szFile, szDevice)
 *
 * Open the file/device combination of <szFile> and <szDevice>.
 * <szFile> may be "" if a "pure device" (e.g. "CDAudio") is to be opened.
 * <szDevice> may be "" if a file is to be opened with an implicit type.
 * However, <szFile> and <szDevice> may not both be "".
 *
 * On success, return TRUE.  On failure, display an error message and
 * return FALSE.
 *
 */

BOOL FAR PASCAL OpenMCI(
    LPCTSTR szFile,        /* name of the media file to be loaded (or "")    */
    LPCTSTR szDevice)      /* name of the device to be opened (or "")        */
{
    MCI_OPEN_PARMS      mciOpen;    /* Structure for MCI_OPEN command */
    DWORD               dwFlags;
    DWORD               dw;
    HCURSOR             hcurPrev;
    HDRVR               hdrv;
    SHFILEINFO          sfi;
	HFILE				hFile;

    /*
     * This application is designed to handle only one device at a time,
     * so before opening a new device we should close the device that is
     * currently open (if there is one).
     *
     * in case the user is opening a file of the same device again, do
     * an OpenDriver to hold the DLL in memory.
     *
     */
    if (gwDeviceID && gwCurDevice > 0) {

#ifdef UNICODE
        hdrv = OpenDriver(garMciDevices[gwCurDevice].szDevice, aszMCI, 0);
#else
        //
        // There is only a UNICODE version of OpenDriver.  Unfortunately
        // the majority of this code is Ascii.  Convert the ASCII strings
        // to UNICODE, then call OpenDriver
        //
        WCHAR               waszMCI[sizeof(aszMCI)];
        WCHAR               wszDevice[40];
        AnsiToUnicodeString(aszMCI, waszMCI, UNKNOWN_LENGTH);
        AnsiToUnicodeString(garMciDevices[gwCurDevice].szDevice, wszDevice, UNKNOWN_LENGTH);
        hdrv = OpenDriver((LPCWSTR)garMciDevices[gwCurDevice].szDevice,
                          (LPCWSTR)aszMCI,
                          0);
#endif
    }
    else
        hdrv = NULL;

    CloseMCI(TRUE);

    //
    //  Store the displayable file/device name in <gachFileDevice>
    //
    if (szFile == NULL || szFile[0] == 0) {
        /* It's a device -- display the device name */
        lstrcpy(gachFileDevice, szDevice);

        if (gwCurDevice > 0)
            lstrcpy(gachWindowTitle,garMciDevices[gwCurDevice].szDeviceName);
        else
            lstrcpy(gachWindowTitle,gachFileDevice);
    } else {
        /* It's a file -- display the filename */
        lstrcpy(gachFileDevice,  szFile);  //!!!

        // Makes the window title be the name of the file being played
        lstrcpy(gachWindowTitle, FileName(gachFileDevice));
    }

    /* Get the display name for this file:
     */

    if (SHGetFileInfo(gachFileDevice, 0 /* No file attributes specified */,
                    &sfi, sizeof sfi, SHGFI_DISPLAYNAME))
        lstrcpy(gachWindowTitle, sfi.szDisplayName);

    //
    // Set caption to the WindowTitle
    //
    lstrcpy(gachCaption, gachWindowTitle);


    /*
     * because *most* MCI devices yield during the open call, we *must*
     * register our document *before* doing the open.  OLE does not expect
     * the server app to yield when exec'ed with a link request.
     *
     * if the open fails then we revoke our document right away.
     */

//  if (!gfEmbeddedObject)
//      RegisterDocument(0L,0L);

    /*
     * Show the hourglass cursor -- who knows how long this stuff
     * will take
     */

    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    DPF("OpenMCI: Device = %"DTS", File = %"DTS"\n", szDevice ? szDevice : TEXT("(null)"),szFile ? szFile : TEXT("(null)"));

    mciOpen.lpstrAlias = aszMPlayerAlias;
    dwFlags = MCI_OPEN_ALIAS;

    if (szFile == NULL || szFile[0] == 0) {

        /* Open a fileless (simple) device (e.g. "CDAudio") */

        mciOpen.lpstrDeviceType = szDevice;
        dwFlags |= MCI_WAIT | MCI_OPEN_TYPE | MCI_OPEN_SHAREABLE;
    } else if (szDevice == NULL || szDevice[0] == 0) {
        /*
         * Open a file; the correct device is determined implicitly by the
         * filename extension.
         *
         */
        mciOpen.lpstrElementName = szFile;
        mciOpen.lpstrDeviceType = NULL;
        dwFlags |= MCI_WAIT | MCI_OPEN_ELEMENT;
    } else {

        /* Open a file with an explicitly specified device */

        mciOpen.lpstrDeviceType = szDevice;
        mciOpen.lpstrElementName = szFile;
        dwFlags |= MCI_WAIT | MCI_OPEN_ELEMENT | MCI_OPEN_TYPE;
    }

    /*
     * Now that we have filled the parameter structure appropriately and
     * supplied the correct flags, send the actual MCI_OPEN message.
     *
     */

    //
    // What if the MCI device brings up an error box!  We don't want MPlayer
    // to be allowed to exit.
    //
    gfErrorBox++;

    dw = mciSendCommand((MCIDEVICEID)0, MCI_OPEN, dwFlags,(DWORD_PTR)(LPVOID)&mciOpen);

    if (dw != 0 && (dwFlags & MCI_OPEN_SHAREABLE))
        dw = mciSendCommand((MCIDEVICEID)0, MCI_OPEN, (dwFlags & ~MCI_OPEN_SHAREABLE),
            (DWORD_PTR)(LPVOID)&mciOpen);
    DPF("MCI_OPEN returned %lu, wDeviceID=%u\n", dw, mciOpen.wDeviceID);
    gfErrorBox--;

    /*
     * now free the driver instance we opened above.
     */
    if (hdrv)
        CloseDriver(hdrv, 0, 0);

    if (hcurPrev)
        SetCursor(hcurPrev);

    if (dw != 0 && !gfEmbeddedObject) {
//      UnblockServer();        // we may have blocked before and the error
                                // recovery code will loop infinitely if we're
                                // blocked!
        InitDoc(TRUE);
    }

    /* If the open was unsuccessful, display an error message and return */

    if (dw == MCIERR_DEVICE_OPEN ||       /* nonshareable device already open */
        dw == MCIERR_MUST_USE_SHAREABLE) {
        Error(ghwndApp, IDS_DEVICEINUSE);
        return FALSE;
    }

    if (dw == MCIERR_FILE_NOT_FOUND) {
		//Need to give an appropriate error message.
		//The following could be the causes:
		//1. File does not exist
		//This is already handled by the file open dialog box.
		//2. Access to the file is denied. (bug #53492)
		//3. The file is opened exclusively by another app.
		//The file already exists. so if it cannot be opened for reading
		//either access is denied or it is opened by another app.
	    if ((hFile = (HFILE)HandleToUlong(CreateFile (szFile, GENERIC_READ, 
						    FILE_SHARE_READ, NULL, 
						    OPEN_EXISTING, 0, NULL))) == HFILE_ERROR)
        {
			Error(ghwndApp, IDS_CANTACCESSFILE);
		}
		//4. File was not in a recognized format
		else
		{	
			_lclose(hFile);
			Error(ghwndApp, IDS_CANTOPENFILE);
		}
        return FALSE;
    }


   /* If the MCI device that plays the given file does not exist then  */
   /* bring up a  dialog box and close mplayer.                        */
    if (dw == MCIERR_INVALID_DEVICE_NAME) {
        Error(ghwndApp,  IDS_DEVICENOTINSTALLED);
        return FALSE;
    }

    if (dw != 0) {                     /* some other error */
        //
        // try again, if we can't open the file with a particular device.
        // this lets the MCI core try to figure out the device type from
        // the file extension, or some other method.
        //
        if ((dw != MCIERR_DRIVER_INTERNAL) && szDevice != NULL &&
            szDevice[0] != 0) {
            if (szFile && szFile[0] != 0) {
                return OpenMCI(szFile, TEXT(""));
            }
        }

        CheckErrorMCI(dw);
        return FALSE;
    }

    /* The open was successful, so retain the MCI device ID for later use */
    gwDeviceID = (UINT)mciOpen.wDeviceID;

    //
    //  now query the device and see what it can do
    //
    FindDeviceMCI();
    gwDeviceType = QueryDeviceTypeMCI(gwDeviceID);

    if (!(gwDeviceType & DTMCI_CANPLAY)) {
        Error(ghwndApp, IDS_DEVICECANNOTPLAY);
        CloseMCI(TRUE);
        return FALSE;
    }

    if (!(gwDeviceType & (DTMCI_TIMEMS|DTMCI_TIMEFRAMES))) {
        Error(ghwndApp, IDS_NOGOODTIMEFORMATS);
        CloseMCI(TRUE);
        return FALSE;
    }

    if (gwDeviceType & DTMCI_CANWINDOW) {
        GetDestRectMCI(&grcSize);
#ifdef NEW_MCI_DIALOG
        grcInitSize = grcSize;
        // HACK!! We want to pay attention to some MCIAVI registry default
        // sizes, so we'll read the registry and adjust the size of the movie
        // accordingly.
    	AlterRectUsingDefaults(&grcSize);
#endif /* NEW_MCI_DIALOG */
    } else
        SetRectEmpty(&grcSize);

    if (IsRectEmpty(&grcSize)) {
        DPF("NULL rectange in GetDestRect() assuming device cant window!\n");
        gwDeviceType &= ~DTMCI_CANWINDOW;
    }

    /* Turn on the update-display timer so the display is updated regularly */

    EnableTimer(TRUE);

    /*
    ** for devices that do windows, show the window right away.
    **
    ** !!! note when we support a built in window it will go here.
    */
    if (gfPlayOnly) {
        CreateWindowMCI();
        if (!IsIconic(ghwndApp))
            SetMPlayerSize(&grcSize);
    }
    else if (GetWindowMCI() && IsWindowVisible(ghwndApp)) {

        MCI_SEEK_PARMS  mciSeek;        /* parameter structure for MCI_SEEK */
        TCHAR           achReturn[40];

        PostMessage(ghwndApp, WM_QUERYNEWPALETTE, 0, 0);

        //
        // make sure the default window is the right size.
        //
        PutWindowMCI(NULL);

        //
        // center the default window above or below our window
        //
        SmartWindowPosition(GetWindowMCI(), ghwndApp, TRUE);

        //
        // make sure the default window is showing
        //
        ShowWindowMCI(TRUE);

        /* hack for MMP, do a seek to the start, it does not paint
           correctly for some reason if we just show the window!
           NOTE:  0 may not be the start of the media so this may
           fail, but OH WELL! We can't call UpdateMCI yet to set
           gdwMediaStart because we don't know the scale (time/frames)
           yet so UpdateMCI won't set gdwMediaLength properly, and
           I don't feel like calling UpdateMCI twice, so tough!!
           And we can't just SeekMCI(0) because UpdateDisplay will get
           called too soon so we hack everything!                      */

        mciSendString(aszInfoProduct, achReturn,
                      CHAR_COUNT(achReturn), NULL);
        if (!lstrcmpi(achReturn, aszMMPName)) {
            mciSeek.dwTo = 0;
            dw = mciSendCommand(gwDeviceID, MCI_SEEK, MCI_TO,
                                (DWORD_PTR)&mciSeek);
        }
    }

    /*
     * Remember to update the media information and the caption when
     * UpdateDisplay() is next called.  We don't set them until now
     * because we want the ReadDefaults() to be called which will set
     * gwCurScale to happen before UpdateDisplay calls UpdateMCI.
     */
    gfValidMediaInfo = FALSE;
    gfValidCaption = FALSE;

    return TRUE;
}

//
//  GetDeviceNameMCI()
//
// wLen is the size IN BYTES of szDevice buffer
void FAR PASCAL GetDeviceNameMCI(LPTSTR szDevice, UINT wLen)
{
    MCI_SYSINFO_PARMS   mciSysInfo;
    DWORD               dw;

    //
    // assume failure.
    //
    szDevice[0] = 0;

    mciSysInfo.dwCallback = 0L;
    mciSysInfo.lpstrReturn = szDevice;
    mciSysInfo.dwRetSize = wLen;
    mciSysInfo.dwNumber = 0;
    mciSysInfo.wDeviceType = 0;

    if (gwDeviceID) {
        dw = mciSendCommand(gwDeviceID, MCI_SYSINFO,
            MCI_SYSINFO_INSTALLNAME,
            (DWORD_PTR)(LPVOID)&mciSysInfo);
    }
}

//
//  QueryDevicesMCI
//
// wLen is the size IN BYTES of szDevice buffer
//
// Returns a list of devices in form "<device1>\0<device2>\0 ... <deviceN>\0\0"
void FAR PASCAL QueryDevicesMCI(LPTSTR szDevices, UINT wLen)
{
    MCI_SYSINFO_PARMS mciSysInfo;
    DWORD             dw;
    DWORD             i;
    DWORD_PTR         cDevices;     /* Total number of devices to enumerate */
    DWORD             BufferPos;    /* Index to end of buffer */

    //
    // assume failure.
    //
    szDevices[0] = 0;
    szDevices[1] = 0;

    mciSysInfo.dwCallback = 0L;
    mciSysInfo.lpstrReturn = szDevices;
    mciSysInfo.dwRetSize = wLen;
    mciSysInfo.dwNumber = 0;
    mciSysInfo.wDeviceType = MCI_ALL_DEVICE_ID;

    /* How many devices does mmsystem know about?
     */
    dw = mciSendCommand(MCI_ALL_DEVICE_ID,
                        MCI_SYSINFO,
                        MCI_SYSINFO_QUANTITY,
                        (DWORD_PTR)(LPVOID)&mciSysInfo);

    if (dw == 0) {

        /* Device count is returned in lpstrReturn!
         */
        cDevices = (DWORD_PTR)(LPVOID)*mciSysInfo.lpstrReturn;
        BufferPos = 0;

        /* Get the name of each device in turn.  N.B. Not zero-based!
         * Ensure there's room for the final (double) null terminator.
         */
        for (i = 1; i < (cDevices + 1) && BufferPos < (wLen - 1); i++) {

            mciSysInfo.lpstrReturn = &(szDevices[BufferPos]);
            mciSysInfo.dwRetSize = wLen - BufferPos; /* How much space left */
            mciSysInfo.dwNumber = i;

            dw = mciSendCommand(MCI_ALL_DEVICE_ID,
                                MCI_SYSINFO,
                                MCI_SYSINFO_NAME,
                                (DWORD_PTR)(LPVOID)&mciSysInfo);

            if (dw == 0) {
                DPF1("Found device: %"DTS"\n", &(szDevices[BufferPos]));
                BufferPos += (lstrlen(&(szDevices[BufferPos])) + 1);
            }
        }

        /* Not strictly required, since our buffer was allocated LMEM_ZEROINIT:
         */
        szDevices[BufferPos] = '\0';
    }
}



//
//  FindDeviceMCI()
//
//  Find the device the user just opened.  We normally should know what
//  was opened, but in the auto-open case MCI will pick a device for us.
//
//  Determines what device is associated with <gwDeviceID> and
//  sets the <gwCurDevice> global.
//
//  Called by OpenMCI() whenever a new device is opened successfully.
//
void FAR PASCAL FindDeviceMCI(void)
{
    UINT                w;
    TCHAR               achDevice[80];

    //
    // assume failure.
    //
    gwCurDevice = 0;

    GetDeviceNameMCI(achDevice, BYTE_COUNT(achDevice));

    for (w=1; w<=gwNumDevices; w++)
    {
        if (lstrcmpi(achDevice, garMciDevices[w].szDevice) == 0) {
            gwCurDevice  = w;
        }

        if (ghMenu)
            CheckMenuItem(ghMenu, IDM_DEVICE0+w, MF_BYCOMMAND |
                ((gwCurDevice == w) ? MF_CHECKED : MF_UNCHECKED));
    }

    if (gwCurDevice == 0)
    {
        DPF("FindDevice: Unable to find device\n");
    }
}

void FAR PASCAL CreateWindowMCI()
{
    RECT        rc;
    HWND        hwnd;

    if (IsWindow(ghwndMCI) || !gwDeviceID || !(gwDeviceType & DTMCI_CANWINDOW))
        return;

    /* Figure out how big the Playback window is, and make our MCI window */
    /* the same size.                                                     */

    hwnd = GetWindowMCI();

    if (hwnd != NULL)
        GetClientRect(hwnd, &rc);
    else
        rc = grcSize;  // use original size if error

    CreateWindowEx(gfdwFlagsEx,
                   MCI_WINDOW_CLASS,
                   TEXT(""),
                   WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                   rc.left,
                   rc.top,
                   rc.right  - rc.left,
                   rc.bottom - rc.top,
                   ghwndApp,
                   (HMENU)NULL,
                   ghInst,
                   NULL);
}

/*
 * SendStringMCI() - send a MCI string command to the device.
 *
 * the string is of the form "verb params" our device name is inserted
 * after the verb and sent to the device.
 *
 */
DWORD PASCAL SendStringMCI(PTSTR szCmd, PTSTR szReturn, UINT wLen /* Characters */)
{
    TCHAR ach[MCI_STRING_LENGTH + CHAR_COUNT(aszMPlayerAlias) + 1];
    TCHAR *pch;

    pch = ach;
    while (*szCmd && *szCmd != TEXT(' '))
        *pch++ = *szCmd++;

    *pch++ = TEXT(' ');
    lstrcpy(pch,aszMPlayerAlias);
    lstrcat(pch,szCmd);

    return mciSendString(ach, szReturn, wLen, ghwndApp);
}

/*
 * UpdateMCI()
 *
 * Update <gfCanEject>, <gdwMediaLength>, <gwNumTracks>, and <gadwTrackStart>
 * to agree with what MCI knows them to be.
 */
void FAR PASCAL UpdateMCI(void)
{
    MCI_STATUS_PARMS        mciStatus;    /* Structure for MCI_STATUS command */
    DWORD                   dw;
    HCURSOR                 hcurPrev;

    if (gfValidMediaInfo)
        return;

    /* If no device is currently open, then there's nothing to update */

    if (gwDeviceID == (UINT)0) {
        return;
    }

    /*
     * Show the hourglass cursor -- who knows how long this stuff will take
     */

    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    /*
     * This function may fail (due to I/O error etc.), but we might as
     * well say that the media information is valid now, because otherwise
     * we'll just get into an endless loop.
     *
     */

    gfValidMediaInfo = TRUE;

    gdwMediaStart = 0L;
    gdwMediaLength = 0L;
    gwNumTracks = 0;

    /* If things aren't valid anyway, give up. */
    if (gwStatus == MCI_MODE_OPEN || gwStatus == MCI_MODE_NOT_READY)
        goto exit;

    /* Find out how many tracks are present in the medium */

    mciStatus.dwItem = MCI_STATUS_NUMBER_OF_TRACKS;
    dw = mciSendCommand(gwDeviceID, MCI_STATUS, MCI_STATUS_ITEM,
                        (DWORD_PTR)&mciStatus);

#ifdef DEBUG
    DPF("MCI_STATUS (MCI_STATUS_NUMBER_OF_TRACKS) returned %lu,"
        " %d tracks\n", dw, mciStatus.dwReturn);
#endif

    /*
     * If the command retuned a value of zero, then the medium contains tracks,
     * so use the number of tracks returned in the parameter structure.
     * Otherwise, the medium does not contain tracks, so use a value of 0.
     *
     */

    if (dw == 0L)
        gwNumTracks = (UINT) mciStatus.dwReturn;

    /* Set the correct time format either frames or milliseconds */

    if (gwCurScale == ID_FRAMES && !(gwDeviceType & DTMCI_TIMEFRAMES))
        gwCurScale = ID_TIME;

    if (gwCurScale == ID_TRACKS && gwNumTracks <= 1)
        gwCurScale = ID_TIME;

    if (gwCurScale == ID_TIME && !(gwDeviceType & DTMCI_TIMEMS))
        gwCurScale = ID_FRAMES;

    /* set the time format, If this does not work, punt. */
    if (!SetTimeFormatMCI(gwCurScale == ID_FRAMES ? MCI_FORMAT_FRAMES : MCI_FORMAT_MILLISECONDS))
        goto exit;

    mciStatus.dwItem = MCI_STATUS_LENGTH;
    dw = mciSendCommand(gwDeviceID, MCI_STATUS, MCI_STATUS_ITEM,
                        (DWORD_PTR)&mciStatus);

    DPF("MCI_STATUS (MCI_STATUS_LENGTH) returned %lu, media length %ld\n", dw, mciStatus.dwReturn);

    /*
     * If the MCI command returned a nonzero value, then an error has
     * occurred, so alert the user, close the offending device, and return.
     *
     */

    if (dw != 0L)
        goto exit;

    /* Everything is OK, so retain the media length for later use */

    gdwMediaLength = (DWORD)mciStatus.dwReturn;

    mciStatus.dwItem = MCI_STATUS_POSITION;
    dw = mciSendCommand(gwDeviceID, MCI_STATUS,
        MCI_STATUS_START | MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);

#ifdef DEBUG
    DPF2("MCI_STATUS (MCI_STATUS_START) returned %lu, start %ld\n",dw, mciStatus.dwReturn);
#endif

    gdwMediaStart = (DWORD)mciStatus.dwReturn;

    if (dw != 0) {
        /* Error: forget about track display */
        gwNumTracks = 0;
    }

    if (gwNumTracks > 0) {

        UINT    wTrack;

        /* Free the track map if it already exists */

        if (gadwTrackStart != NULL)
            FreeMem(gadwTrackStart, sizeof(DWORD) * gwNumTracks);

        /* Allocate memory for the track map */

        gadwTrackStart = AllocMem(sizeof(DWORD) * gwNumTracks);
        if (gadwTrackStart == NULL) {

            /* AllocMem() failed - alert the user, close the device, return */

            Error(ghwndApp, IDS_OUTOFMEMORY);
            gwNumTracks = 0;
            goto exit;
        }

        /* See if there is a track zero */
        mciStatus.dwItem = MCI_STATUS_POSITION;
        mciStatus.dwTrack = (DWORD) 0;
        dw = mciSendCommand(gwDeviceID, MCI_STATUS,
            MCI_TRACK | MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);

#ifdef DEBUG
      DPF2("MCI_STATUS (MCI_STATUS_START for track %lu) returned %lu, start %ld\n", mciStatus.dwTrack, dw, mciStatus.dwReturn);
#endif

        if (dw == 0)
            gwFirstTrack = 0;
        else
            gwFirstTrack = 1;

        /* Get the track map from MCI */

        for (wTrack = 0; wTrack < gwNumTracks; wTrack++) {

            mciStatus.dwItem = MCI_STATUS_POSITION;
            mciStatus.dwTrack = (DWORD) wTrack + gwFirstTrack;
            dw = mciSendCommand(gwDeviceID, MCI_STATUS,
                MCI_TRACK | MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);

#ifdef DEBUG
            DPF2("MCI_STATUS (MCI_STATUS_START for track %lu) returned %lu, start %ld\n", mciStatus.dwTrack, dw,mciStatus.dwReturn);
#endif

            if (dw != 0) {
#if 1
                /* Error: forget about track display */
                gwNumTracks = 0;
                goto exit;
#else
                /* An error occurred - do the usual stuff */

                Error(ghwndApp, IDS_CANTACCESSFILEDEV);
                goto exit;
#endif
            }

            /* Add the start of this track to the track list */

            gadwTrackStart[wTrack] = (DWORD)mciStatus.dwReturn;
        }
    }

    /*
     * Invalidate the track map window so it will be redrawn with the
     * correct positions, etc.
     *
     */
exit:
#ifdef DEBUG
    DPF("Finished updating status: # tracks = %u, length = %lu\n", gwNumTracks, gdwMediaLength);
#endif

    SendMessage(ghwndTrackbar, TBM_SETRANGEMIN, (WPARAM)FALSE, gdwMediaStart);
    SendMessage(ghwndTrackbar, TBM_SETRANGEMAX, (WPARAM)FALSE, gdwMediaStart + gdwMediaLength);

    /* We must set the range before calling TBM_SETTIC (which is sent by
     * CalcTicsOfDoom()), since the common trackbar now tests the range
     * before accepting a new tic.
     * It would probably be better to set the range in CalcTicsOfDoom().
     */
    if (!gfCurrentCDNotAudio)
        CalcTicsOfDoom();

    SendMessage(ghwndTrackbar, TBM_SETSELSTART, (WPARAM)FALSE, -1);   // invalid selection
    SendMessage(ghwndTrackbar, TBM_SETSELEND, (WPARAM)TRUE, -1);

    if (hcurPrev)
        SetCursor(hcurPrev);
}

/*
 * CloseMCI(fUpdateDisplay)
 *
 * Close the currently-open MCI device (if any).  If <fUpdateDisplay>
 * is TRUE, then update the display as well.
 *
 * Closing the device merely relinquishes control of it so that the device
 * may be used by someone else. The device does not necessarily stop playing
 * or return to the start of the medium when this message is received - the
 * behaviour is device-dependent.
 *
 */

void FAR PASCAL CloseMCI(BOOL fUpdateDisplay)
{
    DWORD       dw;
    UINT        w;
    HWND        hwnd;

    if (!gfEmbeddedObject)
        gachCaption[0] = 0; // nuke the caption

    /* If no device is currently open, then there's nothing to close */
    if (gwDeviceID == (UINT)0)
        return;

    /*
     * Disable the display-update timer, as there's no longer any reason to
     * periodically update the display.
     */
    EnableTimer(FALSE);

////StopMCI();

    //
    // set either the owner or the WS_CHILD bit so it will
    // not act up because we have the palette bit set and cause the
    // desktop to steal the palette.
    //
    // because we are being run from client apps that dont deal
    // with palettes we dont want the desktop to hose the palette.
    //
    hwnd = GetWindowMCI();

    if ((hwnd != NULL) && gfRunWithEmbeddingFlag)
        SetParent(hwnd, ghwndApp);

    /* Send the MCI CLOSE message, and set the current device to NULL */
    dw = mciSendCommand(gwDeviceID, MCI_CLOSE, 0L, (DWORD_PTR)0);
    gwDeviceID = (UINT)0;
    gwDeviceType = 0;
    gwCurScale = ID_NONE;
    SetRectEmpty(&grcSize);

    /* Now close the MCI window AFTER we close the MCIDevice, so that the */
    /* SetMCIWindow(NULL) this does won't flash up a default playback win.*/
    if (ghwndMCI) {
        /*
        **  Don't pass the WM_CLOSE to the subclass window proc or it will
        **  spuriously issue and IDM_CLOSE again!
        */
        if (gfnMCIWndProc != NULL && ghwndSubclass == ghwndMCI) {
            SetWindowLongPtr(ghwndMCI, GWLP_WNDPROC, (LONG_PTR)gfnMCIWndProc);
            gfnMCIWndProc = NULL;
        }
        SendMessage(ghwndMCI, WM_CLOSE, 0, 0L);
    }

    /* Don't set gwCurDevice = 0 because if we were called by Open MCI, then */
    /* we won't remember what device we were opening.  So instead, we'll set */
    /* gwCurDevice = 0 after returning from CloseMCI if we so desire.  I know*/
    /* it sounds hacky, but Todd told me to do it this way. End disclamer.   */

    /* Uncheck the device menus */
    if (ghMenu) {
        for (w = 1; w <= gwNumDevices; w++)
            CheckMenuItem(ghMenu, IDM_DEVICE0 + w, MF_BYCOMMAND | MF_UNCHECKED);
    }

    DPF("MCI_CLOSE returned %lu\n", dw);

    /* Free up the resources used by the track map */

    if (gadwTrackStart != NULL)
    {
        FreeMem(gadwTrackStart, sizeof(DWORD) * gwNumTracks);
        gadwTrackStart = NULL;
    }

    /* If you have auto-repeat on and you load a new file in between the   */
    /* repeating, the new file may come up with no buttons or no scrollbar */
    /* because our JustPlayed code sets the old status to PLAY which avoids*/
    /* updating.                                                           */
    gfJustPlayed = FALSE;

    /*
     * If the display update flag was set, then update the display, taking
     * into account that the media information and caption are now inaccurate.
     */
    if (fUpdateDisplay) {
        gfValidCaption = FALSE;
        gfValidMediaInfo = FALSE;
        UpdateDisplay();
    }
}

/* Helper function to check return code from MCI functions. */
STATICFN BOOL NEAR PASCAL CheckErrorMCI(DWORD dwRet)
{
    TCHAR       ach[200];
    if (dwRet != 0 && dwRet != MCIERR_NONAPPLICABLE_FUNCTION) {
        mciGetErrorString(dwRet, ach, CHAR_COUNT(ach));
        Error1(ghwndApp, IDS_DEVICEERROR, ach);
//      CloseMCI(TRUE);
        return FALSE;
    }
    return TRUE;
}

/*
 * PlayMCI()
 *
 * Start the current device playing.  If the device is in a paused state,
 * un-pause it.
 * Maybe play the selection.
 *
#ifdef NEW_MCI_DIALOG
 * NOTE:  MCIAVI will automatically play fullscreen if that option is selected
 * in the registry.  We don't have to do anything.
#endif NEW_MCI_DIALOG
 *
 */

BOOL FAR PASCAL PlayMCI(DWORD_PTR dwFrom, DWORD_PTR dwTo)

{
    MCI_PLAY_PARMS      mciPlay;    /* structure used to pass parameters along
                                        with the MCI_PLAY command             */
    DWORD               dw;         /* variable holding the return value of
                                        the various MCI commands              */
    DWORD               dwflags = 0L;     /* play flags */

    /* If no device is currently open, then there's nothing to play */

    DPF("mciPlay:  From=%d   To=%d\n", dwFrom, dwTo);

    if (gwDeviceID == (UINT)0)
        return TRUE;

     if (gfInPlayMCI) {
         return(TRUE);
     }

     gfInPlayMCI = TRUE;

    /*
     * Send the MCI_PLAY message. This will start the device playing from
     * wherever the current position is within the medium. This message will
     * un-pause the player if it is currently in the paused state.
     *
     */

    mciPlay.dwCallback = (DWORD_PTR)(HWND) ghwndApp;
    if (dwFrom != dwTo) {
        mciPlay.dwFrom = (DWORD)dwFrom;
        mciPlay.dwTo = (DWORD)dwTo;
        dwflags = MCI_FROM | MCI_TO;
    }

    /* don't allow MCIAVI full screen mode --- force Windowing */
    if (gfPlayingInPlace && ((gwDeviceType & DTMCI_DEVICE) == DTMCI_AVIVIDEO))
        dwflags |= MCI_MCIAVI_PLAY_WINDOW;

    /* If auto-repeat is on, MCIAVI will bring the playback window to the */
    /* front every time it repeats, because that's what it does when you  */
    /* issue a play.  To avoid that, we'll just do a play repeat once.    */
    if (((gwDeviceType & DTMCI_DEVICE) == DTMCI_AVIVIDEO) &&
        (gwOptions & OPT_AUTOREP))
        dwflags |= MCI_DGV_PLAY_REPEAT;

    //
    // what if the MCI device brings up a error box?  We don't want MPlayer
    // to be allowed to exit.
    //
    gfErrorBox++;
    dw = mciSendCommand(gwDeviceID, MCI_PLAY, F_NOTIFY | dwflags, (DWORD_PTR)&mciPlay);
    DPF("MCI_PLAY returned %lu\n", dw);
    gfErrorBox--;

    /* In case it stops so soon we wouldn't notice this play command. */
    if (dw == 0)
        gfJustPlayed = TRUE;

    gfInPlayMCI = FALSE;

    return CheckErrorMCI(dw);
}


/*
 * SetTimeFormatMCI()
 *
 * sets the current time format
 *
 */

BOOL FAR PASCAL SetTimeFormatMCI(UINT wTimeFormat)
{
    MCI_SET_PARMS           mciSet;        /* Structure for MCI_SET command */
    DWORD                   dw;

    mciSet.dwTimeFormat = wTimeFormat;

    dw = mciSendCommand(gwDeviceID, MCI_SET, MCI_SET_TIME_FORMAT,
        (DWORD_PTR) (LPVOID) &mciSet);

    if (dw != 0) {
        mciSet.dwTimeFormat = MCI_FORMAT_MILLISECONDS;

        mciSendCommand(gwDeviceID, MCI_SET, MCI_SET_TIME_FORMAT,
            (DWORD_PTR)(LPVOID)&mciSet);
    }

    return (dw == 0);
}

/*
 * PauseMCI()
 *
 * Pause the current MCI device.
 *
 */

BOOL FAR PASCAL PauseMCI(void)

{
    MCI_GENERIC_PARMS   mciGeneric; /* General-purpose structure used to pass
                                        parameters along with various MCI
                                        commands                              */
    DWORD               dw;         /* variable holding the return value of
                                        the various MCI commands              */

    /* If no device is currently open, then there's nothing to pause */

    if (gwDeviceID == (UINT)0)
        return TRUE;

    /* Send the MCI_PAUSE message */

    mciGeneric.dwCallback = (DWORD_PTR)(HWND) ghwndApp;

    dw = mciSendCommand(gwDeviceID, MCI_PAUSE, F_NOTIFY, (DWORD_PTR)&mciGeneric);

    DPF("MCI_PAUSE returned %lu\n", dw);

    if (dw == MCIERR_UNSUPPORTED_FUNCTION) {
        /* Pause isn't supported.  Don't allow it any more. */
        gwDeviceType &= ~DTMCI_CANPAUSE;
    }

    return CheckErrorMCI(dw);
}

/*
 * SeekExactMCI()
 *
 * Set set exactly on or off
 *
 */

BOOL FAR PASCAL SeekExactMCI(BOOL fExact)
{
    DWORD dw;
    BOOL  fWasExact;
    MCI_STATUS_PARMS    mciStatus;

    if (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANSEEKEXACT))
        return FALSE;

    //
    // see if the device can seek exactly
    //
    dw = mciSendString(aszSeekExact, NULL, 0, NULL);

    if (dw != 0)
    {
        gwDeviceType &= ~DTMCI_CANSEEKEXACT;
        return FALSE;
    }

    //
    // get current value.
    //
    mciStatus.dwItem = MCI_DGV_STATUS_SEEK_EXACTLY;
    dw = mciSendCommand(gwDeviceID, MCI_STATUS, MCI_STATUS_ITEM,
                                    (DWORD_PTR) (LPVOID) &mciStatus);
    fWasExact = (dw == 0 && mciStatus.dwReturn != MCI_OFF) ? TRUE : FALSE;

    if (fExact)
        dw = mciSendString(aszSeekExactOn, NULL, 0, NULL);
    else
        dw = mciSendString(aszSeekExactOff, NULL, 0, NULL);

    return fWasExact;
}

/*
 * SetAudioMCI()
 *
 * Set audio for the current MCI device on/off.
 *
 */

BOOL FAR PASCAL SetAudioMCI(BOOL fAudioOn)

{
    MCI_SET_PARMS   mciSet;
    DWORD               dw;

    /* If no device is currently open, then there's nothing to do. */

    if (gwDeviceID == (UINT)0)
        return TRUE;

    /* Send the MCI_SET message */
    mciSet.dwAudio = MCI_SET_AUDIO_ALL;

    dw = mciSendCommand(gwDeviceID, MCI_SET,
                MCI_SET_AUDIO | (fAudioOn ? MCI_SET_ON : MCI_SET_OFF),
                (DWORD_PTR)&mciSet);

    DPF("MCI_SET returned %lu\n", dw);

    return CheckErrorMCI(dw);
}

/*
 * StopMCI()
 *
 * Stop the current MCI device.
 *
 */

BOOL FAR PASCAL StopMCI(void)

{
    MCI_GENERIC_PARMS   mciGeneric; /* General-purpose structure used to pass
                                       parameters along with various MCI
                                       commands                              */
    DWORD               dw;         /* variable holding the return value of
                                       the various MCI commands              */

    /* If no device is currently open, then there's nothing to stop */

    if (gwDeviceID == (UINT)0)
        return TRUE;

    /* Send the MCI_STOP message */

    mciGeneric.dwCallback = (DWORD_PTR)(HWND) ghwndApp;

    dw = mciSendCommand(gwDeviceID, MCI_STOP, F_NOTIFY,
                            (DWORD_PTR)&mciGeneric);

    DPF("MCI_STOP returned %lu\n", dw);

    return CheckErrorMCI(dw);
}


/*
 * EjectMCI(fOpen)
 *
 * Open the device door if <fOpen> is TRUE, otherwise close it.
 *
 * To do: When un-ejected, update track map, media length, etc.
 *
 */

BOOL FAR PASCAL EjectMCI(BOOL fOpen)

{
    MCI_GENERIC_PARMS   mciGeneric; /* General-purpose structure used to pass
                                       parameters along with various MCI
                                       commands                              */
    DWORD               dw;         /* variable holding the return value of
                                       the various MCI commands              */

    /* If no device is currently open, then there's nothing to eject */

    if (gwDeviceID == (UINT)0)
    return TRUE;

    /*
     * Send a message opening or closing the door depending on the state of
     * <fOpen>.
     *
     */

    mciGeneric.dwCallback = (DWORD_PTR)(HWND) ghwndApp;

    dw = mciSendCommand(gwDeviceID, MCI_SET,
         (fOpen ? MCI_SET_DOOR_OPEN : MCI_SET_DOOR_CLOSED) | F_NOTIFY,
         (DWORD_PTR)&mciGeneric);

    DPF("MCI_SET (MCI_SET_DOOR_%s) returned %lu\n",(LPSTR)(fOpen ? "OPEN" : "CLOSED"), dw);

    return CheckErrorMCI(dw);
}


/*
 * SeekMCI(dwPosition)
 *
 * Seek to position <dwPosition> (measured in milliseconds from 0L to
 * <gdwMediaLength> inclusive).
 *
 */
STATICDT BOOL sfSeeking = FALSE;

BOOL FAR PASCAL SeekMCI(DWORD_PTR dwPosition)
{
    DWORD               dw;         /* variable holding the return value of
                                       the various MCI commands              */
    static int          wStatus = -1;

    /*
     * If no device is currently open, then there's not much bloody point
     * in trying to seek to a new position, is there?
     *
     */

    if (gwDeviceID == (UINT)0)
    return TRUE;

    /*
    ** If we're seeking, decide whether to play from or seek to based on
    ** the status at the last time we seeked.  Otherwise, use the current
    ** status.
    */

    if (!sfSeeking)
        wStatus = gwStatus;

    /* Playing from end of media is broken in CD, so don't let it happen. */
    if (dwPosition >= gdwMediaStart + gdwMediaLength) {
        if (!StopMCI())
            return FALSE;
        wStatus = MCI_MODE_STOP;
    }

    if (wStatus == MCI_MODE_PLAY) {

        MCI_PLAY_PARMS  mciPlay;        /* parameter structure for MCI_PLAY */
        DWORD           dwflags = 0L;

        /*
         * If the player in in 'Play' mode, then we want to jump to the new
         * position and keep playing. This can be done by sending an MCI_PLAY
         * message and specifying the position which we wish to play from.
         *
         */

        mciPlay.dwFrom = (DWORD)dwPosition;
        mciPlay.dwCallback = (DWORD_PTR)(HWND) ghwndApp;

        /* don't allow MCIAVI full screen mode --- force Windowing */
        if (gfPlayingInPlace && ((gwDeviceType & DTMCI_DEVICE) == DTMCI_AVIVIDEO))
            dwflags |= MCI_MCIAVI_PLAY_WINDOW;

        dw = mciSendCommand(gwDeviceID, MCI_PLAY, MCI_FROM | F_NOTIFY | dwflags,
            (DWORD_PTR)&mciPlay);
        DPF("MCI_PLAY (from %lu) returned %lu\n", mciPlay.dwFrom, dw);

        /* In case it stops so soon we wouldn't notice this play command. */
        if (dw == 0)
            gfJustPlayed = TRUE;

    }
    else {

        MCI_SEEK_PARMS  mciSeek;        /* parameter structure for MCI_SEEK */

        /*
         * In any other state but 'Play', we want the player to go to the new
         * position and remain stopped. This is accomplished by sending an
         * MCI_SEEK message and specifying the position we want to seek to.
         *
         */

        mciSeek.dwTo = (DWORD)dwPosition;
        mciSeek.dwCallback = (DWORD_PTR)(HWND) ghwndApp;

        dw = mciSendCommand(gwDeviceID, MCI_SEEK, MCI_TO | F_NOTIFY,
            (DWORD_PTR)&mciSeek);
        DPF2("MCI_SEEK (to %lu) returned %lu\n", mciSeek.dwTo, dw);

    }

    /*
     * If no error occurred, save the position that is to be seeked to in
     * order to use that position in UpdateDisplay() if the device is in
     * seek mode.
     *
     */
    if (!dw)
        gdwLastSeekToPosition = (DWORD)dwPosition;

    /*
     * Because we've moved to a new position in the medium, the scrollbar
     * thumb is no longer positioned accurately. Call UpdateDisplay()
     * immediately to rectify this. (We could just wait for the next
     * automatic update, but this is friendlier).
     *
     */

    UpdateDisplay();

    return CheckErrorMCI(dw);
}


/* SeekToStartMCI( )
 *
 * Better than SeekMCI(gdwMediaStart) for CDAudio (like, it works).
 *
 */
BOOL FAR PASCAL SeekToStartMCI( )
{
    MCI_SEEK_PARMS  mciSeek;        /* parameter structure for MCI_SEEK */
    DWORD           dw;

    mciSeek.dwTo = 0;
    mciSeek.dwCallback = (DWORD_PTR)(HWND) ghwndApp;

    dw = mciSendCommand(gwDeviceID, MCI_SEEK, MCI_SEEK_TO_START,
                        (DWORD_PTR)&mciSeek);

    DPF2("MCI_SEEK_TO_START returned %lu\n", dw);

    return CheckErrorMCI(dw);
}


/*
 * SkipTrackMCI(iSkip)
 *
 * Skip to the beginning of track <iCur> + <iSkip>, where <iCur>
 * is the current track.
 *
 */

void FAR PASCAL SkipTrackMCI(int iSkip)
{
    MCI_STATUS_PARMS    mciStatus;     /* Structure used to pass parameters
                                         along with an MCI_STATUS command */
    DWORD               dw;            /* variable holding the return value
                                         of the various MCI commands      */
    int                 iTrack;        /* index of the track to skip to   */
    static int          iLastTrack = -1;

    /* If no device is currently open, then return */

    if (gwDeviceID == (UINT)0)
        return;

    /* Determine the track # of the current track */

    if (gfScrollTrack && gdwSeekPosition != 0) {
        iTrack = iLastTrack + iSkip;
    } else {
        mciStatus.dwItem = MCI_STATUS_CURRENT_TRACK;
        dw = mciSendCommand(gwDeviceID, MCI_STATUS, MCI_STATUS_ITEM,
            (DWORD_PTR)&mciStatus);

        DPF("MCI_STATUS (MCI_STATUS_CURRENT_TRACK) returned %lu, current track %ld\n", dw, mciStatus.dwReturn);

        if (dw != 0L) {

            /* Something went wrong, but it isn't catastrophic... */

            MessageBeep(0);
            return;
        }

        /* Compute the track # to which we wish to skip */

        iTrack = ((int) mciStatus.dwReturn) + iSkip;
    }

    /* Handle special case of seeking backward from middle first track */
    if (iTrack < (int)gwFirstTrack)
        iTrack = (int)gwFirstTrack;

    /* Don't do anything if <iTrack> is out of range */

    if ((iTrack < (int)gwFirstTrack) || (iTrack >= (int)gwNumTracks +
                                                (int)gwFirstTrack))
        return;

    /* Everything seems to be OK, so skip to the requested track */

    gdwSeekPosition = gadwTrackStart[iTrack - gwFirstTrack];
    iLastTrack = iTrack;

    /* Hack: Update global scroll position */
    SendMessage(ghwndTrackbar, TBM_SETPOS, TRUE, gadwTrackStart[iTrack-gwFirstTrack]);
}

STATICFN DWORD GetMode(MCI_STATUS_PARMS *pmciStatus)
{
    pmciStatus->dwItem = MCI_STATUS_MODE;
    if (0 != mciSendCommand(gwDeviceID, MCI_STATUS, MCI_STATUS_ITEM,
        (DWORD_PTR)pmciStatus)) {
        /* If the command returned a nonzero value, the mode is unknown */
        return MCI_MODE_NOT_READY;
    } else {
        return (UINT)pmciStatus->dwReturn;
    }
}

/*
 * wStatus = StatusMCI(pdwPosition)
 *
 * Query the status of the current device and return it.
 *
 * If <pdwPosition> is not NULL, then <*pdwPosition> is filled in with
 * the current position of the device within the medium (in milliseconds,
 * from 0 to <gdwMediaLength> *inclusive*).  <*pdwPosition> is not
 * necessarily filled in if MCI_MODE_NOT_READY is returned.
 *
 */

UINT FAR PASCAL StatusMCI(DWORD_PTR* pdwPosition)
{
    static UINT         swModeLast = MCI_MODE_NOT_READY;
    MCI_STATUS_PARMS    mciStatus;
    DWORD               dw;
    UINT                wMode;
    DWORD               dwPosition;

    /* If no device is currently open, return error. */

    if (gwDeviceID == (UINT)0)
        return MCI_MODE_NOT_READY;

    /* Determine what the current mode (status) of the device is */
    wMode = GetMode(&mciStatus);

    if ((gwDeviceType & DTMCI_CANPLAY) &&
        wMode != MCI_MODE_OPEN && wMode != MCI_MODE_NOT_READY) {
        /* Determine the current position within the medium */

        mciStatus.dwItem = MCI_STATUS_POSITION;
        dw = mciSendCommand(gwDeviceID, MCI_STATUS,     MCI_STATUS_ITEM,
            (DWORD_PTR)&mciStatus);

        DPF4("position = %lu (%lu)\n", mciStatus.dwReturn, dw);

        /* If an error occurred, set the current position to zero */

        if (dw == 0)
            dwPosition = (DWORD)mciStatus.dwReturn;
        else
            dwPosition = 0L;
    } else
        dwPosition = 0L;

    /*
     * If the current position is past the end of the medium, set it to be
     * equal to the end of the medium.
     *
     */

    if (dwPosition > gdwMediaLength + gdwMediaStart) {
        DPF("Position beyond end of media: truncating value\n");
        dwPosition = gdwMediaLength + gdwMediaStart;
    }

    if (dwPosition < gdwMediaStart) {
        DPF2("Position before beginning of media: adjusting value\n");
        dwPosition = gdwMediaStart;
    }

    sfSeeking = (wMode == MCI_MODE_SEEK);

    /*
     * If we were passed a valid position pointer, then return the current
     * position.
     *
     */

    if (pdwPosition != NULL)
        *pdwPosition = dwPosition;

    /* Return the status of the device */

    return wMode;
}

/*
 * wRet = QueryDeviceTypeMCI(wDeviceID)
 *
 * This routine determines whether or not the device given in <szDevice> uses
 * files and whether or not it can play anything at all.
 * It does so by opening the device in question and then querying its
 * capabilities.
 *
 * It returns a combination of DTMCI_ flags or DTMCI_ERROR
 *
 */
UINT FAR PASCAL QueryDeviceTypeMCI(UINT wDeviceID)
{
    MCI_GETDEVCAPS_PARMS    mciDevCaps; /* for the MCI_GETDEVCAPS command */
    MCI_SET_PARMS           mciSet;     /* for the MCI_SET command */
    MCI_ANIM_WINDOW_PARMS   mciWindow;  /* for the MCI_WINDOW command */
    DWORD                   dw;
    UINT                    wRet=0;
    TCHAR                   achDevice[40];
    DWORD                   i;

    //
    // determine if the device is simple or compound
    //
    mciDevCaps.dwItem = MCI_GETDEVCAPS_COMPOUND_DEVICE;
    dw = mciSendCommand(wDeviceID, MCI_GETDEVCAPS,
        MCI_GETDEVCAPS_ITEM, (DWORD_PTR)&mciDevCaps);

    DPF("MCI_GETDEVCAPS_COMPOUND_DEVICE: %lu  (ret=%lu)\n", dw, mciDevCaps.dwReturn);

    if (dw == 0 && mciDevCaps.dwReturn != 0)
        wRet |= DTMCI_COMPOUNDDEV;
    else
        wRet |= DTMCI_SIMPLEDEV;

    //
    // determine if the device handles files
    //
    if (wRet & DTMCI_COMPOUNDDEV) {
        mciDevCaps.dwItem = MCI_GETDEVCAPS_USES_FILES;
        dw = mciSendCommand(wDeviceID, MCI_GETDEVCAPS,
            MCI_GETDEVCAPS_ITEM, (DWORD_PTR)&mciDevCaps);

        DPF("MCI_GETDEVCAPS_USES_FILES: %lu  (ret=%lu)\n", dw, mciDevCaps.dwReturn);

        if (dw == 0 && mciDevCaps.dwReturn != 0)
            wRet |= DTMCI_FILEDEV;
    }

    //
    // determine if the device can play
    //
    mciDevCaps.dwItem = MCI_GETDEVCAPS_CAN_PLAY;
    dw = mciSendCommand(wDeviceID, MCI_GETDEVCAPS,
        MCI_GETDEVCAPS_ITEM, (DWORD_PTR)&mciDevCaps);

    if (dw == 0 && mciDevCaps.dwReturn != 0)
        wRet |= DTMCI_CANPLAY;

    //
    // determine if the device can pause
    //
    if (wRet & DTMCI_CANPLAY)
        wRet |= DTMCI_CANPAUSE;     // assume it can pause!!!

    //
    // determine if the device does frames
    //
    mciSet.dwTimeFormat = MCI_FORMAT_FRAMES;
    dw = mciSendCommand(wDeviceID, MCI_SET, MCI_SET_TIME_FORMAT, (DWORD_PTR)&mciSet);

    DPF("MCI_SET TIME FORMAT (frames) returned %lu\n", dw);

    if (dw == 0)
        wRet |= DTMCI_TIMEFRAMES;

    //
    // determine if the device does milliseconds
    //
    mciSet.dwTimeFormat = MCI_FORMAT_MILLISECONDS;
    dw = mciSendCommand(wDeviceID, MCI_SET, MCI_SET_TIME_FORMAT, (DWORD_PTR)&mciSet);

    DPF("MCI_SET TIME FORMAT (milliseconds) returned %lu\n", dw);

    if (dw == 0)
        wRet |= DTMCI_TIMEMS;

    //
    // determine if the device can eject.
    //
    mciDevCaps.dwItem = MCI_GETDEVCAPS_CAN_EJECT;
    dw = mciSendCommand(wDeviceID, MCI_GETDEVCAPS, MCI_GETDEVCAPS_ITEM, (DWORD_PTR)(LPVOID)&mciDevCaps);

    DPF("MCI_GETDEVCAPS (MCI_GETDEVCAPS_CAN_EJECT) returned %lu, can eject: %ld\n", dw, mciDevCaps.dwReturn);

    if (dw == 0 && mciDevCaps.dwReturn)
        wRet |= DTMCI_CANEJECT;

    //
    // determine if the device supports configuration
    //
    dw = mciSendCommand(wDeviceID, MCI_CONFIGURE, MCI_TEST, (DWORD_PTR)NULL);

    DPF("MCI_CONFIGURE (MCI_TEST) returned %lu\n", dw);

    if (dw == 0)
        wRet |= DTMCI_CANCONFIG;

    //
    //  test the device driver and see if it can config.
    //
    if (!(wRet & DTMCI_CANCONFIG)) {

        //!!! is this safe?

        dw = mciSendCommand(wDeviceID, DRV_QUERYCONFIGURE, 0, 0);

        if (dw == 1L)
            wRet |= DTMCI_CANCONFIG;
    }

    //
    // determine if the device supports the "set audio" command
    //
    mciSet.dwAudio = MCI_SET_AUDIO_ALL;
    dw = mciSendCommand(wDeviceID, MCI_SET, MCI_SET_AUDIO | MCI_SET_ON,(DWORD_PTR)(LPVOID)&mciSet);

    DPF("MCI_SET (audio all) returned %lu\n", dw);

    if (dw == 0)
        wRet |= DTMCI_CANMUTE;

    //
    // determine if the device supports the "window" command, by sending a
    // "window handle default" command
    //

#ifdef NEWSTUFF
    /* Uh oh, we don't want to do this, because it causes our MCIWnd to be
     * overridden by the default window:
     */

    if (MCIWndCanWindow(ghwndMCI) == TRUE);
        wRet |= DTMCI_CANWINDOW;
#else
    mciWindow.hWnd = MCI_ANIM_WINDOW_DEFAULT;
    dw = mciSendCommand(wDeviceID, MCI_WINDOW,MCI_ANIM_WINDOW_HWND|MCI_WAIT,
            (DWORD_PTR)(LPVOID)&mciWindow);

    DPF("MCI_WINDOW: (set default) dw=0x%08lx\n", dw);

    if (dw == 0)
        wRet |= DTMCI_CANWINDOW;

    //
    // determine if the device supports the "window" command, by sending a
    // "window state hide" command
    //
    if (!(wRet & DTMCI_CANWINDOW)) {
        mciWindow.nCmdShow = SW_HIDE;
        dw = mciSendCommand(wDeviceID, MCI_WINDOW,MCI_ANIM_WINDOW_STATE|MCI_WAIT,
                (DWORD_PTR)(LPVOID)&mciWindow);

        DPF("MCI_WINDOW: (hide) dw=0x%08lx\n", dw);

        if (dw == 0)
            wRet |= DTMCI_CANWINDOW;
    }
#endif /* NEWSTUFF */

    //
    // assume the device can seek exact.
    //
    wRet |= DTMCI_CANSEEKEXACT;     // assume it can seek exact

    //
    // Are we the MCIAVI device?
    //
    GetDeviceNameMCI(achDevice, BYTE_COUNT(achDevice));

    if (*achDevice)
    {
        for (i = 0; i < sizeof DevToDevIDMap / sizeof *DevToDevIDMap; i++)
        {
            if (!lstrcmpi(achDevice, DevToDevIDMap[i].pString))
            {
                wRet |= DevToDevIDMap[i].ID;
                DPF("Found device %"DTS"\n", DevToDevIDMap[i].pString);
                break;
            }
        }
    }


    mciDevCaps.dwItem = MCI_GETDEVCAPS_DEVICE_TYPE;
    dw = mciSendCommand(gwDeviceID, MCI_GETDEVCAPS,
                        MCI_GETDEVCAPS_ITEM, (DWORD_PTR)&mciDevCaps);
    if ((dw == 0)
       &&(mciDevCaps.dwReturn == MCI_DEVTYPE_CD_AUDIO))
        wRet |= DTMCI_CDAUDIO;

    return wRet;
}

BOOL FAR PASCAL SetWindowMCI(HWND hwnd)
{
    MCI_ANIM_WINDOW_PARMS   mciWindow;  /* for the MCI_WINDOW command */
    DWORD                   dw;

    if (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW))
        return FALSE;

    mciWindow.hWnd = hwnd;

    dw = mciSendCommand(gwDeviceID, MCI_WINDOW,MCI_ANIM_WINDOW_HWND|MCI_WAIT,
            (DWORD_PTR)(LPVOID)&mciWindow);

    if (dw != 0)
        gwDeviceType &= ~DTMCI_CANWINDOW;

    return (dw == 0);
}

BOOL FAR PASCAL ShowWindowMCI(BOOL fShow)
{
    DWORD dw;

    if (fShow)
        dw = mciSendString(aszWindowShow, NULL, 0, NULL);
    else
        dw = mciSendString(aszWindowHide, NULL, 0, NULL);

    return dw == 0;
}

BOOL FAR PASCAL PutWindowMCI(LPRECT prc)
{
    RECT rc;
    HWND hwnd;
    UINT w;

    //
    // note we could use the "put window at x y dx dy client" command but it
    // may not work on all devices.
    //

    if (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW))
        return FALSE;

    if (!(hwnd = GetWindowMCI()))
        return FALSE;

    //
    // either snap to the default size or use the given size *and* position.
    //
    if (prc == NULL || IsRectEmpty(prc))
        rc = grcSize;
    else
        rc = *prc;

    if (rc.left == 0 && rc.top == 0)
        w = SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE;
    else
        w = SWP_NOZORDER | SWP_NOACTIVATE;

    AdjustWindowRect(&rc, (DWORD)GetWindowLongPtr(hwnd, GWL_STYLE), GetMenu(hwnd) != NULL);
    SetWindowPos(hwnd, NULL, rc.left, rc.top, rc.right-rc.left,
       rc.bottom-rc.top,w);

    return TRUE;
}

HWND FAR PASCAL GetWindowMCI(void)
{
    DWORD               dw;
    TCHAR               ach[40];

    if (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW))
        return NULL;

    dw = mciSendString(aszStatusWindow, ach, CHAR_COUNT(ach), NULL);

    if (dw != 0)
        gwDeviceType &= ~DTMCI_CANWINDOW;

    if (dw == 0)
        return (HWND)IntToPtr(ATOI(ach));
    else
        return NULL;
}

BOOL FAR PASCAL SetPaletteMCI(HPALETTE hpal)
{
    MCI_DGV_SETVIDEO_PARMS  mciVideo;
    DWORD       dw;

    if (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW))
        return FALSE;

    //!!! bug should not send this.

    mciVideo.dwItem  = MCI_DGV_SETVIDEO_PALHANDLE;
    mciVideo.dwValue = (DWORD)(DWORD_PTR)(UINT_PTR)hpal;

    dw = mciSendCommand(gwDeviceID, MCI_SETVIDEO,
            MCI_DGV_SETVIDEO_ITEM|MCI_DGV_SETVIDEO_VALUE|MCI_WAIT,
            (DWORD_PTR)(LPVOID)&mciVideo);

    return (dw == 0);
}

/*
 * wRet = DeviceTypeMCI(szDevice)
 *
 * This routine determines whether or not the device given in <szDevice> uses
 * files and whether or not it can play anything at all.
 * It does so by opening the device in question and then querying its
 * capabilities.  It returns either DTMCI_FILEDEV, DTMCI_SIMPLEDEV,
 * DTMCI_CANTPLAY, or DTMCI_ERROR.
 *
 */

UINT FAR PASCAL DeviceTypeMCI(
    LPTSTR  szDevice,           /* name of the device to be opened (or "")        */
    LPTSTR  szDeviceName,       /* place to put device full-name */
    int     nBuf)               /* size of buffer IN CHARACTERS */

{
    MCI_OPEN_PARMS          mciOpen;    /* Structure used for MCI_OPEN */
    MCI_INFO_PARMS          mciInfo;    /* Structure used for MCI_INFO */
    DWORD                   dw;
    UINT                    wRet;

    if (szDeviceName && nBuf > 0)
        szDeviceName[0] = 0;

    /*
     * Open the device as a simple device. If the device is actually compound,
     * then the open should still succeed, but the only thing we'll be able to
     * go is query the device capabilities.
     */

    mciOpen.lpstrDeviceType = szDevice;
    dw = mciSendCommand((MCIDEVICEID)0, MCI_OPEN, MCI_OPEN_TYPE,(DWORD_PTR)&mciOpen);

    if (dw == MCIERR_MUST_USE_SHAREABLE)
        dw = mciSendCommand((MCIDEVICEID)0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_SHAREABLE,
            (DWORD_PTR)(LPVOID)&mciOpen);

    DPF("MCI_OPEN(%"DTS") returned %lu, wDeviceID=%u\n", szDevice, dw, mciOpen.wDeviceID);

    /* If the open was unsuccessful, return */

    switch (dw)
    {
        case MCIERR_MUST_USE_SHAREABLE:
        case MCIERR_DEVICE_OPEN:
            return DTMCI_IGNOREDEVICE;

        case 0: // no error
            break;

        default:
            DPF("Unable to open device (%"DTS")\n", szDevice);
            return DTMCI_ERROR;
    }

    wRet = QueryDeviceTypeMCI(mciOpen.wDeviceID);

    //
    //  get the "name" of the device if the caller wants it
    //
    if (szDeviceName && nBuf > 0)
    {
        mciInfo.dwCallback  = 0;
        mciInfo.lpstrReturn = szDeviceName;
        mciInfo.dwRetSize   = nBuf;

        //
        // default the product name to the device name
        //
        lstrcpy(szDeviceName, szDevice);

        dw = mciSendCommand(mciOpen.wDeviceID, MCI_INFO,
            MCI_INFO_PRODUCT, (DWORD_PTR)(LPVOID)&mciInfo);

        if (dw != 0)
            lstrcpy(szDeviceName, szDevice);
    }

    /* Close the device, and exit */

    dw = mciSendCommand(mciOpen.wDeviceID, MCI_CLOSE, 0L, (DWORD_PTR)0);

    return wRet;
}

BOOL FAR PASCAL ConfigMCI(HWND hwnd)
{
    DWORD               dw;
    DRVCONFIGINFO       drvc;
    RECT                rc1,rc2;
#ifndef UNICODE
    WCHAR               waszMCI[sizeof(aszMCI)];
    WCHAR               wszDevice[40];
#endif

    if (gwDeviceID == (UINT)0)
        return TRUE;

    dw = mciSendCommand(gwDeviceID, MCI_CONFIGURE, MCI_TEST, (DWORD_PTR)0);

    if (dw == 0) {
        GetDestRectMCI(&rc1);

        dw = mciSendCommand(gwDeviceID, MCI_CONFIGURE, 0L, (DWORD_PTR)0);

        GetDestRectMCI(&rc2);

        //
        // get the new size from MCIAVI, because the user may have
        // chosen ZoomBy2 as default.
        //

//
// This won't happen anymore... it was fixed by an MCIAVI fix.
//
#ifdef NEW_MCI_DIALOG
        if (IsRectEmpty(&rc2))
        {
            /* On Windows 95, GetDestRectMCI() returns an empty rectangle
             * if you make a change in the configure dialog.
             * I don't know if this is a bug.
             */
            grcSize = grcInitSize;

            AlterRectUsingDefaults(&grcSize);

            SetDestRectMCI(&grcSize);
            SetMPlayerSize(&grcSize);
            //HACK: It doesn't always repaint properly.
            InvalidateRect(GetWindowMCI(), NULL, TRUE);
        }
        else
#endif
        if (!EqualRect(&rc1, &rc2) && !IsRectEmpty(&rc2))
            grcSize = rc2;

    } else if (dw != MCIERR_DEVICE_NOT_READY) {
        drvc.dwDCISize          = sizeof(drvc);
#ifdef UNICODE
        drvc.lpszDCISectionName = aszMCI;
        drvc.lpszDCIAliasName   = garMciDevices[gwCurDevice].szDevice;
        dw = mciSendCommand(gwDeviceID, DRV_CONFIGURE, (LONG_PTR) (UINT_PTR) hwnd,
            (DWORD_PTR) (DRVCONFIGINFO FAR *) &drvc);
#else
        // No ASCII->Unicode thunking exists for DRV_CONFIGURE.  We have
        // to pass unicode strings on the configure command.

        AnsiToUnicodeString(aszMCI, waszMCI, UNKNOWN_LENGTH);
        AnsiToUnicodeString(garMciDevices[gwCurDevice].szDevice, wszDevice, UNKNOWN_LENGTH);

        drvc.lpszDCISectionName = waszMCI;
        drvc.lpszDCIAliasName   = wszDevice;
#ifdef CHICAGO_PRODUCT
        dw = mciSendCommand(gwDeviceID, DRV_CONFIGURE, (LONG) (UINT) hwnd,
            (DWORD_PTR) (DRVCONFIGINFO FAR *) &drvc);
#else
        dw = mciSendCommandW(gwDeviceID, DRV_CONFIGURE, (LONG) (UINT) hwnd,
            (DWORD_PTR) (DRVCONFIGINFO FAR *) &drvc);
#endif
#endif

    }

    return dw == 0;
}

BOOL FAR PASCAL GetDestRectMCI(LPRECT lprc)
{
    MCI_ANIM_RECT_PARMS mciRect;
    DWORD               dw;

    /* get the size (rectangle) of the element */
    if (gwDeviceID != (UINT)0)
        dw = mciSendCommand(gwDeviceID, MCI_WHERE,
            MCI_ANIM_WHERE_DESTINATION | MCI_WAIT,
            (DWORD_PTR)(LPVOID)&mciRect);
    else
        dw = 1;

    DPF("MCI_WHERE (dest): dw0x%08lx [%d,%d,%d,%d]\n", dw, mciRect.rc);

    if (dw != 0) {
        SetRectEmpty(lprc);
        return FALSE;
    }
    else {
        *lprc = mciRect.rc;
        lprc->right += lprc->left;
        lprc->bottom += lprc->top;
        return TRUE;
    }
}

#if 0 /* This is never called */
BOOL FAR PASCAL GetSourceRectMCI(LPRECT lprc)
{
    MCI_ANIM_RECT_PARMS mciRect;
    DWORD               dw;

    /* get the size (rectangle) of the element */
    if (gwDeviceID != (UINT)0)
        dw = mciSendCommand(gwDeviceID, MCI_WHERE,
            MCI_ANIM_WHERE_SOURCE | MCI_WAIT,
            (DWORD_PTR)(LPVOID)&mciRect);
    else
        dw = 1;

    DPF("MCI_WHERE (source): dw0x%08lx [%d,%d,%d,%d]\n", dw, mciRect.rc);

    if (dw != 0) {
        SetRectEmpty(lprc);
        return FALSE;
    }
    else {
        *lprc = mciRect.rc;
        lprc->right += lprc->left;
        lprc->bottom += lprc->top;
        return TRUE;
    }
}
#endif

BOOL FAR PASCAL SetDestRectMCI(LPRECT lprc)
{
    MCI_ANIM_RECT_PARMS mciRect;
    DWORD               dw;

    mciRect.rc = *lprc;

    /* get the size (rectangle) of the element */

    mciRect.rc.right  = mciRect.rc.right  - mciRect.rc.left;
    mciRect.rc.bottom = mciRect.rc.bottom - mciRect.rc.top;

    dw = mciSendCommand(gwDeviceID, MCI_PUT,
            MCI_ANIM_RECT | MCI_ANIM_PUT_DESTINATION | MCI_WAIT,
            (DWORD_PTR)(LPVOID)&mciRect);

    if (dw != 0)
    {
        DPF0("mciSendCommand( MCI_PUT ) failed with error x%08x\n", dw);
    }

    DPF("MCI_PUT (dest): [%d,%d,%d,%d]\n", mciRect.rc);

    return (dw == 0);
}

#if 0
BOOL FAR PASCAL SetSourceRectMCI(LPRECT lprc)
{
    MCI_ANIM_RECT_PARMS mciRect;
    DWORD               dw;

    mciRect.rc = *lprc;

    mciRect.rc.right  = mciRect.rc.right  - mciRect.rc.left;
    mciRect.rc.bottom = mciRect.rc.bottom - mciRect.rc.top;

    dw = mciSendCommand(gwDeviceID, MCI_PUT,
            MCI_ANIM_RECT | MCI_ANIM_PUT_SOURCE | MCI_WAIT,
            (DWORD_PTR)(LPVOID)&mciRect);

    DPF("MCI_PUT (source): [%d,%d,%d,%d]\n", mciRect.rc);

    return (dw == 0);
}
#endif

HPALETTE FAR PASCAL PaletteMCI(void)
{
    MCI_STATUS_PARMS    mciStatus;
    DWORD               dw;

    if (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW))
        return NULL;

    mciStatus.dwItem = MCI_ANIM_STATUS_HPAL;
    dw = mciSendCommand(gwDeviceID, MCI_STATUS, MCI_STATUS_ITEM,
        (DWORD_PTR)(LPVOID)&mciStatus);

    if (dw == 0 && mciStatus.dwReturn)
        return (HPALETTE)mciStatus.dwReturn;
    else
        return NULL;
}

HBITMAP FAR PASCAL BitmapMCI(void)
{
    MCI_ANIM_UPDATE_PARMS mciUpdate;
    HDC         hdc, hdcMem;
    HBITMAP     hbm, hbmT;
    HBRUSH      hbrOld;
    HANDLE      hfontOld;
    DWORD       dw;
    RECT        rc;
    int         xExt, yExt;                     // size of text area
    int         xOff = 0, yOff = 0;             // offset of text string
    int         xSize, ySize;                   // size of whole picture
    int         xIconOffset;                        // x Offset if drawing Icon.
    TCHAR       ach[20];
    RECT        rcSave;
    RECT        rcs;
    SIZE        TempSize;

    /* Minimum size of bitmap is icon size */
    int ICON_MINX = GetSystemMetrics(SM_CXICON);
    int ICON_MINY = GetSystemMetrics(SM_CYICON);

    /* Get size of a frame or an icon that we'll be drawing */
    rcs = grcSize;
    GetDestRectMCI(&grcSize);
    rc = grcSize;

    if (IsRectEmpty(&rc))
        SetRect(&rc, 0, 0, 3*ICON_MINX, ICON_MINY);

    /* Offset to title bar */
    yOff = rc.bottom;

    hdc = GetDC(NULL);
    if (hdc == NULL)
        return NULL;
    hdcMem = CreateCompatibleDC(NULL);
    if (hdcMem == NULL) {
        ReleaseDC(NULL, hdc);
        return NULL;
    }

    if (gwOptions & OPT_TITLE) {
        if (ghfontMap)
            hfontOld = SelectObject(hdcMem, ghfontMap);

        GetTextExtentPoint32(hdcMem, gachCaption, STRLEN(gachCaption), &TempSize);
        xExt = max(TempSize.cx + 4, ICON_MINX);
        yExt = TempSize.cy;

        if (yExt > TITLE_HEIGHT)        // don't let text be higher than bar
            yExt = TITLE_HEIGHT;
        if (xExt > rc.right) {
            rc.left = (xExt - rc.right) / 2;
            rc.right += rc.left;
        } else {
            xOff = (rc.right - xExt) /2;
            xExt = rc.right;
        }
        if (rc.bottom < ICON_MINY) {
            yOff = ICON_MINY;
            rc.top = (ICON_MINY - rc.bottom) / 2;
            rc.bottom += rc.top;
        }
        xSize = xExt; ySize = yOff + TITLE_HEIGHT;
    } else {
        if (rc.right < ICON_MINX) {
            rc.left = (ICON_MINX - rc.right) / 2;
            rc.right += rc.left;
        }
        if (rc.bottom < ICON_MINY) {
            rc.top = (ICON_MINY - rc.bottom) / 2;
            rc.bottom += rc.top;
        }
        xSize = max(rc.right, ICON_MINX);
        ySize = max(rc.bottom, ICON_MINY);
    }

    /* Big enough to hold text caption too, if necessary */
    hbm = CreateCompatibleBitmap(hdc, xSize, ySize);

    ReleaseDC(NULL, hdc);
    if (hbm == NULL) {
        DeleteDC(hdcMem);
        return NULL;
    }

    hbmT = SelectObject(hdcMem, hbm);

    hbrOld = SelectObject(hdcMem, hbrWindowColour);
    PatBlt(hdcMem, 0,0, xSize, ySize, PATCOPY);
    SelectObject(hdcMem, hbrOld);

    if (gwOptions & OPT_TITLE) {
        hbrOld = SelectObject(hdcMem, hbrButtonFace);
        PatBlt(hdcMem, 0, rc.bottom, xExt, TITLE_HEIGHT, PATCOPY);
        SetBkMode(hdcMem, TRANSPARENT);
        SetTextColor(hdcMem, rgbButtonText);
        /* Centre text vertically in title bar */
        TextOut(hdcMem, xOff + 2, yOff + (TITLE_HEIGHT - yExt) / 2,
                gachCaption, STRLEN(gachCaption));
        if (hbrOld)
            SelectObject(hdcMem, hbrOld);
        if (ghfontMap)
            SelectObject(hdcMem, hfontOld);
    }

    /* Use our ICON as the picture */
    if (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW)) {
        xIconOffset = rc.left + (rc.right-rc.left-ICON_MINX)/2;
        xIconOffset = xIconOffset < 0 ? 0: xIconOffset;
        DrawIcon(hdcMem, xIconOffset, rc.top,
                 GetIconForCurrentDevice(GI_LARGE, IDI_DDEFAULT));

    /* Use a frame of our file */
    } else {
        LOADSTRING(IDS_NOPICTURE, ach);
        DrawText(hdcMem, ach, STRLEN(ach), &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

        mciUpdate.hDC = hdcMem;

        mciUpdate.dwCallback = 0;
        SetRectEmpty(&mciUpdate.rc);

        /* NO matter what size our playback window is, we want to use the   */
        /* original size of the window as the picture we put on the clipbrd */
        SetViewportOrgEx(hdcMem, rc.left, rc.top, NULL);
        GetDestRectMCI(&rcSave);
        SetDestRectMCI(&grcSize);
        dw = mciSendCommand(gwDeviceID, MCI_UPDATE,
                MCI_ANIM_UPDATE_HDC | MCI_WAIT, (DWORD_PTR)(LPVOID)&mciUpdate);
        SetDestRectMCI(&rcSave);
        SetViewportOrgEx(hdcMem, 0, 0, NULL);
    }

    if (gwOptions & OPT_BORDER) {
        SetRect(&rc, 0, 0, xSize, ySize);
        FrameRect(hdcMem, &rc, GetStockObject(BLACK_BRUSH));

        if (gwOptions & OPT_TITLE) {
            SetRect(&rc, 0, ySize - TITLE_HEIGHT, xSize, ySize-TITLE_HEIGHT+1);
            FrameRect(hdcMem, &rc, GetStockObject(BLACK_BRUSH));
        }
    }

    if (hbmT)
        SelectObject(hdcMem, hbmT);
    DeleteDC(hdcMem);
    grcSize=rcs;

    return hbm;
}

//
//  if we are on a palette device, dither to the VGA colors
//  for apps that dont deal with palettes!
//
void FAR PASCAL DitherMCI(HANDLE hdib, HPALETTE hpal)
{
    LPBYTE      lpBits;
    int         i;
    LPBITMAPINFOHEADER  lpbi;

    DPF2("DitherMCI\n");

    lpbi = (LPVOID)GLOBALLOCK(hdib);

    if (lpbi == NULL)
        return;

    ////////////////////////////////////////////////////////////////////////
    //
    // HACK!!! patch the fake gamma-corrected colors to match the VGA's
    //
    ////////////////////////////////////////////////////////////////////////

    lpBits = (LPBYTE)(lpbi+1);

    for (i=0; i<8*4; i++)
    {
        if (lpBits[i] == 191)
            lpBits[i] = 128;
    }
    ////////////////////////////////////////////////////////////////////////

    lpBits = (LPBYTE)(lpbi+1) + 256 * sizeof(RGBQUAD);

    BltProp(lpbi,lpBits,0,0,(int)lpbi->biWidth,(int)lpbi->biHeight,
        lpbi,lpBits,0,0);

    GLOBALUNLOCK(hdib);
}


void FAR PASCAL CopyMCI(HWND hwnd)
{
    HBITMAP  hbm;
    HPALETTE hpal;
    HANDLE   hdib;
    HANDLE   hmfp;
    HDC      hdc;

    DPF2("CopyMCI\n");

    if (gwDeviceID == (UINT)0)
        return;

    if (hwnd) {
        if (!OpenClipboard(ghwndApp))
            return;

        EmptyClipboard();
    }

    hpal = PaletteMCI();
    hbm  = BitmapMCI();
    hdib = DibFromBitmap(hbm, hpal);
    hpal = CopyPalette(hpal);

    //
    //  if we are on a palette device. possibly dither to the VGA colors
    //  for apps that dont deal with palettes!
    //
    hdc = GetDC(NULL);
    if ((GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) &&
             (gwOptions & OPT_DITHER) && (gwDeviceType & DTMCI_CANWINDOW)) {
        DitherMCI(hdib, hpal);
        hpal = NULL;
    }
    ReleaseDC(NULL, hdc);

    hmfp = PictureFromDib(hdib, hpal);

    if (hmfp)
        SetClipboardData(CF_METAFILEPICT, hmfp);

    if (hdib)
        SetClipboardData(CF_DIB, hdib);

    if (hpal)
        SetClipboardData(CF_PALETTE, hpal);

//// we want people to pick the meta file always.
////if (hbm)
////     SetClipboardData(CF_BITMAP, hbm);
    if (hbm)
        DeleteObject(hbm);

    /* If not everything can be copied to the clipboard, error out and  */
    /* don't put anything up there.                                     */
    if (!hmfp || !hdib) {
        EmptyClipboard();
        Error(ghwndApp, IDS_CANTCOPY);
    }

    if (hwnd)
        CloseClipboard();
}


/* MCIWndProc()
 *
 * Window procedure for MCI element window.
 * This also initiates the the OLE2 drag-drop data transfer if required.
 */
LONG_PTR FAR PASCAL _EXPORT
MCIWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT     ps;             // information from BeginPaint()
    HDC             hdc;
    DWORD           dw;             // function return status
    MCI_ANIM_UPDATE_PARMS mciUpdate;
    RECT            rc;
    static BOOL fDragCapture = FALSE;
    static RECT rcWin;
    POINT       pt;

    switch (msg)
    {
//      case WM_NCHITTEST:
//              return HTTRANSPARENT;

        case WM_CREATE:
                ghwndMCI = hwnd;
                SetWindowMCI(hwnd);
                break;

        case WM_SIZE:
                GetClientRect(hwnd, &rc);
                SetDestRectMCI(&rc);
                break;

        case WM_CLOSE:
                SetWindowMCI(NULL);
                break;

        case WM_DESTROY:
                SetWindowMCI(NULL);
                ghwndMCI = NULL;
                CleanUpDrag();
                break;

        case WM_RBUTTONDOWN:
                PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_STOP, 0);
                break;

        case WM_LBUTTONDOWN:
                switch(gwStatus) {

            case MCI_MODE_PAUSE:
                PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAY, 0);
                break;

            case MCI_MODE_PLAY:
            case MCI_MODE_SEEK:
                PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PAUSE, 0);
                break;

            default:
                //Capture to initiate the drag drop operation.
                if (!gfOle2IPEditing) {
                    fDragCapture = TRUE;
                    SetCapture(hwnd);
                    GetClientRect(hwnd, (LPRECT)&rcWin);
                    MapWindowPoints(hwnd, NULL, (LPPOINT)&rcWin, 2);
                }
            }
            break;

        case WM_LBUTTONDBLCLK:
            SeekMCI(gdwMediaStart);
            PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAY, 0);
            break;

        case WM_LBUTTONUP:
            if (!fDragCapture)
                break;
            fDragCapture = FALSE;
            ReleaseCapture();
            break;

        case WM_MOUSEMOVE:
            //Initiate drag drop if outside the window.
            if (!fDragCapture)
                break;
            LONG2POINT(lParam, pt);
            MapWindowPoints(hwnd, NULL, &pt, 1);

            if (!PtInRect((LPRECT)&rcWin, pt)) {

                ReleaseCapture();
                DoDrag();
                fDragCapture = FALSE;

            } else {

                SetCursor(LoadCursor(ghInst,MAKEINTRESOURCE(IDC_DRAG)));
            }
            break;

        case WM_PALETTECHANGED:
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case WM_QUERYNEWPALETTE:
            if (gwDeviceID && (gwDeviceType & DTMCI_CANWINDOW)) {
                mciSendCommand(gwDeviceID, MCI_REALIZE,
                MCI_ANIM_REALIZE_NORM, 0L);
            }
            break;

        case WM_ERASEBKGND:
                /* Don't erase the part we'll paint into cuz we'd flicker */
                /* and flicker is bad.                                    */
                if (gwDeviceID && (gwDeviceType & DTMCI_CANWINDOW)) {
                    GetDestRectMCI(&rc);
                    SaveDC((HDC)wParam);
                    ExcludeClipRect((HDC)wParam, rc.left, rc.top, rc.right,
                        rc.bottom);
                    DefWindowProc(hwnd, msg, wParam, lParam);
                    RestoreDC((HDC)wParam, -1);
                }
                return 0;

        case WM_PAINT:
                hdc = BeginPaint(hwnd, &ps);

                if (gwDeviceID)
                {
                    GetClientRect(hwnd, &rc);

                    if (gwDeviceType & DTMCI_CANWINDOW) {
                        mciUpdate.hDC = hdc;

/*!!! should we send  MCI_DGV_UPDATE_PAINT? to non dgv devices? */

                        dw = mciSendCommand(gwDeviceID, MCI_UPDATE,
                            MCI_ANIM_UPDATE_HDC | MCI_WAIT |
                            MCI_DGV_UPDATE_PAINT,
                            (DWORD_PTR)(LPVOID)&mciUpdate);

                        //
                        // if the update fails then erase
                        //
                        if (dw != 0)
                            DefWindowProc(hwnd, WM_ERASEBKGND, (WPARAM)hdc, 0);

                    }
                }
                EndPaint(hwnd, &ps);
                return 0;
        }

        return DefWindowProc(hwnd, msg, wParam, lParam);
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

HPALETTE CopyPalette(HPALETTE hpal)
{
    PLOGPALETTE ppal;
    int         nNumEntries = 0; // MUST initialise.  GetObject stores TWO bytes
    int         i;

    if (!hpal)
        return NULL;

    GetObject(hpal,sizeof(int),&nNumEntries);

    if (nNumEntries == 0)
        return NULL;

    ppal = AllocMem(sizeof(LOGPALETTE) + nNumEntries * sizeof(PALETTEENTRY));

    if (!ppal)
        return NULL;

    ppal->palVersion    = 0x300;
    ppal->palNumEntries = (USHORT)nNumEntries;

    GetPaletteEntries(hpal,0,nNumEntries,ppal->palPalEntry);

    for (i=0; i<nNumEntries; i++)
        ppal->palPalEntry[i].peFlags = 0;

    hpal = CreatePalette(ppal);

    FreeMem(ppal, sizeof(LOGPALETTE) + nNumEntries * sizeof(PALETTEENTRY));

    return hpal;
}


#ifdef UNUSED
HANDLE PictureFromBitmap(HBITMAP hbm, HPALETTE hpal)
{
    LPMETAFILEPICT  pmfp;
    HANDLE          hmfp;
    HANDLE          hmf;
    HANDLE          hdc;
    HDC             hdcMem;
    BITMAP          bm;
    HBITMAP         hbmT;

    if (!hbm)
        return NULL;

    GetObject(hbm, sizeof(bm), (LPVOID)&bm);

    hdcMem = CreateCompatibleDC(NULL);
    if (!hdcMem)
        return NULL;
    hbmT = SelectObject(hdcMem, hbm);

    hdc = CreateMetaFile(NULL);
    if (!hdc) {
        DeleteDC(hdcMem);
        return NULL;
    }

    SetWindowOrgEx (hdc, 0, 0, NULL);
    SetWindowExtEx (hdc, bm.bmWidth, bm.bmHeight, NULL);

    if (hpal)
    {
        SelectPalette(hdcMem,hpal,FALSE);
        RealizePalette(hdcMem);
        SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);
    }

    SetStretchBltMode(hdc, COLORONCOLOR);
    BitBlt(hdc,0,0,bm.bmWidth,bm.bmHeight,hdcMem,0,0,SRCCOPY);

    hmf = CloseMetaFile(hdc);

    SelectObject(hdcMem, hbmT);
    DeleteDC(hdcMem);

    if (hmfp = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE, sizeof(METAFILEPICT)))
    {
        pmfp = (LPMETAFILEPICT)GLOBALLOCK(hmfp);

        hdc = GetDC(NULL);
#if 1
        pmfp->mm   = MM_ANISOTROPIC;
        pmfp->hMF  = hmf;
        pmfp->xExt = MulDiv(bm.bmWidth ,2540,GetDeviceCaps(hdc, LOGPIXELSX));
        pmfp->yExt = MulDiv(bm.bmHeight,2540,GetDeviceCaps(hdc, LOGPIXELSX));
#else
        pmfp->mm   = MM_TEXT;
        pmfp->hMF  = hmf;
        pmfp->xExt = bm.bmWidth;
        pmfp->yExt = bm.bmHeight;
#endif
        ReleaseDC(NULL, hdc);
    }
    else
    {
        DeleteMetaFile(hmf);
    }

    return hmfp;
}
#endif /* UNUSED */

HANDLE FAR PASCAL PictureFromDib(HANDLE hdib, HPALETTE hpal)
{
    LPMETAFILEPICT      pmfp;
    HANDLE              hmfp;
    HANDLE              hmf;
    HANDLE              hdc;
    LPBITMAPINFOHEADER  lpbi;

    if (!hdib)
        return NULL;

    lpbi = (LPVOID)GLOBALLOCK(hdib);
    if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
        lpbi->biClrUsed = 1 << lpbi->biBitCount;

    hdc = CreateMetaFile(NULL);
    if (!hdc)
        return NULL;

    SetWindowOrgEx(hdc, 0, 0, NULL);
    SetWindowExtEx(hdc, (int)lpbi->biWidth, (int)lpbi->biHeight, NULL);

    if (hpal)
    {
        SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);
    }

    SetStretchBltMode(hdc, COLORONCOLOR);

    StretchDIBits(hdc,
        0,0,(int)lpbi->biWidth, (int)lpbi->biHeight,
        0,0,(int)lpbi->biWidth, (int)lpbi->biHeight,
        (LPBYTE)lpbi + (int)lpbi->biSize + (int)lpbi->biClrUsed * sizeof(RGBQUAD),
        (LPBITMAPINFO)lpbi,
        DIB_RGB_COLORS,
        SRCCOPY);

    if (hpal)
        SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);

    hmf = CloseMetaFile(hdc);

    hmfp = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE, sizeof(METAFILEPICT));

    if (hmfp)
    {
        pmfp = (LPMETAFILEPICT)GLOBALLOCK(hmfp);

        hdc = GetDC(NULL);
#if 1
        pmfp->mm   = MM_ANISOTROPIC;
        pmfp->hMF  = hmf;
        pmfp->xExt = MulDiv((int)lpbi->biWidth ,2540,GetDeviceCaps(hdc, LOGPIXELSX));
        pmfp->yExt = MulDiv((int)lpbi->biHeight,2540,GetDeviceCaps(hdc, LOGPIXELSY));
        extWidth   = pmfp->xExt;
        extHeight  = pmfp->yExt;
        DPF1("PictureFromDib: Bitmap %d x %d; metafile %d x %d\n", lpbi->biWidth, lpbi->biHeight, extWidth, extHeight);
#else
        pmfp->mm   = MM_TEXT;
        pmfp->hMF  = hmf;
        pmfp->xExt = (int)lpbi->biWidth;
        pmfp->yExt = (int)lpbi->biHeight;
#endif

        ReleaseDC(NULL, hdc);
    }
    else
    {
        DeleteMetaFile(hmf);
    }

    GLOBALUNLOCK(hdib);
    GLOBALUNLOCK(hmfp);

    return hmfp;
}

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */

/*
 *  DibFromBitmap()
 *
 *  Will create a global memory block in DIB format that represents the DDB
 *  passed in
 *
 */
HANDLE FAR PASCAL DibFromBitmap(HBITMAP hbm, HPALETTE hpal)
{
    BITMAP               bm;
    BITMAPINFOHEADER     bi;
    BITMAPINFOHEADER FAR *lpbi;
    DWORD                dw;
    HANDLE               hdib;
    HDC                  hdc;
    HPALETTE             hpalT;

    if (!hbm)
        return NULL;

    GetObject(hbm,sizeof(bm),&bm);

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = (bm.bmPlanes * bm.bmBitsPixel) > 8 ? 24 : 8;
    bi.biCompression        = BI_RGB;
    bi.biSizeImage          = (DWORD)WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = bi.biBitCount == 8 ? 256 : 0;
    bi.biClrImportant       = 0;

    dw  = bi.biSize + bi.biClrUsed * sizeof(RGBQUAD) + bi.biSizeImage;

    hdib = GlobalAlloc(GHND | GMEM_DDESHARE, dw);

    if (!hdib)
        return NULL;

    lpbi = (LPBITMAPINFOHEADER)GLOBALLOCK(hdib);
    *lpbi = bi;

    hdc = CreateCompatibleDC(NULL);

    if (hpal && hdc)
    {
        hpalT = SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);
    }

    GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
        (LPBYTE)lpbi + (int)lpbi->biSize + (int)lpbi->biClrUsed * sizeof(RGBQUAD),
        (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

    if (hpal)
        SelectPalette(hdc,hpalT,FALSE);

    if (hdc)
        DeleteDC(hdc);

    GLOBALUNLOCK(hdib);

    return hdib;
}

/* CreateSystemPalette()
 *
 * Return a palette which represents the system (physical) palette.
 * By selecting this palette into a screen DC and realizing the palette,
 * the exact physical mapping will be restored
 *
 * one use for this is when "snapping" the screen as a bitmap
 *
 * On error (e.g. out of memory), NULL is returned.
 */
HPALETTE FAR PASCAL CreateSystemPalette()
{
    HDC             hdc;                    // DC onto the screen
    int             iSizePalette;           // size of entire palette
    int             iFixedPalette;          // number of reserved colors
    int             i;

    struct {
        WORD         palVersion;
        WORD         palNumEntries;
        PALETTEENTRY palPalEntry[256];
    }   pal;

    hdc = GetDC(NULL);

    if (!(GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE))
    {
        ReleaseDC(NULL,hdc);
        return NULL;
    }

    iSizePalette = GetDeviceCaps(hdc, SIZEPALETTE);

    //
    // determine the number of 'static' system colors that
    // are currently reserved
    //
    if (GetSystemPaletteUse(hdc) == SYSPAL_STATIC)
        iFixedPalette = GetDeviceCaps(hdc, NUMCOLORS);
    else
        iFixedPalette = 2;

    //
    // create a logical palette containing the system colors;
    // this palette has all entries except fixed (system) colors
    // flagged as PC_NOCOLLAPSE
    //
    pal.palVersion = 0x300;
    pal.palNumEntries = (USHORT)iSizePalette;

    GetSystemPaletteEntries(hdc, 0, iSizePalette, pal.palPalEntry);

    ReleaseDC(NULL,hdc);

    for (i = iFixedPalette/2; i < iSizePalette-iFixedPalette/2; i++)
        pal.palPalEntry[i].peFlags = PC_NOCOLLAPSE;

    return CreatePalette((LPLOGPALETTE)&pal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\mci.h ===
/*-----------------------------------------------------------------------------+
| MCI.H                                                                        |
|                                                                              |
| Routines for dealing with MCI devices.                                       |
| These routines only support *one* open MCI device/file at a time.            |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#define MCI_WINDOW_CLASS TEXT("MCIWindow")

BOOL FAR PASCAL InitMCI(HANDLE hPrev, HANDLE hInst);
BOOL FAR PASCAL OpenMCI(LPCTSTR szFile, LPCTSTR szDevice);
void LoadStatusStrings(void);
LPTSTR MapModeToStatusString( WORD Mode );
void FAR PASCAL UpdateMCI(void);
void FAR PASCAL CloseMCI(BOOL fUpdateDisplay);
BOOL FAR PASCAL PlayMCI(DWORD_PTR dwFrom, DWORD_PTR dwTo);
BOOL FAR PASCAL PauseMCI(void);
BOOL FAR PASCAL StopMCI(void);
BOOL FAR PASCAL EjectMCI(BOOL fOpen);
UINT FAR PASCAL StatusMCI(DWORD_PTR FAR *pdwPosition);
BOOL FAR PASCAL SeekMCI(DWORD_PTR dwPosition);
BOOL FAR PASCAL SeekToStartMCI(void);
void FAR PASCAL SkipTrackMCI(int iSkip);
BOOL FAR PASCAL SetWindowMCI(HWND hwnd);
HWND FAR PASCAL GetWindowMCI(void);
BOOL FAR PASCAL SetPaletteMCI(HPALETTE hpal);
BOOL FAR PASCAL SetTimeFormatMCI(UINT wTimeFormat);
BOOL FAR PASCAL SeekExactMCI(BOOL fExact);
void FAR PASCAL CreateWindowMCI(void);
void FAR PASCAL FindDeviceMCI(void);
void FAR PASCAL GetDeviceNameMCI(LPTSTR szDevice, UINT wLen);
void FAR PASCAL QueryDevicesMCI(LPTSTR szDevices, UINT wLen);

BOOL FAR PASCAL GetDestRectMCI(LPRECT lprc);
BOOL FAR PASCAL GetSourceRectMCI(LPRECT lprc);
BOOL FAR PASCAL SetDestRectMCI(LPRECT lprc);
BOOL FAR PASCAL SetSourceRectMCI(LPRECT lprc);

BOOL FAR PASCAL ShowWindowMCI(BOOL fShow);
BOOL FAR PASCAL PutWindowMCI(LPRECT prc);

#define MCI_STRING_LENGTH   128
DWORD PASCAL SendStringMCI(PTSTR szCmd, PTSTR szReturn, UINT wLen);

BOOL FAR PASCAL ConfigMCI(HWND hwnd);

HPALETTE FAR PASCAL PaletteMCI(void);
HBITMAP FAR PASCAL BitmapMCI(void);
void    FAR PASCAL CopyMCI(HWND hwnd);

#define WM_MCI_POSITION_CHANGE  (WM_USER+10)    // wParam = DeviceID, lParam = position
#define WM_MCI_MODE_CHANGE      (WM_USER+11)    // wParam = DeviceID, lParam = mode
#define WM_MCI_MEDIA_CHANGE     (WM_USER+12)    // wParam = DeviceID, lParam = 0


//
//  the following flags are returned by DeviceTypeMCI, and QueryDeviceMCI
//
UINT FAR PASCAL DeviceTypeMCI(LPTSTR szDevice, LPTSTR szDeviceName, int nBuf);
UINT FAR PASCAL QueryDeviceTypeMCI(UINT wDeviceID);

extern UINT gwDeviceType;

#define DTMCI_ERROR             0x0000
#define DTMCI_IGNOREDEVICE      0xFFFF

#define DTMCI_SIMPLEDEV         0x0001      // simple (not compound) device
#define DTMCI_FILEDEV           0x0002      // device does files
#define DTMCI_COMPOUNDDEV       0x0004      // compound (not simple) device
#define DTMCI_CANSEEKEXACT      0x0008      // can seek exactly
#define DTMCI_CANPLAY           0x0010      // device supports play
#define DTMCI_CANEJECT          0x0020      // device supports eject
#define DTMCI_CANCONFIG         0x0040      // device supports config
#define DTMCI_CANMUTE           0x0080      // device supports set audio
#define DTMCI_CANPAUSE          0x0100      // device supports config
#define DTMCI_CANWINDOW         0x0200      // device supports windows
#define DTMCI_TIMEFRAMES        0x0400      // device does frames
#define DTMCI_TIMEMS            0x0800      // device does milliseconds

// Known devices:
#define DTMCI_DEVICE            0xF000      // The following are mutually exclusive
#define DTMCI_AVIVIDEO          0x1000      // device is MCIAVI
#define DTMCI_CDAUDIO           0x2000      // device is CDAUDIO
#define DTMCI_SEQUENCER         0x3000      // device is MIDI sequencer
#define DTMCI_WAVEAUDIO         0x4000      // device is Wave audio
#define DTMCI_VIDEODISC         0x5000      // device is Video disc
#define DTMCI_VCR               0x6000      // device is Video cassette


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\menuids.h ===
/*-----------------------------------------------------------------------------+
| MENUIDS.H                                                                    |
|                                                                              |
| IDs of the menu items.                                                       |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

/* Menu Identifiers */

/* File */

#define IDM_OPEN                100     /* ID of the 'Open File' option       */
#define IDM_CLOSE               101     /* ID of the 'Close' option           */
#define IDM_EXIT                102     /* ID of the 'Exit' option            */

/* Edit */

#define IDM_COPY_OBJECT         110     /* copy ole object */
#define IDM_OPTIONS             111
#define IDM_SELECTION           112

/* Device */

#define IDM_CONFIG              120     /* do device config dialog */
#define IDM_VOLUME              121     /* do device config dialog */

/* Scale */

#define IDM_SCALE               131     /* Add to one of the below */
#define ID_NONE                 0       /* nothing                            */
#define ID_FRAMES               1       /* ID of the 'Frames' scale option    */
#define ID_TIME                 2       /* ID of the 'Time' scale option      */
#define ID_TRACKS               3       /* ID of the 'Tracks' scale option    */

/* Help */

#define IDM_HELPTOPICS          140     /* ID of the 'Help Topics' option     */
#define IDM_ABOUT               143     /* ID of the 'About' option           */


#define IDM_UPDATE              222

#define IDM_WINDOW              223     /* make MPlayer small/big */
#define IDM_DEFAULTSIZE         224     /* make MPlayer the default size */
#define IDM_MCISTRING           225

#define IDM_ZOOM                230
#define IDM_ZOOM1               231
#define IDM_ZOOM2               232
#define IDM_ZOOM3               233
#define IDM_ZOOM4               234

#define IDM_NONE                400
#define IDM_DEVICE0             400     /* ID of the first entry in the Device*/
                                        /* menu. No new menu items should be  */
                                        /* #defined with a number greater than*/
                                        /* this.                              */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\nocrap.h ===
/*-----------------------------------------------------------------------------+
| NOCRAP.H                                                                     |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

//#define NOVIRTUALKEYCODES    // VK_*
//#define NOSYSMETRICS         // SM_*
#define NOICONS              // IDI_*
//#define NOSYSCOMMANDS        // SC_*
#define OEMRESOURCE          // OEM Resource values
#define NOATOM               // Atom Manager routines
//#define NOCLIPBOARD          // Clipboard routines
//#define NOCTLMGR             // Control and Dialog routines
#define NODRAWTEXT           // DrawText() and DT_*
//#define NOMETAFILE           // typedef METAFILEPICT
//#define NOMSG                // typedef MSG and associated routines
#define NOSOUND              // Sound driver routines
//#define NOWH                 // SetWindowsHook and WH_*
#define NOCOMM               // COMM driver routines
#define NOKANJI              // Kanji support stuff.
//#define NOHELP               // Help engine interface.
#define NOPROFILER           // Profiler interface.
//#define NODEFERWINDOWPOS     // DeferWindowPos routines

//#define NOWIN31              // New Windows 3.1 APIs
#define NOGDICAPMASKS        // CC_*, LC_*, PC_*, CP_*, TC_*, RC_
//#define NOWINMESSAGES        // WM_*, EM_*, LB_*, CB_*
//#define NOWINSTYLES          // WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
//#define NOMENUS              // MF_*
//#define NORASTEROPS          // Binary and Tertiary raster ops
//#define NOSHOWWINDOW         // SW_*
//#define NOCOLOR              // Screen colors
//#define NOGDI                // All GDI defines and routines
//#define NOKERNEL             // All KERNEL defines and routines
//#define NOUSER               // All USER defines and routines
//#define NOMB                 // MB_* and MessageBox()
//#define NOMEMMGR             // GMEM_*, LMEM_*, GHND, LHND, associated routines
//#define NOMINMAX             // Macros min(a,b) and max(a,b)
#define NOOPENFILE           // OpenFile(), OemToAnsi, AnsiToOem, and OF_*
//#define NOSCROLL             // SB_* and scrolling routines
//#define NOWINOFFSETS         // GWL_*, GCL_*, associated routines
//#define NODRIVERS            // Installable driver defines
//#define NODBCS               // DBCS support stuff.
#define NOSYSTEMPARAMSINFO   // SystemParameterInfo (SPI_*)
#define NOSCALABLEFONT       // Scalable font prototypes and data structures
//#define NOGDIOBJ             // GDI objects including pens, brushes and logfonts.
//#define NOBITMAP             // GDI bitmaps
#define NOLFILEIO            // _l* file I/O
#define NOLOGERROR           // LogError() and related definitions
#define NOPROFILER           // Profiler APIs


#define MMNOSOUND            // Sound support
//#define MMNOWAVE             // Waveform support
#define MMNOMIDI             // MIDI support
#define MMNOAUX              // Auxiliary output support
#define MMNOTIMER            // Timer support
#define MMNOJOY              // Joystick support
//#define MMNOMCI              // MCI support
//#define MMNODRV              // Installable driver support
//#define MMNOMMIO             // MMIO library support
//#define MMNOMMSYSTEM         // No mmsystem general functions

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\obj.c ===
/*---------------------------------------------------------------------------
|   OBJ.C
|   This file has the IUnknown, IOleObject, IStdMarshalInfo and IDataObject
|   interfaces of the  OLE2 object (docMain). it also has other helper functions
|
|   Created By: Vij Rajarajan (VijR)
+---------------------------------------------------------------------------*/
#define SERVERONLY
#include <Windows.h>
#include <shellapi.h>

#include "mpole.h"
#include "mplayer.h"

extern int FAR PASCAL  ReallyDoVerb (LPDOC, LONG, LPMSG, LPOLECLIENTSITE,
                     BOOL, BOOL);
extern BOOL FindRealFileName(LPTSTR szFile, int iLen);

// static functions.
HANDLE  PASCAL GetDib (VOID);

HANDLE  GetMetafilePict (VOID);
HANDLE  GetMPlayerIcon(void);

extern void FAR PASCAL SetEmbeddedObjectFlag(BOOL flag);
extern HPALETTE CopyPalette(HPALETTE hpal);
extern HBITMAP FAR PASCAL BitmapMCI(void);
extern HPALETTE FAR PASCAL PaletteMCI(void);
extern void DoInPlaceDeactivate(LPDOC lpdoc);
HANDLE FAR PASCAL PictureFromDib(HANDLE hdib, HPALETTE hpal);
HANDLE FAR PASCAL DibFromBitmap(HBITMAP hbm, HPALETTE hpal);
void FAR PASCAL DitherMCI(HANDLE hdib, HPALETTE hpal);



/* GetMetafilePict
 * ---------------
 *
 * RETURNS: A handle to the object's data in metafile format.
 */
HANDLE GetMetafilePict ( )
{

    HPALETTE hpal;
    HANDLE   hdib;
    HANDLE   hmfp;
    HDC      hdc;

    DPF("GetMetafilePict called on thread %d\n", GetCurrentThreadId());

    hdib = (HANDLE)SendMessage(ghwndApp, WM_GETDIB, 0, 0);

    /* If we're dithered, don't use a palette */
    hdc = GetDC(NULL);
    if ((GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
        && (gwOptions & OPT_DITHER))
        hpal = NULL;
    else
        hpal = PaletteMCI();

    if (hpal)
        hpal = CopyPalette(hpal);

    ReleaseDC(NULL, hdc);

    hmfp = PictureFromDib(hdib, hpal);

    if (hpal)
        DeleteObject(hpal);

    GLOBALFREE(hdib);

    return hmfp;
}


/**************************************************************************
//## Somebody wants a dib (OLE)
***************************************************************************/
HANDLE PASCAL GetDib( VOID )
{
    HBITMAP  hbm;
    HPALETTE hpal;
    HANDLE   hdib;
    HDC      hdc;

    DPF("GetDib\n");

    hbm  = BitmapMCI();
    hpal = PaletteMCI();

    hdib = DibFromBitmap(hbm, hpal);

    //
    //  if we are on a palette device. possibly dither to the VGA colors
    //  for apps that dont deal with palettes!
    //
    hdc = GetDC(NULL);
    if ((GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) &&
                       (gwOptions & OPT_DITHER))
    {
        DitherMCI(hdib, hpal);
        hpal = NULL;            // no longer working with a palette
    }
    ReleaseDC(NULL, hdc);

    if (hbm)
        DeleteObject(hbm);
    return hdib;
}


/**************************************************************************
* GetMPlayerIcon: This function extracts the our Icon and gives it out
* as a Metafile incase the client wants DVASPECT_ICON
***************************************************************************/
HANDLE GetMPlayerIcon (void)
{
    HICON           hicon;
    HDC             hdc;
    HANDLE          hmfp = NULL;
    LPMETAFILEPICT  pmfp=NULL;
    static int      cxIcon = 0;
    static int      cyIcon = 0;
    static int      cxIconHiMetric = 0;
    static int      cyIconHiMetric = 0;

    hicon = GetIconForCurrentDevice(GI_LARGE, IDI_DDEFAULT);

    if ((HICON)1==hicon || NULL==hicon)
        return NULL;

    if (!(hmfp = GlobalAlloc (GMEM_DDESHARE | GMEM_MOVEABLE,
                    sizeof(METAFILEPICT))))
        return NULL;

    pmfp = (METAFILEPICT FAR*) GLOBALLOCK (hmfp);

    if (0==cxIcon)
    {
        // In units of pixels
        cxIcon = GetSystemMetrics (SM_CXICON);
        cyIcon = GetSystemMetrics (SM_CYICON);

        // In units of .01 millimeter
        cxIconHiMetric = cxIcon * HIMETRIC_PER_INCH / giXppli;
        cyIconHiMetric = cyIcon * HIMETRIC_PER_INCH / giYppli;;
    }

    pmfp->mm   = MM_ANISOTROPIC;
    pmfp->xExt = cxIconHiMetric;
    pmfp->yExt = cyIconHiMetric;
    hdc = CreateMetaFile (NULL);

    SetWindowOrgEx (hdc, 0, 0, NULL);
    SetWindowExtEx (hdc, cxIcon, cyIcon, NULL);

    DrawIcon (hdc, 0, 0, hicon);
    pmfp->hMF = CloseMetaFile (hdc);

    GLOBALUNLOCK (hmfp);

    if (NULL == pmfp->hMF) {
        GLOBALFREE (hmfp);
        return NULL;
    }

    return hmfp;
}


#ifdef DEBUG

#define DBG_CHECK_GUID(guid)            \
        if (IsEqualIID(&guid, riidReq))  \
            return #guid

LPSTR DbgGetIIDString(REFIID riidReq)
{
    static CHAR UnknownIID[64];

    DBG_CHECK_GUID(IID_IUnknown);
    DBG_CHECK_GUID(IID_IClassFactory);
    DBG_CHECK_GUID(IID_IMalloc);
    DBG_CHECK_GUID(IID_IMarshal);
    DBG_CHECK_GUID(IID_IRpcChannel);
    DBG_CHECK_GUID(IID_IRpcStub);
    DBG_CHECK_GUID(IID_IStubManager);
    DBG_CHECK_GUID(IID_IRpcProxy);
    DBG_CHECK_GUID(IID_IProxyManager);
    DBG_CHECK_GUID(IID_IPSFactory);
    DBG_CHECK_GUID(IID_ILockBytes);
    DBG_CHECK_GUID(IID_IStorage);
    DBG_CHECK_GUID(IID_IStream);
    DBG_CHECK_GUID(IID_IEnumSTATSTG);
    DBG_CHECK_GUID(IID_IBindCtx);
    DBG_CHECK_GUID(IID_IMoniker);
    DBG_CHECK_GUID(IID_IRunningObjectTable);
    DBG_CHECK_GUID(IID_IInternalMoniker);
    DBG_CHECK_GUID(IID_IRootStorage);
    DBG_CHECK_GUID(IID_IDfReserved1);
    DBG_CHECK_GUID(IID_IDfReserved2);
    DBG_CHECK_GUID(IID_IDfReserved3);
    DBG_CHECK_GUID(IID_IMessageFilter);
    DBG_CHECK_GUID(CLSID_StdMarshal);
    DBG_CHECK_GUID(IID_IStdMarshalInfo);
    DBG_CHECK_GUID(IID_IExternalConnection);
    DBG_CHECK_GUID(IID_IEnumUnknown);
    DBG_CHECK_GUID(IID_IEnumString);
    DBG_CHECK_GUID(IID_IEnumMoniker);
    DBG_CHECK_GUID(IID_IEnumFORMATETC);
    DBG_CHECK_GUID(IID_IEnumOLEVERB);
    DBG_CHECK_GUID(IID_IEnumSTATDATA);
    DBG_CHECK_GUID(IID_IEnumGeneric);
    DBG_CHECK_GUID(IID_IEnumHolder);
    DBG_CHECK_GUID(IID_IEnumCallback);
    DBG_CHECK_GUID(IID_IPersistStream);
    DBG_CHECK_GUID(IID_IPersistStorage);
    DBG_CHECK_GUID(IID_IPersistFile);
    DBG_CHECK_GUID(IID_IPersist);
    DBG_CHECK_GUID(IID_IViewObject);
    DBG_CHECK_GUID(IID_IDataObject);
    DBG_CHECK_GUID(IID_IAdviseSink);
    DBG_CHECK_GUID(IID_IDataAdviseHolder);
    DBG_CHECK_GUID(IID_IOleAdviseHolder);
    DBG_CHECK_GUID(IID_IOleObject);
    DBG_CHECK_GUID(IID_IOleInPlaceObject);
    DBG_CHECK_GUID(IID_IOleWindow);
    DBG_CHECK_GUID(IID_IOleInPlaceUIWindow);
    DBG_CHECK_GUID(IID_IOleInPlaceFrame);
    DBG_CHECK_GUID(IID_IOleInPlaceActiveObject);
    DBG_CHECK_GUID(IID_IOleClientSite);
    DBG_CHECK_GUID(IID_IOleInPlaceSite);
    DBG_CHECK_GUID(IID_IParseDisplayName);
    DBG_CHECK_GUID(IID_IOleContainer);
    DBG_CHECK_GUID(IID_IOleItemContainer);
    DBG_CHECK_GUID(IID_IOleLink);
    DBG_CHECK_GUID(IID_IOleCache);
    DBG_CHECK_GUID(IID_IOleManager);
    DBG_CHECK_GUID(IID_IOlePresObj);
    DBG_CHECK_GUID(IID_IDropSource);
    DBG_CHECK_GUID(IID_IDropTarget);
    DBG_CHECK_GUID(IID_IDebug);
    DBG_CHECK_GUID(IID_IDebugStream);
    DBG_CHECK_GUID(IID_IAdviseSink2);
    DBG_CHECK_GUID(IID_IRunnableObject);
    DBG_CHECK_GUID(IID_IViewObject2);
    DBG_CHECK_GUID(IID_IOleCache2);
    DBG_CHECK_GUID(IID_IOleCacheControl);

    wsprintfA(UnknownIID, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
              riidReq->Data1, riidReq->Data2, riidReq->Data3,
              riidReq->Data4[0], riidReq->Data4[1],
              riidReq->Data4[2], riidReq->Data4[3],
              riidReq->Data4[4], riidReq->Data4[5],
              riidReq->Data4[6], riidReq->Data4[7]);

    return UnknownIID;
}

#endif


/**************************************************************************
*****************   IUnknown INTERFACE IMPLEMENTATION.
**************************************************************************/

STDMETHODIMP UnkQueryInterface(
LPUNKNOWN         lpUnkObj,       // Unknown object ptr
REFIID            riidReq,        // IID required
LPVOID FAR *      lplpUnk         // pre for returning the interface
)
{
    LPDOC       lpdoc;

    lpdoc = ((struct COleObjectImpl FAR*)lpUnkObj)->lpdoc;

    DPF1("QueryInterface( %s )\n", DbgGetIIDString(riidReq));

    if (IsEqualIID(riidReq, &IID_IOleObject)) {
        *lplpUnk = (LPVOID) &lpdoc->m_Ole;
        lpdoc->cRef++;
        return NOERROR;

    } else if (IsEqualIID(riidReq, &IID_IDataObject)) {
        *lplpUnk = (LPVOID) &lpdoc->m_Data;
        lpdoc->cRef++;
        return NOERROR;

    } else if (IsEqualIID(riidReq, &IID_IUnknown)) {
        *lplpUnk = (LPVOID) &lpdoc->m_Ole;
        lpdoc->cRef++;
        return NOERROR;

    } else if (IsEqualIID(riidReq, &IID_IPersist) || IsEqualIID(riidReq, &IID_IPersistStorage)) {
        *lplpUnk = (LPVOID) &lpdoc->m_PersistStorage;
        lpdoc->cRef++;
        return NOERROR;

    } else if (IsEqualIID(riidReq, &IID_IPersistFile)) {
        *lplpUnk = (LPVOID) &lpdoc->m_PersistFile;
        lpdoc->cRef++;
        return NOERROR;

    } else if (IsEqualIID(riidReq, &IID_IOleWindow) || IsEqualIID(riidReq, &IID_IOleInPlaceObject)) {
        *lplpUnk = (LPVOID) &lpdoc->m_InPlace;
        lpdoc->cRef++;
        return NOERROR;

    } else if (IsEqualIID(riidReq, &IID_IOleInPlaceActiveObject)) {
        *lplpUnk = (LPVOID) &lpdoc->m_IPActive;
        lpdoc->cRef++;
        return NOERROR;

    } else {
        *lplpUnk = (LPVOID) NULL;
        DPF1("E_NOINTERFACE\n");
        RETURN_RESULT(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG) UnkAddRef(LPUNKNOWN    lpUnkObj)
{
    LPDOC   lpdoc;

    lpdoc = ((struct COleObjectImpl FAR*)lpUnkObj)->lpdoc;
    return ++lpdoc->cRef;
}

STDMETHODIMP_(ULONG) UnkRelease (LPUNKNOWN lpUnkObj)
{
    LPDOC   lpdoc;

    lpdoc = ((struct COleObjectImpl FAR*)lpUnkObj)->lpdoc;
    if (--lpdoc->cRef == 0)
    {
        DPF1("\n**^*^*^*^*^*^*^*^*^*^*^*^*Refcnt OK\n");
        if (!(gfOle2IPPlaying || gfOle2IPEditing) && srvrMain.cLock == 0)
            PostCloseMessage();
        return 0;
    }

    return lpdoc->cRef;
}

/**************************************************************************
*************   IOleObject INTERFACE IMPLEMENTATION
**************************************************************************/

//delegate to the common IUnknown Implemenation.
STDMETHODIMP OleObjQueryInterface(
LPOLEOBJECT   lpOleObj,      // ole object ptr
REFIID            riidReq,        // IID required
LPVOID FAR *      lplpUnk         // pre for returning the interface
)
{
    return( UnkQueryInterface((LPUNKNOWN)lpOleObj, riidReq, lplpUnk));
}


STDMETHODIMP_(ULONG) OleObjAddRef(
LPOLEOBJECT   lpOleObj      // ole object ptr
)
{
    return UnkAddRef((LPUNKNOWN) lpOleObj);
}


STDMETHODIMP_(ULONG) OleObjRelease (
LPOLEOBJECT   lpOleObj      // ole object ptr
)
{
    LPDOC    lpdoc;

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    return UnkRelease((LPUNKNOWN) lpOleObj);
}

//Save the Client site pointer.
STDMETHODIMP OleObjSetClientSite(
LPOLEOBJECT         lpOleObj,
LPOLECLIENTSITE     lpclientSite
)
{
    LPDOC   lpdoc;

    DPF("OleObjSetClientSite\n");

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    if (lpdoc->lpoleclient)
        IOleClientSite_Release(lpdoc->lpoleclient);

    lpdoc->lpoleclient = (LPOLECLIENTSITE) lpclientSite;

    // OLE2NOTE: to be able to hold onto clientSite pointer, we must AddRef it
    if (lpclientSite)
        IOleClientSite_AddRef(lpclientSite);

    return NOERROR;
}

STDMETHODIMP OleObjGetClientSite (
LPOLEOBJECT             lpOleObj,
LPOLECLIENTSITE FAR*    lplpclientSite
)
{
    DPF("OleObjGetClientSite\n");

    return NOERROR;
}


/* CheckIfInPPViewer
 *
 * Hack to stop PowerPoint viewer from crashing when we're trying to play in place.
 *
 * PP Viewer was written under the assumption that Media Player was not a full-blown
 * OLE2 server.  Much of the code was stubbed out to make the Viewer small.
 * Unfortunately this means it crashes when certain calls are made for in-place
 * activation.  These are the problem interface methods:
 *
 * OnInPlaceActivate/Deactivate
 * OnUIActivate/Deactivate
 * OnPosRectChange
 *
 * If we're in PP Viewer we simply do not make these calls.
 *
 * We detect that we're in PP Viewer by finding the parent of the window whose
 * handle is passed to DoVerb.  The window handle passed in to DoVerb is of
 * "ppSlideShowWin" class, which is the same as in PP Slide Show, which works
 * correctly.  However its parent's class is "PP4VDialog" (as distinct from
 * "PPApplicationClass").  So, if we find this class name, set a global flag
 * to test before making the troublesome calls.
 *
 * Andrew Bell (andrewbe) 11 May 1995
 *
 */
STATICFN void CheckIfInPPViewer(HWND hwndParent)
{
    HWND  hwndGrandParent;
    TCHAR ClassName[256];

    gfInPPViewer = FALSE;

    if (hwndParent)
    {
        hwndGrandParent = GetParent(hwndParent);

        if (hwndGrandParent)
        {
            if (GetClassName(hwndGrandParent, ClassName, CHAR_COUNT(ClassName)) > 0)
            {
                if (lstrcmp(ClassName, TEXT("PP4VDialog")) == 0)
                {
                    DPF0("Detected that we're in PP Viewer\n");
                    gfInPPViewer = TRUE;
                }
            }
        }
    }
}

//delegate to ReallyDoVerb.
STDMETHODIMP OleObjDoVerb(
LPOLEOBJECT             lpOleObj,
LONG                    lVerb,
LPMSG                   lpmsg,
LPOLECLIENTSITE         pActiveSite,
LONG                    lindex,
HWND            hwndParent,
LPCRECT         lprcPosRect
)
{
     LPDOC  lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

     DPF("OleObjDoVerb\n");

     CheckIfInPPViewer(hwndParent);

     RETURN_RESULT( ReallyDoVerb(lpdoc, lVerb, lpmsg, pActiveSite, TRUE, TRUE));
}



STDMETHODIMP     OleObjEnumVerbs(
LPOLEOBJECT             lpOleObj,
IEnumOLEVERB FAR* FAR*  lplpenumOleVerb )
{
    DPF("OleObjEnumVerbs\n");

    *lplpenumOleVerb = NULL;
    RETURN_RESULT( OLE_S_USEREG); //Use the reg db.
}


STDMETHODIMP     OleObjUpdate(LPOLEOBJECT lpOleObj)
{
    DPF("OleObjUpdate\n");

    // we can't contain links so there is nothing to update
    return NOERROR;
}



STDMETHODIMP     OleObjIsUpToDate(LPOLEOBJECT lpOleObj)
{
    DPF("OleObjIsUpToDate\n");

    // we can't contain links so there is nothing to update
    return NOERROR;
}



/*
From OLE2HELP.HLP:

GetUserClassID returns the CLSID as the user knows it. For embedded objects,
this is always the CLSID that is persistently stored and is returned by
IPersist::GetClassID. For linked objects, this is the CLSID of the last
bound link source. If a Treat As operation is taking place, this is the CLSID
of the application being emulated (also the CLSID that will be written into storage).

I can't follow the logic here.  What if it's an embedded object and a Treat As
operation?  However, AlexGo tells me that my IOleObject interfaces should return
the OLE2 Class ID.
*/
STDMETHODIMP OleObjGetUserClassID
    (LPOLEOBJECT lpOleObj,
    CLSID FAR*      pClsid)
{
    DPF1("OleObjGetUserClassID\n");

    *pClsid = gClsID;

    return NOERROR;
}



/**************************************************************************
*   Set our UserTypeName to "Media Clip"
**************************************************************************/

STDMETHODIMP OleObjGetUserType
    (LPOLEOBJECT lpOleObj,
    DWORD dwFormOfType,
    LPWSTR FAR* pszUserType)
{
    LPMALLOC lpMalloc;
    LPWSTR lpstr;
    int clen;

    DPF1("OleObjGetUserType\n");

    *pszUserType = NULL;
    if(CoGetMalloc(MEMCTX_TASK,&lpMalloc) != 0)
        RETURN_RESULT(E_OUTOFMEMORY);
    clen = STRING_BYTE_COUNT(gachClassRoot);
#ifndef UNICODE
    clen *= (sizeof(WCHAR) / sizeof(CHAR));
#endif
    lpstr = IMalloc_Alloc(lpMalloc, clen);
    IMalloc_Release(lpMalloc);
#ifdef UNICODE
    lstrcpy(lpstr,gachClassRoot);
#else
    AnsiToUnicodeString(gachClassRoot, lpstr, -1);
#endif /* UNICODE */
    *pszUserType = lpstr;
    return NOERROR;
}

/**************************************************************************
*   Get the name of the client and set the title.
**************************************************************************/
STDMETHODIMP OleObjSetHostNames (
LPOLEOBJECT             lpOleObj,
LPCWSTR                 lpszClientAppW,
LPCWSTR                 lpszClientObjW
)
{
    LPDOC    lpdoc;
    LPTSTR   lpszClientApp;
    LPTSTR   lpszClientObj;

    DPF1("OleObjSetHostNames\n");

#ifdef UNICODE
    lpszClientApp = (LPTSTR)lpszClientAppW;
    lpszClientObj = (LPTSTR)lpszClientObjW;
#else
    lpszClientApp = AllocateAnsiString(lpszClientAppW);
    lpszClientObj = AllocateAnsiString(lpszClientObjW);
    if( !lpszClientApp || !lpszClientObj )
        RETURN_RESULT(E_OUTOFMEMORY);
#endif /* UNICODE */

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    // object is embedded.
    lpdoc->doctype = doctypeEmbedded;

    if (lpszClientObj == NULL)
        lpszClientObj = lpszClientApp;

    SetTitle(lpdoc, lpszClientObj);
    SetMPlayerIcon();
    lstrcpy (szClient, lpszClientApp);
    if (lpszClientObj)
    {
        LPTSTR lpszFileName = FileName(lpszClientObj);
        if (lpszFileName)
            lstrcpy (szClientDoc, lpszFileName);
    }

    // this is the only time we know the object will be an embedding
    SetEmbeddedObjectFlag(TRUE);

#ifndef UNICODE
    FreeAnsiString(lpszClientApp);
    FreeAnsiString(lpszClientObj);
#endif /* NOT UNICODE */

    return NOERROR;
}


/**************************************************************************
*   The client closed the object. The server will now shut down.
**************************************************************************/
STDMETHODIMP OleObjClose (
LPOLEOBJECT             lpOleObj,
DWORD           dwSaveOptions
)
{
    LPDOC   lpdoc;

    DPF1("OleObjClose\n");

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    /* Hack to stop PowerPoint crashing:
     *
     * Win95 bug #19848: Crash saving PowerPoint with out-of-place mplayer
     *
     * If we don't call IOleClientSite::SaveObject() at this point,
     * PowerPoint will crash under certain circumstances.
     *
     * This is an extract from mail I received from TuanN, the PPT dev:
     *
     * The fundamental problem is that PP expects to receive the
     * IAdviseSink::SaveObject() as a result of calling IOleObject::Close().
     * Since the Media Player did not send that notficiation in this test case,
     * PP tries to perform an Undo operation during the ensuing OnClose()
     * notification and thus erroneously destroys the embedded object.
     * The reason we throw away the object is because PP thinks that this
     * object is still virgin (no OnViewChange). Please refer to SaveObject(),
     * OnClose() in CtCommon.cpp and slide\sextern.c for more info. In the test
     * case, during OnClose(), the "revert" state is TRUE, PP will do a
     * Ex_REVERTED operation (stack calls: SClosePicts, SClear,
     * SSaveforUndo--> object deleted).
     *
     * AndrewBe, 6 December 1994
     */
    if (lpdoc->lpoleclient)
        IOleClientSite_SaveObject(lpdoc->lpoleclient);

    DoInPlaceDeactivate(lpdoc);
    SendDocMsg(lpdoc,OLE_CLOSED);
    DestroyDoc(lpdoc);
    ExitApplication();
    //CoDisconnectObject((LPUNKNOWN)lpdoc, NULL);
    SendMessage(ghwndApp, WM_COMMAND, (WPARAM)IDM_EXIT, 0L);
    return NOERROR;
}


STDMETHODIMP OleObjSetMoniker(LPOLEOBJECT lpOleObj,
    DWORD dwWhichMoniker, LPMONIKER pmk)
{
    DPF("OleObjSetMoniker\n");

    return NOERROR;
}


STDMETHODIMP OleObjGetMoniker(LPOLEOBJECT lpOleObj,
    DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* lplpmk)
{
    LPDOC   lpdoc;

    DPF("OleObjGetMoniker\n");

    *lplpmk = NULL;
    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    if (lpdoc->lpoleclient != NULL)
    {
        return( IOleClientSite_GetMoniker(lpdoc->lpoleclient,
                dwAssign, dwWhichMoniker, lplpmk));
    }
    else if (lpdoc->doctype == doctypeFromFile)
    {
        // use file moniker

        WCHAR  sz[cchFilenameMax];

        if (GlobalGetAtomNameW(lpdoc->aDocName, sz, CHAR_COUNT(sz)) == 0)
            RETURN_RESULT( E_FAIL);

        return( (HRESULT)CreateFileMoniker(sz, lplpmk));
    }
    else
        RETURN_RESULT( E_FAIL);
}



STDMETHODIMP OleObjInitFromData (
LPOLEOBJECT         lpOleObj,
LPDATAOBJECT        lpDataObj,
BOOL                fCreation,
DWORD               dwReserved
)
{
    DPF("OleObjInitFromData - E_NOTIMPL\n");

    RETURN_RESULT( E_NOTIMPL);
}

STDMETHODIMP OleObjGetClipboardData (
LPOLEOBJECT         lpOleObj,
DWORD               dwReserved,
LPDATAOBJECT FAR*   lplpDataObj
)
{
    DPF("OleObjGetClipboardData - E_NOTIMPL\n");

    RETURN_RESULT( E_NOTIMPL);
}


STDMETHODIMP     OleObjSetExtent(
LPOLEOBJECT             lpOleObj,
DWORD                   dwAspect,
LPSIZEL                 lpsizel)
{
    DPF("OleObjSetExtent\n");

#ifdef LATER
    gscaleInitXY[SCALE_X].denom = lpsizel->cx;
    gscaleInitXY[SCALE_Y].denom = lpsizel->cy;
#endif

    return NOERROR;
}

//Get the object extent from the Metafile. GetMetafilePict saves the extents
// in extWidth and extHeight
STDMETHODIMP     OleObjGetExtent(
LPOLEOBJECT             lpOleObj,
DWORD                   dwAspect,
LPSIZEL                 lpSizel)
{
    HGLOBAL hTmpMF;
    LPDOC lpdoc;

    DPF("OleObjGetExtent\n");

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    if((dwAspect & (DVASPECT_CONTENT | DVASPECT_DOCPRINT)) == 0)
        RETURN_RESULT( E_INVALIDARG);
    // There may be a potential memory leak here -- hTmpMF contains a handle to a
    // metafile that must be deleted. See code in cdrag.c.
    // Not changed here at this time since I do not want to break anything.
    // SteveZ
    hTmpMF = GetMetafilePict();
    GLOBALUNLOCK(hTmpMF);
    GLOBALFREE(hTmpMF);
    lpSizel->cx = extWidth;
    lpSizel->cy = extHeight;

    return NOERROR;
}


STDMETHODIMP OleObjAdvise(LPOLEOBJECT lpOleObj, LPADVISESINK lpAdvSink, LPDWORD lpdwConnection)
{
    LPDOC    lpdoc;

    DPF("OleObjAdvise\n");

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    if (lpdoc->lpoaholder == NULL &&
        CreateOleAdviseHolder(&lpdoc->lpoaholder) != S_OK)
        RETURN_RESULT( E_OUTOFMEMORY);

    return( IOleAdviseHolder_Advise(lpdoc->lpoaholder, lpAdvSink, lpdwConnection));
}


STDMETHODIMP OleObjUnadvise(LPOLEOBJECT lpOleObj, DWORD dwConnection)
{
    LPDOC    lpdoc;

    DPF("OleObjUnadvise\n");

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    if (lpdoc->lpoaholder == NULL)
        RETURN_RESULT( E_FAIL);

    return( IOleAdviseHolder_Unadvise(lpdoc->lpoaholder, dwConnection));
}


STDMETHODIMP OleObjEnumAdvise(LPOLEOBJECT lpOleObj, LPENUMSTATDATA FAR* lplpenumAdvise)
{
    LPDOC    lpdoc;

    DPF("OleObjEnumAdvise\n");

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    if (lpdoc->lpoaholder == NULL)
        RETURN_RESULT( E_FAIL);

    return(IOleAdviseHolder_EnumAdvise(lpdoc->lpoaholder, lplpenumAdvise));
}


STDMETHODIMP OleObjGetMiscStatus
    (LPOLEOBJECT lpOleObj,
    DWORD dwAspect,
    DWORD FAR* pdwStatus)
{
    DPF("OleObjGetMiscStatus\n");

    RETURN_RESULT( OLE_S_USEREG);
}



STDMETHODIMP OleObjSetColorScheme(LPOLEOBJECT lpOleObj, LPLOGPALETTE lpLogPal)
{
    DPF("OleObjSetColorScheme\n");

    return NOERROR;
}

STDMETHODIMP OleObjLockObject(LPOLEOBJECT lpOleObj, BOOL fLock)
{
    LPDOC    lpdoc;

    DPF("OleObjLockObject\n");

    lpdoc = ((struct COleObjectImpl FAR*)lpOleObj)->lpdoc;

    if (fLock)
        lpdoc->cLock++;
    else
    {
        if (!lpdoc->cLock)
            RETURN_RESULT( E_FAIL);

        if (--lpdoc->cLock == 0)
            OleObjClose(lpOleObj, OLECLOSE_SAVEIFDIRTY);

        return NOERROR;
    }

    return NOERROR;
}



/**************************************************************************
*************   IDataObject INTERFACE IMPLEMENTATION.
**************************************************************************/

//Delegate to the common IUnknown implementation.
STDMETHODIMP     DataObjQueryInterface (
LPDATAOBJECT      lpDataObj,       // data object ptr
REFIID            riidReq,        // IID required
LPVOID FAR *      lplpUnk         // pre for returning the interface
)
{
    return( UnkQueryInterface((LPUNKNOWN)lpDataObj, riidReq, lplpUnk));
}


STDMETHODIMP_(ULONG) DataObjAddRef(
LPDATAOBJECT      lpDataObj      // data object ptr
)
{
    return UnkAddRef((LPUNKNOWN) lpDataObj);
}


STDMETHODIMP_(ULONG) DataObjRelease (
LPDATAOBJECT      lpDataObj      // data object ptr
)
{
    LPDOC    lpdoc;

    lpdoc = ((struct CDataObjectImpl FAR*)lpDataObj)->lpdoc;

    return UnkRelease((LPUNKNOWN) lpDataObj);
}


/**************************************************************************
*   DataObjGetData:
*   Provides the data for METAFILE and DIB formats.
**************************************************************************/
STDMETHODIMP    DataObjGetData (
LPDATAOBJECT            lpDataObj,
LPFORMATETC             lpformatetc,
LPSTGMEDIUM             lpMedium
)
{
   LPDOC        lpdoc;

   DPF1("DataObjGetData\n");

   if (lpMedium == NULL) RETURN_RESULT( E_FAIL);

   // null out in case of error
   lpMedium->tymed = TYMED_NULL;
   lpMedium->pUnkForRelease = NULL;
   lpMedium->hGlobal = NULL;

   lpdoc = ((struct CDataObjectImpl FAR*)lpDataObj)->lpdoc;

   VERIFY_LINDEX(lpformatetc->lindex);

   if (lpformatetc->dwAspect == DVASPECT_ICON)
   {
       if (lpformatetc->cfFormat != CF_METAFILEPICT)
           RETURN_RESULT( DATA_E_FORMATETC);
   }
   else
   {
       if (!(lpformatetc->dwAspect & (DVASPECT_CONTENT | DVASPECT_DOCPRINT)))
           RETURN_RESULT( DATA_E_FORMATETC); // we support only these 2 aspects
   }


   if (lpMedium->tymed != TYMED_NULL)
        // all the other formats we only give out in our own global block
       RETURN_RESULT( DATA_E_FORMATETC);

   lpMedium->tymed = TYMED_HGLOBAL;
   if (lpformatetc->cfFormat == CF_METAFILEPICT)
   {
      lpMedium->tymed = TYMED_MFPICT;

      DPF1("Before getmeta\n");
      if (lpformatetc->dwAspect == DVASPECT_ICON)
      lpMedium->hGlobal = GetMPlayerIcon ();
      else
      lpMedium->hGlobal = GetMetafilePict ();
      DPF1("After getmeta\n");

      if (!lpMedium->hGlobal)
      RETURN_RESULT( E_OUTOFMEMORY);

#ifdef DEBUG
      if (__iDebugLevel >= 1)
      {
          /* Useful check to validate what we're passing back to the container.
           */
          if (OpenClipboard(ghwndApp))
          {
              EmptyClipboard();
              SetClipboardData(CF_METAFILEPICT, lpMedium->hGlobal);
              CloseClipboard();
          }
      }
#endif
      return NOERROR;
   }

   if (lpformatetc->cfFormat == CF_DIB)
   {
      lpMedium->tymed = TYMED_HGLOBAL;
      lpMedium->hGlobal = (HANDLE)GetDib();
      if (!(lpMedium->hGlobal))
     RETURN_RESULT( E_OUTOFMEMORY);

#ifdef DEBUG
      if (__iDebugLevel >= 1)
      {
          /* Useful check to validate what we're passing back to the container.
           */
          if (OpenClipboard(ghwndApp))
          {
              EmptyClipboard();
              SetClipboardData(CF_DIB, lpMedium->hGlobal);
              CloseClipboard();
          }
      }
#endif
      return NOERROR;
   }
   RETURN_RESULT( DATA_E_FORMATETC);
}



STDMETHODIMP    DataObjGetDataHere (
LPDATAOBJECT            lpDataObj,
LPFORMATETC             lpformatetc,
LPSTGMEDIUM             lpMedium
)
{
    RETURN_RESULT( E_NOTIMPL);
}



STDMETHODIMP    DataObjQueryGetData (
LPDATAOBJECT            lpDataObj,
LPFORMATETC             lpformatetc
)
{ // this is only a query
    if ((lpformatetc->cfFormat == CF_METAFILEPICT) &&
        (lpformatetc->tymed & TYMED_MFPICT))
        return NOERROR;
    if ((lpformatetc->cfFormat == CF_DIB) &&
        (lpformatetc->tymed & TYMED_HGLOBAL))
        return NOERROR;
    RETURN_RESULT( DATA_E_FORMATETC);
}



STDMETHODIMP        DataObjGetCanonicalFormatEtc(
LPDATAOBJECT            lpDataObj,
LPFORMATETC             lpformatetc,
LPFORMATETC             lpformatetcOut
)
{
    RETURN_RESULT(DATA_S_SAMEFORMATETC);
}


STDMETHODIMP DataObjEnumFormatEtc(
LPDATAOBJECT            lpDataObj,
DWORD                   dwDirection,
LPENUMFORMATETC FAR*    lplpenumFormatEtc
)
{
    *lplpenumFormatEtc = NULL;
    RETURN_RESULT( OLE_S_USEREG);
}


STDMETHODIMP DataObjAdvise(LPDATAOBJECT lpDataObject,
                FORMATETC FAR* pFormatetc, DWORD advf,
                IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection)
{
    LPDOC    lpdoc;

    lpdoc = ((struct CDataObjectImpl FAR*)lpDataObject)->lpdoc;

    VERIFY_LINDEX(pFormatetc->lindex);
    if (pFormatetc->cfFormat == 0 && pFormatetc->dwAspect == -1 &&
        pFormatetc->ptd == NULL && pFormatetc->tymed == -1)
        // wild card advise; don't check
        ;
    else

    if (DataObjQueryGetData(lpDataObject, pFormatetc) != S_OK)
        RETURN_RESULT( DATA_E_FORMATETC);

    if (lpdoc->lpdaholder == NULL &&
        CreateDataAdviseHolder(&lpdoc->lpdaholder) != S_OK)
        RETURN_RESULT( E_OUTOFMEMORY);

    return( IDataAdviseHolder_Advise(lpdoc->lpdaholder, lpDataObject,
            pFormatetc, advf, pAdvSink, pdwConnection));
}




STDMETHODIMP DataObjUnadvise(LPDATAOBJECT lpDataObject, DWORD dwConnection)
{
    LPDOC    lpdoc;

    lpdoc = ((struct CDataObjectImpl FAR*)lpDataObject)->lpdoc;

    if (lpdoc->lpdaholder == NULL)
        // no one registered
        RETURN_RESULT( E_INVALIDARG);

    return( IDataAdviseHolder_Unadvise(lpdoc->lpdaholder, dwConnection));
}

STDMETHODIMP DataObjEnumAdvise(LPDATAOBJECT lpDataObject,
                LPENUMSTATDATA FAR* ppenumAdvise)
{
    LPDOC    lpdoc;

    lpdoc = ((struct CDataObjectImpl FAR*)lpDataObject)->lpdoc;

    if (lpdoc->lpdaholder == NULL)
        RETURN_RESULT( E_FAIL);

    return( IDataAdviseHolder_EnumAdvise(lpdoc->lpdaholder, ppenumAdvise));
}


/**************************************************************************
*   DataObjSetData:
*   This should never be called.!! The data is actually fed through
*   IPersistStorage.
**************************************************************************/
STDMETHODIMP        DataObjSetData (
LPDATAOBJECT            lpDataObj,
LPFORMATETC             lpformatetc,
LPSTGMEDIUM             lpmedium,
BOOL                    fRelease
)
{
    LPVOID lpMem;
    LPSTR  lpnative;
    LPDOC lpdoc = ((struct CDataObjectImpl FAR *)lpDataObj)->lpdoc;
DPF1("*DOSETDATA");

    if(lpformatetc->cfFormat !=cfNative)
        RETURN_RESULT(DATA_E_FORMATETC);

    lpMem = GLOBALLOCK(lpmedium->hGlobal);


    if (lpMem)
    {
        SCODE scode;

        lpnative = lpMem;

        scode = ItemSetData((LPBYTE)lpnative);

        if(scode == S_OK)
            fDocChanged = FALSE;

        GLOBALUNLOCK(lpmedium->hGlobal);

        RETURN_RESULT(scode);
    }

    RETURN_RESULT(E_OUTOFMEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\mplayer.h ===
/*-----------------------------------------------------------------------------+
| MPLAYER.H                                                                    |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/
#if (DBG || defined(DEBUG_RETAIL))
#ifndef DEBUG
#define DEBUG
#endif
#endif

#include <stdlib.h> // Make sure _MAX_PATH is defined if it's there
#include <malloc.h>

#include "dynalink.h"
#include "menuids.h"
#include "helpids.h"
#include "mci.h"
#include "unicode.h"
#include "alloc.h"


#ifndef CHICAGO_PRODUCT
#ifndef RC_INVOKED
#include <winuserp.h>
#endif
#endif
#include <commctrl.h>
#define TBM_SHOWTICS    (WM_USER+30)

/* Dialog style on Win4+
 */
#ifndef DS_CONTEXTHELP
#define DS_CONTEXTHELP 0
#endif

/* These macros were originally defined for 16-32 portability.
 * The code is now expected to build for Win32 only.
 */
#define LONG2POINT(l, pt)               ((pt).x = (SHORT)LOWORD(l), (pt).y = (SHORT)HIWORD(l))
#define GETWINDOWUINT(hwnd, index)      (UINT)GetWindowLongPtr(hwnd, index)
#define GETWINDOWID(hwnd)               GETWINDOWUINT((hwnd), GWL_ID)
#define GETHWNDINSTANCE(hwnd)           (HINSTANCE)GetWindowLongPtr((hwnd), GWLP_HINSTANCE)
#define SETWINDOWUINT(hwnd, index, ui)  (UINT)SetWindowLongPtr(hwnd, index, (LONG_PTR)(ui))
#define MMoveTo(hdc, x, y)               MoveToEx(hdc, x, y, NULL)
#define MSetViewportExt(hdc, x, y)       SetViewportExtEx(hdc, x, y, NULL)
#define MSetViewportOrg(hdc, x, y)       SetViewportOrgEx(hdc, x, y, NULL)
#define MSetWindowExt(hdc, x, y)         SetWindowExtEx(hdc, x, y, NULL)
#define MSetWindowOrg(hdc, x, y)         SetWindowOrgEx(hdc, x, y, NULL)
#define MGetCurrentTask                  (HANDLE)ULongToPtr(GetCurrentThreadId())
#define _EXPORT
BOOL WINAPI   MGetTextExtent(HDC hdc, LPSTR lpstr, INT cnt, INT *pcx, INT *pcy);


#ifndef RC_INVOKED
#pragma warning(disable: 4001)  // nonstandard extension 'single line comment' was used
#pragma warning(disable: 4201)  // nonstandard extension used : nameless struct/union
#pragma warning(disable: 4214)  // nonstandard extension used : bit field types other than int
#pragma warning(disable: 4103)  // used #pragma pack to change alignment (on Chicago)
#endif

#ifdef OLE1_HACK
/* Disgusting OLE1 hackery:
 */
void Ole1UpdateObject(void);
extern DWORD gDocVersion;
#define DOC_VERSION_NONE    0
#define DOC_VERSION_OLE1    1
#define DOC_VERSION_OLE2    2

VOID SetDocVersion( DWORD DocVersion );

#endif /* OLE1_HACK */

//
//  have the debug version show preview.
//
extern BOOL    gfShowPreview;


#define DEF_WIDTH       ((GetACP()==932)?600:400)

#define DEF_HEIGHT      124

#define CAPTION_LEN     80        // max length of caption

/* BOGUS constants for Layout() */
#define FSARROW_WIDTH            20        // width of one arrow bitmap for SB
#define FSARROW_HEIGHT           17        // height
#define FSTRACK_HEIGHT           30        // height of the scrollbar
#define LARGE_CONTROL_WIDTH     172        // Width of full transport toolbar
#define SMALL_CONTROL_WIDTH      73        // width with only 3 buttons

#define SB_XPOS                   4        // how far in to put scrollbar
#define SHOW_MARK_WIDTH         363        // when to drop mark buttons
#define MAP_HEIGHT               14        // height of trackmap window
#define FULL_TOOLBAR_WIDTH      307        // when to drop last 4 transport btns
#define MARK_WIDTH               52        // width of mark button toolbar
#define MAX_NORMAL_HEIGHT        73        // max size for non-windowed device
#define MIN_NORMAL_HEIGHT        27        // min size for anybody

#ifndef _MAX_PATH
#define _MAX_PATH    144        /* max. length of full pathname */
#endif

#define TOOLBAR_HEIGHT      27
#define BUTTONWIDTH         25
#define BUTTONHEIGHT        23

#define SZCODE TCHAR

/* Strings that MUST be ANSI even if we're compiling Unicode
 * e.g. to pass to GetProcAddress, which is ANSI only:
 */
#define ANSI_SZCODE CHAR
#define ANSI_TEXT( quote )  quote

/* Macro for string replacement parameter in printf etc:
 * (Anyone know of a better way to do this?)
 */
#ifdef UNICODE
#define TS  L"ws"L
#ifdef DEBUG
#define DTS "ws"    /* For unicode args to ASCII API */
#endif
#else
#define TS  "s"
#ifdef DEBUG
#define DTS "s"
#endif
#endif /* UNICODE */


/* defines for set sel dlg box */
#define IDC_EDITALL     220        // these 3 are a group
#define IDC_EDITSOME    221
#define IDC_EDITNONE    222

#define IDC_EDITFROM    223
#define IDC_EDITTO      224
#define IDC_EDITNUM     225

#define IDC_SELECTG     226     /* Needed for Context sensitive help */
#define IDC_ETTEXT      227
#define IDC_ESTEXT      228

#define ARROWEDITDELTA  10      /* Add to arrow ID to get edit ID */

#define IDC_XARROWS     180
#define IDC_YARROWS     181
#define IDC_WARROWS     182
#define IDC_HARROWS     183

#define IDC_FARROWS     183
#define IDC_TARROWS     184
#define IDC_NARROWS     210

/* Controls for Selection range dialog */
#define IDC_MARKIN      150
#define IDC_MARKOUT     151

#define DLG_MCICOMMAND  942
#define IDC_MCICOMMAND  10
#define IDC_RESULT      11

/* Bit fields for the gwOptions */
// bottom two bits = Scale Mode (01 = FRAMES) (10 = TIME) (11 = TRACK)
#define OPT_SCALE       0x0003
#define OPT_TITLE       0x0004
#define OPT_BORDER      0x0008
#define OPT_PLAY        0x0010
#define OPT_BAR         0x0020
#define OPT_DITHER      0x0040
#define OPT_AUTORWD     0x0080
#define OPT_AUTOREP     0x0100
#define OPT_USEPALETTE  0x0200
#define OPT_DEFAULT     (ID_TIME|OPT_TITLE|OPT_BORDER|OPT_PLAY|OPT_BAR)

#define OPT_FIRST       OPT_TITLE
#if 1
#define OPT_LAST        OPT_AUTOREP
#else
#define OPT_LAST        OPT_USEPALETTE
#endif

#define IDC_CAPTIONTEXT 202
#define IDC_OLEOBJECT   203
#define IDC_TITLETEXT   160
#define TITLE_HEIGHT    TOOLBAR_HEIGHT  // height of title bar part of object picture

/* Options used when initial Open dialog is displayed:
 */
#define OPEN_NONE       (UINT)-1
#define OPEN_VFW        0
#define OPEN_MIDI       1
#define OPEN_WAVE       2

#define MCIWND_STYLE WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | \
                     MCIWNDF_NOPLAYBAR | MCIWNDF_NOMENU | MCIWNDF_SHOWNAME | \
                     MCIWNDF_NOTIFYALL

/* Parameters for GetIconForCurrentDevice:
 */
#define GI_LARGE    0
#define GI_SMALL    1


/* For mapping strings to device IDs
 */
typedef struct _STRING_TO_ID_MAP
{
    LPTSTR pString;
    UINT   ID;
}
STRING_TO_ID_MAP, *PSTRING_TO_ID_MAP;


/* global array of all mci devices */

typedef struct {
    UINT    wDeviceType;        // flags, DTMCI_*
    PTSTR   szDevice;           // name used to open device e.g. "WaveAudio"
    PTSTR   szDeviceName;       // name to display to user  e.g. "Wave Audio"
    PTSTR   szFileExt;          // file extensions used by device.
}   MCIDEVICE, *PMCIDEVICE;

#define MAX_MCI_DEVICES     50

extern UINT         gwCurDevice;       /* current device */
extern UINT         gwNumDevices;      /* number of available devices   */
extern MCIDEVICE    garMciDevices[];   /* array with info about a device */

/* global variables */
extern DWORD   gwPlatformId;           // Win95, NT etc
extern BOOL    gfEmbeddedObject;       // TRUE if editing embedded OLE object
extern BOOL    gfPlayingInPlace;       // TRUE if playing in place
extern BOOL    gfParentWasEnabled;     // TRUE if parent was enabled
extern BOOL    gfShowWhilePlaying;     //
extern BOOL    gfDirty;                //
extern int     gfErrorBox;             // TRUE if we have a message box active
extern BOOL    gfErrorDeath;           // Die when errorbox is up

extern BOOL gfOleInitialized;
extern BOOL gfOle2Open;
extern BOOL gfOle2IPEditing;
extern BOOL gfOle2IPPlaying;
extern RECT gInPlacePosRect;
extern HWND ghwndCntr;
extern HWND ghwndIPToolWindow;
extern HWND ghwndIPScrollWindow;

extern LPWSTR sz1Ole10Native;

extern UINT         gwOptions;         /* play options */
extern UINT         gwOpenOption;      /* Type of file to open */
extern BOOL         gfOpenDialog;      // If TRUE, put up open dialog
extern BOOL         gfCloseAfterPlaying;  // TRUE if we are to hide after play
extern BOOL         gfRunWithEmbeddingFlag; // TRUE if run with "-Embedding"
extern HMENU        ghMenu;            /* normal menu */
extern HICON        hiconApp;          /* the applicaiion's icon */
extern HANDLE       ghInst;            /* the application's instance handle   */
extern DWORD        gfdwFlagsEx;       /* the application's RTL status        */
extern HANDLE       ghInstPrev;        /* the application's instance handle   */
extern HFONT        ghfontMap;         /* font used for drawing the track map */
extern HWND         ghwndApp;          /* handle to the main dialog window    */
extern HWND         ghwndMap;          /* handle to the track map window      */
extern HWND         ghwndTrackbar;     /* handle to the horizontal track bar  */
extern HWND         ghwndToolbar;      /* handle to the toolbar               */
extern HWND         ghwndMark;         /* handle to the Mark buttons toolbar  */
extern HWND         ghwndFSArrows;     /* handle to the scrollbar arrows      */
extern HWND         ghwndStatic;       /* handle ot the static text window    */
extern HWND         ghwndMCI;          /* MCI window returned from MCIWndCreate */
extern HBRUSH       ghbrFillPat;       /* The selection fill pattern.         */
extern UINT         gwHeightAdjust;    /* Difference between client & non-c height */
extern LPTSTR       gszCmdLine;        /* null-terminated command line str.   */
extern int          giCmdShow;         /* show command                        */
extern UINT         gwDeviceID;        /* current MCI device ID (or NULL)     */
extern UINT         gwStatus;          /* status of current MCI device        */
extern UINT         gwNumTracks;       /* current # of tracks in the medium   */
extern UINT         gwFirstTrack;      /* number of first track                      */
extern BOOL         gfValidMediaInfo;  /* are we displaying valid media info? */
extern BOOL         gfValidCaption;    /* are we displaying a valid caption?  */
extern BOOL         gfPlayOnly;        /* play only window?  */
extern BOOL         gfJustPlayed;      /* Just sent a PlayMCI() command       */
extern DWORD        gdwLastSeekToPosition; /* Last requested seek position    */
extern DWORD        gdwMediaLength;    /* length of entire medium in msec.    */
extern DWORD        gdwMediaStart;     /* start of medium in msec.              */
extern DWORD NEAR * gadwTrackStart;    /* array of track start positions      */
extern UINT         gwOptions;               /* the options from the dlg box        */
extern SZCODE       aszIntl[];         /* string for international section */
extern TCHAR        gachAppName[];     /* string for holding the app. name  */
extern TCHAR        gachClassRoot[];   /* string for holding the class root OLE "Media Clip"*/
extern TCHAR        chDecimal;         /* Stores current decimal separator */
extern TCHAR        chTime;            /* Stores the current Time separator */
extern TCHAR        chLzero;           /* Stores if Leading Zero required for decimal numbers less than 1 */
extern TCHAR        aszNotReadyFormat[];
extern TCHAR        aszReadyFormat[];
extern TCHAR        gachFileDevice[_MAX_PATH];  /* string holding the current file or device name */
extern TCHAR        gachWindowTitle[_MAX_PATH]; /* string holding name */
extern TCHAR        gachCaption[_MAX_PATH];     /* string holding name */
extern TCHAR        gachOpenExtension[5];   /* Non-null if a device extension passed in */
extern TCHAR        gachOpenDevice[128];    /* Non-null if a device extension passed in */

extern TCHAR        gszHelpFileName[];/* name of the help file        */
extern TCHAR        gszHtmlHelpFileName[];/* name of the html help file */

extern DWORD        gdwSeekPosition;  /* Position to seek to after skipping track. */
extern BOOL         gfScrollTrack;    /* is user dragging the scrollbar thumb?  */
extern UINT         gwCurScale;       /* scale is TIME/TRACKS/FRAMES */
extern INT          gwCurZoom;        /* current zoom factor */

extern HWND         ghwndMCI;         /* current window for window objects */
extern RECT         grcSize;          /* size of MCI object */
extern BOOL         gfAppActive;      /* Our app active? (incl. playback win) */
extern LONG         glSelStart;       /* See if selection changes (dirty object)*/
extern LONG         glSelEnd;         /* See if selection changes (dirty object)*/

extern HPALETTE     ghpalApp;
extern BOOL     gfInClose;
extern BOOL     gfCurrentCDNotAudio;  /* TRUE when we have a CD that we can't play */
extern BOOL     gfWinIniChange;

extern DWORD        gdwPosition;      /* The Seek position we emedded */
extern BOOL         gfSeenPBCloseMsg;
extern int      giHelpContext;    /* Contains the context id for help */

extern HANDLE   heventDeviceMenuBuilt;/* Event will be signaled when device menu complete */
extern HANDLE   heventCmdLineScanned; /* Event will be signaled when command line scanned */

// strings for registration database
extern SZCODE aszKeyMID[];
extern SZCODE aszKeyRMI[];
extern SZCODE aszKeyAVI[];
extern SZCODE aszKeyMMM[];
extern SZCODE aszKeyWAV[];

extern SZCODE szCDAudio[];
extern SZCODE szVideoDisc[];
extern SZCODE szSequencer[];
extern SZCODE szVCR[];
extern SZCODE szWaveAudio[];
extern SZCODE szAVIVideo[];

/* constants */

#define DEVNAME_MAXLEN            40               /* the maximum length of a device name */

/* IDs of icons and dialog boxes */

#define APPICON                 10     /* ID of the application's icon        */
#define	IDI_DDEFAULT    11
#define	IDI_DSOUND		12
#define	IDI_DVIDEO		13
#define	IDI_DANI		14
#define	IDI_DMIDI		15
#define	IDI_DCDA		16
#define IDC_DRAG                17


#define MPLAYERBOX              11     /* ID of the main "MPlayer" dialog box */
#define MPLAYERACCEL             1

/* IDs of the MPLAYERBOX (main dialog box) controls */

#define ID_MAP                  20     /* ID of thetrack map                  */
#define ID_SB                   21     /* ID of the horizontal scrollbar      */
#define ID_STATIC               22     /* ID of the static text control       */
#define ID_PLAY                 23     /* Command   'Play'                    */
#define ID_PAUSE                24     /* Command   'Pause'                   */
#define ID_STOP                 25     /* Command   'Stop'                    */
#define ID_PLAYSEL              26     /* Command   'Play Selection'          */
#define ID_PLAYTOGGLE           27     /* For accelerator to toggle play/pause*/
#define ID_EJECT                28     /* Command   'Eject'                   */
#define ID_ESCAPE               29     /* Escape key was hit                  */

/* IDs of the string resources */

#define IDS_APPNAME             100    /* ID of the application name string   */
#define IDS_OPENTITLE           101    /* ID of the "Open Media File" str.    */
#define IDS_OUTOFMEMORY         102    /* ID of the "Out of memory" string    */
#define IDS_CANTOPENFILEDEV     103    /* ID of the "Cannot open file/dev" str*/
#define IDS_DEVICEINUSE         104    /* ID of the "Device is in use" string */
#define IDS_CANTOPENFILE        105    /* ID of the "Cannot open file" string */
#define IDS_CANTACCESSFILEDEV   106    /* ID of the "Cannot access..." str.   */
#define IDS_DEVICECANNOTPLAY    107    /* ID of the "Cannot play..." str.     */
#define IDS_SCALE               108    /* ID of the "Scale" string            */
#define IDS_CANTPLAY            109
#define IDS_CANTEDIT            110
#define IDS_CANTCOPY            111
#define IDS_FINDFILE            112
#define IDS_DEVICENOTINSTALLED  113
#define IDS_DEVICEERROR         114    /* ID of the "Device error" str.              */
#define IDS_CANTPLAYSOUND       115
#define IDS_CANTPLAYVIDEO       116
#define IDS_CANTPLAYMIDI        117
#define IDS_NOTSOUNDFILE        118
#define IDS_NOTVIDEOFILE        119
#define IDS_NOTMIDIFILE         120

#define IDS_TIMEMODE            121    /* Moved "Set Selection" strings from  */
#define IDS_FRAMEMODE           122    /* being embedded in DLGS.C !          */
#define IDS_TRACKMODE           123

#define IDS_SEC         124 /* "hrs", "min", "sec" and "msec" string ids. */
#define IDS_MIN         125
#define IDS_HRS         126
#define IDS_MSEC        127
#define IDS_FRAME       128 /* "frame" string id.               */

#define IDS_UPDATEOBJECT        129

#define IDS_NOTREADYFORMAT      132
#define IDS_READYFORMAT         133
#define IDS_DEVICEMENUCOMPOUNDFORMAT 134
#define IDS_DEVICEMENUSIMPLEFORMAT   135
#define IDS_ALLFILES            136
#define IDS_ANYDEVICE           137
#define IDS_CLASSROOT           138
#define IDS_NOGOODTIMEFORMATS   139

#define IDS_FRAMERANGE          140
#define IDS_INIFILE             141    /* ID of the private INI file name     */
#define IDS_HELPFILE            142    /* ID of help file name     */
#define IDS_HTMLHELPFILE        147    /* ID of HTML help file */

#define IDS_NOMCIDEVICES        143    /* no MCI devices are installed.  */
#define IDS_PLAYVERB            144
#define IDS_EDITVERB            145
#define IDS_CANTSTARTOLE        146

#define IDS_UNTITLED            149

#define IDS_CANTLOADLIB         151
#define IDS_CANTFINDPROC        152

#define IDS_MPLAYERWIDTH        200

#define IDS_CANTACCESSFILE		250

/* These macros and typedefs can be used to clarify whether we're talking about
 * numbers of characters or numbers of bytes in a given buffer.
 * Unfortunately C doesn't give us type checking to do this properly.
 */
#define BYTE_COUNT( buf )   sizeof(buf)
#define CHAR_COUNT( buf )   (sizeof(buf) / sizeof(TCHAR))

/* Find how many bytes are in a given string:
 */
#define STRING_BYTE_COUNT( str )    (STRLEN(str) * sizeof(TCHAR) + sizeof(TCHAR))
#define ANSI_STRING_BYTE_COUNT( str )   (strlen(str) * sizeof(CHAR) + sizeof(CHAR))

/* Check the length of a string or number of bytes where NULL is a valid
 * pointer which should give a length of 0:
 */
#define STRLEN_NULLOK( str )    ((str) ? STRLEN(str) : 0)
#define STRING_BYTE_COUNT_NULLOK( str ) ((str) ? STRING_BYTE_COUNT(str) : 0)

/* Use this macro for loading strings.  It make the parameter list tidier
 * and ensures we pass the buffer size in CHARACTERS, not bytes.
 * This assumes that the buffer is static, not dynamically allocated.
 */
#define LOADSTRING( id, buf )   LoadString(ghInst, (UINT)id, buf, CHAR_COUNT(buf))
#define LOADSTRINGFROM( inst, id, buf )   LoadString(inst, id, buf, CHAR_COUNT(buf))

/* track map scale values */

#define SCALE_HOURS             153    /* draw the scale in hours          */
#define SCALE_MINUTES           154    /* draw the scale in minutes        */
#define SCALE_SECONDS           155    /* draw the scale in seconds        */
#define SCALE_MSEC              156    /* draw it in milli vanilliseconds  */
#define SCALE_FRAMES            157    /* draw scale in 'frames'           */
#define SCALE_TRACKS            158
#define SCALE_NOTRACKS          159

#define IDS_CLOSE               160
#define IDS_UPDATE              161
#define IDS_NOPICTURE           162
#define IDS_EXIT                163
#define IDS_EXITRETURN          164

#define IDS_SSNOTREADY      170
#define IDS_SSPAUSED        171
#define IDS_SSPLAYING       172
#define IDS_SSSTOPPED       173
#define IDS_SSOPEN      174
#define IDS_SSPARKED        175
#define IDS_SSRECORDING     176
#define IDS_SSSEEKING       177
#define IDS_SSUNKNOWN       178

#define IDS_OLEVER      180
#define IDS_OLEINIT     181
#define IDS_OLENOMEM        182

//InPlace menu names.
#define IDS_EDITMENU        185
#define IDS_INSERTMENU      186
#define IDS_SCALEMENU       187
#define IDS_COMMANDMENU     188
#define IDS_HELPMENU        189
#define IDS_NONE                190

#define IDS_MSGFORMAT		191
#define IDS_FORMATEMBEDDEDTITLE 192
#define IDS_IS_RTL              193

// String for registry fix-up message
#define IDS_BADREG          195
#define IDS_FIXREGERROR     196

#define IDS_NETWORKERROR        197
#define IDS_UNKNOWNNETWORKERROR 198

#define IDS_INSERTAUDIODISC     199

/* macros for displaying error messages */

#define MB_ERROR    (MB_ICONEXCLAMATION | MB_OK)
#define Error(hwnd, idsFmt)                                               \
    ( ErrorResBox(hwnd, ghInst, MB_ERROR, IDS_APPNAME, (idsFmt)), FALSE )
#define Error1(hwnd, idsFmt, arg1)                                        \
    ( ErrorResBox(hwnd, ghInst, MB_ERROR, IDS_APPNAME, (idsFmt), (arg1)), \
        FALSE )
#define Error2(hwnd, idsFmt, arg1, arg2)                                  \
    ( ErrorResBox(hwnd, ghInst, MB_ERROR, IDS_APPNAME,  (idsFmt), (arg1), \
        (arg2)), FALSE )


/* app tabbing code */
BOOL IsDannyDialogMessage(HWND hwndApp, MSG msg);

/* calc where the tics belong on the scrollbar */
void FAR PASCAL CalcTicsOfDoom(void);

/* Layout the main window and the children */
void FAR PASCAL Layout(void);

/* prototypes from "errorbox.c" */
short FAR cdecl ErrorResBox(HWND hwnd, HANDLE hInst, UINT flags,
        UINT idAppName, UINT idErrorStr, ...);

/* function prototypes from "framebox.c" */
BOOL FAR PASCAL frameboxInit(HANDLE hInst, HANDLE hPrev);
/* function prototypes from "dlgs.c" */
BOOL FAR PASCAL mciDialog(HWND hwnd);
BOOL FAR PASCAL setselDialog(HWND hwnd);
BOOL FAR PASCAL optionsDialog(HWND hwnd);
/* function prototypes from "arrow.c" */
BOOL FAR PASCAL ArrowInit(HANDLE hInst);

/* function prototypes from "mplayer.c" */
void FAR PASCAL FormatTime(DWORD_PTR dwPosition, LPTSTR szNum, LPTSTR szBuf, BOOL fRound);
void FAR PASCAL UpdateDisplay(void);
void FAR PASCAL EnableTimer(BOOL fEnable);
LRESULT FAR PASCAL MPlayerWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
HICON GetIconForCurrentDevice(UINT Size, UINT DefaultID);
void SetMPlayerIcon(void);

/* function prototypes from "init.c" */
BOOL FAR PASCAL AppInit(HANDLE hInst, HANDLE hPrev, LPTSTR szCmdLine);
void FAR PASCAL InitMPlayerDialog(HWND hwnd);
BOOL FAR PASCAL GetIntlSpecs(void);

void FAR PASCAL SmartWindowPosition (HWND hWndDlg, HWND hWndShow, BOOL fForce);

void FAR PASCAL SizeMPlayer(void);
void FAR PASCAL SetMPlayerSize(LPRECT prc);

void FAR PASCAL InitDeviceMenu(void);
void WaitForDeviceMenu(void);

VOID FAR PASCAL CompleteOpenDialog(BOOL FileSelected);

/* function prototypes from "open.c" */

INT_PTR FAR PASCAL DoOpen(UINT wCurDevice, LPTSTR SzFileName);
BOOL FAR PASCAL DoChooseDevice(UINT wID);
void FAR PASCAL CheckDeviceMenu(void);
BOOL FAR PASCAL OpenMciDevice(LPCTSTR szFile, LPCTSTR szDevice);
UINT FAR PASCAL IsMCIDevice(LPCTSTR szDevice);

/* function prototype from "trackmap.c" */

LRESULT FAR PASCAL fnMPlayerTrackMap(HWND hwnd, UINT wMsg, WPARAM wParam,
    LPARAM lParam);

/* function prototype from init.c */
void FAR PASCAL WriteOutPosition(void);
void FAR PASCAL WriteOutOptions(void);
void FAR PASCAL ReadOptions(void);

void MapStatusString(LPTSTR lpstatusstr);

/* function prototype from "math.asm", if needed */

#define MULDIV32( number, numerator, denominator )  \
    MulDiv( (int)number, (int)numerator, (int)denominator )

/* function prototype from "doverb.c" */
LPTSTR FAR FileName(LPCTSTR);

/* constants */

#define WM_USER_DESTROY     (WM_USER+120)
#define WM_SEND_OLE_CHANGE  (WM_USER+122)
#define WM_STARTTRACK       (WM_USER+123)
#define WM_ENDTRACK         (WM_USER+124)
#define WM_BADREG           (WM_USER+125)
#define WM_DOLAYOUT         (WM_USER+126)
#define WM_GETDIB           (WM_USER+127)
#define WM_NOMCIDEVICES     (WM_USER+128)


/* constants */

#define SCROLL_GRANULARITY  ((gdwMediaLength+127)/128) /* granularity of the scrollbar  */
#define SCROLL_BIGGRAN      ((gdwMediaLength+15)/16)   /* gran. for page up/down in time mode */
#define UPDATE_TIMER        1                /* # of the timer being used     */
#define UPDATE_MSEC         500              /* msec between display updates  */
#define UPDATE_INACTIVE_MSEC 2000             /* msec betw. upds. when inactive*/
#define SKIPTRACKDELAY_MSEC 3000             /* max msec for double-page-left */

#define SetDlgFocus(hwnd) SendMessage(ghwndApp, WM_NEXTDLGCTL, (WPARAM)(hwnd), 1L)

#ifdef DEBUG
        #define STATICDT
        #define STATICFN
        int __iDebugLevel;

        extern void cdecl dprintf(LPSTR, ...);

        #define DPF0                         dprintf
        #define DPF  if (__iDebugLevel >  0) dprintf
        #define DPFI if (__iDebugLevel >= 1) dprintf
        #define DPF1 if (__iDebugLevel >= 1) dprintf
        #define DPF2 if (__iDebugLevel >= 2) dprintf
        #define DPF3 if (__iDebugLevel >= 3) dprintf
        #define DPF4 if (__iDebugLevel >= 4) dprintf
        #define CPF
#else
        #define STATICDT    static
        #define STATICFN    static
        #define DPF0       ; / ## /
        #define DPFI       ; / ## /
        #define DPF        ; / ## /
        #define DPF1        ; / ## /
        #define DPF2        ; / ## /
        #define DPF3        ; / ## /
        #define DPF4        ; / ## /

        #define CPF          / ## /
#endif

#ifdef DEBUG
LPVOID DbgGlobalLock(HGLOBAL hglbMem);
BOOL DbgGlobalUnlock(HGLOBAL hglbMem);
HGLOBAL DbgGlobalFree(HGLOBAL hglbMem);
#define GLOBALLOCK(hglbMem)     DbgGlobalLock(hglbMem)
#define GLOBALUNLOCK(hglbMem)   DbgGlobalUnlock(hglbMem);
#define GLOBALFREE(hglbMem)     DbgGlobalFree(hglbMem)
#else
#define GLOBALLOCK(hglbMem)     GlobalLock(hglbMem)
#define GLOBALUNLOCK(hglbMem)   GlobalUnlock(hglbMem);
#define GLOBALFREE(hglbMem)     GlobalFree(hglbMem)
#endif

/*----Constants--------------------------------------------------------------*/
    /* Push buttons */
#define psh15       0x040e
#define pshHelp     psh15
    /* Checkboxes */
#define chx1        0x0410
    /* Static text */
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
    /* Edit controls */
#define edt1        0x0480


/**************************************************************************
***************************************************************************/

#define GetWS(hwnd)     GetWindowLongPtr(hwnd, GWL_STYLE)
#define PutWS(hwnd, f)  SetWindowLongPtr(hwnd, GWL_STYLE, f)
#define TestWS(hwnd,f)  (GetWS(hwnd) & f)
#define SetWS(hwnd, f)  ((PutWS(hwnd, GetWS(hwnd) | f) & (f)) != (f))
#define ClrWS(hwnd, f)  ((PutWS(hwnd, GetWS(hwnd) & ~(f)) & (f)) != 0)

#define GetWSEx(hwnd)    GetWindowLongPtr(hwnd, GWL_EXSTYLE)
#define PutWSEx(hwnd, f) SetWindowLongPtr(hwnd, GWL_EXSTYLE, f)
#define SetWSEx(hwnd, f) ((PutWSEx(hwnd, GetWSEx(hwnd) | f) & (f)) != (f))
#define ClrWSEx(hwnd, f) ((PutWSEx(hwnd, GetWSEx(hwnd) & ~(f)) & (f)) != 0)

// server related stuff.

void FAR PASCAL ServerUnblock(void);
void FAR PASCAL BlockServer(void);
void FAR PASCAL UnblockServer(void);
void FAR PASCAL PlayInPlace(HWND hwndApp, HWND hwndClient, LPRECT prc);
void FAR PASCAL EditInPlace(HWND hwndApp, HWND hwndClient, LPRECT prc);
void FAR PASCAL EndPlayInPlace(HWND hwndApp);
void FAR PASCAL EndEditInPlace(HWND hwndApp);
void FAR PASCAL DelayedFixLink(UINT verb, BOOL fShow, BOOL fActivate);
void DirtyObject(BOOL fDocStgChangeOnly);
void CleanObject(void);
void UpdateObject(void);
BOOL FAR PASCAL IsObjectDirty(void);
void FAR PASCAL TerminateServer(void);
void FAR PASCAL SetEmbeddedObjectFlag(BOOL flag);
HMENU GetInPlaceMenu(void);
void PostCloseMessage();
void FAR PASCAL InitDoc(BOOL fUntitled);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\objfdbk.c ===
/*
 * OBJFDBK.C
 *
 * Miscellaneous API's to generate UI feedback effects for OLE objects. This
 * is part of the OLE 2.0 User Interface Support Library.
 * The following feedback effects are supported:
 *      1. Object selection handles (OleUIDrawHandles)
 *      2. Open Object window shading (OleUIDrawShading)
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#define STRICT  1
#include <windows.h>
#ifdef MTN
#pragma warning(disable: 4103)  // used #pragma pack to change alignment (on Chicago)
#endif
#include <ole2.h>
#include "ole2ui.h"

static void DrawHandle(HDC hdc, int x, int y, UINT cSize, BOOL bInvert, BOOL fDraw);

/*
 * OleUIDrawHandles
 *
 * Purpose:
 *  Draw handles or/and boundary around Container Object when selected
 *
 * Parameters:
 *  lpRect      Dimensions of Container Object
 *  hdc         HDC of Container Object (MM_TEXT mapping mode)
 *  dwFlags-
 *      Exclusive flags
 *          OLEUI_HANDLES_INSIDE    Draw handles on inside of rect
 *          OLEUI_HANDLES_OUTSIDE   Draw handles on outside of rect
 *      Optional flags
 *          OLEUI_HANDLES_NOBORDER  Draw handles only, no rect
 *          OLEUI_HANDLES_USEINVERSE
 *              use invert for handles and rect, o.t. use COLOR_WINDOWTEXT
 *  cSize       size of handle box
 *  fDraw       Draw if TRUE, erase if FALSE
 *
 * Return Value: null
 *
 */
STDAPI_(void) OleUIDrawHandles(
    LPRECT  lpRect,
    HDC     hdc,
    DWORD   dwFlags,
    UINT    cSize,
    BOOL    fDraw
)
{
    HBRUSH  hbr;
    RECT    rc;
    int     bkmodeOld;
    BOOL    bInvert = (BOOL) (dwFlags & OLEUI_HANDLES_USEINVERSE);

    CopyRect((LPRECT)&rc, lpRect);

    bkmodeOld = SetBkMode(hdc, TRANSPARENT);

    if (dwFlags & OLEUI_HANDLES_OUTSIDE)
        InflateRect((LPRECT)&rc, cSize - 1, cSize - 1);

    // Draw the handles inside the rectangle boundary
    DrawHandle(hdc, rc.left, rc.top, cSize, bInvert, fDraw);
    DrawHandle(hdc, rc.left, rc.top+(rc.bottom-rc.top-cSize)/2, cSize, bInvert, fDraw);
    DrawHandle(hdc, rc.left, rc.bottom-cSize, cSize, bInvert, fDraw);
    DrawHandle(hdc, rc.left+(rc.right-rc.left-cSize)/2, rc.top, cSize, bInvert, fDraw);
    DrawHandle(hdc, rc.left+(rc.right-rc.left-cSize)/2, rc.bottom-cSize, cSize, bInvert, fDraw);
    DrawHandle(hdc, rc.right-cSize, rc.top, cSize, bInvert, fDraw);
    DrawHandle(hdc, rc.right-cSize, rc.top+(rc.bottom-rc.top-cSize)/2, cSize, bInvert, fDraw);
    DrawHandle(hdc, rc.right-cSize, rc.bottom-cSize, cSize, bInvert, fDraw);

    if (!(dwFlags & OLEUI_HANDLES_NOBORDER)) {
        if (fDraw)
            hbr = GetStockObject(BLACK_BRUSH);
        else
            hbr = GetStockObject(WHITE_BRUSH);

        if (hbr)
            FrameRect(hdc, lpRect, hbr);
    }

    SetBkMode(hdc, bkmodeOld);
}



/*
 * DrawHandle
 *
 * Purpose:
 *  Draw a handle box at the specified coordinate
 *
 * Parameters:
 *  hdc         HDC to be drawn into
 *  x, y        upper left corner coordinate of the handle box
 *  cSize       size of handle box
 *  bInvert     use InvertRect() if TRUE, otherwise use Rectangle()
 *  fDraw       Draw if TRUE, erase if FALSE, ignored if bInvert is TRUE
 *
 * Return Value: null
 *
 */
static void DrawHandle(HDC hdc, int x, int y, UINT cSize, BOOL bInvert, BOOL fDraw)
{
    HBRUSH  hbr;
    HBRUSH  hbrOld;
    HPEN    hpen;
    HPEN    hpenOld;
    RECT    rc;


    if (!bInvert) {
        if (fDraw) {
            hpen = GetStockObject(BLACK_PEN);
            hbr = GetStockObject(BLACK_BRUSH);
        } else {
            hpen = GetStockObject(WHITE_PEN);
            hbr = GetStockObject(WHITE_PEN);
        }

        hpenOld = SelectObject(hdc, hpen);
        hbrOld = SelectObject(hdc, hbr);
        Rectangle(hdc, x, y, x+cSize, y+cSize);
        SelectObject(hdc, hpenOld);
        SelectObject(hdc, hbrOld);
    }
    else {
        rc.left = x;
        rc.top = y;
        rc.right = x + cSize;
        rc.bottom = y + cSize;
        InvertRect(hdc, (LPRECT)&rc);
    }
}


/*
 * OleUIDrawShading
 *
 * Purpose:
 *  Shade the object when it is in in-place editing. Borders are drawn
 *  on the Object rectangle. The right and bottom edge of the rectangle
 *  are excluded in the drawing.
 *
 * Parameters:
 *  lpRect      Dimensions of Container Object
 *  hdc         HDC for drawing
 *  dwFlags-
 *      Exclusive flags
 *          OLEUI_SHADE_FULLRECT    Shade the whole rectangle
 *          OLEUI_SHADE_BORDERIN    Shade cWidth pixels inside rect
 *          OLEUI_SHADE_BORDEROUT   Shade cWidth pixels outside rect
 *      Optional flags
 *          OLEUI_SHADE_USEINVERSE
 *              use PATINVERT instead of the hex value
 *  cWidth      width of border in pixel
 *
 * Return Value: null
 *
 */
STDAPI_(void) OleUIDrawShading(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cWidth)
{
    HBRUSH  hbr;
    HBRUSH  hbrOld;
    HBITMAP hbm;
    RECT    rc;
    WORD    wHatchBmp[] = {0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88};
    COLORREF cvText;
    COLORREF cvBk;

    hbm = CreateBitmap(8, 8, 1, 1, wHatchBmp);
    hbr = CreatePatternBrush(hbm);
    hbrOld = SelectObject(hdc, hbr);

    rc = *lpRect;

    if (dwFlags == OLEUI_SHADE_FULLRECT) {
        cvText = SetTextColor(hdc, RGB(255, 255, 255));
        cvBk = SetBkColor(hdc, RGB(0, 0, 0));
        PatBlt(hdc, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top,
            0x00A000C9L /* DPa */ );

    } else {    // either inside or outside rect

        if (dwFlags == OLEUI_SHADE_BORDEROUT)
            InflateRect((LPRECT)&rc, cWidth - 1, cWidth - 1);

        cvText = SetTextColor(hdc, RGB(255, 255, 255));
        cvBk = SetBkColor(hdc, RGB(0, 0, 0));
        PatBlt(hdc, rc.left, rc.top, rc.right - rc.left,
            cWidth, 0x00A000C9L /* DPa */);
        PatBlt(hdc, rc.left, rc.top, cWidth, rc.bottom - rc.top,
            0x00A000C9L /* DPa */);
        PatBlt(hdc, rc.right - cWidth, rc.top, cWidth,
            rc.bottom - rc.top, 0x00A000C9L /* DPa */);
        PatBlt(hdc, rc.left, rc.bottom - cWidth, rc.right-rc.left,
            cWidth, 0x00A000C9L /* DPa */);
    }

    SetTextColor(hdc, cvText);
    SetBkColor(hdc, cvBk);
    SelectObject(hdc, hbrOld);
    if (hbr)
        DeleteObject(hbr);
    if (hbm)
        DeleteObject(hbm);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\mpole.h ===
/*---------------------------------------------------------------------------
|   MPOLE.H
|   This file is the header file that has most of the OLE2 specific
|   data structures.
|
|   Created By: Vij Rajarajan (VijR)
+---------------------------------------------------------------------------*/
#ifndef COBJMACROS
#define COBJMACROS
#endif
#ifdef MTN
#pragma warning(disable: 4103)  // used #pragma pack to change alignment (on Chicago)
#endif
#include <ole2.h>
#include <ole2ver.h>
#include <shlobj.h> /* For ResolveLink() */
#include "server.h"

#ifdef INCGUID
#include <initguid.h>
#endif

#define _NOHRESULT

#define INPLACE
#define DRAGDROP

#define RETURN_RESULT(sc) return(ResultFromScode(sc))

// number HIMETRIC units per inch
#define  HIMETRIC_PER_INCH  2540

#if (defined(DEBUG) || DBG)
BOOL WriteOLE2Class( );
#endif

/****  'lindex' related macros  ****/

#define DEF_LINDEX              -1

#define VERIFY_LINDEX(lindex) { \
    if (lindex != -1)    \
        return (ResultFromScode(E_INVALIDARG)); \
}

// Used to check for "-Embedding" on command line.
#define szEmbeddingFlag  "Embedding"


// Maximum length of a fully-qualified pathname.
#define cchFilenameMax  256

//OLE2 CLsids
DEFINE_OLEGUID(CLSID_MPlayer,           0x00022601, 0, 0);
#define CLSID_MPLAYER CLSID_MPlayer

//OLE1 clsid.
DEFINE_OLEGUID(CLSID_Ole1MPlayer,           0x0003000E, 0, 0);
#define CLSID_OLE1MPLAYER CLSID_Ole1MPlayer

extern TCHAR        gachProgID[];
extern CLSID        gClsID;
extern CLSID        gClsIDOLE1Compat;   /* This will be MPlayer's OLE1 class ID    */
                                        /* if we're servicing a Media Clip object, */
                                        /* otherwise it's the same as gClsID.      */

// Sizes of toolbar items
#define TOOLBAR_WIDTH           300
#define TOOL_WIDTH              26

/* Types */

// Document type

typedef enum
{
    doctypeNew,      // The document is untitled.
    doctypeFromFile, // The document exists in a file and may be linked.
    doctypeEmbedded, // The document is an embedded document.
} DOCTYPE;

// Verbs

typedef enum
{
   verbPlay = OLEIVERB_PRIMARY,
   verbEdit,
   verbOpen,
   verbNil
} VERB;


// Corresponds to the order of the menus in the .rc file.
enum {
    menuposFile,
    menuposEdit,
    menuposDevice,
    menuposScale,
    menuposHelp
};

#ifdef OLDSTUFF
/* Codes for CallBack events */
/* The first four of these are redefinitions on NT, and the others don't exist: */
typedef enum {
    OLE_CHANGED,            /* 0                                           */
    OLE_SAVED,              /* 1                                           */
    OLE_CLOSED,             /* 2                                           */
    OLE_RENAMED,            /* 3                                           */
    OLE_SAVEOBJ,            /* 4                                           */
    OLE_SIZECHG,            /* 5                                           */
    OLE_SHOWOBJ             /* 6                                           */
} OLE_NOTIFICATION;
#endif

typedef enum
{
    OLE_CHANGED,            /* 0                                             */
    OLE_SAVED,              /* 1                                             */
    OLE_CLOSED,             /* 2                                             */
    OLE_RENAMED,            /* 3                                             */
    OLE_QUERY_PAINT,        /* 4  Interruptible paint support                */
    OLE_RELEASE,            /* 5  Object is released(asynchronous operation  */
                            /*    is completed)                              */
    OLE_QUERY_RETRY        /* 6  Query for retry when server sends busy ACK */
} OLE_NOTIFICATION;
#define OLE_SAVEOBJ 7
#define OLE_SIZECHG 8
#define OLE_SHOWOBJ 9


// Server structure

typedef struct
{
    IClassFactory      olesrvr;        // This must be the first field so that
    BOOL               fEmbedding;     // was server launched for embedding
    int            cRef;           // ref count;
    int            cLock;          // Lock count
    DWORD          dwRegCF;
} SRVR, FAR *LPSRVR;

//InPlace data structure.
typedef struct tagINPLACEDATA {
    OLEMENUGROUPWIDTHS      menuWidths;
    HOLEMENU                holemenu;
    HMENU                   hmenuShared;
    LPOLEINPLACESITE        lpSite;
    LPOLEINPLACEUIWINDOW    lpUIWindow;
    LPOLEINPLACEFRAME       lpFrame;
    OLEINPLACEFRAMEINFO     frameInfo;
    BOOL                    fNoNotification;
    BOOL                    fInContextHelpMode;
} INPLACEDATA, * PINPLACEDATA, FAR* LPINPLACEDATA;


typedef struct DOC FAR* LPDOC;

// Document structure
typedef struct  DOC
{
    struct COleObjectImpl {
        IOleObjectVtbl FAR*             lpVtbl;
        LPDOC                                   lpdoc;
    } m_Ole;

    struct CDataObjectImpl {
        IDataObjectVtbl FAR*            lpVtbl;
        LPDOC                                   lpdoc;
    } m_Data;

    struct CPersistStorageImpl {
        IPersistStorageVtbl FAR* lpVtbl;
        LPDOC                                    lpdoc;
    } m_PersistStorage;

    struct COleInPlaceObjectImpl {
        IOleInPlaceObjectVtbl FAR* lpVtbl;
        LPDOC                                    lpdoc;
    } m_InPlace;

    struct COleInPlaceActiveObjectImpl {
        IOleInPlaceActiveObjectVtbl FAR* lpVtbl;
        LPDOC                                    lpdoc;
    } m_IPActive;

    struct CPersistFileImpl {
        IPersistFileVtbl FAR*   lpVtbl;
        LPDOC                                   lpdoc;
    } m_PersistFile;

    int             cRef;    // ref count.
    HWND                    hwnd;        // The object's own window
    LPTSTR           native; // Object data in native format
    LPOLECLIENTSITE         lpoleclient; // Client associated with the object
    LPDATAADVISEHOLDER      lpdaholder;  // util instance to hold data advises
    LPOLEADVISEHOLDER       lpoaholder;  // util instance to hold ole advises

    DOCTYPE                 doctype;     // Document type
    ATOM                    aDocName;    // Document name
    HWND            hwndParent;
    LPINPLACEDATA       lpIpData;
    int             cLock;

} DOC;


typedef struct ClipDragData CLIPDRAGDATA, FAR* LPCLIPDRAGDATA;
typedef struct ClipDragEnum CLIPDRAGENUM, FAR* LPCLIPDRAGENUM;

struct ClipDragData
{
    struct CDataObject {
        IDataObjectVtbl FAR*    lpVtbl;
        LPCLIPDRAGDATA                  lpclipdragdata;
    } m_IDataObject;
    struct CDropSource {
        IDropSourceVtbl FAR*    lpVtbl;
        LPCLIPDRAGDATA                  lpclipdragdata;
    } m_IDropSource;

    LPDOC                           lpdoc;
    int                 cRef;         // ref count
    LPCLIPDRAGENUM                  lpClipDragEnum;  // The enumerator
    BOOL                fClipData;      //Is this for Clipboard or Dragdrop
} ;

struct ClipDragEnum
{
    IEnumFORMATETCVtbl FAR* lpVtbl;

    int              cRef;    // ref count
    LPCLIPDRAGDATA           lpClipDragData;  // Obj to which enumerator blongs
    CLIPFORMAT           cfNext;      // Next format returned
};

#ifdef LATER
typedef struct _SCALE
{
    int num;    // Numerator
    int denom;  // Denominator
}
SCALE, *PSCALE;

extern SCALE        gscaleInitXY[2];   // Initial scale to use for inserting OLE objects
#define SCALE_X 0
#define SCALE_Y 1
#endif


/* Global variable declarations.  (See SrvrDemo.c for descriptions.) */
extern LPMALLOC         lpMalloc;
extern HMENU        hmenuMain;
extern SRVR             srvrMain;
extern DOC              docMain;
extern BOOL     fDocChanged;
extern TCHAR    szClient[];
extern TCHAR            szClientDoc[];
extern int extHeight;
extern int extWidth;
extern TCHAR dbs[];
extern int giXppli, giYppli;
extern BOOL SkipInPlaceEdit;
extern BOOL gfInPlaceResize;
extern BOOL gfOle1Client;
extern HWND ghwndIPHatch;
extern HANDLE ghClipData;
extern HANDLE ghClipMetafile;
extern HANDLE ghClipDib;
extern LONG   glCurrentVerb;
extern BOOL  gfPosRectChange;
extern RECT gPrevPosRect;

extern BOOL gfInPPViewer;

extern HWND  ghwndFrame;
extern HWND  ghwndFocusSave;

extern CLIPFORMAT   cfNative;
extern CLIPFORMAT       cfEmbedSource;
extern CLIPFORMAT   cfObjectDescriptor;
extern CLIPFORMAT   cfMPlayer;

extern IOleObjectVtbl                           oleVtbl;
extern IDataObjectVtbl              dataVtbl;
extern IEnumFORMATETCVtbl           ClipDragEnumVtbl;
extern IClassFactoryVtbl                        srvrVtbl;
extern IPersistStorageVtbl                      persistStorageVtbl;
extern IOleInPlaceObjectVtbl        ipVtbl;
extern IOleInPlaceActiveObjectVtbl      ipActiveVtbl;
extern IDataObjectVtbl         clipdragVtbl;
extern IDropSourceVtbl          dropsourceVtbl;
#ifdef LATER
extern IDropTargetVtbl          droptargetVtbl;
#endif

extern IPersistFileVtbl             persistFileVtbl;

/* Function Prototypes */

// Various functions

BOOL InitOLE (PBOOL pfInit, LPMALLOC *ppMalloc);
BOOL  CreateDocObjFromFile (LPCTSTR lpszDoc, LPDOC lpdoc);
BOOL  ReadObjFromFile(LPTSTR, LPDOC);
BOOL  InitNewDocObj (LPDOC lpdoc);
void  CutOrCopyObj (LPDOC lpobj);
void  DestroyDoc (LPDOC lpdoc);
void  DeviceToHiMetric (LPSIZEL lpsizel);
void  UpdateObject (void);
BOOL  InitServer (HWND hwnd, HANDLE hInst);
void  DestroyServer (LPSRVR lpsrvr);
BOOL  OpenDoc (UINT wid, LPTSTR lpsz);
BOOL  NewDoc (void);
SCODE SendDocMsg (LPDOC lpdoc, WORD wMessage);
BOOL  SetTitle (LPDOC lpdoc, LPCTSTR lpszDoc);
BOOL  ExitApplication ();
LPCLIPDRAGDATA  CreateClipDragDataObject ( LPDOC lpdoc, BOOL fClipData);
void SubClassMCIWindow(void);
void DoDrag(void);
void CleanUpDrag(void);
HANDLE  GetLink (VOID);
SCODE ItemSetData(LPBYTE);

STDMETHODIMP DoInPlaceEdit(LPDOC lpdoc, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite, LONG verb, HWND FAR * lphwnd, LPRECT lprect);
void DoInPlaceDeactivate (LPDOC lpdoc);
STDMETHODIMP AssembleMenus (LPDOC lpdoc, BOOL fPlayOnly);
STDMETHODIMP DisassembleMenus (LPDOC lpdoc);

LPTSTR Abbrev (LPTSTR lpsz);

// Server methods
STDMETHODIMP  SrvrQueryInterface (LPCLASSFACTORY, REFIID, LPVOID    FAR  *);
STDMETHODIMP_(ULONG)    SrvrAddRef (LPCLASSFACTORY);
STDMETHODIMP_(ULONG)  SrvrRelease (LPCLASSFACTORY);
STDMETHODIMP  SrvrCreateInstance (LPCLASSFACTORY, LPUNKNOWN, REFIID, LPVOID FAR  *);
STDMETHODIMP  SrvrLockServer (LPCLASSFACTORY, BOOL);

STDMETHODIMP     UnkQueryInterface (LPUNKNOWN, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     UnkAddRef (LPUNKNOWN);
STDMETHODIMP_(ULONG)     UnkRelease (LPUNKNOWN);

STDMETHODIMP     OleObjQueryInterface (LPOLEOBJECT, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     OleObjAddRef (LPOLEOBJECT);
STDMETHODIMP_(ULONG)     OleObjRelease (LPOLEOBJECT);
STDMETHODIMP     OleObjSetClientSite (LPOLEOBJECT,  LPOLECLIENTSITE);
STDMETHODIMP     OleObjGetClientSite (LPOLEOBJECT,  LPOLECLIENTSITE FAR*);

STDMETHODIMP     OleObjSetHostNames (LPOLEOBJECT, LPCWSTR, LPCWSTR);
STDMETHODIMP     OleObjClose (LPOLEOBJECT, DWORD);
STDMETHODIMP     OleObjSetMoniker (LPOLEOBJECT, DWORD, LPMONIKER);
STDMETHODIMP     OleObjGetMoniker (LPOLEOBJECT, DWORD, DWORD, LPMONIKER FAR*);
STDMETHODIMP     OleObjInitFromData (LPOLEOBJECT, LPDATAOBJECT, BOOL, DWORD);
STDMETHODIMP     OleObjGetClipboardData (LPOLEOBJECT, DWORD, LPDATAOBJECT FAR*);
STDMETHODIMP     OleObjDoVerb (LPOLEOBJECT, LONG, LPMSG, LPOLECLIENTSITE, LONG, HWND, LPCRECT);

STDMETHODIMP     OleObjEnumVerbs(LPOLEOBJECT, IEnumOLEVERB FAR* FAR*);
STDMETHODIMP     OleObjUpdate(LPOLEOBJECT);
STDMETHODIMP     OleObjIsUpToDate(LPOLEOBJECT);
STDMETHODIMP     OleObjGetUserClassID (LPOLEOBJECT, CLSID FAR* pClsid);
STDMETHODIMP     OleObjGetUserType (LPOLEOBJECT, DWORD, LPWSTR FAR*);
STDMETHODIMP     OleObjSetExtent(LPOLEOBJECT, DWORD, LPSIZEL);
STDMETHODIMP     OleObjGetExtent(LPOLEOBJECT, DWORD, LPSIZEL);
STDMETHODIMP     OleObjAdvise(LPOLEOBJECT, LPADVISESINK, LPDWORD);
STDMETHODIMP     OleObjUnadvise(LPOLEOBJECT, DWORD);
STDMETHODIMP     OleObjEnumAdvise (LPOLEOBJECT, LPENUMSTATDATA FAR*);
STDMETHODIMP     OleObjGetMiscStatus (LPOLEOBJECT, DWORD, DWORD FAR*);
STDMETHODIMP     OleObjSetColorScheme (LPOLEOBJECT, LPLOGPALETTE);


STDMETHODIMP     DataObjQueryInterface (LPDATAOBJECT, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     DataObjAddRef (LPDATAOBJECT);
STDMETHODIMP_(ULONG)     DataObjRelease (LPDATAOBJECT);
STDMETHODIMP     DataObjGetData (LPDATAOBJECT, LPFORMATETC, LPSTGMEDIUM);
STDMETHODIMP     DataObjGetDataHere (LPDATAOBJECT, LPFORMATETC, LPSTGMEDIUM);
STDMETHODIMP     DataObjQueryGetData (LPDATAOBJECT, LPFORMATETC);
STDMETHODIMP     DataObjGetCanonicalFormatEtc (LPDATAOBJECT, LPFORMATETC,
                            LPFORMATETC);
STDMETHODIMP     DataObjSetData (LPDATAOBJECT, LPFORMATETC, LPSTGMEDIUM, BOOL);
STDMETHODIMP     DataObjEnumFormatEtc (LPDATAOBJECT,  DWORD, LPENUMFORMATETC FAR*);
STDMETHODIMP     DataObjAdvise(LPDATAOBJECT, FORMATETC FAR*,
                            DWORD, IAdviseSink FAR*, DWORD FAR*);
STDMETHODIMP     DataObjUnadvise(LPDATAOBJECT, DWORD );
STDMETHODIMP     DataObjEnumAdvise(LPDATAOBJECT, LPENUMSTATDATA FAR*);


STDMETHODIMP     ClipDragEnumQueryInterface (LPENUMFORMATETC, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     ClipDragEnumAddRef (LPENUMFORMATETC);
STDMETHODIMP_(ULONG)     ClipDragEnumRelease (LPENUMFORMATETC);
STDMETHODIMP     ClipDragEnumNext (LPENUMFORMATETC, ULONG, FORMATETC FAR[],
                                   ULONG FAR*);
STDMETHODIMP     ClipDragEnumSkip (LPENUMFORMATETC, ULONG);
STDMETHODIMP     ClipDragEnumReset (LPENUMFORMATETC);
STDMETHODIMP     ClipDragEnumClone (LPENUMFORMATETC, LPENUMFORMATETC FAR*);

STDMETHODIMP     ClipDragUnknownQueryInterface (LPCLIPDRAGDATA, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     ClipDragUnknownAddRef (LPCLIPDRAGDATA);
STDMETHODIMP_(ULONG)     ClipDragUnknownRelease (LPCLIPDRAGDATA);

STDMETHODIMP     ClipDragQueryInterface (LPDATAOBJECT, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     ClipDragAddRef (LPDATAOBJECT);
STDMETHODIMP_(ULONG)     ClipDragRelease (LPDATAOBJECT);
STDMETHODIMP     ClipDragGetData (LPDATAOBJECT, LPFORMATETC, LPSTGMEDIUM);
STDMETHODIMP     ClipDragGetDataHere (LPDATAOBJECT, LPFORMATETC, LPSTGMEDIUM);
STDMETHODIMP     ClipDragQueryGetData (LPDATAOBJECT, LPFORMATETC);
STDMETHODIMP     ClipDragGetCanonicalFormatEtc (LPDATAOBJECT,
                             LPFORMATETC, LPFORMATETC);
STDMETHODIMP     ClipDragSetData (LPDATAOBJECT,
                           LPFORMATETC, LPSTGMEDIUM, BOOL);
STDMETHODIMP     ClipDragEnumFormatEtc (LPDATAOBJECT,
                          DWORD, LPENUMFORMATETC FAR*);
STDMETHODIMP     ClipDragAdvise(LPDATAOBJECT, FORMATETC FAR*,
                      DWORD, IAdviseSink FAR*, DWORD FAR*);
STDMETHODIMP     ClipDragUnadvise(LPDATAOBJECT, DWORD );
STDMETHODIMP     ClipDragEnumAdvise(LPDATAOBJECT, LPENUMSTATDATA FAR*);

STDMETHODIMP     DropSourceQueryInterface (LPDROPSOURCE, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     DropSourceAddRef (LPDROPSOURCE);
STDMETHODIMP_(ULONG)     DropSourceRelease (LPDROPSOURCE);
STDMETHODIMP     DropSourceQueryContinueDrag (LPDROPSOURCE, BOOL, DWORD );
STDMETHODIMP     DropSourceGiveFeedback (LPDROPSOURCE, DWORD );

STDMETHODIMP     PSQueryInterface (LPPERSISTSTORAGE, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     PSAddRef (LPPERSISTSTORAGE);
STDMETHODIMP_(ULONG)     PSRelease (LPPERSISTSTORAGE);
STDMETHODIMP     PSGetClassID(LPPERSISTSTORAGE, CLSID FAR*);
STDMETHODIMP     PSIsDirty(LPPERSISTSTORAGE);
STDMETHODIMP     PSInitNew (LPPERSISTSTORAGE, LPSTORAGE);
STDMETHODIMP     PSLoad (LPPERSISTSTORAGE, LPSTORAGE);
STDMETHODIMP     PSSave (LPPERSISTSTORAGE, LPSTORAGE, BOOL);
STDMETHODIMP     PSSaveCompleted(LPPERSISTSTORAGE, LPSTORAGE );
STDMETHODIMP     PSHandsOffStorage(LPPERSISTSTORAGE);

STDMETHODIMP     IPObjQueryInterface (LPOLEINPLACEOBJECT,REFIID, LPVOID FAR*);
STDMETHODIMP_(ULONG)     IPObjAddRef (LPOLEINPLACEOBJECT);
STDMETHODIMP_(ULONG)     IPObjRelease (LPOLEINPLACEOBJECT);
STDMETHODIMP     IPObjGetWindow (LPOLEINPLACEOBJECT, HWND FAR*);
STDMETHODIMP     IPObjContextSensitiveHelp (LPOLEINPLACEOBJECT, BOOL);
STDMETHODIMP     IPObjInPlaceDeactivate (LPOLEINPLACEOBJECT);
STDMETHODIMP     IPObjUIDeactivate (LPOLEINPLACEOBJECT);
STDMETHODIMP     IPObjSetObjectRects (LPOLEINPLACEOBJECT, LPCRECT, LPCRECT);
STDMETHODIMP     IPObjReactivateAndUndo (LPOLEINPLACEOBJECT);

STDMETHODIMP     IPActiveQueryInterface (LPOLEINPLACEACTIVEOBJECT,REFIID, LPVOID FAR*);
STDMETHODIMP_(ULONG)     IPActiveAddRef (LPOLEINPLACEACTIVEOBJECT);
STDMETHODIMP_(ULONG)     IPActiveRelease (LPOLEINPLACEACTIVEOBJECT);
STDMETHODIMP     IPActiveGetWindow (LPOLEINPLACEACTIVEOBJECT, HWND FAR*);
STDMETHODIMP     IPActiveContextSensitiveHelp (LPOLEINPLACEACTIVEOBJECT, BOOL);
STDMETHODIMP     IPActiveTranslateAccelerator (LPOLEINPLACEACTIVEOBJECT, LPMSG);
STDMETHODIMP     IPActiveOnFrameWindowActivate (LPOLEINPLACEACTIVEOBJECT, BOOL);
STDMETHODIMP     IPActiveOnDocWindowActivate (LPOLEINPLACEACTIVEOBJECT, BOOL);
STDMETHODIMP     IPActiveResizeBorder (LPOLEINPLACEACTIVEOBJECT, LPCRECT, LPOLEINPLACEUIWINDOW,BOOL);
STDMETHODIMP     IPActiveEnableModeless (LPOLEINPLACEACTIVEOBJECT, BOOL);

STDMETHODIMP     PFQueryInterface (LPPERSISTFILE, REFIID, LPVOID FAR *);
STDMETHODIMP_(ULONG)     PFAddRef (LPPERSISTFILE);
STDMETHODIMP_(ULONG)     PFRelease (LPPERSISTFILE);
STDMETHODIMP     PFGetClassID(LPPERSISTFILE, CLSID FAR*);
STDMETHODIMP     PFIsDirty(LPPERSISTFILE);
STDMETHODIMP     PFLoad (LPPERSISTFILE, LPCWSTR, DWORD);
STDMETHODIMP     PFSave (LPPERSISTFILE, LPCWSTR, BOOL);
STDMETHODIMP     PFSaveCompleted(LPPERSISTFILE, LPCWSTR );
STDMETHODIMP     PFGetCurFile(LPPERSISTFILE, LPWSTR FAR*);


typedef enum
{
    OLE1_OLEOK,             /* 0   Function operated correctly         */

    OLE1_OLEWAIT_FOR_RELEASE,       /* 1   Command has been initiated, client      */
                /*     must wait for release. keep dispatching */
                /*     messages till OLE1_OLERELESE in callback    */

    OLE1_OLEBUSY,           /* 2   Tried to execute a method while another */
                /*     method is in progress.                  */

    OLE1_OLEERROR_PROTECT_ONLY,     /* 3   Ole APIs are called in real mode    */
    OLE1_OLEERROR_MEMORY,       /* 4   Could not alloc or lock memory      */
    OLE1_OLEERROR_STREAM,       /* 5  (OLESTREAM) stream error         */
    OLE1_OLEERROR_STATIC,       /* 6   Non static object expected          */
    OLE1_OLEERROR_BLANK,        /* 7   Critical data missing           */
    OLE1_OLEERROR_DRAW,         /* 8   Error while drawing             */
    OLE1_OLEERROR_METAFILE,     /* 9   Invalid metafile            */
    OLE1_OLEERROR_ABORT,        /* 10  Client chose to abort metafile drawing  */
    OLE1_OLEERROR_CLIPBOARD,        /* 11  Failed to get/set clipboard data    */
    OLE1_OLEERROR_FORMAT,       /* 12  Requested format is not available       */
    OLE1_OLEERROR_OBJECT,       /* 13  Not a valid object              */
    OLE1_OLEERROR_OPTION,       /* 14  Invalid option(link update / render)    */
    OLE1_OLEERROR_PROTOCOL,     /* 15  Invalid protocol            */
    OLE1_OLEERROR_ADDRESS,      /* 16  One of the pointers is invalid      */
    OLE1_OLEERROR_NOT_EQUAL,        /* 17  Objects are not equal           */
    OLE1_OLEERROR_HANDLE,       /* 18  Invalid handle encountered          */
    OLE1_OLEERROR_GENERIC,      /* 19  Some general error              */
    OLE1_OLEERROR_CLASS,        /* 20  Invalid class               */
    OLE1_OLEERROR_SYNTAX,       /* 21  Command syntax is invalid           */
    OLE1_OLEERROR_DATATYPE,     /* 22  Data format is not supported        */
    OLE1_OLEERROR_PALETTE,      /* 23  Invalid color palette           */
    OLE1_OLEERROR_NOT_LINK,     /* 24  Not a linked object             */
    OLE1_OLEERROR_NOT_EMPTY,        /* 25  Client doc contains objects.        */
    OLE1_OLEERROR_SIZE,         /* 26  Incorrect buffer size passed to the api */
                /*     that places some string in caller's     */
                /*     buffer                                  */

    OLE1_OLEERROR_DRIVE,        /* 27  Drive letter in doc name is invalid     */
    OLE1_OLEERROR_NETWORK,      /* 28  Failed to establish connection to a     */
                /*     network share on which the document     */
                /*     is located                              */

    OLE1_OLEERROR_NAME,         /* 29  Invalid name(doc name, object name),    */
                /*     etc.. passed to the APIs                */

    OLE1_OLEERROR_TEMPLATE,     /* 30  Server failed to load template      */
    OLE1_OLEERROR_NEW,          /* 31  Server failed to create new doc     */
    OLE1_OLEERROR_EDIT,         /* 32  Server failed to create embedded    */
                /*     instance                                */
    OLE1_OLEERROR_OPEN,         /* 33  Server failed to open document,     */
                /*     possible invalid link                   */

    OLE1_OLEERROR_NOT_OPEN,     /* 34  Object is not open for editing      */
    OLE1_OLEERROR_LAUNCH,       /* 35  Failed to launch server         */
    OLE1_OLEERROR_COMM,         /* 36  Failed to communicate with server       */
    OLE1_OLEERROR_TERMINATE,        /* 37  Error in termination            */
    OLE1_OLEERROR_COMMAND,      /* 38  Error in execute            */
    OLE1_OLEERROR_SHOW,         /* 39  Error in show               */
    OLE1_OLEERROR_DOVERB,       /* 40  Error in sending do verb, or invalid    */
                /*     verb                                    */
    OLE1_OLEERROR_ADVISE_NATIVE,    /* 41  Item could be missing           */
    OLE1_OLEERROR_ADVISE_PICT,      /* 42  Item could be missing or server doesn't */
                /*     this format.                            */

    OLE1_OLEERROR_ADVISE_RENAME,    /* 43  Server doesn't support rename           */
    OLE1_OLEERROR_POKE_NATIVE,      /* 44  Failure of poking native data to server */
    OLE1_OLEERROR_REQUEST_NATIVE,   /* 45  Server failed to render native data     */
    OLE1_OLEERROR_REQUEST_PICT,     /* 46  Server failed to render presentation    */
                /*     data                                    */
    OLE1_OLEERROR_SERVER_BLOCKED,   /* 47  Trying to block a blocked server or     */
                /*     trying to revoke a blocked server       */
                /*     or document                             */

    OLE1_OLEERROR_REGISTRATION,     /* 48  Server is not registered in regestation */
                /*     data base                               */
    OLE1_OLEERROR_ALREADY_REGISTERED,/*49  Trying to register same doc multiple    */
                 /*    times                                   */
    OLE1_OLEERROR_TASK,         /* 50  Server or client task is invalid    */
    OLE1_OLEERROR_OUTOFDATE,        /* 51  Object is out of date           */
    OLE1_OLEERROR_CANT_UPDATE_CLIENT,/* 52 Embed doc's client doesn't accept       */
                /*     updates                                 */
    OLE1_OLEERROR_UPDATE,       /* 53  erorr while trying to update        */
    OLE1_OLEERROR_SETDATA_FORMAT,   /* 54  Server app doesn't understand the       */
                /*     format given to its SetData method      */
    OLE1_OLEERROR_STATIC_FROM_OTHER_OS,/* 55 trying to load a static object created */
                   /*    on another Operating System           */

    /*  Following are warnings */
    OLE1_OLEWARN_DELETE_DATA = 1000 /*     Caller must delete the data when he is  */
                /*     done with it.                           */
} OLE1_OLESTATUS;


typedef OLE1_OLESTATUS (FAR PASCAL *OQOPROC)( LPVOID lpobj
                                       , HWND FAR* lphwnd
                                       , LPRECT lprc
                                       , LPRECT lprcWBounds
                                       );
OLE1_OLESTATUS (FAR PASCAL *OleQueryObjPos)(LPVOID lpobj, HWND FAR* lphwnd, LPRECT lprc, LPRECT lprcWBounds);

extern HMODULE hMciOle;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\mplayer.c ===
/*-----------------------------------------------------------------------------+
| MPLAYER.C                                                                    |
|                                                                              |
| This file contains the code that implements the "MPlayer" (main) dialog box. |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

/* include files */
#include "nocrap.h"
#include "stdio.h"

#include <windows.h>
#include <mmsystem.h>
#include <shellapi.h>
#include <windowsx.h>
#include <htmlhelp.h>
#include <tchar.h>
#define INCGUID
#include "mpole.h"

#include "mplayer.h"
#include "toolbar.h"
#include "fixreg.h"
#include "helpids.h"

//These include files for WM_DEVICECHANGE messages from the mixer
#include <dbt.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <mmddk.h>
#include <ks.h>
#include <ksmedia.h>

HDEVNOTIFY MixerEventContext = NULL;	//Event Context for WM_DEVICECHANGE messages related to mixer

BOOL DeviceChange_Init(HWND hWnd);
void DeviceChange_Cleanup();

//extern int FAR PASCAL ShellAbout(HWND hWnd, LPCTSTR szApp, LPCTSTR szOtherStuff, HICON hIcon);

/* in server.c, but not in a header file like it should be... */
extern PTSTR FAR FileName(LPCTSTR szPath);

/* globals */


// Used in converting units from pixels to Himetric and vice-versa
int    giXppli = 0;          // pixels per logical inch along width
int    giYppli = 0;          // pixels per logical inch along height

// Since this is a not an MDI app, there can be only one server and one doc.
CLSID      clsid;
SRVR   srvrMain;
DOC    docMain;
LPMALLOC    lpMalloc;

TCHAR  szClient[cchFilenameMax];
TCHAR  szClientDoc[cchFilenameMax];

// Has the user made changes to the document?
BOOL fDocChanged = FALSE;

/*********************************************************************
** OLE2NOTE: the very last thing an app must be do is properly shut
**    down OLE. This call MUST be guarded! it is only allowable to
**    call OleUninitialize if OleInitialize has been called.
*********************************************************************/

// Has OleInitialize been called? assume not.
BOOL    gfOleInitialized = FALSE;

// Clipboard formats
CLIPFORMAT   cfNative;
CLIPFORMAT   cfEmbedSource;
CLIPFORMAT   cfObjectDescriptor;
CLIPFORMAT   cfMPlayer;

LPWSTR sz1Ole10Native = L"\1Ole10Native";

/* in server.c, but not in a header file like it should be... */
extern LPTSTR FAR FileName(LPCTSTR szPath);
/* in init.c */
extern PTSTR     gpchFilter;
//extern HMREGNOTIFY  ghmrn;

/* globals */

DWORD   gwPlatformId;
UINT    gwPlaybarHeight=TOOLBAR_HEIGHT;/* Taken from server.c         */
UINT    gwOptions;              /* The object options from the dlg box */
BOOL    gfEmbeddedObject;       // TRUE if editing embedded OLE object
BOOL    gfRunWithEmbeddingFlag; // TRUE if we are run with "-Embedding"
BOOL    gfPlayingInPlace;       // TRUE if playing in place
BOOL    gfParentWasEnabled;     // TRUE if parent was enabled
BOOL    gfShowWhilePlaying;     //
BOOL    gfDirty;                //
int gfErrorBox;     // TRUE if we have a message box active
BOOL    gfErrorDeath;
BOOL    gfWinIniChange;

HHOOK    hHookMouse;            // Mouse hook handle.
HOOKPROC fpMouseHook;           // Mouse hook proc address.

HWND    ghwndFocusSave;         // saved focus window

BOOL    gfOpenDialog = FALSE;       // If TRUE, put up open dialog
BOOL    gfCloseAfterPlaying = FALSE;// TRUE if we are to hide after play
HICON   hiconApp;                   /* app icon */
HMENU   ghMenu;                     /* handle to the dialog's main menu       */
HMENU   ghDeviceMenu;               /* handle to the Device popup menu        */
HWND    ghwndApp;                   /* handle to the MPlayer (main) dialog box*/
HWND    ghwndMap;                   /* handle to the track map window         */
HWND    ghwndStatic;                /* handle to the static text window       */
HBRUSH  ghbrFillPat;                /* The selection fill pattern.         */
HWND    ghwndToolbar;               /* handle of the toolbar                  */
HWND    ghwndMark;                  /* handle of the mark buttons toolbar     */
HWND    ghwndFSArrows;              /* handle of the arrows to the scrollbar  */
HWND    ghwndTrackbar;              /* handle to the trackbar window          */
UINT    gwStatus = (UINT)(-1);      /* device status (if <gwDeviceID> != NULL)*/
DWORD   gdwSeekPosition;            /* Place to seek to next */
BOOL    gfValidMediaInfo;           /* are we displaying valid media info?    */
BOOL    gfValidCaption;             /* are we displaying a valid caption?     */
BOOL    gfScrollTrack;              /* is user dragging the scrollbar thumb?  */
BOOL    gfPlayOnly;                 /* play only window?  */
BOOL    gfJustPlayed = FALSE;       /* Just sent a PlayMCI() command          */
BOOL    gfJustPlayedSel = FALSE;    /* Just sent a ID_PLAYSEL command.        */
BOOL    gfUserStopped = FALSE;      /* user pressed stop - didn't happen itslf*/
DWORD_PTR   dwLastPageUpTime;           /* time of last page-left operation       */
UINT    gwCurScale = ID_NONE;       /* current scale style                    */
LONG    glSelStart = -1;            /* See if selection changes (dirty object)*/
LONG    glSelEnd = -1;              /* See if selection changes (dirty object)*/

int     gInc;                       /* how much to inc/dec spin arrows by     */

BOOL    gfAppActive = FALSE;        /* Are we the active application?         */
UINT    gwHeightAdjust;
HWND    ghwndFocus = NULL;          /* Who had the focus when we went inactive*/
BOOL    gfInClose = FALSE;          /* ack?*/
BOOL    gfCurrentCDChecked = FALSE; /* TRUE if we've checked whether it can play */
BOOL    gfCurrentCDNotAudio = FALSE;/* TRUE when we have a CD that we can't play */

extern BOOL gfInPlayMCI;

LPDATAOBJECT gpClipboardDataObject = NULL; /* If non-NULL, call OleFlushClipboard on exit */

HPALETTE     ghpalApp;

static    sfSeekExact;    // last state

UINT        gwCurDevice  = 0;                   /* current device */
UINT        gwNumDevices = 0;                   /* number of available media devices      */
MCIDEVICE   garMciDevices[MAX_MCI_DEVICES];     /* array with info about a device */


/* strings which get loaded in InitMplayerDialog in init.c, English version shown here
   All the sizes are much larger than needed, probably.  Maybe could save nearly 100 bytes!! :)
*/
extern TCHAR gszFrames[40];                          /* "frames" */
extern TCHAR gszHrs[20];                             /* "hrs" */
extern TCHAR gszMin[20];                             /* "min" */
extern TCHAR gszSec[20];                             /* "sec" */
extern TCHAR gszMsec[20];                            /* "msec" */


static SZCODE   aszNULL[] = TEXT("");
static BOOL     sfInLayout = FALSE;     // don't let Layout get re-entered

static SZCODE   szSndVol32[] = TEXT("sndvol32.exe");


static SZCODE   aszTitleFormat[] =  TEXT("%"TS" - %"TS"");

HANDLE  ghInst;                     /* handle to the application instance     */
HFONT   ghfontMap;                  /* handle to the font used for drawing
					the track map                         */
LPTSTR  gszCmdLine;                 /* string holding the command line parms  */
int     giCmdShow;                  /* command show                           */
TCHAR   gachFileDevice[MAX_PATH];   /* string holding the curr file or device */
TCHAR   gachWindowTitle[MAX_PATH];  /* string holding name we will display  */
TCHAR   gachCaption[MAX_PATH];      /* string holding name we will display  */

HACCEL   hAccel;
int      gcAccelEntries;

typedef struct _POS
{
    int x;
    int y;
    int cx; /* This field is non-0 if we're currently sizing/moving */
    int cy;
}
POS, *PPOS;

POS     posSizeMove = {0,0,0,0};    /* POS we want during size/move operations */



STRING_TO_ID_MAP DevToIconIDMap[] =
{
    { szCDAudio,    IDI_DCDA     },
    { szVideoDisc,  IDI_DDEFAULT },
    { szSequencer,  IDI_DMIDI    },
    { szVCR,        IDI_DDEFAULT },
    { szWaveAudio,  IDI_DSOUND   },
    { szAVIVideo,   IDI_DVIDEO   }
};


//CDA file processing///////////////////////////////////////////////////
//The following structure taken from deluxecd. This is used in processing
typedef struct {
    DWORD   dwRIFF;         // 'RIFF'
    DWORD   dwSize;         // Chunk size = (file size - 8)
    DWORD   dwCDDA;         // 'CDDA'
    DWORD   dwFmt;          // 'fmt '
    DWORD   dwCDDASize;     // Chunk size of 'fmt ' = 24
    WORD    wFormat;        // Format tag
    WORD    wTrack;         // Track number
    DWORD   DiscID;         // Unique disk id
    DWORD   lbnTrackStart;  // Track starting sector (LBN)
    DWORD   lbnTrackLength; // Track length (LBN count)
    DWORD   msfTrackStart;  // Track starting sector (MSF)
    DWORD   msfTrackLength; // Track length (MSF)
	}   RIFFCDA;

void HandleCDAFile(TCHAR *szFile);
BOOL IsTrackFileNameValid(LPTSTR lpstFileName, UINT *pUiTrackIndex);
void JumpToCDTrack(UINT trackno);

////////////////////////////////////////////////////////////////////////

/* private function prototypes */

//int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int iCmdShow);
void CleanUpClipboard();
int GetHeightAdjust(HWND hwnd);
HANDLE PASCAL GetDib (VOID);


static HHOOK     fpfnOldMsgFilter;
static HOOKPROC  fpfnMsgHook;
//Data used for supporting context menu help
BOOL   bF1InMenu=FALSE;	//If true F1 was pressed on a menu item.
UINT   currMenuItem=0;	//The current menu item if any.


typedef void (FAR PASCAL *PENWINREGISTERPROC)(UINT, BOOL);

/* Define some constants to make parameters to CreateEvent a tad less obscure:
 */
#define EVENT_DEFAULT_SECURITY              NULL
#define EVENT_RESET_MANUAL                  TRUE
#define EVENT_RESET_AUTOMATIC               FALSE
#define EVENT_INITIAL_STATE_SIGNALED        TRUE
#define EVENT_INITIAL_STATE_NOT_SIGNALED    FALSE
#define EVENT_NO_NAME                       NULL

HANDLE heventCmdLineScanned;    /* Event will be signaled when command line scanned */
HANDLE heventDeviceMenuBuilt;   /* Event will be signaled when device menu complete */

#ifdef LATER
SCALE   gscaleInitXY[2] = { 0, 0, 0, 0 }; // Initial scale to use for inserting OLE objects
#endif



/*------------------------------------------------------+
| HelpMsgFilter - filter for F1 key in dialogs          |
|                                                       |
+------------------------------------------------------*/

DWORD FAR PASCAL HelpMsgFilter(int nCode, DWORD_PTR wParam, DWORD_PTR lParam)
{
  if (nCode >= 0){
      LPMSG    msg = (LPMSG)lParam;

      if ((msg->message == WM_KEYDOWN) && (msg->wParam == VK_F1))
	  {
		if(nCode == MSGF_MENU)
			bF1InMenu = TRUE;
		SendMessage(ghwndApp, WM_COMMAND, (WPARAM)IDM_HELPTOPICS, 0L);
	  }
  }
//  return DefHookProc(nCode, wParam, lParam, (HHOOK FAR *)&fpfnOldMsgFilter);
    return 0;
}

#ifdef CHICAGO_PRODUCT

BOOL IsBadSegmentedCodePtr(LPARAM lpPtr)
{
#define DSC_PRESENT         0x80
#define DSC_CODE_BIT    0x08
#define DSC_RW_BIT          0x02
#define DSC_DISCARDABLE 0x10

    WORD wSel;
    WORD wOff;
    BOOL fRet;

    wSel = HIWORD(lpPtr);
    wOff = LOWORD(lpPtr);

_asm {
	mov     ax, [wSel];
	lar     bx, ax;
	jnz     ValidDriverCallback_Failure     ; //Return TRUE for error

	mov     ch, DSC_CODE_BIT or DSC_RW_BIT or DSC_PRESENT  ;
	and     bh, ch;
	cmp     bh, ch;
	jne     ValidDriverCallback_Failure     ; //Not executable segment

	test    bl, DSC_DISCARDABLE ;
	jnz     ValidDriverCallback_Failure     ; //Not fixed segment

	lsl     cx, ax;                         ; //Get segment limit
	mov     bx, [wOff];
	cmp     bx, cx;
	jb      ValidDriverCallback_Success     ; //Valid offset

	jne     ValidDriverCallback_Failure     ; //Not executable segment

ValidDriverCallback_Failure:
    mov eax, 1;
    jmp ValidDriverCallback_Return;
ValidDriverCallback_Success:
    xor eax, eax;
ValidDriverCallback_Return:
    mov [fRet], eax;
    }
    return fRet;
}

#endif

/* RouteKeyPresses
 *
 * Reroutes cursor keys etc to track bar.
 */
void RouteKeyPresses(PMSG pMsg)
{
    /* Hack for PowerPoint
     *
     * Mail from PaulWa:
     *
     * --------
     * Here's a problem you might consider fixing.
     * Launching Media Player with certain keystrokes
     * doesn't work right (e.g. arrow keys, page up/down,
     * etc.).
     *
     * The problem is due to the fact that Media Player
     * handles key up events.  We use the key down event
     * to launch the server in slideshow, but then the key
     * up event is passed to the server.  It would probably
     * be best for Media Player to ignore key up events
     * unless it had previously received a key down.
     * If this is very difficult to fix in Media Player,
     * then we can fix it in PP by launching servers on
     * key up rather than key down.  However, other container
     * apps will see the same problem.
     * --------
     *
     * OK, in the spirit of cooperation, let's hack things
     * so our PowerPoint friends can carry on with their
     * dubious practices.
     */
    static WPARAM LastVKeyDown;

    /* On key down when we're embedded, remember what is was:
     */
    if (gfRunWithEmbeddingFlag && (pMsg->message == WM_KEYDOWN))
	LastVKeyDown = pMsg->wParam;

    /* Don't reroute if it's a key up that doesn't match
     * the last key down; this effectively ignores it:
     */
    if (gfRunWithEmbeddingFlag &&
	(pMsg->message == WM_KEYUP) && (pMsg->wParam != LastVKeyDown))
    {
	DPF0("Ignoring WM_KEYUP, since it doesn't match last WM_KEYDOWN.\n");
    }
    else
    {
	switch(pMsg->wParam)
	{
	case VK_UP:
	case VK_LEFT:
	case VK_DOWN:
	case VK_RIGHT:
	case VK_NEXT:
	case VK_PRIOR:
	case VK_HOME:
	case VK_END:
	    pMsg->hwnd = ghwndTrackbar;
	    break;

	default:
	    break;
	}
    }

    if (pMsg->message == WM_KEYUP)
	LastVKeyDown = 0;
}



/*
 * WinMain(hInst, hPrev, szCmdLine, iCmdShow)
 *
 * This is the main procedure for the application.  It performs initialization
 * and then enters a message-processing loop, where it remains until it
 * receives a WM_QUIT message (meaning the app was closed). This function
 * always returns TRUE..
 *
 */
int WINAPI WinMain( HINSTANCE hInst /* handle to the current instance of the application */
		  , HINSTANCE hPrev /* handle to the previous instance of the application */
		  , LPSTR szCmdLine /* null-terminated string holding the command line params */
		  , int iCmdShow    /* how the window should be initially displayed */
		  )
{
    MSG         rMsg;   /* variable used for holding a message */
    HWND        hwndFocus;
    HWND        hwndP;

    /* call the Pen Windows extensions to allow them to subclass our
       edit controls if they so wish
    */

    OSVERSIONINFO         OSVersionInfo;

#ifdef UNICODE
    LPTSTR      szUnicodeCmdLine;

    szUnicodeCmdLine = AllocateUnicodeString(szCmdLine);
#endif

    heventCmdLineScanned = CreateEvent( EVENT_DEFAULT_SECURITY,
					EVENT_RESET_MANUAL,
					EVENT_INITIAL_STATE_NOT_SIGNALED,
					EVENT_NO_NAME );

    heventDeviceMenuBuilt = CreateEvent( EVENT_DEFAULT_SECURITY,
					 EVENT_RESET_MANUAL,
					 EVENT_INITIAL_STATE_NOT_SIGNALED,
					 EVENT_NO_NAME );

    if (!heventCmdLineScanned || !heventDeviceMenuBuilt)
	return FALSE;

    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;

    GetVersionEx(&OSVersionInfo);

    gwPlatformId = OSVersionInfo.dwPlatformId;


    giCmdShow = iCmdShow;

#ifdef UNICODE
    if (!AppInit(hInst,hPrev,szUnicodeCmdLine))
#else
    if (!AppInit(hInst,hPrev,szCmdLine))
#endif
	return FALSE;

    /* Device Menu Initialization:
     *
     * If the user has requested an Open dialog (by supplying the /open
     * flag with no file name), we've already built the Device menu,
     * since the list of devices is required up front.
     *
     * If we're just playing in tiny mode, we don't need the device list.
     * It will be built if the user switches to full mode and then accesses
     * the Device menu or selects File.Open.
     *
     * Otherwise go for it.  The main window's already up now, so we
     * can build the list on a background thread.  Don't forget to wait
     * for the event to be signaled when the appropriate menu is accessed.
     */
    if (!gfOpenDialog && !gfPlayOnly)
	InitDeviceMenu();

#ifdef UNICODE
//  ScanCmdLine mangles it, so forget it
//  FreeUnicodeString(szUnicodeCmdLine);
#endif

    /* setup the message filter to handle grabbing F1 for this task */
    fpfnMsgHook = (HOOKPROC)MakeProcInstance((FARPROC)HelpMsgFilter, ghInst);
    fpfnOldMsgFilter = (HHOOK)SetWindowsHook(WH_MSGFILTER, fpfnMsgHook);

#ifdef DEBUG
    GdiSetBatchLimit(1);
#endif

    for (;;)
    {
	/* If we're ever still around after being destroyed, DIE! */
	if (!IsWindow(ghwndApp))
	    break;

	/* call the server code and let it unblock the server */
#ifdef OLE1_HACK
	ServerUnblock();
#endif /* OLE1_HACK */

	/* Polling messages from event queue */

	if (!GetMessage(&rMsg, NULL, 0, 0))
	    break;

	if (gfPlayingInPlace) {

	    // If focus ever gets to the client during play in place,
	    // be really nasty and force focus to us.   (Aldus BUG!!!!)
	    // Aldus Persuasion won't play in place without this.

	    hwndFocus = GetFocus();
	    hwndP = GetParent(ghwndApp);

	    if (!ghwndIPHatch && hwndFocus && hwndP &&
			GetWindowTask(hwndP) == GetWindowTask(hwndFocus))
		PostCloseMessage();
	}

	/* Hack: post END_SCROLL messages with lParam == -1 */

	if ((rMsg.hwnd==ghwndApp)
	     || (rMsg.hwnd && GetParent(rMsg.hwnd)==ghwndApp))
	{
	    /* Reroute arrow keys etc to track bar:
	     */
	    if (rMsg.message == WM_KEYDOWN || rMsg.message == WM_KEYUP)
		RouteKeyPresses(&rMsg);
	}


	if (IsWindow(ghwndApp)) {

	    if (gfRunWithEmbeddingFlag
	       && docMain.lpIpData
	       && docMain.lpIpData->lpFrame
	       && !IsAccelerator(hAccel, gcAccelEntries, &rMsg, NULL)
	       && OleTranslateAccelerator(docMain.lpIpData->lpFrame,
					  &docMain.lpIpData->frameInfo, &rMsg) == NOERROR) {
		continue;
	    }

	    if (hAccel && TranslateAccelerator(ghwndApp, hAccel, &rMsg))
		continue;

	}

	if (rMsg.message == WM_TIMER && rMsg.hwnd == NULL) {
#ifdef CHICAGO_PRODUCT
	    /* The reason for requiring the following test is now lost
	     * in the mists of time.  Now this app is 32-bit, these
	     * bogus timer callbacks (if they really do still occur)
	     * could be 16-bit, so we need to add yet more ugliness
	     * in the form of assembler to an app which is already
	     * hardly a paragon of pulchritude.
	     *
	     * A plea:
	     *
	     * If you add some obscure code such as below, to this or
	     * any other app, even if it has only the teeniest chance
	     * of being less blindingly obvious to someone else than
	     * it is to you at the time of writing, please please please
	     * add a f***ing comment.
	     *
	     * Respectfully,
	     * A Developer
	     */
	    if (IsBadSegmentedCodePtr(rMsg.lParam))
#else
	    if (IsBadCodePtr((FARPROC)rMsg.lParam))
#endif /* ~CHICAGO_PRODUCT */
	    {
		DPF0("Bad function pointer (%08lx) in WM_TIMER message\n", rMsg.lParam);
		rMsg.message = WM_NULL;
	    }
	}
	if (rMsg.message == WM_SYSCOMMAND
	    && (((0xFFF0 & rMsg.wParam) == SC_MOVE)|| ((0xFFF0 & rMsg.wParam) == SC_SIZE)) ) {
		// If ANY window owned by our thread is going into a modal
		// size or move loop then we need to force some repainting to
		// take place.  The cost of not doing so is that garbage can
		// be left lying around on the trackbar, e.g. bits of system
		// menu, or partially drawn sliders.
		UpdateWindow(ghwndApp);
	}
	TranslateMessage(&rMsg);
	DispatchMessage(&rMsg);
    }

    ghwndApp = NULL;

    /* Delete the track map font that we created earlier. */

    if (ghfontMap != NULL) {
	DeleteObject(ghfontMap);
	ghfontMap = NULL;
    }

    if (ghbrFillPat)
	DeleteObject(ghbrFillPat);

    if (ghpalApp)
	DeleteObject(ghpalApp);

    /* if the message hook was installed, remove it and free */
    /* up our proc instance for it.                          */
    if (fpfnOldMsgFilter){
	UnhookWindowsHook(WH_MSGFILTER, fpfnMsgHook);
    }

    ControlCleanup();

//  TermServer();

    /*********************************************************************
    ** OLE2NOTE: the very last thing an app must be do is properly shut
    **    down OLE. This call MUST be guarded! it is only allowable to
    **    call OleUninitialize if OleInitialize has been called.
    *********************************************************************/

    // Clean shutdown for OLE
    DPFI("*before oleunint");
    if (gfOleInitialized) {
	if (gpClipboardDataObject)
	    CleanUpClipboard();
	(void)OleUninitialize();
	IMalloc_Release(lpMalloc);
	lpMalloc = NULL;
	gfOleInitialized = FALSE;
	}


    if (hOLE32)
	FreeLibrary(hOLE32);

    /* End of program */

    return((int)rMsg.wParam);
}

void CleanUpClipboard()
{
    /* Check whether the DATAOBJECT we put on the clipboard is still there:
     */
    if (OleIsCurrentClipboard(gpClipboardDataObject) == S_OK)
    {
	LPDATAOBJECT pIDataObject;

	if (OleGetClipboard(&pIDataObject) == S_OK)
	{
	    OleFlushClipboard();
	    IDataObject_Release(pIDataObject);
	}
	else
	{
	    DPF0("OleGetClipboard failed\n");
	}
    }
    else
    {
	if(ghClipData)
	    GLOBALFREE(ghClipData);
	if(ghClipMetafile)
	    GLOBALFREE(ghClipMetafile);
	if(ghClipDib)
	    GLOBALFREE(ghClipDib);
    }
}

//
// cancel any active menus and close the app.
//
void PostCloseMessage()
{
    HWND hwnd;

    hwnd = GetWindowMCI();
    if (hwnd != NULL)
	SendMessage(hwnd, WM_CANCELMODE, 0, 0);
    SendMessage(ghwndApp, WM_CANCELMODE, 0, 0);
    PostMessage(ghwndApp, WM_CLOSE, 0, 0);
}

//
// If we have a dialog box up (gfErrorBox is set) or we're disabled (we have
// a dialog box up) or the MCI device's default window is disabled (it has a
// dialog box up) then closing us would result in our deaths.
//
BOOL ItsSafeToClose(void)
{
    HWND hwnd;

    if (gfErrorBox)
    return FALSE;
    if (!IsWindowEnabled(ghwndApp))
    return FALSE;
    hwnd = GetWindowMCI();
    if (hwnd && !IsWindowEnabled(hwnd))
    return FALSE;

    return TRUE;
}

/* ResolveLink
 *
 * This routine is called when the user drags and drops a shortcut
 * onto Media Player.  If it succeeds, it returns the full path
 * of the actual file in szResolved.
 */
BOOL ResolveLink(LPTSTR szPath, LPTSTR szResolved, LONG cbSize)
{
    IShellLink *psl = NULL;
    HRESULT hres;

    if (!InitOLE(&gfOleInitialized, &lpMalloc))
    {
	DPF0("Initialization of OLE FAILED!!  Can't resolve link.\n");
	return FALSE;
    }

    hres = (HRESULT)CoCreateInstance(&CLSID_ShellLink, NULL, CLSCTX_INPROC,
			    &IID_IShellLink, &psl);

    if (SUCCEEDED(hres))
    {
	IPersistFile *ppf;

	psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf);

	if (ppf)
	{
		WCHAR wszPath[MAX_PATH];
#ifdef UNICODE
		lstrcpy (wszPath, szPath);
#else
		AnsiToUnicodeString(szPath, wszPath, UNKNOWN_LENGTH);
#endif
		hres = ppf->lpVtbl->Load(ppf, wszPath, 0);
		ppf->lpVtbl->Release(ppf);

		if (FAILED(hres))
		{
		psl->lpVtbl->Release(psl);
		psl = NULL;
		}
	}
	else
	{
		psl->lpVtbl->Release(psl);
		psl = NULL;
	}
    }   

    if (psl)
    {
	psl->lpVtbl->Resolve(psl, NULL, SLR_NO_UI);
	psl->lpVtbl->GetPath(psl, szResolved, cbSize, NULL, 0);
	psl->lpVtbl->Release(psl);
    }

    return SUCCEEDED(hres);
}


/* ResolveIfLink
 *
 * Called to check whether a given file name is a shortcut
 * on Windows 95.
 *
 * Copies the resolved file name into the buffer provided,
 * overwriting the original name.
 *
 * Returns TRUE if the function succeeded, whether or not the
 * file name was changed.  FALSE indicates that an error occurred.
 *
 * Andrew Bell, 16 February 1995
 */
BOOL ResolveIfLink(PTCHAR szFileName)
{
    SHFILEINFO sfi;
    BOOL       rc = TRUE;

    if ((SHGetFileInfo(szFileName, 0, &sfi, sizeof sfi, SHGFI_ATTRIBUTES) == 1)
	&& ((sfi.dwAttributes & SFGAO_LINK) == SFGAO_LINK))
    {
	TCHAR szResolvedLink[MAX_PATH];

	if (ResolveLink(szFileName, szResolvedLink, CHAR_COUNT(szResolvedLink)))
	    lstrcpy(szFileName, szResolvedLink);
	else
	    rc = FALSE;
    }

    return rc;
}

/* JumpToCDTrack()
*
* Jumps to the appropriate track on the CD and updates the UI accordingly
*
*/
void JumpToCDTrack(UINT trackno)
{
	//If the track number is invalid just ignore.
	//Let the default behaviour take place, There is no need to give a message box
	//saying we couldn't jump to track.
	if(trackno > gwNumTracks)
		return;

	/* We MUST use PostMessage because the */
	/* SETPOS and ENDTRACK must happen one */
    /* immediately after the other         */
   	PostMessage(ghwndTrackbar, TBM_SETPOS, (WPARAM)TRUE, gadwTrackStart[trackno]);
   	PostMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_ENDTRACK, (LPARAM)ghwndTrackbar);
}

/*****************************Private*Routine******************************\
* IsTrackFileNameValid
*
* This routine copied from deluxecd and modified
*
* This function returns true if the specified filename is a valid CD track.

* On NT track filenames must be of the form:
*   d:\track(n).cda  where d: is the CD-Rom device and \track(n).cda
*                    is the index of the track to be played (starting from 1).
*
* On Chicago the track filename is actually a riff CDDA file which contains
* the track info that we require.
*
* If the filename is valid the function true and sets 
* piTrackIndex to the correct value.
*
* History:
* 29-09-94 - StephenE - Created
*
\**************************************************************************/
BOOL
IsTrackFileNameValid(
    LPTSTR lpstFileName,
    UINT *puiTrackIndex
    )
{
#define RIFF_RIFF 0x46464952
#define RIFF_CDDA 0x41444443

	
    RIFFCDA     cda;
    HANDLE          hFile;
    int         i;
    DWORD       cbRead;
    BOOL        fRead;
	
	// Open file and read in CDA info
	hFile = CreateFile (lpstFileName, GENERIC_READ, 
						FILE_SHARE_READ, NULL, 
						OPEN_EXISTING, 0, NULL);
	if (INVALID_HANDLE_VALUE == hFile) {
		return FALSE;
	}
	
    ZeroMemory (&cda, sizeof (cda));
	fRead = ReadFile(hFile, &cda, sizeof(cda), &cbRead, NULL);
	CloseHandle (hFile);

    if (!fRead)
        return FALSE;

    //
    // Make sure its a RIFF CDDA file
    //
    if ( (cda.dwRIFF != RIFF_RIFF) || (cda.dwCDDA != RIFF_CDDA) ) {
		
	return FALSE;
    }

    *puiTrackIndex = cda.wTrack - 1;

    return TRUE;
}

/* HandleCDAFile()
*
* Checks to see if the opened file is a CDA file and tries to jump to the appropriate track.
*
*/
void HandleCDAFile(TCHAR *szFile)
{
	UINT trackno;
	if(IsTrackFileNameValid(szFile, &trackno))
	{
		JumpToCDTrack(trackno);
	}
}


/* Process file drop/drag options. */
void PASCAL NEAR doDrop(HWND hwnd, HDROP hDrop)
{
    RECT    rc;

    if(DragQueryFile(hDrop,(UINT)(~0),NULL,0)){/* # of files dropped */
	TCHAR  szPath[MAX_PATH];

	/* If user dragged/dropped a file regardless of keys pressed
	 * at the time, open the first selected file from file
	 * manager.
	 */
	DragQueryFile(hDrop,0,szPath,sizeof(szPath)/sizeof(TCHAR));
	SetActiveWindow(hwnd);

	ResolveIfLink(szPath);

	if (OpenMciDevice(szPath, NULL)) {
	    SubClassMCIWindow();
	    PostMessage(hwnd, WM_COMMAND, (WPARAM)ID_PLAY, 0);
	    DirtyObject(FALSE);             // we're dirty now!
	    gfCloseAfterPlaying = FALSE;    // stay up from now on

		//If the CD Audio device was opened it must have been a *.cda file.
		//Try to jump to the track corresponding to the file opened.
		if ((gwDeviceType & DTMCI_DEVICE) == DTMCI_CDAUDIO)
		{
			HandleCDAFile(szPath);
		}
	}
	else
	{
		gwCurDevice = 0;// force next file open dialog to say
				// "all files" because CloseMCI won't.
		gwCurScale = ID_NONE;  // uncheck all scale types
		Layout(); // Make window snap back to smaller size
	}

	SetMPlayerIcon();

	/* Force WM_GETMINMAXINFO to be called so we'll snap to a */
	/* proper size.                                           */
	GetWindowRect(ghwndApp, &rc);
	MoveWindow(ghwndApp, rc.left, rc.top, rc.right - rc.left,
		    rc.bottom - rc.top, TRUE);
    }
    DragFinish(hDrop);     /* Delete structure alocated for WM_DROPFILES*/
}

/* Change the number in dwPosition to the proper format.  szNum contains the */
/* formatted number only "01 45:10" while szBuf contains units such as       */
/* "01 45:10 (min:sec)"                                                      */
/* If fRound is set, it will not always display millisecond accuracy, but    */
/* choose something useful like second accuracy or hundreth sec accuracy.    */
void FAR PASCAL FormatTime(DWORD_PTR dwPosition, LPTSTR szNum, LPTSTR szBuf, BOOL fRound)
{
    UINT w;
    UINT hrs;
    UINT min;
    UINT sec;
    UINT hsec;
    UINT msec;
    DWORD dwMaxSize = gdwMediaLength;
    static TCHAR framestr[40] = TEXT("");
    static TCHAR sec_str[40] = TEXT("");
    static TCHAR min_str[40] = TEXT("");
    static TCHAR hrs_str[40] = TEXT("");
    static TCHAR msec_str[40] = TEXT("");

	static SZCODE   aszLongDecimal[] = TEXT("%ld");
	static SZCODE   aszFrameFormat[] = TEXT("%"TS" %ld");
	static SZCODE   asz02Decimal[] = TEXT("%02d ");
	static SZCODE   aszTimeFormat1[] = TEXT("%02d%c%02d%c%02d");
	static SZCODE   aszTimeFormat2[] = TEXT("%02d%c%02d%c%02d%c%03d");
	static SZCODE   aszTimeFormat3[] = TEXT("%02d%c%02d%c%02d (%"TS"%c%"TS"%c%"TS")");
	static SZCODE   aszTimeFormat4[] = TEXT("%02d%c%02d%c%02d%c%03d (%"TS"%c%"TS"%c%"TS"%c%"TS")");
	static SZCODE   aszTimeFormat5[] = TEXT("%02d%c%02d");
	static SZCODE   aszTimeFormat6[] = TEXT("%02d%c%02d%c%03d");
	static SZCODE   aszTimeFormat7[] = TEXT("%02d%c%02d (%"TS"%c%"TS")");
	static SZCODE   aszTimeFormat8[] = TEXT("%02d%c%02d%c%03d (%"TS"%c%"TS"%c%"TS")");
	static SZCODE   aszTimeFormat9[] = TEXT("%c%02d");
	static SZCODE   aszTimeFormat10[] = TEXT("%c%03d");
	static SZCODE   aszTimeFormat11[] = TEXT("%02d%c%03d");
	static SZCODE   aszTimeFormat12[] = TEXT("%c%02d (%"TS")");
	static SZCODE   aszTimeFormat13[] = TEXT("%02d%c%02d (%"TS")");
	static SZCODE   aszTimeFormat14[] = TEXT("%c%03d (%"TS"%c%"TS")");
	static SZCODE   aszTimeFormat15[] = TEXT("%02d%c%03d (%"TS"%c%"TS")");


    //!!! LoadStrings at init time, dont hardcode...

    #define ONE_HOUR    (60ul*60ul*1000ul)
    #define ONE_MINUTE  (60ul*1000ul)
    #define ONE_SECOND  (1000ul)

    if (szBuf)
	*szBuf = 0;
    if (szNum)
	*szNum = 0;

    if (gwDeviceID == (UINT)0)
	return;

    if (gwStatus == MCI_MODE_NOT_READY || gwStatus == MCI_MODE_OPEN)
	return;

    switch (gwCurScale) {

    case ID_FRAMES:
	if (!STRLEN(framestr))
	    LOADSTRING(IDS_FRAME,framestr);
	if (szNum)
	    wsprintf(szNum, aszLongDecimal, (long)dwPosition);
	if (szBuf)
	    wsprintf(szBuf, aszFrameFormat, framestr, (long)dwPosition);
	gInc = 1;    // spin arrow inc/dec by one frame
	break;

    case ID_TRACKS:
	//
	//  find the track that contains this position
	//  also, find the longest track so we know if we should display
	//  hh:mm:ss or mm:ss or ss.sss or whatever.
	//

	if (gwNumTracks == 0)
	    return;

	dwMaxSize = 0;

	for (w=0; w<gwNumTracks-1; w++) {

	    if (gadwTrackStart[w+1] - gadwTrackStart[w] > dwMaxSize)
		dwMaxSize = gadwTrackStart[w+1] - gadwTrackStart[w];

	    /* When a CD is stopped, it's still spinning, and after we */
	    /* seek to the beginning of a track, it may return a value */
	    /* slightly less than the track start everyonce in a while.*/
	    /* So if we're within 200ms of the track start, let's just */
	    /* pretend we're exactly on the start of the track.        */

	    if (dwPosition < gadwTrackStart[w+1] &&
		gadwTrackStart[w+1] - dwPosition < 200)
		dwPosition = gadwTrackStart[w+1];

	    if (gadwTrackStart[w+1] > dwPosition)
		break;
	}

	if (szNum) {
	    wsprintf(szNum, asz02Decimal, gwFirstTrack + w);
	    szNum += 3;
	}
	if (szBuf) {
	    wsprintf(szBuf, asz02Decimal, gwFirstTrack + w);
	    szBuf += 3;
	}

	dwPosition -= gadwTrackStart[w];

	for (; w < gwNumTracks - 1; w++) {
	    if (gadwTrackStart[w+1] - gadwTrackStart[w] > dwMaxSize)
		dwMaxSize = gadwTrackStart[w+1] - gadwTrackStart[w];
	}

	// fall through

    case ID_TIME:
	if (!STRLEN(sec_str))
	{
	    LOADSTRING(IDS_SEC,sec_str);
	    LOADSTRING(IDS_HRS,hrs_str);
	    LOADSTRING(IDS_MIN,min_str);
	    LOADSTRING(IDS_MSEC,msec_str);
	}

	min  = (UINT)((dwPosition / ONE_MINUTE) % 60);
	sec  = (UINT)((dwPosition / ONE_SECOND) % 60);
	msec = (UINT)(dwPosition % 1000);

	if (dwMaxSize > ONE_HOUR) {

	    hrs  = (UINT)(dwPosition / ONE_HOUR);

	    if (szNum && fRound) {
		wsprintf(szNum, aszTimeFormat1,
			 hrs, chTime, min, chTime, sec);
	    } else if (szNum) {
		wsprintf(szNum, aszTimeFormat2,
			 hrs, chTime, min, chTime, sec, chDecimal, msec);
	    }

	    if (szBuf && fRound) {
		wsprintf(szBuf, aszTimeFormat3,
			 hrs, chTime, min, chTime, sec, hrs_str,
			 chTime, min_str, chTime, sec_str);
	    } else if (szBuf) {
		wsprintf(szBuf,
			 aszTimeFormat4,
			 hrs, chTime, min, chTime, sec, chDecimal, msec,
			 hrs_str,chTime, min_str,chTime,
			 sec_str, chDecimal, msec_str);
	    }

	    gInc = 1000;    // spin arrow inc/dec by seconds

	} else if (dwMaxSize > ONE_MINUTE) {

	    if (szNum && fRound) {
		wsprintf(szNum, aszTimeFormat5, min, chTime, sec);
	    } else if (szNum) {
		wsprintf(szNum, aszTimeFormat6, min, chTime, sec,
			 chDecimal, msec);
	    }

	    if (szBuf && fRound) {
		wsprintf(szBuf, aszTimeFormat7, min, chTime, sec,
			 min_str,chTime,sec_str);
	    } else if (szBuf) {
		wsprintf(szBuf, aszTimeFormat8,
			 min, chTime, sec, chDecimal, msec,
			 min_str,chTime,sec_str, chDecimal,
			 msec_str);
	    }

	    gInc = 1000;    // spin arrow inc/dec by seconds

	} else {

	    hsec = (UINT)((dwPosition % 1000) / 10);

	    if (szNum && fRound) {
		if (!sec && chLzero == TEXT('0'))
		    wsprintf(szNum, aszTimeFormat9, chDecimal, hsec);
		else
		    wsprintf(szNum, aszTimeFormat5, sec, chDecimal, hsec);

	    } else if (szNum) {
		if (!sec && chLzero == TEXT('0'))
		    wsprintf(szNum, aszTimeFormat10,  chDecimal, msec);
		else
		    wsprintf(szNum, aszTimeFormat11, sec, chDecimal, msec);
	    }

	    if (szBuf && fRound) {
		if (!sec && chLzero == TEXT('0'))
		    wsprintf(szBuf, aszTimeFormat12, chDecimal, hsec, sec_str);
		else
		    wsprintf(szBuf, aszTimeFormat13, sec, chDecimal, hsec, sec_str);

	    } else if (szBuf) {
		if (!sec && chLzero == TEXT('0'))
		    wsprintf(szBuf, aszTimeFormat14,  chDecimal,
			     msec, sec_str,chDecimal,msec_str);
		else
		    wsprintf(szBuf, aszTimeFormat15, sec, chDecimal,
			     msec, sec_str,chDecimal,msec_str);
	    }

	    gInc = 100;    // spin arrow inc/dec by 1/10 second
	}
    }
}


BOOL IsCdromDataOnly();


BOOL UpdateWindowText(HWND hwnd, LPTSTR Text)
{
    TCHAR CurrentText[80];

    GetWindowText(hwnd, CurrentText, CHAR_COUNT(CurrentText));

    if(lstrcmp(Text, CurrentText))
	return SetWindowText(hwnd, Text);
    else
	return TRUE;
}


/*
 * UpdateDisplay()
 *
 * Update the scrollbar, buttons, etc.  If the media information (media
 * length, no. tracks, etc.) is not currently valid, then update it first.
 *
 * The following table shows how the current status (value of <gwStatus>)
 * affects which windows are enabled:
 *
 *                      Play    Pause   Stop    Eject
 *    MCI_MODE_STOP     ENABLE  n/a             ENABLE
 *    MCI_MODE_PAUSE    ENABLE  n/a     ENABLE  ENABLE
 *    MCI_MODE_PLAY     n/a     ENABLE  ENABLE  ENABLE
 *    MCI_MODE_OPEN             n/a             ENABLE
 *    MCI_MODE_RECORD   ??????  ??????  ??????  ??????
 *    MCI_MODE_SEEK     ENABLE  n/a     ENABLE  ENABLE
 *
 *    MCI_MODE_NOT_READY  ALL DISABLED
 *
 * The eject button is always enabled if the medium can be ejected and
 * disabled otherwise.
 *
 * In open mode, either Play or Eject will cause the media door to close,
 * but Play will also begin play.  In any mode, Eject always does an
 * implicit Stop first.
 *
 * If <gwDeviceID> is NULL, then there is no current device and all four
 * of these buttons are disabled.
 *
 */
void FAR PASCAL UpdateDisplay(void)
{
    DWORD_PTR         dwPosition;         /* the current position within the medium */
    UINT          wStatusMCI;         /* status of the device according to MCI  */
#if 0
    TOOLBUTTON    tb;
#endif
    static BOOL   sfBlock = FALSE;    // keep SeekMCI from causing infinite loop

    /* Don't even think about updating the display if the trackbar's scrolling: */
    if (gfScrollTrack)
	return;

    /* We've been re-entered */
    if (sfBlock)
	return;

    /*
     * if for some reason we were closed, close now!
     */
    if (gfErrorDeath) {
	DPF("*** Trying to close window now!\n");
	PostMessage(ghwndApp, gfErrorDeath, 0, 0);
	return;
    }

    /*
     * If the track information is not valid (e.g. a CD was just inserted),
     * then update it.
     *
     */

    if (!gfValidMediaInfo)
	UpdateMCI();                /* update the appropriate global variables*/

    /*
     * Determine the current position and status ( stopped, playing, etc. )
     * as MCI believes them to be.
     *
     */

    wStatusMCI = StatusMCI(&dwPosition);



    /* The deal here is that the user can insert CDs, any of which may not be
     * playable because they contain no audio tracks.  So, as soon as we detect
     * that we have a CD we haven't checked, make sure we can play it.
     * If the current device is CD, and the door isn't open, check it.
     *
     */
    if (((gwDeviceType & DTMCI_DEVICE) == DTMCI_CDAUDIO) &&
	(wStatusMCI != MCI_MODE_OPEN))
    {
	if (!gfCurrentCDChecked)
	{
	    if (IsCdromDataOnly())
	    {
		gfCurrentCDNotAudio = TRUE;
		gwCurScale = ID_NONE;
		Error(ghwndApp, IDS_INSERTAUDIODISC);
	    }
	    else
		gfCurrentCDNotAudio = FALSE;

	    gfCurrentCDChecked = TRUE;
	}
    }
    else
    {
	gfCurrentCDChecked = FALSE; // Otherwise, make sure it gets cleared.
	gfCurrentCDNotAudio = FALSE;
    }


    /* Here's the problem:  If the medium is short, we'll send a Play command */
    /* but it'll stop before we notice it was ever playing.  So if we know    */
    /* that we just sent a PlayMCI command, but the status isn't PLAY, then   */
    /* force the last command to be PLAY.  Also, once we notice we are playing*/
    /* we can clear gfJustPlayed.                                             */

    if (wStatusMCI == MCI_MODE_PLAY && gfJustPlayed)
	gfJustPlayed = FALSE;
    if (((wStatusMCI == MCI_MODE_STOP) || (wStatusMCI == MCI_MODE_SEEK)) && gfJustPlayed) {
	gwStatus = MCI_MODE_PLAY;
	gfJustPlayed = FALSE;
    }

    if (wStatusMCI == MCI_MODE_SEEK) {
	// The second major problem is this.  During rewind the status
	// is SEEK.  If we detect MODE_SEEK we will not restart the play,
	// and it looks like the auto replay simply ended.  Seeking back to
	// the beginning can take a significant amount of time.  We allow
	// ourselves to wait for up to half a second to give the device,
	// particularly AVI from a CD or over the network, a chance to
	// catch up.  Any slower response and the autorepeat will terminate.
	dwPosition = gdwLastSeekToPosition;
	if (!gfUserStopped && (gwOptions&OPT_AUTOREP)) {
	    UINT n=15;
	    for (; n; --n) {

		Sleep(32);
		// If autorepeating and device is seeking, try the status
		// again in case it has got back to the beginning
		wStatusMCI = StatusMCI(&dwPosition);

		if (wStatusMCI != MCI_MODE_SEEK) {
		    wStatusMCI = MCI_MODE_STOP;
		    break; // Exit the FOR loop
		} else {
		    dwPosition = gdwLastSeekToPosition;
		}
	    }
	}
    }

    /*
     * The current device status has
     * changed from the way MPlayer last perceived it, so update the display
     * and make MPlayer agree with MCI again.
     *
     */

    // After we close, our last timer msg must gray stuff and execute this //
    if (!gwDeviceID || wStatusMCI != gwStatus) {
	DWORD    dwEndMedia, dwStartSel, dwEndSel, dwEndSelDelta;

	/* Auto-repeat and Rewind happen if you stop at the end of the media */
	/* (rewind to beginning) or if you stop at the end of the selection  */
	/* (rewind to beginning of selection).                               */

	dwEndMedia = MULDIV32(gdwMediaLength + gdwMediaStart, 99, 100L);
	dwStartSel = (DWORD)SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0);
	dwEndSel = (DWORD)SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0);
	if (dwEndSel != -1) {
	    dwEndSelDelta = MULDIV32(dwEndSel, 99, 100L);
	} else {
	    dwEndSelDelta = 0; // force (dwPosition >= dwEndSelDelta) to FALSE
	}

	if ((wStatusMCI == MCI_MODE_STOP || wStatusMCI == MCI_MODE_PAUSE)
	  && ((dwPosition >= dwEndMedia) || (dwPosition==0) ||
		(dwPosition >= dwEndSelDelta && gfJustPlayedSel))
	  && dwPosition >= gdwMediaStart  // dwPosition may == the beginning
	  && !gfScrollTrack
	  && (gwStatus == MCI_MODE_PLAY || gwStatus == MCI_MODE_SEEK)) {

	    DPF("End of medium\n");

	    /* We're at the end of the entire media or at the end of  */
	    /* our selection now, and stopped automatically (not      */
	    /* by the user).  We were playing or seeking.  So         */
	    /* we can check the Auto Repeat and Auto Rewind flags.    */
	    /* CD players seem to return a length that's too big, so  */
	    /* we check for > 99% done.  Use semaphore to keep from   */
	    /* causing an infinite loop.                              */

	    if (!gfUserStopped && (gwOptions & OPT_AUTOREP)) {
		DPF("Auto-Repeat\n");
		sfBlock = TRUE;    // calls UpdateDisplay which will
				   // re-enter this code just before mode

		/* Repeat either the selection or whole thing.       */
		/* NOTE: Must send message while gwStatus is STOPPED.*/

		gwStatus = wStatusMCI;    // old status no longer valid
		if (gfJustPlayedSel && dwPosition >= dwEndSelDelta)
		{
		    SeekMCI(dwStartSel); // MCICDA doen't go to start w/out this.
		    SendMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAYSEL, 0);
		}
		else
		{
		    SeekToStartMCI();
		    SendMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAY, 0);
		}

		sfBlock = FALSE;    // switches to SEEK.
		gwStatus = (UINT)(-1);  // old status no longer valid
		return;                // because we are switching modes

	    } else if (!gfCloseAfterPlaying && !gfUserStopped &&
			(gwOptions & OPT_AUTORWD)) {
		DPF("Auto-Rewind to media start\n");
		//
		// set gwStatus so SeekMCI will just seek!
		sfBlock = TRUE;    // calls UpdateDisplay which will
		// re-enter this code just before mode
		// switches to SEEK.

		/* Rewind either the selection or whole thing. */
		gwStatus = wStatusMCI;    // or SeekMCI will play, too.
		if (gfJustPlayedSel && dwPosition >= dwEndSelDelta)
		    {
		    SeekMCI(dwStartSel);
			    }
		else
			    {
		    SeekToStartMCI();
			}
		sfBlock = FALSE;
		gwStatus = (UINT)(-1);  // old status no longer valid
		return;    // because we are switching modes
	    }
	    else if (gfCloseAfterPlaying)
		PostCloseMessage();
	}

	/*
	 * Enable or disable the various controls according to the new status,
	 * following the rules given in the header to this function.
	 *
	 */

	EnableWindow(ghwndTrackbar, TRUE); // Good to always have something enabled

	/* Show status bar if full mplayer and if device loaded */
	if (ghwndStatic && !gfPlayOnly)
	{
	    if (IsWindowVisible(ghwndStatic) != (gwDeviceID ? TRUE : FALSE))
	    {
		ShowWindow(ghwndStatic, gwDeviceID ? SW_SHOW : SW_HIDE);
		InvalidateRect(ghwndApp, NULL, TRUE);
	    }
	}

	if (gwDeviceID != (UINT)0 ) {

	    switch (wStatusMCI)
	    {
	    case MCI_MODE_PLAY:
		toolbarSetFocus(ghwndToolbar,BTN_PAUSE);
		break;

	    case MCI_MODE_PAUSE:
	    case MCI_MODE_STOP:
		toolbarSetFocus(ghwndToolbar,BTN_PLAY);
		break;
	    }
	}

	if (wStatusMCI == MCI_MODE_OPEN || wStatusMCI == MCI_MODE_NOT_READY ||
	    gwDeviceID == (UINT)0 ||
	    ((gwDeviceType & DTMCI_DEVICE) == DTMCI_CDAUDIO) && gfCurrentCDNotAudio) {
	    /* Try to modify both -- one of them should work */

	    toolbarModifyState(ghwndToolbar, BTN_PLAY, TBINDEX_MAIN, BTNST_GRAYED);
	    toolbarModifyState(ghwndToolbar, BTN_PAUSE, TBINDEX_MAIN, BTNST_GRAYED);

	    toolbarModifyState(ghwndToolbar, BTN_HOME, TBINDEX_MAIN, BTNST_GRAYED);
	    toolbarModifyState(ghwndToolbar, BTN_END, TBINDEX_MAIN, BTNST_GRAYED);
	    toolbarModifyState(ghwndToolbar, BTN_RWD, TBINDEX_MAIN, BTNST_GRAYED);
	    toolbarModifyState(ghwndToolbar, BTN_FWD, TBINDEX_MAIN, BTNST_GRAYED);

	    SendMessage(ghwndTrackbar, TBM_SETRANGEMIN, (WPARAM)FALSE, 0);
	    SendMessage(ghwndTrackbar, TBM_SETRANGEMAX, (WPARAM)FALSE, 0);
	    SendMessage(ghwndTrackbar, TBM_CLEARTICS, (WPARAM)FALSE, 0);
	    SendMessage(ghwndTrackbar, TBM_CLEARSEL, (WPARAM)TRUE, 0);

	    if (ghwndMark) {
		toolbarModifyState(ghwndMark, BTN_MARKIN, TBINDEX_MARK, BTNST_GRAYED);
		toolbarModifyState(ghwndMark, BTN_MARKOUT, TBINDEX_MARK, BTNST_GRAYED);
	    }

	    if (ghwndFSArrows) {
		toolbarModifyState(ghwndFSArrows, ARROW_NEXT, TBINDEX_ARROWS, BTNST_GRAYED);
		toolbarModifyState(ghwndFSArrows, ARROW_PREV, TBINDEX_ARROWS, BTNST_GRAYED);
	    }

	/* Enable transport and Mark buttons if we come from a state where */
	/* they were gray.  Layout will then re-gray the ones that         */
	/* shouldn't have been enabled because they don't fit.             */
	} else if (gwStatus == MCI_MODE_OPEN || gwStatus == MCI_MODE_NOT_READY
		   || gwStatus == -1 ) {

	    /* Only one of these buttons exists */
	    toolbarModifyState(ghwndToolbar, BTN_PLAY, TBINDEX_MAIN, BTNST_UP);
	    toolbarModifyState(ghwndToolbar, BTN_PAUSE, TBINDEX_MAIN, BTNST_UP);

	if (!gfPlayOnly || gfOle2IPEditing) {
		toolbarModifyState(ghwndToolbar, BTN_HOME, TBINDEX_MAIN, BTNST_UP);
		toolbarModifyState(ghwndToolbar, BTN_END, TBINDEX_MAIN, BTNST_UP);
		toolbarModifyState(ghwndToolbar, BTN_RWD, TBINDEX_MAIN, BTNST_UP);
		toolbarModifyState(ghwndToolbar, BTN_FWD, TBINDEX_MAIN, BTNST_UP);

		if (ghwndMark) {
		    toolbarModifyState(ghwndMark, BTN_MARKIN, TBINDEX_MARK, BTNST_UP);
		    toolbarModifyState(ghwndMark, BTN_MARKOUT, TBINDEX_MARK, BTNST_UP);
		}
		if (ghwndFSArrows) {
		    toolbarModifyState(ghwndFSArrows, ARROW_PREV, TBINDEX_ARROWS, BTNST_UP);
		    toolbarModifyState(ghwndFSArrows, ARROW_NEXT, TBINDEX_ARROWS, BTNST_UP);
		}
	    }
	    /* AND we need to call layout to gray the buttons that are too
	     * short to fit in this window right now.
	     */
	    Layout();
	}

	//
	// always have the stop button if we are playing in place
	//
	if ((gwDeviceID != (UINT)0) &&
	    (wStatusMCI == MCI_MODE_PAUSE ||
	    wStatusMCI == MCI_MODE_PLAY ||
	    wStatusMCI == MCI_MODE_SEEK || gfPlayingInPlace)) {

	    if (toolbarStateFromButton(ghwndToolbar, BTN_STOP, TBINDEX_MAIN) == BTNST_GRAYED)
		toolbarModifyState(ghwndToolbar, BTN_STOP, TBINDEX_MAIN, BTNST_UP);

	} else {
	    toolbarModifyState(ghwndToolbar, BTN_STOP, TBINDEX_MAIN, BTNST_GRAYED);
	}

    if (!gfPlayOnly || gfOle2IPEditing) {
	    if ((gwDeviceID != (UINT)0) && (gwDeviceType & DTMCI_CANEJECT))
		toolbarModifyState(ghwndToolbar, BTN_EJECT, TBINDEX_MAIN, BTNST_UP);
	    else
		toolbarModifyState(ghwndToolbar, BTN_EJECT, TBINDEX_MAIN, BTNST_GRAYED);

	    EnableWindow(ghwndMap, (gwDeviceID != (UINT)0));
    }

// WHO had the idea that setting focus back to play every
// time the status changes was a good idea ??
	/* Only set focus if we won't take activation by doing so */
	//VIJRif (gfAppActive) {
	    if (wStatusMCI == MCI_MODE_NOT_READY) {
		//if (gfAppActive)
		    //SetFocus(ghwndToolbar); //Setting focus messes up menu access
									  //using the ALT key
	    } else if (wStatusMCI != MCI_MODE_SEEK &&
		       gwStatus != MCI_MODE_SEEK) {
		if (wStatusMCI == MCI_MODE_PLAY) {
		    //VIJR SetFocus(ghwndToolbar); // give focus to PAUSE button
		    toolbarSetFocus(ghwndToolbar, BTN_PAUSE);
		} else {
		    //VIJR SetFocus(ghwndToolbar); // give focus to PLAY button
		    toolbarSetFocus(ghwndToolbar, BTN_PLAY);
		    if (wStatusMCI == MCI_MODE_OPEN || wStatusMCI == MCI_MODE_NOT_READY ||
				gwDeviceID == (UINT)0) {
				/* Try to modify both -- one of them should work */
				toolbarModifyState(ghwndToolbar, BTN_PLAY, TBINDEX_MAIN, BTNST_GRAYED);
		    }
		}
	    }
	//VIJR}

	if (wStatusMCI == MCI_MODE_OPEN || gwStatus == MCI_MODE_OPEN
		|| gwStatus == MCI_MODE_NOT_READY
		|| wStatusMCI == MCI_MODE_NOT_READY) {

	    /* Either the medium was just ejected, or it was just
	     * re-inserted -- in either case, the media information (length,
	     * # of tracks, etc.) is currently invalid and needs to be updated.
	     */

	    gfValidMediaInfo = FALSE;
	}

	/*
	 * Set <gwStatus> to agree with what MCI tells us, and update the
	 * display accordingly.
	 *
	 */

	gwStatus = wStatusMCI;
	gfValidCaption = FALSE;
    }

    /*
     * The previous code may have invalidated the Media again, so we'll update
     * now instead of waiting for the next UpdateDisplay call.
     *
     */

    if (!gfValidMediaInfo)
	UpdateMCI();                /* update the appropriate global variables*/

    /* If the caption is not valid, then update it */

    if (!gfValidCaption) {

	TCHAR  ach[_MAX_PATH * 2 + 60];   // string used for the window caption
	TCHAR  achWhatToPrint[_MAX_PATH * 2 + 40];  // room for doc title too

	if (gfPlayOnly) {
	    if (gwDeviceID == (UINT)0)
		lstrcpy(ach, gachAppName);      /* just use the app name */
	    else
		lstrcpy(ach, gachWindowTitle);  /* just use device */
	} else {
	    /* Latest style guide says title bars should have
	     * <object> - <appname>, so do that for anything
	     * other than NT:
	     */
	    if (gwPlatformId == VER_PLATFORM_WIN32_NT)
		wsprintf(achWhatToPrint, aszTitleFormat, gachAppName,
			 gachWindowTitle);
	    else
		wsprintf(achWhatToPrint, aszTitleFormat, gachWindowTitle,
			 gachAppName);

	    if (gwDeviceID == (UINT)0) {
		lstrcpy(ach, gachAppName);      /* just display the app name  */
	    } else if (gwStatus == MCI_MODE_NOT_READY) {
		wsprintf(ach, aszNotReadyFormat,
			 achWhatToPrint);   /*  the current file / device */
	    } else {
		wsprintf(ach, aszReadyFormat,
			 achWhatToPrint,    /*  the current file / device */
			 MapModeToStatusString((WORD)wStatusMCI));
	    }
	}

	if (gfEmbeddedObject) {
	    if (!SetTitle((LPDOC)&docMain, szClientDoc))
		UpdateWindowText(ghwndApp, ach);

	    SetMPlayerIcon();

	} else {
	    UpdateWindowText(ghwndApp, ach);
	}

	gfValidCaption = TRUE;

    }

    /* Update the scrollbar thumb position unless the user is dragging it */
    /* or the media is current seeking to a previously requested position. */

    if (!gfScrollTrack && gfValidMediaInfo && wStatusMCI != MCI_MODE_SEEK) {
	TCHAR ach[40];
		
	if (ghwndStatic) {
	    FormatTime(dwPosition, NULL, ach, TRUE);
	    WriteStatusMessage(ghwndStatic, ach);
	}
	SendMessage(ghwndTrackbar, TBM_SETPOS, (WPARAM)TRUE, dwPosition);
    }

    /* Finish any required window painting immediately */

    if (gfOle2IPEditing && wStatusMCI == MCI_MODE_STOP &&
	((gwDeviceType & DTMCI_DEVICE) == DTMCI_AVIVIDEO))
    {
	RedrawWindow(ghwndTrackbar, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
    }
    UpdateWindow(ghwndApp);
}


/*
 * EnableTimer(fEnable)
 *
 * Enable the display-update timer if <fEnable> is TRUE.
 * Disable the timer if <fEnable> is FALSE.
 *
 */

void FAR PASCAL EnableTimer(BOOL fEnable)
{
    DPF("EnableTimer(%d)  %dms\n", fEnable, gfAppActive ? UPDATE_MSEC : UPDATE_INACTIVE_MSEC);

    if (fEnable)
	SetTimer(ghwndApp, UPDATE_TIMER,
		 gfAppActive ? UPDATE_MSEC : UPDATE_INACTIVE_MSEC, NULL);
    else
	KillTimer(ghwndApp, UPDATE_TIMER);
}


void FAR PASCAL Layout(void)
{
    RECT    rcClient, rc;
    int     iYOffset;
    UINT    wWidth;
    UINT    wFSArrowsWidth = 2 * FSARROW_WIDTH - 1; // 2 arrow buttons wide
    UINT    wFSArrowsHeight = FSARROW_HEIGHT;
    UINT    wFSTrackHeight = FSTRACK_HEIGHT;
    UINT    wFSTrackWidth;
    UINT    wToolbarWidth;
    UINT    wMinStatusWidth = 0;
    int     iYPosition;
    BOOL    fShowMark;
    BOOL    fShowTrackbar;
    BOOL    fShowStatus;
    HDWP    hdwp;
    int     nState;     // The status of the transport buttons (when visible)
    DWORD_PTR   dw;         // the current position within the medium
    UINT    wStatusMCI; // status of the device according to MCI
    UINT    wBaseUnits;
    BOOL    fRedrawFrame;
    SIZE    StatusTextExtent;
    BOOL    fRepaintToolbar;    // TRUE if we remove or add something to toolbar area

    /* OK to execute if we're hidden to set ourselves up for being shown */

    if (sfInLayout || IsIconic(ghwndApp))
	return;

    if (gfInPlayMCI) {
	DPF("Layout() called when in PlayMCI().  Posting message to Layout() later.\n");
	/* Don't allow this to happen, because Layout() may cause a call to
	 * MCI_PUT (via SetWindowPos(ghwndMCI)), which will result in a
	 * device-not-ready error, as the MCI_PLAY hasn't completed.
	 */
	PostMessage(ghwndApp, WM_DOLAYOUT, 0, 0);
	return;
    }

    sfInLayout = TRUE;

#ifdef DEBUG
    GetWindowRect(ghwndApp, &rc);
    DPF("***** Layout Window Rect *****  %d %d\n", rc.right - rc.left, rc.bottom - rc.top);
#endif

    if (gfPlayOnly) {

	extern UINT gwPlaybarHeight;    // in server.c

#define XSLOP   0
#define XOFF    2


	if (gfOle2IPEditing || gfOle2IPPlaying)
	{
	    /* Don't call GetClientrect, because the window may have a border,
	     * and this will cause us to shrink the window.
	     * Note this is a hack to get around the problem of the window
	     * changing size when it is in place, making some displays dither
	     * the video in a disgusting manner.
	     */
	    GetWindowRect(ghwndApp, &rc);
	    rc.right -= rc.left;
	    rc.bottom -= rc.top;
	    rc.left = rc.top = 0;
	}
	else
	    GetClientRect(ghwndApp, &rc);

	rc.bottom -= gwPlaybarHeight;

#if 0
	/* If we set WS_MAXIMIZE, user doesn't allow the window to be
	 * sized on NT.  What's the idea behind this code anyway?
	 */

	if (ghwndMCI && !EqualRect(&rc, &grcSize))
	    fRedrawFrame = SetWS(ghwndApp, WS_MAXIMIZE /* |WS_MAXIMIZEBOX */);
	else if (ghwndMCI)
	    fRedrawFrame = //SetWS(ghwndApp, WS_MAXIMIZEBOX) ||
			   ClrWS(ghwndApp, WS_MAXIMIZE);
	else
	    fRedrawFrame = ClrWS(ghwndApp, WS_MAXIMIZEBOX);
#endif
	fRedrawFrame = FALSE;

	/* Here's another horrible hack.
	 * When you try to Play an in-place video after an Open (OLE),
	 * the toolbar and trackbar don't get drawn correctly.
	 * I haven't figured out why this is, but forcing a redraw
	 * seems to fix it.  This code gets executed only when the window
	 * position changes, so it isn't too much of a hit.
	 */
	if (gfOle2IPEditing || gfOle2IPPlaying)
	    fRedrawFrame = TRUE;

	if (fRedrawFrame)
	    SetWindowPos(ghwndApp,
			 NULL,
			 0,
			 0,
			 0,
			 0,
	      SWP_DRAWFRAME|SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);

	if (ghwndMCI)
	    SetWindowPos(ghwndMCI,
			 NULL,
			 0,
			 0,
			 rc.right,
			 rc.bottom,
			 SWP_NOZORDER|SWP_NOACTIVATE);

	//  If we are inplace editing place controls on the ghwndIPToolWindow
	//  and the static window at the bottom of ghwndApp.
	if(gfOle2IPEditing) {

	    SendMessage(ghwndTrackbar, TBM_SHOWTICS, TRUE, FALSE);

	    SetWindowPos(ghwndStatic,
			 NULL,
			 3,
			 rc.bottom + 2 + (gwPlaybarHeight - TOOLBAR_HEIGHT)/2,
			 rc.right - rc.left - 8,
			 TOOLBAR_HEIGHT-7,
			 SWP_NOZORDER|SWP_NOACTIVATE);

	// Why are we getting the Status here when we have a global that
	// contains it?  Because gwStatus is set in UpdateDisplay, but
	// Layout() is called by UpdateDisplay, so the global is not always
	// set properly when this code runs.  BUT!  We must NOT pass a string
	// to StatusMCI() or it will think UpdateDisplay() called it, and
	// not tell UpdateDisplay() the proper mode next time it asks for it,
	// because it will think that it already knows it.

	    wStatusMCI = StatusMCI(NULL);
	    nState = (wStatusMCI == MCI_MODE_OPEN
		       || wStatusMCI == MCI_MODE_NOT_READY
		       || gwDeviceID == (UINT) 0)
		     ? BTNST_GRAYED
		     : BTNST_UP;

	    toolbarModifyState(ghwndToolbar, BTN_HOME, TBINDEX_MAIN, nState);
	    toolbarModifyState(ghwndToolbar, BTN_RWD, TBINDEX_MAIN, nState);
	    toolbarModifyState(ghwndToolbar, BTN_FWD, TBINDEX_MAIN, nState);
	    toolbarModifyState(ghwndToolbar, BTN_END, TBINDEX_MAIN, nState);

	    ShowWindow(ghwndTrackbar, SW_SHOW);
	    ShowWindow(ghwndToolbar, SW_SHOW);
	    ShowWindow(ghwndStatic, SW_SHOW);
	    ShowWindow(ghwndFSArrows, SW_SHOW);
	    ShowWindow(ghwndMark, SW_SHOW);
	    ShowWindow(ghwndMap, SW_SHOW);

	    if (ghwndIPToolWindow && (ghwndIPToolWindow != GetParent(ghwndTrackbar))
		      && (ghwndIPScrollWindow != GetParent(ghwndTrackbar)))
	    {
		SetParent(ghwndTrackbar,ghwndIPToolWindow);
		SetWindowPos(ghwndTrackbar, NULL,4,TOOL_WIDTH+2,
		     11*BUTTONWIDTH+3,FSTRACK_HEIGHT,SWP_NOZORDER | SWP_NOACTIVATE);
		SetParent(ghwndMap,ghwndIPToolWindow);
		SetWindowPos(ghwndMap, NULL,4,TOOL_WIDTH+FSTRACK_HEIGHT+2+2,
		     11*BUTTONWIDTH+50,MAP_HEIGHT,SWP_NOZORDER | SWP_NOACTIVATE);
	    }
	    CalcTicsOfDoom();

	} else {

#define LEFT_MARGIN 1

	    SendMessage(ghwndTrackbar, TBM_SHOWTICS, FALSE, FALSE);

	    SetWindowPos(ghwndToolbar,
			 NULL,
			 LEFT_MARGIN,
			 rc.bottom + 2 + (gwPlaybarHeight - TOOLBAR_HEIGHT)/2,
			 XSLOP + 2 * (BUTTONWIDTH - XOFF),
			 TOOLBAR_HEIGHT,
			 SWP_NOZORDER|SWP_NOACTIVATE);

	    SetWindowPos(ghwndTrackbar,
			 NULL,
			 XSLOP + 2 * (BUTTONWIDTH - XOFF) + LEFT_MARGIN,
			 rc.bottom + (gwPlaybarHeight - TOOLBAR_HEIGHT)/2 + 1,
			 rc.right-rc.left-(2 * XSLOP + 2 *(BUTTONWIDTH - XOFF) - LEFT_MARGIN),
			 TOOLBAR_HEIGHT - 1,
			 SWP_NOZORDER | SWP_NOACTIVATE);

	    // HACK!!!
	    // If we aren't visible, officially disable ourselves so that the
	    // trackbar shift code won't try and set selection

	    ShowWindow(ghwndTrackbar, gwPlaybarHeight > 0 ? SW_SHOW : SW_HIDE);
	    ShowWindow(ghwndToolbar, gwPlaybarHeight > 0 ? SW_SHOW : SW_HIDE);
	    ShowWindow(ghwndStatic, SW_HIDE);
	    ShowWindow(ghwndFSArrows, SW_HIDE);
	    ShowWindow(ghwndMark, SW_HIDE);
	    ShowWindow(ghwndMap, SW_HIDE);
	}

	goto Exit_Layout;
    }

    fRedrawFrame = ClrWS(ghwndApp, WS_MAXIMIZEBOX);

    if (fRedrawFrame)
	SetWindowPos(ghwndApp, NULL, 0, 0, 0, 0, SWP_DRAWFRAME|
	    SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);

    if (GetMenu(ghwndApp) != ghMenu)
	SetMenu(ghwndApp, ghMenu);

    wBaseUnits = LOWORD(GetDialogBaseUnits());  // prop. to size of system font

    /* If we're bigger than we're allowed to be then shrink us right now */
    GetWindowRect(ghwndApp, &rc);

    gwHeightAdjust = GetHeightAdjust(ghwndApp);

    DPF1("Layout: WindowRect = %x, %x, %x, %x\n", rc);

    if (rc.bottom - rc.top != (int)(MAX_NORMAL_HEIGHT + gwHeightAdjust)) {
	MoveWindow(ghwndApp,
		   rc.left,
		   rc.top,
		   rc.right - rc.left,
		   (int)(MAX_NORMAL_HEIGHT + gwHeightAdjust),
		   TRUE);
    }


    hdwp = BeginDeferWindowPos(6);

    if (!hdwp)
	goto Exit_Layout;

    GetClientRect(ghwndApp, &rcClient);    // get new size

    wWidth = rcClient.right;

    iYOffset = rcClient.bottom - MAX_NORMAL_HEIGHT + 2;    // start here

    /* ??? Hide the trackbar if it can't fit on completely ??? */
    iYPosition = iYOffset >= 0 ? iYOffset :
		((iYOffset >= - 9) ? iYOffset + 9 : 1000);

    fShowTrackbar = (iYOffset >= - 9);

    /* Focus in on trackbar which is about to go away */
    if (!fShowTrackbar && GetFocus() == ghwndTrackbar)
	SetFocus(ghwndToolbar);

    ShowWindow(ghwndToolbar, SW_SHOW);

/* The space that COMMCTRL puts to the left of the first toolbar button:
 */
#define SLOPLFT 0
#define XOFF1   8

    // how long did it end up being?
    wFSTrackWidth = wWidth - SB_XPOS - 1 - wFSArrowsWidth - SLOPLFT;

    DeferWindowPos(hdwp,
		   ghwndTrackbar,
		   HWND_TOP,
		   SB_XPOS,
		   iYPosition,
		   wFSTrackWidth,
		   wFSTrackHeight,
		   SWP_NOZORDER | SWP_NOREDRAW |
		       (fShowTrackbar ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));


    /* Toolbar positioning:
     *
     * If the window is not wide enough to accommodate all the buttons
     * and status bar, here's what we do:
     *
     * If the status bar is invisible, first remove the mark buttons,
     * then use the small control width (with only three buttons).
     *
     * If the status bar is visible, give it priority over the mark
     * buttons and the extra controls, but remove it if there isn't
     * room for it and the small control width.
     */

    if (gwDeviceID)
    {
	fShowStatus = TRUE;

	if (GetStatusTextExtent(ghwndStatic, &StatusTextExtent))
	{
	    RECT rc;
	    LONG StatusWidth;   /* Total width of status window */
	    LONG TextAreaWidth; /* Width minus border and size grip */

	    /* Allow for the border around the status window:
	     */
	    GetWindowRect(ghwndStatic, &rc);
	    StatusWidth = rc.right - rc.left;

	    SendMessage(ghwndStatic, SB_GETRECT, 0, (LPARAM)&rc);
	    TextAreaWidth = rc.right - rc.left;

	    wMinStatusWidth = StatusTextExtent.cx + (StatusWidth - TextAreaWidth) + 16;
	}
    }
    else
    {
	fShowStatus = FALSE;
    }

    wToolbarWidth = LARGE_CONTROL_WIDTH + SLOPLFT;
    fShowMark = TRUE;

    if (wWidth < LARGE_CONTROL_WIDTH + SLOPLFT + MARK_WIDTH + XOFF1 + wMinStatusWidth)
    {
	fShowMark = FALSE;

	if (wWidth < LARGE_CONTROL_WIDTH + SLOPLFT + wMinStatusWidth)
	    wToolbarWidth = SMALL_CONTROL_WIDTH + SLOPLFT;

	if (wWidth < SMALL_CONTROL_WIDTH + SLOPLFT + wMinStatusWidth)
	    fShowStatus = FALSE;
    }

    fRepaintToolbar = FALSE;

    /* If we're adding or removing the mark buttons or the status window,
     * make sure we repaint things so that the separator bar corresponds.
     * (It should separate the status window from the buttons, but should
     * go away when the status window does.)
     */
    if (IsWindowVisible(ghwndStatic) != fShowStatus)
	fRepaintToolbar = TRUE;
    else if (IsWindowVisible(ghwndMark) != fShowMark)
	fRepaintToolbar = TRUE;

    ShowWindow(ghwndStatic, fShowStatus);

    /* Turn off the toolbar (for tabbing) if it's not going to be there */
    /* and if we're disabled, we better not keep the focus.             */
    if (!fShowMark) {
	if (GetFocus() == ghwndMark)
	    SetFocus(ghwndToolbar);  // can't give it to SB, might be gone too
	EnableWindow(ghwndMark, FALSE);
    } else
	EnableWindow(ghwndMark, TRUE);

    DeferWindowPos(hdwp,
		   ghwndFSArrows,
		   HWND_TOP,
		   SB_XPOS + wFSTrackWidth,
//                 wWidth - 1 - wFSArrowsWidth,
		   iYPosition + 2,
		   wFSArrowsWidth + SLOPLFT,
		   wFSArrowsHeight + 4, /* Er, 4 because it works */
		   SWP_NOZORDER);

    iYOffset += wFSTrackHeight;

    DeferWindowPos(hdwp,
		   ghwndMap,
		   HWND_TOP,
		   SB_XPOS,
		   iYOffset,
		   wWidth - SB_XPOS,
		   MAP_HEIGHT,
		   SWP_NOZORDER | SWP_NOREDRAW |
		      (fShowTrackbar ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));
    iYOffset += MAP_HEIGHT;

    /* Do we show the last four buttons on the main toolbar? */
    /* If not, then disable them for tabs and such.          */
    if (wToolbarWidth == LARGE_CONTROL_WIDTH + SLOPLFT)
    {

	// Why are we getting the Status here when we have a global that
	// contains it?  Because gwStatus is set in UpdateDisplay, but
	// Layout() is called by UpdateDisplay, so the global is not always
	// set properly when this code runs.  BUT!  We must NOT pass a string
	// to StatusMCI() or it will think UpdateDisplay() called it, and
	// not tell UpdateDisplay() the proper mode next time it asks for it,
	// because it will think that it already knows it.

	wStatusMCI = StatusMCI(&dw);
	nState = (wStatusMCI == MCI_MODE_OPEN
		    || wStatusMCI == MCI_MODE_NOT_READY
		    || gwDeviceID == (UINT)0) ? BTNST_GRAYED : BTNST_UP;

	toolbarModifyState(ghwndToolbar, BTN_HOME, TBINDEX_MAIN, nState);
	toolbarModifyState(ghwndToolbar, BTN_RWD, TBINDEX_MAIN, nState);
	toolbarModifyState(ghwndToolbar, BTN_FWD, TBINDEX_MAIN, nState);
	toolbarModifyState(ghwndToolbar, BTN_END, TBINDEX_MAIN, nState);
	toolbarModifyState(ghwndToolbar, BTN_PLAY, TBINDEX_MAIN, nState);
    }
    else
    {
	toolbarModifyState(ghwndToolbar, BTN_HOME, TBINDEX_MAIN, BTNST_GRAYED);
	toolbarModifyState(ghwndToolbar, BTN_RWD, TBINDEX_MAIN, BTNST_GRAYED);
	toolbarModifyState(ghwndToolbar, BTN_FWD, TBINDEX_MAIN, BTNST_GRAYED);
	toolbarModifyState(ghwndToolbar, BTN_END, TBINDEX_MAIN, BTNST_GRAYED);
    }

    DeferWindowPos(hdwp,
		   ghwndToolbar,
		   HWND_TOP,
		   2,
		   iYOffset + 2,
		   wToolbarWidth,
		   TOOLBAR_HEIGHT,
		   SWP_NOZORDER);

    DeferWindowPos(hdwp,
		   ghwndMark,
		   HWND_TOP,
		   wToolbarWidth + XOFF1,
		   iYOffset + 2,
		   MARK_WIDTH,
		   TOOLBAR_HEIGHT,
		   SWP_NOZORDER | (fShowMark ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));

#define ARBITRARY_Y_OFFSET  4

    DeferWindowPos(hdwp,
		   ghwndStatic,
		   HWND_TOP,
		   wToolbarWidth + (fShowMark ? MARK_WIDTH + XOFF1 : 0) + XOFF1,
		   iYOffset + ARBITRARY_Y_OFFSET,
		   wWidth - (wToolbarWidth + 3) -
		      (fShowMark ? MARK_WIDTH + XOFF1 : 0) - XOFF1,
		   TOOLBAR_HEIGHT - 6,
		   SWP_NOZORDER);

    EndDeferWindowPos(hdwp);

    if (fRepaintToolbar)
    {
	InvalidateRect(ghwndApp, NULL, TRUE);
    }

    CalcTicsOfDoom();

/* These little gems have just cost me about ten hours worth of debugging -
 * note the useful and descriptive comments...
 *
 * The Win32 problem caused by this only arises with CD Audio, when the disk is
 * ejected and then another one is inserted into the drive. At that point
 * the redrawing misses out the Trackmap FSArrows, the borders on the
 * Mark buttons, and various bits of the toolbar.
 *
 * I will leave this here on the assumption that whichever bout 
 * on Win16 they are intended to fix still exists - it certainly doesn't on
 * Win32.
 */


Exit_Layout:
    sfInLayout = FALSE;
    return;
}


/* What is the previous mark from our current spot? */
LONG_PTR CalcPrevMark(void)
{
    LONG_PTR lStart, lEnd, lPos, lTol, lTrack = -1, lTarget;
    LONG_PTR l;

    lStart = SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0);
    lEnd = SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0);
    lPos = SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0);

    /* Find the next track we should go to (ignore selection markers) */
    if (gwCurScale == ID_TRACKS) {
	lTol = (LONG)gdwMediaLength / 2000;
	for (l = (LONG)gwNumTracks - 1; l >= 0; l--) {
	    if (gadwTrackStart[l] < (DWORD)lPos - lTol) {
		lTrack = gadwTrackStart[l];
		break;
	    }
	}
    }

    /* For msec mode:                                                     */
    /* Our current position fluctuates randomly and even if we're dead on */
    /* a selection mark, it might say we're a little before or after it.  */
    /* So we'll allow a margin for error so that you don't forever stay   */
    /* still while you hit PrevMark because it happens to be saying you're*/
    /* always past the mark you're at.  The margin of error will be       */
    /* half the width of the thumb.                                       */

    if (gwCurScale == ID_FRAMES)
	lTol = 0L;
    else
	lTol = 0L;//VIJR-TBTrackGetLogThumbWidth(ghwndTrackbar) / 2;

    if (lEnd != -1 && lPos > lEnd + lTol)
	lTarget = lEnd;
    else if (lStart != -1 && lPos > lStart + lTol)
	lTarget = lStart;
    else
	lTarget = 0;

    /* go to the either the selection mark or the next track (the closest) */
    if (lTrack != -1 && lTrack > lTarget)
	lTarget = lTrack;

    return lTarget;
}

/* What is the next mark from our current spot? */
LONG_PTR CalcNextMark(void)
{
    LONG_PTR lStart, lEnd, lPos, lTol, lTrack = -1, lTarget;
    UINT_PTR w;

    lStart = SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0);
    lEnd = SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0);
    lPos = SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0);

    /* Find the next track we should go to (ignore selection markers) */
    if (gwCurScale == ID_TRACKS) {
	lTol = (LONG)gdwMediaLength / 2000;
	for (w = 0; w < gwNumTracks; w++) {
	    if (gadwTrackStart[w] > (DWORD)lPos + lTol) {
		lTrack = gadwTrackStart[w];
		break;
	    }
	}
    }

    /* For msec mode:                                                     */
    /* Our current position fluctuates randomly and even if we're dead on */
    /* a selection mark, it might say we're a little before or after it.  */
    /* So we'll allow a margin for error so that you don't forever stay   */
    /* still while you hit NextMark because it happens to be saying you're*/
    /* always before the mark you're at.  The margin of error will be     */
    /* half the width of the thumb.                                       */

    if (gwCurScale == ID_FRAMES)
	lTol = 0L;
    else
	lTol = 0L;//VIJR-TBTrackGetLogThumbWidth(ghwndTrackbar) / 2;

    /* Find the selection mark we should go to */
    if (lStart != -1 && lPos < lStart - lTol)
	lTarget = lStart;
    else if (lEnd != -1 && lPos < lEnd - lTol)
	lTarget = lEnd;
    else
	lTarget = gdwMediaStart + gdwMediaLength;

    /* go to the either the selection mark or the next track (the closest) */
    if (lTrack != -1 && lTrack < lTarget)
	lTarget = lTrack;

    return lTarget;
}


HICON GetIconFromProgID(LPTSTR szProgID)
{
    DWORD Status;
    HKEY  hkeyDefaultIcon;
    BOOL  rc = FALSE;
    DWORD Type;
    DWORD Size;
    TCHAR szProgIDDefaultIcon[128];
    TCHAR szDefaultIcon[MAX_PATH+4];    /* <path>,N */
    HICON hicon = NULL;
    LPTSTR pIconIndex;
    UINT  IconIndex;

    wsprintf(szProgIDDefaultIcon, TEXT("%s\\DefaultIcon"), szProgID);

    Status = RegOpenKeyEx( HKEY_CLASSES_ROOT, szProgIDDefaultIcon, 0,
			   KEY_READ, &hkeyDefaultIcon );

    if (Status == NO_ERROR)
    {
	Size = CHAR_COUNT(szDefaultIcon);

	Status = RegQueryValueEx( hkeyDefaultIcon,
				  aszNULL,
				  0,
				  &Type,
				  (LPBYTE)szDefaultIcon,
				  &Size );

	if (Status == NO_ERROR)
	{
	    /* Find a comma in the string.  After it comes the icon index:
	     */
	    pIconIndex = STRCHR(szDefaultIcon, TEXT(','));

	    if (pIconIndex)
	    {
		/* Null terminate the file name:
		 */
		*pIconIndex = TEXT('\0');

		/* Get the index that comes after the comma:
		 */
		IconIndex = ATOI(pIconIndex+1);

		DPF1("Extracting icon #%d from %"DTS"\n", IconIndex, szDefaultIcon);

		hicon = ExtractIcon(ghInst, szDefaultIcon, IconIndex);
	    }

	}
	else
	{
	    DPF0("Couldn't find Default Icon for %"DTS"\n", szProgID);
	}

	RegCloseKey(hkeyDefaultIcon);
    }

    return hicon;
}



/* GetIconForCurrentDevice
 *
 * Checks what device is currently selected, and returns a handle to the
 * appropriate icon of the specified size.  If there is no current device,
 * returns either the application's icon or the default icon for media
 * documents.
 *
 * Parameters:
 *
 *     Size - GI_SMALL (for title bar) or GI_LARGE (for in-place icon).
 *
 *     DefaultID - Default to use if no current device.  APPICON or IDI_DDEFAULT.
 *
 * Return:
 *
 *     Icon handle
 *
 *
 * Andrew Bell (andrewbe), 31 March 1995
 */
HICON GetIconForCurrentDevice(UINT Size, UINT DefaultID)
{
    TCHAR  DeviceName[256];
    DWORD  i;
    LPTSTR ImageID = NULL;
    int    cx;
    int    cy;
    HICON  hIcon;

    GetDeviceNameMCI(DeviceName, BYTE_COUNT(DeviceName));

    if (DeviceName[0])
    {
	for (i = 0; i < sizeof DevToIconIDMap / sizeof *DevToIconIDMap; i++)
	{
	    if (!lstrcmpi(DeviceName, DevToIconIDMap[i].pString))
	    {
		ImageID = MAKEINTRESOURCE(DevToIconIDMap[i].ID);
		break;
	    }
	}
    }

    else
    {
	if (Size == GI_LARGE)
	{

	    hIcon = GetIconFromProgID(gachProgID);

	    if (hIcon)
	    {
		return hIcon;
	    }
	}
    }

    if (ImageID == NULL)
	ImageID = MAKEINTRESOURCE(DefaultID);

    cx = (Size == GI_SMALL ? GetSystemMetrics(SM_CXSMICON) : 0);
    cy = (Size == GI_SMALL ? GetSystemMetrics(SM_CYSMICON) : 0);

    hIcon = (HICON)LoadImage(ghInst, ImageID, IMAGE_ICON,
			     cx, cy, LR_DEFAULTSIZE);

    return hIcon;
}


/* SetMPlayerIcon
 *
 * Sets the icon based upon the current device.  Uses default document
 * icon if embedded, otherwise the application icon.
 *
 * Andrew Bell (andrewbe), 31 March 1995
 */
void SetMPlayerIcon()
{
    UINT DefaultID;

    DefaultID = gfEmbeddedObject ? IDI_DDEFAULT : APPICON;

    SendMessage(ghwndApp, WM_SETICON, FALSE,
		(LPARAM)GetIconForCurrentDevice(GI_SMALL, DefaultID));
}


/*--------------------------------------------------------------+
| AskUpdate -     ask the user if they want to update the       |
|                 object (if we're dirty).                      |
|                 IDYES means yes, go ahead and update please.  |
|                 IDNO means don't update, but continue.        |
|                 IDCANCEL means don't update, and cancel what  |
|                    you were doing.                            |
+--------------------------------------------------------------*/
int NEAR PASCAL AskUpdate(void)
{
    UINT         w;

    /* Don't update object if no device is loaded into mplayer! */
    if (IsObjectDirty() && gfDirty != -1 && gfEmbeddedObject && gwDeviceID) {

	if((glCurrentVerb == OLEIVERB_PRIMARY) && !gfOle2IPEditing)
	    return IDNO;
	//
	//  if we are a hidden MPlayer (most likely doing a Play verb) then
	//  update without asking?
	//
	if (!IsWindowVisible(ghwndApp) || gfOle2IPEditing)
	    return IDYES;

	w = ErrorResBox(ghwndApp, ghInst,
		MB_YESNOCANCEL | MB_ICONQUESTION,
		IDS_APPNAME, IDS_UPDATEOBJECT, szClientDoc);

    } else
	w = IDNO;

    return w;
}

void SizePlaybackWindow(int dx, int dy)
{
    RECT rc;
    HWND hwndPlay;

    if (gfPlayOnly) {
	SetRect(&rc, 0, 0, dx, dy);
	SetMPlayerSize(&rc);
    }
    else {
	if (dx == 0 && dy == 0) {
	    SetMPlayerSize(NULL);   // size MPlayer to default size
	    dx = grcSize.right;     // then size the playback window too.
	    dy = grcSize.bottom;
	}
	hwndPlay = GetWindowMCI();

	if (hwndPlay != NULL) {

	    /* make sure that the play window isn't iconized */

	    if (IsIconic(hwndPlay))
		return;

	    GetClientRect(hwndPlay, &rc);
	    ClientToScreen(hwndPlay, (LPPOINT)&rc);
	    SetRect(&rc, rc.left, rc.top, rc.left+dx, rc.top+dy);
	    PutWindowMCI(&rc);
	    SetRect(&rc, 0, 0, dx, dy);
	    SetDestRectMCI(&rc);
	}
    }
}


/* StartSndVol
 *
 * Kicks off the Sound Volume app asynchronously so we don't hang the UI.
 */
VOID StartSndVol( )
{
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInformation;

    memset( &StartupInfo, 0, sizeof StartupInfo );
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.wShowWindow = SW_SHOW;

    CreateProcess( NULL, szSndVol32, NULL, NULL, FALSE, 0,
		   NULL, NULL, &StartupInfo, &ProcessInformation );

    ExitThread( 0 );
}


/* GetHeightAdjust
 *
 * Finds the real height adjustment needed, by subtracting the client
 * height from the main window height.  This allows for menus that
 * have wrapped.
 */
int GetHeightAdjust(HWND hwnd)
{
    RECT rcWindow;
    RECT rcClient;
    int  WindowHeight;
    int  ClientHeight;

    GetWindowRect(hwnd, &rcWindow);
    GetClientRect(hwnd, &rcClient);
    WindowHeight = rcWindow.bottom - rcWindow.top;
    ClientHeight = rcClient.bottom - rcClient.top;

    return WindowHeight - ClientHeight;
}


/* Message-cracking routines for MPlayerWndProc:
 */

BOOL MPlayer_OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    InitMPlayerDialog(hwnd);

    /* set off a thread to check that the OLE registry stuff is not corrupted  */

#ifdef CHICAGO_PRODUCT
    /* If this is the Chicago Media Player, only mess with the registry
     * if we're actually running on that platform.
     * The guy may be running it on NT.
     */
    if (gwPlatformId != VER_PLATFORM_WIN32_WINDOWS)
	return TRUE;
#endif

    if (!IgnoreRegCheck())
	BackgroundRegCheck(hwnd);

	//Register for WM_DEVICECHANGE notification.
	DeviceChange_Init(hwnd);

    return TRUE;
}


void MPlayer_OnShowWindow(HWND hwnd, BOOL fShow, UINT status)
{
    if (fShow)
	Layout();    // we're about to be shown and want to set
}


void MPlayer_OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    /* Don't waste time Layout()ing if we're not visible */
    if (state != SIZE_RESTORED || IsWindowVisible(hwnd)) {

	Layout();

	// If we are inplace editing, our size change must be informed
	// to the container, unless the size change was a result of a
	// OnPosRectChange sent to us by the container.
	if ((gfOle2IPEditing || gfOle2IPPlaying) && ghwndMCI) {

	    RECT rc;
	    RECT rcPrev;

	    rcPrev = gInPlacePosRect;
	    GetWindowRect(ghwndApp, &gInPlacePosRect);
	    gfInPlaceResize = TRUE;
	    rc = gInPlacePosRect;

	    /* Check that the previous rect wasn't empty, otherwise we send
	     * a bogus OLE_CHANGED on startup.
	     */
	    if (!gfPosRectChange /*&& !IsRectEmpty(&rcPrev)*/) {

		MapWindowPoints(NULL,ghwndCntr,(POINT FAR *)&rc,(UINT)2);

		DPF("IOleInPlaceSite::OnPosRectChange %d, %d, %d, %d\n", rc);
		if (!gfInPPViewer)
		    IOleInPlaceSite_OnPosRectChange(docMain.lpIpData->lpSite, &rc);
		fDocChanged = TRUE;
		SendDocMsg((LPDOC)&docMain, OLE_CHANGED);
	    }

	    gfPosRectChange = FALSE;
	}
    }
}


BOOL MPlayer_OnWindowPosChanging(HWND hwnd, LPWINDOWPOS lpwpos)
{
#define SNAPTOGOODSIZE
#ifdef SNAPTOGOODSIZE
    BOOL    wHeight;
#endif

    DPF2("ENTER OnWindowPosChanging: lpwpos = %x, %x, %x, %x\n", *((PPOS)&lpwpos->x));

    if (IsIconic(hwnd) || gfPlayOnly)
	return TRUE;

    /* posSizeMove contains the height we want to be when sizing.
     * Don't let the system tell us otherwise.
     */
    if (posSizeMove.cx != 0)
    {
	lpwpos->cy = posSizeMove.cy;
	posSizeMove = *(PPOS)&lpwpos->x;
    }

    else if (!(lpwpos->flags & SWP_NOSIZE)) {

#ifdef SNAPTOGOODSIZE
	/* We should also do things here to make the window
	** snap to good sizes */
	wHeight = lpwpos->cy - gwHeightAdjust;
//        if (lpwpos->cy >= (int) gwHeightAdjust + MAX_NORMAL_HEIGHT) {
//        } else if (lpwpos->cy < (int) gwHeightAdjust +
//                    ((MIN_NORMAL_HEIGHT + MAX_NORMAL_HEIGHT) / 2)) {
//            lpwpos->cy = (int) gwHeightAdjust + MIN_NORMAL_HEIGHT;
//        } else {
	    lpwpos->cy = (int) gwHeightAdjust + MAX_NORMAL_HEIGHT;
//        }
#endif
    }

    DPF2("EXIT  OnWindowPosChanging: lpwpos = %x, %x, %x, %x\n", *((PPOS)&lpwpos->x));

    return FALSE;
}


BOOL MPlayer_OnWindowPosChanged(HWND hwnd, LPWINDOWPOS lpwpos)
{
    if (!IsIconic(hwnd) && !gfPlayOnly && !gfOle2IPEditing && !gfOle2IPPlaying)
    {
	/* The problem here is that we want to modify the height of the
	 * window while tracking to take account of the menu height.
	 * In its wisdom, the system keeps trying to resize us back to the
	 * original height.  So, during tracking, we keep hold of the
	 * dimensions we want to be and ignore the height that we get
	 * passed on WM_WINDOWPOSCHANGING.
	 */
	if (posSizeMove.cx != 0)
	{
	    int NewHeightAdjust = GetHeightAdjust(hwnd);

	    if ((int)gwHeightAdjust != NewHeightAdjust)
	    {
		/* The total non-client height has changed, so it must
		 * be the menu that's wrapped or unwrapped.
		 * Modify our height adjustment accordingly and resize
		 * the window.
		 */
		DPF("Menu appears to have wrapped.  Changing window height.\n");

		posSizeMove.cy += ( NewHeightAdjust - gwHeightAdjust );
		gwHeightAdjust = NewHeightAdjust;
		MoveWindow(ghwndApp,
			   posSizeMove.x, posSizeMove.y,
			   posSizeMove.cx, posSizeMove.cy, TRUE);
		return FALSE;
	    }
	}

	if (ghwndStatic && IsWindowVisible(ghwndStatic))
	{
	    InvalidateRect(ghwndStatic, NULL, FALSE);
	}
    }

    FORWARD_WM_WINDOWPOSCHANGED(hwnd, lpwpos, DefWindowProc);

    return TRUE;
}


void MPlayer_OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange)
{
    if (ghwndMCI && !IsIconic(hwnd))
	FORWARD_WM_PALETTECHANGED(ghwndMCI, hwndPaletteChange, SendMessage);
}


BOOL MPlayer_OnQueryNewPalette(HWND hwnd)
{
    HWND     hwndT;
    HPALETTE hpal, hpalT;
    HDC      hdc;
    UINT     PaletteEntries;

    if (IsIconic(hwnd))
	return FALSE;

    if (ghwndMCI)
	return FORWARD_WM_QUERYNEWPALETTE(ghwndMCI, SendMessage);

    hwndT = GetWindowMCI();
    hpal = PaletteMCI();

    if ((hwndT != NULL) && (hpal != NULL)) {
	hdc = GetDC(hwnd);
	hpalT = SelectPalette(hdc, hpal, FALSE);
	PaletteEntries = RealizePalette(hdc);
	SelectPalette(hdc, hpalT, FALSE);
	ReleaseDC(hwnd, hdc);

	if (PaletteEntries != GDI_ERROR) {
	    InvalidateRect(hwndT, NULL, TRUE);
	    return TRUE;
	}
    }

    return FALSE;
}


HBRUSH MPlayer_OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
{
    /* Only interested in the CTLCOLOR_STATIC messages.
     * On Win32, type should always equal CTLCOLOR_STATIC:
     */
    switch( type )
    {
    case CTLCOLOR_STATIC:
	SetBkColor(hdc, rgbButtonFace);
	SetTextColor(hdc, rgbButtonText);
    }

    return hbrButtonFace;
}


void MPlayer_OnWinIniChange(HWND hwnd, LPCTSTR lpszSectionName)
{
    if (!lpszSectionName || !lstrcmpi(lpszSectionName, (LPCTSTR)aszIntl))
	if (GetIntlSpecs())
	    InvalidateRect(ghwndMap, NULL, TRUE);

    if (!gfPlayOnly) {

	if (gwHeightAdjust != (WORD)(2 * GetSystemMetrics(SM_CYFRAME) +
		     GetSystemMetrics(SM_CYCAPTION) +
		     GetSystemMetrics(SM_CYBORDER) +
		     GetSystemMetrics(SM_CYMENU))) {

	    RECT rc;

	    gwHeightAdjust = 2 * GetSystemMetrics(SM_CYFRAME) +
			     GetSystemMetrics(SM_CYCAPTION) +
			     GetSystemMetrics(SM_CYBORDER) +
			     GetSystemMetrics(SM_CYMENU);
	    GetClientRect(hwnd, &rc);
	    gfWinIniChange = TRUE;
	    SetMPlayerSize(&rc);
	    gfWinIniChange = FALSE;
	}
    }
}


void MPlayer_OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags)
{
	// Make sure that the container is still not displaying info. about
    // its own menu.
	
    if (gfOle2IPEditing && docMain.lpIpData->lpFrame) {

	//Should have some useful text later.
	IOleInPlaceFrame_SetStatusText(docMain.lpIpData->lpFrame, L"");
    }
	else
	{
		//Keep track of which menu bar item is currently popped up.
		//This will be used for displaying the appropriate help from the mplayer.hlp file
		//when the user presses the F1 key.
		currMenuItem = item;
	}
}


#define MVSIZEFIRST         1
#define MVMOVE              9
void MPlayer_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
{
    RECT rc;

    if (gfPlayOnly && !IsIconic(hwnd) && IsZoomed(hwnd)) {

	if (codeHitTest >= HTSIZEFIRST && codeHitTest <= HTSIZELAST) {

	    SendMessage(hwnd, WM_SYSCOMMAND,
//                        (WPARAM)(SC_SIZE + (codeHitTest - HTSIZEFIRST + MVSIZEFIRST) ),
			(WPARAM)SC_SIZE,
			MAKELPARAM(x, y));
	    return;
	}

	GetWindowRect(hwnd, &rc);

	if (codeHitTest == HTCAPTION && (rc.left > 0 || rc.top > 0 ||
	    rc.right  < GetSystemMetrics(SM_CXSCREEN) ||
	    rc.bottom < GetSystemMetrics(SM_CYSCREEN))) {

	    SendMessage(hwnd, WM_SYSCOMMAND,
//                        (WPARAM)(SC_MOVE | MVMOVE),
			(WPARAM)SC_MOVE,
			MAKELPARAM(x, y));
	    return;
	}
    }

    FORWARD_WM_NCLBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, DefWindowProc);
}


void MPlayer_OnNCLButtonDblClk(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
{
    //
    // when the user dbl-clicks on the caption, toggle the play mode.
    //
    if (codeHitTest == HTCAPTION && !IsIconic(hwnd))
	SendMessage(hwnd, WM_COMMAND, (WPARAM)IDM_WINDOW, 0);
}


void MPlayer_OnInitMenu(HWND hwnd, HMENU hMenu)
{

    EnableMenuItem(hMenu, IDM_CLOSE,   gwDeviceID ? MF_ENABLED : MF_GRAYED);
//  EnableMenuItem(hMenu, IDM_UPDATE,  gwDeviceID && gfEmbeddedObject ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(hMenu, IDM_COPY_OBJECT, (gwDeviceID && (gwStatus != MCI_MODE_OPEN) && (gwStatus != MCI_MODE_NOT_READY)) ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu, IDM_CONFIG, gwDeviceID && (gwDeviceType & DTMCI_CANCONFIG) ? MF_ENABLED : MF_GRAYED);

    CheckMenuItem(hMenu, IDM_SCALE + ID_TIME, gwCurScale == ID_TIME   ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hMenu, IDM_SCALE + ID_TRACKS, gwCurScale == ID_TRACKS ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hMenu, IDM_SCALE + ID_FRAMES, gwCurScale == ID_FRAMES ? MF_CHECKED : MF_UNCHECKED);

    EnableMenuItem(hMenu, IDM_SCALE + ID_TIME,   gwDeviceID && !gfCurrentCDNotAudio && (gwDeviceType & DTMCI_TIMEMS) ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu, IDM_SCALE + ID_FRAMES, gwDeviceID && !gfCurrentCDNotAudio && (gwDeviceType & DTMCI_TIMEFRAMES) ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu, IDM_SCALE + ID_TRACKS, gwDeviceID && !gfCurrentCDNotAudio && (gwNumTracks > 1) ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(hMenu, IDM_OPTIONS, gwDeviceID ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu, IDM_SELECTION, gwDeviceID && gdwMediaLength ? MF_ENABLED : MF_GRAYED);

#ifdef DEBUG
    EnableMenuItem(hMenu, IDM_MCISTRING, gwDeviceID ? MF_ENABLED : MF_GRAYED);
#endif

/*
    EnableMenuItem(hMenu, IDM_PASTE_PICTURE , gwDeviceID &&
		(IsClipboardFormatAvailable(CF_METAFILEPICT) ||
		 IsClipboardFormatAvailable(CF_BITMAP) ||
		 IsClipboardFormatAvailable(CF_DIB))
		? MF_ENABLED : MF_GRAYED);

    //
    //  what is paste frame!
    //
    EnableMenuItem(hMenu, IDM_PASTE_FRAME, gwDeviceID &&
		   (gwDeviceType & DTMCI_CANCONFIG) ? MF_ENABLED : MF_GRAYED);
*/
}


void MPlayer_OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu)
{
    static BOOL VolumeControlChecked = FALSE;

    /* Here we look to see whether the menu selected is the Device popup,
     * and, if it is the first time, search for the Sound Volume applet.
     * If we can't find it, grey out the menu item.
     */

    /* Caution:  When we're in place, there seems to be a discrepancy
     * in the value of parameter UINT item depending on which app is our
     * container.  If you use Spy to look at the parameters sent on
     * WM_INITMENUPOPUP, some apps seem to have zero-based menus (e.g.
     * ProgMan, PowerPoint, FileMan), which is what I would expect,
     * but others seem to have one-based menus (e.g. Word, Excel).
     * Why is this?  I don't know.  But it means that, when the
     * Insert Clip menu item is selected, the item parameter may be
     * either 2 or 3.  That's why I'm calling GetSubMenu, since hMenu
     * is always what I would expect.
     *
     * I sent some mail to the User and OLE guys to point this out,
     * but haven't heard anything yet.
     *
     * andrewbe, 28 February 1995
     */

    if (hMenu == GetSubMenu(ghMenu, menuposDevice))
    {
	HCURSOR hcurPrev;

	if(!VolumeControlChecked)
	{
	    /*
	    ** Check to see if the volume controller piglet can be found on
	    ** the path.
	    */
	    {
		TCHAR   chBuffer[8];
		LPTSTR  lptstr;

		if( SearchPath( NULL, szSndVol32, NULL, 8, chBuffer, &lptstr ) == 0L )
		    EnableMenuItem( hMenu, IDM_VOLUME, MF_GRAYED );

		VolumeControlChecked = TRUE;
	    }
	}

	/* On Device (or Insert Clip) menu start menu building if necessary
	 * (e.g. if we came up in tiny mode then switched to full size),
	 * and wait for the separate thread to complete.
	 */
	InitDeviceMenu();
	hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));
	WaitForDeviceMenu();
	SetCursor(hcurPrev);
    }

    /////////////////////////////////////////////////////////////////////////////
    // This code allows a window to by sized even when in the maximized state
    /////////////////////////////////////////////////////////////////////////////

    if (gfPlayOnly && !IsIconic(hwnd) && fSystemMenu && IsZoomed(hwnd))
	EnableMenuItem(hMenu, SC_SIZE,
		       !IsIconic(hwnd) ? MF_ENABLED : MF_GRAYED);
}


void MPlayer_OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpMinMaxInfo)
{
    RECT rc;

    if (gfPlayOnly) {
	SetRect(&rc, 0, 0, 0, TOOLBAR_HEIGHT);
	AdjustWindowRect(&rc, (DWORD)GetWindowLongPtr(hwnd, GWL_STYLE), FALSE);
	lpMinMaxInfo->ptMinTrackSize.y = rc.bottom - rc.top - 1;

	if (!gfPlayingInPlace &&
	    (gwDeviceID == (UINT)0 || !(gwDeviceType & DTMCI_CANWINDOW)))
	    lpMinMaxInfo->ptMaxTrackSize.y = lpMinMaxInfo->ptMinTrackSize.y;
    }
    else {
	lpMinMaxInfo->ptMinTrackSize.y = MAX_NORMAL_HEIGHT + gwHeightAdjust;
	lpMinMaxInfo->ptMaxTrackSize.y = MAX_NORMAL_HEIGHT + gwHeightAdjust;
    }
}


void MPlayer_OnPaint(HWND hwnd)
{
    PAINTSTRUCT ps;
    RECT        rc;
    int         x1, x2, y, y2;
    UINT        wParent;
    HBRUSH      hbrOld;

    BeginPaint(hwnd, &ps);

    if (gfPlayOnly) {

	extern UINT gwPlaybarHeight;    // in server.c

	/* Separate mci playback window from controls */
	if (gwDeviceType & DTMCI_CANWINDOW) {
	    SelectObject(ps.hdc, hbrButtonText);
	    GetClientRect(ghwndApp, &rc);
	    PatBlt(ps.hdc, 0, rc.bottom - gwPlaybarHeight, rc.right, 1, PATCOPY);
	}
    }
    else {
	hbrOld = SelectObject(ps.hdc, hbrButtonText);
	GetClientRect(ghwndApp, &rc);
	wParent = rc.right;

	y = rc.bottom - 27;   // where to paint borders around toolbar

	/* Line above trackbar */
#ifdef CHICAGO_PRODUCT
	y2 = rc.bottom - 74;
	/* This looks bad on NT */
	PatBlt(ps.hdc, 0, y2, wParent, 1, PATCOPY);
#else
	y2 = rc.bottom - 75;
#endif
	/* Lines around toolbars */
	PatBlt(ps.hdc, 0, y, wParent, 1, PATCOPY);
	GetClientRect(ghwndToolbar, &rc);
	x1 = rc.right;
	PatBlt(ps.hdc, x1, y, 1, TOOLBAR_HEIGHT + 3, PATCOPY);
	GetWindowRect(ghwndApp, &rc);
	x2 = rc.left;

	if (IsWindowVisible(ghwndStatic)) {
	    GetWindowRect(ghwndStatic, &rc);
	    MapWindowPoints(NULL, ghwndApp, (LPPOINT)&rc, 1);
	    x2 = rc.left - 2 - GetSystemMetrics(SM_CXFRAME);

	    PatBlt(ps.hdc, x2, y, 1, TOOLBAR_HEIGHT + 3, PATCOPY);
	}

	SelectObject(ps.hdc, hbrButtonHighLight);
	/* Line above trackbar */
	PatBlt(ps.hdc, 0, y2 + 1, wParent, 1, PATCOPY);
	/* Lines around toolbar */
	PatBlt(ps.hdc, 0, y + 1, wParent, 1, PATCOPY);
	PatBlt(ps.hdc, x1 + 1, y + 1, 1, TOOLBAR_HEIGHT + 2, PATCOPY);
	if (IsWindowVisible(ghwndStatic)) {
	    PatBlt(ps.hdc, x2 + 1, y + 1, 1,TOOLBAR_HEIGHT +2, PATCOPY);
	}
	SelectObject(ps.hdc, hbrOld);
    }

    EndPaint(hwnd, &ps);

}


void MPlayer_OnCommand_Toolbar_Play()
{
    /* This checks to see whether the ALT key is held down.
     * If so, the current selection (if it exists) is played,
     * otherwise the whole shooting match.
     * Note, this does not appear to be documented at present.
     */
    if (GetKeyState(VK_MENU) < 0)
	PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAYSEL, 0);

    /* On WFW, pressing the play button when in place plays the
     * current selection, if there is one.  Do the same if we're
     * playing or editing in place.
     */
    else if (gfOle2IPPlaying || gfOle2IPEditing)
	PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAYSEL, 0);
    else
	PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PLAY, 0);
}

void MPlayer_OnCommand_Toolbar_Pause()
{
    PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_PAUSE, 0L);
}

void MPlayer_OnCommand_Toolbar_Stop()
{
    PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_STOP, 0L);
}

void MPlayer_OnCommand_Toolbar_Eject()
{
    PostMessage(ghwndApp, WM_COMMAND, (WPARAM)ID_EJECT, 0L);
}

void MPlayer_OnCommand_Toolbar_Home()
{
    LONG_PTR lPos = CalcPrevMark();

    /* We MUST use PostMessage because the */
    /* SETPOS and ENDTRACK must happen one */
    /* immediately after the other         */

    PostMessage(ghwndTrackbar, TBM_SETPOS, (WPARAM)TRUE, lPos);

    PostMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_ENDTRACK, (LPARAM)ghwndTrackbar);
}

void MPlayer_OnCommand_Toolbar_End()
{
    LONG_PTR lPos = CalcNextMark();

    /* We MUST use PostMessage because the */
    /* SETPOS and ENDTRACK must happen one */
    /* immediately after the other         */

    PostMessage(ghwndTrackbar, TBM_SETPOS, (WPARAM)TRUE, lPos);

    PostMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_ENDTRACK, (LPARAM)ghwndTrackbar);
}

void MPlayer_OnCommand_Toolbar_Rwd(HWND hwndCtl)
{
    if (hwndCtl == (HWND)REPEAT_ID)
    {
	if (gwCurScale != ID_TRACKS)
	    PostMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_PAGEUP, 0L);
	else
	    PostMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_LINEUP, 0L);
    }
}

void MPlayer_OnCommand_Toolbar_Fwd(HWND hwndCtl)
{
    if (hwndCtl == (HWND)REPEAT_ID)
    {
	if (gwCurScale != ID_TRACKS)
	    PostMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_PAGEDOWN, 0L);
	else
	    PostMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_LINEDOWN, 0L);
    }
}

void MPlayer_OnCommand_Toolbar_MarkIn()
{
    SendMessage(ghwndTrackbar, TBM_SETSELSTART, (WPARAM)TRUE,
		SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0));

    DirtyObject(TRUE);
}

void MPlayer_OnCommand_Toolbar_MarkOut()
{
    SendMessage(ghwndTrackbar, TBM_SETSELEND, (WPARAM)TRUE,
		SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0));

    DirtyObject(TRUE);
}

void MPlayer_OnCommand_Toolbar_ArrowPrev(HWND hwndCtl)
{
    if (hwndCtl == (HWND)REPEAT_ID)
	SendMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_LINEUP, 0L);
}

void MPlayer_OnCommand_Toolbar_ArrowNext(HWND hwndCtl)
{
    if (hwndCtl == (HWND)REPEAT_ID)
	SendMessage(ghwndApp, WM_HSCROLL, (WPARAM)TB_LINEDOWN, 0L);
}

void MPlayer_OnCommand_Menu_CopyObject(HWND hwnd)
{
    if (gfPlayingInPlace)
    {
	DPF0("Mplayer WndProc: Can't cutorcopy\n");
	return;
    }

    DPF("Mplayer WndProc: Calling cutorcopy\n");

    if (!InitOLE(&gfOleInitialized, &lpMalloc))
    {
	/* How likely is this?  Do we need a dialog box?
	 */
	DPF0("Initialization of OLE FAILED!!  Can't do copy.\n");
    }

#ifdef OLE1_HACK
    CopyObject(hwnd);
#endif /* OLE1_HACK */
    CutOrCopyObj(&docMain);
}

void MPlayer_OnCommand_Menu_Config(HWND hwnd)
{
    RECT rcBefore;
    RECT rcAfter;

    if (gfPlayingInPlace)
	return;

    GetDestRectMCI (&rcBefore);

    ConfigMCI(hwnd);

    /* If the MCI window size changed, we need to resize */
    /* our reduced mplayer.                              */
    if (gfPlayOnly)
    {
	GetDestRectMCI (&rcAfter);

	if (!EqualRect(&rcBefore, &rcAfter) && (!IsRectEmpty(&rcAfter)))
	    SetMPlayerSize(&rcAfter);
    }
}


void MPlayer_OnCommand_Menu_Volume(HWND hwnd)
{
    HANDLE  hThread;
    DWORD   dwThreadId;

    hThread = CreateThread( NULL, 0L,
			    (LPTHREAD_START_ROUTINE)StartSndVol,
			    NULL, 0L, &dwThreadId );

    if ( hThread != NULL ) {
	CloseHandle( hThread );
    }
}


void MPlayer_OnCommand_PlayToggle(HWND hwnd)
{
    /* This is for the accelerator to toggle play and pause. */
    /* Ordinary play commands better not toggle.             */

    DPF2("MPlayer_OnCommand_PlayToggle: gwStatus == %x\n", gwStatus);

    switch(gwStatus) {

    case MCI_MODE_STOP:
    case MCI_MODE_PAUSE:
    case MCI_MODE_SEEK:
	PostMessage(hwnd, WM_COMMAND, (WPARAM)ID_PLAY, 0);
	break;

    case MCI_MODE_PLAY:
	PostMessage(hwnd, WM_COMMAND, (WPARAM)ID_PAUSE, 0);
	break;
    }
}

void MPlayer_OnCommand_PlaySel(HWND hwnd, HWND hwndCtl)
{
    DWORD_PTR dwPos, dwStart, dwEnd;
    BOOL f;
    dwPos = 0; // Make Prefix Happy..

    DPF2("MPlayer_OnCommand_PlaySel: gwStatus == %x\n", gwStatus);

    switch(gwStatus) {

    case MCI_MODE_OPEN:
    case MCI_MODE_NOT_READY:

	Error(ghwndApp, IDS_CANTPLAY);
	if (gfCloseAfterPlaying)    // get us out now!!
	    PostCloseMessage();

	break;

    default:

	/* If the shift key's being held down, make this the start
	 * of a selection:
	 */

	if((GetKeyState(VK_SHIFT) < 0)
	 &&(toolbarStateFromButton(ghwndMark, BTN_MARKIN, TBINDEX_MARK)
						   != BTNST_GRAYED))
	    SendMessage(hwnd, WM_COMMAND, IDT_MARKIN, 0);

	/* Start playing the medium */

	StatusMCI(&dwPos);   // get the REAL position
	dwStart = SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0);
	dwEnd = SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0);

	/* If there is no valid selection, act like PLAY */
	if (dwStart == -1 || dwEnd == -1 || dwStart == dwEnd)
	    hwndCtl = (HWND)ID_PLAY;

	// Be nice and rewind automatically if we're at the end of the media.
	// Depending on the device, though, the end could be "start + len"
	// or "start + len - 1"
	if (hwndCtl == (HWND)ID_PLAY &&
			dwPos >= gdwMediaStart + gdwMediaLength - 1) {
	    if (!SeekMCI(gdwMediaStart))
		break;
	}

	if (hwndCtl == (HWND)ID_PLAYSEL) {
	    f = PlayMCI(dwStart, dwEnd);
	    gfJustPlayedSel = TRUE;
	} else {
	    f = PlayMCI(0, 0);
	    gfJustPlayedSel = FALSE;
	}

	// get us out NOW!! or focus goes to client
	if (!f && gfCloseAfterPlaying)
	    PostCloseMessage();

	/* No longer needed - reset for next time */
	gfUserStopped = FALSE;

	gwStatus = (UINT)(-1);    // force rewind if needed
	break;
    }
}

void MPlayer_OnCommand_Pause()
{
    /* Pause the medium, unless we are already paused */

    DPF2("MPlayer_OnCommand_Pause: gwStatus == %x\n", gwStatus);

    switch(gwStatus) {

    case MCI_MODE_PAUSE:
	PlayMCI(0, 0);
	break;

    case MCI_MODE_PLAY:
    case MCI_MODE_SEEK:
	PauseMCI();
	break;

    case MCI_MODE_STOP:
    case MCI_MODE_OPEN:
	break;
    }
}

void MPlayer_OnCommand_Stop()
{
    /* Stop the medium */

    DPF2("MPlayer_OnCommand_Stop: gwStatus == %x\n", gwStatus);

    switch(gwStatus) {

    case MCI_MODE_PAUSE:
    case MCI_MODE_PLAY:
    case MCI_MODE_STOP:
    case MCI_MODE_SEEK:

	StopMCI();		
	SeekToStartMCI();
	gfUserStopped = TRUE;        // we did this
	gfCloseAfterPlaying = FALSE; //stay up from now on

	UpdateDisplay();

	// Focus should go to PLAY button now
	toolbarSetFocus(ghwndToolbar, BTN_PLAY);
	break;

    case MCI_MODE_OPEN:
	break;
    }

    if (gfPlayingInPlace)
	PostCloseMessage();
}


void MPlayer_OnCommand_Eject()
{
    /*
     * Eject the medium if it currently isn't ejected. If it
     * is currently ejected, then load the new medium into
     * the device.
     *
     */

    switch(gwStatus) {

    case MCI_MODE_PLAY:
    case MCI_MODE_PAUSE:

	StopMCI();
	EjectMCI(TRUE);

	break;

    case MCI_MODE_STOP:
    case MCI_MODE_SEEK:
    case MCI_MODE_NOT_READY:

	EjectMCI(TRUE);

	break;

    case MCI_MODE_OPEN:

	EjectMCI(FALSE);

	break;
    }
}


void MPlayer_OnCommand_Escape()
{
    MPlayer_OnCommand_Stop();

    if( gfOle2IPEditing || gfOle2IPPlaying)
	PostCloseMessage();
}


void MPlayer_OnCommand_Menu_Open()
{
    UINT  wLastScale;
    UINT  wLastDeviceID;
    TCHAR szFile[256];
    RECT  rc;

    wLastScale = gwCurScale;  // save old scale
    wLastDeviceID = gwDeviceID;
    if (gfPlayingInPlace || gfOle2IPEditing || gfOle2IPPlaying)
	return;

    InitDeviceMenu();
    WaitForDeviceMenu();

    if (OpenDoc(gwCurDevice,szFile))
    {
	DirtyObject(FALSE);
	/* Force WM_GETMINMAXINFO to be called so we'll snap  */
	/* to a proper size.                                  */
	GetWindowRect(ghwndApp, &rc);
	MoveWindow(ghwndApp,
		   rc.left,
		   rc.top,
		   rc.right - rc.left,
		   rc.bottom - rc.top,
		   TRUE);

	if (gfOpenDialog)
	    CompleteOpenDialog(TRUE);
	else
	    gfCloseAfterPlaying = FALSE;    // stay up from now on

	//If the CD Audio device was opened it must have been a *.cda file.
	//Try to jump to the track corresponding to the file opened.
	if ((gwDeviceType & DTMCI_DEVICE) == DTMCI_CDAUDIO)
	{
		HandleCDAFile(szFile);
	}
    }
    else
    {
	if (gfOpenDialog)
	    CompleteOpenDialog(FALSE);

	/* The previous device may or may not still be open.
	 * If it is, make sure we have the right scale.
	 */
	if (gwDeviceID == wLastDeviceID)
	    gwCurScale = wLastScale;   // restore to last scale

	InvalidateRect(ghwndMap, NULL, TRUE); //erase map area
    }

    // put the focus on the Play button
    SetFocus(ghwndToolbar);    // give focus to PLAY button
    toolbarSetFocus(ghwndToolbar, BTN_PLAY);

    SetMPlayerIcon();
}

void MPlayer_OnCommand_Menu_Close(HWND hwnd)
{
    if (gfEmbeddedObject && !gfSeenPBCloseMsg) {
	// this is File.Update
#ifdef OLE1_HACK
	if( gDocVersion == DOC_VERSION_OLE1 )
	    Ole1UpdateObject();
	else
#endif /* OLE1_HACK */
	UpdateObject();
    }
    else
    {
	// this is File.Close
	gfSeenPBCloseMsg = TRUE;

	WriteOutOptions();
	InitDoc(TRUE);
	SetMPlayerIcon();
	gwCurDevice = 0;// force next file open dialog to say
			// "all files" because CloseMCI won't.

	gwCurScale = ID_NONE;  // uncheck all scale types

	Layout(); // Make window snap back to smaller size
		  // if it should.
		  // Don't leave us closed in play only mode

	if (gfPlayOnly)
	    SendMessage(hwnd, WM_COMMAND, (WPARAM)IDM_WINDOW, 0);
    }
}

void MPlayer_OnCommand_Menu_Exit()
{
    PostCloseMessage();
}

void MPlayer_OnCommand_Menu_Scale(UINT id)
{
    /*
     * Invalidate the track map window so it will be
     * redrawn with the correct positions, etc.
     */
    if (gwCurScale != id - IDM_SCALE) {

	// Restoring the selection doesn't work yet,
	// because UpdateMCI clears the selection,
	// plus we need to do some conversion.
//        int SelStart = SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0);
//        int SelEnd = SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0);

	SendMessage(ghwndTrackbar, TBM_CLEARTICS, (WPARAM)FALSE, 0L);
	if (gwCurScale == ID_FRAMES || id - IDM_SCALE == ID_FRAMES)
	    gfValidMediaInfo = FALSE;

	gwCurScale = id - IDM_SCALE;
	DirtyObject(TRUE);    // change scale changes PAGE UP/DOWN
	CalcTicsOfDoom();

//        SendMessage(ghwndTrackbar, TBM_SETSELSTART, TRUE, SelStart);
//        SendMessage(ghwndTrackbar, TBM_SETSELEND, TRUE, SelEnd);
    }
}

void MPlayer_OnCommand_Menu_Selection(HWND hwnd)
{
    if (!gfPlayingInPlace)
	setselDialog(hwnd);
}


void MPlayer_OnCommand_Menu_Options(HWND hwnd)
{
    if (!gfPlayingInPlace)
	optionsDialog(hwnd);
}

void MPlayer_OnCommand_Menu_MCIString(HWND hwnd)
{
    if (!gfPlayingInPlace && gwDeviceID)
	mciDialog(hwnd);
}

void MPlayer_OnCommand_Menu_Window(HWND hwnd)
{
    //
    //  make MPlayer small/big
    //
    //!! dont do this if inside client document !!
    //!! or if we're not visible                !!

    if (!IsWindowVisible(ghwndApp) || gfPlayingInPlace || IsIconic(hwnd)
	|| gfOle2IPEditing)
	return;

    // allowed to get out of teeny mode when no file is open
    if (gwDeviceID != (UINT)0 || gfPlayOnly) {
	gfPlayOnly = !gfPlayOnly;
	SizeMPlayer();
    }
}

void MPlayer_OnCommand_Menu_Zoom(HWND hwnd, int id)
{
    int dx, dy;

    if (IsIconic(hwnd) ||gfPlayingInPlace || gfOle2IPPlaying || gfOle2IPEditing ||
		 !(gwDeviceType & DTMCI_CANWINDOW))
	return;

    dx = grcSize.right  * (id-IDM_ZOOM);
    dy = grcSize.bottom * (id-IDM_ZOOM);

    //
    // if the playback windows is now larger than the screen
    // maximize MPlayer, this only makes sence for Tiny mode.
    //
    if (gfPlayOnly &&
	(dx >= GetSystemMetrics(SM_CXSCREEN) ||
	 dy >= GetSystemMetrics(SM_CYSCREEN))) {
	ClrWS(hwnd, WS_MAXIMIZE);
	DefWindowProc(hwnd, WM_SYSCOMMAND, (WPARAM)SC_MAXIMIZE, 0);
    }
    else {
	SizePlaybackWindow(dx, dy);
    }
}

void DoHtmlHelp()
{
	//note, using ANSI version of function because UNICODE is foobar in NT5 builds
    char chDst[MAX_PATH];

	WideCharToMultiByte(CP_ACP, 0, gszHtmlHelpFileName, 
									-1, chDst, MAX_PATH, NULL, NULL); 
	HtmlHelpA(GetDesktopWindow(), chDst, HH_DISPLAY_TOPIC, 0);
}

void MPlayer_OnCommand_Menu_HelpTopics(HWND hwnd)
{
	static TCHAR HelpFile[] = TEXT("MPLAYER.HLP");
	
	//Handle context menu help
	if(bF1InMenu) 
	{
		switch(currMenuItem)
		{
		case IDM_OPEN:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_FILE_OPEN);
		break;
		case IDM_CLOSE:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_FILE_CLOSE);
		break;
		case IDM_EXIT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_FILE_EXIT);
		break;
		case IDM_COPY_OBJECT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_EDIT_COPY_OBJECT);
		break;
		case IDM_OPTIONS:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_EDIT_OPTIONS);
		break;
		case IDM_SELECTION:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_EDIT_SELECTION);
		break;
		case IDM_CONFIG:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_DEVICE_PROPERTIES);
		break;
		case IDM_VOLUME:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_DEVICE_VOLUME_CONTROL);
		break;
		case IDM_SCALE + ID_TIME:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_SCALE_TIME);
		break;
		case IDM_SCALE + ID_TRACKS:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_SCALE_TRACKS);
		break;
		case IDM_SCALE + ID_FRAMES:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_SCALE_FRAMES);
		break;
		case IDM_HELPTOPICS:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_HELP_HELP_TOPICS);
		break;
		case IDM_ABOUT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_MPLYR_CS_MEDIA_PLAYER_HELP_ABOUT);
		break;
		default://In the default case just display the HTML Help.
			DoHtmlHelp();
		}
		bF1InMenu = FALSE; //This flag will be set again if F1 is pressed in a menu.
	}
	else
		DoHtmlHelp();
}

void MPlayer_OnCommand_Menu_About(HWND hwnd)
{
    ShellAbout(hwnd, gachAppName, aszNULL, hiconApp);
}

void MPlayer_OnCommand_Default(HWND hwnd, int id)
{
    /*
     * Determine if the user selected one of the entries in
     * the Device menu.
     *
     */

    if (id > IDM_DEVICE0 &&
	(id <= (WORD)(IDM_DEVICE0 + gwNumDevices))
       ) {

	BOOL fHasWindow, fHadWindow, fHadDevice;

	fHadWindow = (gwDeviceID != (UINT)0) && (gwDeviceType & DTMCI_CANWINDOW);
	fHadDevice = (gwDeviceID != (UINT)0);

	//Choose and open a new device. If we are active inplace we have
	//to consider the effect of the change in device on the visual appearence.
	//For this we have to take into account whether the current and previous
	//device had a playback window or not. We also have to consider
	//whether this is the first device are opening.
	//After all the crazy munging send a messages to the container about
	//the changes.
	if (DoChooseDevice(id-IDM_DEVICE0))
	{
	    if (gfOpenDialog)
		CompleteOpenDialog(TRUE);

	    fHasWindow = (gwDeviceID != (UINT)0) && (gwDeviceType & DTMCI_CANWINDOW);
	    if(gfOle2IPEditing)
	    {
		if (fHasWindow && fHadWindow)
		{
		    GetWindowRect(ghwndApp, (LPRECT)&gInPlacePosRect);
		    gfInPlaceResize = TRUE;
		    SendDocMsg((LPDOC)&docMain, OLE_SIZECHG);
		    SendDocMsg((LPDOC)&docMain, OLE_CHANGED);
		}

		else
		{
		    RECT rc;
		    RECT rctmp;

		    ClrWS(ghwndApp,
			  WS_THICKFRAME|WS_CAPTION|WS_SYSMENU|WS_MINIMIZEBOX|WS_MAXIMIZEBOX|WS_BORDER);

		    if (gwOptions & OPT_BORDER)
			SetWS(ghwndApp, WS_BORDER);

		    GetWindowRect(ghwndApp, &rc);

		    if (!(gwDeviceType & DTMCI_CANWINDOW))
		    {
			HBITMAP  hbm;
			BITMAP   bm;

			if (!fHadDevice)
			GetWindowRect(ghwndIPHatch, &rc);
			hbm =  BitmapMCI();
			GetObject(hbm,sizeof(bm),&bm);
			rc.bottom = rc.top + bm.bmHeight;
			rc.right = rc.left + bm.bmWidth;
			DeleteObject(hbm);
		    }
		    else
		    {
			if(!fHadDevice)
			{
			rc.bottom -= (GetSystemMetrics(SM_CYCAPTION)-GetSystemMetrics(SM_CYBORDER));
			gwOptions |= OPT_BAR | OPT_TITLE;
			}
		      rc.bottom += gInPlacePosRect.top - rc.top - 4*GetSystemMetrics(SM_CYBORDER) - 4 ;
		      rc.right += gInPlacePosRect.left - rc.left- 4*GetSystemMetrics(SM_CXBORDER) - 4 ;
			rc.top = gInPlacePosRect.top;
			rc.left = gInPlacePosRect.left;
		    }
		    rctmp = gPrevPosRect;
		    MapWindowPoints( ghwndCntr, NULL, (LPPOINT)&rctmp,2);
		    OffsetRect((LPRECT)&rc, rctmp.left - rc.left, rctmp.top -rc.top);
		    gInPlacePosRect = rc;
		    gfInPlaceResize = TRUE;
		    if(!(gwDeviceType & DTMCI_CANWINDOW) && (gwOptions & OPT_BAR))
		    {
			rc.top = rc.bottom - gwPlaybarHeight;
		    }
		    EditInPlace(ghwndApp,ghwndIPHatch,&rc);
		    SendDocMsg((LPDOC)&docMain, OLE_SIZECHG);
		    SendDocMsg((LPDOC)&docMain, OLE_CHANGED);
		    if (!(gwDeviceType & DTMCI_CANWINDOW) && !(gwOptions &OPT_BAR))
			ShowWindow(ghwndApp, SW_HIDE);
		    else
			ShowWindow(ghwndApp, SW_SHOW);
		}
	    }

	    DirtyObject(FALSE);

	    if (!gfOpenDialog)
		gfCloseAfterPlaying = FALSE;  // stay up from now on

	    SetMPlayerIcon();
	}
	else
	    if (gfOpenDialog)
		CompleteOpenDialog(FALSE);
    }
}

#define HANDLE_COMMAND(id, call)    case (id): (call); break

void MPlayer_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id) {

    HANDLE_COMMAND(IDT_PLAY,              MPlayer_OnCommand_Toolbar_Play());
    HANDLE_COMMAND(IDT_PAUSE,             MPlayer_OnCommand_Toolbar_Pause());
    HANDLE_COMMAND(IDT_STOP,              MPlayer_OnCommand_Toolbar_Stop());
    HANDLE_COMMAND(IDT_EJECT,             MPlayer_OnCommand_Toolbar_Eject());
    HANDLE_COMMAND(IDT_HOME,              MPlayer_OnCommand_Toolbar_Home());
    HANDLE_COMMAND(IDT_END,               MPlayer_OnCommand_Toolbar_End());
    HANDLE_COMMAND(IDT_RWD,               MPlayer_OnCommand_Toolbar_Rwd(hwndCtl));
    HANDLE_COMMAND(IDT_FWD,               MPlayer_OnCommand_Toolbar_Fwd(hwndCtl));
    HANDLE_COMMAND(IDT_MARKIN,            MPlayer_OnCommand_Toolbar_MarkIn());
    HANDLE_COMMAND(IDT_MARKOUT,           MPlayer_OnCommand_Toolbar_MarkOut());
    HANDLE_COMMAND(IDT_ARROWPREV,         MPlayer_OnCommand_Toolbar_ArrowPrev(hwndCtl));
    HANDLE_COMMAND(IDT_ARROWNEXT,         MPlayer_OnCommand_Toolbar_ArrowNext(hwndCtl));
    HANDLE_COMMAND(IDM_COPY_OBJECT,       MPlayer_OnCommand_Menu_CopyObject(hwnd));
    HANDLE_COMMAND(IDM_CONFIG,            MPlayer_OnCommand_Menu_Config(hwnd));
    HANDLE_COMMAND(IDM_VOLUME,            MPlayer_OnCommand_Menu_Volume(hwnd));
    HANDLE_COMMAND(ID_PLAYTOGGLE,         MPlayer_OnCommand_PlayToggle(hwnd));
    HANDLE_COMMAND(ID_PLAY,               MPlayer_OnCommand_PlaySel(hwnd, (HWND)IntToPtr(id)));
    HANDLE_COMMAND(ID_PLAYSEL,            MPlayer_OnCommand_PlaySel(hwnd, (HWND)IntToPtr(id)));
    HANDLE_COMMAND(ID_PAUSE,              MPlayer_OnCommand_Pause());
    HANDLE_COMMAND(ID_STOP,               MPlayer_OnCommand_Stop());
    HANDLE_COMMAND(ID_EJECT,              MPlayer_OnCommand_Eject());
    HANDLE_COMMAND(ID_ESCAPE,             MPlayer_OnCommand_Escape());
    HANDLE_COMMAND(IDM_OPEN,              MPlayer_OnCommand_Menu_Open());
    HANDLE_COMMAND(IDM_CLOSE,             MPlayer_OnCommand_Menu_Close(hwnd));
    HANDLE_COMMAND(IDM_EXIT,              MPlayer_OnCommand_Menu_Exit());
    HANDLE_COMMAND(IDM_SCALE + ID_TIME,   MPlayer_OnCommand_Menu_Scale(id));
    HANDLE_COMMAND(IDM_SCALE + ID_TRACKS, MPlayer_OnCommand_Menu_Scale(id));
    HANDLE_COMMAND(IDM_SCALE + ID_FRAMES, MPlayer_OnCommand_Menu_Scale(id));
    HANDLE_COMMAND(IDM_SELECTION,         MPlayer_OnCommand_Menu_Selection(hwnd));
    HANDLE_COMMAND(IDM_OPTIONS,           MPlayer_OnCommand_Menu_Options(hwnd));
    HANDLE_COMMAND(IDM_MCISTRING,         MPlayer_OnCommand_Menu_MCIString(hwnd));
    HANDLE_COMMAND(IDM_WINDOW,            MPlayer_OnCommand_Menu_Window(hwnd));
    HANDLE_COMMAND(IDM_ZOOM1,             MPlayer_OnCommand_Menu_Zoom(hwnd, id));
    HANDLE_COMMAND(IDM_ZOOM2,             MPlayer_OnCommand_Menu_Zoom(hwnd, id));
    HANDLE_COMMAND(IDM_ZOOM3,             MPlayer_OnCommand_Menu_Zoom(hwnd, id));
    HANDLE_COMMAND(IDM_ZOOM4,             MPlayer_OnCommand_Menu_Zoom(hwnd, id));
    HANDLE_COMMAND(IDM_HELPTOPICS,        MPlayer_OnCommand_Menu_HelpTopics(hwnd));
    HANDLE_COMMAND(IDM_ABOUT,             MPlayer_OnCommand_Menu_About(hwnd));

    default:                              MPlayer_OnCommand_Default(hwnd, id);
    }

    UpdateDisplay();
}

void MPlayer_OnClose(HWND hwnd)
{
    int f;

    DPF("WM_CLOSE received\n");

    if (gfInClose) {
	DPF("*** \n");
	DPF("*** Trying to re-enter WM_CLOSE\n");
	DPF("*** \n");
	return;
    }


    // Ask if we want to update before we set gfInClose to TRUE or
    // we won't let the dialog box up.
    f = AskUpdate();
	if (f == IDYES)
	    UpdateObject();
    if (f == IDCANCEL) {
	    gfInClose = FALSE;
	    return;
	}

    gfInClose = TRUE;

    ExitApplication();
    if (gfPlayingInPlace)
       EndPlayInPlace(hwnd);
    if (gfOle2IPEditing)
       EndEditInPlace(hwnd);

    if (docMain.lpoleclient)
	IOleClientSite_OnShowWindow(docMain.lpoleclient, FALSE);

    SendDocMsg(&docMain,OLE_CLOSED);
    DestroyDoc(&docMain);
    ExitApplication();

    if (hMciOle)
    {
	FreeLibrary(hMciOle);
	hMciOle = NULL;
    }


    //
    // set either the owner or the WS_CHILD bit so it will
    // not act up because we have the palette bit set and cause the
    // desktop to steal the palette.
    //
    // because we are being run from client apps that dont deal
    // with palettes we dont want the desktop to hose the palette.
    //
    if (gfPlayOnly && gfCloseAfterPlaying && gfRunWithEmbeddingFlag)
	   SetWindowLongPtr(hwnd, GWLP_HWNDPARENT, (LPARAM)GetDesktopWindow() );

    if (!ItsSafeToClose()) {
	DPF("*** \n");
	DPF("*** Trying to close MPLAYER with a ErrorBox up\n");
	DPF("*** \n");
	gfErrorDeath = WM_CLOSE;
	gfInClose = FALSE;
	return;
    }

    f = AskUpdate();
    if (f == IDYES)
	UpdateObject();
    if (f == IDCANCEL) {
	gfInClose = FALSE;
	return;
    }

    PostMessage(ghwndApp, WM_USER_DESTROY, 0, 0);
    DPF("WM_DESTROY message sent\n");
}

void MPlayer_OnEndSession(HWND hwnd, BOOL fEnding)
{
    if (fEnding) {
	WriteOutPosition();
	WriteOutOptions();
	CloseMCI(FALSE);
    }
}

void MPlayer_OnDestroy(HWND hwnd)
{
    /*
     * Relinquish control of whatever MCI device we were using (if any). If
     * this device is not shareable, then performing this action allows
     * someone else to gain access to the device.
     *
     */

    /* Client might close us if he dies while we're Playing in Place */
    if (gfPlayingInPlace) {
	DPF("****\n");
	DPF("**** Window destroyed while in place!\n");
	DPF("****\n");
    }

	//Unregister the WM_DEVICECHANGE notification
	DeviceChange_Cleanup();

    WriteOutOptions();
    CloseMCI(FALSE);

    SetMenu(hwnd, NULL);

    if (ghMenu)
	DestroyMenu(ghMenu);

    ghMenu = NULL;

    WinHelp(hwnd, gszHelpFileName, HELP_QUIT, 0L);

    PostQuitMessage(0);

    if (IsWindow(ghwndFrame))
	SetFocus(ghwndFrame);
    else if (IsWindow(ghwndFocusSave))
	SetFocus(ghwndFocusSave);

    //Inform OLE that we are not taking any more calls.
    if (gfOleInitialized)
    {
#ifdef OLE1_HACK
	if( gDocVersion == DOC_VERSION_OLE1 )
	    TerminateServer();
	else
#endif /* OLE1_HACK */
	/* Verify that the server was initialised by checking that one
	 * of the fields in docMain is non-null:
	 */
	if( docMain.hwnd )
	    CoDisconnectObject((LPUNKNOWN)&docMain, 0);
	else
	    DPF0("An instance of the server was never created.\n");
    }
}


void MPlayer_OnTimer(HWND hwnd, UINT id)
{
    MSG msg;

    UpdateDisplay();
    PeekMessage(&msg, hwnd, WM_TIMER, WM_TIMER, PM_REMOVE);
}


#define MARK_START  -1
#define MARK_NONE    0
#define MARK_END     1
void UpdateSelection(HWND hwnd, INT_PTR pos, int *pPrevMark)
{
    INT_PTR SelStart;
    INT_PTR SelEnd;

    SelStart = SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0);
    SelEnd = SendMessage(ghwndTrackbar, TBM_GETSELEND, 0, 0);

    if (pos < SelStart)
    {
	SendMessage(hwnd, WM_COMMAND, IDT_MARKIN, 0);
	*pPrevMark = MARK_START;
    }
    else if (pos > SelEnd)
    {
	SendMessage(hwnd, WM_COMMAND, IDT_MARKOUT, 0);
	*pPrevMark = MARK_END;
    }
    else
    {
	if (*pPrevMark == MARK_START)
	    SendMessage(hwnd, WM_COMMAND, IDT_MARKIN, 0);
	else
	    SendMessage(hwnd, WM_COMMAND, IDT_MARKOUT, 0);
    }
}


void MPlayer_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos)
{
    DWORD_PTR dwPosition;       /* player's current position in the medium*/
    DWORD_PTR dwCurTime;        /* Time a page up/down is last made       */
    TCHAR ach[60];
    static int PrevMark;

    /* If the media has no size, we can't seek. */
    if (gdwMediaLength == 0L)
	return;

    dwPosition = SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0);

    if (!gfScrollTrack) {
	gfScrollTrack = TRUE;

	/* If the shift key's being held down, make this the start
	 * of a selection:
	 */

	if((GetKeyState(VK_SHIFT) < 0)
	 &&(toolbarStateFromButton(ghwndMark, BTN_MARKIN, TBINDEX_MARK)
						   != BTNST_GRAYED))
	{
	    SendMessage(ghwndTrackbar, TBM_CLEARSEL, (WPARAM)TRUE, 0);
	    SendMessage(hwnd, WM_COMMAND, IDT_MARKIN, 0);
	    SetFocus(ghwndTrackbar);    /* So that escape will go to
					   the trackbar's subclassed
					   winproc. */
	}

	sfSeekExact = SeekExactMCI(FALSE);
    }

    switch (code) {
	/*
	 * Set the new position within the medium to be
	 * slightly before/after the current position if the
	 * left/right scroll arrow was clicked on.
	 */
	case TB_LINEUP:                 /* left scroll arrow  */
	    dwPosition -= (gwCurScale == ID_FRAMES) ? 1L : SCROLL_GRANULARITY;
	    break;

	case TB_LINEDOWN:               /* right scroll arrow */
	    dwPosition += (gwCurScale == ID_FRAMES) ? 1L : SCROLL_GRANULARITY;
	    break;

	case TB_PAGEUP:                 /* page-left */

	    /*
	     * If the user just did a page-left a short time ago,
	     * then seek to the start of the previous track.
	     * Otherwise, seek to the start of this track.
	     *
	     */
	    if (gwCurScale != ID_TRACKS) {
		dwPosition -= SCROLL_BIGGRAN;
	    } else {
		dwCurTime = GetCurrentTime();
		if (dwCurTime - dwLastPageUpTime < SKIPTRACKDELAY_MSEC)
		    SkipTrackMCI(-1);
		else
		    SkipTrackMCI(0);

		dwLastPageUpTime = dwCurTime;
		goto BreakOut;    // avoid SETPOS
	    }

	    break;

	case TB_PAGEDOWN:               /* page-right */

	    if (gwCurScale != ID_TRACKS) {
		dwPosition += SCROLL_BIGGRAN;
	    } else {
	    /* Seek to the start of the next track */
		SkipTrackMCI(1);
		// Ensure next PageUp can't possibly do SkipTrackMCI(-1)
		// which will skip back too far if you page
		// left, right, left really quickly.
		dwLastPageUpTime = 0;
		goto BreakOut;    // avoid SETPOS
	    }

	    break;

	case TB_THUMBTRACK:             /* track thumb movement */
	    //!!! we should do a "set seek exactly off"
	    /* Only seek while tracking for windowed devices that */
	    /* aren't currently playing                           */
	    if ((gwDeviceType & DTMCI_CANWINDOW) &&
		!(gwStatus == MCI_MODE_PLAY)) {
		SeekMCI(dwPosition);
	    }

	    break;

	case TB_TOP:
	    dwPosition = gdwMediaStart;
	    break;

	case TB_BOTTOM:
	    dwPosition = gdwMediaStart + gdwMediaLength;
	    break;

	case TB_THUMBPOSITION:          /* thumb has been positioned */
	    break;

	case TB_ENDTRACK:              /* user let go of scroll */
	    DPF2("TB_ENDTRACK\n");

	    gfScrollTrack = FALSE;

	    /* New as of 2/7/91: Only seek on ENDTRACK */

	    /*
	     * Calculate the new position in the medium
	     * corresponding to the scrollbar position, and seek
	     * to this new position.
	     *
	     */

	    /* We really want to update our position */
	    if (hwndCtl) {
		if (gdwSeekPosition) {
		    dwPosition = gdwSeekPosition;
		    gdwSeekPosition = 0;
		}

		/* Go back to the seek mode we were in before */
		/* we started scrolling.                      */
		SeekExactMCI(sfSeekExact);
		SeekMCI(dwPosition);
	    }

	    PrevMark = MARK_NONE;

	    return;

	default:
	    return;
    }
    SendMessage(ghwndTrackbar, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)dwPosition);
    /* Clamp to a valid range */
    dwPosition = SendMessage(ghwndTrackbar, TBM_GETPOS, 0, 0);

BreakOut:

    if (GetKeyState(VK_SHIFT) < 0)
	UpdateSelection(hwnd, dwPosition, &PrevMark);

    if (ghwndStatic) {
	FormatTime(dwPosition, NULL, ach, TRUE);
	//VIJR-SBSetWindowText(ghwndStatic, ach);
	WriteStatusMessage(ghwndStatic, ach);
    }

// Dirty if you just move the thumb???
//  if (!IsObjectDirty() && !gfCloseAfterPlaying) // don't want playing to dirty
//  DirtyObject();
}

void MPlayer_OnSysCommand(HWND hwnd, UINT cmd, int x, int y)
{
    RECT rc;

    // The bottom four bits of wParam contain system information. They
    // must be masked off in order to work out the actual command.
    // See the comments section in the online help for WM_SYSCOMMAND.

    switch (cmd & 0xFFF0) {

    case SC_MINIMIZE:
	DPF("minimized -- turn off timer\n");
	ClrWS(hwnd, WS_MAXIMIZE);
	EnableTimer(FALSE);
	break;

    case SC_MAXIMIZE:
	if (gfPlayOnly && !IsIconic(hwnd)) {
	    (void)PostMessage(hwnd, WM_COMMAND, (WPARAM)IDM_ZOOM2, 0);
	    return;
	}

	break;

    case SC_RESTORE:
	if (gfPlayOnly && !IsIconic(hwnd)) {
	    GetWindowRect(hwnd, &rc);
	    if (rc.left > 0 || rc.top > 0)
		(void)PostMessage(hwnd, WM_COMMAND, (WPARAM)IDM_ZOOM1, 0);
		return;
	}

	if (gwDeviceID != (UINT)0) {
	    DPF("un-minimized -- turn timer back on\n");
	    EnableTimer(TRUE);
	}

	break;
    }

    FORWARD_WM_SYSCOMMAND(hwnd, cmd, x, y, DefWindowProc);
}


int MPlayer_OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg)
{
    if (gfPlayingInPlace && !gfOle2IPPlaying)
	return MA_NOACTIVATE;
    else
	/* !!! Is this the right thing to do in this case? */
	return FORWARD_WM_MOUSEACTIVATE(hwnd, hwndTopLevel, codeHitTest, msg,
					DefWindowProc);
}


UINT MPlayer_OnNCHitTest(HWND hwnd, int x, int y)
{
    UINT Pos;

    Pos = FORWARD_WM_NCHITTEST(hwnd, x, y, DefWindowProc);

    if (gfPlayingInPlace && (Pos == HTCLIENT))
	Pos = HTNOWHERE;

    return Pos;
}


void MPlayer_OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized)
{
    HWND hwndT;

    gfAppActive = (state != WA_INACTIVE);

    // Put the playback window BEHIND us so it's kinda
    // visible, but not on top of us (annoying).
    if (gfAppActive && !ghwndMCI && !IsIconic(hwnd) &&
	((hwndT = GetWindowMCI()) != NULL))
    {
	SetWindowPos(hwndT, hwnd, 0, 0, 0, 0,
		     SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }

    if (gwDeviceID != (UINT)0)
	EnableTimer(TRUE);

    /* Remember who had focus if we're being de-activated. */
    /* Give focus back to him once we're re-activated.     */
    /* Don't remember a window that doesn't belong to us,  */
    /* or when we give focus back to it, we'll never be    */
    /* able to activate!                                   */

#if 0
    /* Commenting this out for now.  This code looks dubious.
     * wParam (as was) contains state and fMinimized, so, if we're minimized,
     * it will always be non-null.
     */

    if (wParam && ghwndFocus) {
	SetFocus(ghwndFocus);
    } else if (!wParam) {
	ghwndFocus = GetFocus();
    }
#endif

    FORWARD_WM_ACTIVATE(hwnd, state, hwndActDeact, fMinimized, DefWindowProc);
}

void MPlayer_OnSysColorChange(HWND hwnd)
{
    ControlCleanup();
    ControlInit(ghInst);

    FORWARD_WM_SYSCOLORCHANGE(ghwndToolbar, SendMessage);
    FORWARD_WM_SYSCOLORCHANGE(ghwndFSArrows, SendMessage);
    FORWARD_WM_SYSCOLORCHANGE(ghwndMark, SendMessage);
    FORWARD_WM_SYSCOLORCHANGE(ghwndTrackbar, SendMessage);
}


void MPlayer_OnDropFiles(HWND hwnd, HDROP hdrop)
{
    doDrop(hwnd, hdrop);
}


LRESULT MPlayer_OnNotify(HWND hwnd, int idFrom, NMHDR FAR* pnmhdr)
{
    LPTOOLTIPTEXT pTtt;
    LPTBNOTIFY    pTbn;
    TCHAR         ach[40];

    switch(pnmhdr->code) {

    case TTN_NEEDTEXT:

	pTtt = (LPTOOLTIPTEXT)pnmhdr;

	if (gfPlayOnly && (pTtt->hdr.idFrom != IDT_PLAY)
		       && (pTtt->hdr.idFrom != IDT_PAUSE)
		       && (pTtt->hdr.idFrom != IDT_STOP)
		       && !gfOle2IPEditing)
		    break;
	switch (pTtt->hdr.idFrom) {
	    case IDT_PLAY:
	    case IDT_PAUSE:
	    case IDT_STOP:
	    case IDT_EJECT:
	    case IDT_HOME:
	    case IDT_END:
	    case IDT_FWD:
	    case IDT_RWD:
	    case IDT_MARKIN:
	    case IDT_MARKOUT:
	    case IDT_ARROWPREV:
	    case IDT_ARROWNEXT:
		LOADSTRING(pTtt->hdr.idFrom, ach);
		lstrcpy(pTtt->szText, ach);
		break;
	    default:
		*pTtt->szText = TEXT('\0');
		break;
	}

	break;

    case TBN_BEGINDRAG:
	pTbn = (LPTBNOTIFY)pnmhdr;
	if(pTbn->iItem == IDT_ARROWPREV || pTbn->iItem == IDT_ARROWNEXT)
	    SendMessage(ghwndFSArrows, WM_STARTTRACK, (WPARAM)pTbn->iItem, 0L);
	else
	    SendMessage(ghwndToolbar, WM_STARTTRACK, (WPARAM)pTbn->iItem, 0L);
	break;

    case TBN_ENDDRAG:
	pTbn = (LPTBNOTIFY)pnmhdr;
	if(pTbn->iItem == IDT_ARROWPREV || pTbn->iItem == IDT_ARROWNEXT)
	    SendMessage(ghwndFSArrows, WM_ENDTRACK, (WPARAM)pTbn->iItem, 0L);
	else
	    SendMessage(ghwndToolbar, WM_ENDTRACK, (WPARAM)pTbn->iItem, 0L);
	break;
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * DeviceChange_Init
// First time initialization for WM_DEVICECHANGE messages
// This is specific to NT5
////////////////////////////////////////////////////////////////////////////////////////////
BOOL DeviceChange_Init(HWND hWnd)
{
	DEV_BROADCAST_DEVICEINTERFACE dbi;

	dbi.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    dbi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    dbi.dbcc_reserved   = 0;
    dbi.dbcc_classguid  = KSCATEGORY_AUDIO;
    dbi.dbcc_name[0] = TEXT('\0');

    MixerEventContext = RegisterDeviceNotification(hWnd,
                                         (PVOID)&dbi,
										 DEVICE_NOTIFY_WINDOW_HANDLE);
	if(!MixerEventContext)
		return FALSE;
	
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
// * DeviceChange_Cleanup
// Unregister the device notification.
////////////////////////////////////////////////////////////////////////////////////////////
void DeviceChange_Cleanup()
{
   if (MixerEventContext) {
       UnregisterDeviceNotification(MixerEventContext);
       MixerEventContext = NULL;
       }

   return;
}


void DisplayNoMciDeviceError()
{
    DWORD ErrorID;

    if (!lstrcmpi(gachOpenExtension, aszKeyMID))
	ErrorID = IDS_CANTPLAYMIDI;

    else if (!lstrcmpi(gachOpenExtension, aszKeyAVI))
	ErrorID = IDS_CANTPLAYVIDEO;

    else if (!lstrcmpi(gachOpenExtension, aszKeyWAV))
	ErrorID = IDS_CANTPLAYSOUND;

    else
	ErrorID = IDS_NOMCIDEVICES;

    Error(ghwndApp, ErrorID);
}


/*
 * MPlayerWndProc(hwnd, wMsg, wParam, lParam)
 *
 * This is the message processing routine for the MPLAYERBOX (main) dialog.
 *
 */
//Harmless message-cracker because the user guys will not fix their
//windowsx.h macro which cause the irritating rip.
//This is also a wee bit faster because the message
//is forwarded only on select and not on deselects.     Also we do not care
//about the params
#define HANDLE_MPLAYER_WM_MENUSELECT(hwnd, message, fn)                  \
    case (message): if(lParam)  ((fn)((hwnd), (HMENU)(lParam), (UINT)LOWORD(wParam), 0L, 0L )); break;

LRESULT FAR PASCAL MPlayerWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg) {

	HANDLE_MSG(hwnd, WM_CREATE,            MPlayer_OnCreate);
	HANDLE_MSG(hwnd, WM_SHOWWINDOW,        MPlayer_OnShowWindow);
	HANDLE_MSG(hwnd, WM_SIZE,              MPlayer_OnSize);
	HANDLE_MSG(hwnd, WM_WINDOWPOSCHANGING, MPlayer_OnWindowPosChanging);
	HANDLE_MSG(hwnd, WM_WINDOWPOSCHANGED,  MPlayer_OnWindowPosChanged);
	HANDLE_MSG(hwnd, WM_PALETTECHANGED,    MPlayer_OnPaletteChanged);
	HANDLE_MSG(hwnd, WM_QUERYNEWPALETTE,   MPlayer_OnQueryNewPalette);
	HANDLE_MSG(hwnd, WM_CTLCOLORSTATIC,    MPlayer_OnCtlColor);
	HANDLE_MSG(hwnd, WM_WININICHANGE,      MPlayer_OnWinIniChange);
	HANDLE_MPLAYER_WM_MENUSELECT(hwnd, WM_MENUSELECT,        MPlayer_OnMenuSelect);
	HANDLE_MSG(hwnd, WM_NCLBUTTONDOWN,     MPlayer_OnNCLButtonDown);
	HANDLE_MSG(hwnd, WM_NCLBUTTONDBLCLK,   MPlayer_OnNCLButtonDblClk);
	HANDLE_MSG(hwnd, WM_INITMENU,          MPlayer_OnInitMenu);
	HANDLE_MSG(hwnd, WM_INITMENUPOPUP,     MPlayer_OnInitMenuPopup);
	HANDLE_MSG(hwnd, WM_GETMINMAXINFO,     MPlayer_OnGetMinMaxInfo);
	HANDLE_MSG(hwnd, WM_PAINT,             MPlayer_OnPaint);
	HANDLE_MSG(hwnd, WM_COMMAND,           MPlayer_OnCommand);
	HANDLE_MSG(hwnd, WM_CLOSE,             MPlayer_OnClose);
	HANDLE_MSG(hwnd, WM_ENDSESSION,        MPlayer_OnEndSession);
	HANDLE_MSG(hwnd, WM_DESTROY,           MPlayer_OnDestroy);
	HANDLE_MSG(hwnd, WM_TIMER,             MPlayer_OnTimer);
	HANDLE_MSG(hwnd, WM_HSCROLL,           MPlayer_OnHScroll);
	HANDLE_MSG(hwnd, WM_SYSCOMMAND,        MPlayer_OnSysCommand);
	HANDLE_MSG(hwnd, WM_MOUSEACTIVATE,     MPlayer_OnMouseActivate);
	HANDLE_MSG(hwnd, WM_NCHITTEST,         MPlayer_OnNCHitTest);
	HANDLE_MSG(hwnd, WM_ACTIVATE,          MPlayer_OnActivate);
	HANDLE_MSG(hwnd, WM_SYSCOLORCHANGE,    MPlayer_OnSysColorChange);
	HANDLE_MSG(hwnd, WM_DROPFILES,         MPlayer_OnDropFiles);
	HANDLE_MSG(hwnd, WM_NOTIFY,            MPlayer_OnNotify);

	/* Other bits of stuff that need tidying up sometime:
	 */

	case WM_NOMCIDEVICES:
	    /* This was posted by the thread building the Device
	     * menu to tell us it couldn't find any MCI devices.
	     */
	    DisplayNoMciDeviceError();
	    PostMessage(ghwndApp, WM_CLOSE, 0, 0);
	    break;

	case WM_GETDIB:
	    return (LRESULT)GetDib();

	case WM_DEVICECHANGE :
	    {
			//if plug-and-play sends this, pass it along to the component
        	PDEV_BROADCAST_DEVICEINTERFACE bid = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;

			//Check to see if this is a audio message
			if (!MixerEventContext || !bid ||
			bid->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE ||
			!IsEqualGUID(&KSCATEGORY_AUDIO, &bid->dbcc_classguid) ||
			!(*bid->dbcc_name))
			{
				break;
			}
			else
			{
				switch(wParam)
				{
					case DBT_DEVICEQUERYREMOVE:
						CloseMCI(TRUE);          //Close the MCI device
						break;
				
			        case DBT_DEVICEREMOVECOMPLETE:
						CloseMCI(TRUE);          //Close the MCI device
						break;

					default:
						break;
				}
			}
	    }

	case WM_ENTERSIZEMOVE:
	    if (!IsIconic(hwnd) && !gfPlayOnly && !gfOle2IPEditing && !gfOle2IPPlaying)
	    {
		/* Save the current window position in x, y, dx, dy format:
		 */
		GetWindowRect(hwnd, (PRECT)&posSizeMove);
		posSizeMove.cx -= posSizeMove.x;
		posSizeMove.cy -= posSizeMove.y;
	    }
	    break;

	case WM_EXITSIZEMOVE:
	    SetRectEmpty((PRECT)&posSizeMove);
	    break;

	case WM_DOLAYOUT:
	    Layout();
	    break;

	case WM_BADREG:
	    if ( IDYES == ErrorResBox(hwnd, NULL,
		MB_YESNO | MB_ICONEXCLAMATION, IDS_APPNAME, IDS_BADREG) )
		if (!SetRegValues())
		    Error(ghwndApp, IDS_FIXREGERROR);
	    break;

	case WM_SEND_OLE_CHANGE:
	    fDocChanged = TRUE;
	    SendDocMsg((LPDOC)&docMain,OLE_CHANGED);
	    break;

	case MM_MCINOTIFY:
#if 0
	    //
	    // don't do this because, some devices send notify failures
	    // where there really is not a error.
	    //
	    if ((WORD)wParam == MCI_NOTIFY_FAILURE) {
		Error(ghwndApp, IDS_NOTIFYFAILURE);
	    }
#endif
	    UpdateDisplay();
	    break;

#ifdef OLE1_HACK
    /* Actually do the FixLink, SetData and DoVerb we've been putting off */
    /* for so long.                                                       */
	case WM_DO_VERB:
	    /* This message comes from server.c (and goes back there too) */
	    DelayedFixLink(wParam, LOWORD(lParam), HIWORD(lParam));  //OK on NT. LKG
	    break;
#endif /* OLE1_HACK */

#ifdef LATER
	// We'll need to call RegisterWindowMessage and provide a message hook proc
	// for this on Win32.

	case WM_HELP:
	    WinHelp(hwnd, TEXT("MPLAYER.HLP"), HELP_PARTIALKEY,
			    (DWORD)aszNULL);
	    return TRUE;
#endif /* LATER */

	case WM_USER_DESTROY:
	    DPF("WM_USER_DESTROY received\n");

	    if (gfPlayingInPlace) {
		DPF("****\n");
		DPF("**** Window destroyed while in place!\n");
		DPF("****\n");
		EndPlayInPlace(hwnd);
	    }

	    if (gfOle2IPEditing) {
		EndEditInPlace(hwnd);
	    }

	    if (!ItsSafeToClose()) {
		DPF("*** \n");
		DPF("*** Trying to destroy MPLAYER with an ErrorBox up\n");
		DPF("*** \n");
		gfErrorDeath = WM_USER_DESTROY;
		return TRUE;
	    }

	    if (!gfRunWithEmbeddingFlag)
		WriteOutPosition();

	    DestroyWindow(hwnd);
	    DestroyIcon(hiconApp);
	    return TRUE;

	case WM_USER+500:
	    /*
	    ** This message is sent by the HookProc inside mciole32.dll when
	    ** it detects that it should stop playing in place of a WOW client
	    ** application.
	    **
	    ** Because the OleActivate originated in mciole16.dll,
	    ** mciole32.dll does not know the OLE Object that is being
	    ** played and therefore dose not know how to close that object.
	    ** Only mplay32.exe has the necessary information, hence
	    ** mciole32.dll sends this message to mplay32.exe.
	    */
	    if (gfPlayingInPlace) {
		EndPlayInPlace(hwnd);
	    }
	    PostMessage( hwnd, WM_CLOSE, 0L, 0L );
	    break;
    }

    return DefWindowProc(hwnd, wMsg, wParam, lParam);
}



/* InitInstance
 * ------------
 *
 * Create brushes used by the program, the main window, and
 * do any other per-instance initialization.
 *
 * HANDLE hInstance
 *
 * RETURNS: TRUE if successful
 *          FALSE otherwise.
 *
 * CUSTOMIZATION: Re-implement
 *
 */
BOOL InitInstance (HANDLE hInstance)
{
    HDC      hDC;

	static SZCODE   aszNative[] = TEXT("Native");
	static SZCODE   aszEmbedSrc[] = TEXT("Embed Source");
	static SZCODE   aszObjDesc[] = TEXT("Object Descriptor");
	static SZCODE   aszMplayer[] = TEXT("mplayer");
	static SZCODE   aszClientDoc[] = TEXT("Client Document");

    /* Why doesn't RegisterClipboardFormat return a value of type CLIPFORMAT (WORD)
     * instead of UINT?
     */
    cfNative           = (CLIPFORMAT)RegisterClipboardFormat (aszNative);
    cfEmbedSource      = (CLIPFORMAT)RegisterClipboardFormat (aszEmbedSrc);
    cfObjectDescriptor = (CLIPFORMAT)RegisterClipboardFormat (aszObjDesc);
    cfMPlayer          = (CLIPFORMAT)RegisterClipboardFormat (aszMplayer);

    szClient[0] = TEXT('\0');

    lstrcpy (szClientDoc, aszClientDoc);

    // Initialize global variables with LOGPIXELSX and LOGPIXELSY

    hDC    = GetDC (NULL);    // Get the hDC of the desktop window
    giXppli = GetDeviceCaps (hDC, LOGPIXELSX);
    giYppli = GetDeviceCaps (hDC, LOGPIXELSY);
    ReleaseDC (NULL, hDC);

    return TRUE;
}


#define COINIT_APARTMENTTHREADED 2

/* InitOLE
 *
 * This should be called only when we're certain that OLE is needed,
 * to avoid loading loads of unnecessary stuff.
 *
 */
BOOL InitOLE (PBOOL pfInit, LPMALLOC *ppMalloc)
{
    HRESULT  hr;

    if (*pfInit)
	return TRUE;

    hr = (HRESULT)OleInitialize(NULL);

    if (!SUCCEEDED (hr))
    {
	DPF0("OleInitialize failed with error 0x%08x\n", hr);
	Error(NULL, IDS_OLEINIT);
	return FALSE;
    }

    if (ppMalloc && (CoGetMalloc(MEMCTX_TASK, ppMalloc) != S_OK))
    {
	Error(NULL, IDS_OLENOMEM);
	OleUninitialize();
	return FALSE;
    }
    /*****************************************************************
    ** OLE2NOTE: we must remember the fact that OleInitialize has
    **    been called successfully. the very last thing an app must
    **    do is properly shut down OLE by calling
    **    OleUninitialize. This call MUST be guarded! it is only
    **    allowable to call OleUninitialize if OleInitialize has
    **    been called SUCCESSFULLY.
    *****************************************************************/

    *pfInit = TRUE;

    return TRUE;
}


// This function cleans up all the OLE2 stuff. It lets the container
// save the object and informs that it is closing.
BOOL ExitApplication ()
{

    DPFI("\n*******Exitapp\n");
    // if we registered class factory, we must revoke it
    if(gfOle2IPEditing || gfOle2IPPlaying)
	DoInPlaceDeactivate((LPDOC)&docMain);

    SendDocMsg((LPDOC)&docMain,OLE_CLOSED);
    if (srvrMain.fEmbedding) {
	HRESULT status;
	srvrMain.fEmbedding = FALSE;    // HACK--guard against revoking twice
	status = (HRESULT)CoRevokeClassObject (srvrMain.dwRegCF);
    }

    return TRUE;
}


#ifdef DEBUG

/* DbgGlobalLock
 *
 * Debug wrapper for GlobalLock
 *
 * Checks that the memory handle to be locked isn't already locked,
 * and checks the return code from GlobalLock.
 *
 * andrewbe, 1 March 1995
 */
LPVOID DbgGlobalLock(HGLOBAL hglbMem)
{
    LPVOID lpReturn;

    if (GlobalFlags(hglbMem) & GMEM_LOCKCOUNT)
	DPF0("Calling GlobalLock on already locked memory object %08x\n", hglbMem);

    lpReturn = GlobalLock(hglbMem);

    if (lpReturn == NULL)
	DPF0("GlobalLock(%08x) failed: Error %d\n", hglbMem, GetLastError());

    return lpReturn;
}


/* DbgGlobalUnlock
 *
 * Debug wrapper for GlobalUnlock
 *
 * Checks the return code from GlobalUnlock, and outputs appropriate
 * error messages
 *
 * andrewbe, 1 March 1995
 */
BOOL DbgGlobalUnlock(HGLOBAL hglbMem)
{
    BOOL boolReturn;

    boolReturn = GlobalUnlock(hglbMem);

    if ((boolReturn) && (GlobalFlags(hglbMem) & GMEM_LOCKCOUNT))
    {
	DPF0("Locks still outstanding on memory object %08x\n", hglbMem);
    }
    else
    {
	DWORD Error = GetLastError();

	if (Error == ERROR_NOT_LOCKED)
	{
	    DPF0("Attempt to unlock already unlocked memory object %08x\n", hglbMem);
	}
	else if (Error != NO_ERROR)
	{
	    DPF0("Error %d attempting to unlock memory object %08x\n", Error, hglbMem);
	}
    }

    return boolReturn;
}


/* DbgGlobalFree
 *
 * Debug wrapper for GlobalFree.
 *
 * Checks that the global handle has no locks before freeing,
 * then checks that the call succeeded.  Error messages output
 * as appropriate.
 *
 * andrewbe, 1 March 1995
 *
 */
HGLOBAL DbgGlobalFree(HGLOBAL hglbMem)
{
    HGLOBAL hglbReturn;

    if (GlobalFlags(hglbMem) & GMEM_LOCKCOUNT)
	DPF0("Freeing global memory object %08x still locked\n", hglbMem);

    hglbReturn = GlobalFree(hglbMem);

    if (hglbReturn != NULL)
	DPF0("GlobalFree(%08x) failed: Error %d\n", hglbMem, GetLastError());

    return hglbReturn;
}


#ifdef UNICODE
/* Note: This function assumes that szFormat strings are NOT unicode.
 * Unicode var params may, however, be passed, as long as %ws is specified
 * in the format string.
 */
#endif
void FAR cdecl dprintf(LPSTR szFormat, ...)
{
    CHAR ach[_MAX_PATH * 3]; // longest I think we need
    int  s,d;
    va_list va;

    va_start(va, szFormat);
    s = wvsprintfA(ach,szFormat, va);
    va_end(va);

#if 0
    strcat(ach,"\n");
    s++;
#endif
    for (d=sizeof(ach)-1; s>=0; s--)
    {
	if ((ach[d--] = ach[s]) == TEXT('\n'))
	    ach[d--] = TEXT('\r');
    }

    /* Not unicode */
    if (*(ach+d+1) != ' ')
	OutputDebugStringA("MPLAYER: ");
    OutputDebugStringA(ach+d+1);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\ole1.c ===
/*-----------------------------------------------------------------------------+
| OLE1.C                                                                       |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
| 02-Jun-94 AndrewBe created, based upon the OLE1 SERVER.C                     |
|                                                                              |
+-----------------------------------------------------------------------------*/

#ifdef OLE1_HACK

/* This was originally server.c in the OLE1 Media Player.
 * It is here somewhat munged to bolt onto the side of the OLE2 Media Player,
 * to get around the fact that OLE1/OLE2 interoperability is broken in Daytona.
 *
 * The OLE2 interface is Unicode, whereas the OLE1 interface is ANSI.
 * This accounts for some, though probably not all, of the horrors that are
 * about to unfold before your eyes.
 */

#ifndef UNICODE
#error This file assumes that UNICODE is defined.
#endif

#undef UNICODE

#define SERVERONLY
#include <windows.h>
#include <commdlg.h>
#include <mmsystem.h>
#include <port1632.h>
#include <shellapi.h>
#include <string.h>
#include <ole.h>
#include "mplayer.h"
#include "ole1.h"

//////////////////////////////////////////////////////////////////////////
//
// (c) Copyright Microsoft Corp. 1991 - All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////
#include <stdlib.h>
#undef _MAX_PATH             // ??? someone hacking?
#undef _MAX_DIR              // ??? someone hacking?
#undef _MAX_FNAME            // ??? someone hacking?
#undef _MAX_EXT              // ??? someone hacking?
#include "toolbar.h"

DWORD gDocVersion = DOC_VERSION_NONE;

extern PSTR     gpchFilter;

#define WAITDIFFERENTLY         // dont ask....

extern   UINT  gwPlaybarHeight;   // tell playbar how tall to make itself
                                            // so it covers the title
STATICDT BOOL  gfMouseUpSeen = FALSE;     // OK to close play in place?
STATICDT BOOL  gfKeyStateUpSeen = FALSE;  // OK to close play in place?

/* Height of picture given to client to be pasted */
STATICDT UINT  gwPastedHeight;

/* DELAYED BROKEN LINK */
extern   WCHAR gachFile[MAX_PATH];
STATICDT CHAR  gachDeviceA[80];
STATICDT WCHAR gachDeviceW[80];
extern   BOOL  gfBrokenLink;
STATICDT int   gerr;
STATICDT HWND  ghwndClient = NULL;
STATICDT RECT  grcClient;
/* ........................ */

extern  HANDLE  ghInst;
extern  POINT   gptBtnSize;

#define abs(x) ((x) < 0 ? -(x) : (x))

/**************************************************************************
***************************************************************************/

#ifndef GetWS
#define GetWS(hwnd)     GetWindowLongPtr(hwnd, GWL_STYLE)
#define PutWS(hwnd, f)  SetWindowLongPtr(hwnd, GWL_STYLE, f)
#define TestWS(hwnd,f)  (GetWS(hwnd) & f)
#define SetWS(hwnd, f)  PutWS(hwnd, GetWS(hwnd) | f)
#define ClrWS(hwnd, f)  PutWS(hwnd, GetWS(hwnd) & ~(f))
#endif

/************************************************************************
   Important Note:

   No method should ever dispatch a DDE message or allow a DDE message to
   be dispatched.
   Therefore, no method should ever enter a message dispatch loop.
   Also, a method should not show a dialog or message box, because the
   processing of the dialog box messages will allow DDE messages to be
   dispatched.

   the hacky way we enforce this is with the global <gfErrorBox>.  see
   errorbox.c and all the "gfErrorBox++"'s in this file.

   Note that we are an exe, not a DLL, so this does not rely on
   non-preemptive scheduling.  Should be OK on NT too.

***************************************************************************/


/**************************************************************************

    GLOBALS

***************************************************************************/

STATICDT BOOL    gfUnblockServer;        //
STATICDT int     nBlockCount;

#ifndef _WIN32
HHOOK    hHookMouse;            // Mouse hook handle.
HOOKPROC fpMouseHook;           // Mouse hook proc address.
#else

/*
** These functions are exported from mciole32.dll.
**
*/
typedef BOOL (*LPINSTALLHOOK)( HWND, DWORD );
typedef BOOL (*LPREMOVEHOOK)( VOID );

LPINSTALLHOOK       fpInstallHook;
LPREMOVEHOOK        fpRemoveHook;
BOOL                fHookInstalled = FALSE;

#endif

HWND    ghwndFocusSave;         // saved focus window

HMODULE hMciOle;

OLECLIPFORMAT    cfLink;
OLECLIPFORMAT    cfOwnerLink;
OLECLIPFORMAT    cfNative;

OLESERVERDOCVTBL     docVTbl;
OLEOBJECTVTBL       itemVTbl;
OLESERVERVTBL       srvrVTbl;

SRVR    gSrvr;
OLE1DOC     gDoc;
ITEM    gItem;

/**************************************************************************

    STRINGS

***************************************************************************/

#ifdef _WIN32
STATICDT  ANSI_SZCODE aszInstallHook[]  = "InstallHook";
STATICDT  ANSI_SZCODE aszRemoveHook[]   = "RemoveHook";
#endif

extern    ANSI_SZCODE aszAppName[]      = "MPlayer";


/* Formatting characters for string macros:
 */

STATICDT  WCHAR szFormatAnsiToUnicode[]     = L"%hs";
STATICDT  CHAR  szFormatUnicodeToAnsi[]     = "%ws";
STATICDT  WCHAR szFormatUnicodeToUnicode[]  = L"%ws";

/* Unicode - ANSI string-copying macros:
 */

#define COPYSTRINGA2W(pTarget, pSource) wsprintfW(pTarget, szFormatAnsiToUnicode, pSource)
#define COPYSTRINGW2A(pTarget, pSource) wsprintfA(pTarget, szFormatUnicodeToAnsi, pSource)
#define COPYSTRINGW2W(pTarget, pSource) wsprintfW(pTarget, szFormatUnicodeToUnicode, pSource)



/**************************************************************************
***************************************************************************/

void FAR PASCAL Ole1PlayInPlace(HWND hwndApp, HWND hwndClient, LPRECT prc);
void FAR PASCAL Ole1EndPlayInPlace(HWND hwndApp);
OLESTATUS FAR PASCAL  ItemSetData1(LPOLEOBJECT lpoleobject, OLECLIPFORMAT cfFormat, HANDLE hdata);
BOOL NEAR PASCAL ScanCmdLine(LPSTR szCmdLine);
STATICFN int NEAR PASCAL Ole1ReallyDoVerb(LPOLEOBJECT lpobj, UINT verb, BOOL fShow, BOOL fActivate);
STATICFN OLESTATUS NEAR PASCAL SetDataPartII(LPWSTR szFile, LPWSTR szDevice);
STATICFN BOOL NetParseFile(LPSTR szFile, LPSTR szPath);

int FAR PASCAL ParseOptions(LPTSTR pOpt);
extern BOOL FindRealFileName(LPTSTR szFile, int iLen);
HWND TopWindow(HWND hwnd);
void PASCAL DinkWithWindowStyles(HWND hwnd, BOOL fRestore);
HANDLE GetLink( VOID );

/*
 *
 */
VOID SetDocVersion( DWORD DocVersion )
{
#if DBG
    if( ( DocVersion != DOC_VERSION_NONE ) && ( gDocVersion != DOC_VERSION_NONE ) )
    {
        DPF0( "Expected gDocVersion == 0!!  It's %u\n", gDocVersion );
    }
#endif /* DBG */

    gDocVersion = DocVersion;

    DPF0( "gDocVersion set to %u\n", DocVersion );
}


/**************************************************************************
* Ole1UpdateObject() - handle the update of the object
*
***************************************************************************/

void Ole1UpdateObject(void)
{
    if (gfEmbeddedObject) {
        //
        //  some client's (ie Excel 3.00 and PowerPoint 1.0) dont
        //  handle saved notifications, they expect to get a
        //  OLE_CLOSED message.
        //
        //  we will send a OLE_CLOSED message right before we
        //  revoke the DOC iff gfDirty == -1, see FileNew()
        //
        if (SendChangeMsg(OLE_SAVED) == OLE_OK)
            CleanObject();
        else {
            DPF("Unable to update object, setting gfDirty = -1\n");
            gfDirty = -1;
        }
    }
}


/*
 *
 */
BOOL FAR PASCAL Ole1FixLinkDialog(LPSTR szFile, LPSTR szDevice, int iLen)
{
    UINT        wDevice;
    char        achFile[MAX_PATH + 1];  /* file or device name buffer  */
    char        achTitle[80];   /* string holding the title bar name    */
    HWND        hwndFocus;
    OPENFILENAME ofn;
    BOOL        f;

    static SZCODE   aszDialog[] = "MciOpenDialog"; // in open.c too.

    //
    // I GIVE UP!!!  Put up an open dlg box and let them find it themselves!
    //

    // If we haven't initialized the device menu yet, do it now.
    if (gwNumDevices == 0)
        InitDeviceMenu();

    // find out the device number for the specifed device
    wDevice = gwCurDevice;

    LoadString(ghInst, IDS_FINDFILE, achFile, CHAR_COUNT(achFile));
    wsprintf(achTitle, achFile, FileName(szFile));  // title bar for locate dlg

    /* Start with the bogus file name */
    lstrcpy(achFile, FileName(szFile));

    /* Set up the ofn struct */
    ofn.lStructSize = sizeof(OPENFILENAME);

    /* MUST use ActiveWindow to make user deal with us NOW in case of multiple*/
    /* broken links                                                           */
    ofn.hwndOwner = GetActiveWindow();

    ofn.hInstance = ghInst;
    ofn.lpstrFilter = gpchFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;

    if (wDevice == 0)
        ofn.nFilterIndex = gwNumDevices+1;      // select "All Files"
    else
        ofn.nFilterIndex = wDevice;

    ofn.lpstrFile       = achFile;
    ofn.nMaxFile        = sizeof(achFile);
    ofn.lpstrFileTitle  = NULL;
    ofn.nMaxFileTitle   = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle      = achTitle;

    // ofn.Flags = OFN_ENABLETEMPLATE | OFN_HIDEREADONLY | OFN_FILEMUSTEXIST |
    ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST |
                OFN_SHAREAWARE | OFN_PATHMUSTEXIST;

    ofn.nFileOffset     = 0;
    ofn.nFileExtension  = 0;
    ofn.lpstrDefExt     = NULL;
    ofn.lCustData       = 0;
    ofn.lpfnHook        = NULL;
    // ofn.lpTemplateName  = aszDialog;
    ofn.lpTemplateName  = NULL;

    // Show the cursor in case PowerPig is hiding it
    ShowCursor(TRUE);

    hwndFocus = GetFocus();

    /* Let the user pick a filename */
    BlockServer();
    gfErrorBox++;
    f = GetOpenFileName(&ofn);
    if (f) {
        lstrcpyn(szFile, achFile, iLen);
        gfDirty = TRUE;       // make sure the object is dirty now
    }
    gfErrorBox--;
    UnblockServer();

    SetFocus(hwndFocus);

    // Put cursor back how it used to be
    ShowCursor(FALSE);

    return f;
}


/**************************************************************************/
/* We've just gotten our delayed message that we need to bring up an open */
/* dialog to let the user fix the broken link, and then we can finish the */
/* SetData and the DoVerb.                                                */
/**************************************************************************/
void FAR PASCAL DelayedFixLink(UINT verb, BOOL fShow, BOOL fActivate)
{
    CHAR achFileA[MAX_PATH];

    gfBrokenLink = FALSE;

    COPYSTRINGW2A(gachDeviceA, garMciDevices[gwCurDevice].szDevice);
    COPYSTRINGW2W(gachDeviceW, garMciDevices[gwCurDevice].szDevice);
    COPYSTRINGW2A(achFileA, gachFile);

    /* Something goes wrong?  Get out of here and give up. */
    if (!Ole1FixLinkDialog(achFileA, gachDeviceA, CHAR_COUNT(achFileA)) ||
                            SetDataPartII(gachFile, gachDeviceW) != OLE_OK)
        PostMessage(ghwndApp, WM_CLOSE, 0, 0L);    // GET OUT !!!
    else
        Ole1ReallyDoVerb(NULL, verb, fShow, fActivate);
}



/**************************************************************************
***************************************************************************/

BOOL FAR PASCAL InitOle1Server(HWND hwnd, HANDLE hInst)
{
    long        cb;
    int         err;
    char        aszPlay[40];
    char        aszEdit[40];

#ifdef _WIN32
    /*
    ** On NT we have to install a global mouse HookProc which has to
    ** in a DLL.  Also we have to tell the DLL which process/thread we are
    ** interested in, therefore let the DLL install the HookProc.  When the
    ** HookProc detects an "interesting" mouse message it stops the
    ** device from playing.  However, the device "stopping" function is
    ** inside mplayer, so we have to export it so that the HookProc can
    ** call it.
    */
    if ( hMciOle ) {

        fpInstallHook = (LPINSTALLHOOK)GetProcAddress(hMciOle, aszInstallHook);
        fpRemoveHook = (LPREMOVEHOOK)GetProcAddress(hMciOle, aszRemoveHook);
    }
    else {
        fpInstallHook = NULL;
        fpRemoveHook = NULL;
    }
#endif

    cfLink      = RegisterClipboardFormat("Link");
    cfOwnerLink = RegisterClipboardFormat("OwnerLink");

// The scheme of casting everything to FARPROC relies on then being able
// to do a cast on lvalue later to make it all work.  Last time I checked
// that wouldn't wash on MIPS.  So we have be a little cleaner.
    #define MPI(fn) MakeProcInstance((FARPROC)fn, hInst);

    //
    // srvr vtable.
    //
    *(FARPROC*)&srvrVTbl.Open               = MPI(SrvrOpen);
    *(FARPROC*)&srvrVTbl.Create             = MPI(SrvrCreate);
    *(FARPROC*)&srvrVTbl.CreateFromTemplate = MPI(SrvrCreateFromTemplate);
    *(FARPROC*)&srvrVTbl.Edit               = MPI(SrvrEdit);
    *(FARPROC*)&srvrVTbl.Exit               = MPI(SrvrExit);
    *(FARPROC*)&srvrVTbl.Release            = MPI(SrvrRelease1);
    *(FARPROC*)&srvrVTbl.Execute            = MPI(SrvrExecute);

    //
    // doc table
    //
    *(FARPROC*)&docVTbl.Save                = MPI(DocSave);
    *(FARPROC*)&docVTbl.Close               = MPI(DocClose);
    *(FARPROC*)&docVTbl.GetObject           = MPI(DocGetObject);
    *(FARPROC*)&docVTbl.Release             = MPI(DocRelease);
    *(FARPROC*)&docVTbl.SetHostNames        = MPI(DocSetHostNames);
    *(FARPROC*)&docVTbl.SetDocDimensions    = MPI(DocSetDocDimensions);
    *(FARPROC*)&docVTbl.SetColorScheme      = MPI(DocSetColorScheme);
    *(FARPROC*)&docVTbl.Execute             = MPI(DocExecute);

    //
    // item table.
    //
    *(FARPROC*)&itemVTbl.Show               = MPI(ItemOpen);
    *(FARPROC*)&itemVTbl.DoVerb             = MPI(ItemDoVerb);
    *(FARPROC*)&itemVTbl.GetData            = MPI(ItemGetData);
    *(FARPROC*)&itemVTbl.SetData            = MPI(ItemSetData1);
    *(FARPROC*)&itemVTbl.Release            = MPI(ItemRelease);
    *(FARPROC*)&itemVTbl.SetTargetDevice    = MPI(ItemSetTargetDevice);
    *(FARPROC*)&itemVTbl.EnumFormats        = MPI(ItemEnumFormats);
    *(FARPROC*)&itemVTbl.SetBounds          = MPI(ItemSetBounds);
    *(FARPROC*)&itemVTbl.SetColorScheme     = MPI(ItemSetColorScheme);

    gSrvr.lhsrvr = 0L;
    gDoc.lhdoc = 0L;
    gItem.lpoleclient = NULL;

    gSrvr.olesrvr.lpvtbl = &srvrVTbl;

    err = OleRegisterServer(aszAppName, (LPOLESERVER)&gSrvr,
                &gSrvr.lhsrvr, hInst, OLE_SERVER_MULTI);

    if (err != OLE_OK) {
        gSrvr.lhsrvr = 0L;
        Error(ghwndApp, IDS_CANTSTARTOLE);
        return TRUE;
    }
    gSrvr.hwnd = hwnd;        // corresponding main window

    return TRUE;
}

/**************************************************************************
***************************************************************************/

void FAR PASCAL TermServer(void)
{
    if (hMciOle)
        FreeLibrary(hMciOle);
}

/**************************************************************************
***************************************************************************/

void FAR PASCAL NewDoc(BOOL fUntitled)
{
    //
    //  some client's (ie Excel 3.00 and PowerPoint 1.0) dont
    //  handle saved notifications, they expect to get a
    //  OLE_CLOSED message.
    //
    //  if the user has chosen to update the object, but the client did
    //  not then send a OLE_CLOSED message.
    //
    if (gfEmbeddedObject && IsObjectDirty()) {

        UpdateObject();

        if (gfDirty == -1)
            SendChangeMsg(OLE_CLOSED);

        CleanObject();
    }

    BlockServer();
    /* !!! If PlayMCI errors, and we close the client, we get called, but */
    /* we can't CloseMCI now or we'll explode.                            */
    if (!gfErrorBox && IsWindowEnabled(ghwndApp))
        CloseMCI(TRUE);

    // app.c has a better way of not dispatching evil timer messages
#if 0
    // A leftover WM_TIMER is UAE'ing Packager going down
    if (PeekMessage(&msg, NULL, WM_TIMER, WM_TIMER, PM_REMOVE | PM_NOYIELD)) {
        DPF("Ack! *** We removed a WM_TIMER msg from someone's queue!\n");
    }
#endif

    UnblockServer();

    RevokeDocument();

    //
    // register a "untitled" doc?????
    //
    if (fUntitled) {
        LoadStringW(ghInst, IDS_UNTITLED, (LPWSTR)gachFileDevice, 40);
        RegisterDocument(0,0);
    }
}

/**************************************************************************
***************************************************************************/

void FAR PASCAL ServerUnblock()
{
    if (gfUnblockServer)
    {
       BOOL fMoreMsgs = TRUE;

       while (fMoreMsgs && gSrvr.lhsrvr)
           OleUnblockServer (gSrvr.lhsrvr, &fMoreMsgs);

       // We have taken care of all the messages in the OLE queue
       gfUnblockServer = FALSE;
    }
}

/**************************************************************************
***************************************************************************/

void FAR PASCAL BlockServer()
{
//    gfErrorBox++;

    if (nBlockCount++ == 0)
        OleBlockServer(gSrvr.lhsrvr);
}

/**************************************************************************
***************************************************************************/

void FAR PASCAL UnblockServer()
{
    /* Don't wrap around! */
    if (!nBlockCount)
        return;

    if (--nBlockCount == 0)
        gfUnblockServer = TRUE;

//    gfErrorBox--;
}

/**************************************************************************
***************************************************************************/

void FAR PASCAL TerminateServer(void)
{
    LHSERVER lhsrvr;

    if (gfPlayingInPlace)
        Ole1EndPlayInPlace(ghwndApp);

    // Is this right?
    DPF("IDM_EXIT: Revoking server...\n");

    lhsrvr = gSrvr.lhsrvr;
    if (lhsrvr) {
        ServerUnblock();
        gSrvr.lhsrvr = (LHSERVER)0;
////////ShowWindow(ghwndApp,SW_HIDE);  // Insert 2nd obj over 1st in Write bug
        // RevokeServer won't Destroy us
        OleRevokeServer(lhsrvr);
    } else {
        /* Probably, there never was a server... */
        DPF("Closing application window\n");
        // This delete server should release the server immediately
        // EndDialog(ghwndApp, TRUE);
        // DestroyWindow(ghwndApp);
        PostMessage(ghwndApp, WM_USER_DESTROY, 0, 0);
    }
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL SrvrRelease1 (LPOLESERVER lpolesrvr)
{
    LHSERVER lhsrvr;

    /* If we're visible, but we don't want to be released, then ignore. */
    if (gSrvr.lhsrvr && (IsWindowVisible(ghwndApp) || !gfRunWithEmbeddingFlag)) {
        DPF("SrvrRelease: Ignoring releases...\n");
        return OLE_OK;
    }

    lhsrvr = gSrvr.lhsrvr;
    if (lhsrvr) {
        DPF("SrvrRelease: Calling RevokeServer\n");
        ServerUnblock();
        gSrvr.lhsrvr = 0;
        OleRevokeServer(lhsrvr);
    } else {
        DPF("SrvrRelease: Closing application window\n");
        // This delete server should release the server immediately
        // EndDialog(ghwndApp, TRUE);
        // DestroyWindow(ghwndApp);

        PostMessage(ghwndApp, WM_USER_DESTROY, 0, 0);
    }
    return OLE_OK;    // return something
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL SrvrExecute (LPOLESERVER lpoledoc, HGLOBAL hCommands)
{
    return OLE_ERROR_GENERIC;
}

/**************************************************************************
***************************************************************************/

BOOL FAR PASCAL RegisterDocument(LHSERVERDOC lhdoc, LPOLESERVERDOC FAR *lplpoledoc)
{
    /* If we don't have a server, don't even bother. */
    if (!gSrvr.lhsrvr)
        return TRUE;

    gDoc.hwnd = ghwndApp;        // corresponding main window

    /* should only be one document at a time... */

    while (gDoc.lhdoc != (LHSERVERDOC)0 && gDoc.lhdoc != -1)
        RevokeDocument();

#ifdef WAITDIFFERENTLY
    while (gDoc.lhdoc == -1) {
        MSG         rMsg;   /* variable used for holding a message */
        DPF("RegisterDoc: Waiting for document to be released....\n");

        /* call the server code and let it unblock the server */
        ServerUnblock();

        if (!GetMessage(&rMsg, NULL, 0, 0)) {
            DPF("VERY BAD: got WM_QUIT while waiting...\n");
        }
        TranslateMessage(&rMsg);
        DispatchMessage(&rMsg);
    }
#endif

    if (lhdoc == (LHSERVERDOC)0) {
        CHAR szAnsi[MAX_PATH];

        DPF("Registering document: %ws\n", (LPWSTR)gachFileDevice);

        COPYSTRINGW2A(szAnsi, gachFileDevice);
        if (OleRegisterServerDoc(gSrvr.lhsrvr, szAnsi, (LPOLESERVERDOC)&gDoc,
            (LHSERVERDOC FAR *)&gDoc.lhdoc) != OLE_OK)
            return FALSE;
    } else {
        gDoc.lhdoc = lhdoc;
    }

    DPF0( "RegisterDocument: Locks on server doc: %x\n", GlobalFlags(gDoc.lhdoc) & (GMEM_LOCKCOUNT | GMEM_INVALID_HANDLE) );

////UpdateCaption(); //!!!

////DPF("Adding document handle: %lx\n",lhdoc);

////gDoc.aName = GlobalAddAtom(MakeAnsi((LPWSTR)gachFileDevice));
    gDoc.oledoc.lpvtbl = &docVTbl;

    if (lplpoledoc)
        *lplpoledoc = (LPOLESERVERDOC)&gDoc;

    SetDocVersion( DOC_VERSION_OLE1 );

    return TRUE;
}

/**************************************************************************
***************************************************************************/

void FAR PASCAL RevokeDocument(void)
{
    LHSERVERDOC     lhdoc;

    if (gDoc.lhdoc == -1) {
        DPF("RevokeDocument: Document has been revoked, waiting for release!\n");
        return;
    }

    if (gDoc.lhdoc) {

        DPF0( "RevokeDocument: Locks on server doc: %x\n", GlobalFlags(gDoc.lhdoc) & (GMEM_LOCKCOUNT | GMEM_INVALID_HANDLE) );
        DPF("Revoking document: lhdoc=%lx\n",gDoc.lhdoc);
        lhdoc = gDoc.lhdoc;
        if (lhdoc) {
            gDoc.lhdoc = -1;
            if (OleRevokeServerDoc(lhdoc) == OLE_WAIT_FOR_RELEASE) {
#ifndef WAITDIFFERENTLY
                while (gDoc.lhdoc != 0) {
                    MSG msg;

                    DPF("RevokeDocument: waiting for release...\n");

                    /* call the server code and let it unblock the server */
                    ServerUnblock();

                    if (!GetMessage(&msg, NULL, 0, 0)) {
                        DPF("VERY BAD: got WM_QUIT while waiting...\n");
                    }
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
                DPF("RevokeDocument: done waiting for release\n");
#endif
            } else {
//!!            WinAssert(gDoc.lhdoc == 0);
            }

            SetDocVersion( DOC_VERSION_NONE );

        } else {
            DPF0("Document already revoked!");
        }
        SetEmbeddedObjectFlag(FALSE);
    }
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL SrvrOpen (
LPOLESERVER    lpolesrvr,
LHSERVERDOC    lhdoc,
OLE_LPCSTR     lpdocname,
LPOLESERVERDOC FAR *lplpoledoc)
{
    BOOL f;

    DPF("SrvrOpen: %s\n",lpdocname);

    SetEmbeddedObjectFlag(TRUE);

    BlockServer();
    f = OpenMciDevice((LPSTR)lpdocname, (LPSTR)NULL);
    UnblockServer();

    if (!f)
        return OLE_ERROR_GENERIC;

    SetEmbeddedObjectFlag(FALSE);

    RegisterDocument(lhdoc, lplpoledoc);
    return OLE_OK;
}


/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL SrvrCreate (
LPOLESERVER   lpolesrvr,
LHSERVERDOC   lhdoc,
OLE_LPCSTR    lpclassname,
OLE_LPCSTR    lpdocname,
LPOLESERVERDOC  FAR *lplpoledoc)
{
    DPF("SrvrCreate: %s!%s\n",lpdocname,lpclassname);

    BlockServer();
    CloseMCI(TRUE);
    UnblockServer();

    /* Set the title of the client document we're imbedded in */
    COPYSTRINGA2W((LPWSTR)gachDocTitle, lpdocname);

    RegisterDocument(lhdoc,lplpoledoc);

    /* You are dirty by default according to OLE */
    gfDirty = TRUE;

    return OLE_OK;
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL SrvrCreateFromTemplate (
LPOLESERVER   lpolesrvr,
LHSERVERDOC   lhdoc,
OLE_LPCSTR    lpclassname,
OLE_LPCSTR    lpdocname,
OLE_LPCSTR    lptemplatename,
LPOLESERVERDOC  FAR *lplpoledoc)
{
    BOOL f;

    DPF("SrvrCreateFromTemplate: %s as %s  class=%s\n",lptemplatename,lpdocname,lpclassname);

    SetEmbeddedObjectFlag(TRUE);

    BlockServer();
    f = OpenMciDevice((LPSTR)lptemplatename, (LPSTR)NULL);
    UnblockServer();

    if (!f)
        return OLE_ERROR_GENERIC;

    RegisterDocument(lhdoc,lplpoledoc);

    gfDirty = TRUE;

    return OLE_OK;
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL SrvrEdit (
LPOLESERVER   lpolesrvr,
LHSERVERDOC   lhdoc,
OLE_LPCSTR    lpclassname,
OLE_LPCSTR    lpdocname,
LPOLESERVERDOC  FAR *lplpoledoc)
{
    DPF("SrvrEdit: %s  class=%s\n",lpdocname,lpclassname);

    BlockServer();
    CloseMCI(TRUE);
    UnblockServer();

    /* Set the title of the client document we're imbedded in */
    COPYSTRINGA2W((LPWSTR)gachDocTitle, lpdocname);
    RegisterDocument(lhdoc,lplpoledoc);

    return OLE_OK;
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL SrvrExit (
LPOLESERVER   lpolesrvr)
{
    LHSERVER lhsrvr;
    // Server lib is calling us to exit.
    // Let us hide the main window.
    // But let us not delete the window.

    DPF("SrvrExit\n");

    ShowWindow (ghwndApp, SW_HIDE);

    lhsrvr = gSrvr.lhsrvr;
    if (lhsrvr) {
        gSrvr.lhsrvr = 0;
        OleRevokeServer(lhsrvr);
    }
    return OLE_OK;

    // How does the application ever end?
    // Application will end when Release is received
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL  DocSave (
LPOLESERVERDOC  lpoledoc)
{
    DPF("DocSave\n");

////BlockServer();
////FileSave(FALSE);    // Save should send change message
////UnblockServer();

    return OLE_OK;
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL  DocClose (
LPOLESERVERDOC  lpoledoc)
{
    DPF("DocClose\n");

    BlockServer();
    NewDoc(FALSE);
    UnblockServer();

    DPF("Leaving DocClose\n");

#ifdef WAITDIFFERENTLY
    TerminateServer();
#else
    PostMessage(ghwndApp, WM_CLOSE, 0, 0L);  // GET OUT !!!
#endif

    return OLE_OK;

    // Should we exit the app here?
}

/**************************************************************************
***************************************************************************/
OLESTATUS FAR PASCAL DocSetHostNames(
LPOLESERVERDOC   lpoledoc,
OLE_LPCSTR       lpclientName,
OLE_LPCSTR       lpdocName)
{
    DPF("DocSetHostNames: %s -- %s\n",lpclientName,lpdocName);

    COPYSTRINGA2W((LPWSTR)gachDocTitle, lpdocName);
    SetEmbeddedObjectFlag(TRUE);  // update menu items
    gfValidCaption = FALSE;
    UpdateDisplay();

    return OLE_OK;
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL DocSetDocDimensions(
LPOLESERVERDOC   lpoledoc,
OLE_CONST RECT FAR * lprc)
{
    DPF("DocSetDocDimensions [%d,%d,%d,%d]\n", *lprc);
    return OLE_OK;
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL  DocRelease (
LPOLESERVERDOC  lpoledoc)
{
    DPF("DocRelease\n");

    // !!! what is this supposed to do?
    // Revoke document calls DocRelease.
////if (gDoc.aName)
////////GlobalDeleteAtom (gDoc.aName);

    /* This marks the document as having been released */
    gDoc.lhdoc = 0L;

    // Should we kill the application here?
    // No, I don't think so.

    return OLE_OK;        // return something
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL DocExecute (LPOLESERVERDOC lpoledoc, HANDLE hCommands)
{
    return OLE_ERROR_GENERIC;
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL DocSetColorScheme (LPOLESERVERDOC lpdoc,
                                        OLE_CONST LOGPALETTE FAR* lppalette)
{
    return OLE_OK;
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL  DocGetObject (
LPOLESERVERDOC      lpoledoc,
OLE_LPCSTR          lpitemname,
LPOLEOBJECT FAR *   lplpoleobject,
LPOLECLIENT         lpoleclient)
{
    DPF("DocGetObject: '%s'\n",lpitemname);

    gItem.hwnd     = ghwndApp;
    gItem.oleobject.lpvtbl = &itemVTbl;

    // If the item is not null, then do not show the window.
    // So do we show the window here, or not?

    *lplpoleobject = (LPOLEOBJECT)&gItem;
    gItem.lpoleclient = lpoleclient;

/* !!! We have been given OLD options before any updates.  We don't need */
/* to parse options here... we'll do it when given our native data in    */
/* ItemSetData.                                                          */
#if 0
    /* Get the options from the item string */
    BlockServer();
    err = ParseOptions(lpitemname);
    UnblockServer();
#endif

    return OLE_OK;
}

/**************************************************************************

    get the native data that represents the currenly open MCI
    file/device.  currently this is exactly the same as cfLink data!

***************************************************************************/

STATICFN  HANDLE NEAR PASCAL Ole1GetLink ()
{
    HANDLE hUnicode;
    DWORD  cbUnicode;
    LPWSTR pUnicode;
    DWORD  cbAnsi;
    LPSTR  pAnsi;
    HANDLE hAnsi;

    DPF("Ole1GetLink\n");

    hUnicode = GetLink();

    if( !hUnicode )
        return NULL;

    cbUnicode = GlobalSize( hUnicode );

    if( cbUnicode == 0 )
        return NULL;

    pUnicode = GlobalLock( hUnicode );

    if( !pUnicode )
    {
        GlobalUnlock( hUnicode );
        GlobalFree( hUnicode );
        return NULL;
    }

    cbAnsi = ( cbUnicode * sizeof(CHAR) ) / sizeof(WCHAR);

    hAnsi = GlobalAlloc( GMEM_DDESHARE | GMEM_ZEROINIT, cbAnsi );

    if( !hAnsi )
        return NULL;

    pAnsi = GlobalLock( hAnsi );

    if( !pAnsi )
    {
        GlobalFree( hAnsi );
        return NULL;
    }

    while( *pUnicode )
    {
        DWORD Len;

        COPYSTRINGW2A( pAnsi, pUnicode );
        Len = wcslen( pUnicode );
        pAnsi += ( Len + 1 );
        pUnicode += ( Len + 1 );
    }

    GlobalUnlock( hUnicode );
    GlobalUnlock( hAnsi );

    GlobalFree( hUnicode );

    return hAnsi;
}

/**************************************************************************
***************************************************************************/

STATICFN HBITMAP NEAR PASCAL GetBitmap (PITEM pitem)
{
    DPF("  GetBitmap\n");

    return BitmapMCI();
}

/**************************************************************************
***************************************************************************/

STATICFN  HANDLE PASCAL NEAR GetPalette(PITEM pitem)
{
    extern HPALETTE CopyPalette(HPALETTE);      // in MCI.C

    DPF("  GetPalette\n");

    return CopyPalette(PaletteMCI());
}

/**************************************************************************
***************************************************************************/

STATICFN  HANDLE PASCAL NEAR GetDib(PITEM pitem)
{
    HBITMAP  hbm;
    HPALETTE hpal;
    HANDLE   hdib;
    HDC      hdc;

    extern HANDLE FAR PASCAL DibFromBitmap(HBITMAP hbm, HPALETTE hpal);
    extern void FAR PASCAL DitherMCI(HANDLE hdib, HPALETTE hpal);

    DPF("  GetDib\n");

    hbm  = GetBitmap(pitem);
    hpal = PaletteMCI();

    hdib = DibFromBitmap(hbm, hpal);

    //
    //  if we are on a palette device. possibly dither to the VGA colors
    //  for apps that dont deal with palettes!
    //
    hdc = GetDC(NULL);
    if ((GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) &&
                       (gwOptions & OPT_DITHER)) {
        DitherMCI(hdib, hpal);
        hpal = NULL;            // no longer working with a palette
    }
    ReleaseDC(NULL, hdc);

    DeleteObject(hbm);
    return hdib;
}

/**************************************************************************
***************************************************************************/

STATICFN  HANDLE PASCAL NEAR GetPicture (PITEM pitem)
{
    HPALETTE hpal;
    HANDLE   hdib;
    HANDLE   hmfp;
    HDC      hdc;
    extern HPALETTE CopyPalette(HPALETTE);      // in MCI.C

    HANDLE FAR PASCAL PictureFromDib(HANDLE hdib, HPALETTE hpal);

    DPF("  GetPicture\n");

    hdib = GetDib(pitem);

    /* If we're dithered, don't use a palette */
    hdc = GetDC(NULL);
    if ((GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) && (gwOptions & OPT_DITHER))
        hpal = NULL;
    else
        hpal = PaletteMCI();

    if (hpal)
        hpal = CopyPalette(hpal);

    ReleaseDC(NULL, hdc);

    hmfp = PictureFromDib(hdib, hpal);

    if (hpal)
        DeleteObject(hpal);

    GlobalFree(hdib);

    return hmfp;
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL  ItemOpen (
LPOLEOBJECT     lpoleobject,
BOOL            fActivate)
{
    /* Start an edit session, and if there is something to play, play it  */
    /* This is called by Excel to play an object, because it doesn't know */
    /* about the PLAY verb.  It's also called to Insert a New object into */
    /* any client.                                                        */
    /* All this work is done in our special -1 verb in ReallyDoVerb.      */

    DPF("ItemOpen\n");
    Ole1ReallyDoVerb(lpoleobject, (UINT)(-1), TRUE, fActivate);

    return OLE_OK;
}

/**************************************************************************
***************************************************************************/

/**************************************************************************
* I know this looks odd, but ItemDoVerb is exported so we can't call it*
* internally and sometimes we need to.                                    *
***************************************************************************/

OLESTATUS FAR PASCAL  ItemDoVerb (
LPOLEOBJECT  lpobj,
UINT         verb,
BOOL         fShow,
BOOL         fActivate)
{
    return Ole1ReallyDoVerb(lpobj, verb, fShow, fActivate);
}

/**************************************************************************
***************************************************************************/

typedef enum
{
    OLE1_OLEOK,             /* 0   Function operated correctly         */

    OLE1_OLEWAIT_FOR_RELEASE,       /* 1   Command has been initiated, client      */
                /*     must wait for release. keep dispatching */
                /*     messages till OLE1_OLERELESE in callback    */

    OLE1_OLEBUSY,           /* 2   Tried to execute a method while another */
                /*     method is in progress.                  */

    OLE1_OLEERROR_PROTECT_ONLY,     /* 3   Ole APIs are called in real mode    */
    OLE1_OLEERROR_MEMORY,       /* 4   Could not alloc or lock memory      */
    OLE1_OLEERROR_STREAM,       /* 5  (OLESTREAM) stream error         */
    OLE1_OLEERROR_STATIC,       /* 6   Non static object expected          */
    OLE1_OLEERROR_BLANK,        /* 7   Critical data missing           */
    OLE1_OLEERROR_DRAW,         /* 8   Error while drawing             */
    OLE1_OLEERROR_METAFILE,     /* 9   Invalid metafile            */
    OLE1_OLEERROR_ABORT,        /* 10  Client chose to abort metafile drawing  */
    OLE1_OLEERROR_CLIPBOARD,        /* 11  Failed to get/set clipboard data    */
    OLE1_OLEERROR_FORMAT,       /* 12  Requested format is not available       */
    OLE1_OLEERROR_OBJECT,       /* 13  Not a valid object              */
    OLE1_OLEERROR_OPTION,       /* 14  Invalid option(link update / render)    */
    OLE1_OLEERROR_PROTOCOL,     /* 15  Invalid protocol            */
    OLE1_OLEERROR_ADDRESS,      /* 16  One of the pointers is invalid      */
    OLE1_OLEERROR_NOT_EQUAL,        /* 17  Objects are not equal           */
    OLE1_OLEERROR_HANDLE,       /* 18  Invalid handle encountered          */
    OLE1_OLEERROR_GENERIC,      /* 19  Some general error              */
    OLE1_OLEERROR_CLASS,        /* 20  Invalid class               */
    OLE1_OLEERROR_SYNTAX,       /* 21  Command syntax is invalid           */
    OLE1_OLEERROR_DATATYPE,     /* 22  Data format is not supported        */
    OLE1_OLEERROR_PALETTE,      /* 23  Invalid color palette           */
    OLE1_OLEERROR_NOT_LINK,     /* 24  Not a linked object             */
    OLE1_OLEERROR_NOT_EMPTY,        /* 25  Client doc contains objects.        */
    OLE1_OLEERROR_SIZE,         /* 26  Incorrect buffer size passed to the api */
                /*     that places some string in caller's     */
                /*     buffer                                  */

    OLE1_OLEERROR_DRIVE,        /* 27  Drive letter in doc name is invalid     */
    OLE1_OLEERROR_NETWORK,      /* 28  Failed to establish connection to a     */
                /*     network share on which the document     */
                /*     is located                              */

    OLE1_OLEERROR_NAME,         /* 29  Invalid name(doc name, object name),    */
                /*     etc.. passed to the APIs                */

    OLE1_OLEERROR_TEMPLATE,     /* 30  Server failed to load template      */
    OLE1_OLEERROR_NEW,          /* 31  Server failed to create new doc     */
    OLE1_OLEERROR_EDIT,         /* 32  Server failed to create embedded    */
                /*     instance                                */
    OLE1_OLEERROR_OPEN,         /* 33  Server failed to open document,     */
                /*     possible invalid link                   */

    OLE1_OLEERROR_NOT_OPEN,     /* 34  Object is not open for editing      */
    OLE1_OLEERROR_LAUNCH,       /* 35  Failed to launch server         */
    OLE1_OLEERROR_COMM,         /* 36  Failed to communicate with server       */
    OLE1_OLEERROR_TERMINATE,        /* 37  Error in termination            */
    OLE1_OLEERROR_COMMAND,      /* 38  Error in execute            */
    OLE1_OLEERROR_SHOW,         /* 39  Error in show               */
    OLE1_OLEERROR_DOVERB,       /* 40  Error in sending do verb, or invalid    */
                /*     verb                                    */
    OLE1_OLEERROR_ADVISE_NATIVE,    /* 41  Item could be missing           */
    OLE1_OLEERROR_ADVISE_PICT,      /* 42  Item could be missing or server doesn't */
                /*     this format.                            */

    OLE1_OLEERROR_ADVISE_RENAME,    /* 43  Server doesn't support rename           */
    OLE1_OLEERROR_POKE_NATIVE,      /* 44  Failure of poking native data to server */
    OLE1_OLEERROR_REQUEST_NATIVE,   /* 45  Server failed to render native data     */
    OLE1_OLEERROR_REQUEST_PICT,     /* 46  Server failed to render presentation    */
                /*     data                                    */
    OLE1_OLEERROR_SERVER_BLOCKED,   /* 47  Trying to block a blocked server or     */
                /*     trying to revoke a blocked server       */
                /*     or document                             */

    OLE1_OLEERROR_REGISTRATION,     /* 48  Server is not registered in regestation */
                /*     data base                               */
    OLE1_OLEERROR_ALREADY_REGISTERED,/*49  Trying to register same doc multiple    */
                 /*    times                                   */
    OLE1_OLEERROR_TASK,         /* 50  Server or client task is invalid    */
    OLE1_OLEERROR_OUTOFDATE,        /* 51  Object is out of date           */
    OLE1_OLEERROR_CANT_UPDATE_CLIENT,/* 52 Embed doc's client doesn't accept       */
                /*     updates                                 */
    OLE1_OLEERROR_UPDATE,       /* 53  erorr while trying to update        */
    OLE1_OLEERROR_SETDATA_FORMAT,   /* 54  Server app doesn't understand the       */
                /*     format given to its SetData method      */
    OLE1_OLEERROR_STATIC_FROM_OTHER_OS,/* 55 trying to load a static object created */
                   /*    on another Operating System           */

    /*  Following are warnings */
    OLE1_OLEWARN_DELETE_DATA = 1000 /*     Caller must delete the data when he is  */
                /*     done with it.                           */
} OLE1_OLESTATUS;

OLE1_OLESTATUS (FAR PASCAL *OleQueryObjPos)(LPVOID lpobj, HWND FAR* lphwnd, LPRECT lprc, LPRECT lprcWBounds);

STATICFN int NEAR PASCAL  Ole1ReallyDoVerb (
LPOLEOBJECT  lpobj,
UINT         verb,
BOOL         fShow,
BOOL         fActivate)
{
    BOOL    fWindowWasVisible = IsWindowVisible(ghwndApp);

    int     dx,dy;
    HWND    hwndClient;
    HWND    hwndT;
    RECT    rcSave;
    RECT    rcClient;
    RECT    rc;
    UINT    err;
    HPALETTE hpal;
    HDC     hdc;
    INT     xTextExt, yTextExt;
    int     yOrig, yNow, xOrig, ytitleNow, xtitleOrig, xNow;
    int     xIndent;
    int     wWinNow;


    // ACK!  We haven't finished doing ItemSetData yet because we have to
    // bring up an open dialog.  So we can't do the ItemDoVerb yet.  We will
    // Post a message to ourselves that will do both the SetData and DoVerb
    // and we will succeed the DoVerb right now so the client will be happy
    // and start dispatching messages again.
    if (gfBrokenLink) {
        // We need to get client info NOW because our OLE handler can only
        // answer this question now... if we click on two broken links at the
        // same time, it will get confused about which object we want.
        gerr = OleQueryObjPos(lpobj, &ghwndClient, &grcClient, NULL);

        PostMessage(ghwndApp, WM_DO_VERB, verb, MAKELONG(fShow, fActivate));
        return OLE_OK;
    }

    //
    // dont even try to nest things.
    //
    if (gfPlayingInPlace)
        return OLE_OK;

    if (verb == OLEVERB_PRIMARY) {
        DPF("ItemDoVerb: Play\n");

        //
        // if the device can't window and the user does not want a playbar
        // dont play in place - just start the media and run invisible.
        //
        if (!(gwDeviceType & DTMCI_CANWINDOW) && !(gwOptions & OPT_BAR)) {
            gwOptions &= ~OPT_PLAY;
        }

        //
        //  Select the palette in right now on behalf of the active
        //  window, so USER will think it is palette aware.
        //
        //  any palette will do we dont even have to realize it!!
        //
        if ((hpal = PaletteMCI()) && (hwndT = GetActiveWindow())) {
            hdc = GetDC(hwndT);
            hpal = SelectPalette(hdc, hpal, FALSE);
            SelectPalette(hdc, hpal, FALSE);
            ReleaseDC(hwndT, hdc);
        }

        if (ghwndClient) {
            hwndClient = ghwndClient;
            err = gerr;
            rcClient = grcClient;
            ghwndClient = NULL;
        } else
            err = OleQueryObjPos(lpobj, &hwndClient, &rcClient, NULL);

#ifdef DEBUG
        if (gwOptions & OPT_PLAY)
        {
            DPF("ObjQueryObjPos: hwnd=%04X [%d %d %d %d]\n",hwndClient, rcClient);

            if (err != OLE_OK) {
                DPF("ItemDoVerb: CANT GET OBJECT POSITION!!!\n");
            }
            else {
                if (!(gwDeviceType & DTMCI_CANWINDOW))
                    DPF("ItemDoVerb: DEVICE CANT WINDOW\n");

                if (!IsWindow(hwndClient))
                    DPF("ItemDoVerb: Invalid Client Window?\n");

                if (!IsWindowVisible(hwndClient))
                    DPF("ItemDoVerb: Client window is not visible, playing in a popup\n");
            }
        }
#endif

        /* We want to play in place and we can.                               */
        /* If we're a link, not an embedded object, and there was an instance */
        /* of MPlayer up when we said "Play" that was already editing this    */
        /* file, we don't want to play in place... we'll just play in that    */
        /* instance.  We can tell this by the fact that our main MPlayer      */
        /* window is already visible.                                         */
        if (err == OLE_OK && (gwOptions & OPT_PLAY) &&
            IsWindow(hwndClient) && IsWindowVisible(hwndClient) &&
            !fWindowWasVisible)
        {
            extern HPALETTE FAR PASCAL CreateSystemPalette(void);

            rc = grcSize;    // default playback window size for this movie

            /* If we can't window, or something's wrong, use ICON size */
            if (IsRectEmpty(&rc))
                SetRect(&rc, 0, 0, GetSystemMetrics(SM_CXICON),
                    GetSystemMetrics(SM_CYICON));

            /* rcSave is the area for the MCI window above the control bar */
            /* (if we have one).                                           */
            /* rcClient is the area of the MCI window (0 based) to play in.*/
            /* Control bar may be longer than picutre, so rcClient may be  */
            /* smaller than rcSave.                                        */
            rcSave = rcClient;    // remember stretched size

            /* Make rcClient 0 based from rcSave */
            rcClient.left = 0;
            rcClient.right = rcSave.right - rcSave.left;
            rcClient.top = 0;
            rcClient.bottom = rcSave.bottom - rcSave.top;

            /* Assume playbar will be regular height for now */
            if (gwOptions & OPT_BAR)
                gwPlaybarHeight = TOOLBAR_HEIGHT;
            else
                gwPlaybarHeight = 0;

            //
            // munge rectangle to account for a title in the picture
            // and the fact that picture is centred above title.
            // Remember, it's been stretched around.
            //
            if (gwOptions & OPT_TITLE) {

                CHAR szAnsi[MAX_PATH];

                hdc = GetDC(NULL);

                if (ghfontMap)
                    SelectObject(hdc, ghfontMap);

#ifdef _WIN32
                COPYSTRINGW2A(szAnsi, gachCaption);
                MGetTextExtent( hdc, szAnsi, lstrlen(szAnsi),
                                &xTextExt, &yTextExt);
#else
                xTextExt = GetTextExtent(hdc, gachCaption,
                                         lstrlen(gachCaption));
#endif

                ReleaseDC(NULL, hdc);
                if (gwPastedHeight)
                    yOrig = gwPastedHeight;
                else
                    yOrig = rc.bottom - rc.top;
                xOrig = rc.right - rc.left;
                xtitleOrig = max(xTextExt + 4, xOrig);
                yNow  = rcClient.bottom - rcClient.top;
                xNow  = rcClient.right - rcClient.left;
                ytitleNow = (int)((long)yNow - ((long)yOrig * yNow)
                                                    / (yOrig + TITLE_HEIGHT));
                /* for windowed devices, center the playback area above the */
                /* control bar if the control bar is longer.                */
                if (gwDeviceType & DTMCI_CANWINDOW) {
                    wWinNow =(int)((long)xOrig * (long)xNow / (long)xtitleOrig);
                    xIndent = (xNow - wWinNow) / 2;
                    rcClient.left += xIndent;
                    rcClient.right = rcClient.left + wWinNow;
                }

                // Align top of control bar with the top of the title bar.
                // The control bar (if there) will appear under rcSave.
                rcClient.bottom = rcClient.top + yNow - ytitleNow;
                rcSave.bottom = rcSave.top + yNow - ytitleNow;

                /* When we make the playbar, make it cover the title */
                /* if the caption was stretched taller than ordinary.*/
                if (gwOptions & OPT_BAR)
                    gwPlaybarHeight = max(ytitleNow, TOOLBAR_HEIGHT);
            }

            /* Enforce a minimum width for the control bar */
            if ((gwOptions & OPT_BAR) &&
                (rcSave.right - rcSave.left < 3 * GetSystemMetrics(SM_CXICON))){
                rcSave.right = rcSave.left + 3 * GetSystemMetrics(SM_CXICON);
                if (gwDeviceType & DTMCI_CANWINDOW)
                    xIndent = TRUE;     // force SetWindowMCI to be called to
                                        // avoid stretching to this new size.
            }

            if (gwDeviceType & DTMCI_CANWINDOW) {
                //
                //  If we've only stretched a bit, don't stretch at all.
                //  We might be off a bit due to rounding problems.
                //
                dx = (rcClient.right - rcClient.left) - (rc.right - rc.left);
                dy = (rcClient.bottom - rcClient.top) - (rc.bottom - rc.top);

                if (dx && abs(dx) <= 2)
                {
                    DPF("Adjusting for x round off\n");
                    rcClient.right = rcClient.left + (rc.right - rc.left);
                    // Fix Save rect too
                    rcSave.right = rcSave.left + (rc.right - rc.left);
                }

                if (dy && abs(dy) <= 2)
                {
                    DPF("Adjusting for y round off\n");
                    rcClient.bottom = rcClient.top + (rc.bottom - rc.top);
                    // Fix Save rect, too.
                    rcSave.bottom = rcSave.top + (rc.bottom - rc.top);
                }

                //
                // try to get the right palette from the client, if our
                // pesentation data was dithered or, the user asked us to
                // always use the object palette, then ignore any client
                // palette.
                //
#ifdef DEBUG
                if (GetProfileInt("options", "UseClientPalette", !(gwOptions & OPT_USEPALETTE)))
                    gwOptions &= ~OPT_USEPALETTE;
                else
                    gwOptions |= OPT_USEPALETTE;
#endif
                if (!(gwOptions & OPT_USEPALETTE) &&
                    !(gwOptions & OPT_DITHER)) {

                    //
                    // try to get a OWNDC Palette of the client, PowerPoint
                    // uses a PC_RESERVED palette in "SlideShow" mode. so
                    // we must use it's exact palette.
                    //
                    hdc = GetDC(hwndClient);
                    hpal = SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);
                    SelectPalette(hdc, hpal, FALSE);
                    ReleaseDC(hwndClient, hdc);

                    if (hpal == NULL || hpal == GetStockObject(DEFAULT_PALETTE)) {

                        /* Assume client realized the proper palette for us */

                        DPF("Using system palette\n");

                        if (ghpalApp)
                            DeleteObject(ghpalApp);

                        hpal = ghpalApp = CreateSystemPalette();
                    }
                    else {
                        DPF("Using clients OWNDC palette\n");
                    }

                    if (hpal)
                        SetPaletteMCI(hpal);
                }
                else {
                    DPF("Using MCI Object's normal palette\n");
                }
            }
            else {
                //
                // for non window devices, just have the playbar show up!
                // so use a zero height MCI Window area.
                //
                rcSave.top = rcSave.bottom;
            }

            //
            // if we are not in small mode, get there now
            //
            if (!gfPlayOnly) {
                ShowWindow(ghwndApp, SW_HIDE);
                gfPlayOnly = TRUE;
                SizeMPlayer();
            }

            ClrWS(ghwndApp, WS_THICKFRAME|WS_CAPTION|WS_SYSMENU|WS_MINIMIZEBOX|WS_MAXIMIZEBOX|WS_BORDER);

            if (gwOptions & OPT_BORDER)
                SetWS(ghwndApp, WS_BORDER);

            /* Set the size of Mplayer to have enough space for the MCI */
            /* playback area and a playbar and the non-client area.     */

            rcSave.bottom += gwPlaybarHeight;

            AdjustWindowRect(&rcSave, GetWS(ghwndApp), FALSE);

            Ole1PlayInPlace(ghwndApp, hwndClient, &rcSave);

            fShow = FALSE;
            fActivate = FALSE;

            /* become visible */
            ShowWindow(ghwndApp,SW_SHOWNA);

            /* Remember to play the video in the rcClient area of rcSave */
            if ((gwDeviceType & DTMCI_CANWINDOW) &&
                (gwOptions & OPT_TITLE) && xIndent != 0)
                SetDestRectMCI(&rcClient);

            /* Let keyboard interface work on control bar, and let the  */
            /* accelerators go through.                                 */
            toolbarSetFocus(ghwndToolbar, BTN_PLAY);
            SetFocus(ghwndToolbar);

            gfCloseAfterPlaying = TRUE;

            /* We won't play in place - use a popup window or nothing. */
        } else {

            /* If we want a playbar, then use MPlayer reduced mode to play. */
            /* If we don't want one, then don't show mplayer's window -     */
            /* we'll just use the default MCI window (for a windowed device)*/
            /* or nothing for a non-windowed device.  If we stole an already*/
            /* running instance of mplayer, we must use it and not run      */
            /* silently.                                                    */
            if ((gwOptions & OPT_BAR) || fWindowWasVisible) {
                DPF("Using Toplevel window for playback\n");

                /* go to our little miniature version */
                if (!gfPlayOnly && !fWindowWasVisible) {
                    gwPlaybarHeight = TOOLBAR_HEIGHT;
                    gfPlayOnly = TRUE;
                    SizeMPlayer();
                }

                fShow = fActivate = TRUE;
                gfCloseAfterPlaying = !fWindowWasVisible;

            } else {
                DPF("Running silently\n");

                if (!fWindowWasVisible)
                    SetWindowMCI(NULL);     // make sure we're using default MCI win

                fShow = fActivate = FALSE;
                gfCloseAfterPlaying = TRUE; // we're invisible, so close auto.
            }
        }

        Yield();    // If play goes to full screen mode, PowerPig will
        Yield();    // time out and put up errors thinking we didn't play.
        PostMessage(ghwndApp, WM_COMMAND, ID_PLAYSEL, 0); // play selection

    } else if (verb == 1) {
        DPF("ItemDoVerb: Edit\n");

        if (gfPlayOnly) {
            gfPlayOnly = FALSE;
            SizeMPlayer();
        }

        /* If we come up empty, it's OK to be in OPEN or NOT_READY mode and */
        /* don't try to seek anywhere.                                      */
        if (gwDeviceID) {
            switch (gwStatus) {

                case MCI_MODE_OPEN:
                case MCI_MODE_NOT_READY:
                    Error(ghwndApp, IDS_CANTEDIT);
                    break;

                default:
                    // Seek to the position we were when we copied.  Stop first.
                    if (StopMCI()) {
                        // fix state so Seek recognizes we're stopped
                        gwStatus = MCI_MODE_STOP;
                        SeekMCI(gdwPosition);
                    }
                    break;
            }
        }

        /* Let UpdateDisplay set focus properly by saying we're invalid */
        gwStatus = (UINT)(-1);

    /* Our special ItemOpen verb */
    } else if (verb == -1)  {
        Ole1ReallyDoVerb(lpobj, 1, fShow, fActivate);
        if (gwDeviceID)
            Ole1ReallyDoVerb(lpobj, OLEVERB_PRIMARY, fShow, fActivate);
        return OLE_OK;

    } else {
        DPF("ItemDoVerb: Unknown verb: %d\n", verb);
    }

    if (fShow) {
        ShowWindow(ghwndApp, SW_SHOW);

        if (IsIconic(ghwndApp))
            SendMessage(ghwndApp, WM_SYSCOMMAND, SC_RESTORE, 0L);
    }

    if (fActivate) {
        BringWindowToTop (ghwndApp);  // let WM_ACTIVATE put client
        SetActiveWindow (ghwndApp);   // underneath us
    }

    return OLE_OK;
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL  ItemRelease (
LPOLEOBJECT     lpoleobject)
{
    DPF("ItemRelease\n");

    gItem.lpoleclient = NULL;
    return OLE_OK;
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL ItemGetData ( LPOLEOBJECT     lpoleobject,
                                   OLECLIPFORMAT   cfFormat,
                                   LPHANDLE        lphandle)
{
    PITEM   pitem;

    DPF("ItemGetData\n");

#ifndef _WIN32
    pitem = (PITEM)(WORD)(DWORD)lpoleobject;
#else
    // LKG: What was that doing?  Are they unpacking something subtle?
    pitem = (PITEM)lpoleobject;
#endif //_WIN32

    if (cfFormat == cfNative) {

        *lphandle = Ole1GetLink ();
        if (!(*lphandle))
            return OLE_ERROR_MEMORY;

        if (gfEmbeddedObject)
            CleanObject();

        return OLE_OK;
    }

    *lphandle = NULL;

    if (cfFormat == CF_METAFILEPICT) {
        *lphandle = GetPicture (pitem);

    }
    else if (cfFormat == CF_PALETTE) {
        *lphandle = GetPalette(pitem);

    }
    else if (cfFormat == CF_DIB) {
        *lphandle = GetDib(pitem);

    }
    else if (cfFormat == cfLink || cfFormat == cfOwnerLink){
        *lphandle = Ole1GetLink ();
    }
    else return OLE_ERROR_MEMORY;          // this is actually unknown format.

    if (!(*lphandle))
            return OLE_ERROR_MEMORY;       // honestly this time

    return OLE_OK;
}



/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL   ItemSetTargetDevice (
LPOLEOBJECT     lpoleobject,
HGLOBAL          hdata)
{
    DPF("ItemSetTargetDevice\n");

    return OLE_OK;
}

/**************************************************************************
***************************************************************************/


STATICFN OLESTATUS NEAR PASCAL SetDataPartII(LPWSTR szFile, LPWSTR szDevice)
{
    int         status = OLE_OK;
    LHSERVERDOC lhdocTemp;

    // TERRIBLE HACK! set gfEmbeddedObject so OpenMCI does
    // not re-register this document!!!
    //

    BlockServer();

    lhdocTemp = gDoc.lhdoc;
    gDoc.lhdoc = (LHSERVERDOC)0;          /* So it won't be killed by CloseMCI!! */
    gfEmbeddedObject++;

    /* Coming up: Horrible cast to get rid of warning.
     *
     * This file is compiled non-Unicode, in contrast to the rest of MPlayer.
     * This means that LPTSTR in the function prototypes mean different things
     * depending on who included them.  OpenMciDevice and other Unicode
     * routines called from this module expect Unicode strings, but the
     * compiler thinks they're ANSI.  We can keep the compiler happy by
     * casting them to LPTSTR.  Does that make sense?
     *
     * Places where this unspeakable act is perpetrated are indicated thus:
     */
    if (!OpenMciDevice((LPTSTR)szFile, (LPTSTR)szDevice))
                    // ^^^^^^^^        ^^^^^^^^
        status = OLE_ERROR_FORMAT;

    gfEmbeddedObject--;
    gDoc.lhdoc = lhdocTemp;

    /* Set the selection to what we parsed in ParseOptions.      */
    if (status == OLE_OK) {
        SendMessage(ghwndTrackbar, TBM_SETSELSTART, 0, glSelStart);
        SendMessage(ghwndTrackbar, TBM_SETSELEND, 0, glSelEnd);
    }

    UnblockServer();

    return status;
}

/**************************************************************************/
/**************************************************************************/

OLESTATUS FAR PASCAL  ItemSetData1(LPOLEOBJECT lpoleobject, OLECLIPFORMAT cfFormat, HANDLE hdata)
{
    LPBYTE p, pSave, pT;
                                              // Why BYTE?? And is this heading
                                              // for UNICODE trouble?
    LPWSTR pUnicode;
    LPSTR  szFile, szDevice;
    char   achFile[MAX_PATH];
    char   ach[40];
    OLESTATUS status;

    WCHAR  FileNameW[MAX_PATH];

    DPF("ItemSetData1\n");

    if (hdata == NULL)
        return OLE_ERROR_MEMORY;

    if (cfFormat != cfNative)
        return OLE_ERROR_FORMAT;

    p = GlobalLock(hdata);
    if (p == NULL)
        return OLE_ERROR_MEMORY;

    szFile   = p + lstrlen((LPSTR)p) + 1;  // pick off the Filename

    p = szFile + lstrlen(szFile) + 1;
    pSave = p;
    szDevice = ach;                         // copy over Device name and
    for (pT = ach; *p && *p != ',';)        // NULL terminate it (it ends
    *pT++ = *p++;                           // with a ',' right now).
    *pT = '\0';

#ifdef DEBUG
    DPF("   %s|%s!%s\n", (LPSTR)p, (LPSTR)szFile, (LPSTR)szDevice);
#endif

    BlockServer();              // cause CloseMCI can yield
    CloseMCI(TRUE);             // nuke old gachCaption
    UnblockServer();
    pUnicode = AllocateUnicodeString(pSave);

    if( !pUnicode )
        return OLE_ERROR_MEMORY;

    ParseOptions((LPTSTR)pUnicode);     // this will set new gachCaption
          // YUK ^^^^^^^^ \\

    FreeUnicodeString(pUnicode);

    // If this file doesn't exist, we won't continue setting data, we will
    // succeed and get out, and do it later, because we can't bring up a dialog
    // right now because clients like WinWord won't dispatch any msgs.

    lstrcpyn(achFile, szFile, sizeof(achFile));
    // if the filename we were given is bad, try and find it somewhere

    COPYSTRINGA2W(FileNameW, szFile);

    if (FindRealFileName((LPTSTR)FileNameW, sizeof(achFile))) {
                  // YUK ^^^^^^^^ \\
        // We found it on the disk somewhere, so continue with SetData
        WCHAR szDeviceW[80];

        COPYSTRINGA2W(szDeviceW, szDevice);
        status = SetDataPartII(FileNameW, szDeviceW);
    } else {

        // Nowhere to be found.  We need to ask the user to find it... LATER!!

        if (gfBrokenLink) {
            DPF("ACK!! Got Second ItemSetData with BrokenLink!!");
            return OLE_ERROR_GENERIC;
        }

        // Succeed to ItemSetData so client will be happy
        lstrcpyn(gachDeviceA, szDevice, sizeof(gachDeviceA));
        COPYSTRINGA2W(gachFile, szFile);
        gfBrokenLink = TRUE;
        status = OLE_OK;
    }

    return status;
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL  ItemSetColorScheme (LPOLEOBJECT lpobj,
            OLE_CONST LOGPALETTE FAR * lppalette)
{
    DPF("ItemSetColorScheme\n");

    return OLE_OK;
}

/**************************************************************************
***************************************************************************/

OLESTATUS FAR PASCAL  ItemSetBounds (LPOLEOBJECT lpobj, OLE_CONST RECT FAR* lprc)
{
    DPF("ItemSetBounds: [%d,%d,%d,%d]\n", *lprc);

    return OLE_OK;
}

/**************************************************************************
***************************************************************************/

OLECLIPFORMAT   FAR PASCAL ItemEnumFormats(
LPOLEOBJECT     lpoleobject,
OLECLIPFORMAT   cfFormat)
{
////DPF("ItemEnumFormats: %u\n",cfFormat);

    if (cfFormat == 0)
        return cfLink;

    if (cfFormat == cfLink)
        return cfOwnerLink;

    if (cfFormat == cfOwnerLink)
        return CF_METAFILEPICT;

    if (cfFormat == CF_METAFILEPICT)
        return CF_DIB;

    if (cfFormat == CF_DIB)
        return CF_PALETTE;

    if (cfFormat == CF_PALETTE)
        return cfNative;

    //if (cfFormat == cfNative)
    //    return NULL;

    return (OLECLIPFORMAT)0;
}

/**************************************************************************
***************************************************************************/

int FAR PASCAL SendChangeMsg (UINT options)
{
    CHAR szAnsi[MAX_PATH];

    if (gDoc.lhdoc && gDoc.lhdoc != -1) {
        if (options == OLE_SAVED) {
            DPF("SendChangeMsg(OLE_SAVED): Calling OleSavedServerDoc\n");
            DPF0( "SendChangeMsg: Locks on server doc: %x\n", GlobalFlags(gDoc.lhdoc) & (GMEM_LOCKCOUNT | GMEM_INVALID_HANDLE) );
            return OleSavedServerDoc(gDoc.lhdoc);
    } else if (options == OLE_RENAMED) {
            DPF("SendChangeMsg(OLE_RENAMED): new name is '%ws'.\n", (LPWSTR)gachFileDevice);
            COPYSTRINGW2A(szAnsi, gachFileDevice);
            return OleRenameServerDoc(gDoc.lhdoc, szAnsi);
        } else if (gItem.lpoleclient) {
            DPF("SendChangeMsg(%d) client=%lx\n",options,gItem.lpoleclient);
            return (*gItem.lpoleclient->lpvtbl->CallBack) (gItem.lpoleclient,
                                options, (LPOLEOBJECT)&gItem);
        }
    }

    return OLE_OK;
}

/**************************************************************************
***************************************************************************/

void FAR PASCAL CopyObject(HWND hwnd)
{
    PITEM       pitem = &gItem;

    //
    // we put two types of OLE objects in the clipboard, the type of
    // OLE object is determined by the *order* of the clipboard data
    //
    // Embedded Object:
    //      cfNative
    //      OwnerLink
    //      Picture
    //      ObjectLink
    //
    // Linked Object:
    //      OwnerLink
    //      Picture
    //      ObjectLink
    //

    if (OpenClipboard (hwnd)) {

        // Copying an object can take a long time - especially large AVI frames
        // Tell the user its coffee time.
        HCURSOR hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));
        BlockServer();

        EmptyClipboard();

        SetClipboardData(cfNative, Ole1GetLink());

        /* Don't ask me why we do this even if it is untitled... */
        SetClipboardData (cfOwnerLink, Ole1GetLink());

        CopyMCI(NULL);

#if 0        // DON'T OFFER LINKS ANYMORE!
        /* Only offer link data if not untitled and not a embedded object */
        if (gwDeviceType & DTMCI_FILEDEV)
            SetClipboardData(cfLink, Ole1GetLink());
#endif

        UnblockServer();
        CloseClipboard();
        SetCursor(hcurPrev);  // We're back!!!
    }
}

/**************************************************************************
***************************************************************************/

/**************************************************************************

    STUFF FOR PLAY IN PLACE

***************************************************************************/


#ifndef _WIN32
/**************************************************************************
***************************************************************************/

LRESULT CALLBACK _EXPORT MouseHook(int hc, WPARAM wParam, LPARAM lParam)
{
    LPMOUSEHOOKSTRUCT lpmh = (LPVOID)lParam;
    BOOL              fDownNow, fDownBefore;

    //
    //  NOTE SS != DS
    //

    if (hc == HC_ACTION)
    {
#ifdef XDEBUG
        char ach[80];
        wsprintf( ach
                , "MouseHook: %c%c pt=[%d,%d] hwnd=%04X ht=%04X\r\n"
                , (GetAsyncKeyState(VK_LBUTTON) < 0 ? 'L' : ' ')
                , (GetAsyncKeyState(VK_RBUTTON) < 0 ? 'R' : ' ')
                , lpmh->pt
                , lpmh->hwnd
                , lpmh->wHitTestCode
                );
        OutputDebugString(ach);
#endif
        /* If the mouse was DOWN when we started, we wait until it comes up */
        /* before we let mouse downs kill us.  If KeyState said it was DOWN */
        /* we wait until it says it is UP before we let DOWN KeyStates kill */
        /* us.                                                              */
        /* We're checking Async because we have to... it's the NOW state.   */
        /* We're ALSO checking GetKeyState because Faris' machine misses    */
        /* some mouse downs unless we call every function possible !!**!!** */

        fDownNow = GetAsyncKeyState(VK_LBUTTON) || GetAsyncKeyState(VK_RBUTTON);
        fDownBefore = GetKeyState(VK_LBUTTON) || GetKeyState(VK_RBUTTON);

        if ((fDownNow && gfMouseUpSeen) || (fDownBefore && gfKeyStateUpSeen)) {
            //
            // the user is clicking on the client DOC, allow him/her to
            // only click on the caption (for moving sizing) or we will
            // exit.
            //
            if (lpmh->hwnd != GetDesktopWindow() &&
                lpmh->wHitTestCode != HTCAPTION) {

                // Do this NOW before anybody gets a chance to yield and draw
                // with the wrong styles...

                if (gfPlayingInPlace)
                    Ole1EndPlayInPlace(ghwndApp);

                PostMessage(ghwndApp, WM_CLOSE, 0, 0L);  // GET OUT !!!
            }
        }
        if (!fDownNow)
            gfMouseUpSeen = TRUE;
        if (!fDownBefore)
            gfKeyStateUpSeen = TRUE;
    }

    return CallNextHookEx(hHookMouse, hc, wParam, lParam);
}
#endif

/**************************************************************************
***************************************************************************/

void FAR PASCAL Ole1PlayInPlace(HWND hwndApp, HWND hwndClient, LPRECT prc)
{
    HWND hwndP;

    DPF("Ole1PlayInPlace(%04X, %04X, [%d %d %d %d])\n", hwndApp, hwndClient, *prc);

    if (gfPlayingInPlace)           // this is bad
        return;

#ifdef DEBUG
    if (GetPrivateProfileInt("options", "PopupWindow", FALSE, "mplayer.ini"))
#else
    if (FALSE)
#endif
    {
        DPF("Using Popup window for playback\n");

        //
        // this is code for a popup window.
        //
        ClientToScreen(hwndClient, (LPPOINT)prc);
        ClientToScreen(hwndClient, (LPPOINT)prc+1);

        SetWS(hwndApp, WS_POPUP);

        hwndP = TopWindow(hwndClient);

#ifndef _WIN32
        // I haven't the faintest idea what this is trying to do, but I see it's
        // within the scope of a retail if(FALSE) anyway.
        // If you understand it then either delete the function or replace this comment.
        // Laurie
        SetWindowWord(hwndApp, GWW_HWNDPARENT, (WORD)hwndP);  // set owner
#endif

        gfParentWasEnabled = IsWindowEnabled(hwndP);
        EnableWindow(hwndP, FALSE);

    } else {
        DPF("Using Child window for playback\n");

        SetWS(hwndApp, WS_CHILD);
        SetParent(hwndApp, hwndClient);

        DinkWithWindowStyles(hwndApp, FALSE);
    }

    gfPlayingInPlace = TRUE;

    SetWindowPos(hwndApp, HWND_TOP,
                    prc->left,prc->top,
                    prc->right  - prc->left,
                    prc->bottom - prc->top,
                    SWP_NOACTIVATE);

#ifndef _WIN32
    if (fpMouseHook == NULL)
        fpMouseHook = (HOOKPROC)MakeProcInstance((FARPROC)MouseHook, ghInst);
#endif


    //
    // Is the key down at this INSTANT ???  Then wait until it comes up before
    // we allow GetAsyncKeyState to make us go away
    //

    gfMouseUpSeen =   !((GetAsyncKeyState(VK_LBUTTON) & 0x8000) ||
                                    (GetAsyncKeyState(VK_RBUTTON) & 0x8000));

    //
    // Is GetKeyState saying it's down?  If so, wait until GetKeyState returns
    // up before we let GetKeyState kill us.
    //

    gfKeyStateUpSeen= !(GetKeyState(VK_LBUTTON) || GetKeyState(VK_RBUTTON));


#ifdef _WIN32

    /*
    ** Tell mciole32.dll to install its mouse HookProc.
    */

#ifdef DEBUG
    if ( fHookInstalled ) {

        DPF( "Hook already installed\n" );
        DebugBreak();
    }
#endif

    if ( fpInstallHook ) {

        DWORD wow_thread_id = 0L;

        /*
        ** This is a HACK.  If the client applications is a WOW app the
        ** HIWORD of the window handle will be 0xFFFF.
        */
        if ( HIWORD(hwndClient) == 0xFFFF ) {
            wow_thread_id = GetWindowThreadProcessId( hwndClient, NULL );
        }

        fHookInstalled = (*fpInstallHook)( ghwndApp, wow_thread_id );
    }

#else   /* !_WIN32 */

    hHookMouse = SetWindowsHookEx( WH_MOUSE, fpMouseHook, ghInst,
                                   GetWindowTask(hwndClient) );
#endif

    ghwndFocusSave = GetFocus();
}

/**************************************************************************
***************************************************************************/

void FAR PASCAL Ole1EndPlayInPlace(HWND hwndApp)
{
    HWND hwndP;
    HWND hwndT;

#if 0   // can't do this because SS != DS
    DPF("Ole1EndPlayInPlace()\n");
#endif

    if (!gfPlayingInPlace || !IsWindow(hwndApp))
        return;

    /* Do this BEFORE hiding our window and BEFORE we do anything that */
    /* might yield so client can't redraw with the wrong styles set.   */
    DinkWithWindowStyles(hwndApp, TRUE);

    gfPlayingInPlace = FALSE;

#ifdef _WIN32

    /*
    ** Tell mciole32.dll to remove its mouse HookProc.
    */

    if ( fpRemoveHook ) {

        fHookInstalled = !(*fpRemoveHook)();
    }

#else  /* !_WIN32 */

    UnhookWindowsHookEx(hHookMouse);
    hHookMouse = NULL;

#endif

    hwndP = GetParent(hwndApp);

    //
    //  If we have the focus, then restore it to who used to have it.
    //  ACK!! If the person who used to have it is GONE, we must give it away
    //  to somebody (who choose our parent) because our child can't
    //  keep the focus without making windows crash hard during the WM_DESTROY
    //  (or maybe later whenever it feels like crashing at some random time).
    //  See bug #8634.
    //
    if ((hwndT = GetFocus()) && GetWindowTask(hwndT) == MGetCurrentTask) {
        if (IsWindow(ghwndFocusSave))
            SetFocus(ghwndFocusSave);
    else
        SetFocus(hwndP);
    }

    if (!hwndP ||
        (gwOptions & OPT_BAR) ||
        (gwOptions & OPT_BORDER) ||
        (gwOptions & OPT_AUTORWD)) {
        //
        // hide the aplication window
        //
        SetWindowPos(hwndApp, NULL, 0, 0, 0, 0,
            SWP_NOZORDER|SWP_NOSIZE|SWP_NOMOVE|SWP_HIDEWINDOW|
            SWP_NOACTIVATE);
    }
    else {
        //
        // hide our window, but don't redraw it will look
        // like we are still on the last frame.
        //
        // this is when we are playing in place, and there is
        // no playbar, and no rewind
        //
        // this is for Playing a AVI in a PowerPoint slide
        // without redraw problems.
        //
        SetWindowPos(hwndApp, NULL, 0, 0, 0, 0,
            SWP_NOREDRAW|SWP_NOZORDER|SWP_NOSIZE|SWP_NOMOVE|
            SWP_HIDEWINDOW|SWP_NOACTIVATE);
    }

    SetParent(hwndApp, NULL);
    ClrWS(hwndApp, WS_CHILD);

    if (hwndP && gfParentWasEnabled)
        EnableWindow(hwndP, TRUE);

    //
    // set either the owner or the WS_CHILD bit so it will
    // not act up because we have the palette bit set and cause the
    // desktop to steal the palette.
    //
#if 0
    // The folowing was ifdef-ed away before I saw it, but note that it
    // wouldn't work on WIN32 anyway.
    SetWindowWord(hwndApp, GWW_HWNDPARENT, (WORD)GetDesktopWindow());
#else
    SetWS(hwndApp, WS_CHILD);
#endif
}

#endif /* OLE1_HACK */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\ole2ui.h ===
/* NOTE: This stuff was taken from the OLE2UI library.
 * If it gets ported to NT, we can get rid of it from Media Player
 */

/*************************************************************************
** OLE OBJECT FEEDBACK EFFECTS
*************************************************************************/

#define OLEUI_HANDLES_USEINVERSE    0x00000001L
#define OLEUI_HANDLES_NOBORDER      0x00000002L
#define OLEUI_HANDLES_INSIDE        0x00000004L
#define OLEUI_HANDLES_OUTSIDE       0x00000008L


#define OLEUI_SHADE_FULLRECT        1
#define OLEUI_SHADE_BORDERIN        2
#define OLEUI_SHADE_BORDEROUT       3

/* objfdbk.c function prototypes */
STDAPI_(void) OleUIDrawHandles(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cSize, BOOL fDraw);
STDAPI_(void) OleUIDrawShading(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cWidth);
STDAPI_(void) OleUIShowObject(LPCRECT lprc, HDC hdc, BOOL fIsLink);


/*************************************************************************
** Hatch window definitions and prototypes                              **
*************************************************************************/
#define DEFAULT_HATCHBORDER_WIDTH   4

STDAPI_(BOOL) RegisterHatchWindowClass(HINSTANCE hInst);
STDAPI_(HWND) CreateHatchWindow(HWND hWndParent, HINSTANCE hInst);
STDAPI_(UINT) GetHatchWidth(HWND hWndHatch);
STDAPI_(void) GetHatchRect(HWND hWndHatch, LPRECT lpHatchRect);
STDAPI_(void) SetHatchRect(HWND hWndHatch, LPRECT lprcHatchRect);
STDAPI_(void) SetHatchWindowSize(
        HWND        hWndHatch,
        LPCRECT     lprcIPObjRect,
        LPCRECT     lprcClipRect,
        LPPOINT     lpptOffset,
        BOOL        handle
);



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\open.c ===
/*-----------------------------------------------------------------------------+
| OPEN.C                                                                       |
|                                                                              |
| This file contains the code that controls the 'Open Device or File' dialog.  |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

/* include files */

#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <mmsystem.h>
#include "mpole.h"
#include "mplayer.h"
#include "registry.h"
#include "regstr.h"

extern HMENU    ghMenu;                      /* handle to main menu           */
extern HMENU    ghDeviceMenu;                /* handle to the Device menu     */
extern UINT     gwNumDevices;                /* number of available devices   */
extern UINT     gwCurDevice;
extern PTSTR    gpchFilter;
LPTSTR          gpInitialDir = NULL;

extern SZCODE aszOptionsSection[];

static SZCODE   aszNULL[] = TEXT("");
static SZCODE   aszDirName[] = TEXT("%s Directory");

BOOL GetDefaultMediaDirectory(LPTSTR pDirectory, DWORD cbDirectory);

/*
 * fOK = DoOpen()
 *
 * Invoke the standard "File Open" dialog
 *
 * Return TRUE if and only if a new file is successfully opened.
 *
 */

INT_PTR FAR PASCAL DoOpen(UINT wCurDevice, LPTSTR szFileName)
{
    OPENFILENAME    ofn;
    TCHAR           achFile[MAX_PATH + 1];     /* file or device name buffer    */
    TCHAR           achTitle[80];   /* string holding the title bar name      */
    INT_PTR         f;
    TCHAR           DirectoryValue[80];

    ZeroMemory(&ofn, sizeof ofn);

    if (!LOADSTRING(IDS_OPENTITLE, achTitle)) {
        Error(ghwndApp, IDS_OUTOFMEMORY);
        return FALSE;
    }

    if (wCurDevice != 0)
    {
        /* Saving and restoring the current directory for the device:
         *
         * We remember the directory that the user just selected.
         * It is saved as the "<device> Directory" value under
         * \Software\Microsoft\Media Player\Options for the current user.
         * The next time the user goes to open another file via the same
         * Device menu, we present the same initial directory.
         * This directory is also presented in the case where the user
         * selects File.Open.
         */
        wsprintf(DirectoryValue, aszDirName, garMciDevices[wCurDevice].szDevice);
    } else {
        //
        // If you choose Open from File menu instead of Device menu,
        // we should use "<No Name>" value instead of "<device> Directory".
        //
        DirectoryValue[0] = '\0';
    }
    if (ReadRegistryData(aszOptionsSection, DirectoryValue, NULL, (LPBYTE)achFile,
                         BYTE_COUNT(achFile)) == NO_ERROR)
    {
        DWORD FileAttrs = GetFileAttributes(achFile);

        if ((FileAttrs != (DWORD)-1) && (FileAttrs & FILE_ATTRIBUTE_DIRECTORY))
        {
            if (gpInitialDir)
                FreeStr(gpInitialDir);

            gpInitialDir = AllocStr(achFile);
        }
    }


    /* Win95 and NT have a Media directory.  Use that by default.
     */
    if (!gpInitialDir)
    {
        if (GetDefaultMediaDirectory(achFile, BYTE_COUNT(achFile)))
        {
            if (gpInitialDir)
                FreeStr(gpInitialDir);

            gpInitialDir = AllocStr(achFile);
        }
    }

    *achFile = TEXT('\0');
    /* Display the dialog box */

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = ghwndApp;
    ofn.hInstance = ghInst;
    ofn.lpstrFilter = gpchFilter;   // in init.c

    if (wCurDevice == 0)
        ofn.nFilterIndex = gwNumDevices+1;      // select "All Files"
    else
        ofn.nFilterIndex = wCurDevice;

    ofn.lpstrFile = achFile;
    ofn.nMaxFile = sizeof(achFile);
    ofn.lpstrInitialDir = gpInitialDir;
    ofn.lpstrTitle = achTitle;
    ofn.Flags = OFN_HIDEREADONLY |
                OFN_FILEMUSTEXIST |
                OFN_SHAREAWARE |
                OFN_PATHMUSTEXIST;

    f = GetOpenFileName(&ofn);
    lstrcpy(szFileName, achFile);

    if (f) {

        LPTSTR pLastBackslash;

        //
        // get the device selected in the dialog...
        //
        if (ofn.nFilterIndex == gwNumDevices+1)
            wCurDevice = 0;    // all files
        else
            wCurDevice = (UINT)ofn.nFilterIndex;

        f = OpenMciDevice(achFile, garMciDevices[wCurDevice].szDevice);

        /* Save the directory that the user selected the file in.
         * achFile contains the full path of the file, which must include
         * at least one backslash.
         */
        pLastBackslash = STRRCHR(achFile, TEXT('\\'));

        if (pLastBackslash)
        {
            *(pLastBackslash) = TEXT('\0');     /* Make character following last
                                                       backslash null terminator */
            if (gpInitialDir)
                FreeStr(gpInitialDir);

            gpInitialDir = AllocStr(achFile);

            if (wCurDevice != 0 && gpInitialDir)
            {
                /* Save the initial directory for this device:
                 */
                WriteRegistryData(aszOptionsSection, DirectoryValue, REG_SZ,
                                  (LPBYTE)gpInitialDir, STRING_BYTE_COUNT(gpInitialDir));
            }
        }
    }

    return f;
}


/* GetDefaultMediaDirectory
 *
 * Returns C:\WINNT\Media, or whatever it's called.
 *
 */
BOOL GetDefaultMediaDirectory(LPTSTR pDirectory, DWORD cbDirectory)
{
    static SZCODE szSetup[] = REGSTR_PATH_SETUP;
    static SZCODE szMedia[] = REGSTR_VAL_MEDIA;
    HKEY          hkeySetup;
    LONG          Result;

    Result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSetup,
                          REG_OPTION_RESERVED,
                          KEY_QUERY_VALUE, &hkeySetup);

    if (Result == ERROR_SUCCESS)
    {
        Result = RegQueryValueEx(hkeySetup, szMedia, NULL, REG_NONE,
                                 (LPBYTE)pDirectory, &cbDirectory);

        RegCloseKey(hkeySetup);
    }

    return (Result == ERROR_SUCCESS);
}


BOOL FAR PASCAL OpenMciDevice(LPCTSTR szFile, LPCTSTR szDevice)
{
    HCURSOR         hcurPrev;       /* handle to the pre-hourglass cursor     */
    BOOL            f;
    BOOL            fWeWereActive;
    UINT            wDevice;

    if (szDevice == NULL && ((wDevice = IsMCIDevice(szFile)) != 0))
        return DoChooseDevice(wDevice);

    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    /* Avoid the appearance of a half-painted window - update it now */
    UpdateWindow(ghwndApp);

    fWeWereActive = gfAppActive;

    if (gwCurDevice)
        WriteOutOptions();  // save current options as default for the old device
                            // that is being closed before we open the new one.

    gwCurDevice = IsMCIDevice(szDevice);

    //
    // open the device/file
    //
    f = OpenMCI(szFile, szDevice);

    /* Give us activation back so UpdateDisplay can set focus to toolbar */
    if (f && fWeWereActive)
        SetActiveWindow(ghwndApp);

    //
    // only get the new options if:
    //
    //  we actually opened the device and we did not get the options
    //  from a OLE SetData!
    //
    if (f && (!gfRunWithEmbeddingFlag || gwOptions == 0))
        ReadOptions(); // Get the default options for this new device

    UpdateDisplay();

    SetCursor(hcurPrev);

    return f;
}

BOOL FAR PASCAL DoChooseDevice(UINT wID)
{
    BOOL    f;
    TCHAR   szFile[256];
    UINT    wOldDevice;
    UINT    wOldScale;

    //
    // is this a valid device id?
    //
    if (wID < 1 || wID > gwNumDevices)
        return FALSE;

    wOldDevice = gwCurDevice;
    wOldScale = gwCurScale;

    //
    // if this device does files, bring up the open dialog else just open it!
    //
    if (garMciDevices[wID].wDeviceType & DTMCI_FILEDEV)
        f = OpenDoc(wID, szFile);
    else
        f = OpenMciDevice(aszNULL, garMciDevices[wID].szDevice);

    /* NOTE: This needs to be above the UpdateDisplay() so that if no      */
    /* device was properly opened everything will be reset properly.       */
    /* If nothing was opened, reset the current device back to what it was */
    /* and uncheck everything in the scale menu.                           */
    /* Yes, but this surely won't work unless we reopen the old device!!   */
    /* Let's not bother with the previous device.                          */
    if (!f) {
//        gwCurDevice = wOldDevice;
//        gwCurScale = wOldScale;
        InvalidateRect(ghwndMap, NULL, TRUE);    // wipe out track area??
    }

    return f;
}


//
//  find the device, given a MCI device name.
//
UINT FAR PASCAL IsMCIDevice(LPCTSTR szDevice)
{
    UINT                w;

    if (szDevice == NULL || *szDevice == 0)
        return 0;

    for (w=1; w<=gwNumDevices; w++)
    {
        if (lstrcmpi(szDevice, garMciDevices[w].szDevice) == 0 ||
            lstrcmpi(szDevice, garMciDevices[w].szDeviceName) == 0)

            return w;
    }

    return 0;
}

INT_PTR FAR PASCAL FixLinkDialog(LPTSTR szFile, LPTSTR szDevice, int iLen)
{
    UINT        wDevice;
    TCHAR       achFile[_MAX_PATH + 1];  /* file or device name buffer  */
    TCHAR       achTitle[80];   /* string holding the title bar name    */
    HWND        hwndFocus;
    OPENFILENAME ofn;
    INT_PTR     f;

    static SZCODE   aszDialog[] = TEXT("MciOpenDialog"); // in open.c too.

    //
    // I GIVE UP!!!  Put up an open dlg box and let them find it themselves!
    //

    /* Ensure the device menu's built:
     */
    InitDeviceMenu();
    WaitForDeviceMenu();

    // find out the device number for the specifed device
    wDevice = IsMCIDevice(szDevice);

    LOADSTRING(IDS_FINDFILE, achFile);
    wsprintf(achTitle, achFile, gachClassRoot, FileName(szFile));  // title bar for locate dlg

    /* Start with the bogus file name */
    if (szFile)
    {
        LPTSTR szFileName = FileName(szFile);
        if (szFileName)
            lstrcpy(achFile, szFileName);
    }

    /* Set up the ofn struct */
    ofn.lStructSize = sizeof(OPENFILENAME);

    /* MUST use ActiveWindow to make user deal with us NOW in case of multiple*/
    /* broken links                                                           */
    ofn.hwndOwner = GetActiveWindow();

    ofn.hInstance = ghInst;
    ofn.lpstrFilter = gpchFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;

    if (wDevice == 0)
        ofn.nFilterIndex = gwNumDevices+1;      // select "All Files"
    else
        ofn.nFilterIndex = wDevice;

    ofn.lpstrFile       = achFile;
    ofn.nMaxFile        = CHAR_COUNT(achFile);
    ofn.lpstrFileTitle  = NULL;
    ofn.nMaxFileTitle   = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle      = achTitle;

    ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST |
                OFN_SHAREAWARE | OFN_PATHMUSTEXIST;

    ofn.nFileOffset     = 0;
    ofn.nFileExtension  = 0;
    ofn.lpstrDefExt     = NULL;
    ofn.lCustData       = 0;
    ofn.lpfnHook        = NULL;
    ofn.lpTemplateName  = NULL;

    // Show the cursor in case PowerPig is hiding it
    ShowCursor(TRUE);

    hwndFocus = GetFocus();

    /* Let the user pick a filename */
    f = GetOpenFileName(&ofn);
    if (f) {
        lstrcpyn(szFile, achFile, iLen);
        gfDirty = TRUE;       // make sure the object is dirty now
    }

    SetFocus(hwndFocus);

    // Put cursor back how it used to be
    ShowCursor(FALSE);

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\registry.c ===
#include <windows.h>
#ifdef CHICAGO_PRODUCT
#include <regstr.h>
#endif
#include "mplayer.h"

#ifdef CHICAGO_PRODUCT
TCHAR szRegPath[] = TEXT(REGSTR_PATH_WINDOWSAPPLETS "\\Media Player");
#else
TCHAR szRegPath[] = TEXT("Software\\Microsoft\\Media Player");
#endif


/* WriteRegistryData
 *
 * Writes a bunch of information to the registry
 *
 * Parameters:
 *
 *     pEntryNode - The node under szRegPath which should be created
 *         or opened for this data.  If this is NULL, the value is
 *         written directly under szRegPath.
 *
 *     pEntryName - The name of the value under pEntryNode to be set.
 *
 *     Type - Type of data to read (e.g. REG_SZ).
 *
 *     pData - Pointer to the value data to be written.  If this is NULL,
 *         the value under pEntryNode is deleted.
 *
 *     Size - Size, in bytes, of the buffer pointed to by pData.
 *
 *
 * This routine is fairly generic, apart from the name of the top-level node.
 *
 * The data are stored in the following registry tree:
 *
 * HKEY_CURRENT_USER
 *  
 *   Software
 *      
 *       Microsoft
 *          
 *           Windows NT
 *              
 *               CurrentVersion
 *                  
 *                   Media Player
 *                      
 *                       AVIVideo
 *                      
 *                       DisplayPosition
 *                      
 *                       SysIni
 *
 *
 * Return:
 *
 *     Registry status return (NO_ERROR is good)
 *
 *
 * Andrew Bell (andrewbe) wrote it, 10 September 1992
 *
 */
DWORD WriteRegistryData( LPTSTR pEntryNode,
                         LPTSTR pEntryName,
                         DWORD  Type,
                         LPBYTE pData,
                         DWORD  Size )
{
    DWORD  Status;
    HKEY   hkeyRegPath;
    HKEY   hkeyEntryNode;

    /* Open or create the top-level node.  For Media Player this is:
     * "Software\\Microsoft\\Windows NT\\CurrentVersion\\Media Player"
     */
    Status = RegCreateKeyEx( HKEY_CURRENT_USER, szRegPath, 0,
                             NULL, 0, KEY_WRITE, NULL, &hkeyRegPath, NULL );

    if( Status == NO_ERROR )
    {
        /* Open or create the sub-node.
         */
        if( pEntryNode )
            Status = RegCreateKeyEx( hkeyRegPath, pEntryNode, 0,
                                     NULL, 0, KEY_WRITE, NULL, &hkeyEntryNode, NULL );
        else
            hkeyEntryNode = hkeyRegPath;

        if( Status == NO_ERROR )
        {
            if( pData )
            {
                Status = RegSetValueEx( hkeyEntryNode,
                                        pEntryName,
                                        0,
                                        Type,
                                        pData,
                                        Size );

                if( Status != NO_ERROR )
                {
                    DPF1( "RegSetValueEx (%"DTS") failed: Error = %d\n", pEntryName, Status );
                }
            }
            else
            {
                Status = RegDeleteValue( hkeyEntryNode, pEntryName );

                if( Status != NO_ERROR )
                {
                    DPF1( "RegDeleteValue (%"DTS") failed: Error = %d\n", pEntryName, Status );
                }
            }

            if( pEntryNode )
                RegCloseKey( hkeyEntryNode );
        }

        else
        {
            DPF1( "RegCreateKeyEx (%"DTS") failed: Error = %d\n", pEntryNode, Status );
        }

        RegCloseKey( hkeyRegPath );
    }

    else
    {
        DPF1( "RegCreateKeyEx (%"DTS") failed: Error = %d\n", szRegPath, Status );
    }

    return Status;
}


/* ReadRegistryData
 *
 * Reads information from the registry
 *
 * Parameters:
 *
 *     pEntryNode - The node under Media Player which should be opened
 *         for this data.  If this is NULL, the value is
 *         written directly under szRegPath.
 *
 *     pEntryName - The name of the value under pEntryNode to be retrieved.
 *
 *     pType - Pointer to a buffer to receive type of data read.  May be NULL.
 *
 *     pData - Pointer to a buffer to receive the value data.
 *
 *     Size - Size, in bytes, of the buffer pointed to by pData.
 *
 * Return:
 *
 *     Registry status return (NO_ERROR is good)
 *
 *
 * Andrew Bell (andrewbe) wrote it, 10 September 1992
 *
 */
DWORD ReadRegistryData( LPTSTR pEntryNode,
                        LPTSTR pEntryName,
                        PDWORD pType,
                        LPBYTE pData,
                        DWORD  DataSize )
{
    DWORD  Status;
    HKEY   hkeyRegPath;
    HKEY   hkeyEntryNode;
    DWORD  Size;

    /* Open the top-level node.  For Media Player this is:
     * "Software\\Microsoft\\Windows NT\\CurrentVersion\\Media Player"
     */
    Status = RegOpenKeyEx( HKEY_CURRENT_USER, szRegPath, 0,
                           KEY_READ, &hkeyRegPath );

    if( Status == NO_ERROR )
    {
        /* Open the sub-node:
         */
        if( pEntryNode )
            Status = RegOpenKeyEx( hkeyRegPath, pEntryNode, 0,
                                   KEY_READ, &hkeyEntryNode );
        else
            hkeyEntryNode = hkeyRegPath;

        if( Status == NO_ERROR )
        {
            Size = DataSize;

            /* Read the entry from the registry:
             */
            Status = RegQueryValueEx( hkeyEntryNode,
                                      pEntryName,
                                      0,
                                      pType,
                                      pData,
                                      &Size );

            if( pEntryNode )
                RegCloseKey( hkeyEntryNode );
        }

        else
        {
            DPF1( "RegOpenKeyEx (%"DTS") failed: Error = %d\n", pEntryNode, Status );
        }

        RegCloseKey( hkeyRegPath );
    }

    else
    {
        DPF1( "RegOpenKeyEx (%"DTS") failed: Error = %d\n", szRegPath, Status );
    }

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\registry.h ===
DWORD WriteRegistryData( LPTSTR pEntryNode,
                         LPTSTR pEntryName,
                         DWORD  Type,
                         LPBYTE pData,
                         DWORD  Size );

DWORD ReadRegistryData( LPTSTR pEntryNode,
                        LPTSTR pEntryName,
                        PDWORD pType,
                        LPBYTE pData,
                        DWORD  DataSize );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\ole1.h ===
/*-----------------------------------------------------------------------------+
| SERVER.H                                                                     |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

//
//  global variables of doom!!
//
extern BOOL    gfEmbeddedObject;       // TRUE if editing embedded OLE object
extern BOOL    gfRunWithEmbeddingFlag; // TRUE if we are run with "-Embedding"
extern BOOL    gfCloseAfterPlaying;    // TRUE if we are to hide after play
extern BOOL    gfPlayingInPlace;       // TRUE if playing in place
extern BOOL    gfParentWasEnabled;     // TRUE if parent was enabled
extern BOOL    gfShowWhilePlaying;     //
extern BOOL    gfDirty;                //
extern int     gfErrorBox;             // TRUE if we have a message box active
extern BOOL    gfErrorDeath;           // Die when errorbox is up

// server related stuff.
#define REDEFINITION

typedef struct  _SRVR  *PSRVR;
typedef struct  _SRVR  FAR *LPSRVR;

void FAR PASCAL ServerUnblock(void);
void FAR PASCAL BlockServer(void);
void FAR PASCAL UnblockServer(void);

void FAR PASCAL PlayInPlace(HWND hwndApp, HWND hwndClient, LPRECT prc);
void FAR PASCAL EndPlayInPlace(HWND hwndApp);
void FAR PASCAL DelayedFixLink(UINT verb, BOOL fShow, BOOL fActivate);

void CleanObject(void);
void UpdateObject(void);
BOOL FAR PASCAL IsObjectDirty(void);

typedef  struct _SRVR {
    OLESERVER     olesrvr;
    LHSERVER      lhsrvr;         // registration handle
    HWND          hwnd;           // corresponding server window
}SRVR;

//BOOL FAR PASCAL InitServer (HWND, HANDLE, LPTSTR);
void FAR PASCAL TermServer (void);

typedef struct _OLECLIENT FAR*  LPOLECLIENT;

OLESTATUS FAR PASCAL SrvrOpen (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, LPOLESERVERDOC FAR *);
OLESTATUS FAR PASCAL SrvrCreate (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR *);
OLESTATUS FAR PASCAL SrvrCreateFromTemplate (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR *);
OLESTATUS FAR PASCAL SrvrEdit (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR *);
OLESTATUS FAR PASCAL SrvrExit (LPOLESERVER);
OLESTATUS FAR PASCAL SrvrRelease1 (LPOLESERVER);
OLESTATUS FAR PASCAL SrvrExecute (LPOLESERVER, HGLOBAL);

// server related stuff.
typedef struct  _OLE1DOC  *POLE1DOC;

typedef  struct _OLE1DOC {
    OLESERVERDOC     oledoc;
    LHSERVERDOC      lhdoc;         // registration handle
    HWND             hwnd;          // corresponding server window
    ATOM             aName;         // docmnet name.
} OLE1DOC ;

OLESTATUS FAR PASCAL  DocSave (LPOLESERVERDOC);
OLESTATUS FAR PASCAL  DocClose (LPOLESERVERDOC);
OLESTATUS FAR PASCAL  DocRelease (LPOLESERVERDOC);
OLESTATUS FAR PASCAL  DocGetObject (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR *, LPOLECLIENT);
OLESTATUS FAR PASCAL  DocSetDocDimensions (LPOLESERVERDOC, OLE_CONST RECT FAR*);
OLESTATUS FAR PASCAL  DocSetHostNames (LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);
OLESTATUS FAR PASCAL  DocExecute (LPOLESERVERDOC, HANDLE);
OLESTATUS FAR PASCAL  DocSetColorScheme (LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);

typedef struct _ITEM     *PITEM;
typedef struct _ITEM FAR *LPITEM;

typedef struct _ITEM  {   /*OLEOBJECT*/
    OLEOBJECT   oleobject;
    LPOLECLIENT lpoleclient;
    HWND        hwnd;
}ITEM;

OLESTATUS FAR PASCAL  ItemOpen (LPOLEOBJECT, BOOL);
OLESTATUS FAR PASCAL  ItemDoVerb (LPOLEOBJECT, UINT, BOOL, BOOL);
OLESTATUS FAR PASCAL  ItemRelease (LPOLEOBJECT);
OLESTATUS FAR PASCAL  ItemGetData (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FAR PASCAL  ItemSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS FAR PASCAL  ItemSetTargetDevice (LPOLEOBJECT, HANDLE);
OLECLIPFORMAT   FAR PASCAL ItemEnumFormats (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS FAR PASCAL  ItemSetColorScheme (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
OLESTATUS FAR PASCAL  ItemSetBounds (LPOLEOBJECT, OLE_CONST RECT FAR*);

extern SRVR gSrvr;
extern OLE1DOC  gDoc;
extern ITEM gItem;

int  FAR PASCAL SendChangeMsg(UINT options); //!!!

void FAR PASCAL TerminateServer(void);

void FAR PASCAL NewDoc(BOOL fUntitled);
BOOL FAR PASCAL RegisterDocument(LHSERVERDOC lhdoc, LPOLESERVERDOC FAR *lplpoledoc);
void FAR PASCAL RevokeDocument(void);

/* ole.h:
 */
typedef WORD OLECLIPFORMAT;

extern OLECLIPFORMAT  cfLink;
extern OLECLIPFORMAT  cfOwnerLink;
extern OLECLIPFORMAT  cfNative;

void FAR PASCAL SetEmbeddedObjectFlag(BOOL flag);

void FAR PASCAL CopyObject(HWND hwnd);

#define WM_USER_DESTROY (WM_USER+120)
#define WM_DO_VERB      (WM_USER+121)     /* Perform the ItemSetData      */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\persist.c ===
/*---------------------------------------------------------------------------
|   PERS.C
|   This file has the IPersistStorage and IPersistfile interface implementation.
|
|   Created By: Vij Rajarajan (VijR)
+---------------------------------------------------------------------------*/
#define SERVERONLY
#include <Windows.h>
#include "mpole.h"
#include "mplayer.h"

#define STGM_SALL (STGM_READWRITE | STGM_SHARE_EXCLUSIVE)

/**************************************************************************
***************   IPersistStorage INTERFACE IMPLEMENTATION.
**************************************************************************/
//delegate to the common IUnknown implementation.
STDMETHODIMP PSQueryInterface(
LPPERSISTSTORAGE      lpPersStg,      // persist storage object ptr
REFIID            riidReq,        // IID required
LPVOID FAR *      lplpUnk         // pre for returning the interface
)
{
    return UnkQueryInterface((LPUNKNOWN)lpPersStg, riidReq, lplpUnk);
}


STDMETHODIMP_(ULONG) PSAddRef(
LPPERSISTSTORAGE      lpPersStg      // persist storage object ptr
)
{
    return UnkAddRef((LPUNKNOWN) lpPersStg);
}


STDMETHODIMP_(ULONG) PSRelease (
LPPERSISTSTORAGE      lpPersStg      // persist storage object ptr
)
{
    return UnkRelease((LPUNKNOWN) lpPersStg);
}

STDMETHODIMP  PSGetClassID (
LPPERSISTSTORAGE    lpPersStg,
CLSID FAR*      pClsid
)
{
    DPF("PSGetClassID\n");

    /* Return the actual class ID that gets stored:
     */
    *pClsid = gClsIDOLE1Compat;

    return NOERROR;
}


STDMETHODIMP  PSIsDirty (
LPPERSISTSTORAGE    lpPersStg
)
{DPF("PSIsDirty\n");

    RETURN_RESULT( (fDocChanged && !(gfPlayingInPlace || gfOle2IPPlaying))
               ? S_OK : S_FALSE);
}

STDMETHODIMP PSInitNew (
LPPERSISTSTORAGE     lpPersStg,
LPSTORAGE           lpStorage
)
{
    return NOERROR;
}


/**************************************************************************
*   PSLoad:
*   The Load method reads the embedded data from the "\1Ole10Native"
*   stream of the IStorage passed as an argument. This is because
*   we always pretend to be an OLE1 server when transferring data.
*   ItemSetData is called with this embedded data to to run the required
*   object.
**************************************************************************/
STDMETHODIMP PSLoad (
LPPERSISTSTORAGE     lpPersStg,
LPSTORAGE           lpStorage
)
{
    LPDOC   lpdoc;
    SCODE   error;
    LPSTREAM pstm;
    ULONG   cbRead;
    DWORD size = 0;
    HGLOBAL hNative = NULL;
    LPTSTR  lpnative = NULL;

    DPF("\nPSLoad is being called\n");
    lpdoc = ((struct CPersistStorageImpl FAR*)lpPersStg)->lpdoc;

    error = GetScode(IStorage_OpenStream(lpStorage, sz1Ole10Native,
                                         NULL, STGM_SALL, 0, &pstm));
    if (error == S_OK)
    {
        error = GetScode(IStream_Read(pstm, &size, 4, &cbRead));
    }
    if (error == S_OK)
    {
        hNative = GlobalAlloc(GMEM_DDESHARE |GMEM_ZEROINIT, (LONG)size);
        if (hNative)
             lpdoc->native = GLOBALLOCK(hNative);
    }

    if(lpdoc->native )
    {
        error = GetScode(IStream_Read(pstm, lpdoc->native, size, &cbRead));

        if (cbRead != size) error = E_FAIL; // REVIEW SCODE stream size error
        IStream_Release(pstm);
    }
    else error = E_OUTOFMEMORY;

    if (error == S_OK)
    {
        error = ItemSetData((LPBYTE)lpdoc->native);
        fDocChanged = FALSE;
        lpdoc->doctype = doctypeEmbedded;
    }

    if(hNative)
    {
        GLOBALUNLOCK(hNative);
        GLOBALFREE(hNative);
    }

    RETURN_RESULT( error);
}

/**************************************************************************
*   PSSave:
*   The Save method saves the native data in "\1Ole10Native" stream.
*   This is because we always pretend to be an OLE1 server when transferring
*   data. This ensures backward compatibility. GetLink is called to get
*   the embedding data.
**************************************************************************/
STDMETHODIMP PSSave (
LPPERSISTSTORAGE     lpPersStg,
LPSTORAGE           lpStorage,
BOOL            fSameAsLoad
)
{
    LPDOC   lpdoc;
    SCODE   error;
    LPSTREAM pstm = NULL;
    ULONG   cbWritten;
    DWORD_PTR   size;
    HGLOBAL hNative = NULL;
    LPTSTR  lpnative = NULL;
    LPWSTR  lpszUserType;

    DPF("* in pssave *");
    lpdoc = ((struct CPersistStorageImpl FAR*)lpPersStg)->lpdoc;

#if 0
    // Allow saves if we're playing so that broken links can be fixed.
    if (fSameAsLoad && (gfOle2IPPlaying || gfPlayingInPlace))
        RETURN_RESULT(S_OK);
#endif

    //Mark as OLE1 mplayer object.
#ifndef UNICODE
    lpszUserType = AllocateUnicodeString(gachClassRoot);
#else
    lpszUserType = gachClassRoot;
#endif

    error = GetScode(WriteClassStg(lpStorage, &gClsIDOLE1Compat));

    error = GetScode(WriteFmtUserTypeStg(lpStorage, cfMPlayer, lpszUserType));
#ifndef UNICODE
    FreeUnicodeString(lpszUserType);
#endif

    if(error != S_OK)
        RETURN_RESULT(error);
    error = GetScode(IStorage_CreateStream(lpStorage, sz1Ole10Native,
                                           STGM_SALL | STGM_FAILIFTHERE, 0,0, &pstm));
    if (error == STG_E_FILEALREADYEXISTS)
    {
        error = GetScode(IStorage_OpenStream(lpStorage, sz1Ole10Native,
                                             NULL, STGM_SALL, 0,&pstm));
        DPF("*pssave--openstream*");
    }

    if(pstm && (error == S_OK))
        hNative = GetLink();

    if (hNative)
    {
        lpnative = GLOBALLOCK(hNative);
        size = GlobalSize(hNative);
    }
    else
        error = E_OUTOFMEMORY;

    if (lpnative && (size != 0L))
    {
        error = GetScode(IStream_Write(pstm, &size, 4, &cbWritten));
        error = GetScode(IStream_Write(pstm, lpnative, (ULONG)size, &cbWritten));

        DPF("\n*After pssave write");
        if (cbWritten != size) error = E_FAIL   ;   // REVIEW SCODE stream full error
        IStream_Release(pstm);
    }

    CleanObject();
    GLOBALUNLOCK(hNative);
    GLOBALFREE(hNative);
    RETURN_RESULT(error);
}

/* InPowerPointSlideView
 *
 * Check the class name of the container window to see if we're in PowerPoint.
 * This is to support the horrible hack to get around problem of PowerPoint
 * crashing if we delete an empty Media Clip.
 *
 */
STATICFN BOOL InPowerPointSlideView()
{
    TCHAR ClassName[256];

    if (GetClassName(ghwndCntr, ClassName, CHAR_COUNT(ClassName)) > 0)
    {
        if (lstrcmp(ClassName, TEXT("paneClassDC")) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

STDMETHODIMP PSSaveCompleted (
LPPERSISTSTORAGE    lpPersStg,
LPSTORAGE           lpStorage
)
{
    LPDOC   lpdoc;
    DPF("\n**pssavecompleted**");
    lpdoc = ((struct CPersistStorageImpl FAR*)lpPersStg)->lpdoc;

    /* Win95 HOT bug #11142
     *
     * Stop PowerPoint crashing horribly:
     */
    if ((gwDeviceID == 0) && InPowerPointSlideView())
        SendDocMsg(lpdoc, OLE_CHANGED);

    // inform clients that the object has been saved
    return SendDocMsg (lpdoc, OLE_SAVED);
}

STDMETHODIMP PSHandsOffStorage (
LPPERSISTSTORAGE    lpPersStg
)
{
    return NOERROR;
}



/**************************************************************************
************   IPersistFile INTERFACE IMPLEMENTATION.
**************************************************************************/
//delegate to common IUnknown implementation.
STDMETHODIMP PFQueryInterface(
LPPERSISTFILE       lpPersFile,      // persist storage object ptr
REFIID            riidReq,        // IID required
LPVOID FAR *      lplpUnk         // pre for returning the interface
)
{
    return UnkQueryInterface((LPUNKNOWN)lpPersFile, riidReq, lplpUnk);
}


STDMETHODIMP_(ULONG) PFAddRef(
LPPERSISTFILE       lpPersFile      // persist storage object ptr
)
{
    return UnkAddRef((LPUNKNOWN) lpPersFile);
}


STDMETHODIMP_(ULONG) PFRelease (
LPPERSISTFILE       lpPersFile      // persist storage object ptr
)
{
    return UnkRelease((LPUNKNOWN) lpPersFile);
}


STDMETHODIMP  PFGetClassID (
LPPERSISTFILE       lpPersFile,
CLSID FAR*      pCid
)
{
    DPF("\n* PFGetclassid");

    /* The docs are confusing here, but apparently IPersist interfaces
     * should return the old class ID:
     */
    *pCid = gClsIDOLE1Compat;

    return NOERROR;
}


STDMETHODIMP  PFIsDirty (
LPPERSISTFILE       lpPersFile
)
{
    RETURN_RESULT( gfDirty ? S_OK : S_FALSE);
}



//This will be called when the user does a "Insert->Create from file".
//Open the file with OpenMciDevice and we will be ready to transfer the
//object.
STDMETHODIMP PFLoad (
LPPERSISTFILE       lpPersFile,
LPCWSTR             lpszFileName,
DWORD           grfMode
)
{
    LPDOC   lpdoc;
    TCHAR   szFileName[256];

    lpdoc = ((struct CPersistStorageImpl FAR*)lpPersFile)->lpdoc;
    DPF("\n***IN PFLOAD: "DTS"\n", lpszFileName);
#if UNICODE
    lstrcpy(szFileName, lpszFileName);
#else
    UnicodeToAnsiString(lpszFileName, szFileName, UNKNOWN_LENGTH);
#endif
    if(OpenMciDevice(szFileName, NULL))
        RETURN_RESULT(S_OK);
    else
        RETURN_RESULT(E_FAIL);
}


STDMETHODIMP PFSave (
LPPERSISTFILE       lpPersFile,
LPCWSTR             lpszFileName,
BOOL                fRemember
)
{
    return NOERROR;
}



STDMETHODIMP PFSaveCompleted (
LPPERSISTFILE       lpPersFile,
LPCWSTR             lpszFileName
)
{
    LPDOC   lpdoc;

    lpdoc = ((struct CPersistStorageImpl FAR*)lpPersFile)->lpdoc;

    // inform clients that the object has been saved
    return SendDocMsg(lpdoc, OLE_SAVED);
}




STDMETHODIMP PFGetCurFile (
LPPERSISTFILE       lpPersFile,
LPWSTR FAR*         lplpszFileName
)
{
    RETURN_RESULT( E_NOTIMPL);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\riffdisp.c ===
/*-----------------------------------------------------------------------------+
| RIFFDISP.C                                                                   |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <commdlg.h>
#ifdef WIN16
#include "port16.h"
#endif
#include "mplayer.h"
#include "riffdisp.h"

static  HWND        hwndPreview;
static  HANDLE      hdibPreview;
static  TCHAR       achPreview[80];
static  HFONT       hfontPreview;
static  HINSTANCE   hMSVideo;

typedef HANDLE      HDRAWDIB;
typedef HDRAWDIB    (FAR PASCAL *PFNDRAWDIBOPEN)(void);
typedef BOOL        (FAR PASCAL *PFNDRAWDIBCLOSE)(HDRAWDIB hdd);
typedef BOOL        (FAR PASCAL *PFNDRAWDIBDRAW)(HDRAWDIB hdd,HDC hdc,int xDst,int yDst,int dxDst,int dyDst,LPBITMAPINFOHEADER lpbi,LPVOID lpBits,int xSrc,int ySrc,int dxSrc,int dySrc,UINT wFlags);

static  HDRAWDIB    hdd;
static  PFNDRAWDIBOPEN pfnDrawDibOpen;
static  PFNDRAWDIBCLOSE pfnDrawDibClose;
static  PFNDRAWDIBDRAW pfnDrawDibDraw;

#define GetHInstance()  (HINSTANCE)(SELECTOROF((LPVOID)&hwndPreview))

/***************************************************************************
 *
 ****************************************************************************/

//#define FOURCC_RIFF mmioFOURCC('R','I','F','F')
#define FOURCC_INFO mmioFOURCC('I','N','F','O')
#define FOURCC_DISP mmioFOURCC('D','I','S','P')
#define FOURCC_INAM mmioFOURCC('I','N','A','M')
#define FOURCC_ISBJ mmioFOURCC('I','S','B','J')

BOOL   PreviewOpen(HWND hwnd);
BOOL   PreviewFile(HWND hwnd, LPTSTR szFile);
BOOL   PreviewPaint(HWND hwnd);
BOOL   PreviewClose(HWND hwnd);

HANDLE ReadDisp(LPTSTR lpszFile, int cf, LPTSTR pv, int iLen);
HANDLE ReadInfo(LPTSTR lpszFile, FOURCC fcc, LPTSTR pv, int iLen);
HANDLE GetRiffDisp(LPTSTR lpszFile, LPTSTR szText, int iLen);

/***************************************************************************
 *
 ****************************************************************************/

BOOL PreviewOpen(HWND hwnd)
{
    LOGFONT lf;
    UINT    w;

    if (hwndPreview)
        return FALSE;

    hwndPreview = hwnd;

    w = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hMSVideo = LoadLibrary(TEXT("MSVIDEO.DLL"));
    SetErrorMode(w);

#ifdef WIN32
    if (hMSVideo != NULL)
#else
    if (hMSVideo > HINSTANCE_ERROR)
#endif
    {
        pfnDrawDibOpen  = (PFNDRAWDIBOPEN)GetProcAddress(hMSVideo, ANSI_TEXT("DrawDibOpen"));
        pfnDrawDibClose = (PFNDRAWDIBCLOSE)GetProcAddress(hMSVideo, ANSI_TEXT("DrawDibClose"));
        pfnDrawDibDraw  = (PFNDRAWDIBDRAW)GetProcAddress(hMSVideo, ANSI_TEXT("DrawDibDraw"));

        if (pfnDrawDibOpen)
            hdd = pfnDrawDibOpen();
    }

    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), (LPVOID)&lf, 0);
    hfontPreview = CreateFontIndirect(&lf);
}

/***************************************************************************
 *
 ****************************************************************************/

BOOL PreviewClose(HWND hwnd)
{
    if (hwndPreview != hwnd)
        return FALSE;

    if (hdibPreview)
        GlobalFree(hdibPreview);

    if (hfontPreview)
        DeleteObject(hfontPreview);

    if (hdd)
        pfnDrawDibClose(hdd);

#ifdef WIN32
    if (hMSVideo != NULL)
#else
    if (hMSVideo >= HINSTANCE_ERROR)
#endif
        FreeLibrary(hMSVideo);

    achPreview[0] = 0;
    hdd           = NULL;
    hMSVideo      = NULL;
    hwndPreview   = NULL;
    hdibPreview   = NULL;
    hfontPreview  = NULL;
}

/***************************************************************************
 *
 ****************************************************************************/

BOOL PreviewFile(HWND hwnd, LPTSTR szFile)
{
    if (hwndPreview != hwnd)
        return FALSE;

    achPreview[0] = 0;

    if (hdibPreview)
        GlobalFree(hdibPreview);

    hdibPreview = NULL;

    if (szFile)
    {
        hdibPreview = GetRiffDisp(szFile, achPreview, BYTE_COUNT(achPreview));
    }

    PreviewPaint(hwnd);
    return TRUE;
}

/***************************************************************************
 *
 ****************************************************************************/

BOOL PreviewPaint(HWND hwnd)
{
    RECT    rc;
    RECT    rcPreview;
    RECT    rcImage;
    RECT    rcText;
    HDC     hdc;
    HBRUSH  hbr;
    int     dx;
    int     dy;
    LPBITMAPINFOHEADER lpbi;

    if (hwndPreview != hwnd)
        return FALSE;

    //
    // locate the preview in the lower corner of the dialog (below the
    // cancel button)
    //
    GetClientRect(hwnd, &rcPreview);
    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rc);
    ScreenToClient(hwnd, (LPPOINT)&rc);
    ScreenToClient(hwnd, (LPPOINT)&rc+1);

    rcPreview.top   = rc.bottom + (rc.bottom - rc.top) + 12;
    rcPreview.left  = rc.left;
    rcPreview.right = rc.right;
    rcPreview.bottom -= 4;    // leave a little room at the bottom

    hdc = GetDC(hwnd);
#ifdef WIN32
    hbr = (HBRUSH)DefWindowProc(hwnd, WM_CTLCOLORDLG, (WPARAM)hdc, (LPARAM)hwnd);
#else
    hbr = (HBRUSH)DefWindowProc(hwnd, WM_CTLCOLOR, (WPARAM)hdc, MAKELONG(hwnd, CTLCOLOR_DLG));
#endif
    SelectObject(hdc, hfontPreview);
    SetStretchBltMode(hdc, COLORONCOLOR);

    InflateRect(&rcPreview, 4, 1);
    FillRect(hdc, &rcPreview, hbr);
    IntersectClipRect(hdc, rcPreview.left, rcPreview.top, rcPreview.right, rcPreview.bottom);
    InflateRect(&rcPreview, -4, -1);

    //
    // compute the text rect, using DrawText
    //
    rcText = rcPreview;
    rcText.bottom = rcText.top;

    DrawText(hdc, achPreview, -1, &rcText, DT_CALCRECT|DT_LEFT|DT_WORDBREAK);

    //
    // compute the image size
    //
    if (hdibPreview && hdd)
    {
        lpbi = GlobalLock(hdibPreview);

        //
        // DISP(CF_DIB) chunks are messed up they contain a DIB file! not
        // a CF_DIB, skip over the header if it is there.
        //
        if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
            lpbi = (LPBITMAPINFOHEADER)((LPBYTE)lpbi + sizeof(BITMAPFILEHEADER));

        rcImage = rcPreview;

        //
        //  if wider than preview area scale to fit
        //
        if ((int)lpbi->biWidth > rcImage.right - rcImage.left)
        {
            rcImage.bottom = rcImage.top + MulDiv((int)lpbi->biHeight,rcImage.right-rcImage.left,(int)lpbi->biWidth);
        }
        //
        //  if x2 will fit then use it
        //
        else if ((int)lpbi->biWidth * 2 < rcImage.right - rcImage.left)
        {
            rcImage.right  = rcImage.left + (int)lpbi->biWidth*2;
            rcImage.bottom = rcImage.top + (int)lpbi->biHeight*2;
        }
        //
        //  else center the image in the preview area
        //
        else
        {
            rcImage.right  = rcImage.left + (int)lpbi->biWidth;
            rcImage.bottom = rcImage.top + (int)lpbi->biHeight;
        }

        if (rcImage.bottom > rcPreview.bottom - (rcText.bottom - rcText.top))
        {
            rcImage.bottom = rcPreview.bottom - (rcText.bottom - rcText.top);

            rcImage.right = rcPreview.left +
                              MulDiv((int)lpbi->biWidth,
                                     rcImage.bottom-rcImage.top,
                                     (int)lpbi->biHeight);
            rcImage.left = rcPreview.left;
        }
    }
    else
    {
        SetRectEmpty(&rcImage);
    }

    //
    //  now center
    //
    dx = ((rcPreview.right - rcPreview.left) - (rcText.right - rcText.left))/2;
    OffsetRect(&rcText, dx, 0);

    dx = ((rcPreview.right - rcPreview.left) - (rcImage.right - rcImage.left))/2;
    OffsetRect(&rcImage, dx, 0);

    dy  = rcPreview.bottom - rcPreview.top;
    dy -= rcImage.bottom - rcImage.top;
    dy -= rcText.bottom - rcText.top;

    if (dy < 0)
        dy = 0;
    else
        dy = dy / 2;

    OffsetRect(&rcImage, 0, dy);
    OffsetRect(&rcText, 0, dy + rcImage.bottom - rcImage.top + 2);

    //
    //  now draw
    //
    DrawText(hdc, achPreview, -1, &rcText, DT_LEFT|DT_WORDBREAK);

    if (hdibPreview && hdd)
    {
        pfnDrawDibDraw(hdd,
                       hdc,
                       rcImage.left,
                       rcImage.top,
                       rcImage.right  - rcImage.left,
                       rcImage.bottom - rcImage.top,
                       lpbi,
                       NULL,
                       0,
                       0,
                       -1,
                       -1,
                       0);

        InflateRect(&rcImage, 1, 1);
        FrameRect(hdc, &rcImage, GetStockObject(BLACK_BRUSH));
    }

    ReleaseDC(hwnd, hdc);
    return TRUE;
}

/***************************************************************************
 *
 ****************************************************************************/

static UINT (FAR PASCAL *lpfnOldHook)(HWND, unsigned, WPARAM, LPARAM);

    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
    /* Edit controls */
#define edt1        0x0480

#define ID_TIMER    1234
#define PREVIEWWAIT 1000

UINT FAR PASCAL _EXPORT GetFileNamePreviewHook(HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam)
{
    int i;
    TCHAR ach[80];
    UINT Code;

    switch (msg) {
        case WM_COMMAND:
            Code = GET_WM_COMMAND_CMD(wParam,lParam);
            switch (LOWORD(wParam)) {
                case lst1:
                    if (Code == LBN_SELCHANGE)
                    {
                        KillTimer(hwnd, ID_TIMER);
                        SetTimer(hwnd, ID_TIMER, PREVIEWWAIT, NULL);
                    }
                    break;

                case IDOK:
                case IDCANCEL:
                    KillTimer(hwnd, ID_TIMER);
                    PreviewFile(hwnd, NULL);
                    break;

                case cmb1:
                case cmb2:
                case lst2:
                    if (Code == LBN_SELCHANGE)
                    {
                        KillTimer(hwnd, ID_TIMER);
                        PreviewFile(hwnd, NULL);
                    }
                    break;
            }
            break;

        case WM_TIMER:
            if (wParam == ID_TIMER)
            {
                KillTimer(hwnd, ID_TIMER);

                ach[0] = 0;
                i = (int)SendDlgItemMessage(hwnd, lst1, LB_GETCURSEL, 0, 0L);
                SendDlgItemMessage(hwnd, lst1, LB_GETTEXT, i, (LONG)(LPTSTR)ach);
                PreviewFile(hwnd, ach);
                return TRUE;
            }
            break;

        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
        case WM_PAINT:
            PreviewPaint(hwnd);
            break;

        case WM_INITDIALOG:
            PreviewOpen(hwnd);
            break;

        case WM_DESTROY:
            PreviewClose(hwnd);
            break;
    }

    if (lpfnOldHook)
        return (*lpfnOldHook)(hwnd, msg, wParam, lParam);
    else
        return FALSE;
}

/***************************************************************************
 *
 ****************************************************************************/

BOOL FAR PASCAL GetOpenFileNamePreview(LPOPENFILENAME lpofn)
{
    BOOL fHook;
    BOOL f;

    if (hwndPreview)
        return GetOpenFileName(lpofn);

    fHook = (BOOL)(lpofn->Flags & OFN_ENABLEHOOK);

    if (fHook)
        lpfnOldHook = lpofn->lpfnHook;

    lpofn->lpfnHook = (LPOFNHOOKPROC)MakeProcInstance((FARPROC)GetFileNamePreviewHook, GetHInstance());
    lpofn->Flags |= OFN_ENABLEHOOK;

    f = GetOpenFileName(lpofn);

#ifndef WIN32
    FreeProcInstance((FARPROC)lpofn->lpfnHook);
#endif

    if (fHook)
        lpofn->lpfnHook = lpfnOldHook;
    else
        lpofn->Flags &= ~OFN_ENABLEHOOK;

    return f;
}

/****************************************************************************
 *
 *  get both the DISP(CF_DIB) and the DISP(CF_TEXT) info in one pass, this is
 *  much faster than doing multiple passes over the file.
 *
 ****************************************************************************/

HANDLE GetRiffDisp(LPTSTR lpszFile, LPTSTR szText, int iLen)
{
    HMMIO       hmmio;
    MMCKINFO    ck;
    MMCKINFO    ckINFO;
    MMCKINFO    ckRIFF;
    HANDLE      h = NULL;
    LONG        lSize;
    DWORD       dw;
    HCURSOR     hcur = NULL;

    if (szText)
        szText[0] = 0;

    /* 20/9/92 - reverse engineering... (Laurie Griffiths)
    |  This routine ACTUALLY only ever gets called from PreviewFile.  That's
    |  in this file, so this routine should have been PRIVATE or STATIC.
    |  PreviewFile is itself called from only 3 places, also all in this file.
    |  Of these, two have NULL as the lpszFile (which is passed straight through
    |  to here) and the other one has text derived from
    |           SendDlgItemMessage(..., LB_GETTEXT, ...lpszFile)
    |  So if HIWORD(lpszFile) is ever zero, it's hard to see what good it does
    |  to take the LOWORD and cast it as an HMMIO (which would be even sillier
    |  in 32 bit land).  I reckon it will just always return.
    */

#ifdef WIN32
    if (lpszFile == NULL) return NULL;
    hmmio = mmioOpen(lpszFile, NULL, MMIO_ALLOCBUF | MMIO_READ);

#else   // 16 bit idio[syncra]cy?
    /* Open the file */
    if (HIWORD(lpszFile))
        hmmio = mmioOpen(lpszFile, NULL, MMIO_ALLOCBUF | MMIO_READ);
    else
        hmmio = (HMMIO)LOWORD(lpszFile);
#endif

    if (hmmio == NULL)
        return NULL;

    mmioSeek(hmmio, 0, SEEK_SET);

    /* descend the input file into the RIFF chunk */
    if (mmioDescend(hmmio, &ckRIFF, NULL, 0) != 0)
        goto error;

    if (ckRIFF.ckid != FOURCC_RIFF)
        goto error;

    while (!mmioDescend(hmmio, &ck, &ckRIFF, 0))
    {
        if (ck.ckid == FOURCC_DISP)
        {
            if (hcur == NULL)
                hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

            /* Read dword into dw, break if read unsuccessful */
            if (mmioRead(hmmio, (LPVOID)&dw, sizeof(dw)) != sizeof(dw))
                goto error;

            /* Find out how much memory to allocate */
            lSize = ck.cksize - sizeof(dw);

            if ((int)dw == CF_DIB && h == NULL)
            {
                /* get a handle to memory to hold the description and lock it down */
                if ((h = GlobalAlloc(GHND, lSize+4)) == NULL)
                    goto error;

                if (mmioRead(hmmio, GlobalLock(h), lSize) != lSize)
                    goto error;
            }
            else if ((int)dw == CF_TEXT && szText[0] == 0)
            {
                if (lSize > iLen-1)
                    lSize = iLen-1;

                szText[lSize] = 0;

                if (mmioRead(hmmio, (LPSTR)szText, lSize) != lSize)
                    goto error;
            }
        }
        else if (ck.ckid    == FOURCC_LIST &&
                 ck.fccType == FOURCC_INFO &&
                 szText[0]  == 0)
        {
            while (!mmioDescend(hmmio, &ckINFO, &ck, 0))
            {
                switch (ckINFO.ckid)
                {
                    case FOURCC_INAM:
//                  case FOURCC_ISBJ:

                        lSize = ck.cksize;

                        if (lSize > iLen-1)
                            lSize = iLen-1;

                        szText[lSize] = 0;

                        if (mmioRead(hmmio, (LPSTR)szText, lSize) != lSize)
                            goto error;

                        break;
                }

                if (mmioAscend(hmmio, &ckINFO, 0))
                    break;
            }
        }

        //
        // if we have both a picture and a title, then exit.
        //
        if (h != NULL && szText[0] != 0)
            break;

        /* Ascend so that we can descend into next chunk
         */
        if (mmioAscend(hmmio, &ck, 0))
            break;
    }

    goto exit;

error:
    if (h)
        GlobalFree(h);
    h = NULL;

exit:
#ifdef WIN32
    if (hmmio != NULL)
        mmioClose(hmmio, 0);
#else
    if (hmmio && HIWORD(lpszFile))
        mmioClose(hmmio, 0);
#endif

    if (hcur)
        SetCursor(hcur);

    return h;
}

#if 0
*
* /***************************************************************************
*  *
*  ****************************************************************************/
*
* HANDLE FAR PASCAL GetRiffPicture(LPTSTR szFile)
* {
*     return ReadDisp(szFile, CF_DIB, NULL, 0);
* }
*
* * /***************************************************************************
* *  *
* *  ****************************************************************************/
* *
* * BOOL FAR PASCAL GetRiffTitle(LPSTR szFile, LPSTR szTitle, int iLen)
* * {
* *     return ReadDisp(szFile, CF_TEXT,     szTitle, iLen) ||
* *            ReadInfo(szFile, FOURCC_INAM, szTitle, iLen) ||
* *            ReadInfo(szFile, FOURCC_ISBJ, szTitle, iLen) ;
* * }
* /****************************************************************************
*  *
*  ****************************************************************************/
*
* HANDLE ReadDisp(LPSTR lpszFile, int cf, LPSTR pv, int iLen)
* {
*     HMMIO       hmmio;
*     MMCKINFO    ckinfo;
*     MMCKINFO    ckRIFF;
*     HANDLE      h = NULL;
*     DWORD       dwSize;
*     DWORD       dw;
*
*     if (pv)
*         ((LPSTR)pv)[0] = 0;
*
*     /* Open the file */
*     if (HIWORD(lpszFile))
*         hmmio = mmioOpen(lpszFile, NULL, MMIO_ALLOCBUF | MMIO_READ);
*     else
*         hmmio = (HMMIO)LOWORD(lpszFile);
*
*     if (hmmio == NULL)
*         return NULL;
*
*     mmioSeek(hmmio, 0, SEEK_SET);
*
*     /* descend the input file into the RIFF chunk */
*     if (mmioDescend(hmmio, &ckRIFF, NULL, 0) != 0)
*         goto error;
*
*     if (ckRIFF.ckid != FOURCC_RIFF)
*         goto error;
*
*     /* search the file for a 'DISP' chunk */
*     ckinfo.ckid = FOURCC_DISP;
*     while (!mmioDescend(hmmio, &ckinfo, &ckRIFF, MMIO_FINDCHUNK))
*     {
*         /* Read dword into dw, break if read unsuccessful */
*         if (mmioRead(hmmio, (LPVOID)&dw, sizeof(dw)) != sizeof(dw))
*             goto error;
*
*         /* Check to see if the type is right */
*         if ((int)dw == cf)
*         {
*             /* Find out how much memory to allocate */
*             dwSize = ckinfo.cksize - sizeof(dw);
*
*             if (pv == NULL)
*             {
*                 /* get a handle to memory to hold the description and lock it down */
*                 h = GlobalAlloc(GHND, dwSize+1);
*
*                 if (!h)
*                     goto error;
*
*                 pv = GlobalLock(h);
*             }
*             else
*             {
*                 if (dwSize > (DWORD)iLen-1)
*                     dwSize = (DWORD)iLen-1;
*
*                 ((LPSTR)pv)[(int)dwSize] = 0;
*             }
*
*             if (mmioRead(hmmio, pv, (LONG)dwSize) != (LONG)dwSize)
*                 goto error;
*
*             if (HIWORD(lpszFile))
*                 mmioClose(hmmio, 0);
*
*             return h ? h : (HANDLE)(UINT)dwSize;
*         }
*
*         /* Ascend so that we can descend into next chunk
*          */
*         if(mmioAscend(hmmio, &ckinfo, 0))
*             break;
*     }
*
* error:
*     if (hmmio && HIWORD(lpszFile))
*         mmioClose(hmmio, 0);
*
*     if (h)
*         GlobalFree(h);
*
*     return NULL;
* }
*
* /****************************************************************************
*  *
*  ****************************************************************************/
*
* HANDLE ReadInfo(LPSTR lpszFile, FOURCC fcc, LPSTR pv, int iLen)
* {
*     HMMIO       hmmio;
*     HANDLE      h=NULL;
*     MMCKINFO    ckinfo;
*     MMCKINFO    ckLIST;
*     MMCKINFO    ckRIFF;
*     DWORD       dwSize;
*
*     if (pv)
*         ((LPSTR)pv)[0] = 0;
*
*     /* Open the file */
*     if (HIWORD(lpszFile))
*         hmmio = mmioOpen(lpszFile, NULL, MMIO_ALLOCBUF | MMIO_READ);
*     else
*         hmmio = (HMMIO)LOWORD(lpszFile);
*
*     if (hmmio == NULL)
*         return NULL;
*
*     mmioSeek(hmmio, 0, SEEK_SET);
*
*     /* descend the input file into the RIFF chunk */
*     if (mmioDescend(hmmio, &ckRIFF, NULL, 0) != 0)
*         goto error;
*
*     if (ckRIFF.ckid != FOURCC_RIFF)
*         goto error;
*
*     ckLIST.fccType = FOURCC_INFO;
*     if (mmioDescend(hmmio, &ckLIST, &ckRIFF, MMIO_FINDLIST) != 0)
*         goto error;
*
*     ckinfo.ckid = fcc;
*     if (mmioDescend(hmmio, &ckinfo, &ckLIST, MMIO_FINDCHUNK) != 0)
*         goto error;
*
*     /* Find out how much memory to allocate/read */
*     dwSize = ckinfo.cksize;
*
*     if (pv == NULL)
*     {
*         /* get a handle to memory to hold the description and lock it down */
*         h = GlobalAlloc(GHND, dwSize+1);
*
*         if (!h)
*             goto error;
*
*         pv = GlobalLock(h);
*     }
*     else
*     {
*         if (dwSize > (DWORD)iLen-1)
*             dwSize = (DWORD)iLen-1;
*
*         ((LPSTR)pv)[(int)dwSize] = 0;
*     }
*
*     /* read the description into the allocated memory */
*     if (mmioRead(hmmio, pv, (LONG)dwSize) != (LONG)dwSize)
*         goto error;
*
*     if (HIWORD(lpszFile))
*         mmioClose(hmmio, 0);
*
*     return h ? h : (HANDLE)(UINT)dwSize;
*
* error:
*     if (hmmio && HIWORD(lpszFile))
*         mmioClose(hmmio, 0);
*
*     if (h)
*         GlobalFree(h);
*
*     return NULL;
* }
*
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\sbutton.h ===
/*-----------------------------------------------------------------------------+
| SBUTTON.H                                                                    |
|                                                                              |
| Implements "3-D" buttons                                                     |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
| Created by Todd Laney                                                        |
| Munged 3/27/89 by Robert Bunney                                              |
| 7/26/89  - revised by Todd Laney to handle multi-res                         |
|            bitmaps.  transparent color bitmaps                               |
|            windows 3 support                                                 |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#define BS_STRETCH  0x8000L
#define BS_NOFOCUS  0x4000L
#define BS_STATIC   0x2000L

/*
    Sliders.

    Sliders ain't got no style or sophistication.
                                            The Cat
*/

// Useful window messages for sliders
#define SSB_GETPOS        (WM_USER)
#define SSB_SETPOS        (WM_USER+1)
#define SSB_GETRANGE      (WM_USER+2)
#define SSB_SETRANGE      (WM_USER+3)
#define SSB_GETWIDTHS     (WM_USER+4)

//
//  Init routine, will register the various classes.
//
BOOL FAR PASCAL ControlInit (HANDLE hPrev, HANDLE hInst);
void FAR PASCAL ControlCleanup (void);

/* objects from sbutton.c */

extern HBRUSH hbrGray;
extern HBRUSH hbrButtonFace;
extern HBRUSH hbrButtonShadow;
extern HBRUSH hbrButtonText;
extern HBRUSH hbrButtonHighLight;
extern HBRUSH hbrWindowFrame;
extern HBRUSH hbrWindowColour;

extern DWORD  rgbButtonHighLight;
extern DWORD  rgbButtonFocus;
extern DWORD  rgbButtonFace;
extern DWORD  rgbButtonText;
extern DWORD  rgbButtonShadow;
extern DWORD  rgbWindowFrame;
extern DWORD  rgbWindowColour;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\riffdisp.h ===
/*-----------------------------------------------------------------------------+
| RIFFDISP.H                                                                   |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#ifdef OFN_READONLY
    BOOL  FAR PASCAL GetOpenFileNamePreview(LPOPENFILENAME lpofn);
#endif

/****************************************************************************
 ****************************************************************************/

HANDLE FAR PASCAL GetRiffPicture(LPTSTR szFile);
BOOL   FAR PASCAL GetRiffTitle(LPTSTR szFile, LPTSTR szTitle, int iLen);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\server.c ===
/*---------------------------------------------------------------------------
|   SERVER.C
|   This file has the IClassFactory Interface implementation. It also has
|   the Vtbl initializations.
|
|   Created By: Vij Rajarajan (VijR)
+---------------------------------------------------------------------------*/
#define SERVERONLY
#include <windows.h>
#include "mpole.h"
#include "mplayer.h"

extern  IID     iidUnknownObject;
extern  IID iidClassFactory;

HMODULE hMciOle;


static SZCODE aszMCIOLE[]        = TEXT("MCIOLE32.DLL");       // WOW-proofing


static ANSI_SZCODE aszOleQueryObjPos[]   = ANSI_TEXT("OleQueryObjPos");

/**************************************************************************
*   The VTBLs are initialized here.
**************************************************************************/

// Method tables.
IClassFactoryVtbl           srvrVtbl=
{
   // IOleClassFactory method table
   /*   srvrVtbl.QueryInterface         = */    SrvrQueryInterface,
   /*   srvrVtbl.AddRef                 = */    SrvrAddRef,
   /*   srvrVtbl.Release                = */    SrvrRelease,
   /*   srvrVtbl.CreateInstance         = */    SrvrCreateInstance,
   /*   srvrVtbl.LockServer             = */    SrvrLockServer
};

IOleObjectVtbl              oleVtbl =
{
   // IOleObject method table
   /* oleVtbl.QueryInterface          = */ OleObjQueryInterface,
   /* oleVtbl.AddRef                  = */ OleObjAddRef,
   /* oleVtbl.Release                 = */ OleObjRelease,
   /* oleVtbl.SetClientSite           = */ OleObjSetClientSite,
   /* oleVtbl.GetClientSite           = */ OleObjGetClientSite,
   /* oleVtbl.SetHostNames            = */ OleObjSetHostNames,
   /* oleVtbl.Close                   = */ OleObjClose,
   /* oleVtbl.SetMoniker              = */ OleObjSetMoniker,
   /* oleVtbl.GetMoniker              = */ OleObjGetMoniker,
   /* oleVtbl.InitFromData            = */ OleObjInitFromData,
   /* oleVtbl.GetClipboardData        = */ OleObjGetClipboardData,
   /* oleVtbl.DoVerb                  = */ OleObjDoVerb,
   /* oleVtbl.EnumVerbs               = */ OleObjEnumVerbs,
   /* oleVtbl.Update                  = */ OleObjUpdate,
   /* oleVtbl.IsUpToDate              = */ OleObjIsUpToDate,
   /* oleVtbl.GetUserClassID          = */ OleObjGetUserClassID,
   /* oleVtbl.GetUserType             = */ OleObjGetUserType,
   /* oleVtbl.SetExtent               = */ OleObjSetExtent,
   /* oleVtbl.GetExtent               = */ OleObjGetExtent,
   /* oleVtbl.Advise                  = */ OleObjAdvise,
   /* oleVtbl.Unadvise                = */ OleObjUnadvise,
   /* oleVtbl.EnumAdvise              = */ OleObjEnumAdvise,
   /* oleVtbl.GetMiscStatus           = */ OleObjGetMiscStatus,
   /* oleVtbl.SetColorScheme          = */ OleObjSetColorScheme,
};

IDataObjectVtbl             dataVtbl =
{
   // IDataObject method table
   /* dataVtbl.QueryInterface          = */ DataObjQueryInterface,
   /* dataVtbl.AddRef                  = */ DataObjAddRef,
   /* dataVtbl.Release                 = */ DataObjRelease,
   /* dataVtbl.GetData                 = */ DataObjGetData,
   /* dataVtbl.GetDataHere             = */ DataObjGetDataHere,
   /* dataVtbl.QueryGetData            = */ DataObjQueryGetData,
   /* dataVtbl.GetCanonicalFormatEtc   = */ DataObjGetCanonicalFormatEtc,
   /* dataVtbl.SetData                 = */ DataObjSetData,
   /* dataVtbl.EnumFormatEtc           = */ DataObjEnumFormatEtc,
   /* dataVtbl.Advise                  = */ DataObjAdvise,
   /* dataVtbl.Unadvise                = */ DataObjUnadvise,
   /* dataVtbl.EnumAdvise              = */ DataObjEnumAdvise
};

IEnumFORMATETCVtbl      ClipDragEnumVtbl =
{

   // Clipboard dataobject's formatetc enumerator method table
   /* ClipDragEnumVtbl.QueryInterface      = */ ClipDragEnumQueryInterface,
   /* ClipDragEnumVtbl.AddRef          = */ ClipDragEnumAddRef,
   /* ClipDragEnumVtbl.Release         = */ ClipDragEnumRelease,
   /* ClipDragEnumVtbl.Next        = */ ClipDragEnumNext,
   /* ClipDragEnumVtbl.Skip        = */ ClipDragEnumSkip,
   /* ClipDragEnumVtbl.Reset           = */ ClipDragEnumReset,
   /* ClipDragEnumVtbl.Clone           = */ ClipDragEnumClone
};

IPersistStorageVtbl     persistStorageVtbl =
{
   /* persistStorageVtbl.QueryInterface          = */ PSQueryInterface,
   /* persistStorageVtbl.AddRef                  = */ PSAddRef,
   /* persistStorageVtbl.Release                 = */ PSRelease,
   /* persistStorageVtbl.GetClassID              = */ PSGetClassID,
   /* persistStorageVtbl.IsDirty                 = */ PSIsDirty,
   /* persistStorageVtbl.InitNew                 = */ PSInitNew,
   /* persistStorageVtbl.Load                    = */ PSLoad,
   /* persistStorageVtbl.Save            = */ PSSave,
   /* persistStorageVtbl.SaveCompleted       = */ PSSaveCompleted,
   /* persistStorageVtbl.HandsOffStorage     = */ PSHandsOffStorage
};

IOleInPlaceObjectVtbl       ipVtbl =
{

   // IOleInPlaceObject method table
   /* ipVtbl.QueryInterface          = */ IPObjQueryInterface,
   /* ipVtbl.AddRef                  = */ IPObjAddRef,
   /* ipVtbl.Release                 = */ IPObjRelease,
   /* ipVtbl.GetWindow               = */ IPObjGetWindow,
   /* ipVtbl.ContextSensitiveHelp    = */ IPObjContextSensitiveHelp,
   /* ipVtbl.InPlaceDeactivate       = */ IPObjInPlaceDeactivate,
   /* ipVtbl.UIDeactivate            = */ IPObjUIDeactivate,
   /* ipVtbl.SetObjectRects          = */ IPObjSetObjectRects,
   /* ipVtbl.ReactivateAndUndo       = */ IPObjReactivateAndUndo
};

IOleInPlaceActiveObjectVtbl ipActiveVtbl =
{
   // IOleInPlaceActiveObject method table
   /* ipActiveVtbl.QueryInterface          = */ IPActiveQueryInterface,
   /* ipActiveVtbl.AddRef                  = */ IPActiveAddRef,
   /* ipActiveVtbl.Release                 = */ IPActiveRelease,
   /* ipActiveVtbl.GetWindow               = */ IPActiveGetWindow,
   /* ipActiveVtbl.ContextSensitiveHelp    = */ IPActiveContextSensitiveHelp,
   /* ipActiveVtbl.TranslateAccelerator    = */ IPActiveTranslateAccelerator,
   /* ipActiveVtbl.OnFrameWindowActivate   = */ IPActiveOnFrameWindowActivate,
   /* ipActiveVtbl.OnDocWindowActivate     = */ IPActiveOnDocWindowActivate,
   /* ipActiveVtbl.ResizeBorder        = */ IPActiveResizeBorder,
   /* ipActiveVtbl.EnableModeless          = */ IPActiveEnableModeless
};




IDataObjectVtbl         clipdragVtbl =
{

   // ClipDrag IDataObject method table
   /* clipdragVtbl.QueryInterface      = */ ClipDragQueryInterface,
   /* clipdragVtbl.AddRef          = */ ClipDragAddRef,
   /* clipdragVtbl.Release         = */ ClipDragRelease,
   /* clipdragVtbl.GetData         = */ ClipDragGetData,
   /* clipdragVtbl.GetDataHere         = */ ClipDragGetDataHere,
   /* clipdragVtbl.QueryGetData        = */ ClipDragQueryGetData,
   /* clipdragVtbl.GetCanonicalFormatEtc   = */ ClipDragGetCanonicalFormatEtc,
   /* clipdragVtbl.SetData         = */ ClipDragSetData,
   /* clipdragVtbl.EnumFormatEtc       = */ ClipDragEnumFormatEtc,
   /* clipdragVtbl.Advise          = */ ClipDragAdvise,
   /* clipdragVtbl.Unadvise        = */ ClipDragUnadvise,
   /* clipdragVtbl.EnumAdvise          = */ ClipDragEnumAdvise
};

IDropSourceVtbl         dropsourceVtbl =
{
   // DragDrop IDropSource method table
   /* dropsourceVtbl.QueryInterface        = */ DropSourceQueryInterface,
   /* dropsourceVtbl.AddRef                = */ DropSourceAddRef,
   /* dropsourceVtbl.Release               = */ DropSourceRelease,
   /* dropsourceVtbl.QueryContinueDrag     = */ DropSourceQueryContinueDrag,
   /* dropsourceVtbl.GiveFeedback          = */ DropSourceGiveFeedback
};

#ifdef LATER
IDropTargetVtbl         droptargetVtbl =
{
   // DragDrop IDropTarget method table
   /* droptargetVtbl.QueryInterface        = */ DropTargetQueryInterface,
   /* droptargetVtbl.AddRef                = */ DropTargetAddRef,
   /* droptargetVtbl.Release               = */ DropTargetRelease,
   /* droptargetVtbl.DragEnter             = */ DropTargetDragEnter,
   /* droptargetVtbl.DragOver              = */ DropTargetDragOver,
   /* droptargetVtbl.DragLeave             = */ DropTargetDragLeave,
   /* droptargetVtbl.Drop                  = */ DropTargetDrop
};
#endif

IPersistFileVtbl            persistFileVtbl =
{

   /* persistFileVtbl.QueryInterface             = */ PFQueryInterface,
   /* persistFileVtbl.AddRef                     = */ PFAddRef,
   /* persistFileVtbl.Release                    = */ PFRelease,
   /* persistFileVtbl.GetClassID                 = */ PFGetClassID,
   /* persistFileVtbl.IsDirty                    = */ PFIsDirty,
   /* persistFileVtbl.Load                       = */ PFLoad,
   /* persistFileVtbl.Save                       = */ PFSave,
   /* persistFileVtbl.SaveCompleted              = */ PFSaveCompleted,
   /* persistFileVtbl.GetCurFile                 = */ PFGetCurFile
};

/**************************************************************************
***************   IClassFactory INTERFACE IMPLEMENTATION.
***************************************************************************/
STDMETHODIMP SrvrQueryInterface (
LPCLASSFACTORY        lpolesrvr,
REFIID                riid,
LPVOID   FAR          *lplpunkObj
)
{

    LPSRVR  lpsrvr;
DPF("*srvrqi");
    lpsrvr = (LPSRVR)lpolesrvr;

    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IClassFactory)) {
        *lplpunkObj = (LPVOID)lpsrvr;
        lpsrvr->cRef++;
        return NOERROR;
    } else {
        *lplpunkObj = (LPVOID) NULL;
    RETURN_RESULT(  E_NOINTERFACE);
    }
}


STDMETHODIMP_(ULONG) SrvrAddRef(
LPCLASSFACTORY           lpolesrvr
)
{
    LPSRVR  lpsrvr;
DPF("*srvrAR");
    lpsrvr = (LPSRVR)lpolesrvr;

    return ++lpsrvr->cRef;
}


STDMETHODIMP_(ULONG)    SrvrRelease (
LPCLASSFACTORY           lpolesrvr
)
{
    LPSRVR      lpsrvr;
DPF("*srvrREL");
    lpsrvr = (LPSRVR)lpolesrvr;
    DPFI("* SRVR CREF: %d*",lpsrvr->cRef);
    if (--lpsrvr->cRef == 0) {
        DestroyServer(lpsrvr);
        return 0;
    }

    return lpsrvr->cRef;
}


STDMETHODIMP SrvrCreateInstance (
LPCLASSFACTORY       lpolesrvr,
LPUNKNOWN            lpUnkOuter,
REFIID               riid,
LPVOID FAR           *lplpunkObj
)
{
    static BOOL fInstanceCreated = FALSE;
        DPF("*srvrcreateinst");
    /*********************************************************************
    ** OLE2NOTE: this is an SDI app; it can only create and support one
    **    instance. After the instance is created, the OLE libraries
    **    should not call CreateInstance again. it is a good practise
    **    to specifically guard against this.
    *********************************************************************/

    if (fInstanceCreated)
        RETURN_RESULT( E_FAIL);
    else {
        fInstanceCreated = TRUE;
    }

    /*********************************************************************
    ** OLE2NOTE: create and initialize a new document instance. the     **
    **    document's refcnt should start out as 1.                      **
    *********************************************************************/

    if (!InitNewDocObj(&docMain))
    RETURN_RESULT( E_OUTOFMEMORY);

    *lplpunkObj = (LPUNKNOWN) &docMain;

    return NOERROR;
}

//Increment or decrement the lock count as required. The server should not
//quit when there is a lock on the server.
STDMETHODIMP SrvrLockServer(
LPCLASSFACTORY           lpolesrvr,
BOOL                     fLock
)
{
    LPSRVR      lpsrvr;
DPF("*srvrLOCKSERVER");
    lpsrvr = (LPSRVR)lpolesrvr;

    if (fLock)
    {
    lpsrvr->cLock++;
    DPFI("CLOCK =  %d\n", lpsrvr->cLock);
    }
    else if ((--lpsrvr->cLock == 0) && (docMain.cRef == 0))
    {
    DPFI("CLOCK UNLOCK ZERO =  %d\n", lpsrvr->cLock);
    PostCloseMessage();
    }
    return NOERROR;
}



/**************************************************************************
Stub routine if we can't find MCIOLE.DLL
***************************************************************************/

OLE1_OLESTATUS FAR PASCAL NullOleQueryObjPos(LPOLEOBJECT lpobj, HWND FAR* lphwnd, LPRECT lprc, LPRECT lprcWBounds)
{
    DPF("NullQueryObjPos called, MCIOLE.DLL was not loaded\n");

    return OLE1_OLEERROR_GENERIC;
}

#ifdef OLE1_HACK
BOOL FAR PASCAL InitOle1Server(HWND hwnd, HANDLE hInst);
#endif

/**************************************************************************
*   InitServer:
*   This function initializes the server object with the IClassFactory
*   Vtbl and also load the mciole.dll library to support OLE 1.0 apps.
**************************************************************************/
BOOL InitServer (HWND hwnd, HANDLE hInst)
{
    int err;
    OQOPROC fp;

    srvrMain.olesrvr.lpVtbl = &srvrVtbl;
    srvrMain.dwRegCF=0;
    srvrMain.cRef = 0;
    srvrMain.cLock = 0;
    err = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hMciOle = LoadLibrary(aszMCIOLE);
    SetErrorMode(err);

    fp = (OQOPROC)GetProcAddress(hMciOle, aszOleQueryObjPos);

    if (hMciOle && fp)
        OleQueryObjPos = fp;                           // Avoid cast on LVALUE!!
    else
        OleQueryObjPos = (OQOPROC)NullOleQueryObjPos;

#ifdef OLE1_HACK
    InitOle1Server(hwnd, hInst);
#endif

    return TRUE;
}



void DestroyServer (LPSRVR lpsrvr)
{
    lpsrvr->fEmbedding = FALSE;
}



/**************************************************************************
*   InitNewDocObj:
*   Initializes the the lpdoc structure.
**************************************************************************/
BOOL InitNewDocObj(LPDOC lpdoc)
{                 DPFI("*INITNEWDOCOBJ*");
    // Fill the fields in the object structure.
    if(gfOle2IPEditing)
        return TRUE;
    lpdoc->cRef                     = 1;
    lpdoc->doctype                  = doctypeNew;

    lpdoc->m_Ole.lpVtbl             = &oleVtbl;
    lpdoc->m_Ole.lpdoc              = lpdoc;

    lpdoc->m_Data.lpVtbl            = &dataVtbl;
    lpdoc->m_Data.lpdoc             = lpdoc;

    lpdoc->m_PersistStorage.lpVtbl  = &persistStorageVtbl;
    lpdoc->m_PersistStorage.lpdoc   = lpdoc;

    lpdoc->lpIpData                 = NULL;
    lpdoc->m_InPlace.lpVtbl         = &ipVtbl;
    lpdoc->m_InPlace.lpdoc          = lpdoc;

    lpdoc->m_IPActive.lpVtbl        = &ipActiveVtbl;
    lpdoc->m_IPActive.lpdoc         = lpdoc;

    lpdoc->m_PersistFile.lpVtbl     = &persistFileVtbl;
    lpdoc->m_PersistFile.lpdoc      = lpdoc;

    lpdoc->aDocName             = GlobalAddAtom (TEXT("(Untitled)"));
    lpdoc->lpoleclient          = NULL;
    lpdoc->lpdaholder           = NULL;

    lpdoc->hwnd     = ghwndApp;
    lpdoc->hwndParent   = NULL;

#ifdef OLE1_HACK
    SetDocVersion( DOC_VERSION_OLE2 );
#endif /* OLE1_HACK */

   return TRUE;
}


/**************************************************************************
*   DestroyDoc:
*   This function Releases the references we hold. This function is called
*   at the termination of our operation as a server.
**************************************************************************/
void DestroyDoc (LPDOC lpdoc)
{
    if (lpdoc->lpoleclient) {

        /******************************************************************
        ** OLE2NOTE: we no longer need the ClientSite ptr, so release it **
        ******************************************************************/

        IOleClientSite_Release(lpdoc->lpoleclient);
        lpdoc->lpoleclient = NULL;
    }

    if (lpdoc->lpoaholder)
    {
        IOleAdviseHolder_Release(lpdoc->lpoaholder);
        lpdoc->lpoaholder = NULL;
    }

    if (lpdoc->lpdaholder)
    {
        IDataAdviseHolder_Release(lpdoc->lpdaholder);
        lpdoc->lpdaholder = NULL;
    }

    if (lpdoc->aDocName)
    {
        GlobalDeleteAtom (lpdoc->aDocName);
        lpdoc->aDocName = (ATOM)0;
    }

#ifdef OLE1_HACK
    SetDocVersion( DOC_VERSION_NONE );
#endif /* OLE1_HACK */
}




/* SendDocMsg
 * ----------
 *
 * This function sends a message to a specific doc object.
 *
 * LPOBJ lpobj   - The object
 * WORD wMessage - The message to send
 *
 *
 */
SCODE SendDocMsg (LPDOC lpdoc, WORD wMessage)
{
   HRESULT        status = S_OK;

   // if no clients connected, no message.
   if (lpdoc->cRef == 0)
   {
    DPFI("*OLE_NOMSG");
    return S_OK;
    }

   switch (wMessage) {
   case    OLE_CLOSED:
      // tell the clients that the UI is shutting down for this obj
      DPFI("*OLE_CLOSED");
#if 0
      //NOTE: We have to SendOnCLose for all clients even OLE1. But
      //OLE2 has bug (or by design flaw) that causes the OLE1 client
      //doc. to be marked as changed because OLE2 always resaves
      //the object even if the object has not changed. So may be we
      //should not send the SendOnClose if we just Played in the OLE1 client.

      if (gfPlayingInPlace || gfOle1Client)
           break;
#endif
        DPFI("*SENDING ONCLOSE");
      if (lpdoc->lpoaholder)
          status = IOleAdviseHolder_SendOnClose(lpdoc->lpoaholder);
      break;

   case    OLE_SAVED:
      // inform clients that the object has been saved
      DPFI("*OLE_SAVED");
      if (lpdoc->lpoaholder)
          status = IOleAdviseHolder_SendOnSave(lpdoc->lpoaholder);
      break;

   case    OLE_SAVEOBJ:
      // ask the embedding client to save the object now
      //If we are just playing then don't send this message.
#if 0
      // Yes, do, so that broken links can be fixed.
      if(gfOle2IPPlaying || gfPlayingInPlace || glCurrentVerb == OLEIVERB_PRIMARY)
        break;
#endif
      DPFI("*OLE_SAVEOBJ");
      if (lpdoc->lpoleclient)
          status = IOleClientSite_SaveObject(lpdoc->lpoleclient);
      break;

   case OLE_SHOWOBJ:
    if(lpdoc->lpoleclient)
        status = IOleClientSite_ShowObject(lpdoc->lpoleclient);
    break;

   case   OLE_CHANGED:
      // send data changed notification if any have registered
      //If we are just playing then don't send this message.
#if 0
      // Yes, do, so that broken links can be fixed.
      if(gfOle2IPPlaying || gfPlayingInPlace)
        break;
#endif
      DPFI("*OLE_CHANGED");
      if (lpdoc->lpdaholder)
          status = IDataAdviseHolder_SendOnDataChange
              (lpdoc->lpdaholder, (LPDATAOBJECT)&lpdoc->m_Data, 0, 0);
      break;

   case OLE_SIZECHG:
      // Inform clients that the size of the object has changed.
      // This is relevant only if we are inplace Editing.
    DPFI("*OLE_SIZEOBJ");
    if (gfOle2IPEditing)
    {
        RECT rc = gInPlacePosRect;
        if (ghwndMCI && gfInPlaceResize)
        {
        DPFI("***In OLE_SIZECHG gfACTIVE***");
        gfInPlaceResize = FALSE;
        }
        else if(ghwndMCI)
        {
            /* gInPlacePosRect contains the size of the in-place window
             * including playbar, if there is one.
             * Don't include the playbar on the OnPosRectChange:
             */
            DPFI("***getextent gfNotActive***");
            if (gwOptions & OPT_BAR)
                rc.bottom -= TITLE_HEIGHT;
        }

        MapWindowPoints(NULL,ghwndCntr,(POINT FAR *)&rc,(UINT)2);

        DPF("IOleInPlaceSite::OnPosRectChange %d, %d, %d, %d\n", rc);

        if (!gfInPPViewer)
            IOleInPlaceSite_OnPosRectChange(lpdoc->lpIpData->lpSite, (LPRECT)&rc);
    }
    break;
   }
   return GetScode(status);
}



BOOL ItsSafeToClose(void);

void FAR PASCAL InitDoc(BOOL fUntitled)
{

    if (gfEmbeddedObject && IsObjectDirty())
    {
        CleanObject();
    }

    if (ItsSafeToClose())
        CloseMCI(TRUE);
    if (fUntitled)
    {
        LOADSTRING(IDS_UNTITLED, gachFileDevice);
    }
}


BOOL CreateDocObjFromFile (
LPCTSTR  lpszDoc,
LPDOC    lpdoc
)
{
    lpdoc->doctype = doctypeFromFile;

    // set file name atom
    if (lpdoc->aDocName)
        GlobalDeleteAtom (lpdoc->aDocName);
    lpdoc->aDocName = GlobalAddAtom(lpszDoc);

    //SetTitle(lpdoc, lpszDoc);

    // register as running
    return TRUE;
}

//Open a new document (file or media). Subclass the playback window if
// the device has one. This will be used for drag drop operations.
BOOL OpenDoc (UINT wid, LPTSTR lpsz)
{
   if (!DoOpen(wid,lpsz))
      return FALSE;
   /**********************************************************************
   ** OLE2NOTE: shut down current doc before openning a new one. this   **
   **    will send OLE_CLOSED to any clients if they exist.             **
   **********************************************************************/
   CreateDocObjFromFile (lpsz, &docMain);

   SubClassMCIWindow();
   return TRUE;
}




/* SetTitle
 * --------
 *
 * Sets the main window's title bar. The format of the title bar is as follows
 *
 * If embedded
 *        <Server App name> - <object type> in <client doc name>
 *
 *  Example:  "SNWBOARD.AVI - Media Clip in OLECLI.DOC"
 *                where OLECLI.DOC is a Winword document
 */
BOOL SetTitle (LPDOC lpdoc, LPCTSTR lpszDoc)
{
    TCHAR szBuf[cchFilenameMax];
    TCHAR szBuf1[cchFilenameMax];

    if (lpszDoc && lpszDoc[0])
    {
        // Change document name.
        if (lpdoc->aDocName)
            GlobalDeleteAtom (lpdoc->aDocName);
        lpdoc->aDocName = GlobalAddAtom (lpszDoc);
    }

    if (gfEmbeddedObject)
    {
        if (!(gwDeviceType & DTMCI_FILEDEV) && (gwCurDevice > 0))
        {
            lstrcpy(gachWindowTitle,garMciDevices[gwCurDevice].szDeviceName);
        }

        if (lpszDoc && lpszDoc[0])
        {
            /* Load "Media Clip in %s":
             */
            if(!LOADSTRING(IDS_FORMATEMBEDDEDTITLE, szBuf))
                return FALSE;

            if (gachWindowTitle[0])
            {
                /* Format with server app name:
                 */
                wsprintf (szBuf1, TEXT("%s - %s"), gachWindowTitle, szBuf);
                wsprintf (szBuf, szBuf1, gachClassRoot, FileName (lpszDoc));
            }
            else
            {
                /* Format without server app name:
                 */
                wsprintf (szBuf1, TEXT("%s"), szBuf);
                wsprintf (szBuf, szBuf1, gachClassRoot, FileName (lpszDoc));
            }
        }
        else
        {
           return FALSE;
        }

        SetWindowText (ghwndApp, szBuf);
    }

    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\server.h ===
/*-----------------------------------------------------------------------------+
| SERVER.H                                                                     |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

//
// this function is in MCIOLE.DLL
//

/* This is defined (as an enum) in ole.h:
 */
typedef UINT OLESTATUS;

//
//  global variables of doom!!
//
extern BOOL    gfEmbeddedObject;       // TRUE if editing embedded OLE object
extern BOOL    gfRunWithEmbeddingFlag; // TRUE if we are run with "-Embedding"
extern BOOL    gfCloseAfterPlaying;    // TRUE if we are to hide after play
extern BOOL    gfPlayingInPlace;       // TRUE if playing in place
extern BOOL    gfParentWasEnabled;     // TRUE if parent was enabled
extern BOOL    gfShowWhilePlaying;     //
extern BOOL    gfDirty;                //
extern int     gfErrorBox;             // TRUE if we have a message box active
extern BOOL    gfErrorDeath;           // Die when errorbox is up

// server related stuff.
#define SERVER_STUFF
#ifdef SERVER_STUFF
//typedef struct  _SRVR  *PSRVR;
//typedef struct  _SRVR  FAR *LPSRVR;
#endif /* SERVER_STUFF */

void FAR PASCAL ServerUnblock(void);
void FAR PASCAL BlockServer(void);
void FAR PASCAL UnblockServer(void);

void FAR PASCAL PlayInPlace(HWND hwndApp, HWND hwndClient, LPRECT prc);
void FAR PASCAL EndPlayInPlace(HWND hwndApp);
void FAR PASCAL DelayedFixLink(UINT verb, BOOL fShow, BOOL fActivate);

void CleanObject(void);
void UpdateObject(void);
BOOL FAR PASCAL IsObjectDirty(void);

#ifdef SERVER_STUFF
#ifdef REDEFINITION
typedef  struct _SRVR {
    OLESERVER     olesrvr;
    LHSERVER      lhsrvr;         // registration handle
    HWND          hwnd;           // corresponding server window
}SRVR;
#endif /* REDEFINITION */

//BOOL FAR PASCAL InitServer (HWND, HANDLE, LPTSTR);
void FAR PASCAL TermServer (void);

typedef struct _OLECLIENT FAR*  LPOLECLIENT;


#ifdef REDEFINITION
// server related stuff.
typedef struct  _DOC  *PDOC;

typedef  struct _DOC {
    OLESERVERDOC     oledoc;
    LHSERVERDOC      lhdoc;         // registration handle
    HWND             hwnd;          // corresponding server window
    ATOM             aName;         // docmnet name.
} DOC ;
#endif /* REDEFINITION */

#ifdef UNUSED

OLESTATUS FAR PASCAL  DocSave (LPOLESERVERDOC);
OLESTATUS FAR PASCAL  DocClose (LPOLESERVERDOC);
OLESTATUS FAR PASCAL  DocRelease (LPOLESERVERDOC);
OLESTATUS FAR PASCAL  DocGetObject (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR *, LPOLECLIENT);
OLESTATUS FAR PASCAL  DocSetDocDimensions (LPOLESERVERDOC, OLE_CONST RECT FAR*);
OLESTATUS FAR PASCAL  DocSetHostNames (LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);
OLESTATUS FAR PASCAL  DocExecute (LPOLESERVERDOC, HANDLE);
OLESTATUS FAR PASCAL  DocSetColorScheme (LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);

#endif /* UNUSED */

//typedef struct _ITEM     *PITEM;
//typedef struct _ITEM FAR *LPITEM;

//typedef struct _ITEM  {   /*OLEOBJECT*/
//    OLEOBJECT   oleobject;
//    LPOLECLIENT lpoleclient;
//    HWND        hwnd;
//}ITEM;

//OLESTATUS FAR PASCAL  ItemOpen (LPOLEOBJECT, BOOL);
//OLESTATUS FAR PASCAL  ItemDoVerb (LPOLEOBJECT, UINT, BOOL, BOOL);
//OLESTATUS FAR PASCAL  ItemRelease (LPOLEOBJECT);
//OLESTATUS FAR PASCAL  ItemGetData (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
//OLESTATUS FAR PASCAL  ItemSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
//OLESTATUS FAR PASCAL  ItemSetTargetDevice (LPOLEOBJECT, HANDLE);
//OLECLIPFORMAT   FAR PASCAL ItemEnumFormats (LPOLEOBJECT, OLECLIPFORMAT);
//OLESTATUS FAR PASCAL  ItemSetColorScheme (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
//OLESTATUS FAR PASCAL  ItemSetBounds (LPOLEOBJECT, OLE_CONST RECT FAR*);

//!!extern SRVR gSrvr;
//!!extern DOC  gDoc;
//!!extern ITEM gItem;

int  FAR PASCAL SendChangeMsg(UINT options); //!!!

void FAR PASCAL TerminateServer(void);

//void FAR PASCAL NewDoc(BOOL fUntitled);
//BOOL FAR PASCAL RegisterDocument(LHSERVERDOC lhdoc, LPOLESERVERDOC FAR *lplpoledoc);
//void FAR PASCAL RevokeDocument(void);

/* ole.h:
 */
typedef WORD OLECLIPFORMAT;

extern OLECLIPFORMAT  cfLink;
extern OLECLIPFORMAT  cfOwnerLink;
extern OLECLIPFORMAT  cfNative;

void FAR PASCAL SetEmbeddedObjectFlag(BOOL flag);

void FAR PASCAL CopyObject(HWND hwnd);

#define WM_USER_DESTROY (WM_USER+120)
#define WM_DO_VERB      (WM_USER+121)     /* Perform the ItemSetData      */

#endif /* SERVER_STUFF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\toolbar.h ===
/*-----------------------------------------------------------------------------+
| TOOLBAR.H                                                                    |
|                                                                              |
| Program Description: Implements a generic toolbar.                           |
|                                                                              |
| Here's how to use it:                                                        |
|                                                                              |
|           Include the source files "toolbar.h" and "toolbar.c" in your       |
| application.                                                                 |
|                                                                              |
|           Include a line in your application's RC file that gives a file     |
| name with a resource id eg. IDBMP_BUTTONS.  This is a .BMP file that         |
| contains all of the pictures of the buttons you want on your toolbar.        |
| Also, make a define for your label with a unique value.  If your app has     |
| more than one toolbar, and all toolbars don't share a bitmap file, then      |
| you will need several defines.                                               |
|                                                                              |
| e.g.         IDBMP_BUTTONS     BITMAP     "buttons.bmp"                      |
|              IDBMP_ARROWS      BITMAP     "arrows.bmp"                       |
|                                                                              |
|           This file must have the different buttons across horizontally      |
| and the different states for these buttons vertically.  Change the           |
| defines in this header file to match the button names and state names of     |
| your buttons.  You must include the states listed here, and actually         |
| you probably won't need to change them at all.  The numbers for a button     |
| or state are indexes into the bitmap, so the pictures must match.            |
|                                                                              |
| STATE DESCRIPTIONS:                                                          |
|                      GRAYED:  The button cannot be pressed & is inactive     |
|                          UP:  The button is up                               |
|                        DOWN:  The button is down                             |
|                     FOCUSUP:  The button is up and is the one with focus     |
|                   FOCUSDOWN:  The button is down and is the one with focus   |
|                    FULLDOWN:  A checkbox button has this additional state    |
|                               where it is all the way down when pressed      |
|                               and when it is let go, it will go into         |
|                               either the UP or DOWN state (maybe focused)    |
|                                                                              |
| When you draw the pictures, make sure to get the right state in the right    |
| vertical position in the bitmap to match the #define's.                      |
|                                                                              |
| A button can also have a type associated with it:                            |
|                                                                              |
|                PUSH:  When pressed it goes down, when let go it bounces      |
|                       up.  Therefore, when you aren't currently holding      |
|                       the mouse button or space bar on it, it will           |
|                       ALWAYS be in the up position. It can be in any         |
|                       state except FULLDOWN, which is invalid.               |
|                                                                              |
|            CHECKBOX:  This button can be up or down.  When pushed, it        |
|                       toggles into the opposite state.  However, it          |
|                       is always in the FULLDOWN state when being held        |
|                       down with the mouse button or space bar, and when      |
|                       let go, it will go into the opposite state of what     |
|                       it was in before you pressed it.  E.G.  The button     |
|                       is up.  You press it, and it goes way down. You let    |
|                       go, and it comes up a bit, but it's still down.  You   |
|                       press it again, and it goes further down before        |
|                       popping all the way up.                                |
|                                                                              |
|               RADIO:  This is a group of buttons that can be up or down,     |
|                       and also have the intermediate step of being           |
|                       FULLDOWN when being held down.  But, when you          |
|                       push one of the radio buttons down, all other radio    |
|                       buttons in its group will pop up.  Any group can       |
|                       have only 1 down at a time, and 1 must be down.        |
|                                                                              |
|               CUSTOM: If your application is wierd, you can have a custom    |
|                       type button that does anything you want it to.         |
|                                                                              |
| First, your app must call:    toolbarInit(hInst, hPrev);                     |
| with the two instance parameters to register a toolbar window class.         |
| Then your app is free to call CreateWindow with a class of                   |
| szToolBarClass   to create one or more toolbar windows anywhere it wants     |
| and of any size it wants, presumably as the child window of another of the   |
| app's windows.  The file that creates the window must declare an             |
| extern char szToolBarClass[];   All messages about activity to a toolbar     |
| button will go to the parent window of the toolbar.                          |
|                                                                              |
| Next, call:     toolbarSetBitmap(HWND hwnd, HANDLE hInst, int ibmp,          |
|                                                       POINT ptSize);         |
| Pass it the resource ID (eg. IDBMP_BUTTONS) to tell the toolbar where to     |
| find the pictures for the buttons.  Also pass a point with the width and     |
| height of each button (eg. 24 X 22) so it knows how to find individual       |
| buttons in the bitmap file.                                                  |
|                                                                              |
| Next, call:     toolbarAddTool(HWND hwnd, TOOLBUTTON tb);                    |
| as many times as you want to add a button to the toolbar specified by        |
| hwnd.  You fill in the "tb" struct with the following information:           |
|                                                                              |
|      tb.rc        = the rect in the toolbar window to place the button       |
|                     based at 0,0 and measured in pixels.                     |
|      tb.iButton   = the ID of the button you wish the add (which is          |
|                     the horizontal offset into the bitmap of buttons).       |
|                     Only one of each button allowed.  Use one of the         |
|                     defines (BTN_??????).                                    |
|      tb.iState    = the initial state of the button (GRAYED, UP, DOWN).      |
|                     If you wish, you can specify a FOCUS'ed state to give    |
|                     any button you wish the focus.  By default, it's the     |
|                     one furthest left and tabbing order goes to the right.   |
|                     This is the vertical offset into the bitmap.             |
|                     Use one of the defines (BTNST_?????).                    |
|      tb.iType     = The type of button (BTNTYPE_???).  Either pushbutton,    |
|                     checkbox, or radio button. (or custom).  If it is a      |
|                     radio button, you can have many groups of radio btn's    |
|                     on the same toolbar.  Type BTNTYPE_RADIO is one group.   |
|                     Use BTNTYPE_RADIO+1 for another group, BTNTYPE_RADIO+2   |
|                     for a third group, etc.  You have thousands.             |
|      tb.iString   = The resource ID of a string to be associated with        |
|                     this button (if you'd like).                             |
|                                                                              |
|                                                                              |
|  At any time in the app, you can call toolbarAddTool to add more buttons     |
|  or toolbarRemoveTool to take some away.  To take one away, identify it      |
|  with it's button ID (horizontal offset in the bitmap).                      |
|                                                                              |
|  You can also call toolbarRetrieveTool to get the TOOLBUTTON struct back     |
|  from a button that is on the toolbar.  This is the way to change a          |
|  button's position.  Change the tb.rc and then Remove and Add the button     |
|  again so that the tabbing order will be re-calculated based on the new      |
|  rect of the tool.                                                           |
|                                                                              |
|  Now, all buttons will automatically behave properly.  They'll go up and     |
|  down as you press on them, or use the keyboard, groups of radio buttons     |
|  will pop up as you press a different one down, etc. etc. etc.               |
|  You don't have to do a thing!                                               |
|                                                                              |
|  The parent of the toolbar window will get a WM_COMMAND message with         |
|  a wParam of IDC_TOOLBAR  whenever anything happens to a button.             |
|  On Win16:                                                                   |
|    LOWORD(lParam) == hwnd of the toolbar window that has the button on it.   |
|    (HIWORD(lParam) & 0xFF) == the button ID of the button.                   |
|  On Win32:                                                                   |
|    lParam         == hwnd of the toolbar window that has the button on it.   |
|    (HIWORD(wParam) & 0xFF) == the button ID of the button.                   |
|    (This relies on a 32 bit button id being ACTUALLY only 16 bits            |
|     Someday this could go sour and need redesign).                           |
|                                                                              |
|  Remember to change IDC_TOOLBAR to something unique.                         |
|                                                                              |
|  The app can then call   toolbarIndexFromButton(hwnd, buttonID)              |
|  to get the index of the button (used for subsequent calls).                 |
|                                                                              |
|  Then call:      toolbarStateFromButton(hwnd, buttonID)                      |
|                                                                              |
|                  to get either BTNST_UP or BTNST_DOWN.  This is the          |
|                  NEW state of the button since the activity on the           |
|                  button.  It can also be BTNST_GRAYED, but you won't get     |
|                  any activity messages while it's grayed, unless it is a     |
|                  cutsom button.                                              |
|                                                                              |
|            Call  toolbarFullStateFromButton(hwnd, buttonID)                  |
|                                                                              |
|                  to get more detail about the state.  It can also return     |
|                  BTNST_FULLDOWN as well as the above states. In the case     |
|                  of BTNST_FULLDOWN, you'll have to call                      |
|                  toolbarPrevStateFromButton(hwnd, btn ID) to get the state   |
|                  before it went full down.                                   |
|                                                                              |
|                  toolbarPrevStateFromButton(hwnd, buttonID)                  |
|                                                                              |
|                  is only valid when the state is BTNST_FULLDOWN.             |
|                                                                              |
|                  toolbarActivityFromIndex(hwnd, buttonID)                    |
|                                                                              |
|                  tells you what just happened to the button.                 |
|                  BTNACT_KEYDOWN, BTNACT_MOUSEUP, etc. are possibilities.     |
|                  BTNACT_MOUSEMOUSEOFF means that they pressed it down and    |
|                  moved the mouse off of the button (  so it was re- drawn    |
|                  in its previous state before being pressed).                |
|                  BTNACT_MOUSEMOUSEON  means that the above happened and      |
|                  then the mouse moved back on top of the button again, so    |
|                  the button was re-drawn as if it was pushed again.          |
|                                                                              |
|                  For any of the above activities.......                      |
|                                                                              |
|  HIWORD & BTN_SHIFT     is set if this activity involves the right mouse     |
|                         button, or else it is clear.                         |
|  HIWORD & BTN_DBLCLICK  is set means that this mouse button down activity    |
|                         is really a double click (if you care).              |
|                                                                              |
|          If you are a custom button, you can also receive this message...    |
|                                                                              |
|  HIWORD & BTN_REPEAT    is set means that the button or key is being held    |
|                         down, and you are being sent many down messages      |
|                         in a row.  The first such message is sent with       |
|                         this flag clear, all others have this flag set.      |
|                         If you are a custom button, you will have to         |
|                         ignore messages that are repeats if you don't        |
|                         want to get many down messages in a row.             |
|                                                                              |
|                                                                              |
|                   toolbarStringFromIndex(hwnd, index)                        |
|                                                                              |
|                   will return you the string resource ID you gave when       |
|                   you registered this button.                                |
|                                                                              |
|                                                                              |
| IMPORTANT !!!!!!!!!!!!!!!!!!!                                                |
| =============================                                                |
|                                                                              |
| When you get the state of a button, it's already been changed by the         |
| activity so it's the NEW STATE!!!!!!!!!                                      |
|                                                                              |
|  EXCEPT!!!   for a custom button!  For a custom button, NOTHING WILL         |
|  happen, you have to do it all yourself!!!! So the state is going to be      |
|  the state BEFORE the activity and you have to call                          |
|  toolbarModifyState(hwnd, buttonID, newState) to change the state            |
|  yourself!!!!                                                                |
|                                                                              |
|  You also have toolbarGetNumButtons(hwnd) to tell you how many are on the    |
|  the toolbar.                                                                |
|  And... you have other routines you can use if you really want.              |
|                                                                              |
|  ENJOY!!                                                                     |
|                                                                              |
| P.S.  Don't forget to pass on WM_SYSCOLORCHANGE msgs to each toolbar.        |
|                                                                              |
|                                                                              |
| (C) Copyright Microsoft Corporation 1992.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
| Created by Danny Miller, based on David Maymudes' code                       |
|           which was based on Todd Laney's SBUTTON code                       |
|           and stuff from Eric Ledoux.  Did I miss any-                       |
|           body?                                                              |
|    Oct-1992 Laurie Griffiths converted it to 32/16 bit                       |
|             common code.  Mike Tricker reviewed it.                          |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include "ctrls.h"

#define TOOLGROW        8                // power of 2

#define IDC_TOOLBAR   189                // wParam sent to Parent

/* We keep an array of these around (one for each button on the toolbar) */

typedef struct {
        RECT       rc;             // draw it at this postion in the toolbar
        int        iButton;        // it's this button
        int        iState;         // in this state
        int        iPrevState;     // for non-push buttons - last state
        int        iType;          // type of button
        int        iActivity;      // what just happened to button
        int        iString;        // string resource associated with button
} TOOLBUTTON, FAR *LPTOOLBUTTON;

HWND CreateStaticStatusWindow(HWND hwndParent,BOOL fSizeGrip);
BOOL WriteStatusMessage(HWND hwnd, LPTSTR szMsg);
BOOL GetStatusTextExtent(HWND hwnd, LPSIZE pTextExtent);

/* We keep an array of these around (one for each button on the toolbar) */

BOOL FAR PASCAL toolbarInit(void);
HWND FAR PASCAL toolbarCreateMain(HWND hwndParent);
HWND FAR PASCAL toolbarCreateMark(HWND hwndParent);
HWND FAR PASCAL toolbarCreateArrows(HWND hwndParent);
BOOL FAR PASCAL toolbarStateFromButton(HWND hwnd, int iButton, int tbIndex);
BOOL FAR PASCAL toolbarAddTool(HWND hwnd, int iButton, int tbIndex, int iState);
BOOL FAR PASCAL toolbarSwapTools(HWND hwnd, int iButton, int jButton, int tbIndex);
BOOL FAR PASCAL toolbarRemoveTool(HWND hwnd, int iButton, int tbIndex);
BOOL FAR PASCAL toolbarModifyState(HWND hwnd, int iButton, int tbIndex, int iState);
BOOL FAR PASCAL toolbarSetFocus(HWND hwnd, int iButton);


HBITMAP FAR PASCAL  LoadUIBitmap(
    HANDLE      hInstance,          // EXE file to load resource from
    LPCTSTR     szName,             // name of bitmap resource
    COLORREF    rgbText,            // color to use for "Button Text"
    COLORREF    rgbFace,            // color to use for "Button Face"
    COLORREF    rgbShadow,          // color to use for "Button Shadow"
    COLORREF    rgbHighlight,       // color to use for "Button Hilight"
    COLORREF    rgbWindow,          // color to use for "Window Color"
    COLORREF    rgbFrame);          // color to use for "Window Frame"

/* In a bitmap file, each button is the same size, and contains
 * the picture of a button.  Each column contains the picture of a distinct
 * button (e.g. BTN_REWIND, BTN_REVERSE, etc.) and each row contains
 * a specific button state (BTNST_UP, BTNST_DOWN,
 * BTNBAR_GRAYED, etc. just as an example).
 *
 */

#define TB_FIRST            -1
#define TB_LAST             -2

#define BTN_PLAY            0
#define BTN_PAUSE           1
#define BTN_STOP            2
#define BTN_EJECT           3
#define BTN_HOME            4
#define BTN_RWD             5
#define BTN_FWD             6
#define BTN_END             7

#define ARROW_PREV          0
#define ARROW_NEXT          1

#define BTN_MARKIN          0
#define BTN_MARKOUT         1

#define BTNST_GRAYED        0
#define BTNST_UP            1
#define BTNST_DOWN          2
#define BTNST_FOCUSUP       3
#define BTNST_FOCUSDOWN     4
#define BTNST_FULLDOWN      5

#define BTN_REPEAT          0x100        // add this to button index
#define BTN_SHIFT           0x200
#define BTN_DBLCLICK        0x400


/* constants */
#define MSEC_BUTTONREPEAT   200        // milliseconds for auto-repeat

/* timers */
#define TIMER_BUTTONREPEAT  1        // timer for button auto-repeat

/* bitmap resources */
#define IDBMP_TOOLBAR       100        // main toolbar
#define IDBMP_ARROWS        101        // arrows for scrollbar
#define IDBMP_MARK          102        // arrows for scrollbar
                                        // 103 and 104 used by track.h

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\track.c ===
/*-----------------------------------------------------------------------------+
| TRACK.C                                                                      |
|                                                                              |
| Contains the code which implements the track bar                             |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <windowsx.h>
#include "mplayer.h"
#include "toolbar.h"
#include "tracki.h"


WNDPROC fnTrackbarWndProc = NULL;


/* TB_OnKey
 *
 * Handles WM_KEYDOWN and WM_KEYUP messages.
 *
 * If the shift key is pressed while we're playing or scrolling
 * treat it as a start selection.  End the selection on the key-up
 * message.
 *
 * Clear any selection if the escape key is pressed.
 *
 */
void TB_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
{
    int cmd = -1;

    switch(vk)
    {
    case VK_SHIFT:
        /* Check that the key wasn't already down:
         */
        if (fDown && !(flags & 0x4000))
        {
            if(((gwStatus == MCI_MODE_PLAY) || gfScrollTrack)
             &&(toolbarStateFromButton(ghwndMark, BTN_MARKIN, TBINDEX_MARK)
                                                       != BTNST_GRAYED))
                SendMessage(hwnd, WM_COMMAND, IDT_MARKIN, 0);
        }

        /* If !fDown, it must be fUp:
         */
        else if (!fDown)
        {
            if (SendMessage(ghwndTrackbar, TBM_GETSELSTART, 0, 0) != -1)
                SendMessage(hwnd, WM_COMMAND, IDT_MARKOUT, 0);
        }
        break;

    case VK_ESCAPE:
        SendMessage(ghwndTrackbar, TBM_CLEARSEL, (WPARAM)TRUE, 0);
        break;

    default:
        if (fDown)
        {
//          Don't do this, because the common-control trackbar sends us
//          WM_HSCROLL in response to this, which causes us to increment twice:
//          FORWARD_WM_KEYDOWN(hwnd, vk, cRepeat, flags, fnTrackbarWndProc);

            switch (vk)
            {
            case VK_HOME:
                cmd = TB_TOP;
                break;

            case VK_END:
                cmd = TB_BOTTOM;
                break;

            case VK_PRIOR:
                cmd = TB_PAGEUP;
                break;

            case VK_NEXT:
                cmd = TB_PAGEDOWN;
                break;

            case VK_LEFT:
            case VK_UP:
                cmd = TB_LINEUP;
                break;

            case VK_RIGHT:
            case VK_DOWN:
                cmd = TB_LINEDOWN;
                break;

            default:
                break;
            }
        }
        else
        {
            FORWARD_WM_KEYUP(hwnd, vk, cRepeat, flags, fnTrackbarWndProc);
            return;
        }

        if (cmd != -1)
            SendMessage(GetParent(hwnd), WM_HSCROLL, MAKELONG(cmd, 0), (LPARAM)hwnd);
    }
}



/* Subclass the window so that we can handle the key presses
 * we're interested in.
 */


/* TBWndProc() */


LONG_PTR FAR PASCAL
SubClassedTrackbarWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        HANDLE_MSG(hwnd, WM_KEYDOWN, TB_OnKey);
        HANDLE_MSG(hwnd, WM_KEYUP,   TB_OnKey);

    /* HACK ALERT
     *
     * This is to get around a bug in the Chicago common control trackbar,
     * which is sending too many TB_ENDTRACK notifications.
     * It sends one when it receives WM_CAPTURECHANGED, even if it called
     * ReleaseCapture itself.
     * So, if we're not currently scrolling, ignore it.
     */
    case WM_CAPTURECHANGED:
        if (!gfScrollTrack)
            return 0;

    case TBM_SHOWTICS:
        /* If we're hiding the ticks, we want a chiseled thumb,
         * so make it TBS_BOTH as well as TBS_NOTICKS.
         */
        if (wParam == TRUE)
            SetWindowLongPtr(hwnd, GWL_STYLE,
                          (GetWindowLongPtr(hwnd, GWL_STYLE) & ~(TBS_NOTICKS | TBS_BOTH)));
        else
            SetWindowLongPtr(hwnd, GWL_STYLE,
                          (GetWindowLongPtr(hwnd, GWL_STYLE) | TBS_NOTICKS | TBS_BOTH));

        if (lParam == TRUE)
            InvalidateRect(hwnd, NULL, TRUE);

        return 0;

    }

    return CallWindowProc(fnTrackbarWndProc, hwnd, message, wParam, lParam);
}


void SubClassTrackbarWindow()
{
    if (!fnTrackbarWndProc)
        fnTrackbarWndProc = (WNDPROC)GetWindowLongPtr(ghwndTrackbar, GWLP_WNDPROC);
    if (ghwndTrackbar)
        SetWindowLongPtr(ghwndTrackbar, GWLP_WNDPROC, (LONG_PTR)SubClassedTrackbarWndProc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\tracki.h ===
/*-----------------------------------------------------------------------------+
| TRACKI.H                                                                     |
|                                                                              |
| Contains all the useful information for a trackbar.                          |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include "track.h"

static TCHAR szSTrackBarClass[] = TRACKBAR_CLASS;

typedef struct {
        HWND    hwnd;           // our window handle
        HDC     hdc;            // current DC

        LONG    lLogMin;        // Logical minimum
        LONG    lLogMax;        // Logical maximum
        LONG    lLogPos;        // Logical position

        LONG    lSelStart;      // Logical selection start
        LONG    lSelEnd;        // Logical selection end

        LONG    lTrackStart;    // Logical track start

        UINT    wThumbWidth;    // Width of the thumb
        UINT    wThumbHeight;   // Height of the thumb

        int     iSizePhys;      // Size of where thumb lives
        RECT    rc;             // track bar rect.

        RECT    Thumb;          // Rectangle we current thumb
        DWORD   dwDragPos;      // Logical position of mouse while dragging.

        UINT    Flags;          // Flags for our window
        int     Timer;          // Our timer.
        UINT    Cmd;            // The command we're repeating.

        int     nTics;          // number of ticks.
        PDWORD  pTics;          // the tick marks.

} TrackBar, *PTrackBar;

// Trackbar flags

#define TBF_NOTHUMB     0x0001  // No thumb because not wide enough.

/*
    useful constants.
*/

#define REPEATTIME      500     // mouse auto repeat 1/2 of a second
#define TIMER_ID        1

#define GWW_TRACKMEM        0               /* handle to track bar memory */
#define EXTRA_TB_BYTES      sizeof(HLOCAL)  /* Total extra bytes.   */

/*
    Useful defines.
*/

/* We allocate enough window words to store a pointer (not a handle), so the
   definition of EXTRA_TB_BYTES is slightly bad style.  Sorry.  On creation
   we allocate space for the TrackBar struct.  On destruction we free it.
   In between we just retrieve the pointer.
*/
#define CREATETRACKBAR(hwnd) SetWindowLongPtr( hwnd                                 \
                                             , GWW_TRACKMEM                         \
                                             , AllocMem(sizeof(TrackBar))           \
                                             )
#define DESTROYTRACKBAR(hwnd)   FreeMem( (LPVOID)GetWindowLongPtr(hwnd, GWW_TRACKMEM), \
                                         sizeof(TrackBar) )

#define GETTRACKBAR(hwnd)       (PTrackBar)GetWindowLongPtr(hwnd,GWW_TRACKMEM)

/*
    Function Prototypes
*/

void   FAR PASCAL DoTrack(PTrackBar, int, DWORD);
UINT   FAR PASCAL WTrackType(PTrackBar, LONG);
void   FAR PASCAL TBTrackInit(PTrackBar, LONG);
void   FAR PASCAL TBTrackEnd(PTrackBar, LONG);
void   FAR PASCAL TBTrack(PTrackBar, LONG);
void   FAR PASCAL DrawThumb(PTrackBar);
HBRUSH FAR PASCAL SelectColorObjects(PTrackBar, BOOL);
void   FAR PASCAL SetTBCaretPos(PTrackBar);

extern DWORD FAR PASCAL muldiv32(long, long, long);

/* objects from sbutton.c */

extern HBRUSH hbrButtonFace;
extern HBRUSH hbrButtonShadow;
extern HBRUSH hbrButtonText;
extern HBRUSH hbrButtonHighLight;
extern HBRUSH hbrWindowFrame; //???

extern HBITMAP FAR PASCAL  LoadUIBitmap(
    HANDLE      hInstance,          // EXE file to load resource from
    LPCTSTR     szName,             // name of bitmap resource
    COLORREF    rgbText,            // color to use for "Button Text"
    COLORREF    rgbFace,            // color to use for "Button Face"
    COLORREF    rgbShadow,          // color to use for "Button Shadow"
    COLORREF    rgbHighlight,       // color to use for "Button Hilight"
    COLORREF    rgbWindow,          // color to use for "Window Color"
    COLORREF    rgbFrame);          // color to use for "Window Frame"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\trackmap.c ===
/*-----------------------------------------------------------------------------+
| TRACKMAP.C                                                                   |
|                                                                              |
| This file contains the code that implements the "MPlayerTrackMap" control.   |
| The control displays the list of tracks contained in the current medium, or  |
| a time scale appropriate to the length of the medium, in such a way as to    |
| serve as a scale for the scrollbar.                                          |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/

/* include files */

#include <windows.h>
#include <mmsystem.h>
#include "mplayer.h"
#include "toolbar.h"

typedef struct tagScale {
    DWORD   dwInterval;
    UINT    wScale;
} SCALE;

STATICDT SCALE aScale[] =
{
    { 1, SCALE_SECONDS },
    { 2, SCALE_SECONDS },
    { 5, SCALE_SECONDS },
    { 10, SCALE_SECONDS },
    { 25, SCALE_SECONDS },
    { 50, SCALE_SECONDS },
    { 100, SCALE_SECONDS },
    { 250, SCALE_SECONDS },
    { 500, SCALE_SECONDS },
    { 1000, SCALE_SECONDS },
    { 2000, SCALE_SECONDS },
    { 5000, SCALE_SECONDS },
    { 10000, SCALE_SECONDS },
    { 15000, SCALE_MINUTES },
    { 30000, SCALE_MINUTES },
    { 60000, SCALE_MINUTES },
    { 120000, SCALE_MINUTES },
    { 300000, SCALE_MINUTES },
    { 600000, SCALE_HOURS },
    { 1800000, SCALE_HOURS },
    { 3600000, SCALE_HOURS },
    { 7200000, SCALE_HOURS },
    { 18000000, SCALE_HOURS },
    { 36000000, SCALE_HOURS },
    { 72000000, SCALE_HOURS }
};

STATICDT SZCODE   aszNULL[] = TEXT("");
STATICDT SZCODE   aszOneDigit[] = TEXT("0");
STATICDT SZCODE   aszTwoDigits[] = TEXT("00");
STATICDT SZCODE   aszPositionFormat[] = TEXT("%0d");
STATICDT SZCODE   aszMSecFormat[] = TEXT("%d");
STATICDT SZCODE   aszHourFormat[] = TEXT("%d%c");
STATICDT SZCODE   aszMinuteFormat[] = TEXT("%d%c");
STATICDT SZCODE   aszSecondFormat[] = TEXT("%d%c");
STATICDT SZCODE   aszSecondFormatNoLzero[] = TEXT("%c");
STATICDT SZCODE   aszDecimalFormat[] = TEXT("%02d");
/*
 * fnMPlayerTrackMap()
 *
 * This is the window procedure for windows of class "MPlayerTrackMap".
 * This window shows the position of the start of each track of the
 * current medium or a time scale, displayed above the scrollbar which shows
 * the current play position within the medium.
 *
 */

void FAR PASCAL CalcTicsOfDoom(void);

extern UINT gwCurScale;  /* The current scale in which to draw the track map*/
extern BOOL gfCurrentCDNotAudio;/* TRUE when we have a CD that we can't play */

LRESULT FAR PASCAL fnMPlayerTrackMap(

HWND     hwnd,                 /*handle to a MPlayerTrackMap window*/
UINT     wMsg,                 /* message number                   */
WPARAM   wParam,               /* message-dependent parameter      */
LPARAM   lParam)               /* message-dependent parameter      */

{
    PAINTSTRUCT    ps;            /* paint structure for the window   */
    RECT           rc, rcSB;      /* dimensions of the windows        */
    POINT          ptExtent;      /* extent of the track marks        */
    TCHAR          szLabel[20];   /* string holding the current label */
    TCHAR          szLabel2[20];  /* string holding the current label */
    UINT           wNumTics,
                   wTicNo,
                   wTemp,
                   wHour,
                   wMin,
                   wSec,
                   wMsec;
    int            iOldPosition = -1000;
    int            iNewPosition;
    UINT           wScale;
    DWORD          dwMarkValue;
    int            iLargeMarkSize, iFit, iLastPos, iLen;
    BOOL           fForceTextDraw = FALSE;
    HBRUSH         hbr;

    switch (wMsg) {

        case WM_PAINT:

            BeginPaint(hwnd, &ps);

            GetClientRect(ghwndTrackbar, &rcSB);
            GetClientRect(hwnd, &rc);

            /* Set background and text colours */

            (VOID)SendMessage(ghwndApp, WM_CTLCOLORSTATIC,
                              (WPARAM)ps.hdc, (LONG_PTR)hwnd);

            /* Get the length of the scrollbar we're putting tics under */
            /* Use these numbers for size and position calculations     */
            GetClientRect(ghwndMap, &rc);

            /*
             * Check to see if we actually have a valid device loaded up;
             * if not, don't display anything
             *
             */

            if (gwDeviceID == 0
                    || gwStatus == MCI_MODE_OPEN
                    || gwStatus == MCI_MODE_NOT_READY || gdwMediaLength == 0
                    || !gfValidMediaInfo
                    || gfCurrentCDNotAudio) {
                EndPaint(hwnd,&ps);
                //VIJR-SBSetWindowText(ghwndStatic, aszNULL);
                WriteStatusMessage(ghwndStatic, (LPTSTR)aszNULL);
                return 0L;
            }

            /* Select the font to use */

            if (ghfontMap != NULL)
                SelectObject(ps.hdc, ghfontMap);

            /*
             * Because the scrollbar thumb takes up space in the inner part
             * of the scrollbar, compute its width so that we can compensate
             * for it while displaying the trackmap.
             *
             */

            /*
             * Get the child window rectangle and reduce it such that
             * it is the same width as the inner part of the scrollbar.
             *
             */
            //rc.left;  //!!! GetSystemMetrics(SM_CXHSCROLL);
            //rc.right; //!!!(GetSystemMetrics(SM_CXHSCROLL));

            /* Now, Put text underneath the TICS */
            if (gwCurScale == ID_TRACKS) {

                SIZE Size;

                GetTextExtentPoint32( ps.hdc, aszTwoDigits, 2, &Size );

                ptExtent.x = Size.cx;
                ptExtent.y = Size.cy;

                /*
                 * Based on the width of the child window, compute the positions
                 * to place the track markers.
                 *
                 */

                wNumTics = (UINT)SendMessage(ghwndTrackbar, TBM_GETNUMTICS, 0, 0L);

                /*
                 * TBM_GETNUMTICS returns the number of visible tics
                 * which includes the first and last tics not created
                 * by media player.  Subtract 2 to account for the
                 * the first and last tics.
                 *
                 */

                if (wNumTics >= 2)
                    wNumTics = wNumTics - 2;

                for(wTicNo = 0; wTicNo < wNumTics; wTicNo++) {

                    /* Get the position of the next tic */
                    iNewPosition = (int)SendMessage(ghwndTrackbar, TBM_GETTICPOS,
                                                    (WPARAM)wTicNo, 0L);
                    /* Centre it above the marker. */
                    iNewPosition -= ptExtent.x / 4;

                    /*
                     * Check to make sure that we are not overwriting the
                     * text from the previous marker.
                     *
                     */

                    if (iNewPosition > iOldPosition) {

                        wsprintf(szLabel, aszPositionFormat, wTicNo + gwFirstTrack);
                        TextOut(ps.hdc,
                                iNewPosition + rc.left,
                                0, szLabel,
                                (wTicNo + gwFirstTrack < 10) ? 1 : 2 );
                        /* Finish the end of the text string we just printed */
                        iOldPosition = iNewPosition +
                                       ((wTicNo + gwFirstTrack < 10)
                                       ? ptExtent.x / 2 : ptExtent.x);
                    }
                }
            } else {

                #define ONE_HOUR    (60ul*60ul*1000ul)
                #define ONE_MINUTE  (60ul*1000ul)
                #define ONE_SECOND  (1000ul)

                /*
                 * The scale is set to display time - find out what units
                 * (msec, sec, min, or hour) are most appropriate, for the
                 * scale. This requires us to look at both the overall length
                 * of the medium and the distance between markers (or
                 * granularity).
                 *
                 */

                /*
                 * Find the maximum number of markers that we can draw without
                 * cluttering the display too badly, and find the granularity
                 * between these markers.
                 *
                 */

                SIZE Size;

                GetTextExtentPoint32( ps.hdc, aszOneDigit, 1, &Size );

                ptExtent.x = Size.cx;
                ptExtent.y = Size.cy;

                if (gdwMediaLength < 10)
                    iLargeMarkSize = 1;
                else if (gdwMediaLength < 100)
                    iLargeMarkSize = 2;
                else if (gdwMediaLength < 1000)
                    iLargeMarkSize = 3;
                else if (gdwMediaLength < 10000)
                    iLargeMarkSize = 4;
                else
                    iLargeMarkSize = 5;

                wNumTics = (UINT)SendMessage(ghwndTrackbar, TBM_GETNUMTICS,
								0, 0L);

                /*
                 * TBM_GETNUMTICS returns the number of visible tics
                 * which includes the first and last tics not created
                 * by media player.  Subtract 2 to account for the
                 * the first and last tics.
                 *
                 */

                if (wNumTics >= 2)
                    wNumTics = wNumTics - 2;

                /* Where the text for the last mark will begin */
		if (wNumTics > 1) {
                    iLastPos = (int)SendMessage(ghwndTrackbar,
			TBM_GETTICPOS, (WPARAM)wNumTics - 1, 0L);
                    iLastPos -= ptExtent.x  / 2;    // centre 1st numeral
		}

                /* What scale do we use?  Hours, minutes, or seconds? */
                /* NOTE:  THIS MUST AGREE WITH WHAT FormatTime() does */
                /* in mplayer.c !!!                                   */
                if (gwCurScale == ID_FRAMES)
                    wScale = SCALE_FRAMES;
                else {
                    if (gdwMediaLength > ONE_HOUR)
                        wScale = SCALE_HOURS;
                    else if (gdwMediaLength > ONE_MINUTE)
                        wScale = SCALE_MINUTES;
                    else
                        wScale = SCALE_SECONDS;
                }

                for (wTicNo = 0; wTicNo < wNumTics; wTicNo++) {

                    /* The text for the last tic is always drawn */
                    if (wTicNo == wNumTics - 1)
                        fForceTextDraw = TRUE;

                    dwMarkValue = (DWORD)SendMessage(ghwndTrackbar, TBM_GETTIC,
                                          (WPARAM)wTicNo, 0L);
                    iNewPosition = (int)SendMessage(ghwndTrackbar, TBM_GETTICPOS,
                                                (WPARAM)wTicNo, 0L);


                    /*
                     * Get the text ready for printing and centre it above the
                     * marker.
                     *
                     */

                    switch ( wScale ) {

                        case SCALE_FRAMES:
                        case SCALE_MSEC:
                            wsprintf(szLabel, aszMSecFormat, dwMarkValue);
                            break;

                        case SCALE_HOURS:

                            wHour = (WORD)(dwMarkValue / 3600000);
                            wMin = (WORD)((dwMarkValue % 3600000) / 60000);
                            wsprintf(szLabel2,aszDecimalFormat,wMin);
                            wsprintf(szLabel,aszHourFormat,wHour, chTime);
                            lstrcat(szLabel,szLabel2);
                            break;

                        case SCALE_MINUTES :

                            wMin = (WORD)(dwMarkValue / 60000);
                            wSec = (WORD)((dwMarkValue % 60000) / 1000);
                            wsprintf(szLabel2,aszDecimalFormat,wSec);
                            wsprintf(szLabel,aszMinuteFormat,wMin,chTime);
                            lstrcat(szLabel,szLabel2);
                            break;

                        case SCALE_SECONDS :

                            wSec = (WORD)((dwMarkValue + 5) / 1000);
                            wMsec = (WORD)(((dwMarkValue + 5) % 1000) / 10);
                            wsprintf(szLabel2,aszDecimalFormat,wMsec);
                            if (!wSec && chLzero == TEXT('0'))
                                wsprintf(szLabel, aszSecondFormatNoLzero,  chDecimal);
                            else
                                wsprintf(szLabel, aszSecondFormat, wSec, chDecimal);
                            lstrcat(szLabel,szLabel2);
                            break;

                    }

                    wTemp = STRLEN(szLabel);
                    iNewPosition -= ptExtent.x  / 2;    // centre 1st numeral

                    /* The position after which text will be cut off the */
                    /* right edge of the window                          */
                    iFit = rc.right - rc.left - (ptExtent.x * iLargeMarkSize);

                    /* Calculate the length of the text we just printed. */
                    /* Leave a little space at the end, too.             */
                    iLen = (ptExtent.x * wTemp) + ptExtent.x / 2;

                    /* Display the mark if we can without overlapping either
                     * the previous mark or the final mark or going off the
                     * edge of the window. */
                    if (fForceTextDraw ||
                        (iNewPosition >= iOldPosition &&
                         iNewPosition <= iFit &&
                         iNewPosition + iLen <= iLastPos)) {
                        TextOut(ps.hdc, iNewPosition + rc.left, 0,
                                szLabel, wTemp );
                        /* Calculate the end pos of the text we just printed. */
                        iOldPosition = iNewPosition + iLen;

                    } else {

                        DPF("Didn't display mark: iNew = %d; iOld = %d; iFit = %d; iLen = %d, iLast = %d\n", iNewPosition, iOldPosition, iFit, iLen, iLastPos);
                    }
                }
            }
            EndPaint(hwnd, &ps);
            return 0L;

        case WM_ERASEBKGND:

            GetClientRect(hwnd, &rc);

            hbr = (HBRUSH)SendMessage(ghwndApp, WM_CTLCOLORSTATIC,
                                      wParam, (LONG_PTR)hwnd);

            if (hbr != NULL)
                FillRect((HDC)wParam, &rc, hbr);

            return TRUE;
    }

    /* Let DefWindowProc() process all other window messages */

    return DefWindowProc(hwnd, wMsg, wParam, lParam);

}

/* Gee thanks for the helpful spec for this routine! */

void FAR PASCAL CalcTicsOfDoom(void)
{
    UINT        wMarkNo;
    int         iTableIndex;
    DWORD       dwMarkValue,
                dwNewPosition;
    BOOL        fDidLastMark = FALSE;

    if (gfPlayOnly && !gfOle2IPEditing)
        return;

    DPF2("CalcTicsOfDoom\n");
    SendMessage(ghwndTrackbar, TBM_CLEARTICS, (WPARAM)FALSE, 0L);

    if (gwCurScale == ID_TRACKS) {

        /*
         * Based on the width of the child window, compute the positions
         * to place the track marker tics.
         *
         */

        for (wMarkNo = 0; wMarkNo < gwNumTracks; wMarkNo++) {

            /* If zero length, don't mark it, unless it is the end */
            if ((wMarkNo < gwNumTracks - 1) &&
                (gadwTrackStart[wMarkNo] == gadwTrackStart[wMarkNo + 1]))
                continue;

            /* Compute the centre point and place a marker there */

            if (gdwMediaLength == 0)
                dwNewPosition = 0;
            else
                dwNewPosition = gadwTrackStart[wMarkNo];

            SendMessage(ghwndTrackbar,
                        TBM_SETTIC,
                        (WPARAM)FALSE,
                        (LPARAM)dwNewPosition);

        }
    } else {

        /*
         * The scale is set to display time - find out what units
         * (msec, sec, min, or hour) are most appropriate, for the
         * scale. This requires us to look at both the overall length
         * of the medium and the distance between markers (or
         * granularity).
         *
         */

        /*
         * Find the maximum number of markers that we can draw without
         * cluttering the display too badly, and find the granularity
         * between these markers.
         *
         */

        UINT    wNumTicks;
        RECT    rc;

        if(!GetClientRect(ghwndMap, &rc)) {
            DPF0("GetClientRect failed in CalcTicsOfDoom: Error %d\n", GetLastError());
        }

        wNumTicks = rc.right / 60;

        if (0 == gdwMediaLength) {
            iTableIndex = 0;
        } else {

            DPF4("Checking the scale for media length = %d, tick count = %d\n", gdwMediaLength, wNumTicks);

            for (iTableIndex = (sizeof(aScale) / sizeof(SCALE)) -1;
                (int)iTableIndex >= 0;
                iTableIndex--) {

                DPF4("Index %02d: %d\n", aScale[iTableIndex].dwInterval * wNumTicks);

                if ((aScale[iTableIndex].dwInterval * wNumTicks)
                    <= gdwMediaLength)
                    break;
            }
        }
#ifdef DEBUG
        if ((int)iTableIndex == -1) {
            DPF("BAD TABLEINDEX\n");
            DebugBreak();
        }
#endif
        // We have enough room to show every tick.  Don't let our index wrap
        // around, or we won't see ANY ticks which would look odd.
        if (iTableIndex <0)
            iTableIndex = 0;

        dwMarkValue = gdwMediaStart;

        do {

            /* Compute the centre point and place a marker there */

            if (gdwMediaLength == 0)
                dwNewPosition = 0;
            else
                dwNewPosition = dwMarkValue; // HACK!! - gdwMediaStart;

            SendMessage(ghwndTrackbar,
                        TBM_SETTIC,
                        (WPARAM)FALSE,
                        (LPARAM)dwNewPosition);

            /* If this is the first mark, adjust so it's going
            /* by the right interval. */
            if (dwMarkValue == gdwMediaStart) {
                dwMarkValue += aScale[iTableIndex].dwInterval
                - (dwMarkValue % aScale[iTableIndex].dwInterval);
            } else {
                dwMarkValue += aScale[iTableIndex].dwInterval;
            }

            /* If we're almost done, do the final mark. */
            if ((dwMarkValue >= (gdwMediaLength + gdwMediaStart))
                && !(fDidLastMark)) {
                fDidLastMark = TRUE;
                dwMarkValue = gdwMediaLength + gdwMediaStart;
            }
        } while (dwMarkValue <= gdwMediaStart + gdwMediaLength);
    }

    InvalidateRect(ghwndTrackbar, NULL, FALSE);
    InvalidateRect(ghwndMap, NULL, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\track.h ===
/*-----------------------------------------------------------------------------+
| TRACK.H                                                                      |
|                                                                              |
| Contains the code which implements the track bar                             |
|                                                                              |
| (C) Copyright Microsoft Corporation 1991.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    Oct-1992 MikeTri Ported to WIN32 / WIN16 common code                      |
|                                                                              |
+-----------------------------------------------------------------------------*/
/*
    The trackbar messages:

    message         wParam  lParam  return

    TBM_GETPOS      ------  ------  Current logical position of trackbar.
    TBM_GETRANGEMIN ------  ------  Current logical minimum position allowed.
    TBM_GETRANGEMAX ------  ------  Current logical maximum position allowed.
    TBM_SETTIC
    TBM_SETPOS
    TBM_SETRANGEMIN
    TBM_SETRANGEMAX
*/

#ifdef  TRACKBAR_CLASS
#undef  TRACKBAR_CLASS
#endif
#define TRACKBAR_CLASS          TEXT("STrackBar")
BOOL   FAR  PASCAL TrackInit(HANDLE, HANDLE);
void   FAR  PASCAL TrackTerm(void);
LONG   FAR  PASCAL TrackGetLogThumbWidth(HWND hwnd);

/* Track bar styles */
#define TBS_TICS                0x8000L

#define TBM_GETPOS              (WM_USER)
#define TBM_GETRANGEMIN         (WM_USER+1)
#define TBM_GETRANGEMAX         (WM_USER+2)
#define TBM_GETTIC              (WM_USER+3)
#define TBM_SETTIC              (WM_USER+4)
#define TBM_SETPOS              (WM_USER+5)
#define TBM_SETRANGE            (WM_USER+6)
#define TBM_SETRANGEMIN         (WM_USER+7)
#define TBM_SETRANGEMAX         (WM_USER+8)
#define TBM_CLEARTICS           (WM_USER+9)
#define TBM_SETSEL              (WM_USER+10)
#define TBM_SETSELSTART         (WM_USER+11)
#define TBM_SETSELEND           (WM_USER+12)
#define TBM_SETTICTOK           (WM_USER+13)
#define TBM_GETPTICS            (WM_USER+14)
#define TBM_GETTICPOS           (WM_USER+15)
#define TBM_GETNUMTICS          (WM_USER+16)
#define TBM_GETSELSTART         (WM_USER+17)
#define TBM_GETSELEND           (WM_USER+18)
#define TBM_CLEARSEL            (WM_USER+19)
#define TBM_SHOWTICS            (WM_USER+30)

#define TB_LINEUP               0
#define TB_LINEDOWN             1
#define TB_PAGEUP               2
#define TB_PAGEDOWN             3
#define TB_THUMBPOSITION        4
#define TB_THUMBTRACK           5
#define TB_TOP                  6
#define TB_BOTTOM               7
#define TB_ENDTRACK             8
#define TB_STARTTRACK           9

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\unicode.c ===
#include <windows.h>
#include <stdlib.h>

#include "mplayer.h"
#include "unicode.h"

/* AnsiToUnicodeString
 *
 * Parameters:
 *
 *     pAnsi - A valid source ANSI string.
 *
 *     pUnicode - A pointer to a buffer large enough to accommodate
 *         the converted string.
 *
 *     StringLength - The length of the source ANSI string
 *         excluding the null terminator.  This value may be
 *         UNKNOWN_LENGTH (-1).
 *
 *
 * Return:
 *
 *     The return value from MultiByteToWideChar, the number of
 *         wide characters returned.
 *
 *
 * andrewbe, 11 Jan 1993
 *
 * andrewbe, 01 Feb 1994: Added support for in-place conversion
 */
INT AnsiToUnicodeString( LPCSTR pAnsi, LPWSTR pUnicode, INT StringLength )
{
#ifdef IN_PLACE
    /* #def'ed out, 'cos it turned out I didn't need it.
     * It might be useful sometime, however.
     * BUT NOTE: COMPLETELY UNTESTED
     */
    LPWSTR pTemp
    LPWSTR pSave;
#endif
    INT    rc;

    if( !pAnsi )
    {
        DPF( "NULL pointer passed to AnsiToUnicodeString\n" );
        return 0;
    }

    if( StringLength == UNKNOWN_LENGTH )
        StringLength = strlen( pAnsi );

#ifdef IN_PLACE
    /* Allow in-place conversion.  We assume that the buffer is big enough.
     * MultiByteToWideChar doesn't support this.
     */
    if( pAnsi == (LPCSTR)pUnicode )
    {
        pTemp = AllocMem( StringLength * sizeof( WCHAR ) + sizeof( WCHAR ) );

        if( !pTemp )
            return 0;

        pSave = pUnicode;
        pUnicode = pTemp;
    }
#endif

    rc = MultiByteToWideChar( CP_ACP,
                              MB_PRECOMPOSED,
                              pAnsi,
                              StringLength + 1,
                              pUnicode,
                              StringLength + 1 );

#ifdef IN_PLACE
    if( pAnsi == (LPCSTR)pUnicode )
    {
        pTemp = pUnicode;
        pUnicode = pSave;

        lstrcpyW( pUnicode, pTemp );

        FreeMem( pTemp, StringLength * sizeof( WCHAR ) + sizeof( WCHAR ) );
    }
#endif

    return rc;
}


/* AllocateUnicodeString
 *
 * Parameter:
 *
 *     pAnsi - A valid source ANSI string.
 *
 * Return:
 *
 *     A Unicode copy of the supplied ANSI string.
 *     NULL if pAnsi is NULL or the allocation or conversion fails.
 *
 * andrewbe, 27 Jan 1994
 */
LPWSTR AllocateUnicodeString( LPCSTR pAnsi )
{
    LPWSTR pUnicode;
    INT    Length;

    if( !pAnsi )
    {
        DPF( "NULL pointer passed to AllocateUnicodeString\n" );
        return NULL;
    }

    Length = strlen( pAnsi );

    pUnicode = AllocMem( Length * sizeof( WCHAR ) + sizeof( WCHAR ) );

    if( pUnicode )
    {
        if( 0 == AnsiToUnicodeString( pAnsi, pUnicode, Length ) )
        {
            FreeMem( pUnicode, Length * sizeof( WCHAR ) + sizeof( WCHAR )  );
            pUnicode = NULL;
        }
    }

    return pUnicode;
}


/* FreeUnicodeString
 *
 * Parameter:
 *
 *     pString - A valid source Unicode string.
 *
 * Return:
 *
 *     TRUE if the string was successfully freed, FALSE otherwise.
 *
 * andrewbe, 27 Jan 1994
 */
VOID FreeUnicodeString( LPWSTR pString )
{
    if( !pString )
    {
        DPF( "NULL pointer passed to FreeUnicodeString\n" );
        return;
    }

    FreeMem( pString, wcslen( pString ) * sizeof( WCHAR ) + sizeof( WCHAR )  );
}



/* UnicodeStringToNumber
 *
 * Parameter:
 *
 *     pString - A valid source Unicode string.
 *
 * Return:
 *
 *     The integer value represented by the string.
 *
 * andrewbe, 27 Jan 1994
 */
#define BUF_LEN 265
int UnicodeStringToNumber( LPCWSTR pString )
{
    CHAR strAnsi[BUF_LEN];

#ifdef DEBUG
    if( ( wcslen( pString ) + 1 ) > BUF_LEN )
    {
        DPF( "Buffer cannot accommodate string passed to UnicodeStringToNumber\n" );
    }
#endif

    WideCharToMultiByte( CP_ACP, 0, pString, -1, strAnsi,
                         sizeof strAnsi, NULL, NULL );

    return atoi( strAnsi );
}


#ifndef UNICODE


/* UnicodeToAnsiString
 *
 * Parameters:
 *
 *     pUnicode - A valid source Unicode string.
 *
 *     pANSI - A pointer to a buffer large enough to accommodate
 *         the converted string.
 *
 *     StringLength - The length of the source Unicode string.
 *         If 0 (NULL_TERMINATED), the string is assumed to be
 *         null-terminated.
 *
 * Return:
 *
 *     The return value from WideCharToMultiByte, the number of
 *         multi-byte characters returned.
 *
 *
 * andrewbe, 11 Jan 1993
 */
INT UnicodeToAnsiString( LPCWSTR pUnicode, LPSTR pAnsi, INT StringLength )
{
    INT   rc = 0;

    if( StringLength == UNKNOWN_LENGTH )
        StringLength = wcslen( pUnicode );

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength + 1,
                                  pAnsi,
                                  StringLength + 1,
                                  NULL,
                                  NULL );
    }

    return rc;

}


/* AllocateAnsiString
 *
 * Parameter:
 *
 *     pAnsi - A valid source Unicode string.
 *
 * Return:
 *
 *     An ANSI copy of the supplied Unicode string.
 *     NULL if pUnicode is NULL or the allocation or conversion fails.
 *
 * andrewbe, 27 Jan 1994
 */
LPSTR AllocateAnsiString( LPCWSTR pUnicode )
{
    LPSTR pAnsi;
    INT   Length;

    if( !pUnicode )
    {
        DPF( "NULL pointer passed to AllocateUnicodeString\n" );
        return NULL;
    }

    Length = wcslen( pUnicode );

    pAnsi = AllocMem( Length * sizeof( CHAR ) + sizeof( CHAR ) );

    if( pAnsi )
    {
        if( 0 == UnicodeToAnsiString( pUnicode, pAnsi, Length ) )
        {
            FreeMem( pAnsi, Length * sizeof( CHAR ) + sizeof( CHAR )  );
            pAnsi = NULL;
        }
    }

    return pAnsi;
}


/* FreeUnicodeString
 *
 * Parameter:
 *
 *     pString - A valid source Unicode string.
 *
 * Return:
 *
 *     TRUE if the string was successfully freed, FALSE otherwise.
 *
 * andrewbe, 27 Jan 1994
 */
VOID FreeAnsiString( LPSTR pString )
{
    if( !pString )
    {
        DPF( "NULL pointer passed to FreeAnsiString\n" );
        return;
    }

    FreeMem( pString, strlen( pString ) * sizeof( CHAR ) + sizeof( CHAR ) );
}

#endif /* NOT UNICODE */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\utils.h ===
LPTSTR AllocString( LPTSTR pstr );
BOOL FreeString( LPTSTR pstr );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mplayer2\unicode.h ===
#ifdef UNICODE

#define ATOI( pString ) UnicodeStringToNumber( pString )
#define ATOL( pString ) (LONG)UnicodeStringToNumber( pString )
#define STRCHR( pString, Char ) wcschr( pString, Char )
#define STRRCHR( pString, Char ) wcsrchr( pString, Char )
#define STRSTR( pString, pString1 ) wcsstr( pString, pString1 )
#define STRLEN( pString )   wcslen( pString )

#else

#define ATOI( pString ) atoi( pString )
#define ATOL( pString ) atol( pString )
#define STRCHR( pString, Char ) strchr( pString, Char )
#define STRRCHR( pString, Char ) strrchr( pString, Char )
#define STRSTR( pString, pString1 ) strstr( pString, pString1 )
#define STRLEN( pString )   strlen( pString )

#endif


#define UNKNOWN_LENGTH  -1

INT AnsiToUnicodeString( LPCSTR pAnsi, LPWSTR pUnicode, INT StringLength );
LPWSTR AllocateUnicodeString( LPCSTR pAnsi );
VOID FreeUnicodeString( LPWSTR pString );
int UnicodeStringToNumber( LPCWSTR pString );

#ifndef UNICODE

INT UnicodeToAnsiString( LPCWSTR pUnicode, LPSTR pAnsi, INT StringLength );
LPSTR AllocateAnsiString( LPCWSTR pUnicode );
VOID FreeAnsiString( LPSTR pString );

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\g711\codec.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1998 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.h
//
//  Description:
//      This file contains codec definitions, Win16/Win32 compatibility
//      definitions, and instance structure definitions.
//
//
//==========================================================================;

#ifndef _INC_CODEC
#define _INC_CODEC                  // #defined if codec.h has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Version:
//
//  the version is a 32 bit number that is broken into three parts as
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows (in decimal form):
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) &
//      wBuild = LOWORD(dwVersion)
//
//  VERSION_ACM_DRIVER is the version of this driver.
//  VERSION_MSACM is the version of the ACM that this driver
//  was designed for (requires).
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
//
//  32-bit versions
//
#if (WINVER >= 0x0400)
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(4,  0, 0)
#else
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(3, 50, 0)
#endif
#define VERSION_MSACM       MAKE_ACM_VERSION(3, 50, 0)

#else
//
//  16-bit versions
//
#define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(1, 0, 0)
#define VERSION_MSACM       MAKE_ACM_VERSION(2, 1, 0)

#endif

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16/32 portability stuff...
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef _WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNWCALLBACK FAR PASCAL _loadds
        #define FNEXPORT    FAR PASCAL _export
    #else
        #define FNWCALLBACK FAR PASCAL
        #define FNEXPORT    FAR PASCAL _export
    #endif
    #endif

    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif

    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))

    #define HUGE            _huge

    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)
    #define SIZEOFACMSTR(x) sizeof(x)
#else
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    #ifndef try
    #define try         __try
    #define leave       __leave
    #define except      __except
    #define finally     __finally
    #endif


    //
    //  there is no reason to have based stuff in win 32
    //
    #define BCODE

    #define HUGE
    #define HTASK                   HANDLE
    #define SELECTOROF(a)           (a)

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif
    #define SIZEOFACMSTR(x)	(sizeof(x)/sizeof(WCHAR))
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//
//
#define SIZEOF_ARRAY(ar)            (sizeof(ar)/sizeof((ar)[0]))


//
//  macros to compute block alignment and convert between samples and bytes
//  of PCM data. note that these macros assume:
//
//      wBitsPerSample  =  8 or 16
//      nChannels       =  1 or 2
//
//  the pwf argument is a pointer to a PCMWAVEFORMAT structure.
//
#define PCM_BLOCKALIGNMENT(pwf)     (UINT)(((pwf)->wBitsPerSample >> 3) << ((pwf)->wf.nChannels >> 1))
#define PCM_AVGBYTESPERSEC(pwf)     (DWORD)((pwf)->wf.nSamplesPerSec * (pwf)->wf.nBlockAlign)
#define PCM_BYTESTOSAMPLES(pwf, dw) (DWORD)(dw / PCM_BLOCKALIGNMENT(pwf))
#define PCM_SAMPLESTOBYTES(pwf, dw) (DWORD)(dw * PCM_BLOCKALIGNMENT(pwf))



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tDRIVERINSTANCE
{
    //
    //  although not required, it is suggested that the first two members
    //  of this structure remain as fccType and DriverProc _in this order_.
    //  the reason for this is that the driver will be easier to combine
    //  with other types of drivers (defined by AVI) in the future.
    //
    FOURCC          fccType;        // type of driver: 'audc'
    DRIVERPROC      fnDriverProc;   // driver proc for the instance

    //
    //  the remaining members of this structure are entirely open to what
    //  your driver requires.
    //
    HDRVR           hdrvr;          // driver handle we were opened with
    HINSTANCE       hinst;          // DLL module handle.
    DWORD           vdwACM;         // current version of ACM opening you
    DWORD           fdwOpen;        // flags from open description

    DWORD           fdwConfig;      // driver instance configuration flags

} DRIVERINSTANCE, *PDRIVERINSTANCE, FAR *LPDRIVERINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;


//
//
//
//
typedef LRESULT (FNGLOBAL *STREAMCONVERTPROC)
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
);


//
//
//
//
typedef struct tSTREAMINSTANCE
{
    STREAMCONVERTPROC   fnConvert;  // stream instance conversion proc
    DWORD               fdwConfig;  // stream instance configuration flags

} STREAMINSTANCE, *PSTREAMINSTANCE, FAR *LPSTREAMINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  resource id's
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define IDS_ACM_DRIVER_SHORTNAME    (1)     // ACMDRIVERDETAILS.szShortName
#define IDS_ACM_DRIVER_LONGNAME     (2)     // ACMDRIVERDETAILS.szLongName
#define IDS_ACM_DRIVER_COPYRIGHT    (3)     // ACMDRIVERDETAILS.szCopyright
#define IDS_ACM_DRIVER_LICENSING    (4)     // ACMDRIVERDETAILS.szLicensing
#define IDS_ACM_DRIVER_FEATURES     (5)     // ACMDRIVERDETAILS.szFeatures

#define IDS_ACM_DRIVER_TAG_NAME_ALAW    (20)    // ACMFORMATTAGDETAILS.szFormatTag
#define IDS_ACM_DRIVER_TAG_NAME_MULAW   (30)    // ACMFORMATTAGDETAILS.szFormatTag



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" {
#endif

#endif // _INC_CODEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\g711\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1996 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//      This file contains definitions for DEBUG builds; all debugging
//      instructions are #define-d to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//  
//
//
//
#define DEBUG_SECTION       "Debug"         // section name for 
#define DEBUG_MODULE_NAME   "MSG711"        // key name and prefix for output
#define DEBUG_MAX_LINE_LEN  255             // max line length (bytes)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define DPF      dprintf
#else
    #define DbgEnable(x)        FALSE
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #pragma warning(disable:4002)
    #define DPF()
#endif


#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\g711\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1996 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifndef _WIN32
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

    wvsprintfA(ach + lstrlenA(ach), szFormat, va);

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
#if DBG
        DebugBreak();
#endif
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\g711\codec.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.c
//
//  Description:
//      This file contains the DriverProc and other routines which respond
//      to ACM messages.
//
//      Throughout this module, 'g711' refers to both the A-law and u-law
//      coding standards.  When the context requires that these coding
//      standards be differentiated we use 'alaw' and 'mulaw' or a similar
//      variation.
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <memory.h>

#include "codec.h"
#include "g711.h"
#include "debug.h"


const UINT gauFormatTagIndexToTag[] =
{
    WAVE_FORMAT_PCM,
    WAVE_FORMAT_ALAW,
    WAVE_FORMAT_MULAW
};

#define ACM_DRIVER_MAX_FORMAT_TAGS  SIZEOF_ARRAY(gauFormatTagIndexToTag)
#define ACM_DRIVER_MAX_FILTER_TAGS  0


//
//  array of sample rates supported
//
//
const UINT gauFormatIndexToSampleRate[] =
{
    8000,
    11025,
    22050,
    44100
};


#define ACM_DRIVER_MAX_SAMPLE_RATES SIZEOF_ARRAY(gauFormatIndexToSampleRate)

#define ACM_DRIVER_MAX_CHANNELS     G711_MAX_CHANNELS


//
//  bits per sample supported
//
//
#define ACM_DRIVER_MAX_BITSPERSAMPLE_PCM    1       // only 16 bit
#define ACM_DRIVER_MAX_BITSPERSAMPLE_G711   1       // only 8 bit


//
//  number of formats we enumerate per channel is number of sample rates
//  times number of channels times number of types (bits per sample).
//
#define ACM_DRIVER_MAX_FORMATS_PCM  (ACM_DRIVER_MAX_SAMPLE_RATES *      \
                                     ACM_DRIVER_MAX_CHANNELS *          \
                                     ACM_DRIVER_MAX_BITSPERSAMPLE_PCM)

#define ACM_DRIVER_MAX_FORMATS_G711 (ACM_DRIVER_MAX_SAMPLE_RATES *      \
                                     ACM_DRIVER_MAX_CHANNELS *          \
                                     ACM_DRIVER_MAX_BITSPERSAMPLE_G711)



//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  int LoadStringCodec
//
//  Description:
//      This function should be used by all codecs to load resource strings
//      which will be passed back to the ACM.  It works correctly for all
//      platforms, as follows:
//
//          Win16:  Compiled to LoadString to load ANSI strings.
//
//          Win32:  The 32-bit ACM always expects Unicode strings.  Therefore,
//                  when UNICODE is defined, this function is compiled to
//                  LoadStringW to load a Unicode string.  When UNICODE is
//                  not defined, this function loads an ANSI string, converts
//                  it to Unicode, and returns the Unicode string to the
//                  codec.
//
//      Note that you may use LoadString for other strings (strings which
//      will not be passed back to the ACM), because these strings will
//      always be consistent with the definition of UNICODE.
//
//  Arguments:
//      Same as LoadString, except that it expects an LPSTR for Win16 and a
//      LPWSTR for Win32.
//
//  Return (int):
//      Same as LoadString.
//
//--------------------------------------------------------------------------;

#ifndef _WIN32
#define LoadStringCodec LoadString
#else

#ifdef UNICODE
#define LoadStringCodec LoadStringW
#else

int FNGLOBAL LoadStringCodec
(
 HINSTANCE  hinst,
 UINT	    uID,
 LPWSTR	    lpwstr,
 int	    cch)
{
    LPSTR   lpstr;
    int	    iReturn;

    lpstr = (LPSTR)GlobalAlloc(GPTR, cch);
    if (NULL == lpstr)
    {
	return 0;
    }

    iReturn = LoadStringA(hinst, uID, lpstr, cch);
    if (0 == iReturn)
    {
	if (0 != cch)
	{
	    lpwstr[0] = '\0';
	}
    }
    else
    {
    	MultiByteToWideChar( GetACP(), 0, lpstr, cch, lpwstr, cch );
    }

    GlobalFree((HGLOBAL)lpstr);

    return iReturn;
}

#endif  // UNICODE
#endif  // _WIN32


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL pcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid PCM
//      header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL pcmIsValidFormat
(
    LPWAVEFORMATEX          pwfx
)
{
    if (NULL == pwfx)
        return (FALSE);

    if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
        return (FALSE);

    //
    //  verify nChannels member is within the allowed range
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > ACM_DRIVER_MAX_CHANNELS))
        return (FALSE);

    //
    //  only allow the bits per sample that we can encode and decode with
    //
    if (16 != pwfx->wBitsPerSample)
        return (FALSE);

    //
    //  now verify that the block alignment is correct..
    //
    if (PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfx) != pwfx->nBlockAlign)
        return (FALSE);

    //
    //  finally, verify that avg bytes per second is correct
    //
    if (PCM_AVGBYTESPERSEC((LPPCMWAVEFORMAT)pwfx) != pwfx->nAvgBytesPerSec)
        return (FALSE);

    return (TRUE);
} // pcmIsValidFormat()


//--------------------------------------------------------------------------;
//
//  BOOL g711IsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid
//      G711 format header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL g711IsValidFormat
(
    LPWAVEFORMATEX          pwfx
)
{
    if (NULL == pwfx)
        return (FALSE);

    if ((WAVE_FORMAT_MULAW != pwfx->wFormatTag) &&
        (WAVE_FORMAT_ALAW  != pwfx->wFormatTag))
        return (FALSE);

    //
    //  check channels
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > ACM_DRIVER_MAX_CHANNELS))
        return (FALSE);


    //
    //  now verify that the block alignment is correct..
    //
#if 0
    if (G711_BLOCKALIGNMENT(pwfx) != (UINT)pwfx->nBlockAlign)
        return (FALSE);
#else
    //
    //  unfortunately there has been at least one company who didn't
    //  understand what the block alignment was really for and authored
    //  a bunch of files incorrectly. to allow those files to work, we
    //  will just make sure that whole samples remain...
    //
    //  this codec will only author G711 formats with correct block
    //  alignments however.
    //
    if (0 != (pwfx->nBlockAlign % G711_BLOCKALIGNMENT(pwfx)))
        return (FALSE);
#endif

    //
    //  verify that avg bytes per second is correct
    //
    if (G711_AVGBYTESPERSEC(pwfx) != pwfx->nAvgBytesPerSec)
        return (FALSE);

    //
    //  check wBitsPerSample
    //
    if (G711_BITS_PER_SAMPLE != pwfx->wBitsPerSample)
        return (FALSE);

    //
    //  cbSize must be validated also..
    //
    if (G711_WFX_EXTRA_BYTES != pwfx->cbSize)
        return (FALSE);

    return (TRUE);
} // g711IsValidFormat()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverOpen
//
//  Description:
//      This function is used to handle the DRV_OPEN message for the ACM
//      driver. The driver is 'opened' for many reasons with the most common
//      being in preperation for conversion work. It is very important that
//      the driver be able to correctly handle multiple open driver
//      instances.
//
//      Read the comments for this function carefully!
//
//      Note that multiple _streams_ can (and will) be opened on a single
//      open _driver instance_. Do not store/create instance data that must
//      be unique for each stream in this function. See the acmdStreamOpen
//      function for information on conversion streams.
//
//  Arguments:
//      HDRVR hdrvr: Driver handle that will be returned to caller of the
//      OpenDriver function. Normally, this will be the ACM--but this is
//      not guaranteed. For example, if an ACM driver is implemented within
//      a waveform driver, then the driver will be opened by both MMSYSTEM
//      and the ACM.
//
//      LPACMDRVOPENDESC paod: Open description defining how the ACM driver
//      is being opened. This argument may be NULL--see the comments below
//      for more information.
//
//  Return (LRESULT):
//      The return value is non-zero if the open is successful. A zero
//      return signifies that the driver cannot be opened.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverOpen
(
    HDRVR                   hdrvr,
    LPACMDRVOPENDESC        paod
)
{
    PDRIVERINSTANCE     pdi;

    //
    //  the [optional] open description that is passed to this driver can
    //  be from multiple 'managers.' for example, AVI looks for installable
    //  drivers that are tagged with 'vidc' and 'vcap'. we need to verify
    //  that we are being opened as an Audio Compression Manager driver.
    //
    //  if paod is NULL, then the driver is being opened for some purpose
    //  other than converting (that is, there will be no stream open
    //  requests for this instance of being opened). the most common case
    //  of this is the Control Panel's Drivers option checking for config
    //  support (DRV_[QUERY]CONFIGURE).
    //
    //  we want to succeed this open, but be able to know that this
    //  open instance is bogus for creating streams. for this purpose we
    //  leave most of the members of our instance structure that we
    //  allocate below as zero...
    //
    if (NULL != paod)
    {
        //
        //  refuse to open if we are not being opened as an ACM driver.
        //  note that we do NOT modify the value of paod->dwError in this
        //  case.
        //
        if (ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != paod->fccType)
        {
            return (0L);
        }
    }


    //
    //  we are being opened as an installable driver--we can allocate some
    //  instance data to be returned in dwId argument of the DriverProc;
    //  or simply return non-zero to succeed the open.
    //
    //  this driver allocates a small instance structure. note that we
    //  rely on allocating the memory as zero-initialized!
    //
    pdi = (PDRIVERINSTANCE)LocalAlloc(LPTR, sizeof(*pdi));
    if (NULL == pdi)
    {
        //
        //  if this open attempt was as an ACM driver, then return the
        //  reason we are failing in the open description structure..
        //
        if (NULL != paod)
        {
            paod->dwError = MMSYSERR_NOMEM;
        }

        //
        //  fail to open
        //
        return (0L);
    }


    //
    //  fill in our instance structure... note that this instance data
    //  can be anything that the ACM driver wishes to maintain the
    //  open driver instance. this data should not contain any information
    //  that must be maintained per open stream since multiple streams
    //  can be opened on a single driver instance.
    //
    //  also note that we do _not_ check the version of the ACM opening
    //  us (paod->dwVersion) to see if it is at least new enough to work
    //  with this driver (for example, if this driver required Version 3.0
    //  of the ACM and a Version 2.0 installation tried to open us). the
    //  reason we do not fail is to allow the ACM to get the driver details
    //  which contains the version of the ACM that is _required_ by this
    //  driver. the ACM will examine that value (in padd->vdwACM) and
    //  do the right thing for this driver... like not load it and inform
    //  the user of the problem.
    //
    pdi->hdrvr          = hdrvr;
    pdi->hinst          = GetDriverModuleHandle(hdrvr);  // Module handle.

    if (NULL != paod)
    {
        pdi->fnDriverProc = NULL;
        pdi->fccType      = paod->fccType;
        pdi->vdwACM       = paod->dwVersion;
        pdi->fdwOpen      = paod->dwFlags;

        pdi->fdwConfig    = 0L;

        paod->dwError     = MMSYSERR_NOERROR;
    }


    //
    //  non-zero return is success for DRV_OPEN
    //
    return ((LRESULT)(UINT_PTR)pdi);
} // acmdDriverOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverClose
//
//  Description:
//      This function handles the DRV_CLOSE message for the ACM driver. The
//      driver receives a DRV_CLOSE message for each succeeded DRV_OPEN
//      message (see acmdDriverOpen). The driver will only receive a close
//      message for _successful_ opens.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//  Return (LRESULT):
//      The return value is non-zero if the open instance can be closed.
//      A zero return signifies that the ACM driver instance could not be
//      closed.
//
//      NOTE! It is _strongly_ recommended that the driver never fail to
//      close. Note that the ACM will never allow a driver instance to
//      be closed if there are open streams. An ACM driver does not need
//      to check for this case.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverClose
(
    PDRIVERINSTANCE         pdi
)
{
    //
    //  check to see if we allocated instance data. if we did not, then
    //  immediately succeed.
    //
    if (NULL != pdi)
    {
        //
        //  close down the driver instance. this driver simply needs
        //  to free the instance data structure... note that if this
        //  'free' fails, then this ACM driver probably trashed its
        //  heap; assume we didn't do that.
        //
        LocalFree((HLOCAL)pdi);
    }


    //
    //  non-zero return is success for DRV_CLOSE
    //
    return (1L);
} // acmdDriverClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverConfigure
//
//  Description:
//      This function is called to handle the DRV_[QUERY]CONFIGURE messages.
//      These messages are for 'configuration' support of the driver.
//      Normally this will be for 'hardware'--that is, a dialog should be
//      displayed to configure ports, IRQ's, memory mappings, etc if it
//      needs to. However, a software only ACM driver may also require
//      configuration for 'what is real time' or other quality vs time
//      issues.
//
//      The most common way that these messages are generated under Win 3.1
//      and NT Product 1 is from the Control Panel's Drivers option. Other
//      sources may generate these messages in future versions of Windows.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for configuration support.
//
//      LPDRVCONFIGINFO pdci: Pointer to optional DRVCONFIGINFO structure.
//      If this argument is NULL, then the ACM driver should invent its own
//      storage location.
//
//  Return (LRESULT):
//      If the driver is being 'queried' for configuration support (that is,
//      hwnd == (HWND)-1), then non-zero should be returned specifying
//      the driver does support a configuration dialog--or zero should be
//      returned specifying that no configuration dialog is supported.
//
//      If the driver is being called to display the configuration dialog
//      (that is, hwnd != (HWND)-1), then one of the following values
//      should be returned:
//
//      DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
//      and canceled by the user. this value should also be returned if
//      no configuration information was modified.
//
//      DRVCNF_OK (0x0001): specifies that the dialog was displayed and
//      the user pressed OK.  This value should be returned even if the
//      user didn't change anything - otherwise, the driver may not
//      install properly.
//
//      DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
//      and some configuration information was changed that requires
//      Windows to be restarted before the changes take affect. the driver
//      should remain configured with current values until the driver
//      has been 'rebooted'.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverConfigure
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd,
    LPDRVCONFIGINFO         pdci
)
{
    //
    //  first check to see if we are only being queried for configuration
    //  support. if hwnd == (HWND)-1 then we are being queried and should
    //  return zero for 'not supported' and non-zero for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver does NOT support a configuration dialog box, so
        //  return zero...
        //
        return (0L);
    }


    //
    //  we are being asked to bring up our configuration dialog. if this
    //  driver supports a configuration dialog box, then after the dialog
    //  is dismissed we must return one of the following values:
    //
    //  DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
    //  and canceled by the user. this value should also be returned if
    //  no configuration information was modified.
    //
    //  DRVCNF_OK (0x0001): specifies that the dialog was displayed and
    //  the user pressed OK.  This value should be returned even if the
    //  user didn't change anything - otherwise, the driver may not
    //  install properly.
    //
    //  DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
    //  and some configuration information was changed that requires
    //  Windows to be restarted before the changes take affect. the driver
    //  should remain configured with current values until the driver
    //  has been 'rebooted'.
    //
    //
    //  return DRVCNF_CANCEL--this ACM driver does not support configuration
    //
    return (DRVCNF_CANCEL);
} // acmdDriverConfigure()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverDetails
//
//  Description:
//      This function handles the ACMDM_DRIVER_DETAILS message. The ACM
//      driver is responsible for filling in the ACMDRIVERDETAILS structure
//      with various information.
//
//      NOTE! It is *VERY* important that you fill in your ACMDRIVERDETAILS
//      structure correctly. The ACM and applications must be able to
//      rely on this information.
//
//      WARNING! The _reserved_ bits of any fields of the ACMDRIVERDETAILS
//      structure are _exactly that_: RESERVED. Do NOT use any extra
//      flag bits, etc. for custom information. The proper way to add
//      custom capabilities to your ACM driver is this:
//
//      o   define a new message in the ACMDM_USER range.
//
//      o   an application that wishes to use one of these extra features
//          should then:
//
//          o   open the driver with acmDriverOpen.
//
//          o   check for the proper wMid and wPid using acmDriverDetails.
//
//          o   send the 'user defined' message with acmDriverMessage
//              to retrieve additional information, etc.
//
//          o   close the driver with acmDriverClose.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRIVERDETAILS padd: Pointer to ACMDRIVERDETAILS structure to
//      fill in for the caller. This structure may be larger or smaller than
//      the current definition of ACMDRIVERDETAILS--cbStruct specifies the
//      valid size.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) for success. Non-zero
//      signifies that the driver details could not be retrieved.
//
//      NOTE THAT THIS FUNCTION SHOULD NEVER FAIL! There are two possible
//      error conditions:
//
//      o   if padd is NULL or an invalid pointer.
//
//      o   if cbStruct is less than four; in this case, there is not enough
//          room to return the number of bytes filled in.
//
//      Because these two error conditions are easily defined, the ACM
//      will catch these errors. The driver does NOT need to check for these
//      conditions.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMDRIVERDETAILS      padd
)
{
    ACMDRIVERDETAILS    add;
    DWORD               cbStruct;

    //
    //  it is easiest to fill in a temporary structure with valid info
    //  and then copy the requested number of bytes to the destination
    //  buffer.
    //
    cbStruct            = min(padd->cbStruct, sizeof(ACMDRIVERDETAILS));
    add.cbStruct        = cbStruct;


    //
    //  for the current implementation of an ACM driver, the fccType and
    //  fccComp members *MUST* always be ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC
    //  ('audc') and ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (0) respectively.
    //
    add.fccType         = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    add.fccComp         = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;


    //
    //  the manufacturer id (wMid) and product id (wPid) must be filled
    //  in with your company's _registered_ identifier's. for more
    //  information on these identifier's and how to get them registered
    //  contact Microsoft and get the Multimedia Developer Registration Kit:
    //
    //      Microsoft Corporation
    //      Multimedia Technology Group
    //      One Microsoft Way
    //      Redmond, WA 98052-6399
    //
    //      Developer Services Phone: (800) 227-4679 x11771
    //
    //  note that during the development phase or your ACM driver, you may
    //  use the reserved value of '0' for both wMid and wPid. however it
    //  is not acceptable to ship a driver with these values.
    //
    add.wMid            = MM_MICROSOFT;
    add.wPid            = MM_MSFT_ACM_G711;


    //
    //  the vdwACM and vdwDriver members contain version information for
    //  the driver.
    //
    //  vdwACM: must contain the version of the *ACM* that the driver was
    //  _designed_ for. this is the _minimum_ version number of the ACM
    //  that the driver will work with. this value must be >= V2.00.000.
    //
    //  vdwDriver: the version of this ACM driver.
    //
    //  ACM driver versions are 32 bit numbers broken into three parts as
    //  follows (note these parts are displayed as decimal values):
    //
    //      bits 24 - 31:   8 bit _major_ version number
    //      bits 16 - 23:   8 bit _minor_ version number
    //      bits  0 - 15:   16 bit build number
    //
    add.vdwACM          = VERSION_MSACM;
    add.vdwDriver       = VERSION_ACM_DRIVER;


    //
    //  the following flags are used to specify the type of conversion(s)
    //  that the ACM driver supports. note that a driver may support one or
    //  more of these flags in any combination.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver
    //  supports conversions from one format tag to another format tag. for
    //  example, if a converter compresses or decompresses WAVE_FORMAT_PCM
    //  and WAVE_FORMAT_IMA_ADPCM, then this bit should be set. this is
    //  true even if the data is not actually changed in size--for example
    //  a conversion from u-Law to A-Law will still set this bit because
    //  the format tags differ.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the
    //  driver supports conversions on the same format tag. as an example,
    //  the PCM converter that is built into the ACM sets this bit (and only
    //  this bit) because it converts only between PCM formats (bits, sample
    //  rate).
    //
    //  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver
    //  supports transformations on a single format tag but does change
    //  the base characteristics of the format (bit depth, sample rate, etc
    //  will remain the same). for example, a driver that changed the
    //  'volume' of PCM data or applied a low pass filter would set this bit.
    //
    add.fdwSupport      = ACMDRIVERDETAILS_SUPPORTF_CODEC;


    //
    //  the number of individual format tags this ACM driver supports. for
    //  example, if a driver uses the WAVE_FORMAT_IMA_ADPCM and
    //  WAVE_FORMAT_PCM format tags, then this value would be two. if the
    //  driver only supports filtering on WAVE_FORMAT_PCM, then this value
    //  would be one. if this driver supported WAVE_FORMAT_ALAW,
    //  WAVE_FORMAT_MULAW and WAVE_FORMAT_PCM, then this value would be
    //  three. etc, etc.
    //
    add.cFormatTags     = ACM_DRIVER_MAX_FORMAT_TAGS;

    //
    //  the number of individual filter tags this ACM driver supports. if
    //  a driver supports no filters (ACMDRIVERDETAILS_SUPPORTF_FILTER is
    //  NOT set in the fdwSupport member), then this value must be zero.
    //
    add.cFilterTags     = ACM_DRIVER_MAX_FILTER_TAGS;


    //
    //  the remaining members in the ACMDRIVERDETAILS structure are sometimes
    //  not needed. because of this we make a quick check to see if we
    //  should go through the effort of filling in these members.
    //
    if (FIELD_OFFSET(ACMDRIVERDETAILS, hicon) < cbStruct)
    {
        //
        //  fill in the hicon member will a handle to a custom icon for
        //  the ACM driver. this allows the driver to be represented by
        //  an application graphically (usually this will be a company
        //  logo or something). if a driver does not wish to have a custom
        //  icon displayed, then simply set this member to NULL and a
        //  generic icon will be displayed instead.
        //
        //  See the MSFILTER sample for a codec which contains a custom icon.
        //
        add.hicon = NULL;

        //
        //  the short name and long name are used to represent the driver
        //  in a unique description. the short name is intended for small
        //  display areas (for example, in a menu or combo box). the long
        //  name is intended for more descriptive displays (for example,
        //  in an 'about box').
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.
        //
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_SHORTNAME, add.szShortName, SIZEOFACMSTR(add.szShortName));
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LONGNAME,  add.szLongName,  SIZEOFACMSTR(add.szLongName));

        //
        //  the last three members are intended for 'about box' information.
        //  these members are optional and may be zero length strings if
        //  the driver wishes.
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.
        //
        if (FIELD_OFFSET(ACMDRIVERDETAILS, szCopyright) < cbStruct)
        {
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_COPYRIGHT, add.szCopyright, SIZEOFACMSTR(add.szCopyright));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LICENSING, add.szLicensing, SIZEOFACMSTR(add.szLicensing));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_FEATURES,  add.szFeatures,  SIZEOFACMSTR(add.szFeatures));
        }
    }


    //
    //  now copy the correct number of bytes to the caller's buffer
    //
    _fmemcpy(padd, &add, (UINT)add.cbStruct);


    //
    //  success!
    //
    return (MMSYSERR_NOERROR);
} // acmdDriverDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverAbout
//
//  Description:
//      This function is called to handle the ACMDM_DRIVER_ABOUT message.
//      An ACM driver has the option of displaying its own 'about box' or
//      letting the ACM (or calling application) display one for it. This
//      message is normally sent by the Control Panel's Sound Mapper
//      option.
//
//      It is recommended that an ACM driver allow a default about box
//      be displayed for it--there should be no reason to bloat the size
//      of a driver to simply display copyright, etc information when that
//      information is contained in the ACMDRIVERDETAILS structure.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for about box support.
//
//  Return (LRESULT):
//      The return value is MMSYSERR_NOTSUPPORTED if the ACM driver does
//      not support a custom dialog box. In this case, the ACM or calling
//      application will display a generic about box using the information
//      contained in the ACMDRIVERDETAILS structure returned by the
//      ACMDM_DRIVER_DETAILS message.
//
//      If the driver chooses to display its own dialog box, then after
//      the dialog is dismissed by the user, MMSYSERR_NOERROR should be
//      returned.
//
//      If the hwnd argument is equal to (HWND)-1, then no dialog should
//      be displayed (the driver is only being queried for support). The
//      driver must still return MMSYSERR_NOERROR (supported) or
//      MMSYSERR_NOTSUPPORTED (no custom about box supported).
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverAbout
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd
)
{
    //
    //  first check to see if we are only being queried for custom about
    //  box support. if hwnd == (HWND)-1 then we are being queried and
    //  should return MMSYSERR_NOTSUPPORTED for 'not supported' and
    //  MMSYSERR_NOERROR for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver does NOT support a custom about box, so
        //  return MMSYSERR_NOTSUPPORTED...
        //
        return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  this driver does not support a custom dialog, so tell the ACM or
    //  calling application to display one for us. note that this is the
    //  _recommended_ method for consistency and simplicity of ACM drivers.
    //  why write code when you don't have to?
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdDriverAbout()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatSuggest
//
//  Description:
//      This function handles the ACMDM_FORMAT_SUGGEST message. The purpose
//      of this function is to provide a way for the ACM, a wave mapper or
//      an application to quickly get a destination format that this driver
//      can convert the source format to. The 'suggested' format should
//      be as close to a common format as possible. This message is normally
//      sent in response to an acmFormatSuggest function call.
//
//      Another way to think about this message is: what format would this
//      driver like to convert the source format to?
//
//      The caller may place restrictions on the destination format that
//      should be suggested. The padfs->fdwSuggest member contains the
//      restriction bits passed by the caller--see the description for
//      the return value for more information.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVFORMATSUGGEST padfs: Pointer to an ACMDRVFORMATSUGGEST
//      structure that describes the source and destination (possibly with
//      restrictions) for a conversion.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if one or more of
//      the destination restriction bits is not supported. It is strongly
//      recommended that the driver support at least the following suggestion
//      restriction bits:
//
//      ACM_FORMATSUGGESTF_WFORMATTAG: The destination format tag must be
//      the same as the wFormatTag member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NCHANNELS: The destination channel count must be
//      the same as the nChannels member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NSAMPLESPERSEC: The destination samples per
//      second must be the same as the nSamplesPerSec member in the
//      destination format header.
//
//      ACM_FORMATSUGGESTF_WBITSPERSAMPLE: The destination bits per sample
//      must be the same as the wBitsPerSample member in the destination
//      format header.
//
//      If no destintation format can be suggested, then the driver should
//      return ACMERR_NOTPOSSIBLE.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatSuggest
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVFORMATSUGGEST   padfs
)
{
    #define ACMD_FORMAT_SUGGEST_SUPPORT (ACM_FORMATSUGGESTF_WFORMATTAG |    \
                                         ACM_FORMATSUGGESTF_NCHANNELS |     \
                                         ACM_FORMATSUGGESTF_NSAMPLESPERSEC |\
                                         ACM_FORMATSUGGESTF_WBITSPERSAMPLE)

    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
    DWORD                   fdwSuggest;


    //
    //  grab the suggestion restriction bits and verify that we support
    //  the ones that are specified... an ACM driver must return the
    //  MMSYSERR_NOTSUPPORTED if the suggestion restriction bits specified
    //  are not supported.
    //
    fdwSuggest = (ACM_FORMATSUGGESTF_TYPEMASK & padfs->fdwSuggest);

    if (~ACMD_FORMAT_SUGGEST_SUPPORT & fdwSuggest)
        return (MMSYSERR_NOTSUPPORTED);


    //
    //  get the source and destination formats in more convenient variables
    //
    pwfxSrc = padfs->pwfxSrc;
    pwfxDst = padfs->pwfxDst;


    //
    //
    //
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            //
            //  strictly verify that the source format is acceptable for
            //  this driver
            //
            if (!pcmIsValidFormat(pwfxSrc))
                break;


            //
            //  if the destination format tag is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is able to encode to A-Law and u-Law
            //
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                if ((WAVE_FORMAT_ALAW  != pwfxDst->wFormatTag) &&
                    (WAVE_FORMAT_MULAW != pwfxDst->wFormatTag))
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wFormatTag = WAVE_FORMAT_ALAW;
            }


            //
            //  if the destination channel count is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is not able to change the number of channels
            //
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if (pwfxSrc->nChannels != pwfxDst->nChannels)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = pwfxSrc->nChannels;
            }


            //
            //  if the destination samples per second is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is not able to change the sample rate
            //
            if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
            {
                if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
            }


            //
            //  if the destination bits per sample is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is only able to encode to 8 bit
            //
            if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
            {
                if (G711_BITS_PER_SAMPLE != pwfxDst->wBitsPerSample)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wBitsPerSample = G711_BITS_PER_SAMPLE;
            }


            //
            //  at this point, we have filled in all fields except the
            //  following for our 'suggested' destination format:
            //
            //      nAvgBytesPerSec
            //      nBlockAlign
            //      cbSize
            //
            pwfxDst->nBlockAlign     = G711_BLOCKALIGNMENT(pwfxDst);
            pwfxDst->nAvgBytesPerSec = G711_AVGBYTESPERSEC(pwfxDst);
            pwfxDst->cbSize          = G711_WFX_EXTRA_BYTES;

            return (MMSYSERR_NOERROR);


        case WAVE_FORMAT_ALAW:
        case WAVE_FORMAT_MULAW:
            //
            //  strictly verify that the source format is acceptable for
            //  this driver
            //
            if (!g711IsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);


            //
            //  if the destination format tag is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is able to decode to PCM from u-Law and A-Law
            //  as well as convert between u-Law and A-Law
            //
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                switch (pwfxDst->wFormatTag)
                {
                    case WAVE_FORMAT_PCM:
                        break;

                    case WAVE_FORMAT_ALAW:
                        if (WAVE_FORMAT_MULAW != pwfxSrc->wFormatTag)
                            return (ACMERR_NOTPOSSIBLE);
                        break;

                    case WAVE_FORMAT_MULAW:
                        if (WAVE_FORMAT_ALAW != pwfxSrc->wFormatTag)
                            return (ACMERR_NOTPOSSIBLE);
                        break;

                    default:
                        return (ACMERR_NOTPOSSIBLE);
                }


                if (WAVE_FORMAT_PCM == pwfxDst->wFormatTag)
                {
                    //
                    //  if the destination bits per sample is restricted,
                    //  verify that it is within our capabilities...
                    //
                    //  this driver is only able to decode to 16 bit
                    //
                    if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
                    {
                        if (16 != pwfxDst->wBitsPerSample)
                            return (ACMERR_NOTPOSSIBLE);
                    }
                    else
                    {
                        pwfxDst->wBitsPerSample = 16;
                    }
                }
                else
                {
                    //
                    //  if the destination bits per sample is restricted,
                    //  verify that it is within our capabilities...
                    //
                    //  this driver is only able to convert between u-Law and
                    //  A-Law at the same bit depth (8 bit)
                    //
                    if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
                    {
                        if (G711_BITS_PER_SAMPLE != pwfxDst->wBitsPerSample)
                            return (ACMERR_NOTPOSSIBLE);
                    }
                    else
                    {
                        pwfxDst->wBitsPerSample = G711_BITS_PER_SAMPLE;
                    }
                }
            }
            else
            {
                if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
                {
                    if (16 == pwfxDst->wBitsPerSample)
                    {
                        pwfxDst->wFormatTag = WAVE_FORMAT_PCM;
                    }
                    else if (8 == pwfxDst->wBitsPerSample)
                    {
                        if (WAVE_FORMAT_ALAW == pwfxSrc->wFormatTag)
                        {
                            pwfxDst->wFormatTag = WAVE_FORMAT_MULAW;
                        }
                        else if (WAVE_FORMAT_MULAW == pwfxSrc->wFormatTag)
                        {
                            pwfxDst->wFormatTag = WAVE_FORMAT_ALAW;
                        }
                        else
                        {
                            return (ACMERR_NOTPOSSIBLE);
                        }
                    }
                    else
                    {
                        return (ACMERR_NOTPOSSIBLE);
                    }
                }
                else
                {
                    pwfxDst->wFormatTag     = WAVE_FORMAT_PCM;
                    pwfxDst->wBitsPerSample = 16;
                }
            }


            //
            //  if the destination channel count is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is not able to change the number of channels
            //
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if (pwfxSrc->nChannels != pwfxDst->nChannels)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = pwfxSrc->nChannels;
            }


            //
            //  if the destination samples per second is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is not able to change the sample rate
            //
            if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
            {
                if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
            }


            //
            //
            //
            //
            if (WAVE_FORMAT_PCM == pwfxDst->wFormatTag)
            {
                //
                //  at this point, we have filled in all fields except the
                //  following for our 'suggested' destination format:
                //
                //      nAvgBytesPerSec
                //      nBlockAlign
                //      cbSize              !!! not used for PCM !!!
                //
                pwfxDst->nBlockAlign     = PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfxDst);
                pwfxDst->nAvgBytesPerSec = PCM_AVGBYTESPERSEC((LPPCMWAVEFORMAT)pwfxDst);

                // pwfxDst->cbSize       = not used;
            }

            //
            //  the suggested destination format tag is not PCM
            //
            else
            {

                //
                //  at this point, we have filled in all fields except the
                //  following for our 'suggested' destination format:
                //
                //      nAvgBytesPerSec
                //      nBlockAlign
                //      cbSize
                //
                pwfxDst->nBlockAlign     = G711_BLOCKALIGNMENT(pwfxDst);
                pwfxDst->nAvgBytesPerSec = G711_AVGBYTESPERSEC(pwfxDst);
                pwfxDst->cbSize          = G711_WFX_EXTRA_BYTES;
            }
            return (MMSYSERR_NOERROR);
    }


    //
    //  can't suggest anything because either the source format is foreign
    //  or the destination format has restrictions that this ACM driver
    //  cannot deal with.
    //
    return (ACMERR_NOTPOSSIBLE);
} // acmdFormatSuggest()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatTagDetails
//
//  Description:
//      This function handles the ACMDM_FORMATTAG_DETAILS message. This
//      message is normally sent in response to an acmFormatTagDetails or
//      acmFormatTagEnum function call. The purpose of this function is
//      to get details about a specific format tag supported by this ACM
//      driver.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATTAGDETAILS padft: Pointer to an ACMFORMATTAGDETAILS
//      structure that describes what format tag to retrieve details for.
//
//      DWORD fdwDetails: Flags defining what format tag to retrieve the
//      details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATTAGDETAILSF_INDEX: Indicates that a format tag index
//      was given in the dwFormatTagIndex member of the ACMFORMATTAGDETAILS
//      structure. The format tag and details must be returned in the
//      structure specified by padft. The index ranges from zero to one less
//      than the cFormatTags member returned in the ACMDRIVERDETAILS
//      structure for this driver.
//
//      ACM_FORMATTAGDETAILSF_FORMATTAG: Indicates that a format tag
//      was given in the dwFormatTag member of the ACMFORMATTAGDETAILS
//      structure. The format tag details must be returned in the structure
//      specified by padft.
//
//      ACM_FORMATTAGDETAILSF_LARGESTSIZE: Indicates that the details
//      on the format tag with the largest format size in bytes must be
//      returned. The dwFormatTag member will either be WAVE_FORMAT_UNKNOWN
//      or the format tag to find the largest size for.
//
//      If the details for the specified format tag cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatTagDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT                uFormatTag;

    //
    //
    //
    //
    //
    switch (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            //
            //  if the index is too large, then they are asking for a
            //  non-existant format.  return error.
            //
            if (ACM_DRIVER_MAX_FORMAT_TAGS <= padft->dwFormatTagIndex)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = gauFormatTagIndexToTag[(UINT)padft->dwFormatTagIndex];
            break;


        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_UNKNOWN:
                case WAVE_FORMAT_ALAW:
                    uFormatTag = WAVE_FORMAT_ALAW;
                    break;

                case WAVE_FORMAT_MULAW:
                    uFormatTag = WAVE_FORMAT_MULAW;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_ALAW:
                    uFormatTag = WAVE_FORMAT_ALAW;
                    break;

                case WAVE_FORMAT_MULAW:
                    uFormatTag = WAVE_FORMAT_MULAW;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        //
        //  if this ACM driver does not understand a query type, then
        //  return 'not supported'
        //
        default:
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //
    //
    //
    switch (uFormatTag)
    {
        case WAVE_FORMAT_PCM:
            padft->dwFormatTagIndex = 0;
            padft->dwFormatTag      = WAVE_FORMAT_PCM;
            padft->cbFormatSize     = sizeof(PCMWAVEFORMAT);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_PCM;

            //
            //  the ACM is responsible for the PCM format tag name
            //
            padft->szFormatTag[0] = '\0';
            break;

        case WAVE_FORMAT_ALAW:
            padft->dwFormatTagIndex = 1;
            padft->dwFormatTag      = WAVE_FORMAT_ALAW;
            padft->cbFormatSize     = sizeof(WAVEFORMATEX) +
                                      G711_WFX_EXTRA_BYTES;
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_G711;

            LoadStringCodec(pdi->hinst,
                       IDS_ACM_DRIVER_TAG_NAME_ALAW,
                       padft->szFormatTag,
                       SIZEOFACMSTR(padft->szFormatTag));
            break;

        case WAVE_FORMAT_MULAW:
            padft->dwFormatTagIndex = 2;
            padft->dwFormatTag      = WAVE_FORMAT_MULAW;
            padft->cbFormatSize     = sizeof(WAVEFORMATEX) +
                                      G711_WFX_EXTRA_BYTES;
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_G711;

            LoadStringCodec(pdi->hinst,
                       IDS_ACM_DRIVER_TAG_NAME_MULAW,
                       padft->szFormatTag,
                       SIZEOFACMSTR(padft->szFormatTag));
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATTAGDETAILS structure
    //  passed is at least large enough to hold the base information of
    //  the details structure
    //
    padft->cbStruct = min(padft->cbStruct, sizeof(*padft));


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatTagDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatDetails
//
//  Description:
//      This function handles the ACMDM_FORMAT_DETAILS message. This
//      message is normally sent in response to an acmFormatDetails or
//      acmFormatEnum function call. The purpose of this function is
//      to get details about a specific format for a specified format tag
//      supported by this ACM driver.
//
//      Note that an ACM driver can return a zero length string for the
//      format name if it wishes to have the ACM create a format string
//      for it. This is strongly recommended to simplify internationalizing
//      the driver--the ACM will automatically take care of that. The
//      following formula is used to format a string by the ACM:
//
//      <nSamplesPerSec> kHz, <bit depth> bit, [Mono | Stereo | nChannels]
//
//      <bit depth> = <nAvgBytesPerSec> * 8 / nSamplesPerSec / nChannels;
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATDETAILS padf: Pointer to an ACMFORMATDETAILS structure
//      that describes what format (for a specified format tag) to retrieve
//      details for.
//
//      DWORD fdwDetails: Flags defining what format for a specified format
//      tag to retrieve the details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATDETAILSF_INDEX: Indicates that a format index for the
//      format tag was given in the dwFormatIndex member of the
//      ACMFORMATDETAILS structure. The format details must be returned in
//      the structure specified by padf. The index ranges from zero to one
//      less than the cStandardFormats member returned in the
//      ACMFORMATTAGDETAILS structure for a format tag.
//
//      ACM_FORMATDETAILSF_FORMAT: Indicates that a WAVEFORMATEX structure
//      pointed to by pwfx of the ACMFORMATDETAILS structure was given and
//      the remaining details should be returned. The dwFormatTag member
//      of the ACMFORMATDETAILS will be initialized to the same format
//      tag as the pwfx member specifies. This query type may be used to
//      get a string description of an arbitrary format structure.
//
//      If the details for the specified format cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATDETAILS      padf,
    DWORD                   fdwDetails
)
{
    LPWAVEFORMATEX      pwfx;
    UINT                uFormatIndex;
    UINT                u;


    //
    //
    //
    //
    //
    switch (ACM_FORMATDETAILSF_QUERYMASK & fdwDetails)
    {
        //
        //  enumerate by index
        //
        //  verify that the format tag is something we know about and
        //  return the details on the 'standard format' supported by
        //  this driver at the specified index...
        //
        case ACM_FORMATDETAILSF_INDEX:
            //
            //  put some stuff in more accessible variables--note that we
            //  bring variable sizes down to a reasonable size for 16 bit
            //  code...
            //
            pwfx = padf->pwfx;
            uFormatIndex = (UINT)padf->dwFormatIndex;

            switch (padf->dwFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (ACM_DRIVER_MAX_FORMATS_PCM <= padf->dwFormatIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    //
                    //  now fill in the format structure
                    //
                    pwfx->wFormatTag      = WAVE_FORMAT_PCM;

                    u = uFormatIndex / (ACM_DRIVER_MAX_BITSPERSAMPLE_PCM * ACM_DRIVER_MAX_CHANNELS);
                    pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[u];

                    u = uFormatIndex % ACM_DRIVER_MAX_CHANNELS;
                    pwfx->nChannels       = u + 1;
                    pwfx->wBitsPerSample  = 16;

                    pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfx);
                    pwfx->nAvgBytesPerSec = PCM_AVGBYTESPERSEC((LPPCMWAVEFORMAT)pwfx);

                    //
                    //  note that the cbSize field is NOT valid for PCM
                    //  formats
                    //
                    //  pwfx->cbSize      = 0;
                    break;

                case WAVE_FORMAT_MULAW:
                case WAVE_FORMAT_ALAW:
                    if (ACM_DRIVER_MAX_FORMATS_G711 <= padf->dwFormatIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    pwfx->wFormatTag      = LOWORD(padf->dwFormatTag);

                    u = uFormatIndex / (ACM_DRIVER_MAX_BITSPERSAMPLE_G711 * ACM_DRIVER_MAX_CHANNELS);
                    pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[u];

                    u = uFormatIndex % ACM_DRIVER_MAX_CHANNELS;
                    pwfx->nChannels       = u + 1;
                    pwfx->wBitsPerSample  = G711_BITS_PER_SAMPLE;

                    pwfx->nBlockAlign     = G711_BLOCKALIGNMENT(pwfx);
                    pwfx->nAvgBytesPerSec = G711_AVGBYTESPERSEC(pwfx);
                    pwfx->cbSize          = G711_WFX_EXTRA_BYTES;
                    break;


                default:
                    return (ACMERR_NOTPOSSIBLE);
            }

        //
        //  return details on specified format
        //
        //  the caller normally uses this to verify that the format is
        //  supported and to retrieve a string description...
        //
        case ACM_FORMATDETAILSF_FORMAT:
            pwfx = padf->pwfx;

            switch (pwfx->wFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (!pcmIsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                case WAVE_FORMAT_ALAW:
                case WAVE_FORMAT_MULAW:
                    if (!g711IsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        default:
            //
            //  don't know how to do the query type passed--return 'not
            //  supported'.
            //
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  return the size of the valid information we are returning
    //
    //  the ACM will guarantee that the ACMFORMATDETAILS structure
    //  passed is at least large enough to hold the base structure
    //
    //  note that we let the ACM create the format string for us since
    //  we require no special formatting (and don't want to deal with
    //  internationalization issues, etc). simply set the string to
    //  a zero length.
    //
    padf->cbStruct    = min(padf->cbStruct, sizeof(*padf));
    padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_CODEC;
    padf->szFormat[0] = '\0';


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatDetails()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamOpen
//
//  Description:
//      This function handles the ACMDM_STREAM_OPEN message. This message
//      is sent to initiate a new conversion stream. This is usually caused
//      by an application calling acmStreamOpen. If this function is
//      successful, then one or more ACMDM_STREAM_CONVERT messages will be
//      sent to convert individual buffers (user calls acmStreamConvert).
//
//      Note that an ACM driver will not receive open requests for ASYNC
//      or FILTER operations unless the ACMDRIVERDETAILS_SUPPORTF_ASYNC
//      or ACMDRIVERDETAILS_SUPPORTF_FILTER flags are set in the
//      ACMDRIVERDETAILS structure. There is no need for the driver to
//      check for these requests unless it sets those support bits.
//
//      If the ACM_STREAMOPENF_QUERY flag is set in the padsi->fdwOpen
//      member, then no resources should be allocated. Just verify that
//      the conversion request is possible by this driver and return the
//      appropriate error (either ACMERR_NOTPOSSIBLE or MMSYSERR_NOERROR).
//      The driver will NOT receive an ACMDM_STREAM_CLOSE for queries.
//
//      If the ACM_STREAMOPENF_NONREALTIME bit is NOT set, then conversion
//      must be done in 'real-time'. This is a tough one to describe
//      exactly. If the driver may have trouble doing the conversion without
//      breaking up the audio, then a configuration dialog might be used
//      to allow the user to specify whether the real-time conversion
//      request should be succeeded. DO NOT SUCCEED THE CALL UNLESS YOU
//      ACTUALLY CAN DO REAL-TIME CONVERSIONS! There may be another driver
//      installed that can--so if you succeed the call you are hindering
//      the performance of the user's system!
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      This structure will be passed back to all future stream messages
//      if the open succeeds. The information in this structure will never
//      change during the lifetime of the stream--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      A driver should return ACMERR_NOTPOSSIBLE if the conversion cannot
//      be performed due to incompatible source and destination formats.
//
//      A driver should return MMSYSERR_NOTSUPPORTED if the conversion
//      cannot be performed in real-time and the request does not specify
//      the ACM_STREAMOPENF_NONREALTIME flag.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamOpen
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    BOOL                fRealTime;
    STREAMCONVERTPROC   fnConvert;
    PSTREAMINSTANCE     psi;


    //
    //
    //
    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    fRealTime = (0 == (padsi->fdwOpen & ACM_STREAMOPENF_NONREALTIME));


    //
    //  the most important condition to check before doing anything else
    //  is that this ACM driver can actually perform the conversion we are
    //  being opened for. this check should fail as quickly as possible
    //  if the conversion is not possible by this driver.
    //
    //  it is VERY important to fail quickly so the ACM can attempt to
    //  find a driver that is suitable for the conversion. also note that
    //  the ACM may call this driver several times with slightly different
    //  format specifications before giving up.
    //
    //  this driver first verifies that the source and destination formats
    //  are acceptable...
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            if (!pcmIsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);

            if (!g711IsValidFormat(pwfxDst))
                return (ACMERR_NOTPOSSIBLE);

            //
            //
            //
            if (WAVE_FORMAT_ALAW == pwfxDst->wFormatTag)
                fnConvert = PcmToAlaw;
            else
                fnConvert = PcmToUlaw;
            break;


        case WAVE_FORMAT_ALAW:
        case WAVE_FORMAT_MULAW:
            if (!g711IsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);

            if (WAVE_FORMAT_PCM == pwfxDst->wFormatTag)
            {
                if (!pcmIsValidFormat(pwfxDst))
                    return (ACMERR_NOTPOSSIBLE);

                //
                //
                //
                if (WAVE_FORMAT_ALAW == pwfxSrc->wFormatTag)
                    fnConvert = AlawToPcm;
                else
                    fnConvert = UlawToPcm;
            }
            else
            {
                if (!g711IsValidFormat(pwfxDst))
                    return (ACMERR_NOTPOSSIBLE);

                //
                //  we are not a converter for equivelant format tags
                //
                if (pwfxSrc->wFormatTag == pwfxDst->wFormatTag)
                    return (ACMERR_NOTPOSSIBLE);

                //
                //
                //
                if (WAVE_FORMAT_ALAW == pwfxSrc->wFormatTag)
                    fnConvert = AlawToUlaw;
                else
                    fnConvert = UlawToAlaw;
            }
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  for this driver, we must also verify that the nChannels and
    //  nSamplesPerSec members are the same between the source and
    //  destination formats.
    //
    if (pwfxSrc->nChannels != pwfxDst->nChannels)
        return (MMSYSERR_NOTSUPPORTED);

    if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
        return (MMSYSERR_NOTSUPPORTED);


    //
    //  we have determined that the conversion requested is possible by
    //  this driver. now check if we are just being queried for support.
    //  if this is just a query, then do NOT allocate any instance data
    //  or create tables, etc. just succeed the call.
    //
    if (0 != (ACM_STREAMOPENF_QUERY & padsi->fdwOpen))
    {
        return (MMSYSERR_NOERROR);
    }


    //
    //  we have decided that this driver can handle the conversion stream.
    //  so we want to do _AS MUCH WORK AS POSSIBLE_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.
    //
    //  this driver allocates a small instance structure for each stream
    //
    //
    psi = (PSTREAMINSTANCE)LocalAlloc(LPTR, sizeof(*psi));
    if (NULL == psi)
    {
        return (MMSYSERR_NOMEM);
    }


    //
    //  fill out our instance structure
    //
    //  this driver stores a pointer to the conversion function that will
    //  be used for each conversion on this stream. we also store a
    //  copy of the _current_ configuration of the driver instance we
    //  are opened on. this must not change during the life of the stream
    //  instance.
    //
    //  this is also very important! if the user is able to configure how
    //  the driver performs conversions, the changes should only affect
    //  future open streams. all current open streams should behave as
    //  they were configured during the open.
    //
    psi->fnConvert  = fnConvert;
    psi->fdwConfig  = pdi->fdwConfig;


    //
    //  fill in our instance data--this will be passed back to all stream
    //  messages in the ACMDRVSTREAMINSTANCE structure. it is entirely
    //  up to the driver what gets stored (and maintained) in the
    //  fdwDriver and dwDriver members.
    //
    padsi->fdwDriver = 0L;
    padsi->dwDriver  = (DWORD_PTR)psi;

    return (MMSYSERR_NOERROR);
} // acmdStreamOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamClose
//
//  Description:
//      This function is called to handle the ACMDM_STREAM_CLOSE message.
//      This message is sent when a conversion stream is no longer being
//      used (the stream is being closed; usually by an application
//      calling acmStreamClose). The ACM driver should clean up any resources
//      that were allocated for the stream.
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      NOTE! It is _strongly_ recommended that a driver not fail to close
//      a conversion stream.
//
//      An asyncronous conversion stream may fail with ACMERR_BUSY if there
//      are pending buffers. An application may call acmStreamReset to
//      force all pending buffers to be posted.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamClose
(
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    PSTREAMINSTANCE     psi;

    //
    //  the driver should clean up all privately allocated resources that
    //  were created for maintaining the stream instance. if no resources
    //  were allocated, then simply succeed.
    //
    //  in the case of this driver, we need to free the stream instance
    //  structure that we allocated during acmdStreamOpen.
    //
    psi = (PSTREAMINSTANCE)padsi->dwDriver;
    if (NULL != psi)
    {
        //
        //  free the stream instance structure
        //
        LocalFree((HLOCAL)psi);
    }

    return (MMSYSERR_NOERROR);
} // acmdStreamClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamSize
//
//  Description:
//      This function handles the ACMDM_STREAM_SIZE message. The purpose
//      of this function is to provide the _largest size in bytes_ that
//      the source or destination buffer needs to be given the input and
//      output formats and the size in bytes of the source or destination
//      data buffer.
//
//      In other words: how big does my destination buffer need to be to
//      hold the converted data? (ACM_STREAMSIZEF_SOURCE)
//
//      Or: how big can my source buffer be given the destination buffer?
//      (ACM_STREAMSIZEF_DESTINATION)
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMSIZE padss: Specifies a pointer to the ACMDRVSTREAMSIZE
//      structure that defines the conversion stream size query attributes.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      An ACM driver should return MMSYSERR_NOTSUPPORTED if a query type
//      is requested that the driver does not understand. Note that a driver
//      must support both the ACM_STREAMSIZEF_DESTINATION and
//      ACM_STREAMSIZEF_SOURCE queries.
//
//      If the conversion would be 'out of range' given the input arguments,
//      then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamSize
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
)
{
    PSTREAMINSTANCE     psi;
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    DWORD               cb;

    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    //
    //
    //
    //
    //
    switch (ACM_STREAMSIZEF_QUERYMASK & padss->fdwSize)
    {
        //
        //  how many destination bytes are needed to hold the source data
        //  of padss->cbSrcLength bytes
        //
        //  always round UP (since G711 can be computed exactly, don't
        //  round. it is simply a 2:1 compression ratio--and we drop partial
        //  samples)
        //
        case ACM_STREAMSIZEF_SOURCE:
            cb = padss->cbSrcLength;

            switch (pwfxSrc->wFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    cb = PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)pwfxSrc, cb);
                    cb = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)pwfxSrc, cb);

                    if (0 == cb)
                    {
                        return (ACMERR_NOTPOSSIBLE);
                    }

                    cb = (cb / 2);
                    break;

                case WAVE_FORMAT_ALAW:
                case WAVE_FORMAT_MULAW:
                    cb = G711_BYTESTOSAMPLES(pwfxSrc, cb);
                    cb = G711_SAMPLESTOBYTES(pwfxSrc, cb);

                    if (0 == cb)
                    {
                        return (ACMERR_NOTPOSSIBLE);
                    }

                    if (WAVE_FORMAT_PCM == pwfxDst->wFormatTag)
                    {
                        // Make sure we won't overflow padss->cbDstLength
                        if ((0xFFFFFFFFL / 2) < cb)
                        {
                            return (ACMERR_NOTPOSSIBLE);
                        }
                        cb = (cb * 2);
                    }
                    break;
            }

            padss->cbDstLength = cb;
            return (MMSYSERR_NOERROR);


        //
        //  how many source bytes can be encoded into a
        //  destination buffer of padss->cbDstLength bytes
        //
        //  always round DOWN (drop partial samples)
        //
        case ACM_STREAMSIZEF_DESTINATION:
            cb = padss->cbDstLength;

            switch (pwfxDst->wFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    cb = PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)pwfxDst, cb);
                    cb = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)pwfxDst, cb);

                    cb = (cb / 2);

                    if (0 == cb)
                    {
                        return (ACMERR_NOTPOSSIBLE);
                    }

                    break;

                case WAVE_FORMAT_ALAW:
                case WAVE_FORMAT_MULAW:
                    cb = G711_BYTESTOSAMPLES(pwfxDst, cb);
                    cb = G711_SAMPLESTOBYTES(pwfxDst, cb);

                    if (0 == cb)
                    {
                        return (ACMERR_NOTPOSSIBLE);
                    }

                    if (WAVE_FORMAT_PCM == pwfxSrc->wFormatTag)
                    {
                        // Make sure we won't overflow padss->cbDstLength
                        if ((0xFFFFFFFFL / 2) < cb)
                        {
                            return (ACMERR_NOTPOSSIBLE);
                        }
                        cb = (cb * 2);
                    }
                    break;
            }

            padss->cbSrcLength = cb;
            return (MMSYSERR_NOERROR);
    }

    //
    //  if the query type is not understood by this driver, then we need
    //  to return MMSYSERR_NOTSUPPORTED.
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdStreamSize()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT DriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      the driver is opened, through the OpenDriver API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNEXPORT DriverProc
(
    DWORD_PTR               dwId,
    HDRVR                   hdrvr,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT             lr;
    PDRIVERINSTANCE     pdi;

    //
    //  make pdi either NULL or a valid instance pointer. note that dwId
    //  is 0 for several of the DRV_* messages (ie DRV_LOAD, DRV_OPEN...)
    //  see acmdDriverOpen for information on what dwId is for other
    //  messages (instance data).
    //
    pdi = (PDRIVERINSTANCE)dwId;

    switch (uMsg)
    {
        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_LOAD:
#ifdef _WIN32
            DbgInitialize(TRUE);
#endif
            return(1L);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_FREE:
            return (1L);


        //
        //  lParam1: Not used. Ignore this argument.
        //
        //  lParam2: Pointer to ACMDRVOPENDESC (or NULL).
        //
        case DRV_OPEN:
            lr = acmdDriverOpen(hdrvr, (LPACMDRVOPENDESC)lParam2);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_CLOSE:
            lr = acmdDriverClose(pdi);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_INSTALL:
            return ((LRESULT)DRVCNF_RESTART);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_REMOVE:
            return ((LRESULT)DRVCNF_RESTART);



        //
        //  lParam1: Not used.
        //
        //  lParam2: Not used.
        //
        case DRV_QUERYCONFIGURE:
            //
            //  set up lParam1 and lParam2 to values that can be used by
            //  acmdDriverConfigure to know that it is being 'queried'
            //  for configuration support.
            //
            lParam1 = -1L;
            lParam2 = 0L;

            //--fall through--//

        //
        //  lParam1: Handle to parent window for the configuration dialog
        //           box.
        //
        //  lParam2: Optional pointer to DRVCONFIGINFO structure.
        //
        case DRV_CONFIGURE:
            lr = acmdDriverConfigure(pdi, (HWND)lParam1, (LPDRVCONFIGINFO)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to ACMDRIVERDETAILS structure.
        //
        //  lParam2: Size in bytes of ACMDRIVERDETAILS stucture passed.
        //
        case ACMDM_DRIVER_DETAILS:
            lr = acmdDriverDetails(pdi, (LPACMDRIVERDETAILS)lParam1);
            return (lr);

        //
        //  lParam1: Handle to parent window to use if displaying your own
        //           about box.
        //
        //  lParam2: Not used.
        //
        case ACMDM_DRIVER_ABOUT:
            lr = acmdDriverAbout(pdi, (HWND)lParam1);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVFORMATSUGGEST structure.
        //
        //  lParam2: Not used.
        //
       case ACMDM_FORMAT_SUGGEST:
            lr = acmdFormatSuggest(pdi, (LPACMDRVFORMATSUGGEST)lParam1);
            return (lr);


        //
        //  lParam1: Pointer to FORMATTAGDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMATTAG_DETAILS:
            lr = acmdFormatTagDetails(pdi, (LPACMFORMATTAGDETAILS)lParam1, (DWORD)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to FORMATDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMAT_DETAILS:
            lr = acmdFormatDetails(pdi, (LPACMFORMATDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not used.
        //
        case ACMDM_STREAM_OPEN:
            lr = acmdStreamOpen(pdi, (LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not Used.
        //
        case ACMDM_STREAM_CLOSE:
            lr = acmdStreamClose((LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMSIZE structure.
        //
        case ACMDM_STREAM_SIZE:
            lr = acmdStreamSize((LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMSIZE)lParam2);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMHEADER structure.
        //
        case ACMDM_STREAM_CONVERT:
        {
            PSTREAMINSTANCE         psi;
            LPACMDRVSTREAMINSTANCE  padsi;
            LPACMDRVSTREAMHEADER    padsh;

            //
            //  our stream instance data is a pointer to the conversion
            //  procedure needed to convert the pwfxSrc data to pwfxDst.
            //  the correct procedure to use was decided in acmdStreamOpen
            //
            padsi = (LPACMDRVSTREAMINSTANCE)lParam1;
            padsh = (LPACMDRVSTREAMHEADER)lParam2;

            psi   = (PSTREAMINSTANCE)padsi->dwDriver;

            lr = psi->fnConvert(padsi, padsh);
            return (lr);
        }
    }

    //
    //  if we are executing the following code, then this ACM driver does not
    //  handle the message that was sent. there are two ranges of messages
    //  we need to deal with:
    //
    //  o   ACM specific driver messages: if an ACM driver does not answer a
    //      message sent in the ACM driver message range, then it must
    //      return MMSYSERR_NOTSUPPORTED. this applies to the 'user'
    //      range as well (for consistency).
    //
    //  o   other installable driver messages: if an ACM driver does not
    //      answer a message that is NOT in the ACM driver message range,
    //      then it must call DefDriverProc and return that result.
    //      the exception to this is ACM driver procedures installed as
    //      ACM_DRIVERADDF_FUNCTION through acmDriverAdd. in this case,
    //      the driver procedure should conform to the ACMDRIVERPROC
    //      prototype and also return zero instead of calling DefDriverProc.
    //
    if (uMsg >= ACMDM_USER)
        return (MMSYSERR_NOTSUPPORTED);
    else
        return (DefDriverProc(dwId, hdrvr, uMsg, lParam1, lParam2));
} // DriverProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\g711\g711.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1996 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  g711.h
//
//  Description:
//      This file contains prototypes for the filtering routines.
//
//
//==========================================================================;

#ifndef _INC_G711
#define _INC_G711                   // #defined if g711.h has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern 
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif


//
//
//
#define G711_MAX_CHANNELS               2
#define G711_BITS_PER_SAMPLE            8
#define G711_WFX_EXTRA_BYTES            0


//
//  macros to compute block alignment and convert between samples and bytes
//  of G711 data. note that these macros assume:
//
//      wBitsPerSample  =  8
//      nChannels       =  1 or 2
//
//  the pwfx argument is a pointer to a WAVEFORMATEX structure.
//
#define G711_BLOCKALIGNMENT(pwfx)       (UINT)(pwfx->nChannels)
#define G711_AVGBYTESPERSEC(pwfx)       (DWORD)((pwfx)->nSamplesPerSec * (pwfx)->nChannels)
#define G711_BYTESTOSAMPLES(pwfx, dw)   (DWORD)(dw / G711_BLOCKALIGNMENT(pwfx))
#define G711_SAMPLESTOBYTES(pwfx, dw)   (DWORD)(dw * G711_BLOCKALIGNMENT(pwfx))

 
//
//  function prototypes from G711.C
//
// 
LRESULT FNGLOBAL AlawToPcm
(
 LPACMDRVSTREAMINSTANCE		padsi,
 LPACMDRVSTREAMHEADER		padsh
);

LRESULT FNGLOBAL PcmToAlaw
(
 LPACMDRVSTREAMINSTANCE		padsi,
 LPACMDRVSTREAMHEADER		padsh
);

LRESULT FNGLOBAL UlawToPcm
(
 LPACMDRVSTREAMINSTANCE		padsi,
 LPACMDRVSTREAMHEADER		padsh
);

LRESULT FNGLOBAL PcmToUlaw
(
 LPACMDRVSTREAMINSTANCE		padsi,
 LPACMDRVSTREAMHEADER		padsh
);

LRESULT FNGLOBAL AlawToUlaw
(
 LPACMDRVSTREAMINSTANCE		padsi,
 LPACMDRVSTREAMHEADER		padsh
);

LRESULT FNGLOBAL UlawToAlaw
(
 LPACMDRVSTREAMINSTANCE		padsi,
 LPACMDRVSTREAMHEADER		padsh
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _INC_G711
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\g711\g711.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  g711.c
//
//  Description:
//      This file contains encode and decode routines for
//      CCITT Rec. G.711 (A-law and u-law).
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "codec.h"
#include "g711.h"

#include "debug.h"


typedef BYTE HUGE *HPBYTE;
typedef WORD HUGE *HPWORD;


//
//
//
extern const SHORT BCODE AlawToPcmTable[256];
extern const SHORT BCODE UlawToPcmTable[256];
extern const BYTE BCODE AlawToUlawTable[256];
extern const BYTE BCODE UlawToAlawTable[256];


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT FNGLOBAL AlawToUlaw
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message when
//      converting from A-law to u-law.  This is the whole purpose
//      of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//  
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//      
//
//  History:
//      08/01/93    Created. 
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AlawToUlaw
(
    LPACMDRVSTREAMINSTANCE      padsi,
    LPACMDRVSTREAMHEADER        padsh
)
{
    HPBYTE  hpbSrc, hpbDst;
    DWORD   cb;
    DWORD   i;
    PSTREAMINSTANCE     psi;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    cb = padsh->cbSrcLength;
    cb = G711_BYTESTOSAMPLES(padsi->pwfxSrc, cb);
    cb = G711_SAMPLESTOBYTES(padsi->pwfxSrc, cb);
    padsh->cbSrcLengthUsed = cb;

    if (cb > padsh->cbDstLength) return (ACMERR_NOTPOSSIBLE);

    hpbSrc = (HPBYTE) padsh->pbSrc;
    hpbDst = (HPBYTE) padsh->pbDst;
    
    for (i=cb; i>0; i--)
        *(hpbDst++) = AlawToUlawTable[*(hpbSrc++)];
        
    //
    //  because the actual length of the converted data may not be the
    //  exact same amount as the estimate we gave in codecQueryBufferSize,
    //  we need to fill in the actual length we used for the destination
    //  buffer.
    //
    padsh->cbDstLengthUsed = cb;

    return (MMSYSERR_NOERROR);
    
} // AlawToUlaw()


//--------------------------------------------------------------------------;
//
//  LRESULT FNGLOBAL UlawToAlaw
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message when
//      converting from u-law to A-law. This is the whole purpose
//      of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//  
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//
//  History:
//      08/01/93    Created. 
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL UlawToAlaw
(
    LPACMDRVSTREAMINSTANCE      padsi,
    LPACMDRVSTREAMHEADER        padsh
)
{
    HPBYTE  hpbSrc, hpbDst;
    DWORD   cb;
    DWORD   i;
    PSTREAMINSTANCE     psi;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    cb = padsh->cbSrcLength;
    cb = G711_BYTESTOSAMPLES(padsi->pwfxSrc, cb);
    cb = G711_SAMPLESTOBYTES(padsi->pwfxSrc, cb);
    padsh->cbSrcLengthUsed = cb;
    
    if (cb > padsh->cbDstLength) return (ACMERR_NOTPOSSIBLE);

    hpbSrc = (HPBYTE) padsh->pbSrc;
    hpbDst = (HPBYTE) padsh->pbDst;
    
    for (i=cb; i>0; i--)
        *(hpbDst++) = UlawToAlawTable[*(hpbSrc++)];

    //
    //  because the actual length of the converted data may not be the
    //  exact same amount as the estimate we gave in codecQueryBufferSize,
    //  we need to fill in the actual length we used for the destination
    //  buffer.
    //
    padsh->cbDstLengthUsed = cb;
        
    return (MMSYSERR_NOERROR);
    
} // UlawToAlaw()


//--------------------------------------------------------------------------;
//
//  LRESULT FNGLOBAL AlawToPcm
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message when
//      converting from A-law to PCM. This is the whole purpose
//      of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//  
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//
//  History:
//      07/28/93    Created. 
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AlawToPcm
(
    LPACMDRVSTREAMINSTANCE      padsi,
    LPACMDRVSTREAMHEADER        padsh
)
{
    HPWORD  hpwDst;
    HPBYTE  hpbSrc;
    DWORD   cb;
    DWORD   cSamples;
    DWORD   i;
    PSTREAMINSTANCE     psi;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    cb = padsh->cbSrcLength;
    cSamples = G711_BYTESTOSAMPLES(padsi->pwfxSrc, cb);
    
    cb = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)padsi->pwfxDst, cSamples);
    if (cb > padsh->cbDstLength) return (ACMERR_NOTPOSSIBLE);
    
    cb = G711_SAMPLESTOBYTES(padsi->pwfxSrc, cSamples);
    padsh->cbSrcLengthUsed = cb;

    hpbSrc = (HPBYTE) padsh->pbSrc;
    hpwDst = (HPWORD) padsh->pbDst;
    
    for ( i=cb; i>0; i--)
        *(hpwDst++) = AlawToPcmTable[*(hpbSrc++)];

    //
    //  because the actual length of the converted data may not be the
    //  exact same amount as the estimate we gave in codecQueryBufferSize,
    //  we need to fill in the actual length we used for the destination
    //  buffer.
    //
    padsh->cbDstLengthUsed = (DWORD)(((HPBYTE)hpwDst) - (HPBYTE)padsh->pbDst);

    return (MMSYSERR_NOERROR);

} // AlawToPcm()


//--------------------------------------------------------------------------;
//
//  LRESULT FNGLOBAL PcmToAlaw
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message when
//      converting from PCM to A-law. This is the whole purpose
//      of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//  
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//
//  History:
//      07/28/93    Created. 
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL PcmToAlaw
(
    LPACMDRVSTREAMINSTANCE      padsi,
    LPACMDRVSTREAMHEADER        padsh
)
{
    HPBYTE                  hpbDst;
    HPWORD                  hpwSrc;
    DWORD                   cb;
    DWORD		    cSamples;
    DWORD                   i;
    
    signed short int        wSample;
    BYTE                    alaw;
    PSTREAMINSTANCE     psi;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    cb = padsh->cbSrcLength;
    cSamples = PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)padsi->pwfxSrc, cb);
    
    cb = G711_SAMPLESTOBYTES(padsi->pwfxDst, cSamples);
    if (cb > padsh->cbDstLength) return (ACMERR_NOTPOSSIBLE);

    cb = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)padsi->pwfxSrc, cSamples);
    padsh->cbSrcLengthUsed = cb;

    // hpwSrc, hpdDst will walk thru src and dst buffers
    hpbDst = (HPBYTE) padsh->pbDst;
    hpwSrc = (HPWORD) padsh->pbSrc;
    
    //
    //
    // Compression from 16-bit PCM
    //
    //     
    
    // Walk thru the source buffer.  Since the source buffer has 16-bit PCM we
    // need to convert cb/2 samples.
    for (i=cb/2; i>0; i--)
        {
        
        //  Get a signed 16-bit PCM sample from the src buffer
        wSample = (signed short int) *(hpwSrc++);
        
        // We'll init our A-law value per the sign of the PCM sample.  A-law
        // characters have the MSB=1 for positive PCM data.  Also, we'll
        // convert our signed 16-bit PCM value to it's absolute value and
        // then work on that to get the rest of the A-law character bits.
        if (wSample < 0)
            {
            alaw = 0x00;
            wSample = -wSample;
            if (wSample < 0) wSample = 0x7FFF;
            }
        else
            {
            alaw = 0x80;
            }
                            
        // Now we test the PCM sample amplitude and create the A-law character.
        // Study the CCITT A-law for more detail.
        
        if (wSample >= 2048)
            // 2048 <= wSample < 32768
            {
            if (wSample >= 8192)
                // 8192 <= wSample < 32768
                {
                if (wSample >= 16384)
                    // 16384 <= wSample < 32768
                    {
                    alaw |= 0x70 | ((wSample >> 10) & 0x0F);
                    }
                    
                else
                    // 8192 <= wSample < 16384
                    {
                    alaw |= 0x60 | ((wSample >> 9) & 0x0F);
                    }
                }
            else
                // 2048 <= wSample < 8192
                {
                
                if (wSample >= 4096)
                    // 4096 <= wSample < 8192
                    {
                    alaw |= 0x50 | ((wSample >> 8) & 0x0F);
                    }
                    
                else
                    // 2048 <= wSample < 4096
                    {
                    alaw |= 0x40 | ((wSample >> 7) & 0x0F);
                    }
                }
            }
        else
            // 0 <= wSample < 2048
            {
            if (wSample >= 512)
                // 512 <= wSample < 2048
                {
                
                if (wSample >= 1024)
                    // 1024 <= wSample < 2048
                    {
                    alaw |= 0x30 | ((wSample >> 6) & 0x0F);
                    }
                
                else
                    // 512 <= wSample < 1024
                    {
                    alaw |= 0x20 | ((wSample >> 5) & 0x0F);
                    }
                }
            else
                    // 0 <= wSample < 512
                    {
                    alaw |= 0x00 | ((wSample >> 4) & 0x1F);
                    }
            }
                
        
            
        *(hpbDst++) = alaw ^ 0x55;      // Invert even bits
        }   // end for
    
    //
    //  because the actual length of the converted data may not be the
    //  exact same amount as the estimate we gave in codecQueryBufferSize,
    //  we need to fill in the actual length we used for the destination
    //  buffer.
    //
    padsh->cbDstLengthUsed = (DWORD)(hpbDst - (HPBYTE)padsh->pbDst);

    return (MMSYSERR_NOERROR);
    
} // PcmToAlaw()


//--------------------------------------------------------------------------;
//
//  LRESULT FNGLOBAL UlawToPcm
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message when
//      converting from u-law to PCM. This is the whole purpose
//      of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//  
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//
//  History:
//      08/01/93    Created. 
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL UlawToPcm
(
    LPACMDRVSTREAMINSTANCE      padsi,
    LPACMDRVSTREAMHEADER        padsh
)
{
    HPBYTE  hpbSrc;
    HPWORD  hpwDst;
    DWORD   cb;
    DWORD   cSamples;
    DWORD   i;
    PSTREAMINSTANCE     psi;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    cb = padsh->cbSrcLength;
    cSamples = G711_BYTESTOSAMPLES(padsi->pwfxSrc, cb);
    
    cb = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)padsi->pwfxDst, cSamples);
    if (cb > padsh->cbDstLength) return (ACMERR_NOTPOSSIBLE);

    cb = G711_SAMPLESTOBYTES(padsi->pwfxSrc, cSamples);
    padsh->cbSrcLengthUsed = cb;

    hpbSrc = (HPBYTE) padsh->pbSrc;
    hpwDst = (HPWORD) padsh->pbDst;
    
    for ( i=cb; i>0; i--)
        *(hpwDst++) = UlawToPcmTable[*(hpbSrc++)];

    //
    //  because the actual length of the converted data may not be the
    //  exact same amount as the estimate we gave in codecQueryBufferSize,
    //  we need to fill in the actual length we used for the destination
    //  buffer.
    //
    padsh->cbDstLengthUsed = (DWORD)(((HPBYTE)hpwDst) - (HPBYTE)padsh->pbDst);

    return (MMSYSERR_NOERROR);

} // UlawToPcm()


//--------------------------------------------------------------------------;
//
//  LRESULT FNGLOBAL PcmToUlaw
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message when
//      converting from PCM to u-law. This is the whole purpose
//      of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//  
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//
//  History:
//      08/01/93    Created. 
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL PcmToUlaw
(
    LPACMDRVSTREAMINSTANCE      padsi,
    LPACMDRVSTREAMHEADER        padsh
)
{

    HPWORD                  hpwSrc;
    HPBYTE                  hpbDst;
    DWORD                   cb;
    DWORD		    cSamples;
    DWORD                   i;
    
    signed short int        wSample;
    BYTE                    ulaw;
    PSTREAMINSTANCE     psi;
    
    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    //
    // For now we are using a straight-forward/brute-force method
    // for converting from 16-bit PCM to u-law.  This can probably
    // be made more efficient if some thought is put into it...
    //

    cb = padsh->cbSrcLength;
    cSamples = PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)padsi->pwfxSrc, cb);
    
    cb = G711_SAMPLESTOBYTES(padsi->pwfxDst, cSamples);
    if (cb > padsh->cbDstLength) return (ACMERR_NOTPOSSIBLE);
    
    cb = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)padsi->pwfxSrc, cSamples);
    padsh->cbSrcLengthUsed = cb;

    // hpwSrc and hpbDst will walk thru the src and dst buffers
    hpwSrc = (HPWORD) padsh->pbSrc;
    hpbDst = (HPBYTE) padsh->pbDst;
     
    //
    //
    // Handle compression from 16-bit PCM
    //
    //     
    
    // Walk thru the source buffer.  Since the source buffer has 16-bit PCM we
    // need to convert cb/2 samples.
    for (i=cb/2; i>0; i--)
        {
        
        //  Get a signed 16-bit PCM sample from the src buffer
        wSample = (signed short int) *(hpwSrc++);
        
        // We'll init our u-law value per the sign of the PCM sample.  u-law
        // characters have the MSB=1 for positive PCM data.  Also, we'll
        // convert our signed 16-bit PCM value to it's absolute value and
        // then work on that to get the rest of the u-law character bits.
        if (wSample < 0)
            {
            ulaw = 0x00;
            wSample = -wSample;
            if (wSample < 0) wSample = 0x7FFF;
            }
        else
            {
            ulaw = 0x80;
            }
            
        // For now, let's shift this 16-bit value
        //  so that it is within the range defined
        //  by CCITT u-law.
        wSample = wSample >> 2;
                            
        // Now we test the PCM sample amplitude and create the u-law character.
        // Study the CCITT u-law for more details.
        if (wSample >= 8159)
            goto Gotulaw;
        if (wSample >= 4063)
            {
            ulaw |= 0x00 + 15-((wSample-4063)/256);
            goto Gotulaw;
            }
        if (wSample >= 2015)
            {
            ulaw |= 0x10 + 15-((wSample-2015)/128);
            goto Gotulaw;
            }
        if (wSample >= 991)
            {
            ulaw |= 0x20 + 15-((wSample-991)/64);
            goto Gotulaw;
            }
        if (wSample >= 479)
            {
            ulaw |= 0x30 + 15-((wSample-479)/32);
            goto Gotulaw;
            }
        if (wSample >= 223)
            {
            ulaw |= 0x40 + 15-((wSample-223)/16);
            goto Gotulaw;
            }
        if (wSample >= 95)
            {
            ulaw |= 0x50 + 15-((wSample-95)/8);
            goto Gotulaw;
            }
        if (wSample >= 31)
            {
            ulaw |= 0x60 + 15-((wSample-31)/4);
            goto Gotulaw;
            }
        ulaw |= 0x70 + 15-((wSample)/2);
        
Gotulaw:
        *(hpbDst++) = ulaw;
        }


    //
    //  because the actual length of the converted data may not be the
    //  exact same amount as the estimate we gave in codecQueryBufferSize,
    //  we need to fill in the actual length we used for the destination
    //  buffer.
    //
    padsh->cbDstLengthUsed = (DWORD)(hpbDst - (HPBYTE) padsh->pbDst);

    return (MMSYSERR_NOERROR);
    
} // PcmToUlaw()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  Name:
//      AlawToPcmTable
//
//
//  Description:
//      this array maps A-law characters to 16-bit PCM
//
//      
//  Arguments:
//      the index into the array is an A-law character
//
//  Return:
//      an element of the array is a 16-bit PCM value
//
//  Notes:
//
//
//  History:
//      07/28/93    Created.
//
//
//--------------------------------------------------------------------------;
const SHORT BCODE AlawToPcmTable[256] =
    {
         -5504,         // y[00]=   -688
         -5248,         // y[01]=   -656
         -6016,         // y[02]=   -752
         -5760,         // y[03]=   -720
         -4480,         // y[04]=   -560
         -4224,         // y[05]=   -528
         -4992,         // y[06]=   -624
         -4736,         // y[07]=   -592
         -7552,         // y[08]=   -944
         -7296,         // y[09]=   -912
         -8064,         // y[0a]=  -1008
         -7808,         // y[0b]=   -976
         -6528,         // y[0c]=   -816
         -6272,         // y[0d]=   -784
         -7040,         // y[0e]=   -880
         -6784,         // y[0f]=   -848
         -2752,         // y[10]=   -344
         -2624,         // y[11]=   -328
         -3008,         // y[12]=   -376
         -2880,         // y[13]=   -360
         -2240,         // y[14]=   -280
         -2112,         // y[15]=   -264
         -2496,         // y[16]=   -312
         -2368,         // y[17]=   -296
         -3776,         // y[18]=   -472
         -3648,         // y[19]=   -456
         -4032,         // y[1a]=   -504
         -3904,         // y[1b]=   -488
         -3264,         // y[1c]=   -408
         -3136,         // y[1d]=   -392
         -3520,         // y[1e]=   -440
         -3392,         // y[1f]=   -424
        -22016,         // y[20]=  -2752
        -20992,         // y[21]=  -2624
        -24064,         // y[22]=  -3008
        -23040,         // y[23]=  -2880
        -17920,         // y[24]=  -2240
        -16896,         // y[25]=  -2112
        -19968,         // y[26]=  -2496
        -18944,         // y[27]=  -2368
        -30208,         // y[28]=  -3776
        -29184,         // y[29]=  -3648
        -32256,         // y[2a]=  -4032
        -31232,         // y[2b]=  -3904
        -26112,         // y[2c]=  -3264
        -25088,         // y[2d]=  -3136
        -28160,         // y[2e]=  -3520
        -27136,         // y[2f]=  -3392
        -11008,         // y[30]=  -1376
        -10496,         // y[31]=  -1312
        -12032,         // y[32]=  -1504
        -11520,         // y[33]=  -1440
         -8960,         // y[34]=  -1120
         -8448,         // y[35]=  -1056
         -9984,         // y[36]=  -1248
         -9472,         // y[37]=  -1184
        -15104,         // y[38]=  -1888
        -14592,         // y[39]=  -1824
        -16128,         // y[3a]=  -2016
        -15616,         // y[3b]=  -1952
        -13056,         // y[3c]=  -1632
        -12544,         // y[3d]=  -1568
        -14080,         // y[3e]=  -1760
        -13568,         // y[3f]=  -1696
          -344,         // y[40]=    -43
          -328,         // y[41]=    -41
          -376,         // y[42]=    -47
          -360,         // y[43]=    -45
          -280,         // y[44]=    -35
          -264,         // y[45]=    -33
          -312,         // y[46]=    -39
          -296,         // y[47]=    -37
          -472,         // y[48]=    -59
          -456,         // y[49]=    -57
          -504,         // y[4a]=    -63
          -488,         // y[4b]=    -61
          -408,         // y[4c]=    -51
          -392,         // y[4d]=    -49
          -440,         // y[4e]=    -55
          -424,         // y[4f]=    -53
           -88,         // y[50]=    -11
           -72,         // y[51]=     -9
          -120,         // y[52]=    -15
          -104,         // y[53]=    -13
           -24,         // y[54]=     -3
            -8,         // y[55]=     -1
           -56,         // y[56]=     -7
           -40,         // y[57]=     -5
          -216,         // y[58]=    -27
          -200,         // y[59]=    -25
          -248,         // y[5a]=    -31
          -232,         // y[5b]=    -29
          -152,         // y[5c]=    -19
          -136,         // y[5d]=    -17
          -184,         // y[5e]=    -23
          -168,         // y[5f]=    -21
         -1376,         // y[60]=   -172
         -1312,         // y[61]=   -164
         -1504,         // y[62]=   -188
         -1440,         // y[63]=   -180
         -1120,         // y[64]=   -140
         -1056,         // y[65]=   -132
         -1248,         // y[66]=   -156
         -1184,         // y[67]=   -148
         -1888,         // y[68]=   -236
         -1824,         // y[69]=   -228
         -2016,         // y[6a]=   -252
         -1952,         // y[6b]=   -244
         -1632,         // y[6c]=   -204
         -1568,         // y[6d]=   -196
         -1760,         // y[6e]=   -220
         -1696,         // y[6f]=   -212
          -688,         // y[70]=    -86
          -656,         // y[71]=    -82
          -752,         // y[72]=    -94
          -720,         // y[73]=    -90
          -560,         // y[74]=    -70
          -528,         // y[75]=    -66
          -624,         // y[76]=    -78
          -592,         // y[77]=    -74
          -944,         // y[78]=   -118
          -912,         // y[79]=   -114
         -1008,         // y[7a]=   -126
          -976,         // y[7b]=   -122
          -816,         // y[7c]=   -102
          -784,         // y[7d]=    -98
          -880,         // y[7e]=   -110
          -848,         // y[7f]=   -106
          5504,         // y[80]=    688
          5248,         // y[81]=    656
          6016,         // y[82]=    752
          5760,         // y[83]=    720
          4480,         // y[84]=    560
          4224,         // y[85]=    528
          4992,         // y[86]=    624
          4736,         // y[87]=    592
          7552,         // y[88]=    944
          7296,         // y[89]=    912
          8064,         // y[8a]=   1008
          7808,         // y[8b]=    976
          6528,         // y[8c]=    816
          6272,         // y[8d]=    784
          7040,         // y[8e]=    880
          6784,         // y[8f]=    848
          2752,         // y[90]=    344
          2624,         // y[91]=    328
          3008,         // y[92]=    376
          2880,         // y[93]=    360
          2240,         // y[94]=    280
          2112,         // y[95]=    264
          2496,         // y[96]=    312
          2368,         // y[97]=    296
          3776,         // y[98]=    472
          3648,         // y[99]=    456
          4032,         // y[9a]=    504
          3904,         // y[9b]=    488
          3264,         // y[9c]=    408
          3136,         // y[9d]=    392
          3520,         // y[9e]=    440
          3392,         // y[9f]=    424
         22016,         // y[a0]=   2752
         20992,         // y[a1]=   2624
         24064,         // y[a2]=   3008
         23040,         // y[a3]=   2880
         17920,         // y[a4]=   2240
         16896,         // y[a5]=   2112
         19968,         // y[a6]=   2496
         18944,         // y[a7]=   2368
         30208,         // y[a8]=   3776
         29184,         // y[a9]=   3648
         32256,         // y[aa]=   4032
         31232,         // y[ab]=   3904
         26112,         // y[ac]=   3264
         25088,         // y[ad]=   3136
         28160,         // y[ae]=   3520
         27136,         // y[af]=   3392
         11008,         // y[b0]=   1376
         10496,         // y[b1]=   1312
         12032,         // y[b2]=   1504
         11520,         // y[b3]=   1440
          8960,         // y[b4]=   1120
          8448,         // y[b5]=   1056
          9984,         // y[b6]=   1248
          9472,         // y[b7]=   1184
         15104,         // y[b8]=   1888
         14592,         // y[b9]=   1824
         16128,         // y[ba]=   2016
         15616,         // y[bb]=   1952
         13056,         // y[bc]=   1632
         12544,         // y[bd]=   1568
         14080,         // y[be]=   1760
         13568,         // y[bf]=   1696
           344,         // y[c0]=     43
           328,         // y[c1]=     41
           376,         // y[c2]=     47
           360,         // y[c3]=     45
           280,         // y[c4]=     35
           264,         // y[c5]=     33
           312,         // y[c6]=     39
           296,         // y[c7]=     37
           472,         // y[c8]=     59
           456,         // y[c9]=     57
           504,         // y[ca]=     63
           488,         // y[cb]=     61
           408,         // y[cc]=     51
           392,         // y[cd]=     49
           440,         // y[ce]=     55
           424,         // y[cf]=     53
            88,         // y[d0]=     11
            72,         // y[d1]=      9
           120,         // y[d2]=     15
           104,         // y[d3]=     13
            24,         // y[d4]=      3
             8,         // y[d5]=      1
            56,         // y[d6]=      7
            40,         // y[d7]=      5
           216,         // y[d8]=     27
           200,         // y[d9]=     25
           248,         // y[da]=     31
           232,         // y[db]=     29
           152,         // y[dc]=     19
           136,         // y[dd]=     17
           184,         // y[de]=     23
           168,         // y[df]=     21
          1376,         // y[e0]=    172
          1312,         // y[e1]=    164
          1504,         // y[e2]=    188
          1440,         // y[e3]=    180
          1120,         // y[e4]=    140
          1056,         // y[e5]=    132
          1248,         // y[e6]=    156
          1184,         // y[e7]=    148
          1888,         // y[e8]=    236
          1824,         // y[e9]=    228
          2016,         // y[ea]=    252
          1952,         // y[eb]=    244
          1632,         // y[ec]=    204
          1568,         // y[ed]=    196
          1760,         // y[ee]=    220
          1696,         // y[ef]=    212
           688,         // y[f0]=     86
           656,         // y[f1]=     82
           752,         // y[f2]=     94
           720,         // y[f3]=     90
           560,         // y[f4]=     70
           528,         // y[f5]=     66
           624,         // y[f6]=     78
           592,         // y[f7]=     74
           944,         // y[f8]=    118
           912,         // y[f9]=    114
          1008,         // y[fa]=    126
           976,         // y[fb]=    122
           816,         // y[fc]=    102
           784,         // y[fd]=     98
           880,         // y[fe]=    110
           848          // y[ff]=    106
    };
        
//--------------------------------------------------------------------------;
//
//  Name:
//      UlawToPcmTable
//
//
//  Description:
//      this array maps u-law characters to 16-bit PCM
//      
//  Arguments:
//      the index into the array is a u-law character
//
//  Return:
//      an element of the array is a 16-bit PCM value
//
//  Notes:
//
//
//  History:
//      07/28/93    Created.
//
//
//--------------------------------------------------------------------------;
const SHORT BCODE UlawToPcmTable[256] =
    {
        -32124,         // y[00]=  -8031
        -31100,         // y[01]=  -7775
        -30076,         // y[02]=  -7519
        -29052,         // y[03]=  -7263
        -28028,         // y[04]=  -7007
        -27004,         // y[05]=  -6751
        -25980,         // y[06]=  -6495
        -24956,         // y[07]=  -6239
        -23932,         // y[08]=  -5983
        -22908,         // y[09]=  -5727
        -21884,         // y[0a]=  -5471
        -20860,         // y[0b]=  -5215
        -19836,         // y[0c]=  -4959
        -18812,         // y[0d]=  -4703
        -17788,         // y[0e]=  -4447
        -16764,         // y[0f]=  -4191
        -15996,         // y[10]=  -3999
        -15484,         // y[11]=  -3871
        -14972,         // y[12]=  -3743
        -14460,         // y[13]=  -3615
        -13948,         // y[14]=  -3487
        -13436,         // y[15]=  -3359
        -12924,         // y[16]=  -3231
        -12412,         // y[17]=  -3103
        -11900,         // y[18]=  -2975
        -11388,         // y[19]=  -2847
        -10876,         // y[1a]=  -2719
        -10364,         // y[1b]=  -2591
         -9852,         // y[1c]=  -2463
         -9340,         // y[1d]=  -2335
         -8828,         // y[1e]=  -2207
         -8316,         // y[1f]=  -2079
         -7932,         // y[20]=  -1983
         -7676,         // y[21]=  -1919
         -7420,         // y[22]=  -1855
         -7164,         // y[23]=  -1791
         -6908,         // y[24]=  -1727
         -6652,         // y[25]=  -1663
         -6396,         // y[26]=  -1599
         -6140,         // y[27]=  -1535
         -5884,         // y[28]=  -1471
         -5628,         // y[29]=  -1407
         -5372,         // y[2a]=  -1343
         -5116,         // y[2b]=  -1279
         -4860,         // y[2c]=  -1215
         -4604,         // y[2d]=  -1151
         -4348,         // y[2e]=  -1087
         -4092,         // y[2f]=  -1023
         -3900,         // y[30]=   -975
         -3772,         // y[31]=   -943
         -3644,         // y[32]=   -911
         -3516,         // y[33]=   -879
         -3388,         // y[34]=   -847
         -3260,         // y[35]=   -815
         -3132,         // y[36]=   -783
         -3004,         // y[37]=   -751
         -2876,         // y[38]=   -719
         -2748,         // y[39]=   -687
         -2620,         // y[3a]=   -655
         -2492,         // y[3b]=   -623
         -2364,         // y[3c]=   -591
         -2236,         // y[3d]=   -559
         -2108,         // y[3e]=   -527
         -1980,         // y[3f]=   -495
         -1884,         // y[40]=   -471
         -1820,         // y[41]=   -455
         -1756,         // y[42]=   -439
         -1692,         // y[43]=   -423
         -1628,         // y[44]=   -407
         -1564,         // y[45]=   -391
         -1500,         // y[46]=   -375
         -1436,         // y[47]=   -359
         -1372,         // y[48]=   -343
         -1308,         // y[49]=   -327
         -1244,         // y[4a]=   -311
         -1180,         // y[4b]=   -295
         -1116,         // y[4c]=   -279
         -1052,         // y[4d]=   -263
          -988,         // y[4e]=   -247
          -924,         // y[4f]=   -231
          -876,         // y[50]=   -219
          -844,         // y[51]=   -211
          -812,         // y[52]=   -203
          -780,         // y[53]=   -195
          -748,         // y[54]=   -187
          -716,         // y[55]=   -179
          -684,         // y[56]=   -171
          -652,         // y[57]=   -163
          -620,         // y[58]=   -155
          -588,         // y[59]=   -147
          -556,         // y[5a]=   -139
          -524,         // y[5b]=   -131
          -492,         // y[5c]=   -123
          -460,         // y[5d]=   -115
          -428,         // y[5e]=   -107
          -396,         // y[5f]=    -99
          -372,         // y[60]=    -93
          -356,         // y[61]=    -89
          -340,         // y[62]=    -85
          -324,         // y[63]=    -81
          -308,         // y[64]=    -77
          -292,         // y[65]=    -73
          -276,         // y[66]=    -69
          -260,         // y[67]=    -65
          -244,         // y[68]=    -61
          -228,         // y[69]=    -57
          -212,         // y[6a]=    -53
          -196,         // y[6b]=    -49
          -180,         // y[6c]=    -45
          -164,         // y[6d]=    -41
          -148,         // y[6e]=    -37
          -132,         // y[6f]=    -33
          -120,         // y[70]=    -30
          -112,         // y[71]=    -28
          -104,         // y[72]=    -26
           -96,         // y[73]=    -24
           -88,         // y[74]=    -22
           -80,         // y[75]=    -20
           -72,         // y[76]=    -18
           -64,         // y[77]=    -16
           -56,         // y[78]=    -14
           -48,         // y[79]=    -12
           -40,         // y[7a]=    -10
           -32,         // y[7b]=     -8
           -24,         // y[7c]=     -6
           -16,         // y[7d]=     -4
            -8,         // y[7e]=     -2
             0,         // y[7f]=      0
         32124,         // y[80]=   8031
         31100,         // y[81]=   7775
         30076,         // y[82]=   7519
         29052,         // y[83]=   7263
         28028,         // y[84]=   7007
         27004,         // y[85]=   6751
         25980,         // y[86]=   6495
         24956,         // y[87]=   6239
         23932,         // y[88]=   5983
         22908,         // y[89]=   5727
         21884,         // y[8a]=   5471
         20860,         // y[8b]=   5215
         19836,         // y[8c]=   4959
         18812,         // y[8d]=   4703
         17788,         // y[8e]=   4447
         16764,         // y[8f]=   4191
         15996,         // y[90]=   3999
         15484,         // y[91]=   3871
         14972,         // y[92]=   3743
         14460,         // y[93]=   3615
         13948,         // y[94]=   3487
         13436,         // y[95]=   3359
         12924,         // y[96]=   3231
         12412,         // y[97]=   3103
         11900,         // y[98]=   2975
         11388,         // y[99]=   2847
         10876,         // y[9a]=   2719
         10364,         // y[9b]=   2591
          9852,         // y[9c]=   2463
          9340,         // y[9d]=   2335
          8828,         // y[9e]=   2207
          8316,         // y[9f]=   2079
          7932,         // y[a0]=   1983
          7676,         // y[a1]=   1919
          7420,         // y[a2]=   1855
          7164,         // y[a3]=   1791
          6908,         // y[a4]=   1727
          6652,         // y[a5]=   1663
          6396,         // y[a6]=   1599
          6140,         // y[a7]=   1535
          5884,         // y[a8]=   1471
          5628,         // y[a9]=   1407
          5372,         // y[aa]=   1343
          5116,         // y[ab]=   1279
          4860,         // y[ac]=   1215
          4604,         // y[ad]=   1151
          4348,         // y[ae]=   1087
          4092,         // y[af]=   1023
          3900,         // y[b0]=    975
          3772,         // y[b1]=    943
          3644,         // y[b2]=    911
          3516,         // y[b3]=    879
          3388,         // y[b4]=    847
          3260,         // y[b5]=    815
          3132,         // y[b6]=    783
          3004,         // y[b7]=    751
          2876,         // y[b8]=    719
          2748,         // y[b9]=    687
          2620,         // y[ba]=    655
          2492,         // y[bb]=    623
          2364,         // y[bc]=    591
          2236,         // y[bd]=    559
          2108,         // y[be]=    527
          1980,         // y[bf]=    495
          1884,         // y[c0]=    471
          1820,         // y[c1]=    455
          1756,         // y[c2]=    439
          1692,         // y[c3]=    423
          1628,         // y[c4]=    407
          1564,         // y[c5]=    391
          1500,         // y[c6]=    375
          1436,         // y[c7]=    359
          1372,         // y[c8]=    343
          1308,         // y[c9]=    327
          1244,         // y[ca]=    311
          1180,         // y[cb]=    295
          1116,         // y[cc]=    279
          1052,         // y[cd]=    263
           988,         // y[ce]=    247
           924,         // y[cf]=    231
           876,         // y[d0]=    219
           844,         // y[d1]=    211
           812,         // y[d2]=    203
           780,         // y[d3]=    195
           748,         // y[d4]=    187
           716,         // y[d5]=    179
           684,         // y[d6]=    171
           652,         // y[d7]=    163
           620,         // y[d8]=    155
           588,         // y[d9]=    147
           556,         // y[da]=    139
           524,         // y[db]=    131
           492,         // y[dc]=    123
           460,         // y[dd]=    115
           428,         // y[de]=    107
           396,         // y[df]=     99
           372,         // y[e0]=     93
           356,         // y[e1]=     89
           340,         // y[e2]=     85
           324,         // y[e3]=     81
           308,         // y[e4]=     77
           292,         // y[e5]=     73
           276,         // y[e6]=     69
           260,         // y[e7]=     65
           244,         // y[e8]=     61
           228,         // y[e9]=     57
           212,         // y[ea]=     53
           196,         // y[eb]=     49
           180,         // y[ec]=     45
           164,         // y[ed]=     41
           148,         // y[ee]=     37
           132,         // y[ef]=     33
           120,         // y[f0]=     30
           112,         // y[f1]=     28
           104,         // y[f2]=     26
            96,         // y[f3]=     24
            88,         // y[f4]=     22
            80,         // y[f5]=     20
            72,         // y[f6]=     18
            64,         // y[f7]=     16
            56,         // y[f8]=     14
            48,         // y[f9]=     12
            40,         // y[fa]=     10
            32,         // y[fb]=      8
            24,         // y[fc]=      6
            16,         // y[fd]=      4
             8,         // y[fe]=      2
             0          // y[ff]=      0
    };
        
//--------------------------------------------------------------------------;
//
//  Name:
//      AlawToUlawTable
//
//
//  Description:
//      this array maps A-law characters to u-law characters
//      
//  Arguments:
//      the index into the array is an A-law character
//
//  Return:
//      an element of the array is a u-law character
//
//  Notes:
//
//
//  History:
//      08/01/93    Created.
//
//
//--------------------------------------------------------------------------;
const BYTE BCODE AlawToUlawTable[256] =
    {
        0x2a,           // A-law[00] ==> u-law[2a]
        0x2b,           // A-law[01] ==> u-law[2b]
        0x28,           // A-law[02] ==> u-law[28]
        0x29,           // A-law[03] ==> u-law[29]
        0x2e,           // A-law[04] ==> u-law[2e]
        0x2f,           // A-law[05] ==> u-law[2f]
        0x2c,           // A-law[06] ==> u-law[2c]
        0x2d,           // A-law[07] ==> u-law[2d]
        0x22,           // A-law[08] ==> u-law[22]
        0x23,           // A-law[09] ==> u-law[23]
        0x20,           // A-law[0a] ==> u-law[20]
        0x21,           // A-law[0b] ==> u-law[21]
        0x26,           // A-law[0c] ==> u-law[26]
        0x27,           // A-law[0d] ==> u-law[27]
        0x24,           // A-law[0e] ==> u-law[24]
        0x25,           // A-law[0f] ==> u-law[25]
        0x39,           // A-law[10] ==> u-law[39]
        0x3a,           // A-law[11] ==> u-law[3a]
        0x37,           // A-law[12] ==> u-law[37]
        0x38,           // A-law[13] ==> u-law[38]
        0x3d,           // A-law[14] ==> u-law[3d]
        0x3e,           // A-law[15] ==> u-law[3e]
        0x3b,           // A-law[16] ==> u-law[3b]
        0x3c,           // A-law[17] ==> u-law[3c]
        0x31,           // A-law[18] ==> u-law[31]
        0x32,           // A-law[19] ==> u-law[32]
        0x30,           // A-law[1a] ==> u-law[30]
        0x30,           // A-law[1b] ==> u-law[30]
        0x35,           // A-law[1c] ==> u-law[35]
        0x36,           // A-law[1d] ==> u-law[36]
        0x33,           // A-law[1e] ==> u-law[33]
        0x34,           // A-law[1f] ==> u-law[34]
        0x0a,           // A-law[20] ==> u-law[0a]
        0x0b,           // A-law[21] ==> u-law[0b]
        0x08,           // A-law[22] ==> u-law[08]
        0x09,           // A-law[23] ==> u-law[09]
        0x0e,           // A-law[24] ==> u-law[0e]
        0x0f,           // A-law[25] ==> u-law[0f]
        0x0c,           // A-law[26] ==> u-law[0c]
        0x0d,           // A-law[27] ==> u-law[0d]
        0x02,           // A-law[28] ==> u-law[02]
        0x03,           // A-law[29] ==> u-law[03]
        0x00,           // A-law[2a] ==> u-law[00]
        0x01,           // A-law[2b] ==> u-law[01]
        0x06,           // A-law[2c] ==> u-law[06]
        0x07,           // A-law[2d] ==> u-law[07]
        0x04,           // A-law[2e] ==> u-law[04]
        0x05,           // A-law[2f] ==> u-law[05]
        0x1a,           // A-law[30] ==> u-law[1a]
        0x1b,           // A-law[31] ==> u-law[1b]
        0x18,           // A-law[32] ==> u-law[18]
        0x19,           // A-law[33] ==> u-law[19]
        0x1e,           // A-law[34] ==> u-law[1e]
        0x1f,           // A-law[35] ==> u-law[1f]
        0x1c,           // A-law[36] ==> u-law[1c]
        0x1d,           // A-law[37] ==> u-law[1d]
        0x12,           // A-law[38] ==> u-law[12]
        0x13,           // A-law[39] ==> u-law[13]
        0x10,           // A-law[3a] ==> u-law[10]
        0x11,           // A-law[3b] ==> u-law[11]
        0x16,           // A-law[3c] ==> u-law[16]
        0x17,           // A-law[3d] ==> u-law[17]
        0x14,           // A-law[3e] ==> u-law[14]
        0x15,           // A-law[3f] ==> u-law[15]
        0x62,           // A-law[40] ==> u-law[62]
        0x63,           // A-law[41] ==> u-law[63]
        0x60,           // A-law[42] ==> u-law[60]
        0x61,           // A-law[43] ==> u-law[61]
        0x66,           // A-law[44] ==> u-law[66]
        0x67,           // A-law[45] ==> u-law[67]
        0x64,           // A-law[46] ==> u-law[64]
        0x65,           // A-law[47] ==> u-law[65]
        0x5d,           // A-law[48] ==> u-law[5d]
        0x5d,           // A-law[49] ==> u-law[5d]
        0x5c,           // A-law[4a] ==> u-law[5c]
        0x5c,           // A-law[4b] ==> u-law[5c]
        0x5f,           // A-law[4c] ==> u-law[5f]
        0x5f,           // A-law[4d] ==> u-law[5f]
        0x5e,           // A-law[4e] ==> u-law[5e]
        0x5e,           // A-law[4f] ==> u-law[5e]
        0x74,           // A-law[50] ==> u-law[74]
        0x76,           // A-law[51] ==> u-law[76]
        0x70,           // A-law[52] ==> u-law[70]
        0x72,           // A-law[53] ==> u-law[72]
        0x7c,           // A-law[54] ==> u-law[7c]
        0x7e,           // A-law[55] ==> u-law[7e]
        0x78,           // A-law[56] ==> u-law[78]
        0x7a,           // A-law[57] ==> u-law[7a]
        0x6a,           // A-law[58] ==> u-law[6a]
        0x6b,           // A-law[59] ==> u-law[6b]
        0x68,           // A-law[5a] ==> u-law[68]
        0x69,           // A-law[5b] ==> u-law[69]
        0x6e,           // A-law[5c] ==> u-law[6e]
        0x6f,           // A-law[5d] ==> u-law[6f]
        0x6c,           // A-law[5e] ==> u-law[6c]
        0x6d,           // A-law[5f] ==> u-law[6d]
        0x48,           // A-law[60] ==> u-law[48]
        0x49,           // A-law[61] ==> u-law[49]
        0x46,           // A-law[62] ==> u-law[46]
        0x47,           // A-law[63] ==> u-law[47]
        0x4c,           // A-law[64] ==> u-law[4c]
        0x4d,           // A-law[65] ==> u-law[4d]
        0x4a,           // A-law[66] ==> u-law[4a]
        0x4b,           // A-law[67] ==> u-law[4b]
        0x40,           // A-law[68] ==> u-law[40]
        0x41,           // A-law[69] ==> u-law[41]
        0x3f,           // A-law[6a] ==> u-law[3f]
        0x3f,           // A-law[6b] ==> u-law[3f]
        0x44,           // A-law[6c] ==> u-law[44]
        0x45,           // A-law[6d] ==> u-law[45]
        0x42,           // A-law[6e] ==> u-law[42]
        0x43,           // A-law[6f] ==> u-law[43]
        0x56,           // A-law[70] ==> u-law[56]
        0x57,           // A-law[71] ==> u-law[57]
        0x54,           // A-law[72] ==> u-law[54]
        0x55,           // A-law[73] ==> u-law[55]
        0x5a,           // A-law[74] ==> u-law[5a]
        0x5b,           // A-law[75] ==> u-law[5b]
        0x58,           // A-law[76] ==> u-law[58]
        0x59,           // A-law[77] ==> u-law[59]
        0x4f,           // A-law[78] ==> u-law[4f]
        0x4f,           // A-law[79] ==> u-law[4f]
        0x4e,           // A-law[7a] ==> u-law[4e]
        0x4e,           // A-law[7b] ==> u-law[4e]
        0x52,           // A-law[7c] ==> u-law[52]
        0x53,           // A-law[7d] ==> u-law[53]
        0x50,           // A-law[7e] ==> u-law[50]
        0x51,           // A-law[7f] ==> u-law[51]
        0xaa,           // A-law[80] ==> u-law[aa]
        0xab,           // A-law[81] ==> u-law[ab]
        0xa8,           // A-law[82] ==> u-law[a8]
        0xa9,           // A-law[83] ==> u-law[a9]
        0xae,           // A-law[84] ==> u-law[ae]
        0xaf,           // A-law[85] ==> u-law[af]
        0xac,           // A-law[86] ==> u-law[ac]
        0xad,           // A-law[87] ==> u-law[ad]
        0xa2,           // A-law[88] ==> u-law[a2]
        0xa3,           // A-law[89] ==> u-law[a3]
        0xa0,           // A-law[8a] ==> u-law[a0]
        0xa1,           // A-law[8b] ==> u-law[a1]
        0xa6,           // A-law[8c] ==> u-law[a6]
        0xa7,           // A-law[8d] ==> u-law[a7]
        0xa4,           // A-law[8e] ==> u-law[a4]
        0xa5,           // A-law[8f] ==> u-law[a5]
        0xb9,           // A-law[90] ==> u-law[b9]
        0xba,           // A-law[91] ==> u-law[ba]
        0xb7,           // A-law[92] ==> u-law[b7]
        0xb8,           // A-law[93] ==> u-law[b8]
        0xbd,           // A-law[94] ==> u-law[bd]
        0xbe,           // A-law[95] ==> u-law[be]
        0xbb,           // A-law[96] ==> u-law[bb]
        0xbc,           // A-law[97] ==> u-law[bc]
        0xb1,           // A-law[98] ==> u-law[b1]
        0xb2,           // A-law[99] ==> u-law[b2]
        0xb0,           // A-law[9a] ==> u-law[b0]
        0xb0,           // A-law[9b] ==> u-law[b0]
        0xb5,           // A-law[9c] ==> u-law[b5]
        0xb6,           // A-law[9d] ==> u-law[b6]
        0xb3,           // A-law[9e] ==> u-law[b3]
        0xb4,           // A-law[9f] ==> u-law[b4]
        0x8a,           // A-law[a0] ==> u-law[8a]
        0x8b,           // A-law[a1] ==> u-law[8b]
        0x88,           // A-law[a2] ==> u-law[88]
        0x89,           // A-law[a3] ==> u-law[89]
        0x8e,           // A-law[a4] ==> u-law[8e]
        0x8f,           // A-law[a5] ==> u-law[8f]
        0x8c,           // A-law[a6] ==> u-law[8c]
        0x8d,           // A-law[a7] ==> u-law[8d]
        0x82,           // A-law[a8] ==> u-law[82]
        0x83,           // A-law[a9] ==> u-law[83]
        0x80,           // A-law[aa] ==> u-law[80]
        0x81,           // A-law[ab] ==> u-law[81]
        0x86,           // A-law[ac] ==> u-law[86]
        0x87,           // A-law[ad] ==> u-law[87]
        0x84,           // A-law[ae] ==> u-law[84]
        0x85,           // A-law[af] ==> u-law[85]
        0x9a,           // A-law[b0] ==> u-law[9a]
        0x9b,           // A-law[b1] ==> u-law[9b]
        0x98,           // A-law[b2] ==> u-law[98]
        0x99,           // A-law[b3] ==> u-law[99]
        0x9e,           // A-law[b4] ==> u-law[9e]
        0x9f,           // A-law[b5] ==> u-law[9f]
        0x9c,           // A-law[b6] ==> u-law[9c]
        0x9d,           // A-law[b7] ==> u-law[9d]
        0x92,           // A-law[b8] ==> u-law[92]
        0x93,           // A-law[b9] ==> u-law[93]
        0x90,           // A-law[ba] ==> u-law[90]
        0x91,           // A-law[bb] ==> u-law[91]
        0x96,           // A-law[bc] ==> u-law[96]
        0x97,           // A-law[bd] ==> u-law[97]
        0x94,           // A-law[be] ==> u-law[94]
        0x95,           // A-law[bf] ==> u-law[95]
        0xe2,           // A-law[c0] ==> u-law[e2]
        0xe3,           // A-law[c1] ==> u-law[e3]
        0xe0,           // A-law[c2] ==> u-law[e0]
        0xe1,           // A-law[c3] ==> u-law[e1]
        0xe6,           // A-law[c4] ==> u-law[e6]
        0xe7,           // A-law[c5] ==> u-law[e7]
        0xe4,           // A-law[c6] ==> u-law[e4]
        0xe5,           // A-law[c7] ==> u-law[e5]
        0xdd,           // A-law[c8] ==> u-law[dd]
        0xdd,           // A-law[c9] ==> u-law[dd]
        0xdc,           // A-law[ca] ==> u-law[dc]
        0xdc,           // A-law[cb] ==> u-law[dc]
        0xdf,           // A-law[cc] ==> u-law[df]
        0xdf,           // A-law[cd] ==> u-law[df]
        0xde,           // A-law[ce] ==> u-law[de]
        0xde,           // A-law[cf] ==> u-law[de]
        0xf4,           // A-law[d0] ==> u-law[f4]
        0xf6,           // A-law[d1] ==> u-law[f6]
        0xf0,           // A-law[d2] ==> u-law[f0]
        0xf2,           // A-law[d3] ==> u-law[f2]
        0xfc,           // A-law[d4] ==> u-law[fc]
        0xfe,           // A-law[d5] ==> u-law[fe]
        0xf8,           // A-law[d6] ==> u-law[f8]
        0xfa,           // A-law[d7] ==> u-law[fa]
        0xea,           // A-law[d8] ==> u-law[ea]
        0xeb,           // A-law[d9] ==> u-law[eb]
        0xe8,           // A-law[da] ==> u-law[e8]
        0xe9,           // A-law[db] ==> u-law[e9]
        0xee,           // A-law[dc] ==> u-law[ee]
        0xef,           // A-law[dd] ==> u-law[ef]
        0xec,           // A-law[de] ==> u-law[ec]
        0xed,           // A-law[df] ==> u-law[ed]
        0xc8,           // A-law[e0] ==> u-law[c8]
        0xc9,           // A-law[e1] ==> u-law[c9]
        0xc6,           // A-law[e2] ==> u-law[c6]
        0xc7,           // A-law[e3] ==> u-law[c7]
        0xcc,           // A-law[e4] ==> u-law[cc]
        0xcd,           // A-law[e5] ==> u-law[cd]
        0xca,           // A-law[e6] ==> u-law[ca]
        0xcb,           // A-law[e7] ==> u-law[cb]
        0xc0,           // A-law[e8] ==> u-law[c0]
        0xc1,           // A-law[e9] ==> u-law[c1]
        0xbf,           // A-law[ea] ==> u-law[bf]
        0xbf,           // A-law[eb] ==> u-law[bf]
        0xc4,           // A-law[ec] ==> u-law[c4]
        0xc5,           // A-law[ed] ==> u-law[c5]
        0xc2,           // A-law[ee] ==> u-law[c2]
        0xc3,           // A-law[ef] ==> u-law[c3]
        0xd6,           // A-law[f0] ==> u-law[d6]
        0xd7,           // A-law[f1] ==> u-law[d7]
        0xd4,           // A-law[f2] ==> u-law[d4]
        0xd5,           // A-law[f3] ==> u-law[d5]
        0xda,           // A-law[f4] ==> u-law[da]
        0xdb,           // A-law[f5] ==> u-law[db]
        0xd8,           // A-law[f6] ==> u-law[d8]
        0xd9,           // A-law[f7] ==> u-law[d9]
        0xcf,           // A-law[f8] ==> u-law[cf]
        0xcf,           // A-law[f9] ==> u-law[cf]
        0xce,           // A-law[fa] ==> u-law[ce]
        0xce,           // A-law[fb] ==> u-law[ce]
        0xd2,           // A-law[fc] ==> u-law[d2]
        0xd3,           // A-law[fd] ==> u-law[d3]
        0xd0,           // A-law[fe] ==> u-law[d0]
        0xd1            // A-law[ff] ==> u-law[d1]
    };
    
//--------------------------------------------------------------------------;
//
//  Name:
//      UlawToAlawTable
//
//
//  Description:
//      this array maps u-law characters to A-law characters
//      
//  Arguments:
//      the index into the array is a u-law character
//
//  Return:
//      an element of the array is an A-law character
//
//  Notes:
//
//
//  History:
//      08/01/93    Created.
//
//
//--------------------------------------------------------------------------;
const BYTE BCODE UlawToAlawTable[256] =
    {
        0x2a,           // u-law[00] ==> A-law[2a]
        0x2b,           // u-law[01] ==> A-law[2b]
        0x28,           // u-law[02] ==> A-law[28]
        0x29,           // u-law[03] ==> A-law[29]
        0x2e,           // u-law[04] ==> A-law[2e]
        0x2f,           // u-law[05] ==> A-law[2f]
        0x2c,           // u-law[06] ==> A-law[2c]
        0x2d,           // u-law[07] ==> A-law[2d]
        0x22,           // u-law[08] ==> A-law[22]
        0x23,           // u-law[09] ==> A-law[23]
        0x20,           // u-law[0a] ==> A-law[20]
        0x21,           // u-law[0b] ==> A-law[21]
        0x26,           // u-law[0c] ==> A-law[26]
        0x27,           // u-law[0d] ==> A-law[27]
        0x24,           // u-law[0e] ==> A-law[24]
        0x25,           // u-law[0f] ==> A-law[25]
        0x3a,           // u-law[10] ==> A-law[3a]
        0x3b,           // u-law[11] ==> A-law[3b]
        0x38,           // u-law[12] ==> A-law[38]
        0x39,           // u-law[13] ==> A-law[39]
        0x3e,           // u-law[14] ==> A-law[3e]
        0x3f,           // u-law[15] ==> A-law[3f]
        0x3c,           // u-law[16] ==> A-law[3c]
        0x3d,           // u-law[17] ==> A-law[3d]
        0x32,           // u-law[18] ==> A-law[32]
        0x33,           // u-law[19] ==> A-law[33]
        0x30,           // u-law[1a] ==> A-law[30]
        0x31,           // u-law[1b] ==> A-law[31]
        0x36,           // u-law[1c] ==> A-law[36]
        0x37,           // u-law[1d] ==> A-law[37]
        0x34,           // u-law[1e] ==> A-law[34]
        0x35,           // u-law[1f] ==> A-law[35]
        0x0a,           // u-law[20] ==> A-law[0a]
        0x0b,           // u-law[21] ==> A-law[0b]
        0x08,           // u-law[22] ==> A-law[08]
        0x09,           // u-law[23] ==> A-law[09]
        0x0e,           // u-law[24] ==> A-law[0e]
        0x0f,           // u-law[25] ==> A-law[0f]
        0x0c,           // u-law[26] ==> A-law[0c]
        0x0d,           // u-law[27] ==> A-law[0d]
        0x02,           // u-law[28] ==> A-law[02]
        0x03,           // u-law[29] ==> A-law[03]
        0x00,           // u-law[2a] ==> A-law[00]
        0x01,           // u-law[2b] ==> A-law[01]
        0x06,           // u-law[2c] ==> A-law[06]
        0x07,           // u-law[2d] ==> A-law[07]
        0x04,           // u-law[2e] ==> A-law[04]
        0x05,           // u-law[2f] ==> A-law[05]
        0x1b,           // u-law[30] ==> A-law[1b]
        0x18,           // u-law[31] ==> A-law[18]
        0x19,           // u-law[32] ==> A-law[19]
        0x1e,           // u-law[33] ==> A-law[1e]
        0x1f,           // u-law[34] ==> A-law[1f]
        0x1c,           // u-law[35] ==> A-law[1c]
        0x1d,           // u-law[36] ==> A-law[1d]
        0x12,           // u-law[37] ==> A-law[12]
        0x13,           // u-law[38] ==> A-law[13]
        0x10,           // u-law[39] ==> A-law[10]
        0x11,           // u-law[3a] ==> A-law[11]
        0x16,           // u-law[3b] ==> A-law[16]
        0x17,           // u-law[3c] ==> A-law[17]
        0x14,           // u-law[3d] ==> A-law[14]
        0x15,           // u-law[3e] ==> A-law[15]
        0x6a,           // u-law[3f] ==> A-law[6a]
        0x68,           // u-law[40] ==> A-law[68]
        0x69,           // u-law[41] ==> A-law[69]
        0x6e,           // u-law[42] ==> A-law[6e]
        0x6f,           // u-law[43] ==> A-law[6f]
        0x6c,           // u-law[44] ==> A-law[6c]
        0x6d,           // u-law[45] ==> A-law[6d]
        0x62,           // u-law[46] ==> A-law[62]
        0x63,           // u-law[47] ==> A-law[63]
        0x60,           // u-law[48] ==> A-law[60]
        0x61,           // u-law[49] ==> A-law[61]
        0x66,           // u-law[4a] ==> A-law[66]
        0x67,           // u-law[4b] ==> A-law[67]
        0x64,           // u-law[4c] ==> A-law[64]
        0x65,           // u-law[4d] ==> A-law[65]
        0x7a,           // u-law[4e] ==> A-law[7a]
        0x78,           // u-law[4f] ==> A-law[78]
        0x7e,           // u-law[50] ==> A-law[7e]
        0x7f,           // u-law[51] ==> A-law[7f]
        0x7c,           // u-law[52] ==> A-law[7c]
        0x7d,           // u-law[53] ==> A-law[7d]
        0x72,           // u-law[54] ==> A-law[72]
        0x73,           // u-law[55] ==> A-law[73]
        0x70,           // u-law[56] ==> A-law[70]
        0x71,           // u-law[57] ==> A-law[71]
        0x76,           // u-law[58] ==> A-law[76]
        0x77,           // u-law[59] ==> A-law[77]
        0x74,           // u-law[5a] ==> A-law[74]
        0x75,           // u-law[5b] ==> A-law[75]
        0x4b,           // u-law[5c] ==> A-law[4b]
        0x49,           // u-law[5d] ==> A-law[49]
        0x4f,           // u-law[5e] ==> A-law[4f]
        0x4d,           // u-law[5f] ==> A-law[4d]
        0x42,           // u-law[60] ==> A-law[42]
        0x43,           // u-law[61] ==> A-law[43]
        0x40,           // u-law[62] ==> A-law[40]
        0x41,           // u-law[63] ==> A-law[41]
        0x46,           // u-law[64] ==> A-law[46]
        0x47,           // u-law[65] ==> A-law[47]
        0x44,           // u-law[66] ==> A-law[44]
        0x45,           // u-law[67] ==> A-law[45]
        0x5a,           // u-law[68] ==> A-law[5a]
        0x5b,           // u-law[69] ==> A-law[5b]
        0x58,           // u-law[6a] ==> A-law[58]
        0x59,           // u-law[6b] ==> A-law[59]
        0x5e,           // u-law[6c] ==> A-law[5e]
        0x5f,           // u-law[6d] ==> A-law[5f]
        0x5c,           // u-law[6e] ==> A-law[5c]
        0x5d,           // u-law[6f] ==> A-law[5d]
        0x52,           // u-law[70] ==> A-law[52]
        0x52,           // u-law[71] ==> A-law[52]
        0x53,           // u-law[72] ==> A-law[53]
        0x53,           // u-law[73] ==> A-law[53]
        0x50,           // u-law[74] ==> A-law[50]
        0x50,           // u-law[75] ==> A-law[50]
        0x51,           // u-law[76] ==> A-law[51]
        0x51,           // u-law[77] ==> A-law[51]
        0x56,           // u-law[78] ==> A-law[56]
        0x56,           // u-law[79] ==> A-law[56]
        0x57,           // u-law[7a] ==> A-law[57]
        0x57,           // u-law[7b] ==> A-law[57]
        0x54,           // u-law[7c] ==> A-law[54]
        0x54,           // u-law[7d] ==> A-law[54]
        0x55,           // u-law[7e] ==> A-law[55]
        0x55,           // u-law[7f] ==> A-law[55]
        0xaa,           // u-law[80] ==> A-law[aa]
        0xab,           // u-law[81] ==> A-law[ab]
        0xa8,           // u-law[82] ==> A-law[a8]
        0xa9,           // u-law[83] ==> A-law[a9]
        0xae,           // u-law[84] ==> A-law[ae]
        0xaf,           // u-law[85] ==> A-law[af]
        0xac,           // u-law[86] ==> A-law[ac]
        0xad,           // u-law[87] ==> A-law[ad]
        0xa2,           // u-law[88] ==> A-law[a2]
        0xa3,           // u-law[89] ==> A-law[a3]
        0xa0,           // u-law[8a] ==> A-law[a0]
        0xa1,           // u-law[8b] ==> A-law[a1]
        0xa6,           // u-law[8c] ==> A-law[a6]
        0xa7,           // u-law[8d] ==> A-law[a7]
        0xa4,           // u-law[8e] ==> A-law[a4]
        0xa5,           // u-law[8f] ==> A-law[a5]
        0xba,           // u-law[90] ==> A-law[ba]
        0xbb,           // u-law[91] ==> A-law[bb]
        0xb8,           // u-law[92] ==> A-law[b8]
        0xb9,           // u-law[93] ==> A-law[b9]
        0xbe,           // u-law[94] ==> A-law[be]
        0xbf,           // u-law[95] ==> A-law[bf]
        0xbc,           // u-law[96] ==> A-law[bc]
        0xbd,           // u-law[97] ==> A-law[bd]
        0xb2,           // u-law[98] ==> A-law[b2]
        0xb3,           // u-law[99] ==> A-law[b3]
        0xb0,           // u-law[9a] ==> A-law[b0]
        0xb1,           // u-law[9b] ==> A-law[b1]
        0xb6,           // u-law[9c] ==> A-law[b6]
        0xb7,           // u-law[9d] ==> A-law[b7]
        0xb4,           // u-law[9e] ==> A-law[b4]
        0xb5,           // u-law[9f] ==> A-law[b5]
        0x8a,           // u-law[a0] ==> A-law[8a]
        0x8b,           // u-law[a1] ==> A-law[8b]
        0x88,           // u-law[a2] ==> A-law[88]
        0x89,           // u-law[a3] ==> A-law[89]
        0x8e,           // u-law[a4] ==> A-law[8e]
        0x8f,           // u-law[a5] ==> A-law[8f]
        0x8c,           // u-law[a6] ==> A-law[8c]
        0x8d,           // u-law[a7] ==> A-law[8d]
        0x82,           // u-law[a8] ==> A-law[82]
        0x83,           // u-law[a9] ==> A-law[83]
        0x80,           // u-law[aa] ==> A-law[80]
        0x81,           // u-law[ab] ==> A-law[81]
        0x86,           // u-law[ac] ==> A-law[86]
        0x87,           // u-law[ad] ==> A-law[87]
        0x84,           // u-law[ae] ==> A-law[84]
        0x85,           // u-law[af] ==> A-law[85]
        0x9b,           // u-law[b0] ==> A-law[9b]
        0x98,           // u-law[b1] ==> A-law[98]
        0x99,           // u-law[b2] ==> A-law[99]
        0x9e,           // u-law[b3] ==> A-law[9e]
        0x9f,           // u-law[b4] ==> A-law[9f]
        0x9c,           // u-law[b5] ==> A-law[9c]
        0x9d,           // u-law[b6] ==> A-law[9d]
        0x92,           // u-law[b7] ==> A-law[92]
        0x93,           // u-law[b8] ==> A-law[93]
        0x90,           // u-law[b9] ==> A-law[90]
        0x91,           // u-law[ba] ==> A-law[91]
        0x96,           // u-law[bb] ==> A-law[96]
        0x97,           // u-law[bc] ==> A-law[97]
        0x94,           // u-law[bd] ==> A-law[94]
        0x95,           // u-law[be] ==> A-law[95]
        0xea,           // u-law[bf] ==> A-law[ea]
        0xe8,           // u-law[c0] ==> A-law[e8]
        0xe9,           // u-law[c1] ==> A-law[e9]
        0xee,           // u-law[c2] ==> A-law[ee]
        0xef,           // u-law[c3] ==> A-law[ef]
        0xec,           // u-law[c4] ==> A-law[ec]
        0xed,           // u-law[c5] ==> A-law[ed]
        0xe2,           // u-law[c6] ==> A-law[e2]
        0xe3,           // u-law[c7] ==> A-law[e3]
        0xe0,           // u-law[c8] ==> A-law[e0]
        0xe1,           // u-law[c9] ==> A-law[e1]
        0xe6,           // u-law[ca] ==> A-law[e6]
        0xe7,           // u-law[cb] ==> A-law[e7]
        0xe4,           // u-law[cc] ==> A-law[e4]
        0xe5,           // u-law[cd] ==> A-law[e5]
        0xfa,           // u-law[ce] ==> A-law[fa]
        0xf8,           // u-law[cf] ==> A-law[f8]
        0xfe,           // u-law[d0] ==> A-law[fe]
        0xff,           // u-law[d1] ==> A-law[ff]
        0xfc,           // u-law[d2] ==> A-law[fc]
        0xfd,           // u-law[d3] ==> A-law[fd]
        0xf2,           // u-law[d4] ==> A-law[f2]
        0xf3,           // u-law[d5] ==> A-law[f3]
        0xf0,           // u-law[d6] ==> A-law[f0]
        0xf1,           // u-law[d7] ==> A-law[f1]
        0xf6,           // u-law[d8] ==> A-law[f6]
        0xf7,           // u-law[d9] ==> A-law[f7]
        0xf4,           // u-law[da] ==> A-law[f4]
        0xf5,           // u-law[db] ==> A-law[f5]
        0xcb,           // u-law[dc] ==> A-law[cb]
        0xc9,           // u-law[dd] ==> A-law[c9]
        0xcf,           // u-law[de] ==> A-law[cf]
        0xcd,           // u-law[df] ==> A-law[cd]
        0xc2,           // u-law[e0] ==> A-law[c2]
        0xc3,           // u-law[e1] ==> A-law[c3]
        0xc0,           // u-law[e2] ==> A-law[c0]
        0xc1,           // u-law[e3] ==> A-law[c1]
        0xc6,           // u-law[e4] ==> A-law[c6]
        0xc7,           // u-law[e5] ==> A-law[c7]
        0xc4,           // u-law[e6] ==> A-law[c4]
        0xc5,           // u-law[e7] ==> A-law[c5]
        0xda,           // u-law[e8] ==> A-law[da]
        0xdb,           // u-law[e9] ==> A-law[db]
        0xd8,           // u-law[ea] ==> A-law[d8]
        0xd9,           // u-law[eb] ==> A-law[d9]
        0xde,           // u-law[ec] ==> A-law[de]
        0xdf,           // u-law[ed] ==> A-law[df]
        0xdc,           // u-law[ee] ==> A-law[dc]
        0xdd,           // u-law[ef] ==> A-law[dd]
        0xd2,           // u-law[f0] ==> A-law[d2]
        0xd2,           // u-law[f1] ==> A-law[d2]
        0xd3,           // u-law[f2] ==> A-law[d3]
        0xd3,           // u-law[f3] ==> A-law[d3]
        0xd0,           // u-law[f4] ==> A-law[d0]
        0xd0,           // u-law[f5] ==> A-law[d0]
        0xd1,           // u-law[f6] ==> A-law[d1]
        0xd1,           // u-law[f7] ==> A-law[d1]
        0xd6,           // u-law[f8] ==> A-law[d6]
        0xd6,           // u-law[f9] ==> A-law[d6]
        0xd7,           // u-law[fa] ==> A-law[d7]
        0xd7,           // u-law[fb] ==> A-law[d7]
        0xd4,           // u-law[fc] ==> A-law[d4]
        0xd4,           // u-law[fd] ==> A-law[d4]
        0xd5,           // u-law[fe] ==> A-law[d5]
        0xd5            // u-law[ff] ==> A-law[d5]
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\g711\init.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1996 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  init.c
//
//  Description:
//      This file contains module initialization routines.  Note that there
//      is no module initialization for Win32 - the only initialization
//      required is to set ghinst, which is done in the DRV_LOAD message
//      of DriverProc (in codec.c).
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "codec.h"
#include "debug.h"


//==========================================================================;
//
//  WIN 16 SPECIFIC SUPPORT
//
//==========================================================================;

#ifndef _WIN32

//--------------------------------------------------------------------------;
//
//  int LibMain
//
//  Description:
//      Library initialization code.
//
//  Arguments:
//      HINSTANCE hinst: Our module handle.
//
//      WORD wDataSeg: Specifies the DS value for this DLL.
//
//      WORD cbHeapSize: The heap size from the .def file.
//
//      LPSTR pszCmdLine: The command line.
//
//  Return (int):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    Created. 
//
//--------------------------------------------------------------------------;

int FNGLOBAL LibMain
(
    HINSTANCE               hinst, 
    WORD                    wDataSeg, 
    WORD                    cbHeapSize,
    LPSTR                   pszCmdLine
)
{
    DbgInitialize(TRUE);

    //
    //  if debug level is 5 or greater, then do a DebugBreak() to debug
    //  loading of this driver
    //
    DPF(1, "LibMain(hinst=%.4Xh, wDataSeg=%.4Xh, cbHeapSize=%u, pszCmdLine=%.8lXh)",
        hinst, wDataSeg, cbHeapSize, pszCmdLine);
    DPF(5, "!*** break for debugging ***");

    return (TRUE);
} // LibMain()


//--------------------------------------------------------------------------;
//  
//  int WEP
//  
//  Description:
//  
//  
//  Arguments:
//      WORD wUselessParam:
//  
//  Return (int):
//  
//  History:
//      03/28/93    Created.
//  
//--------------------------------------------------------------------------;

EXTERN_C int FNEXPORT WEP
(
    WORD                    wUselessParam
)
{
    DPF(1, "WEP(wUselessParam=%u)", wUselessParam);

    //
    //  always return 1.
    //
    return (1);
} // WEP()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\g711\gentable.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1996 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  gentable.c
//
//  Description:
//      This is a utility program to generate various tables in the
//      form of 'C' source code.  Portions of some of these tables can
//      be pasted into codec source code.  The output is to stdio
//      and can be redirected into a file.  Portions of the file can
//      then be cut and pasted into another 'C' source file as necessary.
//
//==========================================================================;


#include <stdio.h>

//--------------------------------------------------------------------------;
//
//  Name:
//      UlawToAlawTable
//
//
//  Description:
/*      This table was copied directly from the G.711 specification.  Using
        the G.711 spec terminology, this table converts u-law decoder output
        value numbers to A-law decoder output value numbers.
*/      
//      
//  Arguments:
//
//
//  Return:
//
//
//  Notes:
//
//
//  History:
//      08/01/93    Created.
//
//
//--------------------------------------------------------------------------;
unsigned char UlawToAlawTable[128] =
    {
    1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,
    9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,
    27,29,31,
    33,34,35,36,37,38,39,40,41,42,43,44,
    46,
    48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,
    64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
    81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
    100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,
    120,121,122,123,124,125,126,127,128
    };

//--------------------------------------------------------------------------;
//
//  Name:
//      AlawToUlawTable
//
//
//  Description:
/*      This table was copied directly from the G.711 specification.  Using
        the G.711 spec terminology, this table converts A-law decoder output
        value numbers to u-law decoder output value numbers.  A-law decoder
        output value numbers range from 1 to 128, so AlawToUlawTable[0] is
        unused.  Note that u-law decoder output value numbers range from
        0 to 127.
*/      
//      
//  Arguments:
//
//
//  Return:
//
//
//  Notes:
//
//
//  History:
//      08/01/93    Created.
//
//
//--------------------------------------------------------------------------;
unsigned char AlawToUlawTable[129] =
    {
    0,      // this first entry not used
    1,3,5,7,9,11,13,
    15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
    32,32,33,33,34,34,35,35,
    36,37,38,39,40,41,42,43,44,45,46,47,
    48,48,49,49,
    50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,
    64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
    79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
    100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,
    116,117,118,119,120,121,122,123,124,125,126,127
    };
    
short DecodeTable[256];


//
// Our main procedure.
//

void main()
    {

    short i,j;
    
    short SegBase[16];
    short IntervalStep[16];
    
    short Sample;
    
      
      
    //
    // This generates a decode table for A-law.  The resulting
    // table can be used to convert an A-law character to
    // a 16-bit PCM value.
    //
    
    // These seg base values and interval steps are based directly
    // on the G.711 A-law spec.  They correspond to 13-bit PCM data.
    SegBase[ 0] =    -1;        IntervalStep[ 0] =   -2;
    SegBase[ 1] =   -33;        IntervalStep[ 1] =   -2;
    SegBase[ 2] =   -66;        IntervalStep[ 2] =   -4;
    SegBase[ 3] =  -132;        IntervalStep[ 3] =   -8;
    SegBase[ 4] =  -264;        IntervalStep[ 4] =  -16;
    SegBase[ 5] =  -528;        IntervalStep[ 5] =  -32;
    SegBase[ 6] = -1056;        IntervalStep[ 6] =  -64;
    SegBase[ 7] = -2112;        IntervalStep[ 7] = -128;
    SegBase[ 8] =     1;        IntervalStep[ 8] =    2;
    SegBase[ 9] =    33;        IntervalStep[ 9] =    2;
    SegBase[10] =    66;        IntervalStep[10] =    4;
    SegBase[11] =   132;        IntervalStep[11] =    8;
    SegBase[12] =   264;        IntervalStep[12] =   16;
    SegBase[13] =   528;        IntervalStep[13] =   32;
    SegBase[14] =  1056;        IntervalStep[14] =   64;
    SegBase[15] =  2112;        IntervalStep[15] =  128;
    
    printf("\n\n\n\n\n// A-law decode table:\n\n");
    
    for (i=0; i<16; i++)
        for (j=0; j<16; j++)
            {
            Sample = SegBase[i^0x05] + IntervalStep[i^0x05]*(j^0x05);
            // Sample is a 13-bit signed PCM value.
            // In our table, we'll convert it to 16-bit.  The
            // generated comment will indicate the 13-bit value.
            printf( "\t%6d,\t\t// y[%02x]= %6d\n",
                    Sample << 3,
                    i*16 + j,
                    Sample);
            }
            
            
            
    //
    // This generates a decode table for u-law.  The resulting
    // table can be used to convert a u-law character to
    // a 16-bit PCM value.
    //      
    
    // These seg base values and interval steps are based directly
    // on the G.711 A-law spec.  They correspond to 14-bit PCM data.
    SegBase[ 0] = -8031;        IntervalStep[ 0] =  256;
    SegBase[ 1] = -3999;        IntervalStep[ 1] =  128;
    SegBase[ 2] = -1983;        IntervalStep[ 2] =   64;
    SegBase[ 3] =  -975;        IntervalStep[ 3] =   32;
    SegBase[ 4] =  -471;        IntervalStep[ 4] =   16;
    SegBase[ 5] =  -219;        IntervalStep[ 5] =    8;
    SegBase[ 6] =   -93;        IntervalStep[ 6] =    4;
    SegBase[ 7] =   -30;        IntervalStep[ 7] =    2;
    SegBase[ 8] =  8031;        IntervalStep[ 8] = -256;
    SegBase[ 9] =  3999;        IntervalStep[ 9] = -128;
    SegBase[10] =  1983;        IntervalStep[10] =  -64;
    SegBase[11] =   975;        IntervalStep[11] =  -32;
    SegBase[12] =   471;        IntervalStep[12] =  -16;
    SegBase[13] =   219;        IntervalStep[13] =   -8;
    SegBase[14] =    93;        IntervalStep[14] =   -4;
    SegBase[15] =    30;        IntervalStep[15] =   -2;
    
    printf("\n\n\n\n\n// u-law decode table:\n\n");
    
    for (i=0; i<16; i++)
        for (j=0; j<16; j++)
            {
            Sample = SegBase[i] + IntervalStep[i]*j;
            // Sample is a 14-bit signed PCM value.
            // In our table, we'll convert it to 16-bit.  The
            // generated comment will indicate the 14-bit value.
            printf( "\t%6d,\t\t// y[%02x]= %6d\n",
                    Sample << 2,
                    i*16 + j,
                    Sample);
            }
    
        


    //
    // This generates a conversion table from A-law chars
    // to u-law chars.  The AlawToUlawTable above converts
    // decoder output value numbers, which is not quite what
    // we want.  Using that table, this routine will generate
    // 'C' source code for a table that converts directly from
    // A-law chars to u-law chars.
    //
    printf("\n\n\n\n\n// A-law to u-law char conversion table:\n\n");
    for (i=0; i<256; i++)       // i counts thru all A-law chars
        {
        // Here is the process to go from an A-law char
        // to a u-law char.
        
        // 1.   convert from A-law char to A-law decoder
        //      output value number.  from observing the tables
        //      in the G.711 spec it can be seen that this is
        //      done by inverting the even bits and dropping the
        //      sign bit of the A-law char and then adding 1.
        // 2.   using the AlawToUlawTable above, convert from
        //      the A-law decoder output value number to the
        //      corresponding u-law output value number.
        // 3.   convert from u-law decoder output value
        //      number to u-law char.  from observing the tables
        //      in the G.711 spec it can be seen that this is
        //      done by inverting the 7 LSBs of the u-law
        //      decoder output value number.
        // 4.   apply polarity to the u-law char.  that is,
        //      set the sign bit of the u-law char the same
        //      as the sign bit of the original A-law char.
                  
        j = i;                  // j starts of as original A-law char                 
        // Step 1:            
        j = ((i^0x55) & 0x7F) + 1;
        // Step 2:
        j = AlawToUlawTable[j];
        // Step 3:
        j = (j ^ 0x7F);
        // Step 4:
        j = j | (i & 0x80);     // j ends as corresponding u-law char
        
        // Now i is an A-law char and j is the corresponding u-law char
        printf( "\t0x%02x,\t\t// A-law[%02x] ==> u-law[%02x]\n",
                j,
                i,
                j);
                
        }
        
        
        
                
    //
    // This generates a conversion table from u-law chars
    // to A-law chars.  The UlawToAlawTable above converts
    // decoder output value numbers, which is not quite what
    // we want.  Using that table, this routine will generate
    // 'C' source code for a table that converts directly from
    // u-law chars to A-law chars.
    //
    printf("\n\n\n\n\n// u-law to A-law char conversion table:\n\n");
    for (i=0; i<256; i++)       // i counts thru all U-law chars
        {
        // Here is the process to go from a u-law char
        // to a A-law char.
        
        // 1.   convert from u-law char to u-law decoder
        //      output value number.  from observing the tables
        //      in the G.711 spec it can be seen that this is
        //      done by dropping the sign bit of the u-law
        //      char and then inverting the 7 LSBs.
        // 2.   using the UlawToAlawTable above, convert from
        //      the u-law decoder output value number to the
        //      corresponding A-law output value number.
        // 3.   convert from A-law decoder output value
        //      number to A-law char.  from observing the tables
        //      in the G.711 spec it can be seen that this is
        //      done by subtracting 1 from the A-law decoder output
        //      value number and inverting the even bits.
        // 4.   apply polarity to the A-law char.  that is,
        //      set the sign bit of the A-law char the same
        //      as the sign bit of the original u-law char.
                  
        j = i;                  // j starts of as original u-law char                 
        // Step 1:            
        j = (i & 0x7F) ^ 0x7F;
        // Step 2:
        j = UlawToAlawTable[j];
        // Step 3:
        j = (j - 1)^0x55;
        // Step 4:
        j = j | (i & 0x80);     // j ends as corresponding A-law char
        
        // Now i is a u-law char and j is the corresponding A-law char
        printf( "\t0x%02x,\t\t// u-law[%02x] ==> A-law[%02x]\n",
                j,
                i,
                j);
                
        }
    
    return;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\gsm610\codec.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.c
//
//  Description:
//      This file contains the DriverProc and other routines which respond
//      to ACM messages.
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "codec.h"
#include "gsm610.h"
#include "debug.h"


//
//  array of supported format tags
//
//
const UINT gauFormatTagIndexToTag[] =
{
    WAVE_FORMAT_PCM,
    WAVE_FORMAT_GSM610
};

#define ACM_DRIVER_MAX_FORMAT_TAGS   SIZEOF_ARRAY(gauFormatTagIndexToTag)
#define ACM_DRIVER_MAX_FILTER_TAGS   0


//
//  array of sample rates supported
//
//
const UINT gauFormatIndexToSampleRate[] =
{
    8000,
    11025,
    22050,
    44100
};

//
//  array of pcm bits per sample supported
//
//
const UINT gauPcmFormatIndexToBitsPerSample[] =
{
    8,
    16
};

const UINT ACM_DRIVER_MAX_SAMPLE_RATES = SIZEOF_ARRAY(gauFormatIndexToSampleRate);

#define ACM_DRIVER_MAX_CHANNELS     GSM610_MAX_CHANNELS


//
//  bits per sample supported
//
//
#define ACM_DRIVER_MAX_BITSPERSAMPLE_PCM	2
#define ACM_DRIVER_MAX_BITSPERSAMPLE_GSM610	1


//
//  number of formats we enumerate per channel is number of sample rates
//  times number of channels times number of types (bits per sample).
//
#define ACM_DRIVER_MAX_FORMATS_PCM	(ACM_DRIVER_MAX_SAMPLE_RATES *  \
                                         ACM_DRIVER_MAX_CHANNELS *      \
                                         ACM_DRIVER_MAX_BITSPERSAMPLE_PCM)

#define ACM_DRIVER_MAX_FORMATS_GSM610   (ACM_DRIVER_MAX_SAMPLE_RATES *  \
                                         ACM_DRIVER_MAX_CHANNELS *      \
                                         ACM_DRIVER_MAX_BITSPERSAMPLE_GSM610)


//--------------------------------------------------------------------------;
//
//  This array describes the configuration settings for this codec.
//
//  Each line in the realtime encode/decode rate listbox must have one of
//  these structures to describe it.  The type of line is defined in
//  nFormatType, which can have one of the following values:
//
//      CONFIG_RLF_NONUMBER     - the string in idsFormat is displayed as is.
//      CONFIG_RLF_MONOONLY     - dwMonoRate is written into idsFormat, then
//                                  displayed as a mono rate.
//
//  The index to the gaRateListFormat array corresponds to the value which
//  is stored as configuration information in the registry or .ini file.
//  To find out if a certain conversion can be performed in real time,
//  check that:
//
//    SamplingRate <= gaRateListFormat[ConfigSetting].dwMonoRate / nChannels
//
//  Note:  The gaRateListFormat array must change when
//          gauFormatIndexToSampleRate changes.
//
//--------------------------------------------------------------------------;

const RATELISTFORMAT gaRateListFormat[] =
{
    { CONFIG_RLF_NONUMBER,      IDS_CONFIG_NORATES,     0 },
    { CONFIG_RLF_MONOONLY,      IDS_CONFIG_MONOONLY,    8000 },  // gauFormatIndexToSampleRate[0]
    { CONFIG_RLF_MONOONLY,      IDS_CONFIG_MONOONLY,    11025 }, // gauFormatIndexToSampleRate[1]
    { CONFIG_RLF_MONOONLY,      IDS_CONFIG_MONOONLY,    22050 }, // gauFormatIndexToSampleRate[2]
    { CONFIG_RLF_MONOONLY,      IDS_CONFIG_MONOONLY,    44100 }, // gauFormatIndexToSampleRate[3]
    { CONFIG_RLF_NONUMBER,      IDS_CONFIG_ALLRATES,    88200 }  // 2 * gauFormatIndexToSampleRate[3]
};

const UINT MSGSM610_CONFIG_NUMSETTINGS = SIZEOF_ARRAY( gaRateListFormat );


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  int LoadStringCodec
//
//  Description:
//      This function should be used by all codecs to load resource strings
//      which will be passed back to the ACM.  It works correctly for all
//      platforms, as follows:
//
//          Win16:  Compiled to LoadString to load ANSI strings.
//
//          Win32:  The 32-bit ACM always expects Unicode strings.  Therefore,
//                  when UNICODE is defined, this function is compiled to
//                  LoadStringW to load a Unicode string.  When UNICODE is
//                  not defined, this function loads an ANSI string, converts
//                  it to Unicode, and returns the Unicode string to the
//                  codec.
//
//      Note that you may use LoadString for other strings (strings which
//      will not be passed back to the ACM), because these strings will
//      always be consistent with the definition of UNICODE.
//
//  Arguments:
//      Same as LoadString, except that it expects an LPSTR for Win16 and a
//      LPWSTR for Win32.
//
//  Return (int):
//      Same as LoadString.
//
//--------------------------------------------------------------------------;

#ifndef WIN32
#define LoadStringCodec LoadString
#else

#ifdef UNICODE
#define LoadStringCodec LoadStringW
#else

int FNGLOBAL LoadStringCodec
(
 HINSTANCE  hinst,
 UINT	    uID,
 LPWSTR	    lpwstr,
 int	    cch)
{
    LPSTR   lpstr;
    int	    iReturn;

    lpstr = (LPSTR)GlobalAlloc(GPTR, cch);
    if (NULL == lpstr)
    {
	return 0;
    }

    iReturn = LoadStringA(hinst, uID, lpstr, cch);
    if (0 == iReturn)
    {
	if (0 != cch)
	{
	    lpwstr[0] = '\0';
	}
    }
    else
    {
    	MultiByteToWideChar( GetACP(), 0, lpstr, cch, lpwstr, cch );
    }

    GlobalFree((HGLOBAL)lpstr);

    return iReturn;
}

#endif  // UNICODE
#endif  // WIN32


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL pcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid PCM
//      header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL pcmIsValidFormat
(
    LPWAVEFORMATEX          pwfx
)
{
    if (NULL == pwfx)
        return (FALSE);

    if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
        return (FALSE);

    //
    //  verify nChannels member is within the allowed range
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > ACM_DRIVER_MAX_CHANNELS))
        return (FALSE);

    //
    //  only allow the bits per sample that we can encode and decode with
    //
    if ( (16 != pwfx->wBitsPerSample) && (8 != pwfx->wBitsPerSample) )
	return (FALSE);

    //
    //  now verify that the block alignment is correct..
    //
    if (PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfx) != pwfx->nBlockAlign)
        return (FALSE);

    //
    //  finally, verify that avg bytes per second is correct
    //
    if (PCM_AVGBYTESPERSEC((LPPCMWAVEFORMAT)pwfx) != pwfx->nAvgBytesPerSec)
        return (FALSE);

    return (TRUE);
} // pcmIsValidFormat()


//--------------------------------------------------------------------------;
//
//  BOOL gsm610IsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid
//      GSM 6.10 format header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL gsm610IsValidFormat
(
    LPWAVEFORMATEX          pwfx
)
{

    if (NULL == pwfx)
        return (FALSE);

    if (WAVE_FORMAT_GSM610 != pwfx->wFormatTag)
        return (FALSE);

    //
    //  check channels
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > ACM_DRIVER_MAX_CHANNELS))
        return (FALSE);


    //
    //  now verify that the block alignment is correct..
    //
    if (GSM610_BLOCKALIGNMENT(pwfx) != pwfx->nBlockAlign)
        return (FALSE);

    //
    //  verify that avg bytes per second is correct
    //
    if (GSM610_AVGBYTESPERSEC(pwfx) != pwfx->nAvgBytesPerSec)
        return (FALSE);

    //
    //  check wBitsPerSample
    //
    if (GSM610_BITS_PER_SAMPLE != pwfx->wBitsPerSample)
        return (FALSE);

    //
    //  cbSize must be validated also..
    //
    if (GSM610_WFX_EXTRA_BYTES != pwfx->cbSize)
        return (FALSE);

    //
    //	check wSamplesPerBlock
    //
    if (GSM610_SAMPLESPERBLOCK(pwfx) != ((LPGSM610WAVEFORMAT)pwfx)->wSamplesPerBlock)
	return (FALSE);

    return (TRUE);

} // gsm610IsValidFormat()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverOpen
//
//  Description:
//      This function is used to handle the DRV_OPEN message for the ACM
//      driver. The driver is 'opened' for many reasons with the most common
//      being in preperation for conversion work. It is very important that
//      the driver be able to correctly handle multiple open driver
//      instances.
//
//      Read the comments for this function carefully!
//
//      Note that multiple _streams_ can (and will) be opened on a single
//      open _driver instance_. Do not store/create instance data that must
//      be unique for each stream in this function. See the acmdStreamOpen
//      function for information on conversion streams.
//
//  Arguments:
//      HDRVR hdrvr: Driver handle that will be returned to caller of the
//      OpenDriver function. Normally, this will be the ACM--but this is
//      not guaranteed. For example, if an ACM driver is implemented within
//      a waveform driver, then the driver will be opened by both MMSYSTEM
//      and the ACM.
//
//      LPACMDRVOPENDESC paod: Open description defining how the ACM driver
//      is being opened. This argument may be NULL--see the comments below
//      for more information.
//
//  Return (LRESULT):
//      The return value is non-zero if the open is successful. A zero
//      return signifies that the driver cannot be opened.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverOpen
(
    HDRVR                   hdrvr,
    LPACMDRVOPENDESC        paod
)
{
    PDRIVERINSTANCE     pdi;

    //
    //  the [optional] open description that is passed to this driver can
    //  be from multiple 'managers.' for example, AVI looks for installable
    //  drivers that are tagged with 'vidc' and 'vcap'. we need to verify
    //  that we are being opened as an Audio Compression Manager driver.
    //
    //  if paod is NULL, then the driver is being opened for some purpose
    //  other than converting (that is, there will be no stream open
    //  requests for this instance of being opened). the most common case
    //  of this is the Control Panel's Drivers option checking for config
    //  support (DRV_[QUERY]CONFIGURE).
    //
    //  we want to succeed this open, but be able to know that this
    //  open instance is bogus for creating streams. for this purpose we
    //  leave most of the members of our instance structure that we
    //  allocate below as zero...
    //
    if (NULL != paod)
    {
        //
        //  refuse to open if we are not being opened as an ACM driver.
        //  note that we do NOT modify the value of paod->dwError in this
        //  case.
        //
        if (ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != paod->fccType)
        {
            return (0L);
        }
    }


    //
    //  we are being opened as an installable driver--we can allocate some
    //  instance data to be returned in dwId argument of the DriverProc;
    //  or simply return non-zero to succeed the open.
    //
    //  this driver allocates a small instance structure. note that we
    //  rely on allocating the memory as zero-initialized!
    //
    pdi = (PDRIVERINSTANCE)LocalAlloc(LPTR, sizeof(*pdi));
    if (NULL == pdi)
    {
        //
        //  if this open attempt was as an ACM driver, then return the
        //  reason we are failing in the open description structure..
        //
        if (NULL != paod)
        {
            paod->dwError = MMSYSERR_NOMEM;
        }

        //
        //  fail to open
        //
        return (0L);
    }


    //
    //  fill in our instance structure... note that this instance data
    //  can be anything that the ACM driver wishes to maintain the
    //  open driver instance. this data should not contain any information
    //  that must be maintained per open stream since multiple streams
    //  can be opened on a single driver instance.
    //
    //  also note that we do _not_ check the version of the ACM opening
    //  us (paod->dwVersion) to see if it is at least new enough to work
    //  with this driver (for example, if this driver required Version 3.0
    //  of the ACM and a Version 2.0 installation tried to open us). the
    //  reason we do not fail is to allow the ACM to get the driver details
    //  which contains the version of the ACM that is _required_ by this
    //  driver. the ACM will examine that value (in padd->vdwACM) and
    //  do the right thing for this driver... like not load it and inform
    //  the user of the problem.
    //
    pdi->hdrvr          = hdrvr;
    pdi->hinst          = GetDriverModuleHandle(hdrvr);  // Module handle.
    pdi->fHelpRunning   = FALSE;

    if (NULL != paod)
    {
        pdi->fnDriverProc = NULL;
        pdi->fccType      = paod->fccType;
        pdi->vdwACM       = paod->dwVersion;
        pdi->fdwOpen      = paod->dwFlags;
        pdi->hkey         = NULL;           // This is important!

        paod->dwError     = MMSYSERR_NOERROR;
    }

    //
    // Get config info for this driver.  If we're not passed an
    // an ACMDRVOPENDESC structure then we'll assume we are being
    // opened for configuration and will put off getting the config
    // info until we receive the DRV_CONFIGURE message.  Otherwise we
    // get the config info now using the alias passed through the
    // ACMDRVOPENDESC structure.
    //
    if (NULL != paod)
    {
#if defined(WIN32) && !defined(UNICODE)
        //
        //  We must translate the UNICODE alias name to an ANSI version
        //  that we can use.
        //
    	LPSTR	lpstr;
        int     iLen;

        //
        //  Calculate required length without calling UNICODE APIs or CRT.
        //
        iLen  = WideCharToMultiByte( GetACP(), 0, paod->pszAliasName,-1,
                                                    NULL, 0, NULL, NULL );

    	lpstr = (LPSTR)GlobalAlloc(GPTR, iLen);
	    if (NULL != lpstr)
	    {
            WideCharToMultiByte( GetACP(), 0, paod->pszAliasName, iLen,
                                    lpstr, iLen, NULL, NULL );
	    }
	    acmdDriverConfigInit(pdi, lpstr);	// Note: OK to pass lpstr==NULL
	    if (NULL != lpstr)
	    {
	        GlobalFree((HGLOBAL)lpstr);
	    }
#else
    	acmdDriverConfigInit(pdi, paod->pszAliasName);
#endif
    }

    //
    //  non-zero return is success for DRV_OPEN
    //
    return ((LRESULT)pdi);
} // acmdDriverOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverClose
//
//  Description:
//      This function handles the DRV_CLOSE message for the ACM driver. The
//      driver receives a DRV_CLOSE message for each succeeded DRV_OPEN
//      message (see acmdDriverOpen). The driver will only receive a close
//      message for _successful_ opens.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//  Return (LRESULT):
//      The return value is non-zero if the open instance can be closed.
//      A zero return signifies that the ACM driver instance could not be
//      closed.
//
//      NOTE! It is _strongly_ recommended that the driver never fail to
//      close. Note that the ACM will never allow a driver instance to
//      be closed if there are open streams. An ACM driver does not need
//      to check for this case.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverClose
(
    PDRIVERINSTANCE         pdi
)
{
    //
    //  Release the registry key, if we allocated one.
    //
    if( NULL != pdi->hkey )
    {
        (void)RegCloseKey( pdi->hkey );
    }


    //
    //  check to see if we allocated instance data. if we did not, then
    //  immediately succeed.
    //
    if (NULL != pdi)
    {
        //
        //  close down the driver instance. this driver simply needs
        //  to free the instance data structure... note that if this
        //  'free' fails, then this ACM driver probably trashed its
        //  heap; assume we didn't do that.
        //
        LocalFree((HLOCAL)pdi);
    }


    //
    //  non-zero return is success for DRV_CLOSE
    //
    return (1L);
} // acmdDriverClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverConfigure
//
//  Description:
//      This function is called to handle the DRV_[QUERY]CONFIGURE messages.
//      These messages are for 'configuration' support of the driver.
//      Normally this will be for 'hardware'--that is, a dialog should be
//      displayed to configure ports, IRQ's, memory mappings, etc if it
//      needs to. However, a software only ACM driver may also require
//      configuration for 'what is real time' or other quality vs time
//      issues.
//
//      The most common way that these messages are generated under Win 3.1
//      and NT Product 1 is from the Control Panel's Drivers option. Other
//      sources may generate these messages in future versions of Windows.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for configuration support.
//
//      LPDRVCONFIGINFO pdci: Pointer to optional DRVCONFIGINFO structure.
//      If this argument is NULL, then the ACM driver should invent its own
//      storage location.
//
//  Return (LRESULT):
//      If the driver is being 'queried' for configuration support (that is,
//      hwnd == (HWND)-1), then non-zero should be returned specifying
//      the driver does support a configuration dialog--or zero should be
//      returned specifying that no configuration dialog is supported.
//
//      If the driver is being called to display the configuration dialog
//      (that is, hwnd != (HWND)-1), then one of the following values
//      should be returned:
//
//      DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
//      and canceled by the user. this value should also be returned if
//      no configuration information was modified.
//
//      DRVCNF_OK (0x0001): specifies that the dialog was displayed and
//      the user pressed OK.  This value should be returned even if the
//      user didn't change anything - otherwise, the driver may not
//      install properly.
//
//      DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
//      and some configuration information was changed that requires
//      Windows to be restarted before the changes take affect. the driver
//      should remain configured with current values until the driver
//      has been 'rebooted'.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverConfigure
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd,
    LPDRVCONFIGINFO         pdci
)
{
    INT_PTR         n;

    //
    //  first check if we are only being queried for configuration
    //  support. if hwnd == (HWND)-1 then we are being queried and should
    //  return zero for 'not supported' and non-zero for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver supports a configuration dialog box, so
        //  return non-zero...
        //
        return (1L);
    }


    //
    //  we are being asked to bring up our configuration dialog. if this
    //  driver supports a configuration dialog box, then after the dialog
    //  is dismissed we must return one of the following values:
    //
    //  DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
    //  and canceled by the user. this value should also be returned if
    //  no configuration information was modified.
    //
    //  DRVCNF_OK (0x0001): specifies that the dialog was displayed and
    //  the user pressed OK.  This value should be returned even if the
    //  user didn't change anything - otherwise, the driver may not
    //  install properly.
    //
    //  DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
    //  and some configuration information was changed that requires
    //  Windows to be restarted before the changes take affect. the driver
    //  should remain configured with current values until the driver
    //  has been 'rebooted'.
    //
    //
    if (NULL == pdci)
    {
        //
        //  !!!
        //
        return (DRVCNF_CANCEL);
    }

    pdi->pdci = pdci;

    //
    // We may not have our config info yet if the driver has only been
    // opened specifically for configuration.  So, read our configuration
    // using the alias passed in the DRVCONFIGINFO structure passed
    // through the DRV_CONFIGURE message
    //
#if (defined(WIN32) && !defined(UNICODE))
    {
        //
        //  We must translate the UNICODE alias name to an ANSI version
        //  that we can use.
        //
    	LPSTR	lpstr;
        int     iLen;

        //
        //  Calculate required length without calling UNICODE APIs or CRT.
        //
        iLen  = WideCharToMultiByte( GetACP(), 0, pdci->lpszDCIAliasName, -1,
                                                    NULL, 0, NULL, NULL );

    	lpstr = (LPSTR)LocalAlloc(LPTR, iLen);
	    if (NULL != lpstr)
	    {
            WideCharToMultiByte( GetACP(), 0, pdci->lpszDCIAliasName, iLen,
                                    lpstr, iLen, NULL, NULL );
	    }
	    acmdDriverConfigInit(pdi, lpstr);	// Note: OK to pass lpstr==NULL
	    if (NULL != lpstr)
	    {
	        LocalFree((HLOCAL)lpstr);
	    }
    }
#else
    acmdDriverConfigInit(pdi, pdci->lpszDCIAliasName);
#endif

    n = DialogBoxParam(pdi->hinst,
                       IDD_CONFIG,
                       hwnd,
                       acmdDlgProcConfigure,
                       (LPARAM)pdi);

    pdi->pdci = NULL;

    return ((LRESULT)n);
} // acmdDriverConfigure()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverDetails
//
//  Description:
//      This function handles the ACMDM_DRIVER_DETAILS message. The ACM
//      driver is responsible for filling in the ACMDRIVERDETAILS structure
//      with various information.
//
//      NOTE! It is *VERY* important that you fill in your ACMDRIVERDETAILS
//      structure correctly. The ACM and applications must be able to
//      rely on this information.
//
//      WARNING! The _reserved_ bits of any fields of the ACMDRIVERDETAILS
//      structure are _exactly that_: RESERVED. Do NOT use any extra
//      flag bits, etc. for custom information. The proper way to add
//      custom capabilities to your ACM driver is this:
//
//      o   define a new message in the ACMDM_USER range.
//
//      o   an application that wishes to use one of these extra features
//          should then:
//
//          o   open the driver with acmDriverOpen.
//
//          o   check for the proper wMid and wPid using acmDriverDetails.
//
//          o   send the 'user defined' message with acmDriverMessage
//              to retrieve additional information, etc.
//
//          o   close the driver with acmDriverClose.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRIVERDETAILS padd: Pointer to ACMDRIVERDETAILS structure to
//      fill in for the caller. This structure may be larger or smaller than
//      the current definition of ACMDRIVERDETAILS--cbStruct specifies the
//      valid size.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) for success. Non-zero
//      signifies that the driver details could not be retrieved.
//
//      NOTE THAT THIS FUNCTION SHOULD NEVER FAIL! There are two possible
//      error conditions:
//
//      o   if padd is NULL or an invalid pointer.
//
//      o   if cbStruct is less than four; in this case, there is not enough
//          room to return the number of bytes filled in.
//
//      Because these two error conditions are easily defined, the ACM
//      will catch these errors. The driver does NOT need to check for these
//      conditions.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMDRIVERDETAILS      padd
)
{
    ACMDRIVERDETAILS    add;
    DWORD               cbStruct;

    //
    //  it is easiest to fill in a temporary structure with valid info
    //  and then copy the requested number of bytes to the destination
    //  buffer.
    //
    cbStruct            = min(padd->cbStruct, sizeof(ACMDRIVERDETAILS));
    add.cbStruct        = cbStruct;


    //
    //  for the current implementation of an ACM driver, the fccType and
    //  fccComp members *MUST* always be ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC
    //  ('audc') and ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (0) respectively.
    //
    add.fccType         = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    add.fccComp         = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;


    //
    //  the manufacturer id (wMid) and product id (wPid) must be filled
    //  in with your company's _registered_ identifier's. for more
    //  information on these identifier's and how to get them registered
    //  contact Microsoft and get the Multimedia Developer Registration Kit:
    //
    //      Microsoft Corporation
    //      Multimedia Technology Group
    //      One Microsoft Way
    //      Redmond, WA 98052-6399
    //
    //      Developer Services Phone: (800) 227-4679 x11771
    //
    //  note that during the development phase or your ACM driver, you may
    //  use the reserved value of '0' for both wMid and wPid. however it
    //  is not acceptable to ship a driver with these values.
    //
    add.wMid            = MM_MICROSOFT;
    add.wPid            = MM_MSFT_ACM_GSM610;


    //
    //  the vdwACM and vdwDriver members contain version information for
    //  the driver.
    //
    //  vdwACM: must contain the version of the *ACM* that the driver was
    //  _designed_ for. this is the _minimum_ version number of the ACM
    //  that the driver will work with. this value must be >= V2.00.000.
    //
    //  vdwDriver: the version of this ACM driver.
    //
    //  ACM driver versions are 32 bit numbers broken into three parts as
    //  follows (note these parts are displayed as decimal values):
    //
    //      bits 24 - 31:   8 bit _major_ version number
    //      bits 16 - 23:   8 bit _minor_ version number
    //      bits  0 - 15:   16 bit build number
    //
    add.vdwACM          = VERSION_MSACM;
    add.vdwDriver       = VERSION_ACM_DRIVER;


    //
    //  the following flags are used to specify the type of conversion(s)
    //  that the ACM driver supports. note that a driver may support one or
    //  more of these flags in any combination.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver
    //  supports conversions from one format tag to another format tag. for
    //  example, if a converter compresses or decompresses WAVE_FORMAT_PCM
    //  and WAVE_FORMAT_IMA_ADPCM, then this bit should be set. this is
    //  true even if the data is not actually changed in size--for example
    //  a conversion from u-Law to A-Law will still set this bit because
    //  the format tags differ.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the
    //  driver supports conversions on the same format tag. as an example,
    //  the PCM converter that is built into the ACM sets this bit (and only
    //  this bit) because it converts only between PCM formats (bits, sample
    //  rate).
    //
    //  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver
    //  supports transformations on a single format tag but does change
    //  the base characteristics of the format (bit depth, sample rate, etc
    //  will remain the same). for example, a driver that changed the
    //  'volume' of PCM data or applied a low pass filter would set this bit.
    //
    add.fdwSupport      = ACMDRIVERDETAILS_SUPPORTF_CODEC;


    //
    //  the number of individual format tags this ACM driver supports. for
    //  example, if a driver uses the WAVE_FORMAT_IMA_ADPCM and
    //  WAVE_FORMAT_PCM format tags, then this value would be two. if the
    //  driver only supports filtering on WAVE_FORMAT_PCM, then this value
    //  would be one. if this driver supported WAVE_FORMAT_ALAW,
    //  WAVE_FORMAT_MULAW and WAVE_FORMAT_PCM, then this value would be
    //  three. etc, etc.
    //
    add.cFormatTags     = ACM_DRIVER_MAX_FORMAT_TAGS;

    //
    //  the number of individual filter tags this ACM driver supports. if
    //  a driver supports no filters (ACMDRIVERDETAILS_SUPPORTF_FILTER is
    //  NOT set in the fdwSupport member), then this value must be zero.
    //
    add.cFilterTags     = ACM_DRIVER_MAX_FILTER_TAGS;


    //
    //  the remaining members in the ACMDRIVERDETAILS structure are sometimes
    //  not needed. because of this we make a quick check to see if we
    //  should go through the effort of filling in these members.
    //
    if (FIELD_OFFSET(ACMDRIVERDETAILS, hicon) < cbStruct)
    {
        //
        //  fill in the hicon member will a handle to a custom icon for
        //  the ACM driver. this allows the driver to be represented by
        //  an application graphically (usually this will be a company
        //  logo or something). if a driver does not wish to have a custom
        //  icon displayed, then simply set this member to NULL and a
        //  generic icon will be displayed instead.
        //
        //  See the MSFILTER sample for a codec which contains a custom icon.
        //
        add.hicon = NULL;

        //
        //  the short name and long name are used to represent the driver
        //  in a unique description. the short name is intended for small
        //  display areas (for example, in a menu or combo box). the long
        //  name is intended for more descriptive displays (for example,
        //  in an 'about box').
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.
        //
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_SHORTNAME, add.szShortName, SIZEOFACMSTR(add.szShortName));
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LONGNAME,  add.szLongName,  SIZEOFACMSTR(add.szLongName));

        //
        //  the last three members are intended for 'about box' information.
        //  these members are optional and may be zero length strings if
        //  the driver wishes.
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.
        //
        if (FIELD_OFFSET(ACMDRIVERDETAILS, szCopyright) < cbStruct)
        {
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_COPYRIGHT, add.szCopyright, SIZEOFACMSTR(add.szCopyright));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LICENSING, add.szLicensing, SIZEOFACMSTR(add.szLicensing));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_FEATURES,  add.szFeatures,  SIZEOFACMSTR(add.szFeatures));
        }
    }


    //
    //  now copy the correct number of bytes to the caller's buffer
    //
    _fmemcpy(padd, &add, (UINT)add.cbStruct);


    //
    //  success!
    //
    return (MMSYSERR_NOERROR);
} // acmdDriverDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverAbout
//
//  Description:
//      This function is called to handle the ACMDM_DRIVER_ABOUT message.
//      An ACM driver has the option of displaying its own 'about box' or
//      letting the ACM (or calling application) display one for it. This
//      message is normally sent by the Control Panel's Sound Mapper
//      option.
//
//      It is recommended that an ACM driver allow a default about box
//      be displayed for it--there should be no reason to bloat the size
//      of a driver to simply display copyright, etc information when that
//      information is contained in the ACMDRIVERDETAILS structure.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for about box support.
//
//  Return (LRESULT):
//      The return value is MMSYSERR_NOTSUPPORTED if the ACM driver does
//      not support a custom dialog box. In this case, the ACM or calling
//      application will display a generic about box using the information
//      contained in the ACMDRIVERDETAILS structure returned by the
//      ACMDM_DRIVER_DETAILS message.
//
//      If the driver chooses to display its own dialog box, then after
//      the dialog is dismissed by the user, MMSYSERR_NOERROR should be
//      returned.
//
//      If the hwnd argument is equal to (HWND)-1, then no dialog should
//      be displayed (the driver is only being queried for support). The
//      driver must still return MMSYSERR_NOERROR (supported) or
//      MMSYSERR_NOTSUPPORTED (no custom about box supported).
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverAbout
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd
)
{
    //
    //  first check to see if we are only being queried for custom about
    //  box support. if hwnd == (HWND)-1 then we are being queried and
    //  should return MMSYSERR_NOTSUPPORTED for 'not supported' and
    //  MMSYSERR_NOERROR for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver does NOT support a custom about box, so
        //  return MMSYSERR_NOTSUPPORTED...
        //
        return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  this driver does not support a custom dialog, so tell the ACM or
    //  calling application to display one for us. note that this is the
    //  _recommended_ method for consistency and simplicity of ACM drivers.
    //  why write code when you don't have to?
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdDriverAbout()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatSuggest
//
//  Description:
//      This function handles the ACMDM_FORMAT_SUGGEST message. The purpose
//      of this function is to provide a way for the ACM, a wave mapper or
//      an application to quickly get a destination format that this driver
//      can convert the source format to. The 'suggested' format should
//      be as close to a common format as possible. This message is normally
//      sent in response to an acmFormatSuggest function call.
//
//      Another way to think about this message is: what format would this
//      driver like to convert the source format to?
//
//      The caller may place restrictions on the destination format that
//      should be suggested. The padfs->fdwSuggest member contains the
//      restriction bits passed by the caller--see the description for
//      the return value for more information.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVFORMATSUGGEST padfs: Pointer to an ACMDRVFORMATSUGGEST
//      structure that describes the source and destination (possibly with
//      restrictions) for a conversion.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if one or more of
//      the destination restriction bits is not supported. It is strongly
//      recommended that the driver support at least the following suggestion
//      restriction bits:
//
//      ACM_FORMATSUGGESTF_WFORMATTAG: The destination format tag must be
//      the same as the wFormatTag member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NCHANNELS: The destination channel count must be
//      the same as the nChannels member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NSAMPLESPERSEC: The destination samples per
//      second must be the same as the nSamplesPerSec member in the
//      destination format header.
//
//      ACM_FORMATSUGGESTF_WBITSPERSAMPLE: The destination bits per sample
//      must be the same as the wBitsPerSample member in the destination
//      format header.
//
//      If no destintation format can be suggested, then the driver should
//      return ACMERR_NOTPOSSIBLE.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatSuggest
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVFORMATSUGGEST   padfs
)
{
    #define ACMD_FORMAT_SUGGEST_SUPPORT (ACM_FORMATSUGGESTF_WFORMATTAG |    \
                                         ACM_FORMATSUGGESTF_NCHANNELS |     \
                                         ACM_FORMATSUGGESTF_NSAMPLESPERSEC |\
                                         ACM_FORMATSUGGESTF_WBITSPERSAMPLE)

    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
    DWORD                   fdwSuggest;


    //
    //  grab the suggestion restriction bits and verify that we support
    //  the ones that are specified... an ACM driver must return the
    //  MMSYSERR_NOTSUPPORTED if the suggestion restriction bits specified
    //  are not supported.
    //
    fdwSuggest = (ACM_FORMATSUGGESTF_TYPEMASK & padfs->fdwSuggest);

    if (~ACMD_FORMAT_SUGGEST_SUPPORT & fdwSuggest)
        return (MMSYSERR_NOTSUPPORTED);


    //
    //  get the source and destination formats in more convenient variables
    //
    pwfxSrc = padfs->pwfxSrc;
    pwfxDst = padfs->pwfxDst;


    //
    //
    //
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            //
            //  strictly verify that the source format is acceptable for
            //  this driver.
            //
            if (!pcmIsValidFormat(pwfxSrc))
                break;


            //
            //  if the destination format tag is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is able to encode only to GSM 6.10
            //
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                if (WAVE_FORMAT_GSM610 != pwfxDst->wFormatTag)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wFormatTag = WAVE_FORMAT_GSM610;
            }


            //
            //  if the destination channel count is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is not able to change the number of channels
            //
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if (pwfxSrc->nChannels != pwfxDst->nChannels)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = pwfxSrc->nChannels;
            }


            //
            //  if the destination samples per second is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is not able to change the sample rate
            //
            if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
            {
                if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
            }


            //
            //  if the destination bits per sample is restricted, verify
            //  that it is within our capabilities...
            //
            if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
            {
                if (GSM610_BITS_PER_SAMPLE != pwfxDst->wBitsPerSample)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wBitsPerSample = GSM610_BITS_PER_SAMPLE;
            }


            //
            //  at this point, we have filled in all fields except the
            //  following for our 'suggested' destination format:
            //
            //      nAvgBytesPerSec
            //      nBlockAlign
            //      cbSize
	    //	    wSamplesPerBlock
            //
            pwfxDst->nBlockAlign     = GSM610_BLOCKALIGNMENT(pwfxDst);
            pwfxDst->nAvgBytesPerSec = GSM610_AVGBYTESPERSEC(pwfxDst);
            pwfxDst->cbSize          = GSM610_WFX_EXTRA_BYTES;
	    ((LPGSM610WAVEFORMAT)pwfxDst)->wSamplesPerBlock
		    = GSM610_SAMPLESPERBLOCK(pwfxDst);

            return (MMSYSERR_NOERROR);


        case WAVE_FORMAT_GSM610:
            //
            //  strictly verify that the source format is acceptable for
            //  this driver
            //
            if (!gsm610IsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);


            //
            //  if the destination format tag is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is able to decode to PCM
            //
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                if (WAVE_FORMAT_PCM != pwfxDst->wFormatTag)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wFormatTag = WAVE_FORMAT_PCM;
            }


            //
            //  if the destination channel count is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is not able to change the number of channels
            //
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if (pwfxSrc->nChannels != pwfxDst->nChannels)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = pwfxSrc->nChannels;
            }


            //
            //  if the destination samples per second is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is not able to change the sample rate
            //
            if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
            {
                if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
            }


            //
            //  if the destination bits per sample is restricted, verify
            //  that it is within our capabilities...
            //
            //  We prefer decoding to 16-bit PCM.
            //
            if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
            {
                if ( (16 != pwfxDst->wBitsPerSample) && (8 != pwfxDst->wBitsPerSample) )
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wBitsPerSample = 16;
            }


            //
            //  at this point, we have filled in all fields except the
            //  following for our 'suggested' destination format:
            //
            //      nAvgBytesPerSec
            //      nBlockAlign
            //      cbSize              !!! not used for PCM !!!
            //
            pwfxDst->nBlockAlign     = PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfxDst);
            pwfxDst->nAvgBytesPerSec = PCM_AVGBYTESPERSEC((LPPCMWAVEFORMAT)pwfxDst);

            // pwfxDst->cbSize       = not used;
            return (MMSYSERR_NOERROR);
    }


    //
    //  can't suggest anything because either the source format is foreign
    //  or the destination format has restrictions that this ACM driver
    //  cannot deal with.
    //
    return (ACMERR_NOTPOSSIBLE);
} // acmdFormatSuggest()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatTagDetails
//
//  Description:
//      This function handles the ACMDM_FORMATTAG_DETAILS message. This
//      message is normally sent in response to an acmFormatTagDetails or
//      acmFormatTagEnum function call. The purpose of this function is
//      to get details about a specific format tag supported by this ACM
//      driver.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATTAGDETAILS padft: Pointer to an ACMFORMATTAGDETAILS
//      structure that describes what format tag to retrieve details for.
//
//      DWORD fdwDetails: Flags defining what format tag to retrieve the
//      details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATTAGDETAILSF_INDEX: Indicates that a format tag index
//      was given in the dwFormatTagIndex member of the ACMFORMATTAGDETAILS
//      structure. The format tag and details must be returned in the
//      structure specified by padft. The index ranges from zero to one less
//      than the cFormatTags member returned in the ACMDRIVERDETAILS
//      structure for this driver.
//
//      ACM_FORMATTAGDETAILSF_FORMATTAG: Indicates that a format tag
//      was given in the dwFormatTag member of the ACMFORMATTAGDETAILS
//      structure. The format tag details must be returned in the structure
//      specified by padft.
//
//      ACM_FORMATTAGDETAILSF_LARGESTSIZE: Indicates that the details
//      on the format tag with the largest format size in bytes must be
//      returned. The dwFormatTag member will either be WAVE_FORMAT_UNKNOWN
//      or the format tag to find the largest size for.
//
//      If the details for the specified format tag cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatTagDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT                uFormatTag;

    //
    //
    //
    //
    //
    switch (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            //
            //  if the index is too large, then they are asking for a
            //  non-existant format. return error.
            //
            if (ACM_DRIVER_MAX_FORMAT_TAGS <= padft->dwFormatTagIndex)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = gauFormatTagIndexToTag[(UINT)padft->dwFormatTagIndex];
            break;


        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_UNKNOWN:
                case WAVE_FORMAT_GSM610:
                    uFormatTag = WAVE_FORMAT_GSM610;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_GSM610:
                    uFormatTag = WAVE_FORMAT_GSM610;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        //
        //  if this ACM driver does not understand a query type, then
        //  return 'not supported'
        //
        default:
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //
    //
    //
    switch (uFormatTag)
    {
        case WAVE_FORMAT_PCM:
            padft->dwFormatTagIndex = 0;
            padft->dwFormatTag      = WAVE_FORMAT_PCM;
            padft->cbFormatSize     = sizeof(PCMWAVEFORMAT);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_PCM;

            //
            //  the ACM is responsible for the PCM format tag name
            //
            padft->szFormatTag[0] = '\0';
            break;

        case WAVE_FORMAT_GSM610:
            padft->dwFormatTagIndex = 1;
            padft->dwFormatTag      = WAVE_FORMAT_GSM610;
            padft->cbFormatSize     = sizeof(GSM610WAVEFORMAT);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_GSM610;

            LoadStringCodec(pdi->hinst,
                       IDS_ACM_DRIVER_TAG_NAME,
                       padft->szFormatTag,
                       SIZEOFACMSTR(padft->szFormatTag));
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATTAGDETAILS structure
    //  passed is at least large enough to hold the base information of
    //  the details structure
    //
    padft->cbStruct = min(padft->cbStruct, sizeof(*padft));


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatTagDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatDetails
//
//  Description:
//      This function handles the ACMDM_FORMAT_DETAILS message. This
//      message is normally sent in response to an acmFormatDetails or
//      acmFormatEnum function call. The purpose of this function is
//      to get details about a specific format for a specified format tag
//      supported by this ACM driver.
//
//      Note that an ACM driver can return a zero length string for the
//      format name if it wishes to have the ACM create a format string
//      for it. This is strongly recommended to simplify internationalizing
//      the driver--the ACM will automatically take care of that. The
//      following formula is used to format a string by the ACM:
//
//      <nSamplesPerSec> kHz, <bit depth> bit, [Mono | Stereo | nChannels]
//
//      <bit depth> = <nAvgBytesPerSec> * 8 / nSamplesPerSec / nChannels;
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATDETAILS padf: Pointer to an ACMFORMATDETAILS structure
//      that describes what format (for a specified format tag) to retrieve
//      details for.
//
//      DWORD fdwDetails: Flags defining what format for a specified format
//      tag to retrieve the details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATDETAILSF_INDEX: Indicates that a format index for the
//      format tag was given in the dwFormatIndex member of the
//      ACMFORMATDETAILS structure. The format details must be returned in
//      the structure specified by padf. The index ranges from zero to one
//      less than the cStandardFormats member returned in the
//      ACMFORMATTAGDETAILS structure for a format tag.
//
//      ACM_FORMATDETAILSF_FORMAT: Indicates that a WAVEFORMATEX structure
//      pointed to by pwfx of the ACMFORMATDETAILS structure was given and
//      the remaining details should be returned. The dwFormatTag member
//      of the ACMFORMATDETAILS will be initialized to the same format
//      tag as the pwfx member specifies. This query type may be used to
//      get a string description of an arbitrary format structure.
//
//      If the details for the specified format cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATDETAILS      padf,
    DWORD                   fdwDetails
)
{
    LPWAVEFORMATEX      pwfx;
    UINT		uq;		// quotient and
    UINT		ur;		// remainder for arithmetic below.


    //
    //
    //
    //
    //
    switch (ACM_FORMATDETAILSF_QUERYMASK & fdwDetails)
    {
        //
        //  enumerate by index
        //
        //  verify that the format tag is something we know about and
        //  return the details on the 'standard format' supported by
        //  this driver at the specified index...
        //
        case ACM_FORMATDETAILSF_INDEX:
            //
            //  put some stuff in more accessible variables--note that we
            //  bring variable sizes down to a reasonable size for 16 bit
            //  code...
            //
            pwfx = padf->pwfx;

            switch (padf->dwFormatTag)
            {
                case WAVE_FORMAT_PCM:
		    if (ACM_DRIVER_MAX_FORMATS_PCM <= padf->dwFormatIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    //
                    //  now fill in the format structure
		    //
                    pwfx->wFormatTag      = WAVE_FORMAT_PCM;

		    uq = (UINT) padf->dwFormatIndex;
		
		    ur = uq % ACM_DRIVER_MAX_CHANNELS;
		    uq = uq / ACM_DRIVER_MAX_CHANNELS;
		    pwfx->nChannels	    = ur + 1;

		    ur = uq % ACM_DRIVER_MAX_BITSPERSAMPLE_PCM;
		    uq = uq / ACM_DRIVER_MAX_BITSPERSAMPLE_PCM;
		    pwfx->wBitsPerSample =  (WORD)gauPcmFormatIndexToBitsPerSample[ur];

		    ur = uq % ACM_DRIVER_MAX_SAMPLE_RATES;
		    uq = uq / ACM_DRIVER_MAX_SAMPLE_RATES;
                    pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[ur];

                    pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfx);
                    pwfx->nAvgBytesPerSec = PCM_AVGBYTESPERSEC((LPPCMWAVEFORMAT)pwfx);

                    //
                    //  note that the cbSize field is NOT valid for PCM
                    //  formats
                    //
                    //  pwfx->cbSize      = 0;

                    break;


                case WAVE_FORMAT_GSM610:
                    if (ACM_DRIVER_MAX_FORMATS_GSM610 <= padf->dwFormatIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    pwfx->wFormatTag      = LOWORD(padf->dwFormatTag);

		    uq = (UINT) padf->dwFormatIndex;
		
		    ur = uq % ACM_DRIVER_MAX_CHANNELS;
		    uq = uq / ACM_DRIVER_MAX_CHANNELS;
		    pwfx->nChannels =	    ur + 1;

		    ur = uq % ACM_DRIVER_MAX_SAMPLE_RATES;
		    uq = uq / ACM_DRIVER_MAX_SAMPLE_RATES;
                    pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[ur];

                    pwfx->wBitsPerSample  = GSM610_BITS_PER_SAMPLE;

                    pwfx->nBlockAlign     = GSM610_BLOCKALIGNMENT(pwfx);
                    pwfx->nAvgBytesPerSec = GSM610_AVGBYTESPERSEC(pwfx);

		    //
		    //
		    //
                    pwfx->cbSize          = GSM610_WFX_EXTRA_BYTES;
		
		    ((LPGSM610WAVEFORMAT)pwfx)->wSamplesPerBlock
					  = GSM610_SAMPLESPERBLOCK(pwfx);
		
		    //
		    //	acm format details support flags.
		    //
		    padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_CODEC;
		
                    break;


                default:
                    return (ACMERR_NOTPOSSIBLE);
            }

        //
        //  return details on specified format
        //
        //  the caller normally uses this to verify that the format is
        //  supported and to retrieve a string description...
        //
        case ACM_FORMATDETAILSF_FORMAT:
            pwfx = padf->pwfx;

            switch (pwfx->wFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (!pcmIsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
		    break;

                case WAVE_FORMAT_GSM610:
                    if (!gsm610IsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        default:
            //
            //  don't know how to do the query type passed--return 'not
            //  supported'.
            //
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  return the size of the valid information we are returning
    //
    //  the ACM will guarantee that the ACMFORMATDETAILS structure
    //  passed is at least large enough to hold the base structure
    //
    //  note that we let the ACM create the format string for us since
    //  we require no special formatting (and don't want to deal with
    //  internationalization issues, etc). simply set the string to
    //  a zero length.
    //

    //
    //	acm format details support flags.  if 8-bit pcm is
    //	completely disabled (both realtime and non-realtime)
    //	then don't set SUPPORTF_CODEC.
    //
	padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_CODEC;

    padf->cbStruct    = min(padf->cbStruct, sizeof(*padf));
    padf->szFormat[0] = '\0';


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatDetails()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamOpen
//
//  Description:
//      This function handles the ACMDM_STREAM_OPEN message. This message
//      is sent to initiate a new conversion stream. This is usually caused
//      by an application calling acmStreamOpen. If this function is
//      successful, then one or more ACMDM_STREAM_CONVERT messages will be
//      sent to convert individual buffers (user calls acmStreamConvert).
//
//      Note that an ACM driver will not receive open requests for ASYNC
//      or FILTER operations unless the ACMDRIVERDETAILS_SUPPORTF_ASYNC
//      or ACMDRIVERDETAILS_SUPPORTF_FILTER flags are set in the
//      ACMDRIVERDETAILS structure. There is no need for the driver to
//      check for these requests unless it sets those support bits.
//
//      If the ACM_STREAMOPENF_QUERY flag is set in the padsi->fdwOpen
//      member, then no resources should be allocated. Just verify that
//      the conversion request is possible by this driver and return the
//      appropriate error (either ACMERR_NOTPOSSIBLE or MMSYSERR_NOERROR).
//      The driver will NOT receive an ACMDM_STREAM_CLOSE for queries.
//
//      If the ACM_STREAMOPENF_NONREALTIME bit is NOT set, then conversion
//      must be done in 'real-time'. This is a tough one to describe
//      exactly. If the driver may have trouble doing the conversion without
//      breaking up the audio, then a configuration dialog might be used
//      to allow the user to specify whether the real-time conversion
//      request should be succeeded. DO NOT SUCCEED THE CALL UNLESS YOU
//      ACTUALLY CAN DO REAL-TIME CONVERSIONS! There may be another driver
//      installed that can--so if you succeed the call you are hindering
//      the performance of the user's system!
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      This structure will be passed back to all future stream messages
//      if the open succeeds. The information in this structure will never
//      change during the lifetime of the stream--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      A driver should return ACMERR_NOTPOSSIBLE if the conversion cannot
//      be performed due to incompatible source and destination formats.
//
//      A driver should return MMSYSERR_NOTSUPPORTED if the conversion
//      cannot be performed in real-time and the request does not specify
//      the ACM_STREAMOPENF_NONREALTIME flag.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamOpen
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    BOOL                fRealTime;
    STREAMCONVERTPROC   fnConvert;
    PSTREAMINSTANCE     psi;
    DWORD               nConfigMaxRTEncodeSamplesPerSec;
    DWORD               nConfigMaxRTDecodeSamplesPerSec;

    DWORD               dw;


    //
    //
    //
    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    fRealTime = (0 == (padsi->fdwOpen & ACM_STREAMOPENF_NONREALTIME));

    nConfigMaxRTEncodeSamplesPerSec =
                gaRateListFormat[pdi->nConfigMaxRTEncodeSetting].dwMonoRate;
    DPF(2,"nConfigMaxRTEncodeSamplesPerSec=%u",nConfigMaxRTEncodeSamplesPerSec);

    nConfigMaxRTDecodeSamplesPerSec =
                gaRateListFormat[pdi->nConfigMaxRTDecodeSetting].dwMonoRate;
    DPF(2,"nConfigMaxRTDecodeSamplesPerSec=%u",nConfigMaxRTDecodeSamplesPerSec);


    //
    //  the most important condition to check before doing anything else
    //  is that this ACM driver can actually perform the conversion we are
    //  being opened for. this check should fail as quickly as possible
    //  if the conversion is not possible by this driver.
    //
    //  it is VERY important to fail quickly so the ACM can attempt to
    //  find a driver that is suitable for the conversion. also note that
    //  the ACM may call this driver several times with slightly different
    //  format specifications before giving up.
    //
    //  this driver first verifies that the source and destination formats
    //  are acceptable...
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            if (!pcmIsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);

            if (!gsm610IsValidFormat(pwfxDst))
                return (ACMERR_NOTPOSSIBLE);

            //
            //  if a driver cannot perform real-time encoding then
            //  the driver should fail when opened for a real-time
            //  conversion. note that the driver MUST return
            //  MMSYSERR_NOTSUPPORTED in this case!
            //
            //  this driver may or may not be able to perform real-time
            //  encoding, depending on the system on which it is running.
            //  this driver allows the user to select whether to support
            //  real-time encoding thru the config dialog.
            //
            //  if this open is for a real-time conversion, fail if
            //  real-time encoding hasn't been enabled in the config
            //  dialog.
            //
            if (fRealTime)
            {
                dw = nConfigMaxRTEncodeSamplesPerSec;
                dw = dw / pwfxSrc->nChannels;
                if (dw < pwfxSrc->nSamplesPerSec)
                {
                    return (MMSYSERR_NOTSUPPORTED);
                }
            }

            fnConvert = gsm610Encode;
            break;


        case WAVE_FORMAT_GSM610:
            if (!gsm610IsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);

            if (!pcmIsValidFormat(pwfxDst))
                return (ACMERR_NOTPOSSIBLE);

            //
            //  if a driver cannot perform real-time encoding then
            //  the driver should fail when opened for a real-time
            //  conversion. note that the driver MUST return
            //  MMSYSERR_NOTSUPPORTED in this case!
            //
            //  this driver may or may not be able to perform real-time
            //  encoding, depending on the system on which it is running.
            //  this driver allows the user to select whether to support
            //  real-time encoding thru the config dialog.
            //
            //  if this open is for a real-time conversion, fail if
            //  real-time encoding hasn't been enabled in the config
            //  dialog.
            //
            if (fRealTime)
            {
                dw = nConfigMaxRTDecodeSamplesPerSec;
                dw = dw / pwfxSrc->nChannels;
                if (dw < pwfxSrc->nSamplesPerSec)
                {
                    return (MMSYSERR_NOTSUPPORTED);
                }
            }

            fnConvert = gsm610Decode;
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  for this driver, we must also verify that the nChannels and
    //  nSamplesPerSec members are the same between the source and
    //  destination formats.
    //
    if (pwfxSrc->nChannels != pwfxDst->nChannels)
        return (MMSYSERR_NOTSUPPORTED);

    if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
        return (MMSYSERR_NOTSUPPORTED);


    //
    //  we have determined that the conversion requested is possible by
    //  this driver. now check if we are just being queried for support.
    //  if this is just a query, then do NOT allocate any instance data
    //  or create tables, etc. just succeed the call.
    //
    if (0 != (ACM_STREAMOPENF_QUERY & padsi->fdwOpen))
    {
        return (MMSYSERR_NOERROR);
    }


    //
    //  we have decided that this driver can handle the conversion stream.
    //  so we want to do _AS MUCH WORK AS POSSIBLE_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.
    //
    //  this driver allocates a small instance structure for each stream
    //
    //
    psi = (PSTREAMINSTANCE)LocalAlloc(LPTR, sizeof(*psi));
    if (NULL == psi)
    {
        return (MMSYSERR_NOMEM);
    }


    //
    //  fill out our instance structure
    //
    //  this driver stores a pointer to the conversion function that will
    //  be used for each conversion on this stream. we also store a
    //  copy of the _current_ configuration of the driver instance we
    //  are opened on. this must not change during the life of the stream
    //  instance.
    //
    //  this is also very important! if the user is able to configure how
    //  the driver performs conversions, the changes should only affect
    //  future open streams. all current open streams should behave as
    //  they were configured during the open.
    //
    psi->fnConvert  = fnConvert;

    //
    //  this driver must also initialize of few things
    //
    gsm610Reset(psi);


    //
    //  fill in our instance data--this will be passed back to all stream
    //  messages in the ACMDRVSTREAMINSTANCE structure. it is entirely
    //  up to the driver what gets stored (and maintained) in the
    //  fdwDriver and dwDriver members.
    //
    padsi->fdwDriver = 0L;
    padsi->dwDriver  = (DWORD_PTR)psi;

    return (MMSYSERR_NOERROR);
} // acmdStreamOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamClose
//
//  Description:
//      This function is called to handle the ACMDM_STREAM_CLOSE message.
//      This message is sent when a conversion stream is no longer being
//      used (the stream is being closed; usually by an application
//      calling acmStreamClose). The ACM driver should clean up any resources
//      that were allocated for the stream.
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      NOTE! It is _strongly_ recommended that a driver not fail to close
//      a conversion stream.
//
//      An asyncronous conversion stream may fail with ACMERR_BUSY if there
//      are pending buffers. An application may call acmStreamReset to
//      force all pending buffers to be posted.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamClose
(
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    PSTREAMINSTANCE     psi;

    //
    //  the driver should clean up all privately allocated resources that
    //  were created for maintaining the stream instance. if no resources
    //  were allocated, then simply succeed.
    //
    //  in the case of this driver, we need to free the stream instance
    //  structure that we allocated during acmdStreamOpen.
    //
    psi = (PSTREAMINSTANCE)padsi->dwDriver;
    if (NULL != psi)
    {
        //
        //  free the stream instance structure
        //
        LocalFree((HLOCAL)psi);
    }

    return (MMSYSERR_NOERROR);
} // acmdStreamClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamSize
//
//  Description:
//      This function handles the ACMDM_STREAM_SIZE message. The purpose
//      of this function is to provide the _largest size in bytes_ that
//      the source or destination buffer needs to be given the input and
//      output formats and the size in bytes of the source or destination
//      data buffer.
//
//      In other words: how big does my destination buffer need to be to
//      hold the converted data? (ACM_STREAMSIZEF_SOURCE)
//
//      Or: how big can my source buffer be given the destination buffer?
//      (ACM_STREAMSIZEF_DESTINATION)
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMSIZE padss: Specifies a pointer to the ACMDRVSTREAMSIZE
//      structure that defines the conversion stream size query attributes.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      An ACM driver should return MMSYSERR_NOTSUPPORTED if a query type
//      is requested that the driver does not understand. Note that a driver
//      must support both the ACM_STREAMSIZEF_DESTINATION and
//      ACM_STREAMSIZEF_SOURCE queries.
//
//      If the conversion would be 'out of range' given the input arguments,
//      then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamSize
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
)
{
    PSTREAMINSTANCE     psi;
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    DWORD               cb;
    DWORD		dwcSamples;
    DWORD               cBlocks;

    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    //
    //
    //
    //
    //
    switch (ACM_STREAMSIZEF_QUERYMASK & padss->fdwSize)
    {
	case ACM_STREAMSIZEF_SOURCE:

            if (WAVE_FORMAT_GSM610 == pwfxSrc->wFormatTag)
            {
                //
                //  how many destination PCM bytes are needed to hold
                //  the decoded GSM 6.10 data of padss->cbSrcLength bytes
                //
                //  always round UP
                //
		cb = padss->cbSrcLength;
		cBlocks = cb / GSM610_BLOCKALIGNMENT(pwfxSrc);

                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                if ((0xFFFFFFFFL / (GSM610_SAMPLESPERBLOCK(pwfxSrc))) < cBlocks)
                    return (ACMERR_NOTPOSSIBLE);
		dwcSamples = cBlocks * GSM610_SAMPLESPERBLOCK(pwfxSrc);

		if (PCM_BYTESTOSAMPLES(((LPPCMWAVEFORMAT)(pwfxDst)), 0xFFFFFFFFL) < dwcSamples)
		    return (ACMERR_NOTPOSSIBLE);
		cb = PCM_SAMPLESTOBYTES(((LPPCMWAVEFORMAT)(pwfxDst)), dwcSamples);

            }
            else
            {
                //
                //  how many destination GSM 6.10 bytes are needed to hold
                //  the encoded PCM data of padss->cbSrcLength bytes
                //
                //  always round UP
                //
		cb = padss->cbSrcLength;
		dwcSamples = PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)(pwfxSrc), cb);
                cBlocks = dwcSamples / GSM610_SAMPLESPERBLOCK(pwfxDst);
		
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

		if (0 != dwcSamples % GSM610_SAMPLESPERBLOCK(pwfxDst))
		{
		    // Another block to possibly hold the last
		    // fragment of source data if acmdStreamConvert
		    // is called without block align
		    cBlocks++;
		}

                cb = cBlocks * GSM610_BLOCKALIGNMENT(pwfxDst);
            }

            padss->cbDstLength = cb;
            return (MMSYSERR_NOERROR);

        case ACM_STREAMSIZEF_DESTINATION:

            if (WAVE_FORMAT_GSM610 == pwfxDst->wFormatTag)
            {
                //
                //  how many source PCM bytes can be encoded into a
                //  destination buffer of padss->cbDstLength bytes
                //
                //  always round DOWN
                //
		cb = padss->cbDstLength;
                cBlocks = cb / GSM610_BLOCKALIGNMENT(pwfxDst);

                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                if ((0xFFFFFFFFL / (GSM610_SAMPLESPERBLOCK(pwfxDst))) < cBlocks)
		    return (ACMERR_NOTPOSSIBLE);
		dwcSamples = cBlocks * GSM610_SAMPLESPERBLOCK(pwfxDst);

		if (PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)pwfxSrc, 0xFFFFFFFFL) < dwcSamples)
		    return (ACMERR_NOTPOSSIBLE);
		cb = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)pwfxSrc, dwcSamples);

            }
            else
            {
                //
                //  how many source GSM 6.10 bytes can be decoded into a
                //  destination buffer of padss->cbDstLength bytes
                //
                //  always round DOWN
                //
		cb = padss->cbDstLength;
		dwcSamples = PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)(pwfxDst), cb);
		cBlocks = dwcSamples / GSM610_SAMPLESPERBLOCK(pwfxSrc);

                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                cb = cBlocks * GSM610_BLOCKALIGNMENT(pwfxSrc);
            }

            padss->cbSrcLength = cb;
            return (MMSYSERR_NOERROR);

    }

    //
    //  if the query type is not understood by this driver, then we need
    //  to return MMSYSERR_NOTSUPPORTED.
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdStreamSize()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT DriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      the driver is opened, through the OpenDriver API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNEXPORT DriverProc
(
    DWORD_PTR               dwId,
    HDRVR                   hdrvr,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT             lr;
    PDRIVERINSTANCE     pdi;

    //
    //  make pdi either NULL or a valid instance pointer. note that dwId
    //  is 0 for several of the DRV_* messages (ie DRV_LOAD, DRV_OPEN...)
    //  see acmdDriverOpen for information on what dwId is for other
    //  messages (instance data).
    //
    pdi = (PDRIVERINSTANCE)dwId;

    switch (uMsg)
    {
        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_LOAD:
#ifdef WIN32
            DbgInitialize(TRUE);
	    DPF(4, "DRV_LOAD");
#endif
            return(1L);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_FREE:
	    DPF(4, "DRV_FREE");
            return (1L);

        //
        //  lParam1: Not used. Ignore this argument.
        //
        //  lParam2: Pointer to ACMDRVOPENDESC (or NULL).
        //
        case DRV_OPEN:
	    DPF(4, "DRV_OPEN");
            lr = acmdDriverOpen(hdrvr, (LPACMDRVOPENDESC)lParam2);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_CLOSE:
	    DPF(4, "DRV_CLOSE");
            lr = acmdDriverClose(pdi);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_INSTALL:
	    DPF(4, "DRV_INSTALL");
            return ((LRESULT)DRVCNF_RESTART);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_REMOVE:
	    DPF(4, "DRV_REMOVE");
            return ((LRESULT)DRVCNF_RESTART);



        //
        //  lParam1: Not used.
        //
        //  lParam2: Not used.
        //
        case DRV_QUERYCONFIGURE:
	    DPF(4, "DRV_QUERYCONFIGURE");
            //
            //  set up lParam1 and lParam2 to values that can be used by
            //  acmdDriverConfigure to know that it is being 'queried'
            //  for configuration support.
            //
            lParam1 = -1L;
            lParam2 = 0L;

            //--fall through--//

        //
        //  lParam1: Handle to parent window for the configuration dialog
        //           box.
        //
        //  lParam2: Optional pointer to DRVCONFIGINFO structure.
        //
        case DRV_CONFIGURE:
	    DPF(4, "DRV_CONFIGURE");
            lr = acmdDriverConfigure(pdi, (HWND)lParam1, (LPDRVCONFIGINFO)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to ACMDRIVERDETAILS structure.
        //
        //  lParam2: Size in bytes of ACMDRIVERDETAILS stucture passed.
        //
        case ACMDM_DRIVER_DETAILS:
	    DPF(4, "ACMDM_DRIVER_DETAILS");
            lr = acmdDriverDetails(pdi, (LPACMDRIVERDETAILS)lParam1);
            return (lr);

        //
        //  lParam1: Handle to parent window to use if displaying your own
        //           about box.
        //
        //  lParam2: Not used.
        //
        case ACMDM_DRIVER_ABOUT:
	    DPF(4, "ACMDM_DRIVER_ABOUT");
            lr = acmdDriverAbout(pdi, (HWND)lParam1);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVFORMATSUGGEST structure.
        //
        //  lParam2: Not used.
        //
       case ACMDM_FORMAT_SUGGEST:
	    DPF(4, "ACMDM_FORMAT_SUGGEST");
            lr = acmdFormatSuggest(pdi, (LPACMDRVFORMATSUGGEST)lParam1);
            return (lr);


        //
        //  lParam1: Pointer to FORMATTAGDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMATTAG_DETAILS:
	    DPF(4, "ACMDM_FORMATTAG_DETAILS");
            lr = acmdFormatTagDetails(pdi, (LPACMFORMATTAGDETAILS)lParam1, (DWORD)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to FORMATDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMAT_DETAILS:
	    DPF(4, "ACMDM_FORMAT_DETAILS");
            lr = acmdFormatDetails(pdi, (LPACMFORMATDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not used.
        //
        case ACMDM_STREAM_OPEN:
	    DPF(4, "ACMDM_STREAM_OPEN");
            lr = acmdStreamOpen(pdi, (LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not Used.
        //
        case ACMDM_STREAM_CLOSE:
	    DPF(4, "ACMDM_STREAM_CLOSE");
            lr = acmdStreamClose((LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMSIZE structure.
        //
        case ACMDM_STREAM_SIZE:
	    DPF(4, "ACMDM_STREAM_SIZE");
            lr = acmdStreamSize((LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMSIZE)lParam2);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMHEADER structure.
        //
        case ACMDM_STREAM_CONVERT:
	{
	    PSTREAMINSTANCE         psi;
	    LPACMDRVSTREAMINSTANCE  padsi;
	    LPACMDRVSTREAMHEADER    padsh;

	    DPF(4, "ACMDM_STREAM_CONVERT");
            //
            //  our stream instance data is a pointer to the conversion
            //  procedure needed to convert the pwfxSrc data to pwfxDst.
            //  the correct procedure to use was decided in acmdStreamOpen
            //
            padsi = (LPACMDRVSTREAMINSTANCE)lParam1;
            padsh = (LPACMDRVSTREAMHEADER)lParam2;

            psi   = (PSTREAMINSTANCE)padsi->dwDriver;

            lr = psi->fnConvert(padsi, padsh);
            return (lr);
        }
    }

    //
    //  if we are executing the following code, then this ACM driver does not
    //  handle the message that was sent. there are two ranges of messages
    //  we need to deal with:
    //
    //  o   ACM specific driver messages: if an ACM driver does not answer a
    //      message sent in the ACM driver message range, then it must
    //      return MMSYSERR_NOTSUPPORTED. this applies to the 'user'
    //      range as well (for consistency).
    //
    //  o   other installable driver messages: if an ACM driver does not
    //      answer a message that is NOT in the ACM driver message range,
    //      then it must call DefDriverProc and return that result.
    //      the exception to this is ACM driver procedures installed as
    //      ACM_DRIVERADDF_FUNCTION through acmDriverAdd. in this case,
    //      the driver procedure should conform to the ACMDRIVERPROC
    //      prototype and also return zero instead of calling DefDriverProc.
    //
    if (uMsg >= ACMDM_USER)
        return (MMSYSERR_NOTSUPPORTED);
    else
        return (DefDriverProc(dwId, hdrvr, uMsg, lParam1, lParam2));
} // DriverProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\gsm610\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//      This file contains definitions for DEBUG builds; all debugging
//      instructions are #define-d to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MODULE_NAME   "MSGSM610"  // key name and prefix for output
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI _Assert( char * szFile, int iLine );

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
    #define ASSERT(x)   if( !(x) )  _Assert( __FILE__, __LINE__)
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
    #define ASSERT(x)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\gsm610\codec.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1998 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.h
//
//  Description:
//      This file contains codec definitions, Win16/Win32 compatibility
//      definitions, and instance structure definitions.
//
//
//==========================================================================;

#ifndef _INC_CODEC
#define _INC_CODEC                  // #defined if codec.h has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Version:
//
//  the version is a 32 bit number that is broken into three parts as
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows (in decimal form):
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) &
//      wBuild = LOWORD(dwVersion)
//
//  VERSION_ACM_DRIVER is the version of this driver.
//  VERSION_MSACM is the version of the ACM that this driver
//  was designed for (requires).
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
//
//  32-bit versions
//
#if (WINVER >= 0x0400)
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(4,  0, 0)
#else
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(3, 51, 0)
#endif
#define VERSION_MSACM       MAKE_ACM_VERSION(3, 50, 0)

#else
//
//  16-bit versions
//
#define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(1, 0, 0)
#define VERSION_MSACM       MAKE_ACM_VERSION(2, 1, 0)

#endif

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16/32 portability stuff...
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNWCALLBACK FAR PASCAL _loadds
        #define FNEXPORT    FAR PASCAL _export
    #else
        #define FNWCALLBACK FAR PASCAL
        #define FNEXPORT    FAR PASCAL _export
    #endif
    #endif

    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif

    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))

    #define HUGE            _huge

    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
	typedef LPCSTR		LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)
    #define SIZEOFACMSTR(x) sizeof(x)
#else
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    #ifndef try
    #define try         __try
    #define leave       __leave
    #define except      __except
    #define finally     __finally
    #endif


    //
    //  there is no reason to have based stuff in win 32
    //
    #define BCODE

    #define HUGE
    #define HTASK                   HANDLE
    #define SELECTOROF(a)           (a)

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif
    #define SIZEOFACMSTR(x)	(sizeof(x)/sizeof(WCHAR))

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//
//
#define SIZEOF_ARRAY(ar)            (sizeof(ar)/sizeof((ar)[0]))

//
//
//
typedef BOOL FAR*   LPBOOL;


#ifndef INLINE
    #define INLINE __inline
#endif


//
//  macros to compute block alignment and convert between samples and bytes
//  of PCM data. note that these macros assume:
//
//      wBitsPerSample  =  8 or 16
//      nChannels       =  1 or 2
//
//  the pwf argument is a pointer to a PCMWAVEFORMAT structure.
//
#define PCM_BLOCKALIGNMENT(pwf)     (UINT)(((pwf)->wBitsPerSample >> 3) << ((pwf)->wf.nChannels >> 1))
#define PCM_AVGBYTESPERSEC(pwf)     (DWORD)((pwf)->wf.nSamplesPerSec * (pwf)->wf.nBlockAlign)
#define PCM_BYTESTOSAMPLES(pwf, dw) (DWORD)(dw / PCM_BLOCKALIGNMENT(pwf))
#define PCM_SAMPLESTOBYTES(pwf, dw) (DWORD)(dw * PCM_BLOCKALIGNMENT(pwf))



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tDRIVERINSTANCE
{
    //
    //  although not required, it is suggested that the first two members
    //  of this structure remain as fccType and DriverProc _in this order_.
    //  the reason for this is that the driver will be easier to combine
    //  with other types of drivers (defined by AVI) in the future.
    //
    FOURCC          fccType;        // type of driver: 'audc'
    DRIVERPROC      fnDriverProc;   // driver proc for the instance

    //
    //  the remaining members of this structure are entirely open to what
    //  your driver requires.
    //
    HDRVR           hdrvr;          // driver handle we were opened with
    HINSTANCE       hinst;          // DLL module handle.
    DWORD           vdwACM;         // current version of ACM opening you
    DWORD           fdwOpen;        // flags from open description

    LPDRVCONFIGINFO pdci;
    DWORD           fdwConfig;      // stream instance configuration flags

    HKEY            hkey;
    UINT            nConfigMaxRTEncodeSetting;
    UINT            nConfigMaxRTDecodeSetting;
    UINT            nConfigPercentCPU;
    BOOL            fHelpRunning;           // Used by config DlgProc only.
#ifdef WIN4
    HBRUSH          hbrDialog;              // Used by config DlgProc only.
#endif

} DRIVERINSTANCE, *PDRIVERINSTANCE, FAR *LPDRIVERINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;


//
//  Structure used for storing configuration setting.
//  See codec.c for a description of this structure and its use.
//
typedef struct tRATELISTFORMAT
{
    UINT        uFormatType;
    UINT        idsFormat;
    DWORD       dwMonoRate;
} RATELISTFORMAT;
typedef RATELISTFORMAT *PRATELISTFORMAT;

#define CONFIG_RLF_NONUMBER     1
#define CONFIG_RLF_MONOONLY     2
#define CONFIG_RLF_STEREOONLY   3
#define CONFIG_RLF_MONOSTEREO   4


//
//
//
//
typedef LRESULT (FNGLOBAL *STREAMCONVERTPROC)
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
);


//
//
//
//
typedef struct tSTREAMINSTANCE
{
    STREAMCONVERTPROC   fnConvert;  // stream instance conversion proc
    DWORD               fdwConfig;  // stream instance configuration flags

    //
    //  This GSM610 codec requires the following parameters
    //  per stream instance.  These parameters are used by
    //  the encode and decode routines.
    //
    SHORT               dp[120];
    SHORT               drp[160];
    SHORT               z1;
    LONG                l_z2;
    SHORT               mp;
    SHORT               OldLARpp[9];
    SHORT               u[8];
    SHORT               nrp;
    SHORT               OldLARrpp[9];
    SHORT               msr;
    SHORT               v[9];

} STREAMINSTANCE, *PSTREAMINSTANCE, FAR *LPSTREAMINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  resource id's
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define IDS_ACM_DRIVER_SHORTNAME    (1)     // ACMDRIVERDETAILS.szShortName
#define IDS_ACM_DRIVER_LONGNAME     (2)     // ACMDRIVERDETAILS.szLongName
#define IDS_ACM_DRIVER_COPYRIGHT    (3)     // ACMDRIVERDETAILS.szCopyright
#define IDS_ACM_DRIVER_LICENSING    (4)     // ACMDRIVERDETAILS.szLicensing
#define IDS_ACM_DRIVER_FEATURES     (5)     // ACMDRIVERDETAILS.szFeatures

#define IDS_ACM_DRIVER_TAG_NAME     (20)    // ACMFORMATTAGDETAILS.szFormatTag

#define IDS_ERROR		    (30)
#define IDS_ERROR_NOMEM		    (31)
#define IDS_CONFIG_NORATES          (32)
#define IDS_CONFIG_ALLRATES         (33)
#define IDS_CONFIG_MONOONLY         (34)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  resource id's for gsm 610 configuration dialog box
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define IDD_CONFIG                      RCID(100)
#define IDC_BTN_AUTOCONFIG              1001
#define IDC_BTN_HELP                    1002
#define IDC_COMBO_MAXRTENCODE           1003
#define IDC_COMBO_MAXRTDECODE           1004
#define IDC_STATIC_COMPRESS				1005
#define IDC_STATIC_DECOMPRESS			1006
#define IDC_STATIC                      -1

#define MSGSM610_CONFIG_DEFAULT_MAXRTENCODESETTING          0
#define MSGSM610_CONFIG_DEFAULT_MAXRTDECODESETTING          1
#define MSGSM610_CONFIG_UNCONFIGURED                        0x0999
#define MSGSM610_CONFIG_DEFAULT_PERCENTCPU		    50
#define MSGSM610_CONFIG_DEFAULTKEY                          HKEY_CURRENT_USER


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  global variables, etc...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

extern const UINT   gauFormatIndexToSampleRate[];
extern const UINT   ACM_DRIVER_MAX_SAMPLE_RATES;
extern const RATELISTFORMAT gaRateListFormat[];
extern const UINT   MSGSM610_CONFIG_NUMSETTINGS;


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  function prototypes
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

BOOL FNGLOBAL acmdDriverConfigInit
(
    PDRIVERINSTANCE	    pdi,
    LPCTSTR		    pszAliasName
);

INT_PTR FNWCALLBACK acmdDlgProcConfigure
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" {
#endif

#endif // _INC_CODEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\gsm610\config.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  config.c
//
//  Description:
//	GSM 6.10 configuration init and dialog
//
//
//	The configuration parameters for this codec are:
//
//	    MaxRTEncodeSetting:
//	    MaxRTDecodeSetting:
//		These determine the highest mono sample rate that
//		the codec will attempt to convert in real-time.
//
//	    PercentCPU:
//		This configuration parameter is not normally changed
//		by the user and is not presented in the config dialog.
//		This value affects the config dialog's 'Auto-Config'
//		calculation of MaxRTXxcodeSamplesPerSec.
//
//  These parameters may be set in the registry, using the gsm610 subkey
//  (which corresponds to the alias name used for installation) under
//  the following key:
//
//      HKEY_CURRENT_USER\Software\Microsoft\Multimedia
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "codec.h"
#include "gsm610.h"
#include "debug.h"

#ifdef WIN32
#include <tchar.h>
#else
#define _tcstoul strtoul
#define _tcsncpy _fstrncpy
#endif

#include <string.h>
#include <stdlib.h>


//
//  Strings required to access configuration information in the registry.
//
const TCHAR BCODE gszMaxRTEncodeSetting[]   = TEXT("MaxRTEncodeSetting");
const TCHAR BCODE gszMaxRTDecodeSetting[]   = TEXT("MaxRTDecodeSetting");
const TCHAR BCODE gszPercentCPU[]		    = TEXT("PercentCPU");
const TCHAR gszMultimediaKey[] = TEXT("Software\\Microsoft\\Multimedia\\");

#define MSGSM610_CONFIG_TEXTLEN         80


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
//  Be careful changing the following!
//
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
//  Data required to access the dialog box help.
//
//  Note that you must write your own help file for your codec, even if
//  the configuration dialog box looks identical.  If you use the file
//  listed here, then the title will say "GSM 6.10" or something.
//
//  Note:  the number HELPCONTEXT_MSGSM610 must be unique in the file
//          gszHelpFilename, and the number must defined in the [MAP]
//          section of the .hpj help project file.  Then the .rtf file
//          will reference that number (using the keyword defined in
//          the .hpj file).  Then when we call WinHelp with the number,
//          WinHelp will go to the right help entry.
//
const TCHAR BCODE gszHelpFilename[]         = TEXT("audiocdc.hlp");
#define HELPCONTEXT_MSGSM610          1002
#define IDH_AUDIOCDC_COMPRESSION	  100
#define IDH_AUDIOCDC_DECOMPRESSION    200
#define IDH_AUDIOCDC_AUTOCONFIGURE	  300
static int aKeyWordIds[] = {
				   IDC_COMBO_MAXRTENCODE, IDH_AUDIOCDC_COMPRESSION,
				   IDC_STATIC_COMPRESS, IDH_AUDIOCDC_COMPRESSION,
				   IDC_COMBO_MAXRTDECODE, IDH_AUDIOCDC_DECOMPRESSION,
				   IDC_STATIC_DECOMPRESS, IDH_AUDIOCDC_DECOMPRESSION,
				   IDC_BTN_AUTOCONFIG, IDH_AUDIOCDC_AUTOCONFIGURE,
				   0, 0
			       };



//==========================================================================;
//
//
//
//
//==========================================================================;

LPVOID FNLOCAL GlobalAllocLock(HGLOBAL far * ph, DWORD dwc)
{
    *ph = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, dwc);
    if (NULL != *ph)
	return GlobalLock(*ph);
    else
	return NULL;
}

VOID FNLOCAL GlobalUnlockFree(LPVOID p, HGLOBAL h)
{
    if (NULL != h)
    {
	if (NULL != p) GlobalUnlock(h);
	GlobalFree(h);
    }
    return;
}

//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  VOID configWriteConfiguration
//  
//  Description:
//
//      This routine writes the configuration data in PDI to the registry.
//      This consists of the max real-time Encode and Decode settings.
//  
//  Arguments:
//      PDRIVERINSTANCE     pdi
//  
//  Return (VOID):  None.
//  
//--------------------------------------------------------------------------;

VOID configWriteConfiguration
(
    PDRIVERINSTANCE     pdi
)
{
    DWORD               dw;


    if( NULL != pdi->hkey )
    {
        dw   = (DWORD)pdi->nConfigMaxRTEncodeSetting;
        (void)RegSetValueEx( pdi->hkey, (LPTSTR)gszMaxRTEncodeSetting, 0,
                                REG_DWORD, (LPBYTE)&dw, sizeof(DWORD) );

        dw   = (DWORD)pdi->nConfigMaxRTDecodeSetting;
        (void)RegSetValueEx( pdi->hkey, (LPTSTR)gszMaxRTDecodeSetting, 0,
                                REG_DWORD, (LPBYTE)&dw, sizeof(DWORD) );
    }
}


//--------------------------------------------------------------------------;
//  
//  DWORD dwReadRegistryDefault
//  
//  Description:
//
//      This routine reads a given value from the registry, and returns a
//      default value if the read is not successful.
//  
//  Arguments:
//      HKEY    hkey:               Registry key to read from.
//      LPTSTR  lpszEntry:
//      DWORD   dwDefault:
//  
//  Return (DWORD):
//  
//--------------------------------------------------------------------------;

INLINE DWORD dwReadRegistryDefault
(
    HKEY                hkey,
    LPTSTR              lpszEntry,
    DWORD               dwDefault
)
{
    DWORD   dwType = (DWORD)~REG_DWORD;  // Init to anything but REG_DWORD.
    DWORD   cbSize = sizeof(DWORD);
    DWORD   dwRet;
    LONG    lError;

    ASSERT( NULL != hkey );
    ASSERT( NULL != lpszEntry );


    lError = RegQueryValueEx( hkey,
                              lpszEntry,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwRet,
                              &cbSize );

    if( ERROR_SUCCESS != lError  ||  REG_DWORD != dwType )
        dwRet = dwDefault;

    return dwRet;
}


//--------------------------------------------------------------------------;
//  
//  VOID configSetDefaults
//  
//  Description:
//
//      This routine sets the configuration parameters to their default
//      values.
//  
//  Arguments:
//      PDRIVERINSTANCE pdi:
//  
//--------------------------------------------------------------------------;

VOID configSetDefaults
(
    PDRIVERINSTANCE     pdi
)
{
    pdi->nConfigMaxRTEncodeSetting =
            MSGSM610_CONFIG_DEFAULT_MAXRTENCODESETTING;

    pdi->nConfigMaxRTDecodeSetting =
            MSGSM610_CONFIG_DEFAULT_MAXRTDECODESETTING;

    pdi->nConfigPercentCPU =
            MSGSM610_CONFIG_DEFAULT_PERCENTCPU;
}


//--------------------------------------------------------------------------;
//  
//  UINT configAutoConfig
//  
//  Description:
//
//	We will determine how much time it takes to encode and then decode
//	2 seconds of data and use this to guess at the max sample
//	rate we can convert in real-time.
//
//	The max is computed with essentially 100% of the CPU.  Practically,
//	we won't have 100% of the CPU available.  So we take a percentage
//	of the computed max and use that as the max in the config dialog.
//
//	The percentage that we use can be set in the ini file gsm610
//	section by PercentCPU=xx.
//
//  
//  Arguments:
//      HWND hwnd:
//  
//  Return (UINT):  String identifier (IDS) of error message, or zero if
//      the call succeeded.
//  
//--------------------------------------------------------------------------;

UINT FNLOCAL configAutoConfig
(
    PDRIVERINSTANCE             pdi,
    UINT                        *pnEncodeSetting,
    UINT                        *pnDecodeSetting
)
{
    UINT		    nConfig;
    
    UINT		    uIDS;
    HCURSOR		    hCursorSave;

    PSTREAMINSTANCE	    psi;
    
    HGLOBAL		    hbPCM;
    HGLOBAL		    hbGSM;
    HGLOBAL		    hpcmwf;
    HGLOBAL		    hgsmwf;
    HGLOBAL		    hadsi;
    HGLOBAL		    hadsh;
    
    LPBYTE		    pbPCM, pbGSM;
    DWORD		    cbPCMLength, cbGSMLength;

    LPPCMWAVEFORMAT	    ppcmwf;
    LPGSM610WAVEFORMAT	    pgsmwf;

    LPACMDRVSTREAMINSTANCE  padsi;
    LPACMDRVSTREAMHEADER    padsh;

    DWORD		    dwTime;
    DWORD		    dwMaxRate;


    //
    //  We divide by this!
    //
    ASSERT( 0 != pdi->nConfigPercentCPU );

    
    //
    // Init stuff that gets cleaned up at errReturn
    //
    //
    uIDS   = 0;
    
    psi    = NULL;

    hbPCM  = NULL;
    hbGSM  = NULL;
    hpcmwf = NULL;
    hgsmwf = NULL;
    hadsi  = NULL;
    hadsh  = NULL;
    
    pbPCM  = NULL;
    pbGSM  = NULL;
    ppcmwf = NULL;
    pgsmwf = NULL;
    padsi  = NULL;
    padsh  = NULL;


    //
    // This function may take a while.  Set hour glass cursor
    //
    //
    hCursorSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // Allocate memory for all our structures
    //
    //
    psi    = (PSTREAMINSTANCE)LocalAlloc(LPTR, sizeof(*psi));

    cbPCMLength	    = 2 * (8000 / 1 * 2);
    cbGSMLength	    = 2 * (8000 / 320 * 65);

    pbPCM = GlobalAllocLock(&hbPCM, cbPCMLength);
    pbGSM = GlobalAllocLock(&hbGSM, cbGSMLength);
    
    ppcmwf = GlobalAllocLock(&hpcmwf, sizeof(*ppcmwf));
    pgsmwf = GlobalAllocLock(&hgsmwf, sizeof(*pgsmwf));
    
    padsi = GlobalAllocLock(&hadsi, sizeof(*padsi));
    padsh = GlobalAllocLock(&hadsh, sizeof(*padsh));


    //
    // if we couldn't allocate some of the memory
    //
    //
    if ( (psi == NULL)	    ||
	 (pbPCM == NULL)    ||
	 (pbGSM == NULL)    ||
	 (ppcmwf == NULL)   ||
	 (pgsmwf == NULL)   ||
	 (padsi == NULL)    ||
	 (padsh == NULL) )
    {
	uIDS = IDS_ERROR_NOMEM;
	goto errReturn;
    }

    //
    //
    //

    //
    // Fill in format structures for GSM 6.10 and PCM
    //
    //
    pgsmwf->wfx.wFormatTag	= WAVE_FORMAT_GSM610;
    pgsmwf->wfx.nChannels	= 1;
    pgsmwf->wfx.nSamplesPerSec	= 8000;
    pgsmwf->wfx.nAvgBytesPerSec	= 8000 / 320 * 65;
    pgsmwf->wfx.nBlockAlign	= 65;
    pgsmwf->wfx.wBitsPerSample	= 0;
    pgsmwf->wfx.cbSize		= 0;
    pgsmwf->wSamplesPerBlock	= 320;
    
    ppcmwf->wf.wFormatTag	= WAVE_FORMAT_PCM;
    ppcmwf->wf.nChannels	= 1;
    ppcmwf->wf.nSamplesPerSec	= 8000;
    ppcmwf->wf.nAvgBytesPerSec	= 8000 / 1 * 2;
    ppcmwf->wf.nBlockAlign	= 2;
    ppcmwf->wBitsPerSample	= 16;

    //
    // get the time, do encode, get the time.  btw, we've never written
    // any data into our audio data buffers.  we don't know what's in
    // them nor do we care.  we just want to see how long it takes to
    // perform the conversion.
    //
    //
    dwTime = timeGetTime();
    
    padsi->cbStruct	= sizeof(padsi);
    padsi->pwfxSrc	= (LPWAVEFORMATEX) ppcmwf;
    padsi->pwfxDst	= (LPWAVEFORMATEX) pgsmwf;
    padsi->dwDriver	= (DWORD_PTR) psi;

    padsh->cbStruct	= sizeof(padsh);
    padsh->pbSrc	= pbPCM;
    padsh->cbSrcLength	= cbPCMLength;
    padsh->pbDst	= pbGSM;
    padsh->cbDstLength	= cbGSMLength;
    padsh->fdwConvert	= ACM_STREAMCONVERTF_BLOCKALIGN | ACM_STREAMCONVERTF_START;

    gsm610Encode(padsi, padsh);
    
    dwTime = timeGetTime() - dwTime;

    //
    // calculate what we might be able to do in real-time
    //
    //
    if (dwTime == 0)
	dwMaxRate = 0xFFFFFFFFL;
    else
	dwMaxRate = (1000L * 2L * ppcmwf->wf.nSamplesPerSec / dwTime);
    
    if ( (0xFFFFFFFFL / pdi->nConfigPercentCPU) >= dwMaxRate )
	dwMaxRate = dwMaxRate * pdi->nConfigPercentCPU / 100;
    
    if (dwMaxRate > 0xFFFFL)
	dwMaxRate = 0xFFFFL;
    
    DPF(1,"Encode dwMaxRate=%u", dwMaxRate);
    
    //
    //  Now set the configuration based on dwMaxRate.  We scan the
    //  gaRateListFormat[] array looking at the dwMonoRate to determine
    //  the appropriate setting.
    //
    nConfig = 0;                                                
    while( gaRateListFormat[nConfig].dwMonoRate < dwMaxRate  &&
           MSGSM610_CONFIG_NUMSETTINGS > nConfig )
    {
        nConfig++;
    }
    *pnEncodeSetting = nConfig - 1;  // We went too far.

    
    //
    // get the time, do decode, get the time
    //
    //
    dwTime = timeGetTime();
    
    padsi->cbStruct	= sizeof(*padsi);
    padsi->pwfxSrc	= (LPWAVEFORMATEX) pgsmwf;
    padsi->pwfxDst	= (LPWAVEFORMATEX) ppcmwf;
    padsi->dwDriver	= (DWORD_PTR) psi;

    padsh->cbStruct	= sizeof(*padsh);
    padsh->pbSrc	= pbGSM;
    padsh->cbSrcLength	= cbGSMLength;
    padsh->pbDst	= pbPCM;
    padsh->cbDstLength	= cbPCMLength;
    padsh->fdwConvert	= ACM_STREAMCONVERTF_BLOCKALIGN | ACM_STREAMCONVERTF_START;

    gsm610Decode(padsi, padsh);
    
    dwTime = timeGetTime() - dwTime;

    //
    // calculate what we might be able to do in real-time
    //
    //
    if (dwTime == 0)
	dwMaxRate = 0xFFFFFFFFL;
    else
	dwMaxRate = (1000L * 2L * ppcmwf->wf.nSamplesPerSec / dwTime);
    
    if ( (0xFFFFFFFFL / pdi->nConfigPercentCPU) >= dwMaxRate )
	dwMaxRate = dwMaxRate * pdi->nConfigPercentCPU / 100;
    
    if (dwMaxRate > 0xFFFFL)
	dwMaxRate = 0xFFFFL;
    
    DPF(1,"Decode dwMaxRate=%u", dwMaxRate);

    //
    //  Now set the configuration based on these values.  We scan the
    //  gaRateListFormat[] array looking at the dwMonoRate to determine
    //  the appropriate setting.
    //
    nConfig = 0;                                                
    while( gaRateListFormat[nConfig].dwMonoRate < dwMaxRate  &&
           MSGSM610_CONFIG_NUMSETTINGS > nConfig )
    {
        nConfig++;
    }
    *pnDecodeSetting = nConfig - 1;  // We went too far.

        
    //
    // Clean up
    //
    //
errReturn:
    GlobalUnlockFree(padsh, hadsh);
    GlobalUnlockFree(padsi, hadsi);
    
    GlobalUnlockFree(ppcmwf, hpcmwf);
    GlobalUnlockFree(pgsmwf, hgsmwf);
    
    GlobalUnlockFree(pbPCM, hbPCM);
    GlobalUnlockFree(pbGSM, hbGSM);
    
    SetCursor(hCursorSave);
    
    return uIDS;
}


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL acmdDlgProcConfigure
//  
//  Description:
//      This routine handles the configuration dialog box.
//  
//  Arguments:
//      HWND hwnd:
//  
//      UINT uMsg:
//  
//      WPARAM wParam:
//  
//      LPARAM lParam:
//  
//  Return (BOOL):
//
//
//  Note:  In order to avoid using a static fHelpRunning flag which will
//          still be here after we exit, we allocate an fHelpRunning
//          variable in the DRIVERINSTANCE structure.  This is purely to
//          avoid static variables (which force us to have a data segment
//          of 4K); the fHelpRunning is not used in any other procedures.
//  
//--------------------------------------------------------------------------;

INT_PTR FNWCALLBACK acmdDlgProcConfigure
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    PDRIVERINSTANCE     pdi;
    
    HWND                hctrlEnc;
    HWND                hctrlDec;
    UINT                uCmdId;
    UINT                u;
    int                 n;
    TCHAR               szFormat[MSGSM610_CONFIG_TEXTLEN];
    TCHAR               szOutput[MSGSM610_CONFIG_TEXTLEN];

    UINT                nConfigMaxRTEncodeSetting;
    UINT                nConfigMaxRTDecodeSetting;


    switch (uMsg)
    {
        case WM_INITDIALOG:

            pdi = (PDRIVERINSTANCE)lParam;
            pdi->fHelpRunning = FALSE;  // Used only in this procedure.
	    
#ifdef WIN4
            //
            //  This driver is marked Windows Subsystem version 3.5 in order
            //  that it be compatible with Daytona - however, that means that
            //  Chicago will think it is a Win 3.1 application and give it
            //  Win 3.1 default colors.  This makes the config dialog look
            //  white, whereas the Chicago default uses 3DFACE.  This code
            //  (and the CTLCOLOR messages) sets the colors explicitly.
            //
            pdi->hbrDialog = CreateSolidBrush( GetSysColor(COLOR_3DFACE) );
#endif
	    
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);

            nConfigMaxRTEncodeSetting = pdi->nConfigMaxRTEncodeSetting;
            nConfigMaxRTDecodeSetting = pdi->nConfigMaxRTDecodeSetting;

            hctrlEnc = GetDlgItem(hwnd, IDC_COMBO_MAXRTENCODE);
            hctrlDec = GetDlgItem(hwnd, IDC_COMBO_MAXRTDECODE);

            for( u=0; u<MSGSM610_CONFIG_NUMSETTINGS; u++ )
            {
                LoadString( pdi->hinst, gaRateListFormat[u].idsFormat,
                            szFormat, SIZEOF(szFormat) );

                switch( gaRateListFormat[u].uFormatType )
                {
                    case CONFIG_RLF_NONUMBER:
                        lstrcpy( szOutput, szFormat );
                        break;

                    case CONFIG_RLF_MONOONLY:
                        wsprintf( szOutput, szFormat,
                                    gaRateListFormat[u].dwMonoRate );
                        break;
                }

                ComboBox_AddString(hctrlEnc, szOutput);
                ComboBox_AddString(hctrlDec, szOutput);
            }

            ComboBox_SetCurSel( hctrlEnc, nConfigMaxRTEncodeSetting );
            ComboBox_SetCurSel( hctrlDec, nConfigMaxRTDecodeSetting );

	    return (TRUE);

	case WM_DESTROY:
            pdi = (PDRIVERINSTANCE)GetWindowLongPtr(hwnd, DWLP_USER);
	    if (pdi->fHelpRunning)
	    {
		WinHelp(hwnd, gszHelpFilename, HELP_QUIT, 0L);
	    }
#ifdef WIN4
            DeleteObject( pdi->hbrDialog );
#endif

	    //
	    // Let dialog box process this message
	    //
	    //
	    return (FALSE);

#ifdef WIN4
        //
        //  Handle CTLCOLOR messages to get the dialog boxes to the default
        //  Chicago colors.  See the INITDIALOG message, above.
        //
        case WM_CTLCOLORSTATIC:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLORBTN:
            SetTextColor( (HDC)wParam, GetSysColor(COLOR_WINDOWTEXT) );
            SetBkColor( (HDC)wParam, GetSysColor(COLOR_3DFACE) );
            pdi = (PDRIVERINSTANCE)GetWindowLongPtr(hwnd, DWLP_USER);
            return (UINT_PTR)(pdi->hbrDialog);
#endif

		case WM_HELP:
			WinHelp(((LPHELPINFO)lParam)->hItemHandle, gszHelpFilename,
				HELP_WM_HELP, (ULONG_PTR)aKeyWordIds);
			return TRUE;

        case WM_COMMAND:
            pdi = (PDRIVERINSTANCE)GetWindowLongPtr(hwnd, DWLP_USER);

            uCmdId = (UINT) wParam;

            switch (uCmdId)
            {
                case IDC_BTN_AUTOCONFIG:
                    {
                        UINT        uErrorIDS;

                        uErrorIDS   = configAutoConfig( pdi,
                                            &nConfigMaxRTEncodeSetting,
                                            &nConfigMaxRTDecodeSetting );
                        if( 0==uErrorIDS )
                        {
                            //
                            //  No error - set dialog box settings.
                            //
                            hctrlEnc = GetDlgItem( hwnd, IDC_COMBO_MAXRTENCODE );
                            ComboBox_SetCurSel( hctrlEnc, nConfigMaxRTEncodeSetting );
                            hctrlDec = GetDlgItem( hwnd, IDC_COMBO_MAXRTDECODE );
                            ComboBox_SetCurSel( hctrlDec, nConfigMaxRTDecodeSetting );
                        }
                        else
                        {
                            //
                            //  Display error message.
                            //
                            TCHAR       tstrErr[200];
                            TCHAR       tstrErrTitle[200];

                            if (0 == LoadString(pdi->hinst, IDS_ERROR, tstrErrTitle, SIZEOF(tstrErrTitle)))
                                break;
                            if (0 == LoadString(pdi->hinst, uErrorIDS, tstrErr, SIZEOF(tstrErr)))
                                break;
                            MessageBox(hwnd, tstrErr, tstrErrTitle, MB_ICONEXCLAMATION | MB_OK);
                        }
                    }
                    break;


                case IDOK:
                    n = DRVCNF_CANCEL;

                    //
                    //  RT Encode setting
                    //
                    hctrlEnc = GetDlgItem(hwnd, IDC_COMBO_MAXRTENCODE);
                    nConfigMaxRTEncodeSetting = ComboBox_GetCurSel( hctrlEnc );
                    if (nConfigMaxRTEncodeSetting != pdi->nConfigMaxRTEncodeSetting)
                    {
                        pdi->nConfigMaxRTEncodeSetting = nConfigMaxRTEncodeSetting;
                        n = DRVCNF_OK;
                    }

                    //
                    //  RT Decode setting
                    //
                    hctrlDec = GetDlgItem(hwnd, IDC_COMBO_MAXRTDECODE);
                    nConfigMaxRTDecodeSetting = ComboBox_GetCurSel( hctrlDec );
                    if (nConfigMaxRTDecodeSetting != pdi->nConfigMaxRTDecodeSetting)
                    {
                        pdi->nConfigMaxRTDecodeSetting = nConfigMaxRTDecodeSetting;
                        n = DRVCNF_OK;
                    }

                    //
                    //  If we changed something, write the data to the
                    //  registry.
                    //
                    if( DRVCNF_OK == n )
                    {
                        configWriteConfiguration( pdi );
                    }

                    EndDialog(hwnd, DRVCNF_OK);
                    break;


                case IDCANCEL:
                    EndDialog(hwnd, DRVCNF_CANCEL);
                    break;

                case IDC_BTN_HELP:
		    pdi->fHelpRunning = TRUE;
		    WinHelp(hwnd, gszHelpFilename, HELP_CONTEXT, HELPCONTEXT_MSGSM610);
                    break;
            }
            return (TRUE);
    }

    return (FALSE);
} // gsm610DlgProcConfigure()


//--------------------------------------------------------------------------;
//  
//  BOOL acmdDriverConfigInit
//  
//  Description:
//      This routine initializes the configuration parameters by reading them
//      from the registry.  If there are no entries in the registry, this
//      codec auto-configures itself and writes the results to the registry.
//      If the auto-configure fails, or if we don't know our alias name,
//      then we set the configuration to default values.
//  
//  Arguments:
//      PDRIVERINSTANCE pdi:
//  
//      LPCTSTR pszAliasName:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL acmdDriverConfigInit
(
    PDRIVERINSTANCE         pdi,
    LPCTSTR		    pszAliasName
)
{
    HKEY    hkey;
    UINT    nEncodeSetting;
    UINT    nDecodeSetting;
    UINT    uErrorIDS;


    //
    //	If pszAliasName is NULL then just set all defaults
    //
    //
    if (NULL == pszAliasName)
    {
        DPF(2,"acmdDriverConfigInit: no alias name; using default settings.");

        configSetDefaults( pdi );
        return (TRUE);
    }

    
    //
    //  If we haven't got an open hkey, then open it.  Note that this routine
    //  may be called more than once; on the second time, we should not
    //  re-open the key.
    //
    if( NULL == pdi->hkey )
    {
        RegCreateKeyEx( MSGSM610_CONFIG_DEFAULTKEY, gszMultimediaKey, 0,
                        NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hkey, NULL );

        if( NULL != hkey )
        {
            ASSERT( NULL != pszAliasName );

            RegCreateKeyEx( hkey, pszAliasName, 0, NULL, 0,
                    KEY_SET_VALUE | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                    NULL, &pdi->hkey, NULL );

            RegCloseKey( hkey );
        }
    }


    //
    //  Read configuration data from registry.
    //
    if( NULL == pdi->hkey )
    {
        configSetDefaults( pdi );
    }
    else
    {
        pdi->nConfigMaxRTEncodeSetting =
                    (UINT)dwReadRegistryDefault( pdi->hkey,
                    (LPTSTR)gszMaxRTEncodeSetting,
                    MSGSM610_CONFIG_UNCONFIGURED );

        pdi->nConfigMaxRTDecodeSetting =
                    (UINT)dwReadRegistryDefault( pdi->hkey,
                    (LPTSTR)gszMaxRTDecodeSetting,
                    MSGSM610_CONFIG_UNCONFIGURED );

        pdi->nConfigPercentCPU =
                    (UINT)dwReadRegistryDefault( pdi->hkey,
                    (LPTSTR)gszPercentCPU,
                    MSGSM610_CONFIG_DEFAULT_PERCENTCPU );
        
        //
        //  Check that nConfigPercentCPU is a valid value.
        //
        if( pdi->nConfigPercentCPU <= 0 )
        {
            pdi->nConfigPercentCPU = MSGSM610_CONFIG_DEFAULT_PERCENTCPU;
        }
    }


	//
    //  If either the encode or decode setting is out of range, then
    //  we call the auto-configure routine and write out the results.
    //  This should only happen the first time the codec is run.
    //
    if( MSGSM610_CONFIG_NUMSETTINGS <= pdi->nConfigMaxRTEncodeSetting ||
        MSGSM610_CONFIG_NUMSETTINGS <= pdi->nConfigMaxRTDecodeSetting )
    {
        DPF( 1, "acmdDriverConfigInit: performing initial auto-config." );
        uErrorIDS = configAutoConfig( pdi,
                                      &nEncodeSetting,
                                      &nDecodeSetting );

        if( 0 != uErrorIDS )
        {
            //
            //  Error in auto-config.  Use defaults instead.
            //
            nEncodeSetting = MSGSM610_CONFIG_DEFAULT_MAXRTENCODESETTING;
            nDecodeSetting = MSGSM610_CONFIG_DEFAULT_MAXRTDECODESETTING;
        }

        pdi->nConfigMaxRTEncodeSetting = nEncodeSetting;
        pdi->nConfigMaxRTDecodeSetting = nDecodeSetting;

        //
        //  Always write the results to the registry, even if we hit an
        //  error, so we won't hit the automatic auto-config next
        //  time we run.  One failure is enough!
        //
        configWriteConfiguration( pdi );
    }

    return (TRUE);
} // acmdDriverConfigInit()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\gsm610\gsm610.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  gsm610.c
//
//  Description:
//	This file contains encode and decode routines for the
//	GSM 06.10 standard.
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "codec.h"
#include "gsm610.h"

#include "debug.h"

typedef BYTE HUGE *HPBYTE;

#ifdef WIN32
    typedef WORD UNALIGNED *HPWORD;
#else
    typedef WORD HUGE *HPWORD;
#endif


//**************************************************************************
/*

This source module has the following structure.

Section 1:

    Highest level functions.  These functions are called from outside
    this module.
    
Section 2:

    Encoding support functions.	 These functions support
    the encoding process.
    
Section 3:

    Decoding support functions.	 These functions support
    the decoding process.
    
Section 4:

    Math functions used by any of the above functions.

    
Most of the encode and decode support routines are direct implementations of
the pseudocode algorithms described in the GSM 6.10 specification.  Some
changes were made where necessary or where optimization was obvious or
necessary.

Most variables are named as in the GSM 6.10 spec, departing from the common
hungarian notation.  This facilitates referencing the specification when
studying this implementation.

Some of the functions are conditionally compiled per the definition of
the WIN32 and _X86_ symbol.  These functions have analogous alternate
implementations in 80386 assembler (in GSM61016.ASM and GSM61032.ASM) for
the purposes of execution speed.  The 'C' implementations of these functions
are left intact for portability and can also be referenced when studying the
assembler implementations.  Symbols accessed in/from GSM610xx.ASM are
declared with the EXTERN_C linkage macro.

*/
//**************************************************************************


//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
//
// Typedefs
//
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

#ifndef LPSHORT
typedef SHORT FAR *LPSHORT;
#endif

//
//  XM is an RPE sequence containing 13 samples.  There is one
//  RPE sequence per sub-frame.	 This is typedefed in order to
//  facilitate passing the array thru function calls.
//
typedef SHORT XM[13];


//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
//
// Macros
//
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

#define BITSHIFTLEFT(x,c)  ( ((c)>=0) ? ((x)<<(c)) : ((x)>>(-(c))) )
#define BITSHIFTRIGHT(x,c) ( ((c)>=0) ? ((x)>>(c)) : ((x)<<(-(c))) )


//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
//
// function protos
//
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

//
//
// Math function protos
//

__inline SHORT add(SHORT var1, SHORT var2);
__inline SHORT sub(SHORT var1, SHORT var2);
__inline SHORT mult(SHORT var1, SHORT var2);
__inline SHORT mult_r(SHORT var1, SHORT var2);
__inline SHORT gabs(SHORT var1);
__inline SHORT gdiv(SHORT var1, SHORT var2);
__inline LONG  l_mult(SHORT var1, SHORT var2);
__inline LONG  l_add(LONG l_var1, LONG l_var2);
__inline LONG  l_sub(LONG l_var1, LONG l_var2);
__inline SHORT norm(LONG l_var1);
__inline LONG  IsNeg(LONG x);

//
// helper functions
//
__inline SHORT Convert8To16BitPCM(BYTE);
__inline BYTE  Convert16To8BitPCM(SHORT);

//
//
// encode functions
//

void encodePreproc
(   PSTREAMINSTANCE psi,
    LPSHORT sop,
    LPSHORT s	    );

void encodeLPCAnalysis
(   PSTREAMINSTANCE psi,
    LPSHORT s,
    LPSHORT LARc    );

void encodeLPCFilter
(   PSTREAMINSTANCE psi,
    LPSHORT LARc,
    LPSHORT s,
    LPSHORT d	    );

EXTERN_C void encodeLTPAnalysis
(   PSTREAMINSTANCE psi,
    LPSHORT d,
    LPSHORT pNc,
    LPSHORT pbc	    );

void encodeLTPFilter
(   PSTREAMINSTANCE psi,
    SHORT bc,
    SHORT Nc,
    LPSHORT d,
    LPSHORT e,
    LPSHORT dpp	    );

void encodeRPE
(   PSTREAMINSTANCE psi,
    LPSHORT e,
    LPSHORT pMc,
    LPSHORT pxmaxc,
    LPSHORT xMc,
    LPSHORT ep	    );

void encodeUpdate
(   PSTREAMINSTANCE psi,
    LPSHORT ep,
    LPSHORT dpp	    );

void PackFrame0
(   BYTE  FAR ab[],
    SHORT FAR LAR[],
    SHORT FAR N[],
    SHORT FAR b[],
    SHORT FAR M[],
    SHORT FAR Xmax[],
    XM    FAR X[]   );

void PackFrame1
(   BYTE  FAR ab[],
    SHORT FAR LAR[],
    SHORT FAR N[],
    SHORT FAR b[],
    SHORT FAR M[],
    SHORT FAR Xmax[],
    XM    FAR X[]   );

//
//
// decode functions
//

void decodeRPE
(   PSTREAMINSTANCE psi,
    SHORT   Mcr,
    SHORT   xmaxcr,
    LPSHORT xMcr,
    LPSHORT erp	    );

EXTERN_C void decodeLTP
(   PSTREAMINSTANCE psi,
    SHORT   bcr,
    SHORT   Ncr,
    LPSHORT erp	    );

void decodeLPC
(   PSTREAMINSTANCE psi,
    LPSHORT LARcr,
    LPSHORT wt,
    LPSHORT sr	    );

EXTERN_C void decodePostproc
(   PSTREAMINSTANCE psi,
    LPSHORT sr,
    LPSHORT srop    );

void UnpackFrame0
(   BYTE    FAR ab[],
    SHORT   FAR LAR[],
    SHORT   FAR N[],
    SHORT   FAR b[],
    SHORT   FAR M[],
    SHORT   FAR Xmax[],
    XM      FAR X[] );

void UnpackFrame1
(   BYTE    FAR ab[],
    SHORT   FAR LAR[],
    SHORT   FAR N[],
    SHORT   FAR b[],
    SHORT   FAR M[],
    SHORT   FAR Xmax[],
    XM      FAR X[] );


//---------------------------------------------------------------------
//---------------------------------------------------------------------
//
// Functions
//
//---------------------------------------------------------------------
//---------------------------------------------------------------------


//---------------------------------------------------------------------
//
// gsm610Reset(PSTREAMINSTANCE psi)
//
// Description:
//	Resets the gsm610-specific stream instance data for
//	the encode/decode routines
//
// Arguments:
//	PSTREAMINSTANCE psi
//	    Pointer to stream instance structure
//
// Return value:
//	void
//	    No return value
//
//---------------------------------------------------------------------

void FNGLOBAL gsm610Reset(PSTREAMINSTANCE psi)
{
    
    // For our gsm610 codec, almost all our instance data resets to 0
    
    UINT i;

    for (i=0; i<SIZEOF_ARRAY(psi->dp); i++) psi->dp[i] = 0;
    for (i=0; i<SIZEOF_ARRAY(psi->drp); i++) psi->drp[i] = 0;
    psi->z1 = 0;
    psi->l_z2 = 0;
    psi->mp = 0;
    for (i=0; i<SIZEOF_ARRAY(psi->OldLARpp); i++) psi->OldLARpp[i] = 0;
    for (i=0; i<SIZEOF_ARRAY(psi->u); i++) psi->u[i] = 0;
    psi->nrp = 40;	// The only non-zero init
    for (i=0; i<SIZEOF_ARRAY(psi->OldLARrpp); i++) psi->OldLARrpp[i] = 0;
    psi->msr = 0;
    for (i=0; i<SIZEOF_ARRAY(psi->v); i++) psi->v[i] = 0;
	    
    return;
}   
    

//--------------------------------------------------------------------------;
//  
//  LRESULT gsm610Encode
//  
//  Description:
//	This function handles the ACMDM_STREAM_CONVERT message. This is the
//	whole purpose of writing an ACM driver--to convert data. This message
//	is sent after a stream has been opened (the driver receives and
//	succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//	LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//	conversion stream. This structure was allocated by the ACM and
//	filled with the most common instance data needed for conversions.
//	The information in this structure is exactly the same as it was
//	during the ACMDM_STREAM_OPEN message--so it is not necessary
//	to re-verify the information referenced by this structure.
//  
//	LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//	that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//	The return value is zero (MMSYSERR_NOERROR) if this function
//	succeeds with no errors. The return value is a non-zero error code
//	if the function fails.
//  
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL gsm610Encode
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
)
{
#if (GSM610_FRAMESPERMONOBLOCK != 2)
    #error THIS WAS WRITTEN FOR 2 FRAMES PER BLOCK!!!
#endif
#if (GSM610_MAXCHANNELS > 1)
    #error THIS WAS WRITTEN FOR MONO ONLY!!!
#endif

    PSTREAMINSTANCE	psi;
    DWORD		cbSrcLen;
    BOOL		fBlockAlign;
    DWORD		cb;
    DWORD		dwcSamples;	// dw count of samples
    DWORD		cBlocks;
    UINT		i;
    HPBYTE		hpbSrc, hpbDst;
    
    SHORT   sop[GSM610_SAMPLESPERFRAME];
    SHORT   s[GSM610_SAMPLESPERFRAME];
    SHORT   d[GSM610_SAMPLESPERFRAME];
    SHORT   e[GSM610_SAMPLESPERSUBFRAME];
    SHORT   dpp[GSM610_SAMPLESPERSUBFRAME];
    SHORT   ep[GSM610_SAMPLESPERSUBFRAME];
    
    // The GSM610 stream data:
    SHORT   LARc[9];			    // LARc[1..8] (one array per frame)
    SHORT   Nc[GSM610_NUMSUBFRAMES];	    // Nc (one per sub-frame)
    SHORT   bc[GSM610_NUMSUBFRAMES];	    // bc (one per sub-frame)
    SHORT   Mc[GSM610_NUMSUBFRAMES];	    // Mc (one per sub-frame)
    SHORT   xmaxc[GSM610_NUMSUBFRAMES];	    // Xmaxc (one per sub-frame)
    XM	    xMc[GSM610_NUMSUBFRAMES];	    // xMc (one sequence per sub-frame)
    
    // Temp buffer to hold a block (two frames) of packed stream data
    BYTE  abBlock[ GSM610_BYTESPERMONOBLOCK ];
    
    UINT    nFrame;
    UINT    cSamples;
    
#ifdef DEBUG
//  ProfSetup(1000,0);
//  ProfStart();
#endif

    psi		= (PSTREAMINSTANCE)padsi->dwDriver;

    //
    // If this is flagged as the first block of a conversion
    // then reset the stream instance data.
    //
    if (0 != (ACM_STREAMCONVERTF_START & padsh->fdwConvert))
    {
	gsm610Reset(psi);
    }
    
    fBlockAlign = (0 != (ACM_STREAMCONVERTF_BLOCKALIGN & padsh->fdwConvert));


    //
    //	-= encode PCM to GSM 6.10 =-
    //
    //
    //
    dwcSamples = PCM_BYTESTOSAMPLES(((LPPCMWAVEFORMAT)(padsi->pwfxSrc)), padsh->cbSrcLength);
    cBlocks = dwcSamples / GSM610_SAMPLESPERMONOBLOCK;
    if (!fBlockAlign)
    {
	//
	// Add on another block to hold the fragment of
	// data at the end of our source data.
	//
	if (0 != dwcSamples % GSM610_SAMPLESPERMONOBLOCK)
	    cBlocks++;
    }

    //
    //
    //
    cb = cBlocks * GSM610_BLOCKALIGNMENT(padsi->pwfxDst);
    if (cb > padsh->cbDstLength)
    {
	return (ACMERR_NOTPOSSIBLE);
    }
    padsh->cbDstLengthUsed = cb;

    if (fBlockAlign)
    {
	dwcSamples = cBlocks * GSM610_SAMPLESPERMONOBLOCK;
	cb = PCM_SAMPLESTOBYTES(((LPPCMWAVEFORMAT)(padsi->pwfxSrc)), dwcSamples);
    }
    else
    {
	cb = padsh->cbSrcLength;
    }
    padsh->cbSrcLengthUsed = cb;



    //
    //
    //
    cbSrcLen = padsh->cbSrcLengthUsed;

    // Setup huge pointers to our src and dst buffers
    hpbSrc = (HPBYTE)padsh->pbSrc;
    hpbDst = (HPBYTE)padsh->pbDst;
    
    // Loop thru entire source buffer
    while (cbSrcLen)
    {
    
	// Process source buffer as two full GSM610 frames
	
	for (nFrame=0; nFrame < 2; nFrame++)
	{
	    //
	    // the src contains 8- or 16-bit PCM.  currently we only
	    // handle mono conversions.
	    //

	    //
	    // we will fill sop[] with one frame of 16-bit PCM samples
	    //
	    
	    //
	    // copy min( cSrcSamplesLeft, GSM610_SAMPLESPERFRAME ) samples
	    // to array sop[].
	    //
	    dwcSamples = PCM_BYTESTOSAMPLES(((LPPCMWAVEFORMAT)(padsi->pwfxSrc)), cbSrcLen);
	    cSamples = (int) min(dwcSamples, (DWORD) GSM610_SAMPLESPERFRAME);

	    if (padsi->pwfxSrc->wBitsPerSample == 16)
	    {
		// copy 16-bit samples from hpbSrc to sop
		for (i=0; i < cSamples; i++)
		{
		    sop[i] = *( ((HPWORD)hpbSrc)++ );
		}
	    }
	    else
	    {
		// copy 8-bit samples from hpbSrc to 16-bit samples in sop
		for (i=0; i < cSamples; i++)
		{
		    sop[i] = Convert8To16BitPCM(*hpbSrc++);
		}
	    }

	    cbSrcLen -= PCM_SAMPLESTOBYTES(((LPPCMWAVEFORMAT)(padsi->pwfxSrc)), cSamples);

	    // fill out sop[] with silence if necessary.
	    for ( ; i < GSM610_SAMPLESPERFRAME; i++)
	    {
		sop[i] = 0;
	    }
	
	    //
	    // Encode a frame of data
	    //
	
	    encodePreproc(psi, sop, s);
	    encodeLPCAnalysis(psi, s, LARc);
	    encodeLPCFilter(psi, LARc, s, d);

	    // For each of four sub-frames
	    for (i=0; i<4; i++)
	    {	    
		encodeLTPAnalysis(psi, &d[i*40], &Nc[i], &bc[i]);
		encodeLTPFilter(psi, bc[i], Nc[i], &d[i*40], e, dpp);
		encodeRPE(psi, e, &Mc[i], &xmaxc[i], xMc[i], ep);
		encodeUpdate(psi, ep, dpp);
	    }
	
	    //
	    // Pack the data and store in dst buffer
	    //
	    if (nFrame == 0)
		PackFrame0(abBlock, LARc, Nc, bc, Mc, xmaxc, xMc);
	    else
	    {
		PackFrame1(abBlock, LARc, Nc, bc, Mc, xmaxc, xMc);
		for (i=0; i<GSM610_BYTESPERMONOBLOCK; i++)
		    *(hpbDst++) = abBlock[i];
	    }
	}   // for (nFrame...
    }
    

#ifdef DEBUG
//  ProfStop();
#endif
    
    return (MMSYSERR_NOERROR);
}


//--------------------------------------------------------------------------;
//  
//  LRESULT gsm610Decode
//  
//  Description:
//	This function handles the ACMDM_STREAM_CONVERT message. This is the
//	whole purpose of writing an ACM driver--to convert data. This message
//	is sent after a stream has been opened (the driver receives and
//	succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//	LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//	conversion stream. This structure was allocated by the ACM and
//	filled with the most common instance data needed for conversions.
//	The information in this structure is exactly the same as it was
//	during the ACMDM_STREAM_OPEN message--so it is not necessary
//	to re-verify the information referenced by this structure.
//  
//	LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//	that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//	The return value is zero (MMSYSERR_NOERROR) if this function
//	succeeds with no errors. The return value is a non-zero error code
//	if the function fails.
//  
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL gsm610Decode
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
)
{
#if (GSM610_FRAMESPERMONOBLOCK != 2)
    #error THIS WAS WRITTEN FOR 2 FRAMES PER BLOCK!!!
#endif
#if (GSM610_MAXCHANNELS > 1)
    #error THIS WAS WRITTEN FOR MONO ONLY!!!
#endif

    PSTREAMINSTANCE	psi;
    DWORD		cbSrcLen;
    BOOL		fBlockAlign;
    DWORD		cb;
    DWORD		dwcSamples;
    DWORD		cBlocks;
    HPBYTE		hpbSrc, hpbDst;
    
    SHORT   erp[GSM610_SAMPLESPERSUBFRAME];
    SHORT   wt[GSM610_SAMPLESPERFRAME];
    SHORT   sr[GSM610_SAMPLESPERFRAME];
    SHORT   srop[GSM610_SAMPLESPERFRAME];
    
    // The GSM610 stream data:
    SHORT   LARcr[9];			    // LARc[1..8] (one array per frame)
    SHORT   Ncr[GSM610_NUMSUBFRAMES];	    // Nc (one per sub-frame)
    SHORT   bcr[GSM610_NUMSUBFRAMES];	    // bc (one per sub-frame)
    SHORT   Mcr[GSM610_NUMSUBFRAMES];	    // Mc (one per sub-frame)
    SHORT   xmaxcr[GSM610_NUMSUBFRAMES];    // Xmaxc (one per sub-frame)
    XM	    xMcr[GSM610_NUMSUBFRAMES];	    // xMc (one sequence per sub-frame)
    
    UINT    i,j;
    UINT    nFrame;

    // Temp buffer to hold a block (two frames) of packed stream data
    BYTE    abBlock[ GSM610_BYTESPERMONOBLOCK ];
    
    
#ifdef DEBUG
//  ProfStart();
#endif

    psi		= (PSTREAMINSTANCE)padsi->dwDriver;

    // If this is flagged as the first block of a conversion
    // then reset the stream instance data.
    if (0 != (ACM_STREAMCONVERTF_START & padsh->fdwConvert))
    {
	gsm610Reset(psi);
    }
    
    fBlockAlign = (0 != (ACM_STREAMCONVERTF_BLOCKALIGN & padsh->fdwConvert));



    //
    //	-= decode GSM 6.10 to PCM =-
    //
    //
    cb = padsh->cbSrcLength;

    cBlocks = cb / GSM610_BLOCKALIGNMENT(padsi->pwfxSrc);

    if (0L == cBlocks)
    {
       padsh->cbSrcLengthUsed = cb;
       padsh->cbDstLengthUsed = 0L;

       return (MMSYSERR_NOERROR);
    }


    //
    // Compute bytes we will use in destination buffer.  Carefull!  Look
    // out for overflow in our calculations!
    //
    if ((0xFFFFFFFFL / GSM610_SAMPLESPERMONOBLOCK) < cBlocks)
	return (ACMERR_NOTPOSSIBLE);
    dwcSamples = cBlocks * GSM610_SAMPLESPERMONOBLOCK;

    if (PCM_BYTESTOSAMPLES(((LPPCMWAVEFORMAT)(padsi->pwfxDst)), 0xFFFFFFFFL) < dwcSamples)
	return (ACMERR_NOTPOSSIBLE);
    cb = PCM_SAMPLESTOBYTES(((LPPCMWAVEFORMAT)(padsi->pwfxDst)), dwcSamples);
    
    if (cb > padsh->cbDstLength)
    {
       return (ACMERR_NOTPOSSIBLE);
    }

    padsh->cbDstLengthUsed = cb;
    padsh->cbSrcLengthUsed = cBlocks * GSM610_BLOCKALIGNMENT(padsi->pwfxSrc);



    //
    //
    //
    cbSrcLen = padsh->cbSrcLengthUsed;

	
    // Setup huge pointers to our src and dst buffers
    hpbSrc = (HPBYTE)padsh->pbSrc;
    hpbDst = (HPBYTE)padsh->pbDst;

    
    // while at least another full block of coded data
    while (cbSrcLen >= GSM610_BYTESPERMONOBLOCK)
    {
	
	// copy a block of data from stream buffer to our temp buffer	    
	for (i=0; i<GSM610_BYTESPERMONOBLOCK; i++) abBlock[i] = *(hpbSrc++);
	cbSrcLen -= GSM610_BYTESPERMONOBLOCK;
	
	// for each of the two frames in the block
	for (nFrame=0; nFrame < 2; nFrame++)
	{
	    // Unpack data from stream
	    if (nFrame == 0)
		UnpackFrame0(abBlock, LARcr, Ncr, bcr, Mcr, xmaxcr, xMcr);
	    else
		UnpackFrame1(abBlock, LARcr, Ncr, bcr, Mcr, xmaxcr, xMcr);
	    
	    
	    for (i=0; i<4; i++) // for each of 4 sub-blocks
	    {
		// reconstruct the long term residual signal erp[0..39]
		// from Mcr, xmaxcr, and xMcr
		decodeRPE(psi, Mcr[i], xmaxcr[i], xMcr[i], erp);
		
		// reconstruct the short term residual signal drp[0..39]
		// and also update drp[-120..-1]
		decodeLTP(psi, bcr[i], Ncr[i], erp);
    
		// accumulate the four sub-blocks of reconstructed short
		// term residual signal drp[0..39] into wt[0..159]
		for (j=0; j<40; j++) wt[(i*40) + j] = psi->drp[120+j];
		
	    }
	    
	    // reconstruct the signal s
	    decodeLPC(psi, LARcr, wt, sr);
	    
	    // post-process the signal s
	    decodePostproc(psi, sr, srop);

	    //
	    // write decoded 16-bit PCM to dst.  our dst format
	    // may be 8- or 16-bit PCM.
	    //
	    if (padsi->pwfxDst->wBitsPerSample == 16)
	    {
		// copy 16-bit samples from srop to hpbDst
		for (j=0; j < GSM610_SAMPLESPERFRAME; j++)
		{
		    *( ((HPWORD)hpbDst)++ ) = srop[j];
		}
	    }
	    else
	    {
		// copy 16-bit samples from srop to 8-bit samples in hpbDst
		for (j=0; j < GSM610_SAMPLESPERFRAME; j++)
		{
		    *(hpbDst++) = Convert16To8BitPCM(srop[j]);
		}
	    }

	    
	} // for (nFrame...
	
    }
    
#ifdef DEBUG
//  ProfStop();
#endif
    
    return (MMSYSERR_NOERROR);
}


//=====================================================================
//=====================================================================
//
//  Encode routines
//
//=====================================================================
//=====================================================================

//---------------------------------------------------------------------
//--------------------------------------------------------------------
//
// Function protos
//
//---------------------------------------------------------------------
//---------------------------------------------------------------------
EXTERN_C void CompACF(LPSHORT s, LPLONG l_ACF);
void Compr(PSTREAMINSTANCE psi, LPLONG l_ACF, LPSHORT r);
void CompLAR(PSTREAMINSTANCE psi, LPSHORT r, LPSHORT LAR);
void CompLARc(PSTREAMINSTANCE psi, LPSHORT LAR, LPSHORT LARc);

void CompLARpp(PSTREAMINSTANCE psi, LPSHORT LARc, LPSHORT LARpp);
void CompLARp(PSTREAMINSTANCE psi, LPSHORT LARpp, LPSHORT LARp1, LPSHORT LARp2, LPSHORT LARp3, LPSHORT LARp4);
void Comprp(PSTREAMINSTANCE psi, LPSHORT LARp, LPSHORT rp);
EXTERN_C void Compd(PSTREAMINSTANCE psi, LPSHORT rp, LPSHORT s, LPSHORT d, UINT k_start, UINT k_end);

void WeightingFilter(PSTREAMINSTANCE psi, LPSHORT e, LPSHORT x);
void RPEGridSelect(PSTREAMINSTANCE psi, LPSHORT x, LPSHORT pMc, LPSHORT xM);
void APCMQuantize(PSTREAMINSTANCE psi, LPSHORT xM, LPSHORT pxmaxc, LPSHORT xMc, LPSHORT pexp, LPSHORT pmant);
void APCMInvQuantize(PSTREAMINSTANCE psi, SHORT exp, SHORT mant, LPSHORT xMc, LPSHORT xMp);
void RPEGridPosition(PSTREAMINSTANCE psi, SHORT Mc, LPSHORT xMp, LPSHORT ep);


//---------------------------------------------------------------------
//---------------------------------------------------------------------
//
// Global constant data
//
//---------------------------------------------------------------------
//---------------------------------------------------------------------

const SHORT BCODE A[9] = {
    0,	    // not used
    20480, 20480, 20480, 20480, 13964, 15360, 8534, 9036 };

const SHORT BCODE B[9] = {
    0,	    // not used
    0, 0, 2048, -2560, 94, -1792, -341, -1144 };

const SHORT BCODE MIC[9] = {
    0,	    // not used
    -32, -32, -16, -16, -8, -8, -4, -4 };

const SHORT BCODE MAC[9] = {
    0,	    // not used
    31, 31, 15, 15, 7, 7, 3, 3 };

const SHORT BCODE INVA[9] = {
    0,	// unused
    13107, 13107, 13107, 13107, 19223, 17476, 31454, 29708 };

EXTERN_C const SHORT BCODE DLB[4] = { 6554, 16384, 26214, 32767 };
EXTERN_C const SHORT BCODE QLB[4] = { 3277, 11469, 21299, 32767 };

const SHORT BCODE H[11] = { -134, -374, 0, 2054, 5741, 8192, 5741, 2054, 0, -374, -134 };
const SHORT BCODE NRFAC[8] = { 29128, 26215, 23832, 21846, 20165, 18725, 17476, 16384 };
const SHORT BCODE FAC[8] = { 18431, 20479, 22527, 24575, 26623, 28671, 30719, 32767 };

//---------------------------------------------------------------------
//---------------------------------------------------------------------
//
// Procedures
//
//---------------------------------------------------------------------
//---------------------------------------------------------------------


//---------------------------------------------------------------------
//
// PackFrame0
//
//---------------------------------------------------------------------

void PackFrame0
(
    BYTE  FAR ab[],
    SHORT FAR LAR[],
    SHORT FAR N[],
    SHORT FAR b[],
    SHORT FAR M[],
    SHORT FAR Xmax[],
    XM    FAR X[]
)
{
    int i;
    
    // Pack the LAR[1..8] into the first 4.5 bytes
    ab[0] = ((LAR[1]	 ) & 0x3F) | ((LAR[2] << 6) & 0xC0);
    ab[1] = ((LAR[2] >> 2) & 0x0F) | ((LAR[3] << 4) & 0xF0);
    ab[2] = ((LAR[3] >> 4) & 0x01) | ((LAR[4] << 1) & 0x3E) | ((LAR[5] << 6) & 0xC0);
    ab[3] = ((LAR[5] >> 2) & 0x03) | ((LAR[6] << 2) & 0x3C) | ((LAR[7] << 6) & 0xC0);
    ab[4] = ((LAR[7] >> 2) & 0x01) | ((LAR[8] << 1) & 0x0E);
    
    // Pack N, b, M, Xmax, and X for each of the 4 sub-frames
    for (i=0; i<4; i++)
    {
    
	ab[4+i*7+0] |= ((N[i] << 4) & 0xF0);
	ab[4+i*7+1] = ((N[i] >> 4) & 0x07) | ((b[i] << 3) & 0x18) | ((M[i] << 5) & 0x60) | ((Xmax[i] << 7) & 0x80);
	ab[4+i*7+2] = ((Xmax[i] >> 1) & 0x1F) | ((X[i][0] << 5) & 0xE0);
	ab[4+i*7+3] = (X[i][1] & 0x07) | ((X[i][2] << 3) & 0x38) | ((X[i][3] << 6) & 0xC0);
	ab[4+i*7+4] = ((X[i][3] >> 2) & 0x01) | ((X[i][4] << 1) & 0x0E) | ((X[i][5] << 4) & 0x70) | ((X[i][6] << 7) & 0x80);
	ab[4+i*7+5] = ((X[i][6] >> 1) & 0x03) | ((X[i][7] << 2) & 0x1C) | ((X[i][8] << 5) & 0xE0);
	ab[4+i*7+6] = (X[i][9] & 0x07) | ((X[i][10] << 3) & 0x38) | ((X[i][11] << 6) & 0xC0);
	ab[4+i*7+7] = ((X[i][11] >> 2) & 0x01) | ((X[i][12] << 1) & 0x0E);
    
    }
    
    return;
}	


//---------------------------------------------------------------------
//
// PackFrame1
//
//---------------------------------------------------------------------

void PackFrame1
(
    BYTE  FAR ab[],
    SHORT FAR LAR[],
    SHORT FAR N[],
    SHORT FAR b[],
    SHORT FAR M[],
    SHORT FAR Xmax[],
    XM    FAR X[]
)
{
    int i;
    
    // Pack the LAR[1..8] into the first 4.5 bytes, starting with the
    // more significant nibble of the first byte.
    ab[32] |= ((LAR[1] << 4) & 0xF0);
    ab[33] = ((LAR[1] >> 4) & 0x03) | ((LAR[2] << 2) & 0xFC);
    ab[34] = ((LAR[3]	  ) & 0x1F) | ((LAR[4] << 5) & 0xE0);
    ab[35] = ((LAR[4] >> 3) & 0x03) | ((LAR[5] << 2) & 0x3C) | ((LAR[6] << 6) & 0xC0);
    ab[36] = ((LAR[6] >> 2) & 0x03) | ((LAR[7] << 2) & 0x1C) | ((LAR[8] << 5) & 0xE0);
    
    // Pack N, b, M, Xmax, and X for each of the 4 sub-frames
    for (i=0; i<4; i++)
    {
	ab[37+i*7+0] = (N[i] & 0x7F) | ((b[i] << 7) & 0x80);
	ab[37+i*7+1] = ((b[i] >> 1) & 0x01) | ((M[i] << 1) & 0x06) | ((Xmax[i] << 3) & 0xF8);
	ab[37+i*7+2] = ((Xmax[i] >> 5) & 0x01) | ((X[i][0] << 1) & 0x0E) | ((X[i][1] << 4) & 0x70) | ((X[i][2] << 7) & 0x80);
	ab[37+i*7+3] = ((X[i][2] >> 1) & 0x03) | ((X[i][3] << 2) & 0x1C) | ((X[i][4] << 5) & 0xE0);
	ab[37+i*7+4] = ((X[i][5]     ) & 0x07) | ((X[i][6] << 3) & 0x38) | ((X[i][7] << 6) & 0xC0);
	ab[37+i*7+5] = ((X[i][7] >> 2) & 0x01) | ((X[i][8] << 1) & 0x0E) | ((X[i][9] << 4) & 0x70) | ((X[i][10] << 7) & 0x80);
	ab[37+i*7+6] = ((X[i][10] >> 1) & 0x03) | ((X[i][11] << 2) & 0x1C) | ((X[i][12] << 5) & 0xE0);
    }
    
    return;
}	


//---------------------------------------------------------------------
//
// encodePreproc()
//
//---------------------------------------------------------------------

void encodePreproc(PSTREAMINSTANCE psi, LPSHORT sop, LPSHORT s)
{
    
    SHORT   so[160];
    SHORT   sof[160];
    
    UINT    k;
    SHORT   s1;
    SHORT   temp;
    SHORT   msp, lsp;
    LONG    l_s2;
    
    // downscale
    for (k=0; k<160; k++)
    {
	so[k] = sop[k] >> 3;
	so[k] = so[k]  << 2;
    }
	
    // offset compensation
    for (k=0; k<160; k++)
    {
	
	// Compute the non-recursive part
	s1 = sub(so[k], psi->z1);
	psi->z1 = so[k];
	
	// compute the recursive part
	l_s2 = s1;
	l_s2 = l_s2 << 15;
	
	// execution of 31 by 16 bits multiplication
	msp = (SHORT) (psi->l_z2 >> 15);
	lsp = (SHORT) l_sub(psi->l_z2, ( ((LONG)msp) << 15));
	temp = mult_r(lsp, 32735);
	l_s2 = l_add(l_s2, temp);
	psi->l_z2 = l_add(l_mult(msp, 32735) >> 1, l_s2);
	
	// compute sof[k] with rounding
	sof[k] = (SHORT) (l_add(psi->l_z2, 16384) >> 15);
    }
	
    // preemphasis
    for (k=0; k<160; k++)
    {
	s[k] = add(sof[k], mult_r(psi->mp, -28180));
	psi->mp = sof[k];
    }
	
		   
    return;
}
    
    
//---------------------------------------------------------------------
//
// encodeLPCAnalysis()
//
//---------------------------------------------------------------------

void encodeLPCAnalysis(PSTREAMINSTANCE psi, LPSHORT s, LPSHORT LARc)
{

    LONG    l_ACF[9];
    SHORT   r[9];
    SHORT   LAR[9];

    CompACF(s, l_ACF);
    Compr(psi, l_ACF, r);
    CompLAR(psi, r, LAR);
    CompLARc(psi, LAR, LARc);
    
    return;

}


//---------------------------------------------------------------------
//
// CompACF()
//
//---------------------------------------------------------------------

void CompACF(LPSHORT s, LPLONG l_ACF)
{
    SHORT   smax, temp, scalauto;
    UINT    i, k;
    
    //
    // Dynamic scaling of array s[0..159]
    //
    
    // Search for the maximum
    smax = 0;
    for (k=0; k<160; k++)
    {
	temp = gabs(s[k]);
	if (temp > smax) smax = temp;
    }
    
    // Computation of the scaling factor
    if (smax == 0) scalauto = 0;
    else scalauto = sub( 4, norm( ((LONG)smax)<<16 ) );
    
    // Scaling of the array s
    if (scalauto > 0)
    {
	temp = BITSHIFTRIGHT(16384, sub(scalauto,1));
	for (k=0; k<160; k++)
	{
	    // s[k] = mult_r(s[k], temp);
	    s[k] = HIWORD( ( (((LONG)s[k])<<(15-scalauto)) + 0x4000L ) << 1 );
	}
    }
    
    
    //
    // Compute the l_ACF[..]
    //
    
    for (k=0; k<9; k++)
    {
	l_ACF[k] = 0;
	for (i=k; i<160; i++)
	{
	    l_ACF[k] = l_add(l_ACF[k], l_mult(s[i], s[i-k]));
	}
    }
    
    
    //
    // Rescaling of array s
    //
    
    if (scalauto > 0)
    {
	for (k=0; k<160; k++)
	{
	    // We don't need the BITSHIFTLEFT macro
	    // cuz we know scalauto>0 due to above test
	    s[k] = s[k] << scalauto;
	}
    }


    //
    //
    //
    return;
}


//---------------------------------------------------------------------
//
// Compr()
//
//---------------------------------------------------------------------

void Compr(PSTREAMINSTANCE psi, LPLONG l_ACF, LPSHORT r)
{

    UINT    i, k, m, n;
    SHORT   temp, ACF[9];
    SHORT   K[9], P[9];	    // K[2..8], P[0..8]

    //
    // Schur recursion with 16 bits arithmetic
    //

    if (l_ACF[0] == 0)
    {
	for (i=1; i<=8; i++)
	{
	    r[i] = 0;
	}
	return;
    }
    
    
    temp = norm(l_ACF[0]);
    
    for (k=0; k<=8; k++)
    {
	ACF[k] = (SHORT) ((BITSHIFTLEFT(l_ACF[k], temp)) >> 16);
    }
    
    
    //
    // Init array P and K for the recursion
    //
    
    for (i=1; i<=7; i++)
    {
	K[9-i] = ACF[i];
    }
    
    for (i=0; i<=8; i++)
    {
	P[i] = ACF[i];
    }
    
    
    //
    // Compute reflection coefficients
    //
    
    for (n=1; n<=8; n++)
    {
	if (P[0] < gabs(P[1]))
	{
	    for (i=n; i<=8; i++)
	    {
		r[i] = 0;
	    }
	    return;
	}
	
	r[n] = gdiv(gabs(P[1]),P[0]);
	
	if (P[1] > 0) r[n] = sub(0,r[n]);
    
	// Here's the real exit from this for loop  
	if (n==8) return;
	
	
	// Schur recursion
	P[0] = add(P[0], mult_r(P[1], r[n]));
	for (m=1; m<=8-n; m++)
	{
	    P[m] = add( P[m+1], mult_r(K[9-m],r[n]) );
	    K[9-m] = add( K[9-m], mult_r(P[m+1], r[n]) );
	}
	
    }
    
}


//---------------------------------------------------------------------
//
// CompLAR()
//
//---------------------------------------------------------------------

void CompLAR(PSTREAMINSTANCE psi, LPSHORT r, LPSHORT LAR)
{

    UINT  i;
    SHORT temp;

    //
    // Computation of LAR[1..8] from r[1..8]
    //
    
    for (i=1; i<=8; i++)
    {
	temp = gabs(r[i]);
	
	if (temp < 22118)
	{
	    temp = temp >> 1;
	}
	else if (temp < 31130)
	{
	    temp = sub(temp, 11059);
	}
	else
	{
	    temp = sub(temp, 26112) << 2;
	}
	
	LAR[i] = temp;
	
	if (r[i] < 0)
	{
	    LAR[i] = sub(0, LAR[i]);
	}
	
    }
    
    return;
}
    

//---------------------------------------------------------------------
//
// CompLARc()
//
//---------------------------------------------------------------------

void CompLARc(PSTREAMINSTANCE psi, LPSHORT LAR, LPSHORT LARc)
{

    UINT  i;
    SHORT temp;

    for (i=1; i<=8; i++)
    {
	temp = mult(A[i], LAR[i]);
	temp = add(temp, B[i]);
	temp = add(temp, 256);
	LARc[i] = temp >> 9;
	
	// Check if LARc[i] between MIN and MAX
	if (LARc[i] > MAC[i]) LARc[i] = MAC[i];
	if (LARc[i] < MIC[i]) LARc[i] = MIC[i];
	
	// This is used to make all LARc positive
	LARc[i] = sub(LARc[i], MIC[i]);
	
    }
    
    return;
}


//---------------------------------------------------------------------
//
// encodeLPCFilter()
//
//---------------------------------------------------------------------

void encodeLPCFilter(PSTREAMINSTANCE psi, LPSHORT LARc, LPSHORT s, LPSHORT d)
{
    SHORT LARpp[9];				    // array [1..8]
    SHORT LARp1[9], LARp2[9], LARp3[9], LARp4[9];   // array [1..8]
    SHORT rp[9];				    // array [1..8]

    CompLARpp(psi, LARc, LARpp);
    CompLARp(psi, LARpp, LARp1, LARp2, LARp3, LARp4);
    
    Comprp(psi, LARp1, rp);
    Compd(psi, (LPSHORT)rp, s, d, 0, 12);
    
    Comprp(psi, LARp2, rp);
    Compd(psi, (LPSHORT)rp, s, d, 13, 26);
    
    Comprp(psi, LARp3, rp);
    Compd(psi, (LPSHORT)rp, s, d, 27, 39);
    
    Comprp(psi, LARp4, rp);
    Compd(psi, (LPSHORT)rp, s, d, 40, 159);
    
    return;
}


//---------------------------------------------------------------------
//
// CompLARpp()
//
//---------------------------------------------------------------------

void CompLARpp(PSTREAMINSTANCE psi, LPSHORT LARc, LPSHORT LARpp)
{
    UINT    i;
    SHORT   temp1, temp2;
    
    for (i=1; i<=8; i++)
    {
	temp1 = add(LARc[i], MIC[i]) << 10;
	temp2 = B[i] << 1;
	temp1 = sub(temp1,temp2);
	temp1 = mult_r(INVA[i], temp1);
	LARpp[i] = add(temp1, temp1);
    }
    
    return;
}


//---------------------------------------------------------------------
//
// CompLARp()
//
//---------------------------------------------------------------------

void CompLARp(PSTREAMINSTANCE psi, LPSHORT LARpp, LPSHORT LARp1, LPSHORT LARp2, LPSHORT LARp3, LPSHORT LARp4)
{
    UINT i;
    
    for (i=1; i<=8; i++)
    {
	LARp1[i] = add( (SHORT)(psi->OldLARpp[i] >> 2), (SHORT)(LARpp[i] >> 2) );
	LARp1[i] = add( LARp1[i], (SHORT)(psi->OldLARpp[i] >> 1) );
	
	LARp2[i] = add( (SHORT)(psi->OldLARpp[i] >> 1), (SHORT)(LARpp[i] >> 1) );
	
	LARp3[i] = add( (SHORT)(psi->OldLARpp[i] >> 2), (SHORT)(LARpp[i] >> 2) );
	LARp3[i] = add( LARp3[i], (SHORT)(LARpp[i] >> 1) );
	
	LARp4[i] = LARpp[i];
    }
    
    for (i=1; i<=8; i++)
    {
	psi->OldLARpp[i] = LARpp[i];
    }
    
    return;
    
}


//---------------------------------------------------------------------
//
// Comprp()
//
//---------------------------------------------------------------------

void Comprp(PSTREAMINSTANCE psi, LPSHORT LARp, LPSHORT rp)
{
    UINT    i;
    SHORT   temp;

    for (i=1; i<=8; i++)
    {
	temp = gabs(LARp[i]);
	if (temp < 11059)
	{
	    temp = temp << 1;
	}
	else if (temp < 20070)
	{
	    temp = add(temp, 11059);
	}
	else
	{
	    temp = add((SHORT)(temp>>2), 26112);
	}
	
	rp[i] = temp;
	
	if (LARp[i] < 0)
	{
	    rp[i] = sub(0,rp[i]);
	}
	
    }
    
    return;
}


//---------------------------------------------------------------------
//
// Compd()
//
//---------------------------------------------------------------------

void Compd(PSTREAMINSTANCE psi, LPSHORT rp, LPSHORT s, LPSHORT d, UINT k_start, UINT k_end)
{
    UINT    k, i;
    
    SHORT   sav;
    SHORT   di;
    SHORT   temp;
    
    for (k=k_start; k<=k_end; k++)
    {
	di = s[k];
	sav = di;
	
	for (i=1; i<=8; i++)
	{
	    temp = add( psi->u[i-1], mult_r(rp[i],di) );
	    di = add( di, mult_r(rp[i], psi->u[i-1]) );
	    psi->u[i-1] = sav;
	    sav = temp;
	}
	
	d[k] = di;
    }
    
    return;
}


//---------------------------------------------------------------------
//
// encodeLTPAnalysis()
//
//---------------------------------------------------------------------

void encodeLTPAnalysis(PSTREAMINSTANCE psi, LPSHORT d, LPSHORT pNc, LPSHORT pbc)
{
    SHORT dmax;
    SHORT temp;
    SHORT scal;
    SHORT wt[40];
    SHORT lambda;
    LONG  l_max, l_power;
    SHORT R, S;
    SHORT Nc;
    
    int   k;               // k must be int, not UINT!

    Nc = *pNc;
	
    // Search of the optimum scaling of d[0..39]
	   
    dmax = 0;
    
    for (k=39; k>=0; k--)
    {
        temp = gabs( d[k] );
        if (temp > dmax) dmax = temp;
    }

    temp = 0;
    
    if (dmax == 0) scal = 0;
    else temp = norm( ((LONG)dmax) << 16);
    
    if (temp > 6) scal = 0;
    else scal = sub(6,temp);
    

    // Init of working array wt[0..39]
    ASSERT( scal >= 0 );
    for (k=39; k>=0; k--)
    {
        wt[k] = d[k] >> scal;
    }
    
    // Search for max cross-correlation and coding of LTP lag
    
    l_max = 0;
    Nc = 40;
    
    for (lambda=40; lambda<=120; lambda++)
    {
        register LONG l_result = 0;
        for (k=39; k>=0; k--)
        {
            l_result += (LONG)(wt[k]) * (LONG)(psi->dp[120-lambda+k]);
        }
        if (l_result > l_max)
        {
            Nc = lambda;
            l_max = l_result;
        }
    }
    l_max <<= 1;    // This operation should be on l_result as part of the
                    //  multiply/add, but for efficiency we shift it all
                    //  the way out of the loops.
    
    // Rescaling of l_max
    ASSERT( sub(6,scal) >= 0 );
    l_max = l_max >> sub(6,scal);
    
    // Compute the power of the reconstructed short term residual
    // signal dp[..].
    l_power = 0;
    {
        SHORT s;
        for (k=39; k>=0; k--)
        {
            s = psi->dp[120-Nc+k] >> 3;
            l_power += s*s;   // This sum can never overflow!!!
        }
        ASSERT( l_power >= 0 );
        if( l_power >= 1073741824 ) {           // 2**30
            l_power = 2147483647;               // 2**31 - 1
        } else {
            l_power <<= 1;   // This shift is normally part of l_mult().
        }
    }

    *pNc = Nc;
	
    // Normalization of l_max and l_power
    if (l_max <= 0)
    {
	*pbc = 0;
	return;
    }
    
    if (l_max >= l_power)
    {
	*pbc = 3;
	return;
    }
    
    temp = norm(l_power);
    ASSERT( temp >= 0 );
    R = (SHORT) ((l_max<<temp) >> 16);
    S = (SHORT) ((l_power<<temp) >> 16);
    
    // Codeing of the LTP gain
    
    for ( *pbc=0; *pbc<=2; (*pbc)++ )
    {
	if (R <= mult(S, DLB[*pbc]))
	{
	    return;
	}
    }
    *pbc = 3;
    
    return;
}


//---------------------------------------------------------------------
//
// encodeLTPFilter()
//
//---------------------------------------------------------------------

void encodeLTPFilter(PSTREAMINSTANCE psi, SHORT bc, SHORT Nc, LPSHORT d, LPSHORT e, LPSHORT dpp)
{
    SHORT   bp;
    UINT    k;

    // Decoding of the coded LTP gain
    bp = QLB[bc];
    
    // Calculating the array e[0..39] and the array dpp[0..39]
    for (k=0; k<=39; k++)
    {
	dpp[k] = mult_r(bp, psi->dp[120+k-Nc]);
	e[k] = sub(d[k], dpp[k]);
    }
    
    return;
}


//---------------------------------------------------------------------
//
// encodeRPE()
//
//---------------------------------------------------------------------

void encodeRPE(PSTREAMINSTANCE psi, LPSHORT e, LPSHORT pMc, LPSHORT pxmaxc, LPSHORT xMc, LPSHORT ep)
{
    SHORT x[40];
    SHORT xM[13];
    SHORT exp, mant;
    SHORT xMp[13];

    WeightingFilter(psi, e, x);
    RPEGridSelect(psi, x, pMc, xM);
    APCMQuantize(psi, xM, pxmaxc, xMc, &exp, &mant);
    APCMInvQuantize(psi, exp, mant, xMc, xMp);
    RPEGridPosition(psi, *pMc, xMp, ep);
    
    
    return;
    
}


//---------------------------------------------------------------------
//
// WeightingFilter()
//
//---------------------------------------------------------------------

void WeightingFilter(PSTREAMINSTANCE psi, LPSHORT e, LPSHORT x)
{
    UINT    i, k;
    
    LONG    l_result, l_temp;
    SHORT   wt[50];


    // Initialization of a temporary working array wt[0..49]
    for (k= 0; k<= 4; k++) wt[k] = 0;
    for (k= 5; k<=44; k++) wt[k] = e[k-5];
    for (k=45; k<=49; k++) wt[k] = 0;
    
    // Compute the signal x[0..39]
    for (k=0; k<=39; k++)
    {
	l_result = 8192;    // rounding of the output of the filter
	
	for (i=0; i<=10; i++)
	{
	    l_temp = l_mult(wt[k+i], H[i]);
	    l_result = l_add(l_result, l_temp);
	}
	
	l_result = l_add(l_result, l_result);	// scaling x2
	l_result = l_add(l_result, l_result);	// scaling x4
	
	x[k] = (SHORT) (l_result >> 16);
    }
    return;
}


//---------------------------------------------------------------------
//
// RPEGridSelect()
//
//---------------------------------------------------------------------

void RPEGridSelect(PSTREAMINSTANCE psi, LPSHORT x, LPSHORT pMc, LPSHORT xM)
{
    UINT    m, i;

    LONG    l_EM;
    SHORT   temp1;
    LONG    l_result, l_temp;

    // the signal x[0..39] is used to select the RPE grid which is
    // represented by Mc
    l_EM = 0;
    *pMc = 0;
    
    for (m=0; m<=3; m++)
    {
	l_result = 0;
	for (i=0; i<=12; i++)
	{
	    temp1 = x[m+(3*i)] >> 2;
	    l_temp = l_mult(temp1, temp1);
	    l_result = l_add(l_temp, l_result);
	}
	if (l_result > l_EM)
	{
	    *pMc = (SHORT)m;
	    l_EM = l_result;
	}
    }
    
    // down-sampling by a factor of 3 to get the selected xM[0..12]
    // RPE sequence
    for (i=0; i<=12; i++)
    {
	xM[i] = x[*pMc + (3*i)];
    }
    

    return; 
}


//---------------------------------------------------------------------
//
// APCMQuantize()
//
//---------------------------------------------------------------------

void APCMQuantize(PSTREAMINSTANCE psi, LPSHORT xM, LPSHORT pxmaxc, LPSHORT xMc, LPSHORT pexp, LPSHORT pmant)
{
    UINT    i;
    SHORT   xmax;
    SHORT   temp;
    SHORT   itest;
    SHORT   temp1, temp2;

    // find the maximum absolute value xmax or xM[0..12]
    xmax = 0;
    for (i=0; i<=12; i++)
    {
	temp = gabs(xM[i]);
	if (temp > xmax) xmax = temp;
    }
    
    // quantizing and coding of xmax to get xmaxc
    *pexp = 0;
    temp = xmax >> 9;
    itest = 0;
    for (i=0; i<=5; i++)
    {
	if (temp <=0) itest = 1;
	temp = temp >> 1;
	if (itest == 0) *pexp = add(*pexp,1);
    }
    temp = add(*pexp,5);
    *pxmaxc = add( (SHORT)BITSHIFTRIGHT(xmax,temp), (SHORT)(*pexp << 3) );
    
    //
    // quantizing and coding of the xM[0..12] RPE sequence to get
    // the xMc[0..12]
    //
    
    // compute exponent and mantissa of the decoded version of xmaxc
    *pexp = 0;
    if (*pxmaxc > 15) *pexp = sub((SHORT)(*pxmaxc >> 3),1);
    *pmant = sub(*pxmaxc,(SHORT)(*pexp<<3));
    
    // normalize mantissa 0 <= mant <= 7
    if (*pmant==0)
    {
	*pexp = -4;
	*pmant = 15;
    }
    else
    {
	itest = 0;
	for (i=0; i<=2; i++)
	{
	    if (*pmant > 7) itest = 1;
	    if (itest == 0) *pmant = add((SHORT)(*pmant << 1),1);
	    if (itest == 0) *pexp = sub(*pexp,1);
	}
    }
    
    *pmant = sub(*pmant,8);
    
    // direct computation of xMc[0..12] using table
    temp1 = sub(6,*pexp);	// normalization by the exponent
    temp2 = NRFAC[*pmant];  // see table (inverse mantissa)
    for (i=0; i<=12; i++)
    {
	temp = BITSHIFTLEFT(xM[i], temp1);
	temp = mult( temp, temp2 );
	xMc[i] = add( (SHORT)(temp >> 12), 4 );    // makes all xMc[i] positive
    }
    
    return;
}


//---------------------------------------------------------------------
//
// APCMInvQuantize()
//
//---------------------------------------------------------------------

void APCMInvQuantize(PSTREAMINSTANCE psi, SHORT exp, SHORT mant, LPSHORT xMc, LPSHORT xMp)
{
    SHORT   temp1, temp2, temp3, temp;
    UINT    i;

    temp1 = FAC[mant];
    temp2 = sub(6,exp);
    temp3 = BITSHIFTLEFT(1, sub(temp2,1));
    
    for (i=0; i<=12; i++)
    {
	temp = sub( (SHORT)(xMc[i] << 1), 7);	// restores sign of xMc[i]
	temp = temp << 12;
	temp = mult_r(temp1, temp);
	temp = add(temp, temp3);
	xMp[i] = BITSHIFTRIGHT(temp,temp2);
    }
    
    return;
}


//---------------------------------------------------------------------
//
// RPEGridPosition(SHORT Mc, LPSHORT xMp, LPSHORT ep)
//
//---------------------------------------------------------------------

void RPEGridPosition(PSTREAMINSTANCE psi, SHORT Mc, LPSHORT xMp, LPSHORT ep)
{
    UINT    k, i;

    for (k=0; k<=39; k++)
    {
	ep[k] = 0;
    }
    
    for (i=0; i<=12; i++)
    {
	ep[Mc + (3*i)] = xMp[i];
    }
    
    return;
}


//---------------------------------------------------------------------
//
// encodeUpdate()
//
//---------------------------------------------------------------------

void encodeUpdate(PSTREAMINSTANCE psi, LPSHORT ep, LPSHORT dpp)
{
    UINT k;
    
    for (k=0; k<=79; k++)
	psi->dp[120-120+k] = psi->dp[120-80+k];
	
    for (k=0; k<=39; k++)
	psi->dp[120-40+k] = add(ep[k], dpp[k]);
	
    return;
}


//=====================================================================
//=====================================================================
//
//  Decode routines
//
//=====================================================================
//=====================================================================


//---------------------------------------------------------------------
//---------------------------------------------------------------------
//
// Function protos
//
//---------------------------------------------------------------------
//---------------------------------------------------------------------

EXTERN_C void Compsr(PSTREAMINSTANCE psi, LPSHORT wt, LPSHORT rrp, UINT k_start, UINT k_end, LPSHORT sr);


//---------------------------------------------------------------------
//---------------------------------------------------------------------
//
// Procedures
//
//---------------------------------------------------------------------
//---------------------------------------------------------------------


//---------------------------------------------------------------------
//
// UnpackFrame0
//
//---------------------------------------------------------------------

void UnpackFrame0
(
    BYTE  FAR ab[],
    SHORT FAR LAR[],
    SHORT FAR N[],
    SHORT FAR b[],
    SHORT FAR M[],
    SHORT FAR Xmax[],
    XM    FAR X[]
)
{
    UINT i;
    
    // Unpack the LAR[1..8] from the first 4.5 bytes
    LAR[1] =  (ab[0] & 0x3F);
    LAR[2] = ((ab[0] & 0xC0) >> 6) | ((ab[1] & 0x0F) << 2);
    LAR[3] = ((ab[1] & 0xF0) >> 4) | ((ab[2] & 0x01) << 4);
    LAR[4] = ((ab[2] & 0x3E) >> 1);
    LAR[5] = ((ab[2] & 0xC0) >> 6) | ((ab[3] & 0x03) << 2);
    LAR[6] = ((ab[3] & 0x3C) >> 2);
    LAR[7] = ((ab[3] & 0xC0) >> 6) | ((ab[4] & 0x01) << 2);
    LAR[8] = ((ab[4] & 0x0E) >> 1);

    // Unpack N, b, M, Xmax, and X for each of the four sub-frames
    for (i=0; i<4; i++)
    {
	// A convenient macro for getting bytes out of the array for
	// construction of the subframe parameters
#define sfb(x) (ab[4+i*7+x])

	N[i] = ((sfb(0) & 0xF0) >> 4) | ((sfb(1) & 0x07) << 4);
	b[i] = ((sfb(1) & 0x18) >> 3);
	M[i] = ((sfb(1) & 0x60) >> 5);
	Xmax[i] = ((sfb(1) & 0x80) >> 7) | ((sfb(2) & 0x1F) << 1);
	X[i][0] = ((sfb(2) & 0xE0) >> 5);
	X[i][1] =  (sfb(3) & 0x07);
	X[i][2] = ((sfb(3) & 0x3C) >> 3);
	X[i][3] = ((sfb(3) & 0xC0) >> 6) | ((sfb(4) & 0x01) << 2);
	X[i][4] = ((sfb(4) & 0x0E) >> 1);
	X[i][5] = ((sfb(4) & 0x70) >> 4);
	X[i][6] = ((sfb(4) & 0x80) >> 7) | ((sfb(5) & 0x03) << 1);
	X[i][7] = ((sfb(5) & 0x1C) >> 2);
	X[i][8] = ((sfb(5) & 0xE0) >> 5);
	X[i][9] =  (sfb(6) & 0x07);
	X[i][10] = ((sfb(6) & 0x38) >> 3);
	X[i][11] = ((sfb(6) & 0xC0) >> 6) | ((sfb(7) & 0x01) << 2);
	X[i][12] = ((sfb(7) & 0x0E) >> 1);

#undef sfb
    }
    
    return;
}	


//---------------------------------------------------------------------
//
// UnpackFrame1
//
//---------------------------------------------------------------------

void UnpackFrame1
(
    BYTE  FAR ab[],
    SHORT FAR LAR[],
    SHORT FAR N[],
    SHORT FAR b[],
    SHORT FAR M[],
    SHORT FAR Xmax[],
    XM    FAR X[]
)
{
    UINT i;
    
    // Unpack the LAR[1..8] from the first 4.5 bytes
    LAR[1] = ((ab[32] & 0xF0) >> 4) | ((ab[33] & 0x03) << 4);
    LAR[2] = ((ab[33] & 0xFC) >> 2);
    LAR[3] = ((ab[34] & 0x1F)	  );
    LAR[4] = ((ab[34] & 0xE0) >> 5) | ((ab[35] & 0x03) << 3);
    LAR[5] = ((ab[35] & 0x3C) >> 2);
    LAR[6] = ((ab[35] & 0xC0) >> 6) | ((ab[36] & 0x03) << 2);
    LAR[7] = ((ab[36] & 0x1C) >> 2);
    LAR[8] = ((ab[36] & 0xE0) >> 5);

    // Unpack N, b, M, Xmax, and X for each of the four sub-frames
    for (i=0; i<4; i++)
    {
	// A convenient macro for getting bytes out of the array for
	// construction of the subframe parameters
#define sfb(x) (ab[37+i*7+x])

	N[i] = sfb(0) & 0x7F;
	b[i] = ((sfb(0) & 0x80) >> 7) | ((sfb(1) & 0x01) << 1);
	M[i] = ((sfb(1) & 0x06) >> 1);
	Xmax[i] = ((sfb(1) & 0xF8) >> 3) | ((sfb(2) & 0x01) << 5);

	X[i][0] = ((sfb(2) & 0x0E) >> 1);
	X[i][1] = ((sfb(2) & 0x70) >> 4);
	X[i][2] = ((sfb(2) & 0x80) >> 7) | ((sfb(3) & 0x03) << 1);
	X[i][3] = ((sfb(3) & 0x1C) >> 2);
	X[i][4] = ((sfb(3) & 0xE0) >> 5);
	X[i][5] = ((sfb(4) & 0x07)     );
	X[i][6] = ((sfb(4) & 0x38) >> 3);
	X[i][7] = ((sfb(4) & 0xC0) >> 6) | ((sfb(5) & 0x01) << 2);
	X[i][8] = ((sfb(5) & 0x0E) >> 1);
	X[i][9] = ((sfb(5) & 0x70) >> 4);
	X[i][10] = ((sfb(5) & 0x80) >> 7) | ((sfb(6) & 0x03) << 1);
	X[i][11] = ((sfb(6) & 0x1C) >> 2);
	X[i][12] = ((sfb(6) & 0xE0) >> 5);

#undef sfb

    }
    
    return;
}	


//---------------------------------------------------------------------
//
// decodeRPE()
//
//---------------------------------------------------------------------

void decodeRPE(PSTREAMINSTANCE psi, SHORT Mcr, SHORT xmaxcr, LPSHORT xMcr, LPSHORT erp)
{

    SHORT   exp, mant;
    SHORT   itest;
    UINT    i;
    SHORT   temp1, temp2, temp3, temp;
    SHORT   xMrp[13];
    UINT    k;

    // compute the exponent and mantissa of the decoded
    // version of xmaxcr
    
    exp = 0;
    if (xmaxcr > 15) exp = sub( (SHORT)(xmaxcr >> 3), 1 );
    mant = sub( xmaxcr, (SHORT)(exp << 3) );
    
    // normalize the mantissa 0 <= mant <= 7
    if (mant == 0)
    {
	exp = -4;
	mant = 15;
    }
    else
    {
	itest = 0;
	for (i=0; i<=2; i++)
	{
	    if (mant > 7) itest = 1;
	    if (itest == 0) mant = add((SHORT)(mant << 1),1);
	    if (itest == 0) exp = sub(exp,1);
	}
    }
    
    mant = sub(mant, 8);
    
    // APCM inverse quantization
    temp1 = FAC[mant];
    temp2 = sub(6,exp);
    temp3 = BITSHIFTLEFT(1, sub(temp2, 1));
    
    for (i=0; i<=12; i++)
    {
	temp = sub( (SHORT)(xMcr[i] << 1), 7 );
	temp = temp << 12;
	temp = mult_r(temp1, temp);
	temp = add(temp, temp3);
	xMrp[i] = BITSHIFTRIGHT(temp, temp2);
    }
    
    // RPE grid positioning
    for (k=0; k<=39; k++) erp[k] = 0;
    for (i=0; i<=12; i++) erp[Mcr + (3*i)] = xMrp[i];
	
    
    //
    return; 
}


//---------------------------------------------------------------------
//
// decodeLTP()
//
//---------------------------------------------------------------------

void decodeLTP(PSTREAMINSTANCE psi, SHORT bcr, SHORT Ncr, LPSHORT erp)
{
    SHORT   Nr;
    SHORT   brp;
    UINT    k;
    SHORT   drpp;

    // check limits of Nr
    Nr = Ncr;
    if (Ncr < 40) Nr = psi->nrp;
    if (Ncr > 120) Nr = psi->nrp;
    psi->nrp = Nr;
    
    // decoding of the LTP gain bcr
    brp = QLB[bcr];
    
    // computation of the reconstructed short term residual
    // signal drp[0..39]
    for (k=0; k<=39; k++)
    {
	drpp = mult_r( brp, psi->drp[120+k-Nr] );
	psi->drp[120+k] = add( erp[k], drpp );
    }
    
    // update of the reconstructed short term residual
    // signal drp[-1..-120]
    for (k=0; k<=119; k++)
    {
	psi->drp[120-120+k] = psi->drp[120-80+k];
    }
    
    return;
}


//---------------------------------------------------------------------
//
// decodeLPC
//
//---------------------------------------------------------------------

void decodeLPC
(
    PSTREAMINSTANCE psi,    // instance data
    LPSHORT LARcr,	    // received coded Log.-Area Ratios [1..8]
    LPSHORT wt,		    // accumulated drp signal [0..159]
    LPSHORT sr		    // reconstructed s [0..159]
)
{

    UINT    i;
    SHORT   LARrpp[9];	    // LARrpp[1..8], decoded LARcr
    SHORT   LARrp[9];	    // LARrp[1..9], interpolated LARrpp
    SHORT   rrp[9];	    // rrp[1..8], reflection coefficients
    SHORT   temp1, temp2;
    
    //
    // decoding of the coded log area ratios to get LARrpp[1..8]
    //
    
    // compute LARrpp[1..8]
    for (i=1; i<=8; i++)
    {
	temp1 = add( LARcr[i], MIC[i] ) << 10;
	temp2 = B[i] << 1;
	temp1 = sub( temp1, temp2);
	temp1 = mult_r( INVA[i], temp1 );
	LARrpp[i] = add( temp1, temp1 );
    }
    

    //
    // for k_start=0 to k_end=12
    //
	
    // interpolation of LARrpp[1..8] to get LARrp[1..8]
    for (i=1; i<=8; i++)
    {
	// for k_start=0 to k_end=12
	LARrp[i] = add( (SHORT)(psi->OldLARrpp[i] >> 2), (SHORT)(LARrpp[i] >> 2) );
	LARrp[i] = add( LARrp[i], (SHORT)(psi->OldLARrpp[i] >> 1) );
    }
    
    // computation of reflection coefficients rrp[1..8]
    Comprp(psi, LARrp, rrp);
    
    // short term synthesis filtering
    Compsr(psi, wt, rrp, 0, 12, sr);
    
    
    //
    // for k_start=13 to k_end=26
    //
	
    // interpolation of LARrpp[1..8] to get LARrp[1..8]
    for (i=1; i<=8; i++)
    {
	// for k_start=13 to k_end=26
	LARrp[i] = add( (SHORT)(psi->OldLARrpp[i] >> 1), (SHORT)(LARrpp[i] >> 1) );
    }
    
    // computation of reflection coefficients rrp[1..8]
    Comprp(psi, LARrp, rrp);
    
    // short term synthesis filtering
    Compsr(psi, wt, rrp, 13, 26, sr);
    
    //
    // for k_start=27 to k_end=39
    //
	
    // interpolation of LARrpp[1..8] to get LARrp[1..8]
    for (i=1; i<=8; i++)
    {
	// for k_start=27 to k_end=39
	LARrp[i] = add( (SHORT)(psi->OldLARrpp[i] >> 2), (SHORT)(LARrpp[i] >> 2) );
	LARrp[i] = add( LARrp[i], (SHORT)(LARrpp[i] >> 1) );
    }
    
    // computation of reflection coefficients rrp[1..8]
    Comprp(psi, LARrp, rrp);
    
    // short term synthesis filtering
    Compsr(psi, wt, rrp, 27, 39, sr);
    
    //
    // for k_start=40 to k_end=159
    //
	
    // interpolation of LARrpp[1..8] to get LARrp[1..8]
    for (i=1; i<=8; i++)
    {
	// for k_start=40 to k_end=159
	LARrp[i] = LARrpp[i];
    }
    
    // computation of reflection coefficients rrp[1..8]
    Comprp(psi, LARrp, rrp);
    
    // short term synthesis filtering
    Compsr(psi, wt, rrp, 40, 159, sr);


    //	
    // update oldLARrpp[1..8]
    //
    for (i=1; i<=8; i++)
    {
	psi->OldLARrpp[i] = LARrpp[i];
    }
    
    
    return;
}


//---------------------------------------------------------------------
//
// decodePostproc()
//
//---------------------------------------------------------------------

void decodePostproc(PSTREAMINSTANCE psi, LPSHORT sr, LPSHORT srop)
{
    UINT k;
    
    // deemphasis filtering
    for (k=0; k<=159; k++)
    {
	srop[k] = psi->msr = add(sr[k], mult_r(psi->msr, 28180));

	// upscaling and truncation of the output signal
	srop[k] = (add(srop[k], srop[k])) & 0xFFF8;
    }
    
    return;
}


//---------------------------------------------------------------------
//
// Compsr()
//
//---------------------------------------------------------------------

void Compsr(PSTREAMINSTANCE psi, LPSHORT wt, LPSHORT rrp, UINT k_start, UINT k_end, LPSHORT sr)
{
    UINT    i, k;
    SHORT   sri;

    for (k=k_start; k<=k_end; k++)
    {
	sri = wt[k];
	for (i=1; i<=8; i++)
	{
	    sri = sub( sri, mult_r(rrp[9-i], psi->v[8-i]) );
	    psi->v[9-i] = add( psi->v[8-i], mult_r( rrp[9-i], sri ) );
	}
	sr[k] = sri;
	psi->v[0] = sri;
    }
    
    return;
}


//=====================================================================
//=====================================================================
//
//  Math and helper routines
//
//=====================================================================
//=====================================================================


//
// The 8-/16-bit PCM conversion routines are implemented as seperate
// functions to allow easy modification if we someday wish to do
// something more sophisticated that simple truncation...  They are
// prototyped as inline so there should be no performance penalty.
//
//
SHORT Convert8To16BitPCM(BYTE bPCM8)
{
    return  ( ((SHORT)bPCM8) - 0x80 ) << 8;
}

BYTE Convert16To8BitPCM(SHORT iPCM16)
{
    return (BYTE)((iPCM16 >> 8) + 0x80);
}

SHORT add(SHORT var1, SHORT var2)
{
    LONG sum;

    sum = (LONG) var1 + (LONG) var2;
    
    if (sum < -32768L) return -32768;
    if (sum > 32767L) return 32767;
    return (SHORT) sum;

}

SHORT sub(SHORT var1, SHORT var2)
{
    LONG diff;
    
    diff = (LONG) var1 - (LONG) var2;
    if (diff < -32768L) return -32768;
    if (diff > 32767L) return 32767;
    return (SHORT) diff;

}

SHORT mult(SHORT var1, SHORT var2)
{
    LONG product;

    product = (LONG) var1 * (LONG) var2;
    if (product >= 0x40000000) product=0x3FFFFFFF;
    return ( (SHORT) HIWORD((DWORD)(product<<1)) );
}

SHORT mult_r(SHORT var1, SHORT var2)
{
    LONG product;

    product = ((LONG) var1 * (LONG) var2) + 16384L;
    if (product >= 0x40000000) product=0x3FFFFFFF;
    return ( (SHORT) HIWORD((DWORD)(product<<1)) );
}

SHORT gabs(SHORT var1)
{
    if (var1 >= 0) return var1;
    if (var1 == -32768) return 32767;
    return -var1;
}

SHORT gdiv(SHORT num, SHORT denum)
{   
    UINT k;
    LONG l_num, l_denum;
    SHORT div;
    
    l_num = num;
    l_denum = denum;
    
    div = 0;

    for (k=0; k<15; k++)
    {
	div = div << 1;
	l_num = l_num << 1;
	if (l_num >= l_denum)
	{
	    l_num = l_sub(l_num, l_denum);
	    div = add(div,1);
	}
    }

    return div;
}
    
LONG l_mult(SHORT var1, SHORT var2)
{
    LONG product;
    
    product = (LONG) var1 * (LONG) var2;
    return product << 1;
}

LONG l_add(LONG l_var1, LONG l_var2)
{
    LONG l_sum;
    
    // perform long addition
    l_sum = l_var1 + l_var2;

    // check for under or overflow
    if (IsNeg(l_var1))
    {		     
	if (IsNeg(l_var2) && !IsNeg(l_sum))
	{
	    return 0x80000000;
	}
    }
    else
    {
	if (!IsNeg(l_var2) && IsNeg(l_sum))
	{
	    return 0x7FFFFFFF;
	}
    }
    
    return l_sum;
    
}

LONG l_sub(LONG l_var1, LONG l_var2)
{
    LONG l_diff;

    // perform subtraction
    l_diff = l_var1 - l_var2;

    // check for underflow
    if ( (l_var1<0) && (l_var2>0) && (l_diff>0) ) l_diff=0x80000000;
    // check for overflow
    if ( (l_var1>0) && (l_var2<0) && (l_diff<0) ) l_diff=0x7FFFFFFF;

    return l_diff;
}

SHORT norm(LONG l_var)
{
    UINT i;
    
    i=0;
    
    if (l_var > 0)
    {
	while (l_var < 1073741824)
	{
	    i++;
	    l_var = l_var << 1;
	}
    }
    else if (l_var < 0)
    {
	while (l_var > -1073741824)
	{
	    i++;
	    l_var = l_var << 1;
	}
    }

    return (SHORT)i;
}

LONG IsNeg(LONG x)
{
    return(x & 0x80000000);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\gsm610\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code to support easy-to-use debugging support.
//      All code compiles to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifndef WIN32
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
#if DBG
        DebugBreak();
#endif
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()


//--------------------------------------------------------------------------;
//  
//  void _Assert
//  
//  Description:
//      This routine is called if the ASSERT macro (defined in debug.h)
//      tests and expression that evaluates to FALSE.  This routine 
//      displays an "assertion failed" message box allowing the user to
//      abort the program, enter the debugger (the "retry" button), or
//      ignore the assertion and continue executing.  The message box
//      displays the file name and line number of the _Assert() call.
//  
//  Arguments:
//      char *  szFile: Filename where assertion occurred.
//      int     iLine:  Line number of assertion.
//  
//--------------------------------------------------------------------------;

void WINAPI _Assert
(
    char *  szFile,
    int     iLine
)
{
    static CHAR     ach[300];       // debug output (avoid stack overflow)
    int	            id;


    wsprintfA(ach, "Assertion failed in file %s, line %d.  [Press RETRY to debug.]", (LPSTR)szFile, iLine);

    id = MessageBoxA(NULL, ach, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE );

	switch (id)
	{

	case IDABORT:               // Kill the application.
        FatalAppExit(0, TEXT("Good Bye"));
		break;

	case IDRETRY:               // Break into the debugger.
#if DBG
		DebugBreak();
#endif
		break;

	case IDIGNORE:              // Ignore assertion, continue executing.
		break;
	}
} // _Assert

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\gsm610\gsm610.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  gsm610.h
//
//  Description:
//      This file contains prototypes for the filtering routines, and
//      some parameters used by the algorithm.
//
//
//==========================================================================;

#ifndef _INC_GSM610
#define _INC_GSM610                 // #defined if gsm610.h has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern 
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

//
// The following constants are defined in order to make portions
// of the program more readable.  In general, these constants
// cannot be changed without requiring changes in related program code.
//
#define GSM610_MAX_CHANNELS             1
#define GSM610_BITS_PER_SAMPLE          0
#define GSM610_WFX_EXTRA_BYTES          (2)
 
#define GSM610_SAMPLESPERFRAME          160
#define GSM610_NUMSUBFRAMES             4
#define GSM610_SAMPLESPERSUBFRAME       40
#define GSM610_FRAMESPERMONOBLOCK       2
#define GSM610_BITSPERFRAME             260
#define GSM610_BYTESPERMONOBLOCK        (GSM610_FRAMESPERMONOBLOCK * GSM610_BITSPERFRAME / 8)
#define GSM610_SAMPLESPERMONOBLOCK      (GSM610_FRAMESPERMONOBLOCK * GSM610_SAMPLESPERFRAME)

//
//  these assume mono
//
#define GSM610_BLOCKALIGNMENT(pwf)    (GSM610_BYTESPERMONOBLOCK)
#define GSM610_AVGBYTESPERSEC(pwf)    (((LPGSM610WAVEFORMAT)pwf)->wfx.nSamplesPerSec * GSM610_BYTESPERMONOBLOCK / GSM610_SAMPLESPERMONOBLOCK)
#define GSM610_SAMPLESPERBLOCK(pwf)   (GSM610_SAMPLESPERMONOBLOCK)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

//
//  function prototypes from GSM610.C
//
//
void FNGLOBAL gsm610Reset
(
    PSTREAMINSTANCE         psi
);

LRESULT FNGLOBAL gsm610Decode
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
);
                             
LRESULT FNGLOBAL gsm610Encode
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _INC_GSM610
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\gsm610\init.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  init.c
//
//  Description:
//      This file contains module initialization routines.  Note that there
//      is no module initialization for Win32.
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "codec.h"
#include "debug.h"


#ifndef WIN32

//==========================================================================;
//
//  WIN 16 SPECIFIC SUPPORT
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  int LibMain
//
//  Description:
//      Library initialization code.
//
//  Arguments:
//      HINSTANCE hinst: Our module handle.
//
//      WORD wDataSeg: Specifies the DS value for this DLL.
//
//      WORD cbHeapSize: The heap size from the .def file.
//
//      LPSTR pszCmdLine: The command line.
//
//  Return (int):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    Created. 
//
//--------------------------------------------------------------------------;

int FNGLOBAL LibMain
(
    HINSTANCE               hinst, 
    WORD                    wDataSeg, 
    WORD                    cbHeapSize,
    LPSTR                   pszCmdLine
)
{
    DbgInitialize(TRUE);

    //
    //  if debug level is 5 or greater, then do a DebugBreak() to debug
    //  loading of this driver
    //
    DPF(1, "LibMain(hinst=%.4Xh, wDataSeg=%.4Xh, cbHeapSize=%u, pszCmdLine=%.8lXh)",
        hinst, wDataSeg, cbHeapSize, pszCmdLine);
    DPF(5, "!*** break for debugging ***");

    return (TRUE);
} // LibMain()


//--------------------------------------------------------------------------;
//  
//  int WEP
//  
//  Description:
//  
//  
//  Arguments:
//      WORD wUselessParam:
//  
//  Return (int):
//  
//  History:
//      03/28/93    Created.
//  
//--------------------------------------------------------------------------;

EXTERN_C int FNEXPORT WEP
(
    WORD                    wUselessParam
)
{
    DPF(1, "WEP(wUselessParam=%u)", wUselessParam);

    //
    //  always return 1.
    //
    return (1);
} // WEP()

#endif	// !WIN32


#ifdef WIN32

//==========================================================================;
//
//  WIN 32 SPECIFIC SUPPORT
//
//==========================================================================;

#if (defined(WIN4) && defined(DEBUG))

#if FALSE
//--------------------------------------------------------------------------;
//
//  BOOL Gsm610DllMain
//
//  Description:
//      This is the standard DLL entry point for Win 32.
//
//  Arguments:
//      HINSTANCE hinst: Our instance handle.
//
//      DWORD dwReason: The reason we've been called--process/thread attach
//      and detach.
//
//      LPVOID lpReserved: Reserved. Should be NULL--so ignore it.
//
//  Return (BOOL):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT Gsm610DllMain
(
    HINSTANCE               hinst,
    DWORD                   dwReason,
    LPVOID                  lpReserved
)
{

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
	{
	    char strModuleFilename[80];
	    
	    DbgInitialize(TRUE);

	    GetModuleFileNameA(NULL, (LPSTR) strModuleFilename, 80);
            DPF(1, "Gsm610DllMain: DLL_PROCESS_ATTACH: HINSTANCE=%08lx ModuleFilename=%s", hinst, strModuleFilename);
	    return TRUE;
	}

        case DLL_PROCESS_DETACH:
            DPF(1, "Gsm610DllMain: DLL_PROCESS_DETACH");
	    return TRUE;

	case DLL_THREAD_ATTACH:
	    DPF(1, "Gsm610DllMain: DLL_THREAD_ATTACH");
	    return TRUE;

	case DLL_THREAD_DETACH:
	    DPF(1, "Gsm610DllMain: DLL_THREAD_DETACH");
	    return TRUE;
    }

    return TRUE;
} // Gsm610DllMain()
#endif

#endif	// WIN4 && DEBUG

#endif	// WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\imaadpcm\codec.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.c
//
//  Description:
//      This file contains the DriverProc and other routines which respond
//      to ACM messages.
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <ctype.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "codec.h"
#include "imaadpcm.h"
#include "debug.h"


const UINT gauFormatTagIndexToTag[] =
{
    WAVE_FORMAT_PCM,
    WAVE_FORMAT_IMA_ADPCM
};

#define ACM_DRIVER_MAX_FORMAT_TAGS      SIZEOF_ARRAY(gauFormatTagIndexToTag)
#define ACM_DRIVER_MAX_FILTER_TAGS      0


//
//  array of sample rates supported
//
//
const UINT gauFormatIndexToSampleRate[] =
{
    8000,
    11025,
    22050,
    44100
};

#ifdef IMAADPCM_USECONFIG
//
//  Required by config.c as well as codec.c.
//
const UINT ACM_DRIVER_MAX_SAMPLE_RATES = SIZEOF_ARRAY(gauFormatIndexToSampleRate);
const UINT ACM_DRIVER_MAX_CHANNELS =    IMAADPCM_MAX_CHANNELS;
#else
#define ACM_DRIVER_MAX_SAMPLE_RATES     SIZEOF_ARRAY(gauFormatIndexToSampleRate)
#define ACM_DRIVER_MAX_CHANNELS         IMAADPCM_MAX_CHANNELS
#endif


//
//  array of bits per sample supported
//
//
const UINT gauFormatIndexToBitsPerSample[] =
{
    8,
    16
};

#define ACM_DRIVER_MAX_BITSPERSAMPLE_PCM    SIZEOF_ARRAY(gauFormatIndexToBitsPerSample)
#define ACM_DRIVER_MAX_BITSPERSAMPLE_ADPCM  1



//
//  number of formats we enumerate per channel is number of sample rates
//  times number of channels times number of types (bits per sample).
//
#define ACM_DRIVER_MAX_FORMATS_PCM      (ACM_DRIVER_MAX_SAMPLE_RATES *  \
                                         ACM_DRIVER_MAX_CHANNELS *      \
                                         ACM_DRIVER_MAX_BITSPERSAMPLE_PCM)

#define ACM_DRIVER_MAX_FORMATS_ADPCM    (ACM_DRIVER_MAX_SAMPLE_RATES *  \
                                         ACM_DRIVER_MAX_CHANNELS *      \
                                         ACM_DRIVER_MAX_BITSPERSAMPLE_ADPCM)



#ifdef IMAADPCM_USECONFIG
//
//  This array describes the configuration settings for this codec.
//
//  Each line in the realtime encode/decode rate listbox must have one of
//  these structures to describe it.  The type of line is defined in
//  nFormatType, which can have one of the following values:
//
//      CONFIG_RLF_NONUMBER     - the string in idsFormat is displayed as is.
//      CONFIG_RLF_MONOONLY     - dwMonoRate is written into idsFormat, then
//                                  displayed as a mono rate.
//      CONFIG_RLF_STEREOONLY   - dwMonoRate is written into idsFormat, then
//                                  displayed as a stereo rate.
//      CONFIG_RLF_MONOSTEREO   - dwMonoRate followed by nRate/2 are written
//                                  into idsFormat, then displayed as a pair
//                                  of mono and stereo rates.
//
//  The index to the gaRateListFormat array corresponds to the value which
//  is stored as configuration information in the registry or .ini file.
//  To find out if a certain conversion can be performed in real time,
//  check that:
//
//    SamplingRate <= gaRateListFormat[ConfigSetting].dwMonoRate / nChannels
//
//  Note:  The gaRateListFormat array must change when
//          gauFormatIndexToSampleRate changes.
//

const RATELISTFORMAT gaRateListFormat[] =
{
    { CONFIG_RLF_NONUMBER,      IDS_CONFIG_NORATES,     0 },
    { CONFIG_RLF_MONOONLY,      IDS_CONFIG_MONOONLY,    8000 },  // gauFormatIndexToSampleRate[0]
    { CONFIG_RLF_MONOONLY,      IDS_CONFIG_MONOONLY,    11025 }, // gauFormatIndexToSampleRate[1]
    { CONFIG_RLF_STEREOONLY,    IDS_CONFIG_STEREOONLY,  16000 }, // 2 * gauFormatIndexToSampleRate[0]
    { CONFIG_RLF_MONOSTEREO,    IDS_CONFIG_MONOSTEREO,  22050 }, // gauFormatIndexToSampleRate[2]
    { CONFIG_RLF_MONOSTEREO,    IDS_CONFIG_MONOSTEREO,  44100 }, // gauFormatIndexToSampleRate[3]
    { CONFIG_RLF_NONUMBER,      IDS_CONFIG_ALLRATES,    88200 }  // 2 * gauFormatIndexToSampleRate[3]
};

const UINT IMAADPCM_CONFIG_NUMSETTINGS = SIZEOF_ARRAY( gaRateListFormat );

#endif // IMAADPCM_USECONFIG


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  int LoadStringCodec
//
//  Description:
//      This function should be used by all codecs to load resource strings
//      which will be passed back to the ACM.  It works correctly for all
//      platforms, as follows:
//
//          Win16:  Compiled to LoadString to load ANSI strings.
//
//          Win32:  The 32-bit ACM always expects Unicode strings.  Therefore,
//                  when UNICODE is defined, this function is compiled to
//                  LoadStringW to load a Unicode string.  When UNICODE is
//                  not defined, this function loads an ANSI string, converts
//                  it to Unicode, and returns the Unicode string to the
//                  codec.
//
//      Note that you may use LoadString for other strings (strings which
//      will not be passed back to the ACM), because these strings will
//      always be consistent with the definition of UNICODE.
//
//  Arguments:
//      Same as LoadString, except that it expects an LPSTR for Win16 and a
//      LPWSTR for Win32.
//
//  Return (int):
//      Same as LoadString.
//
//--------------------------------------------------------------------------;

#ifndef WIN32
#define LoadStringCodec LoadString
#else

#ifdef UNICODE
#define LoadStringCodec LoadStringW
#else

int FNGLOBAL LoadStringCodec
(
 HINSTANCE  hinst,
 UINT	    uID,
 LPWSTR	    lpwstr,
 int	    cch)
{
    LPSTR   lpstr;
    int	    iReturn;

    lpstr = (LPSTR)GlobalAlloc(GPTR, cch);
    if (NULL == lpstr)
    {
	return 0;
    }

    iReturn = LoadStringA(hinst, uID, lpstr, cch);
    if (0 == iReturn)
    {
	if (0 != cch)
	{
	    lpwstr[0] = '\0';
	}
    }
    else
    {
    	MultiByteToWideChar( GetACP(), 0, lpstr, cch, lpwstr, cch );
    }

    GlobalFree((HGLOBAL)lpstr);

    return iReturn;
}

#endif  // UNICODE
#endif  // WIN32


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  WORD imaadpcmBlockAlign
//
//  Description:
//      This function computes the standard block alignment that should
//      be used given the WAVEFORMATEX structure.
//
//      NOTE! It is _assumed_ that the format is a valid IMA-ADPCM format
//      and that the following fields in the format structure are valid:
//
//          nChannels
//          nSamplesPerSec
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header.
//
//  Return (UINT):
//      The return value is the block alignment that should be placed in
//      the pwfx->nBlockAlign field.
//
//--------------------------------------------------------------------------;

WORD FNLOCAL imaadpcmBlockAlign
(
    LPWAVEFORMATEX          pwfx
)
{
    UINT                uBlockAlign;
    UINT                uChannelShift;

    //
    //  The data must be an integral number of DWORDs for mono, an even
    //  number of DWORDs for stereo.
    //
    uChannelShift  = pwfx->nChannels >> 1;
    uBlockAlign    = 256 << uChannelShift;

    //
    //  choose a block alignment that makes sense for the sample rate
    //  that the original PCM data is. basically, this needs to be
    //  some reasonable number to allow efficient streaming, etc.
    //
    //  don't let block alignment get too small...
    //
    if (pwfx->nSamplesPerSec > 11025)
    {
        uBlockAlign *= (UINT)(pwfx->nSamplesPerSec / 11000);
    }

    //
    //  Just make sure that the alignment is valid.
    //
    ASSERT( 0 == uBlockAlign % (sizeof(DWORD)*pwfx->nChannels) );

    return (WORD)(uBlockAlign);
} // imaadpcmBlockAlign()


//--------------------------------------------------------------------------;
//
//  WORD imaadpcmSamplesPerBlock
//
//  Description:
//      This function computes the Samples Per Block that should be used
//      given the WAVEFORMATEX structure.
//
//      NOTE! It is _assumed_ that the format is a valid IMA-ADPCM format
//      and that the following fields in the format structure are valid:
//
//          nChannels       = must be 1 or 2!
//          nSamplesPerSec
//          nBlockAlign
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header.
//
//  Return (DWORD):
//      The return value is the average bytes per second that should be
//      placed in the pwfx->nAvgBytesPerSec field.
//
//--------------------------------------------------------------------------;

WORD FNLOCAL imaadpcmSamplesPerBlock
(
    LPWAVEFORMATEX          pwfx
)
{
    UINT                uSamplesPerBlock;
    UINT                uChannelShift;
    UINT                uHeaderBytes;
    UINT                uBitsPerSample;

    //
    //
    //
    uChannelShift  = pwfx->nChannels >> 1;
    uHeaderBytes   = 4 << uChannelShift;
    uBitsPerSample = IMAADPCM_BITS_PER_SAMPLE << uChannelShift;

    //
    //  compute the 'samples per block' that will be in the encoded
    //  ADPCM data blocks. this is determined by subtracting out the
    //  'other info' contained in each block--a block is composed of
    //  a header followed by the encoded data.
    //
    //  the block header is composed of the following data:
    //      2 bytes (16 bit) sample per channel
    //      1 byte for step table index per channel
    //      1 byte padding per channel (dword align)
    //
    //  this gives us (4 * uChannels) bytes of header information that
    //  contains our first full sample (so we add one below).
    //
    uSamplesPerBlock  = (pwfx->nBlockAlign - uHeaderBytes) * 8;
    uSamplesPerBlock /= uBitsPerSample;
    uSamplesPerBlock += 1;

    return (WORD)(uSamplesPerBlock);
} // imaadpcmSamplesPerBlock()


//--------------------------------------------------------------------------;
//
//  UINT imaadpcmAvgBytesPerSec
//
//  Description:
//      This function computes the Average Bytes Per Second that should
//      be used given the WAVEFORMATEX structure.
//
//      NOTE! It is _assumed_ that the format is a valid IMA-ADPCM format
//      and that the following fields in the format structure are valid:
//
//          nChannels       = must be 1 or 2!
//          nSamplesPerSec
//          nBlockAlign
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header.
//
//  Return (DWORD):
//      The return value is the average bytes per second that should be
//      placed in the pwfx->nAvgBytesPerSec field.
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL imaadpcmAvgBytesPerSec
(
    LPWAVEFORMATEX          pwfx
)
{
    DWORD               dwAvgBytesPerSec;
    UINT                uSamplesPerBlock;

    //
    //
    //
    uSamplesPerBlock = imaadpcmSamplesPerBlock(pwfx);


    //
    //  compute bytes per second including header bytes
    //
    dwAvgBytesPerSec = (pwfx->nSamplesPerSec * pwfx->nBlockAlign) /
                            uSamplesPerBlock;

    return (dwAvgBytesPerSec);
} // imaadpcmAvgBytesPerSec()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL pcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid PCM
//      header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL pcmIsValidFormat
(
    LPWAVEFORMATEX          pwfx
)
{
    if (NULL == pwfx)
        return (FALSE);

    if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
        return (FALSE);

    //
    //  verify nChannels member is within the allowed range
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > ACM_DRIVER_MAX_CHANNELS))
        return (FALSE);

    //
    //  only allow the bits per sample that we can encode and decode with
    //
    if ((16 != pwfx->wBitsPerSample) && (8 != pwfx->wBitsPerSample))
        return (FALSE);

    //
    //  now verify that the block alignment is correct..
    //
    if (PCM_BLOCKALIGNMENT(pwfx) != pwfx->nBlockAlign)
        return (FALSE);

    //
    //  finally, verify that avg bytes per second is correct
    //
    if (PCM_AVGBYTESPERSEC(pwfx) != pwfx->nAvgBytesPerSec)
        return (FALSE);

    return (TRUE);
} // pcmIsValidFormat()


//--------------------------------------------------------------------------;
//
//  BOOL imaadpcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid
//      IMA ADPCM header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL imaadpcmIsValidFormat
(
    LPWAVEFORMATEX          pwfx
)
{
    LPIMAADPCMWAVEFORMAT    pwfadpcm;

    if (NULL == pwfx)
        return (FALSE);

    if (WAVE_FORMAT_IMA_ADPCM != pwfx->wFormatTag)
        return (FALSE);

    //
    //  check wBitsPerSample
    //
    if (IMAADPCM_BITS_PER_SAMPLE != pwfx->wBitsPerSample)
        return (FALSE);

    //
    //  check channels
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > IMAADPCM_MAX_CHANNELS))
        return (FALSE);

    //
    //  Check block alignment - must be an integral number of DWORDs for
    //  mono, or an even number of DWORDs for stereo.
    //
    if( 0 != pwfx->nBlockAlign % (sizeof(DWORD)*pwfx->nChannels) )
        return FALSE;

    //
    //  cbSize must be 2 for IMA's ADPCM
    //
    if (IMAADPCM_WFX_EXTRA_BYTES != pwfx->cbSize)
        return (FALSE);

    //
    //  wSamplesPerBlock must be equal to 4n+1, where n is at least 1.
    //
    pwfadpcm = (LPIMAADPCMWAVEFORMAT)pwfx;

    if( ( pwfadpcm->wSamplesPerBlock < 5 )  ||
        ( pwfadpcm->wSamplesPerBlock%4 != 1 )  )
        return FALSE;

    //
    //  Verifying nBlockAlign and wSamplesPerBlock are consistent.
    //
    if ( (pwfadpcm->wSamplesPerBlock != imaadpcmSamplesPerBlock(pwfx)) )
        return FALSE;

    return (TRUE);
} // imaadpcmIsValidFormat()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverOpen
//
//  Description:
//      This function is used to handle the DRV_OPEN message for the ACM
//      driver. The driver is 'opened' for many reasons with the most common
//      being in preperation for conversion work. It is very important that
//      the driver be able to correctly handle multiple open driver
//      instances.
//
//      Read the comments for this function carefully!
//
//      Note that multiple _streams_ can (and will) be opened on a single
//      open _driver instance_. Do not store/create instance data that must
//      be unique for each stream in this function. See the acmdStreamOpen
//      function for information on conversion streams.
//
//  Arguments:
//      HDRVR hdrvr: Driver handle that will be returned to caller of the
//      OpenDriver function. Normally, this will be the ACM--but this is
//      not guaranteed. For example, if an ACM driver is implemented within
//      a waveform driver, then the driver will be opened by both MMSYSTEM
//      and the ACM.
//
//      LPACMDRVOPENDESC paod: Open description defining how the ACM driver
//      is being opened. This argument may be NULL--see the comments below
//      for more information.
//
//  Return (LRESULT):
//      The return value is non-zero if the open is successful. A zero
//      return signifies that the driver cannot be opened.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverOpen
(
    HDRVR                   hdrvr,
    LPACMDRVOPENDESC        paod
)
{
    PDRIVERINSTANCE     pdi;

    //
    //  the [optional] open description that is passed to this driver can
    //  be from multiple 'managers.' for example, AVI looks for installable
    //  drivers that are tagged with 'vidc' and 'vcap'. we need to verify
    //  that we are being opened as an Audio Compression Manager driver.
    //
    //  if paod is NULL, then the driver is being opened for some purpose
    //  other than converting (that is, there will be no stream open
    //  requests for this instance of being opened). the most common case
    //  of this is the Control Panel's Drivers option checking for config
    //  support (DRV_[QUERY]CONFIGURE).
    //
    //  we want to succeed this open, but be able to know that this
    //  open instance is bogus for creating streams. for this purpose we
    //  leave most of the members of our instance structure that we
    //  allocate below as zero...
    //
    if (NULL != paod)
    {
        //
        //  refuse to open if we are not being opened as an ACM driver.
        //  note that we do NOT modify the value of paod->dwError in this
        //  case.
        //
        if (ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != paod->fccType)
        {
            return (0L);
        }
    }


    //
    //  we are being opened as an installable driver--we can allocate some
    //  instance data to be returned in dwId argument of the DriverProc;
    //  or simply return non-zero to succeed the open.
    //
    //  this driver allocates a small instance structure. note that we
    //  rely on allocating the memory as zero-initialized!
    //
    pdi = (PDRIVERINSTANCE)LocalAlloc(LPTR, sizeof(*pdi));
    if (NULL == pdi)
    {
        //
        //  if this open attempt was as an ACM driver, then return the
        //  reason we are failing in the open description structure..
        //
        if (NULL != paod)
        {
            paod->dwError = MMSYSERR_NOMEM;
        }

        //
        //  fail to open
        //
        return (0L);
    }


    //
    //  fill in our instance structure... note that this instance data
    //  can be anything that the ACM driver wishes to maintain the
    //  open driver instance. this data should not contain any information
    //  that must be maintained per open stream since multiple streams
    //  can be opened on a single driver instance.
    //
    //  also note that we do _not_ check the version of the ACM opening
    //  us (paod->dwVersion) to see if it is at least new enough to work
    //  with this driver (for example, if this driver required Version 3.0
    //  of the ACM and a Version 2.0 installation tried to open us). the
    //  reason we do not fail is to allow the ACM to get the driver details
    //  which contains the version of the ACM that is _required_ by this
    //  driver. the ACM will examine that value (in padd->vdwACM) and
    //  do the right thing for this driver... like not load it and inform
    //  the user of the problem.
    //
    pdi->hdrvr          = hdrvr;
    pdi->hinst          = GetDriverModuleHandle(hdrvr);  // Module handle.

    if (NULL != paod)
    {
        pdi->fnDriverProc = NULL;
        pdi->fccType      = paod->fccType;
        pdi->vdwACM       = paod->dwVersion;
        pdi->fdwOpen      = paod->dwFlags;

        paod->dwError     = MMSYSERR_NOERROR;
    }


#ifdef IMAADPCM_USECONFIG
    //
    // Get config info for this driver.  If we're not passed an
    // an ACMDRVOPENDESC structure then we'll assume we are being
    // opened for configuration and will put off getting the config
    // info until we receive the DRV_CONFIGURE message.  Otherwise we
    // get the config info now using the alias passed through the
    // ACMDRVOPENDESC structure.
    //
    pdi->hkey = NULL;           // This is important!

    if (NULL != paod)
    {
#if defined(WIN32) && !defined(UNICODE)
        //
        //  We must translate the UNICODE alias name to an ANSI version
        //  that we can use.
        //
    	LPSTR	lpstr;
        int     iLen;

        //
        //  Calculate required length without calling UNICODE APIs or CRT.
        //
        iLen  = WideCharToMultiByte( GetACP(), 0, paod->pszAliasName,-1,
                                                    NULL, 0, NULL, NULL );

    	lpstr = (LPSTR)GlobalAllocPtr( GPTR, iLen );
	    if (NULL != lpstr)
	    {
            WideCharToMultiByte( GetACP(), 0, paod->pszAliasName, iLen,
                                    lpstr, iLen, NULL, NULL );
	    }
	    acmdDriverConfigInit(pdi, lpstr);	// Note: OK to pass lpstr==NULL
	    if (NULL != lpstr)
	    {
	        GlobalFreePtr( lpstr );
	    }
#else
    	acmdDriverConfigInit(pdi, paod->pszAliasName);
#endif // WIN32 && !UNICODE
    }
#else
    //
    //  Actually, fdwConfig is not used - there is no configuration data.
    //
    pdi->fdwConfig    = 0L;
#endif // IMAADPCM_USECONFIG

    //
    //  non-zero return is success for DRV_OPEN
    //
    return ((LRESULT)pdi);
} // acmdDriverOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverClose
//
//  Description:
//      This function handles the DRV_CLOSE message for the ACM driver. The
//      driver receives a DRV_CLOSE message for each succeeded DRV_OPEN
//      message (see acmdDriverOpen). The driver will only receive a close
//      message for _successful_ opens.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//  Return (LRESULT):
//      The return value is non-zero if the open instance can be closed.
//      A zero return signifies that the ACM driver instance could not be
//      closed.
//
//      NOTE! It is _strongly_ recommended that the driver never fail to
//      close. Note that the ACM will never allow a driver instance to
//      be closed if there are open streams. An ACM driver does not need
//      to check for this case.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverClose
(
    PDRIVERINSTANCE         pdi
)
{
#ifdef IMAADPCM_USECONFIG
    //
    //  Release the registry key, if we allocated one.
    //
    if( NULL != pdi->hkey )
    {
        (void)RegCloseKey( pdi->hkey );
    }
#endif

    //
    //  check to see if we allocated instance data. if we did not, then
    //  immediately succeed.
    //
    if (NULL != pdi)
    {
        //
        //  close down the driver instance. this driver simply needs
        //  to free the instance data structure... note that if this
        //  'free' fails, then this ACM driver probably trashed its
        //  heap; assume we didn't do that.
        //
        LocalFree((HLOCAL)pdi);
    }


    //
    //  non-zero return is success for DRV_CLOSE
    //
    return (1L);
} // acmdDriverClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverConfigure
//
//  Description:
//      This function is called to handle the DRV_[QUERY]CONFIGURE messages.
//      These messages are for 'configuration' support of the driver.
//      Normally this will be for 'hardware'--that is, a dialog should be
//      displayed to configure ports, IRQ's, memory mappings, etc if it
//      needs to. However, a software only ACM driver may also require
//      configuration for 'what is real time' or other quality vs time
//      issues.
//
//      The most common way that these messages are generated under Win 3.1
//      and NT Product 1 is from the Control Panel's Drivers option. Other
//      sources may generate these messages in future versions of Windows.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for configuration support.
//
//      LPDRVCONFIGINFO pdci: Pointer to optional DRVCONFIGINFO structure.
//      If this argument is NULL, then the ACM driver should invent its own
//      storage location.
//
//  Return (LRESULT):
//      If the driver is being 'queried' for configuration support (that is,
//      hwnd == (HWND)-1), then non-zero should be returned specifying
//      the driver does support a configuration dialog--or zero should be
//      returned specifying that no configuration dialog is supported.
//
//      If the driver is being called to display the configuration dialog
//      (that is, hwnd != (HWND)-1), then one of the following values
//      should be returned:
//
//      DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
//      and canceled by the user. this value should also be returned if
//      no configuration information was modified.
//
//      DRVCNF_OK (0x0001): specifies that the dialog was displayed and
//      the user pressed OK.  This value should be returned even if the
//      user didn't change anything - otherwise, the driver may not
//      install properly.
//
//      DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
//      and some configuration information was changed that requires
//      Windows to be restarted before the changes take affect. the driver
//      should remain configured with current values until the driver
//      has been 'rebooted'.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverConfigure
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd,
    LPDRVCONFIGINFO         pdci
)
{
#ifdef IMAADPCM_USECONFIG
    INT_PTR     n;
#endif

    //
    //  first check to see if we are only being queried for configuration
    //  support. if hwnd == (HWND)-1 then we are being queried and should
    //  return zero for 'not supported' and non-zero for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
#ifdef IMAADPCM_USECONFIG
        //
        //  this ACM driver supports a configuration dialog box, so
        //  return non-zero...
        //
        return (1L);
#else
        //
        //  this ACM driver does not support a configuration dialog box, so
        //  return zero...
        //
        return (0L);
#endif
    }


    //
    //  we are being asked to bring up our configuration dialog. if this
    //  driver supports a configuration dialog box, then after the dialog
    //  is dismissed we must return one of the following values:
    //
    //  DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
    //  and canceled by the user. this value should also be returned if
    //  no configuration information was modified.
    //
    //  DRVCNF_OK (0x0001): specifies that the dialog was displayed and
    //  the user pressed OK.  This value should be returned even if the
    //  user didn't change anything - otherwise, the driver may not
    //  install properly.
    //
    //  DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
    //  and some configuration information was changed that requires
    //  Windows to be restarted before the changes take affect. the driver
    //  should remain configured with current values until the driver
    //  has been 'rebooted'.
    //
#ifdef IMAADPCM_USECONFIG
    if (NULL == pdci)
    {
        //
        //  !!!
        //
        DPF(2,"acmdDriverConfigure returning CANCEL due to NULL==pdci.");
        return (DRVCNF_CANCEL);
    }

    pdi->pdci = pdci;

    //
    // We may not have our config info yet if the driver has only been
    // opened specifically for configuration.  So, read our configuration
    // using the alias passed in the DRVCONFIGINFO structure passed
    // through the DRV_CONFIGURE message
    //
#if (defined(WIN32) && !defined(UNICODE))
    {
        //
        //  We must translate the UNICODE alias name to an ANSI version
        //  that we can use.
        //
    	LPSTR	lpstr;
        int     iLen;

        //
        //  Calculate required length without calling UNICODE APIs or CRT.
        //
        iLen  = WideCharToMultiByte( GetACP(), 0, pdci->lpszDCIAliasName, -1,
                                                    NULL, 0, NULL, NULL );

    	lpstr = (LPSTR)GlobalAllocPtr( GPTR, iLen );
	    if (NULL != lpstr)
	    {
            WideCharToMultiByte( GetACP(), 0, pdci->lpszDCIAliasName, iLen,
                                    lpstr, iLen, NULL, NULL );
	    }
	    acmdDriverConfigInit(pdi, lpstr);	// Note: OK to pass lpstr==NULL
	    if (NULL != lpstr)
	    {
	        GlobalFreePtr( lpstr );
	    }
    }
#else
    acmdDriverConfigInit(pdi, pdci->lpszDCIAliasName);
#endif // WIN32 && !UNICODE

    n = DialogBoxParam(pdi->hinst,
                       IDD_CONFIG,
                       hwnd,
                       acmdDlgProcConfigure,
                       (LPARAM)pdi);

    pdi->pdci = NULL;

    return ((LRESULT)n);
#else
    //
    //  return DRVCNF_CANCEL--this ACM driver does not support configuration
    //
    return (DRVCNF_CANCEL);
#endif // IMAADPCM_USECONFIG

} // acmdDriverConfigure()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverDetails
//
//  Description:
//      This function handles the ACMDM_DRIVER_DETAILS message. The ACM
//      driver is responsible for filling in the ACMDRIVERDETAILS structure
//      with various information.
//
//      NOTE! It is *VERY* important that you fill in your ACMDRIVERDETAILS
//      structure correctly. The ACM and applications must be able to
//      rely on this information.
//
//      WARNING! The _reserved_ bits of any fields of the ACMDRIVERDETAILS
//      structure are _exactly that_: RESERVED. Do NOT use any extra
//      flag bits, etc. for custom information. The proper way to add
//      custom capabilities to your ACM driver is this:
//
//      o   define a new message in the ACMDM_USER range.
//
//      o   an application that wishes to use one of these extra features
//          should then:
//
//          o   open the driver with acmDriverOpen.
//
//          o   check for the proper wMid and wPid using acmDriverDetails.
//
//          o   send the 'user defined' message with acmDriverMessage
//              to retrieve additional information, etc.
//
//          o   close the driver with acmDriverClose.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRIVERDETAILS padd: Pointer to ACMDRIVERDETAILS structure to
//      fill in for the caller. This structure may be larger or smaller than
//      the current definition of ACMDRIVERDETAILS--cbStruct specifies the
//      valid size.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) for success. Non-zero
//      signifies that the driver details could not be retrieved.
//
//      NOTE THAT THIS FUNCTION SHOULD NEVER FAIL! There are two possible
//      error conditions:
//
//      o   if padd is NULL or an invalid pointer.
//
//      o   if cbStruct is less than four; in this case, there is not enough
//          room to return the number of bytes filled in.
//
//      Because these two error conditions are easily defined, the ACM
//      will catch these errors. The driver does NOT need to check for these
//      conditions.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMDRIVERDETAILS      padd
)
{
    ACMDRIVERDETAILS    add;
    DWORD               cbStruct;

    //
    //  it is easiest to fill in a temporary structure with valid info
    //  and then copy the requested number of bytes to the destination
    //  buffer.
    //
    cbStruct            = min(padd->cbStruct, sizeof(ACMDRIVERDETAILS));
    add.cbStruct        = cbStruct;


    //
    //  for the current implementation of an ACM driver, the fccType and
    //  fccComp members *MUST* always be ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC
    //  ('audc') and ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (0) respectively.
    //
    add.fccType         = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    add.fccComp         = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;


    //
    //  the manufacturer id (wMid) and product id (wPid) must be filled
    //  in with your company's _registered_ identifier's. for more
    //  information on these identifier's and how to get them registered
    //  contact Microsoft and get the Multimedia Developer Registration Kit:
    //
    //      Microsoft Corporation
    //      Multimedia Technology Group
    //      One Microsoft Way
    //      Redmond, WA 98052-6399
    //
    //      Developer Services Phone: (800) 227-4679 x11771
    //
    //  note that during the development phase or your ACM driver, you may
    //  use the reserved value of '0' for both wMid and wPid. however it
    //  is not acceptable to ship a driver with these values.
    //
    add.wMid            = MM_MICROSOFT;
    add.wPid            = MM_MSFT_ACM_IMAADPCM;


    //
    //  the vdwACM and vdwDriver members contain version information for
    //  the driver.
    //
    //  vdwACM: must contain the version of the *ACM* that the driver was
    //  _designed_ for. this is the _minimum_ version number of the ACM
    //  that the driver will work with. this value must be >= V2.00.000.
    //
    //  vdwDriver: the version of this ACM driver.
    //
    //  ACM driver versions are 32 bit numbers broken into three parts as
    //  follows (note these parts are displayed as decimal values):
    //
    //      bits 24 - 31:   8 bit _major_ version number
    //      bits 16 - 23:   8 bit _minor_ version number
    //      bits  0 - 15:   16 bit build number
    //
    add.vdwACM          = VERSION_MSACM;
    add.vdwDriver       = VERSION_ACM_DRIVER;


    //
    //  the following flags are used to specify the type of conversion(s)
    //  that the ACM driver supports. note that a driver may support one or
    //  more of these flags in any combination.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver
    //  supports conversions from one format tag to another format tag. for
    //  example, if a converter compresses or decompresses WAVE_FORMAT_PCM
    //  and WAVE_FORMAT_IMA_ADPCM, then this bit should be set. this is
    //  true even if the data is not actually changed in size--for example
    //  a conversion from u-Law to A-Law will still set this bit because
    //  the format tags differ.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the
    //  driver supports conversions on the same format tag. as an example,
    //  the PCM converter that is built into the ACM sets this bit (and only
    //  this bit) because it converts only between PCM formats (bits, sample
    //  rate).
    //
    //  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver
    //  supports transformations on a single format tag but does change
    //  the base characteristics of the format (bit depth, sample rate, etc
    //  will remain the same). for example, a driver that changed the
    //  'volume' of PCM data or applied a low pass filter would set this bit.
    //
    add.fdwSupport      = ACMDRIVERDETAILS_SUPPORTF_CODEC;


    //
    //  the number of individual format tags this ACM driver supports. for
    //  example, if a driver uses the WAVE_FORMAT_IMA_ADPCM and
    //  WAVE_FORMAT_PCM format tags, then this value would be two. if the
    //  driver only supports filtering on WAVE_FORMAT_PCM, then this value
    //  would be one. if this driver supported WAVE_FORMAT_ALAW,
    //  WAVE_FORMAT_MULAW and WAVE_FORMAT_PCM, then this value would be
    //  three. etc, etc.
    //
    add.cFormatTags     = ACM_DRIVER_MAX_FORMAT_TAGS;

    //
    //  the number of individual filter tags this ACM driver supports. if
    //  a driver supports no filters (ACMDRIVERDETAILS_SUPPORTF_FILTER is
    //  NOT set in the fdwSupport member), then this value must be zero.
    //
    add.cFilterTags     = ACM_DRIVER_MAX_FILTER_TAGS;


    //
    //  the remaining members in the ACMDRIVERDETAILS structure are sometimes
    //  not needed. because of this we make a quick check to see if we
    //  should go through the effort of filling in these members.
    //
    if (FIELD_OFFSET(ACMDRIVERDETAILS, hicon) < cbStruct)
    {
        //
        //  fill in the hicon member will a handle to a custom icon for
        //  the ACM driver. this allows the driver to be represented by
        //  an application graphically (usually this will be a company
        //  logo or something). if a driver does not wish to have a custom
        //  icon displayed, then simply set this member to NULL and a
        //  generic icon will be displayed instead.
        //
        //  See the MSFILTER sample for a codec which contains a custom icon.
        //
        add.hicon = NULL;

        //
        //  the short name and long name are used to represent the driver
        //  in a unique description. the short name is intended for small
        //  display areas (for example, in a menu or combo box). the long
        //  name is intended for more descriptive displays (for example,
        //  in an 'about box').
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.
        //
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_SHORTNAME, add.szShortName, SIZEOFACMSTR(add.szShortName));
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LONGNAME,  add.szLongName,  SIZEOFACMSTR(add.szLongName));

        //
        //  the last three members are intended for 'about box' information.
        //  these members are optional and may be zero length strings if
        //  the driver wishes.
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.
        //
        if (FIELD_OFFSET(ACMDRIVERDETAILS, szCopyright) < cbStruct)
        {
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_COPYRIGHT, add.szCopyright, SIZEOFACMSTR(add.szCopyright));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LICENSING, add.szLicensing, SIZEOFACMSTR(add.szLicensing));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_FEATURES,  add.szFeatures,  SIZEOFACMSTR(add.szFeatures));
        }
    }


    //
    //  now copy the correct number of bytes to the caller's buffer
    //
    _fmemcpy(padd, &add, (UINT)add.cbStruct);


    //
    //  success!
    //
    return (MMSYSERR_NOERROR);
} // acmdDriverDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverAbout
//
//  Description:
//      This function is called to handle the ACMDM_DRIVER_ABOUT message.
//      An ACM driver has the option of displaying its own 'about box' or
//      letting the ACM (or calling application) display one for it. This
//      message is normally sent by the Control Panel's Sound Mapper
//      option.
//
//      It is recommended that an ACM driver allow a default about box
//      be displayed for it--there should be no reason to bloat the size
//      of a driver to simply display copyright, etc information when that
//      information is contained in the ACMDRIVERDETAILS structure.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for about box support.
//
//  Return (LRESULT):
//      The return value is MMSYSERR_NOTSUPPORTED if the ACM driver does
//      not support a custom dialog box. In this case, the ACM or calling
//      application will display a generic about box using the information
//      contained in the ACMDRIVERDETAILS structure returned by the
//      ACMDM_DRIVER_DETAILS message.
//
//      If the driver chooses to display its own dialog box, then after
//      the dialog is dismissed by the user, MMSYSERR_NOERROR should be
//      returned.
//
//      If the hwnd argument is equal to (HWND)-1, then no dialog should
//      be displayed (the driver is only being queried for support). The
//      driver must still return MMSYSERR_NOERROR (supported) or
//      MMSYSERR_NOTSUPPORTED (no custom about box supported).
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverAbout
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd
)
{
    //
    //  first check to see if we are only being queried for custom about
    //  box support. if hwnd == (HWND)-1 then we are being queried and
    //  should return MMSYSERR_NOTSUPPORTED for 'not supported' and
    //  MMSYSERR_NOERROR for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver does NOT support a custom about box, so
        //  return MMSYSERR_NOTSUPPORTED...
        //
        return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  this driver does not support a custom dialog, so tell the ACM or
    //  calling application to display one for us. note that this is the
    //  _recommended_ method for consistency and simplicity of ACM drivers.
    //  why write code when you don't have to?
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdDriverAbout()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatSuggest
//
//  Description:
//      This function handles the ACMDM_FORMAT_SUGGEST message. The purpose
//      of this function is to provide a way for the ACM, a wave mapper or
//      an application to quickly get a destination format that this driver
//      can convert the source format to. The 'suggested' format should
//      be as close to a common format as possible. This message is normally
//      sent in response to an acmFormatSuggest function call.
//
//      Another way to think about this message is: what format would this
//      driver like to convert the source format to?
//
//      The caller may place restrictions on the destination format that
//      should be suggested. The padfs->fdwSuggest member contains the
//      restriction bits passed by the caller--see the description for
//      the return value for more information.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVFORMATSUGGEST padfs: Pointer to an ACMDRVFORMATSUGGEST
//      structure that describes the source and destination (possibly with
//      restrictions) for a conversion.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if one or more of
//      the destination restriction bits is not supported. It is strongly
//      recommended that the driver support at least the following suggestion
//      restriction bits:
//
//      ACM_FORMATSUGGESTF_WFORMATTAG: The destination format tag must be
//      the same as the wFormatTag member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NCHANNELS: The destination channel count must be
//      the same as the nChannels member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NSAMPLESPERSEC: The destination samples per
//      second must be the same as the nSamplesPerSec member in the
//      destination format header.
//
//      ACM_FORMATSUGGESTF_WBITSPERSAMPLE: The destination bits per sample
//      must be the same as the wBitsPerSample member in the destination
//      format header.
//
//      If no destintation format can be suggested, then the driver should
//      return ACMERR_NOTPOSSIBLE.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatSuggest
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVFORMATSUGGEST   padfs
)
{
    #define ACMD_FORMAT_SUGGEST_SUPPORT (ACM_FORMATSUGGESTF_WFORMATTAG |    \
                                         ACM_FORMATSUGGESTF_NCHANNELS |     \
                                         ACM_FORMATSUGGESTF_NSAMPLESPERSEC |\
                                         ACM_FORMATSUGGESTF_WBITSPERSAMPLE)

    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
    LPIMAADPCMWAVEFORMAT    pwfadpcm;
    DWORD                   fdwSuggest;


    //
    //  grab the suggestion restriction bits and verify that we support
    //  the ones that are specified... an ACM driver must return the
    //  MMSYSERR_NOTSUPPORTED if the suggestion restriction bits specified
    //  are not supported.
    //
    fdwSuggest = (ACM_FORMATSUGGESTF_TYPEMASK & padfs->fdwSuggest);

    if (~ACMD_FORMAT_SUGGEST_SUPPORT & fdwSuggest)
        return (MMSYSERR_NOTSUPPORTED);


    //
    //  get the source and destination formats in more convenient variables
    //
    pwfxSrc = padfs->pwfxSrc;
    pwfxDst = padfs->pwfxDst;


    //
    //
    //
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            //
            //  strictly verify that the source format is acceptable for
            //  this driver
            //
            if (!pcmIsValidFormat(pwfxSrc))
                break;


            //
            //  if the destination format tag is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is only able to encode to IMA ADPCM
            //
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                if (WAVE_FORMAT_IMA_ADPCM != pwfxDst->wFormatTag)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wFormatTag = WAVE_FORMAT_IMA_ADPCM;
            }


            //
            //  if the destination channel count is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is not able to change the number of channels
            //
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if (pwfxSrc->nChannels != pwfxDst->nChannels)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = pwfxSrc->nChannels;
            }


            //
            //  if the destination samples per second is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is not able to change the sample rate
            //
            if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
            {
                if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
            }


            //
            //  if the destination bits per sample is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is only able to encode to 4 bit
            //
            if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
            {
                if (IMAADPCM_BITS_PER_SAMPLE != pwfxDst->wBitsPerSample)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wBitsPerSample = IMAADPCM_BITS_PER_SAMPLE;
            }


            //
            //  at this point, we have filled in all fields except the
            //  following for our 'suggested' destination format:
            //
            //      nAvgBytesPerSec
            //      nBlockAlign
            //      cbSize
            //
            //      wSamplesPerBlock    ->  IMA ADPCM extended information
            //
            pwfxDst->nBlockAlign     = imaadpcmBlockAlign(pwfxDst);
            pwfxDst->nAvgBytesPerSec = imaadpcmAvgBytesPerSec(pwfxDst);
            pwfxDst->cbSize          = IMAADPCM_WFX_EXTRA_BYTES;

            pwfadpcm = (LPIMAADPCMWAVEFORMAT)pwfxDst;

            pwfadpcm->wSamplesPerBlock = imaadpcmSamplesPerBlock(pwfxDst);

            return (MMSYSERR_NOERROR);


        case WAVE_FORMAT_IMA_ADPCM:
            //
            //  strictly verify that the source format is acceptable for
            //  this driver
            //
            if (!imaadpcmIsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);


            //
            //  if the destination format tag is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is only able to decode to PCM
            //
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                if (WAVE_FORMAT_PCM != pwfxDst->wFormatTag)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wFormatTag = WAVE_FORMAT_PCM;
            }


            //
            //  if the destination channel count is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is not able to change the number of channels
            //
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if (pwfxSrc->nChannels != pwfxDst->nChannels)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = pwfxSrc->nChannels;
            }


            //
            //  if the destination samples per second is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is not able to change the sample rate
            //
            if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
            {
                if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
            }


            //
            //  if the destination bits per sample is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is only able to decode to 16 or 8 bit
            //
            if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
            {
                if ((16 != pwfxDst->wBitsPerSample) &&
                    (8  != pwfxDst->wBitsPerSample))
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wBitsPerSample = 16;
            }


            //
            //  at this point, we have filled in all fields except the
            //  following for our 'suggested' destination format:
            //
            //      nAvgBytesPerSec
            //      nBlockAlign
            //      cbSize              !!! not used for PCM !!!
            //
            pwfxDst->nBlockAlign     = PCM_BLOCKALIGNMENT(pwfxDst);
            pwfxDst->nAvgBytesPerSec = pwfxDst->nSamplesPerSec *
                                       pwfxDst->nBlockAlign;

            // pwfxDst->cbSize       = not used;

            return (MMSYSERR_NOERROR);
    }


    //
    //  can't suggest anything because either the source format is foreign
    //  or the destination format has restrictions that this ACM driver
    //  cannot deal with.
    //
    return (ACMERR_NOTPOSSIBLE);
} // acmdFormatSuggest()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatTagDetails
//
//  Description:
//      This function handles the ACMDM_FORMATTAG_DETAILS message. This
//      message is normally sent in response to an acmFormatTagDetails or
//      acmFormatTagEnum function call. The purpose of this function is
//      to get details about a specific format tag supported by this ACM
//      driver.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATTAGDETAILS padft: Pointer to an ACMFORMATTAGDETAILS
//      structure that describes what format tag to retrieve details for.
//
//      DWORD fdwDetails: Flags defining what format tag to retrieve the
//      details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATTAGDETAILSF_INDEX: Indicates that a format tag index
//      was given in the dwFormatTagIndex member of the ACMFORMATTAGDETAILS
//      structure. The format tag and details must be returned in the
//      structure specified by padft. The index ranges from zero to one less
//      than the cFormatTags member returned in the ACMDRIVERDETAILS
//      structure for this driver.
//
//      ACM_FORMATTAGDETAILSF_FORMATTAG: Indicates that a format tag
//      was given in the dwFormatTag member of the ACMFORMATTAGDETAILS
//      structure. The format tag details must be returned in the structure
//      specified by padft.
//
//      ACM_FORMATTAGDETAILSF_LARGESTSIZE: Indicates that the details
//      on the format tag with the largest format size in bytes must be
//      returned. The dwFormatTag member will either be WAVE_FORMAT_UNKNOWN
//      or the format tag to find the largest size for.
//
//      If the details for the specified format tag cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatTagDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT                uFormatTag;

    //
    //
    //
    //
    //
    switch (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            //
            //  if the index is too large, then they are asking for a
            //  non-existant format.  return error.
            //
            if (ACM_DRIVER_MAX_FORMAT_TAGS <= padft->dwFormatTagIndex)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = gauFormatTagIndexToTag[(UINT)padft->dwFormatTagIndex];
            break;


        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_UNKNOWN:
                case WAVE_FORMAT_IMA_ADPCM:
                    uFormatTag = WAVE_FORMAT_IMA_ADPCM;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_IMA_ADPCM:
                    uFormatTag = WAVE_FORMAT_IMA_ADPCM;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        //
        //  if this ACM driver does not understand a query type, then
        //  return 'not supported'
        //
        default:
            return (MMSYSERR_NOTSUPPORTED);
    }



    //
    //
    //
    //
    switch (uFormatTag)
    {
        case WAVE_FORMAT_PCM:
            padft->dwFormatTagIndex = 0;
            padft->dwFormatTag      = WAVE_FORMAT_PCM;
            padft->cbFormatSize     = sizeof(PCMWAVEFORMAT);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_PCM;

            //
            //  the ACM is responsible for the PCM format tag name
            //
            padft->szFormatTag[0]   =  '\0';
            break;

        case WAVE_FORMAT_IMA_ADPCM:
            padft->dwFormatTagIndex = 1;
            padft->dwFormatTag      = WAVE_FORMAT_IMA_ADPCM;
            padft->cbFormatSize     = sizeof(WAVEFORMATEX) +
                                      IMAADPCM_WFX_EXTRA_BYTES;
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_ADPCM;

            LoadStringCodec(pdi->hinst,
			 IDS_ACM_DRIVER_TAG_NAME,
			 padft->szFormatTag,
			 SIZEOFACMSTR(padft->szFormatTag));
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATTAGDETAILS structure
    //  passed is at least large enough to hold the base information of
    //  the details structure
    //
    padft->cbStruct = min(padft->cbStruct, sizeof(*padft));


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatTagDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatDetails
//
//  Description:
//      This function handles the ACMDM_FORMAT_DETAILS message. This
//      message is normally sent in response to an acmFormatDetails or
//      acmFormatEnum function call. The purpose of this function is
//      to get details about a specific format for a specified format tag
//      supported by this ACM driver.
//
//      Note that an ACM driver can return a zero length string for the
//      format name if it wishes to have the ACM create a format string
//      for it. This is strongly recommended to simplify internationalizing
//      the driver--the ACM will automatically take care of that. The
//      following formula is used to format a string by the ACM:
//
//      <nSamplesPerSec> kHz, <bit depth> bit, [Mono | Stereo | nChannels]
//
//      <bit depth> = <nAvgBytesPerSec> * 8 / nSamplesPerSec / nChannels;
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATDETAILS padf: Pointer to an ACMFORMATDETAILS structure
//      that describes what format (for a specified format tag) to retrieve
//      details for.
//
//      DWORD fdwDetails: Flags defining what format for a specified format
//      tag to retrieve the details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATDETAILSF_INDEX: Indicates that a format index for the
//      format tag was given in the dwFormatIndex member of the
//      ACMFORMATDETAILS structure. The format details must be returned in
//      the structure specified by padf. The index ranges from zero to one
//      less than the cStandardFormats member returned in the
//      ACMFORMATTAGDETAILS structure for a format tag.
//
//      ACM_FORMATDETAILSF_FORMAT: Indicates that a WAVEFORMATEX structure
//      pointed to by pwfx of the ACMFORMATDETAILS structure was given and
//      the remaining details should be returned. The dwFormatTag member
//      of the ACMFORMATDETAILS will be initialized to the same format
//      tag as the pwfx member specifies. This query type may be used to
//      get a string description of an arbitrary format structure.
//
//      If the details for the specified format cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATDETAILS      padf,
    DWORD                   fdwDetails
)
{
    LPWAVEFORMATEX          pwfx;
    LPIMAADPCMWAVEFORMAT    pwfadpcm;
    UINT                    uFormatIndex;
    UINT                    u;


    //
    //
    //
    //
    //
    switch (ACM_FORMATDETAILSF_QUERYMASK & fdwDetails)
    {
        //
        //  enumerate by index
        //
        //  verify that the format tag is something we know about and
        //  return the details on the 'standard format' supported by
        //  this driver at the specified index...
        //
        case ACM_FORMATDETAILSF_INDEX:
            //
            //  put some stuff in more accessible variables--note that we
            //  bring variable sizes down to a reasonable size for 16 bit
            //  code...
            //
            pwfx = padf->pwfx;
            uFormatIndex = (UINT)padf->dwFormatIndex;

            switch (padf->dwFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (ACM_DRIVER_MAX_FORMATS_PCM <= padf->dwFormatIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    //
                    //  now fill in the format structure
                    //
                    pwfx->wFormatTag      = WAVE_FORMAT_PCM;

                    u = uFormatIndex / (ACM_DRIVER_MAX_BITSPERSAMPLE_PCM * ACM_DRIVER_MAX_CHANNELS);
                    pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[u];

                    u = uFormatIndex % ACM_DRIVER_MAX_CHANNELS;
                    pwfx->nChannels       = u + 1;

                    u = (uFormatIndex / ACM_DRIVER_MAX_CHANNELS) % ACM_DRIVER_MAX_CHANNELS;
                    pwfx->wBitsPerSample  = (WORD)gauFormatIndexToBitsPerSample[u];

                    pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT(pwfx);
                    pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;

                    //
                    //  note that the cbSize field is NOT valid for PCM
                    //  formats
                    //
                    //  pwfx->cbSize      = 0;
                    break;


                case WAVE_FORMAT_IMA_ADPCM:
                    if (ACM_DRIVER_MAX_FORMATS_ADPCM <= padf->dwFormatIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    pwfx->wFormatTag      = WAVE_FORMAT_IMA_ADPCM;

                    u = uFormatIndex / (ACM_DRIVER_MAX_BITSPERSAMPLE_ADPCM * ACM_DRIVER_MAX_CHANNELS);
                    pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[u];

                    u = uFormatIndex % ACM_DRIVER_MAX_CHANNELS;
                    pwfx->nChannels       = u + 1;
                    pwfx->wBitsPerSample  = IMAADPCM_BITS_PER_SAMPLE;

                    pwfx->nBlockAlign     = imaadpcmBlockAlign(pwfx);
                    pwfx->nAvgBytesPerSec = imaadpcmAvgBytesPerSec(pwfx);
                    pwfx->cbSize          = IMAADPCM_WFX_EXTRA_BYTES;

                    pwfadpcm     = (LPIMAADPCMWAVEFORMAT)pwfx;

                    pwfadpcm->wSamplesPerBlock = imaadpcmSamplesPerBlock(pwfx);
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }

        //
        //  return details on specified format
        //
        //  the caller normally uses this to verify that the format is
        //  supported and to retrieve a string description...
        //
        case ACM_FORMATDETAILSF_FORMAT:
            pwfx = padf->pwfx;

            switch (pwfx->wFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (!pcmIsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                case WAVE_FORMAT_IMA_ADPCM:
                    if (!imaadpcmIsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        default:
            //
            //  don't know how to do the query type passed--return 'not
            //  supported'.
            //
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  return the size of the valid information we are returning
    //
    //  the ACM will guarantee that the ACMFORMATDETAILS structure
    //  passed is at least large enough to hold the base structure
    //
    //  note that we let the ACM create the format string for us since
    //  we require no special formatting (and don't want to deal with
    //  internationalization issues, etc). simply set the string to
    //  a zero length.
    //
    padf->cbStruct    = min(padf->cbStruct, sizeof(*padf));
    padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_CODEC;
    padf->szFormat[0] = '\0';


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatDetails()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamOpen
//
//  Description:
//      This function handles the ACMDM_STREAM_OPEN message. This message
//      is sent to initiate a new conversion stream. This is usually caused
//      by an application calling acmStreamOpen. If this function is
//      successful, then one or more ACMDM_STREAM_CONVERT messages will be
//      sent to convert individual buffers (user calls acmStreamConvert).
//
//      Note that an ACM driver will not receive open requests for ASYNC
//      or FILTER operations unless the ACMDRIVERDETAILS_SUPPORTF_ASYNC
//      or ACMDRIVERDETAILS_SUPPORTF_FILTER flags are set in the
//      ACMDRIVERDETAILS structure. There is no need for the driver to
//      check for these requests unless it sets those support bits.
//
//      If the ACM_STREAMOPENF_QUERY flag is set in the padsi->fdwOpen
//      member, then no resources should be allocated. Just verify that
//      the conversion request is possible by this driver and return the
//      appropriate error (either ACMERR_NOTPOSSIBLE or MMSYSERR_NOERROR).
//      The driver will NOT receive an ACMDM_STREAM_CLOSE for queries.
//
//      If the ACM_STREAMOPENF_NONREALTIME bit is NOT set, then conversion
//      must be done in 'real-time'. This is a tough one to describe
//      exactly. If the driver may have trouble doing the conversion without
//      breaking up the audio, then a configuration dialog might be used
//      to allow the user to specify whether the real-time conversion
//      request should be succeeded. DO NOT SUCCEED THE CALL UNLESS YOU
//      ACTUALLY CAN DO REAL-TIME CONVERSIONS! There may be another driver
//      installed that can--so if you succeed the call you are hindering
//      the performance of the user's system!
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      This structure will be passed back to all future stream messages
//      if the open succeeds. The information in this structure will never
//      change during the lifetime of the stream--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      A driver should return ACMERR_NOTPOSSIBLE if the conversion cannot
//      be performed due to incompatible source and destination formats.
//
//      A driver should return MMSYSERR_NOTSUPPORTED if the conversion
//      cannot be performed in real-time and the request does not specify
//      the ACM_STREAMOPENF_NONREALTIME flag.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamOpen
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    BOOL                fRealTime;
    STREAMCONVERTPROC   fnConvert;
    PSTREAMINSTANCE     psi;
#ifdef IMAADPCM_USECONFIG
    DWORD               nConfigMaxRTEncodeSamplesPerSec;
    DWORD               nConfigMaxRTDecodeSamplesPerSec;
    DWORD               dw;
#endif


    //
    //
    //
    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

#ifdef IMAADPCM_USECONFIG
    nConfigMaxRTEncodeSamplesPerSec =
                gaRateListFormat[pdi->nConfigMaxRTEncodeSetting].dwMonoRate;
    DPF(2,"nConfigMaxRTEncodeSamplesPerSec=%u",nConfigMaxRTEncodeSamplesPerSec);

    nConfigMaxRTDecodeSamplesPerSec =
                gaRateListFormat[pdi->nConfigMaxRTDecodeSetting].dwMonoRate;
    DPF(2,"nConfigMaxRTDecodeSamplesPerSec=%u",nConfigMaxRTDecodeSamplesPerSec);
#endif

    fRealTime = (0 == (padsi->fdwOpen & ACM_STREAMOPENF_NONREALTIME));


    //
    //  the most important condition to check before doing anything else
    //  is that this ACM driver can actually perform the conversion we are
    //  being opened for. this check should fail as quickly as possible
    //  if the conversion is not possible by this driver.
    //
    //  it is VERY important to fail quickly so the ACM can attempt to
    //  find a driver that is suitable for the conversion. also note that
    //  the ACM may call this driver several times with slightly different
    //  format specifications before giving up.
    //
    //  this driver first verifies that the source and destination formats
    //  are acceptable...
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            if (!pcmIsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);

            if (!imaadpcmIsValidFormat(pwfxDst))
                return (ACMERR_NOTPOSSIBLE);

#ifdef IMAADPCM_USECONFIG
            //
            //  if a driver cannot perform real-time encoding then
            //  the driver should fail when opened for a real-time
            //  conversion. note that the driver MUST return
            //  MMSYSERR_NOTSUPPORTED in this case!
            //
            //  this driver may or may not be able to perform real-time
            //  encoding, depending on the system on which it is running.
            //  this driver allows the user to select whether to support
            //  real-time encoding thru the config dialog.
            //
            //  if this open is for a real-time conversion, fail if
            //  real-time encoding hasn't been enabled in the config
            //  dialog.  Note that nConfigMaxRTDecodeSamplesPerSec is
            //  the value for a mono conversion - if it's a stereo
            //  conversion, we can only convert half as high...
            //
            if (fRealTime)
            {
                dw = nConfigMaxRTEncodeSamplesPerSec / pwfxSrc->nChannels;
                if (dw < pwfxSrc->nSamplesPerSec)
                {
                    return (MMSYSERR_NOTSUPPORTED);
                }
            }
#endif

            //
            //  Determine the correct conversion routine.
            //
            switch (pwfxSrc->nChannels)
            {
                case 1:
                    if (8 == pwfxSrc->wBitsPerSample)
                        fnConvert = imaadpcmEncode4Bit_M08;
                    else
                        fnConvert = imaadpcmEncode4Bit_M16;
                    break;

                case 2:
                    if (8 == pwfxSrc->wBitsPerSample)
                        fnConvert = imaadpcmEncode4Bit_S08;
                    else
                        fnConvert = imaadpcmEncode4Bit_S16;
                    break;

                default:
                    return ACMERR_NOTPOSSIBLE;
            }
            break;

        case WAVE_FORMAT_IMA_ADPCM:
            if (!imaadpcmIsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);

            if (!pcmIsValidFormat(pwfxDst))
                return (ACMERR_NOTPOSSIBLE);

#ifdef IMAADPCM_USECONFIG
            //
            //  if a driver cannot perform real-time encoding then
            //  the driver should fail when opened for a real-time
            //  conversion. note that the driver MUST return
            //  MMSYSERR_NOTSUPPORTED in this case!
            //
            //  this driver may or may not be able to perform real-time
            //  encoding, depending on the system on which it is running.
            //  this driver allows the user to select whether to support
            //  real-time encoding thru the config dialog.
            //
            //  if this open is for a real-time conversion, fail if
            //  real-time decoding hasn't been enabled in the config
            //  dialog.  Note that nConfigMaxRTDecodeSamplesPerSec is
            //  the value for a mono conversion - if it's a stereo
            //  conversion, we can only convert half as high...
            //
            if (fRealTime)
            {
                dw = nConfigMaxRTDecodeSamplesPerSec / pwfxSrc->nChannels;
                if( dw < pwfxSrc->nSamplesPerSec )
                {
                    return (MMSYSERR_NOTSUPPORTED);
                }
            }
#endif

            //
            //  Determine the correct conversion routine.
            //
            switch (pwfxSrc->nChannels)
            {
                case 1:
                    if (8 == pwfxDst->wBitsPerSample)
                        fnConvert = imaadpcmDecode4Bit_M08;
                    else
                        fnConvert = imaadpcmDecode4Bit_M16;
                    break;

                case 2:
                    if (8 == pwfxDst->wBitsPerSample)
                        fnConvert = imaadpcmDecode4Bit_S08;
                    else
                        fnConvert = imaadpcmDecode4Bit_S16;
                    break;

                default:
                    return ACMERR_NOTPOSSIBLE;
            }
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  for this driver, we must also verify that the nChannels and
    //  nSamplesPerSec members are the same between the source and
    //  destination formats.
    //
    if (pwfxSrc->nChannels != pwfxDst->nChannels)
        return (MMSYSERR_NOTSUPPORTED);

    if (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
        return (MMSYSERR_NOTSUPPORTED);


    //
    //  we have determined that the conversion requested is possible by
    //  this driver. now check if we are just being queried for support.
    //  if this is just a query, then do NOT allocate any instance data
    //  or create tables, etc. just succeed the call.
    //
    if (0 != (ACM_STREAMOPENF_QUERY & padsi->fdwOpen))
    {
        return (MMSYSERR_NOERROR);
    }


    //
    //  we have decided that this driver can handle the conversion stream.
    //  so we want to do _AS MUCH WORK AS POSSIBLE_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.
    //
    //  this driver allocates a small instance structure for each stream
    //
    //
    psi = (PSTREAMINSTANCE)LocalAlloc(LPTR, sizeof(*psi));
    if (NULL == psi)
    {
        return (MMSYSERR_NOMEM);
    }


    //
    //  fill out our instance structure
    //
    //  this driver stores a pointer to the conversion function that will
    //  be used for each conversion on this stream. we also store a
    //  copy of the _current_ configuration of the driver instance we
    //  are opened on. this must not change during the life of the stream
    //  instance.
    //
    //  this is also very important! if the user is able to configure how
    //  the driver performs conversions, the changes should only affect
    //  future open streams. all current open streams should behave as
    //  they were configured during the open.
    //
    psi->fnConvert      = fnConvert;
    psi->fdwConfig      = pdi->fdwConfig;
    psi->nStepIndexL    = 0;
    psi->nStepIndexR    = 0;


    //
    //  fill in our instance data--this will be passed back to all stream
    //  messages in the ACMDRVSTREAMINSTANCE structure. it is entirely
    //  up to the driver what gets stored (and maintained) in the
    //  fdwDriver and dwDriver members.
    //
    padsi->fdwDriver = 0L;
    padsi->dwDriver  = (DWORD_PTR)psi;

    return (MMSYSERR_NOERROR);
} // acmdStreamOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamClose
//
//  Description:
//      This function is called to handle the ACMDM_STREAM_CLOSE message.
//      This message is sent when a conversion stream is no longer being
//      used (the stream is being closed; usually by an application
//      calling acmStreamClose). The ACM driver should clean up any resources
//      that were allocated for the stream.
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      NOTE! It is _strongly_ recommended that a driver not fail to close
//      a conversion stream.
//
//      An asyncronous conversion stream may fail with ACMERR_BUSY if there
//      are pending buffers. An application may call acmStreamReset to
//      force all pending buffers to be posted.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamClose
(
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    PSTREAMINSTANCE     psi;

    //
    //  the driver should clean up all privately allocated resources that
    //  were created for maintaining the stream instance. if no resources
    //  were allocated, then simply succeed.
    //
    //  in the case of this driver, we need to free the stream instance
    //  structure that we allocated during acmdStreamOpen.
    //
    psi = (PSTREAMINSTANCE)padsi->dwDriver;
    if (NULL != psi)
    {
        //
        //  free the stream instance structure
        //
        LocalFree((HLOCAL)psi);
    }

    return (MMSYSERR_NOERROR);
} // acmdStreamClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamSize
//
//  Description:
//      This function handles the ACMDM_STREAM_SIZE message. The purpose
//      of this function is to provide the _largest size in bytes_ that
//      the source or destination buffer needs to be given the input and
//      output formats and the size in bytes of the source or destination
//      data buffer.
//
//      In other words: how big does my destination buffer need to be to
//      hold the converted data? (ACM_STREAMSIZEF_SOURCE)
//
//      Or: how big can my source buffer be given the destination buffer?
//      (ACM_STREAMSIZEF_DESTINATION)
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMSIZE padss: Specifies a pointer to the ACMDRVSTREAMSIZE
//      structure that defines the conversion stream size query attributes.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      An ACM driver should return MMSYSERR_NOTSUPPORTED if a query type
//      is requested that the driver does not understand. Note that a driver
//      must support both the ACM_STREAMSIZEF_DESTINATION and
//      ACM_STREAMSIZEF_SOURCE queries.
//
//      If the conversion would be 'out of range' given the input arguments,
//      then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamSize
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
)
{
    PSTREAMINSTANCE         psi;
    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
    LPIMAADPCMWAVEFORMAT    pwfadpcm;
    DWORD                   cb;
    DWORD                   cBlocks;
    DWORD                   cbBytesPerBlock;


    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    //
    //
    //
    //
    //
    switch (ACM_STREAMSIZEF_QUERYMASK & padss->fdwSize)
    {
        case ACM_STREAMSIZEF_SOURCE:
            cb = padss->cbSrcLength;

            if (WAVE_FORMAT_IMA_ADPCM == pwfxSrc->wFormatTag)
            {
                //
                //  how many destination PCM bytes are needed to hold
                //  the decoded ADPCM data of padss->cbSrcLength bytes
                //
                //  always round UP
                //
                cBlocks = cb / pwfxSrc->nBlockAlign;
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                pwfadpcm = (LPIMAADPCMWAVEFORMAT)pwfxSrc;

                cbBytesPerBlock = pwfadpcm->wSamplesPerBlock * pwfxDst->nBlockAlign;

                if ((0xFFFFFFFFL / cbBytesPerBlock) < cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                if (0 == (cb % pwfxSrc->nBlockAlign))
                {
                    cb = cBlocks * cbBytesPerBlock;
                }
                else
                {
                    cb = (cBlocks + 1) * cbBytesPerBlock;
                }
            }
            else
            {
                //
                //  how many destination ADPCM bytes are needed to hold
                //  the encoded PCM data of padss->cbSrcLength bytes
                //
                //  always round UP
                //
                pwfadpcm = (LPIMAADPCMWAVEFORMAT)pwfxDst;

                cbBytesPerBlock = pwfadpcm->wSamplesPerBlock * pwfxSrc->nBlockAlign;

                cBlocks = cb / cbBytesPerBlock;

                if (0 == (cb % cbBytesPerBlock))
                {
                    cb = cBlocks * pwfxDst->nBlockAlign;
                }
                else
                {
                    cb = (cBlocks + 1) * pwfxDst->nBlockAlign;
                }

                if (0L == cb)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }
            }

            padss->cbDstLength = cb;
            return (MMSYSERR_NOERROR);


        case ACM_STREAMSIZEF_DESTINATION:
            cb = padss->cbDstLength;

            if (WAVE_FORMAT_IMA_ADPCM == pwfxDst->wFormatTag)
            {
                //
                //  how many source PCM bytes can be encoded into a
                //  destination buffer of padss->cbDstLength bytes
                //
                //  always round DOWN
                //
                cBlocks = cb / pwfxDst->nBlockAlign;
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                pwfadpcm = (LPIMAADPCMWAVEFORMAT)pwfxDst;

                cbBytesPerBlock = pwfadpcm->wSamplesPerBlock * pwfxSrc->nBlockAlign;

                if ((0xFFFFFFFFL / cbBytesPerBlock) < cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                cb = cBlocks * cbBytesPerBlock;
            }
            else
            {
                //
                //  how many source ADPCM bytes can be decoded into a
                //  destination buffer of padss->cbDstLength bytes
                //
                //  always round DOWN
                //
                pwfadpcm = (LPIMAADPCMWAVEFORMAT)pwfxSrc;

                cbBytesPerBlock = pwfadpcm->wSamplesPerBlock * pwfxDst->nBlockAlign;

                cBlocks = cb / cbBytesPerBlock;
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                cb = cBlocks * pwfxSrc->nBlockAlign;
            }

            padss->cbSrcLength = cb;
            return (MMSYSERR_NOERROR);
    }

    //
    //
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdStreamSize()



//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamConvert
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message. This is the
//      whole purpose of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamConvert
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
)
{
    BOOL                    fBlockAlign;
    BOOL                    fStart;
    LPWAVEFORMATEX          pwfpcm;
    LPIMAADPCMWAVEFORMAT    pwfadpcm;
    DWORD                   dw;
    DWORD                   cbConvert;
    PSTREAMINSTANCE         psi;

    //
    //  Determine the conversion flags.
    //
    fBlockAlign = (0 != (ACM_STREAMCONVERTF_BLOCKALIGN & padsh->fdwConvert));
    fStart      = (0 != (ACM_STREAMCONVERTF_START      & padsh->fdwConvert));

    psi = (PSTREAMINSTANCE)padsi->dwDriver;

    DPF(4,"acmdStreamConvert: fBlockAlign=%d, fStart=%d, cbSrcLength=%ld",fBlockAlign,fStart,padsh->cbSrcLength);


    if (WAVE_FORMAT_PCM == padsi->pwfxSrc->wFormatTag) {

        //
        //  Encode.
        //

        pwfpcm   = padsi->pwfxSrc;
        pwfadpcm = (LPIMAADPCMWAVEFORMAT)padsi->pwfxDst;

        //
        // Determine the number of samples to convert.  We ALWAYS convert
        // block-aligned.
        //
        dw = PCM_BYTESTOSAMPLES(pwfpcm, padsh->cbSrcLength);
        dw = (dw / pwfadpcm->wSamplesPerBlock) * pwfadpcm->wSamplesPerBlock;
        cbConvert = PCM_SAMPLESTOBYTES(pwfpcm, dw);

        //
        //  Reset step index if we have a start condition.
        //
        if( fStart ) {
            psi->nStepIndexL = 0;
            psi->nStepIndexR = 0;   // Not necessary for mono, but...
        }

    } else {

        //
        //  Decode.
        //

        pwfadpcm = (LPIMAADPCMWAVEFORMAT)padsi->pwfxSrc;
        pwfpcm   = padsi->pwfxDst;

        //
        // Determine the number of bytes to convert.  We ALWAYS convert
        // block-aligned.
        //
        cbConvert = (padsh->cbSrcLength/pwfadpcm->wfx.nBlockAlign) *
                                        pwfadpcm->wfx.nBlockAlign;
    }


    //
    //  Set the number of Src bytes used.  If fBlockAlign is not set, then
    //  we throw away any bytes which aren't used, by marking them as used
    //  even though we don't actually convert them.
    //
    padsh->cbSrcLengthUsed = ( fBlockAlign ?
                                cbConvert :
                                padsh->cbSrcLength );


    //
    //  Call the conversion routine.
    //
    padsh->cbDstLengthUsed = psi->fnConvert(
                (HPBYTE)padsh->pbSrc,
                cbConvert,
                (HPBYTE)padsh->pbDst,
                (UINT)pwfadpcm->wfx.nBlockAlign,   // Used for decode only.
                (UINT)pwfadpcm->wSamplesPerBlock,  // Used for encode only.
                &psi->nStepIndexL,                 // Used for encode only.
                &psi->nStepIndexR                  // For stereo encode only.
    );

    return (MMSYSERR_NOERROR);
} // acmdStreamConvert()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT DriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      the driver is opened, through the OpenDriver API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNEXPORT DriverProc
(
    DWORD_PTR               dwpId,
    HDRVR                   hdrvr,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT             lr;
    PDRIVERINSTANCE     pdi;

    //
    //  make pdi either NULL or a valid instance pointer. note that dwpId
    //  is 0 for several of the DRV_* messages (ie DRV_LOAD, DRV_OPEN...)
    //  see acmdDriverOpen for information on what dwpId is for other
    //  messages (instance data).
    //
    pdi = (PDRIVERINSTANCE)dwpId;

    switch (uMsg)
    {
        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_LOAD:
#ifdef WIN32
            DbgInitialize(TRUE);
#endif
            return(1L);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_FREE:
            return (1L);

        //
        //  lParam1: Not used. Ignore this argument.
        //
        //  lParam2: Pointer to ACMDRVOPENDESC (or NULL).
        //
        case DRV_OPEN:
            lr = acmdDriverOpen(hdrvr, (LPACMDRVOPENDESC)lParam2);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_CLOSE:
            lr = acmdDriverClose(pdi);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_INSTALL:
            return ((LRESULT)DRVCNF_RESTART);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_REMOVE:
            return ((LRESULT)DRVCNF_RESTART);



        //
        //  lParam1: Not used.
        //
        //  lParam2: Not used.
        //
        case DRV_QUERYCONFIGURE:
            //
            //  set up lParam1 and lParam2 to values that can be used by
            //  acmdDriverConfigure to know that it is being 'queried'
            //  for configuration support.
            //
            lParam1 = -1L;
            lParam2 = 0L;

            //--fall through--//

        //
        //  lParam1: Handle to parent window for the configuration dialog
        //           box.
        //
        //  lParam2: Optional pointer to DRVCONFIGINFO structure.
        //
        case DRV_CONFIGURE:
            lr = acmdDriverConfigure(pdi, (HWND)lParam1, (LPDRVCONFIGINFO)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to ACMDRIVERDETAILS structure.
        //
        //  lParam2: Size in bytes of ACMDRIVERDETAILS stucture passed.
        //
        case ACMDM_DRIVER_DETAILS:
            lr = acmdDriverDetails(pdi, (LPACMDRIVERDETAILS)lParam1);
            return (lr);

        //
        //  lParam1: Handle to parent window to use if displaying your own
        //           about box.
        //
        //  lParam2: Not used.
        //
        case ACMDM_DRIVER_ABOUT:
            lr = acmdDriverAbout(pdi, (HWND)lParam1);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVFORMATSUGGEST structure.
        //
        //  lParam2: Not used.
        //
       case ACMDM_FORMAT_SUGGEST:
            lr = acmdFormatSuggest(pdi, (LPACMDRVFORMATSUGGEST)lParam1);
            return (lr);


        //
        //  lParam1: Pointer to FORMATTAGDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMATTAG_DETAILS:
            lr = acmdFormatTagDetails(pdi, (LPACMFORMATTAGDETAILS)lParam1, (DWORD)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to FORMATDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMAT_DETAILS:
            lr = acmdFormatDetails(pdi, (LPACMFORMATDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not used.
        //
        case ACMDM_STREAM_OPEN:
            lr = acmdStreamOpen(pdi, (LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not Used.
        //
        case ACMDM_STREAM_CLOSE:
            lr = acmdStreamClose((LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMSIZE structure.
        //
        case ACMDM_STREAM_SIZE:
            lr = acmdStreamSize((LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMSIZE)lParam2);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMHEADER structure.
        //
        case ACMDM_STREAM_CONVERT:
            lr = acmdStreamConvert(pdi, (LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMHEADER)lParam2);
            return (lr);
    }

    //
    //  if we are executing the following code, then this ACM driver does not
    //  handle the message that was sent. there are two ranges of messages
    //  we need to deal with:
    //
    //  o   ACM specific driver messages: if an ACM driver does not answer a
    //      message sent in the ACM driver message range, then it must
    //      return MMSYSERR_NOTSUPPORTED. this applies to the 'user'
    //      range as well (for consistency).
    //
    //  o   other installable driver messages: if an ACM driver does not
    //      answer a message that is NOT in the ACM driver message range,
    //      then it must call DefDriverProc and return that result.
    //      the exception to this is ACM driver procedures installed as
    //      ACM_DRIVERADDF_FUNCTION through acmDriverAdd. in this case,
    //      the driver procedure should conform to the ACMDRIVERPROC
    //      prototype and also return zero instead of calling DefDriverProc.
    //
    if (uMsg >= ACMDM_USER)
        return (MMSYSERR_NOTSUPPORTED);
    else
        return (DefDriverProc(dwpId, hdrvr, uMsg, lParam1, lParam2));
} // DriverProc()

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\imaadpcm\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//      This file contains definitions for DEBUG builds; all debugging
//      instructions are #define-d to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MODULE_NAME   "IMAADPCM"  // key name and prefix for output
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI _Assert( char * szFile, int iLine );

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
    #define ASSERT(x)   if( !(x) )  _Assert( __FILE__, __LINE__)
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
    #define ASSERT(x)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\imaadpcm\imaadpcm.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  imaadpcm.c
//
//  Description:
//      This file contains encode and decode routines for the IMA's ADPCM
//      format. This format is the same format used in Intel's DVI standard.
//      Intel has made this algorithm public domain and the IMA has endorsed
//      this format as a standard for audio compression.
//
//  Implementation notes:
//
//      A previous distribution of this codec used a data format which did
//      not comply with the IMA standard.  For stereo files, the interleaving
//      of left and right samples was incorrect:  the IMA standard requires
//      that a DWORD of left-channel data be followed by a DWORD of right-
//      channel data, but the previous implementation of this codec
//      interleaved the data at the byte level, with the 4 LSBs being the
//      left channel data and the 4 MSBs being the right channel data.
//      For mono files, each pair of samples was reversed:  the first sample
//      was stored in the 4 MSBs rather than the 4 LSBs.  This problem is
//      fixed during the current release.  Note: files compressed by the
//      old codec will sound distorted when played back with the new codec,
//      and vice versa.  Please recompress these files with the new codec,
//      since they do not conform to the standard and will not be reproduced
//      correctly by hardware codecs, etc.
//
//      A previous distribution of this codec had an implementation problem
//      which degraded the sound quality of the encoding.  This was due to
//      the fact that the step index was not properly maintained between
//      conversions.   This problem has been fixed in the current release.
//
//      The codec has been speeded up considerably by breaking
//      the encode and decode routines into four separate routines each:
//      mono 8-bit, mono 16-bit, stereo 8-bit, and stereo 16-bit.  This
//      approach is recommended for real-time conversion routines.
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include "codec.h"
#include "imaadpcm.h"

#include "debug.h"


//
//  This array is used by imaadpcmNextStepIndex to determine the next step
//  index to use.  The step index is an index to the step[] array, below.
//
const short next_step[16] =
{
    -1, -1, -1, -1, 2, 4, 6, 8,
    -1, -1, -1, -1, 2, 4, 6, 8
};

//
//  This array contains the array of step sizes used to encode the ADPCM
//  samples.  The step index in each ADPCM block is an index to this array.
//
const short step[89] =
{
        7,     8,     9,    10,    11,    12,    13,
       14,    16,    17,    19,    21,    23,    25,
       28,    31,    34,    37,    41,    45,    50,
       55,    60,    66,    73,    80,    88,    97,
      107,   118,   130,   143,   157,   173,   190,
      209,   230,   253,   279,   307,   337,   371,
      408,   449,   494,   544,   598,   658,   724,
      796,   876,   963,  1060,  1166,  1282,  1411,
     1552,  1707,  1878,  2066,  2272,  2499,  2749,
     3024,  3327,  3660,  4026,  4428,  4871,  5358,
     5894,  6484,  7132,  7845,  8630,  9493, 10442,
    11487, 12635, 13899, 15289, 16818, 18500, 20350,
    22385, 24623, 27086, 29794, 32767
};




#ifndef INLINE
    #define INLINE __inline
#endif



//--------------------------------------------------------------------------;
//  
//  DWORD pcmM08BytesToSamples
//  DWORD pcmM16BytesToSamples
//  DWORD pcmS08BytesToSamples
//  DWORD pcmS16BytesToSamples
//  
//  Description:
//      These functions return the number of samples in a buffer of PCM
//      of the specified format.  For efficiency, it is declared INLINE.
//      Note that, depending on the optimization flags, it may not
//      actually be implemented as INLINE.  Optimizing for speed (-Oxwt)
//      will generally obey the INLINE specification.
//  
//  Arguments:
//      DWORD cb: The length of the buffer, in bytes.
//  
//  Return (DWORD):  The length of the buffer in samples.
//  
//--------------------------------------------------------------------------;

INLINE DWORD pcmM08BytesToSamples(
    DWORD cb
)
{
    return cb;
}

INLINE DWORD pcmM16BytesToSamples(
    DWORD cb
)
{
    return cb / ((DWORD)2);
}

INLINE DWORD pcmS08BytesToSamples(
    DWORD cb
)
{
    return cb / ((DWORD)2);
}

INLINE DWORD pcmS16BytesToSamples(
    DWORD cb
)
{
    return cb / ((DWORD)4);
}



#ifdef WIN32
//
// This code assumes that the integer nPredictedSample is 32-bits wide!!!
//
// The following define replaces the pair of calls to the inline functions
// imaadpcmSampleEncode() and imaadpcmSampleDecode which are called in the
// encode routines.  There is some redundancy between them which is exploited
// in this define.  Because there are two returns (nEncodedSample and
// nPredictedSample), it is more efficient to use a #define rather than an
// inline function which would require a pointer to one of the returns.
// 
// Basically, nPredictedSample is calculated based on the lDifference value
// already there, rather than regenerating it through imaadpcmSampleDecode().
//
#define imaadpcmFastEncode(nEncodedSample,nPredictedSample,nInputSample,nStepSize) \
{                                                                       \
    LONG            lDifference;                                        \
                                                                        \
    lDifference = nInputSample - nPredictedSample;                      \
    nEncodedSample = 0;                                                 \
    if( lDifference<0 ) {                                               \
        nEncodedSample = 8;                                             \
        lDifference = -lDifference;                                     \
    }                                                                   \
                                                                        \
    if( lDifference >= nStepSize ) {                                    \
        nEncodedSample |= 4;                                            \
        lDifference -= nStepSize;                                       \
    }                                                                   \
                                                                        \
    nStepSize >>= 1;                                                    \
    if( lDifference >= nStepSize ) {                                    \
        nEncodedSample |= 2;                                            \
        lDifference -= nStepSize;                                       \
    }                                                                   \
                                                                        \
    nStepSize >>= 1;                                                    \
    if( lDifference >= nStepSize ) {                                    \
        nEncodedSample |= 1;                                            \
        lDifference -= nStepSize;                                       \
    }                                                                   \
                                                                        \
    if( nEncodedSample & 8 )                                            \
        nPredictedSample = nInputSample + lDifference - (nStepSize>>1); \
    else                                                                \
        nPredictedSample = nInputSample - lDifference + (nStepSize>>1); \
                                                                        \
    if( nPredictedSample > 32767 )                                      \
        nPredictedSample = 32767;                                       \
    else if( nPredictedSample < -32768 )                                \
        nPredictedSample = -32768;                                      \
}

#else

//--------------------------------------------------------------------------;
//  
//  int imaadpcmSampleEncode
//  
//  Description:
//      This routine encodes a single ADPCM sample.  For efficiency, it is
//      declared INLINE.  Note that, depending on the optimization flags,
//      it may not actually be implemented as INLINE.  Optimizing for speed
//      (-Oxwt) will generally obey the INLINE specification.
//  
//  Arguments:
//      int nInputSample:  The sample to be encoded.
//      int nPredictedSample:  The predicted value of nInputSample.
//      int nStepSize:  The quantization step size for the difference between
//                      nInputSample and nPredictedSample.
//  
//  Return (int):  The 4-bit ADPCM encoded sample, which corresponds to the
//                  quantized difference value.
//  
//--------------------------------------------------------------------------;

INLINE int imaadpcmSampleEncode
(
    int                 nInputSample,
    int                 nPredictedSample,
    int                 nStepSize
)
{
    LONG            lDifference;    // difference may require 17 bits!
    int             nEncodedSample;


    //
    //  set sign bit (bit 3 of the encoded sample) based on sign of the
    //  difference (nInputSample-nPredictedSample).  Note that we want the
    //  absolute value of the difference for the subsequent quantization.
    //
    lDifference = nInputSample - nPredictedSample;
    nEncodedSample = 0;
    if( lDifference<0 ) {
        nEncodedSample = 8;
        lDifference = -lDifference;
    }

    //
    //  quantize lDifference sample
    //
    if( lDifference >= nStepSize ) {        // Bit 2.
        nEncodedSample |= 4;
        lDifference -= nStepSize;
    }

    nStepSize >>= 1;
    if( lDifference >= nStepSize ) {        // Bit 1.
        nEncodedSample |= 2;
        lDifference -= nStepSize;
    }

    nStepSize >>= 1;
    if( lDifference >= nStepSize ) {     // Bit 0.
        nEncodedSample |= 1;
    }

    return (nEncodedSample);
}

#endif


//--------------------------------------------------------------------------;
//  
//  int imaadpcmSampleDecode
//  
//  Description:
//      This routine decodes a single ADPCM sample.  For efficiency, it is
//      declared INLINE.  Note that, depending on the optimization flags,
//      it may not actually be implemented as INLINE.  Optimizing for speed
//      (-Oxwt) will generally obey the INLINE specification.
//  
//  Arguments:
//      int nEncodedSample:  The sample to be decoded.
//      int nPredictedSample:  The predicted value of the sample (in PCM).
//      int nStepSize:  The quantization step size used to encode the sample.
//  
//  Return (int):  The decoded PCM sample.
//  
//--------------------------------------------------------------------------;

INLINE int imaadpcmSampleDecode
(
    int                 nEncodedSample,
    int                 nPredictedSample,
    int                 nStepSize
)
{
    LONG            lDifference;
    LONG            lNewSample;

    //
    //  calculate difference:
    //
    //      lDifference = (nEncodedSample + 1/2) * nStepSize / 4
    //
    lDifference = nStepSize>>3;

    if (nEncodedSample & 4) 
        lDifference += nStepSize;

    if (nEncodedSample & 2) 
        lDifference += nStepSize>>1;

    if (nEncodedSample & 1) 
        lDifference += nStepSize>>2;

    //
    //  If the 'sign bit' of the encoded nibble is set, then the
    //  difference is negative...
    //
    if (nEncodedSample & 8)
        lDifference = -lDifference;

    //
    //  adjust predicted sample based on calculated difference
    //
    lNewSample = nPredictedSample + lDifference;

    //
    //  check for overflow and clamp if necessary to a 16 signed sample.
    //  Note that this is optimized for the most common case, when we
    //  don't have to clamp.
    //
    if( (long)(short)lNewSample == lNewSample )
    {
        return (int)lNewSample;
    }

    //
    //  Clamp.
    //
    if( lNewSample < -32768 )
        return (int)-32768;
    else
        return (int)32767;
}


//--------------------------------------------------------------------------;
//  
//  int imaadpcmNextStepIndex
//  
//  Description:
//      This routine calculates the step index value to use for the next
//      encode, based on the current value of the step index and the current
//      encoded sample.  For efficiency, it is declared INLINE.  Note that,
//      depending on the optimization flags, it may not actually be 
//      implemented as INLINE.  Optimizing for speed (-Oxwt) will generally 
//      obey the INLINE specification.
//  
//  Arguments:
//      int nEncodedSample:  The current encoded ADPCM sample.
//      int nStepIndex:  The step index value used to encode nEncodedSample.
//  
//  Return (int):  The step index to use for the next sample.
//  
//--------------------------------------------------------------------------;

INLINE int imaadpcmNextStepIndex
(
    int                     nEncodedSample,
    int                     nStepIndex
)
{
    //
    //  compute new stepsize step
    //
    nStepIndex += next_step[nEncodedSample];

    if (nStepIndex < 0)
        nStepIndex = 0;
    else if (nStepIndex > 88)
        nStepIndex = 88;

    return (nStepIndex);
}



//--------------------------------------------------------------------------;
//  
//  BOOL imaadpcmValidStepIndex
//  
//  Description:
//      This routine checks the step index value to make sure that it is
//      within the legal range.
//  
//  Arguments:
//      
//      int nStepIndex:  The step index value.
//  
//  Return (BOOL):  TRUE if the step index is valid; FALSE otherwise.
//  
//--------------------------------------------------------------------------;

INLINE BOOL imaadpcmValidStepIndex
(
    int                     nStepIndex
)
{

    if( nStepIndex >= 0 && nStepIndex <= 88 )
        return TRUE;
    else
        return FALSE;
}



//==========================================================================;
//
//      DECODE ROUTINES
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  DWORD imaadpcmDecode4Bit_M08
//  DWORD imaadpcmDecode4Bit_M16
//  DWORD imaadpcmDecode4Bit_S08
//  DWORD imaadpcmDecode4Bit_S16
//  
//  Description:
//      These functions decode a buffer of data from ADPCM to PCM in the
//      specified format.  The appropriate function is called once for each
//      ACMDM_STREAM_CONVERT message received.  Note that since these
//      functions must share the same prototype as the encoding functions
//      (see acmdStreamOpen() and acmdStreamConvert() in codec.c for more
//      details), not all the parameters are used by these routines.
//  
//  Arguments:
//      HPBYTE pbSrc:  Pointer to the source buffer (ADPCM data).
//      DWORD cbSrcLength:  The length of the source buffer (in bytes).
//      HPBYTE pbDst:  Pointer to the destination buffer (PCM data).  Note
//                      that it is assumed that the destination buffer is
//                      large enough to hold all the encoded data; see
//                      acmdStreamSize() in codec.c for more details.
//      UINT nBlockAlignment:  The block alignment of the ADPCM data (in
//                      bytes).
//      UINT cSamplesPerBlock:  The number of samples in each ADPCM block;
//                      not used for decoding.
//      int *pnStepIndexL:  Pointer to the step index value (left channel)
//                      in the STREAMINSTANCE structure; not used for
//                      decoding.
//      int *pnStepIndexR:  Pointer to the step index value (right channel)
//                      in the STREAMINSTANCE structure; not used for
//                      decoding.
//  
//  Return (DWORD):  The number of bytes used in the destination buffer.
//  
//--------------------------------------------------------------------------;

DWORD FNGLOBAL imaadpcmDecode4Bit_M08
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
)
{
    HPBYTE                  pbDstStart;
    UINT                    cbHeader;
    UINT                    cbBlockLength;
    BYTE                    bSample;
    int                     nStepSize;

    int                     nEncSample;
    int                     nPredSample;
    int                     nStepIndex;

    
    pbDstStart = pbDst;
    cbHeader = IMAADPCM_HEADER_LENGTH * 1;  //  1 = number of channels.


    DPF(3,"Starting imaadpcmDecode4Bit_M08().");


    //
    //
    //
    while (cbSrcLength >= cbHeader)
    {
        DWORD       dwHeader;

        cbBlockLength  = (UINT)min(cbSrcLength, nBlockAlignment);
        cbSrcLength   -= cbBlockLength;
        cbBlockLength -= cbHeader;

        //
        //  block header
        //
        dwHeader = *(DWORD HUGE_T *)pbSrc;
        pbSrc   += sizeof(DWORD);
        nPredSample = (int)(short)LOWORD(dwHeader);
        nStepIndex  = (int)(BYTE)HIWORD(dwHeader);

        if( !imaadpcmValidStepIndex(nStepIndex) ) {
            //
            //  The step index is out of range - this is considered a fatal
            //  error as the input stream is corrupted.  We fail by returning
            //  zero bytes converted.
            //
            DPF(1,"imaadpcmDecode4Bit_M08: invalid step index.");
            return 0;
        }
        

        //
        //  write out first sample
        //
        *pbDst++ = (BYTE)((nPredSample >> 8) + 128);


        //
        //
        //
        while (cbBlockLength--)
        {
            bSample = *pbSrc++;

            //
            //  sample 1
            //
            nEncSample  = (bSample & (BYTE)0x0F);
            nStepSize   = step[nStepIndex];
            nPredSample = imaadpcmSampleDecode(nEncSample, nPredSample, nStepSize);
            nStepIndex  = imaadpcmNextStepIndex(nEncSample, nStepIndex);

            //
            //  write out sample
            //
            *pbDst++ = (BYTE)((nPredSample >> 8) + 128);

            //
            //  sample 2
            //
            nEncSample  = (bSample >> 4);
            nStepSize   = step[nStepIndex];
            nPredSample = imaadpcmSampleDecode(nEncSample, nPredSample, nStepSize);
            nStepIndex  = imaadpcmNextStepIndex(nEncSample, nStepIndex);

            //
            //  write out sample
            //
            *pbDst++ = (BYTE)((nPredSample >> 8) + 128);
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // imaadpcmDecode4Bit_M08()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL imaadpcmDecode4Bit_M16
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
)
{
    HPBYTE                  pbDstStart;
    UINT                    cbHeader;
    UINT                    cbBlockLength;
    BYTE                    bSample;
    int                     nStepSize;

    int                     nEncSample;
    int                     nPredSample;
    int                     nStepIndex;

    
    pbDstStart = pbDst;
    cbHeader = IMAADPCM_HEADER_LENGTH * 1;  //  1 = number of channels.


    DPF(3,"Starting imaadpcmDecode4Bit_M16().");


    //
    //
    //
    while (cbSrcLength >= cbHeader)
    {
        DWORD       dwHeader;

        cbBlockLength  = (UINT)min(cbSrcLength, nBlockAlignment);
        cbSrcLength   -= cbBlockLength;
        cbBlockLength -= cbHeader;

        //
        //  block header
        //
        dwHeader = *(DWORD HUGE_T *)pbSrc;
        pbSrc   += sizeof(DWORD);
        nPredSample = (int)(short)LOWORD(dwHeader);
        nStepIndex  = (int)(BYTE)HIWORD(dwHeader);

        if( !imaadpcmValidStepIndex(nStepIndex) ) {
            //
            //  The step index is out of range - this is considered a fatal
            //  error as the input stream is corrupted.  We fail by returning
            //  zero bytes converted.
            //
            DPF(1,"imaadpcmDecode4Bit_M16: invalid step index.");
            return 0;
        }
        

        //
        //  write out first sample
        //
        *(short HUGE_T *)pbDst = (short)nPredSample;
        pbDst += sizeof(short);


        //
        //
        //
        while (cbBlockLength--)
        {
            bSample = *pbSrc++;

            //
            //  sample 1
            //
            nEncSample  = (bSample & (BYTE)0x0F);
            nStepSize   = step[nStepIndex];
            nPredSample = imaadpcmSampleDecode(nEncSample, nPredSample, nStepSize);
            nStepIndex  = imaadpcmNextStepIndex(nEncSample, nStepIndex);

            //
            //  write out sample
            //
            *(short HUGE_T *)pbDst = (short)nPredSample;
            pbDst += sizeof(short);

            //
            //  sample 2
            //
            nEncSample  = (bSample >> 4);
            nStepSize   = step[nStepIndex];
            nPredSample = imaadpcmSampleDecode(nEncSample, nPredSample, nStepSize);
            nStepIndex  = imaadpcmNextStepIndex(nEncSample, nStepIndex);

            //
            //  write out sample
            //
            *(short HUGE_T *)pbDst = (short)nPredSample;
            pbDst += sizeof(short);
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // imaadpcmDecode4Bit_M16()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL imaadpcmDecode4Bit_S08
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
)
{
    HPBYTE                  pbDstStart;
    UINT                    cbHeader;
    UINT                    cbBlockLength;
    int                     nStepSize;
    DWORD                   dwHeader;
    DWORD                   dwLeft;
    DWORD                   dwRight;
    int                     i;

    int                     nEncSampleL;
    int                     nPredSampleL;
    int                     nStepIndexL;

    int                     nEncSampleR;
    int                     nPredSampleR;
    int                     nStepIndexR;

    
    pbDstStart = pbDst;
    cbHeader = IMAADPCM_HEADER_LENGTH * 2;  //  2 = number of channels.


    DPF(3,"Starting imaadpcmDecode4Bit_S08().");


    //
    //
    //
    while( 0 != cbSrcLength )
    {
        //
        //  The data should always be block aligned.
        //
        ASSERT( cbSrcLength >= nBlockAlignment );

        cbBlockLength  = nBlockAlignment;
        cbSrcLength   -= cbBlockLength;
        cbBlockLength -= cbHeader;


        //
        //  LEFT channel header
        //
        dwHeader = *(DWORD HUGE_T *)pbSrc;
        pbSrc   += sizeof(DWORD);
        nPredSampleL = (int)(short)LOWORD(dwHeader);
        nStepIndexL  = (int)(BYTE)HIWORD(dwHeader);

        if( !imaadpcmValidStepIndex(nStepIndexL) ) {
            //
            //  The step index is out of range - this is considered a fatal
            //  error as the input stream is corrupted.  We fail by returning
            //  zero bytes converted.
            //
            DPF(1,"imaadpcmDecode4Bit_S08: invalid step index (L).");
            return 0;
        }
        
        //
        //  RIGHT channel header
        //
        dwHeader = *(DWORD HUGE_T *)pbSrc;
        pbSrc   += sizeof(DWORD);
        nPredSampleR = (int)(short)LOWORD(dwHeader);
        nStepIndexR  = (int)(BYTE)HIWORD(dwHeader);

        if( !imaadpcmValidStepIndex(nStepIndexR) ) {
            //
            //  The step index is out of range - this is considered a fatal
            //  error as the input stream is corrupted.  We fail by returning
            //  zero bytes converted.
            //
            DPF(1,"imaadpcmDecode4Bit_S08: invalid step index (R).");
            return 0;
        }
        

        //
        //  write out first sample
        //
        *pbDst++ = (BYTE)((nPredSampleL >> 8) + 128);
        *pbDst++ = (BYTE)((nPredSampleR >> 8) + 128);


        //
        //  The first DWORD contains 4 left samples, the second DWORD
        //  contains 4 right samples.  We process the source in 8-byte
        //  chunks to make it easy to interleave the output correctly.
        //
        ASSERT( 0 == cbBlockLength%8 );
        while( 0 != cbBlockLength )
        {
            cbBlockLength -= 8;

            dwLeft   = *(DWORD HUGE_T *)pbSrc;
            pbSrc   += sizeof(DWORD);
            dwRight  = *(DWORD HUGE_T *)pbSrc;
            pbSrc   += sizeof(DWORD);

            for( i=8; i>0; i-- )
            {
                //
                //  LEFT channel
                //
                nEncSampleL  = (dwLeft & 0x0F);
                nStepSize    = step[nStepIndexL];
                nPredSampleL = imaadpcmSampleDecode(nEncSampleL, nPredSampleL, nStepSize);
                nStepIndexL  = imaadpcmNextStepIndex(nEncSampleL, nStepIndexL);

                //
                //  RIGHT channel
                //
                nEncSampleR  = (dwRight & 0x0F);
                nStepSize    = step[nStepIndexR];
                nPredSampleR = imaadpcmSampleDecode(nEncSampleR, nPredSampleR, nStepSize);
                nStepIndexR  = imaadpcmNextStepIndex(nEncSampleR, nStepIndexR);

                //
                //  write out sample
                //
                *pbDst++ = (BYTE)((nPredSampleL >> 8) + 128);
                *pbDst++ = (BYTE)((nPredSampleR >> 8) + 128);

                //
                //  Shift the next input sample into the low-order 4 bits.
                //
                dwLeft  >>= 4;
                dwRight >>= 4;
            }
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // imaadpcmDecode4Bit_S08()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL imaadpcmDecode4Bit_S16
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
)
{
    HPBYTE                  pbDstStart;
    UINT                    cbHeader;
    UINT                    cbBlockLength;
    int                     nStepSize;
    DWORD                   dwHeader;
    DWORD                   dwLeft;
    DWORD                   dwRight;
    int                     i;

    int                     nEncSampleL;
    int                     nPredSampleL;
    int                     nStepIndexL;

    int                     nEncSampleR;
    int                     nPredSampleR;
    int                     nStepIndexR;

    
    pbDstStart = pbDst;
    cbHeader = IMAADPCM_HEADER_LENGTH * 2;  //  2 = number of channels.


    DPF(3,"Starting imaadpcmDecode4Bit_S16().");


    //
    //
    //
    while( 0 != cbSrcLength )
    {
        //
        //  The data should always be block aligned.
        //
        ASSERT( cbSrcLength >= nBlockAlignment );

        cbBlockLength  = nBlockAlignment;
        cbSrcLength   -= cbBlockLength;
        cbBlockLength -= cbHeader;


        //
        //  LEFT channel header
        //
        dwHeader = *(DWORD HUGE_T *)pbSrc;
        pbSrc   += sizeof(DWORD);
        nPredSampleL = (int)(short)LOWORD(dwHeader);
        nStepIndexL  = (int)(BYTE)HIWORD(dwHeader);

        if( !imaadpcmValidStepIndex(nStepIndexL) ) {
            //
            //  The step index is out of range - this is considered a fatal
            //  error as the input stream is corrupted.  We fail by returning
            //  zero bytes converted.
            //
            DPF(1,"imaadpcmDecode4Bit_S16: invalid step index %u (L).", nStepIndexL);
            return 0;
        }
        
        //
        //  RIGHT channel header
        //
        dwHeader = *(DWORD HUGE_T *)pbSrc;
        pbSrc   += sizeof(DWORD);
        nPredSampleR = (int)(short)LOWORD(dwHeader);
        nStepIndexR  = (int)(BYTE)HIWORD(dwHeader);

        if( !imaadpcmValidStepIndex(nStepIndexR) ) {
            //
            //  The step index is out of range - this is considered a fatal
            //  error as the input stream is corrupted.  We fail by returning
            //  zero bytes converted.
            //
            DPF(1,"imaadpcmDecode4Bit_S16: invalid step index %u (R).",nStepIndexR);
            return 0;
        }
        

        //
        //  write out first sample
        //
        *(DWORD HUGE_T *)pbDst = MAKELONG(nPredSampleL, nPredSampleR);
        pbDst += sizeof(DWORD);


        //
        //  The first DWORD contains 4 left samples, the second DWORD
        //  contains 4 right samples.  We process the source in 8-byte
        //  chunks to make it easy to interleave the output correctly.
        //
        ASSERT( 0 == cbBlockLength%8 );
        while( 0 != cbBlockLength )
        {
            cbBlockLength -= 8;

            dwLeft   = *(DWORD HUGE_T *)pbSrc;
            pbSrc   += sizeof(DWORD);
            dwRight  = *(DWORD HUGE_T *)pbSrc;
            pbSrc   += sizeof(DWORD);

            for( i=8; i>0; i-- )
            {
                //
                //  LEFT channel
                //
                nEncSampleL  = (dwLeft & 0x0F);
                nStepSize    = step[nStepIndexL];
                nPredSampleL = imaadpcmSampleDecode(nEncSampleL, nPredSampleL, nStepSize);
                nStepIndexL  = imaadpcmNextStepIndex(nEncSampleL, nStepIndexL);

                //
                //  RIGHT channel
                //
                nEncSampleR  = (dwRight & 0x0F);
                nStepSize    = step[nStepIndexR];
                nPredSampleR = imaadpcmSampleDecode(nEncSampleR, nPredSampleR, nStepSize);
                nStepIndexR  = imaadpcmNextStepIndex(nEncSampleR, nStepIndexR);

                //
                //  write out sample
                //
                *(DWORD HUGE_T *)pbDst = MAKELONG(nPredSampleL, nPredSampleR);
                pbDst += sizeof(DWORD);

                //
                //  Shift the next input sample into the low-order 4 bits.
                //
                dwLeft  >>= 4;
                dwRight >>= 4;
            }
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // imaadpcmDecode4Bit_S16()



//==========================================================================;
//
//     ENCODE ROUTINES
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  DWORD imaadpcmEncode4Bit_M08
//  DWORD imaadpcmEncode4Bit_M16
//  DWORD imaadpcmEncode4Bit_S08
//  DWORD imaadpcmEncode4Bit_S16
//  
//  Description:
//      These functions encode a buffer of data from PCM to ADPCM in the
//      specified format.  The appropriate function is called once for each
//      ACMDM_STREAM_CONVERT message received.  Note that since these
//      functions must share the same prototype as the decoding functions
//      (see acmdStreamOpen() and acmdStreamConvert() in codec.c for more
//      details), not all the parameters are used by these routines.
//  
//  Arguments:
//      HPBYTE pbSrc:  Pointer to the source buffer (PCM data).
//      DWORD cbSrcLength:  The length of the source buffer (in bytes).
//      HPBYTE pbDst:  Pointer to the destination buffer (ADPCM data).  Note
//                      that it is assumed that the destination buffer is
//                      large enough to hold all the encoded data; see
//                      acmdStreamSize() in codec.c for more details.
//      UINT nBlockAlignment:  The block alignment of the ADPCM data (in
//                      bytes);  not used for encoding.
//      UINT cSamplesPerBlock:  The number of samples in each ADPCM block.
//      int *pnStepIndexL:  Pointer to the step index value (left channel)
//                      in the STREAMINSTANCE structure; this is used to
//                      maintain the step index across converts.
//      int *pnStepIndexR:  Pointer to the step index value (right channel)
//                      in the STREAMINSTANCE structure; this is used to 
//                      maintain the step index across converts.  It is only
//                      used for stereo converts.
//  
//  Return (DWORD):  The number of bytes used in the destination buffer.
//  
//--------------------------------------------------------------------------;

DWORD FNGLOBAL imaadpcmEncode4Bit_M08
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
)
{
    HPBYTE                  pbDstStart;
    DWORD                   cSrcSamples;
    UINT                    cBlockSamples;
    int                     nSample;
    int                     nStepSize;

    int                     nEncSample1;
    int                     nEncSample2;
    int                     nPredSample;
    int                     nStepIndex;


    pbDstStart = pbDst;
    cSrcSamples = pcmM08BytesToSamples(cbSrcLength);

    //
    //  Restore the Step Index to that of the final convert of the previous
    //  buffer.  Remember to restore this value to psi->nStepIndexL.
    //
    nStepIndex = (*pnStepIndexL);


    //
    //
    //
    //
    while (0 != cSrcSamples)
    {
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;

        //
        //  block header
        //
        nPredSample = ((short)*pbSrc++ - 128) << 8;
        cBlockSamples--;

        *(LONG HUGE_T *)pbDst = MAKELONG(nPredSample, nStepIndex);
        pbDst += sizeof(LONG);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).  Note
        //  that if we don't have enough data to fill a complete byte, then
        //  we add a 0 nibble on the end.
        //
        while( cBlockSamples>0 )
        {
            //
            //  sample 1
            //
            nSample = ((short)*pbSrc++ - 128) << 8;
            cBlockSamples--;

            nStepSize    = step[nStepIndex];
            imaadpcmFastEncode(nEncSample1,nPredSample,nSample,nStepSize);
            nStepIndex   = imaadpcmNextStepIndex(nEncSample1, nStepIndex);

            //
            //  sample 2
            //
            nEncSample2  = 0;
            if( cBlockSamples>0 ) {

                nSample = ((short)*pbSrc++ - 128) << 8;
                cBlockSamples--;

                nStepSize    = step[nStepIndex];
                imaadpcmFastEncode(nEncSample2,nPredSample,nSample,nStepSize);
                nStepIndex   = imaadpcmNextStepIndex(nEncSample2, nStepIndex);
            }

            //
            //  Write out encoded byte.
            //
            *pbDst++ = (BYTE)(nEncSample1 | (nEncSample2 << 4));
        }
    }


    //
    //  Restore the value of the Step Index, to be used on the next buffer.
    //
    (*pnStepIndexL) = nStepIndex;


    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // imaadpcmEncode4Bit_M08()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL imaadpcmEncode4Bit_M16
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
)
{
    HPBYTE                  pbDstStart;
    DWORD                   cSrcSamples;
    UINT                    cBlockSamples;
    int                     nSample;
    int                     nStepSize;

    int                     nEncSample1;
    int                     nEncSample2;
    int                     nPredSample;
    int                     nStepIndex;


    pbDstStart = pbDst;
    cSrcSamples = pcmM16BytesToSamples(cbSrcLength);

    //
    //  Restore the Step Index to that of the final convert of the previous
    //  buffer.  Remember to restore this value to psi->nStepIndexL.
    //
    nStepIndex = (*pnStepIndexL);


    //
    //
    //
    //
    while (0 != cSrcSamples)
    {
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;

        //
        //  block header
        //
        nPredSample = *(short HUGE_T *)pbSrc;
        pbSrc += sizeof(short);
        cBlockSamples--;

        *(LONG HUGE_T *)pbDst = MAKELONG(nPredSample, nStepIndex);
        pbDst += sizeof(LONG);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).  Note
        //  that if we don't have enough data to fill a complete byte, then
        //  we add a 0 nibble on the end.
        //
        while( cBlockSamples>0 )
        {
            //
            //  sample 1
            //
            nSample = *(short HUGE_T *)pbSrc;
            pbSrc  += sizeof(short);
            cBlockSamples--;

            nStepSize    = step[nStepIndex];
            imaadpcmFastEncode(nEncSample1,nPredSample,nSample,nStepSize);
            nStepIndex   = imaadpcmNextStepIndex(nEncSample1, nStepIndex);

            //
            //  sample 2
            //
            nEncSample2  = 0;
            if( cBlockSamples>0 ) {

                nSample = *(short HUGE_T *)pbSrc;
                pbSrc  += sizeof(short);
                cBlockSamples--;

                nStepSize    = step[nStepIndex];
                imaadpcmFastEncode(nEncSample2,nPredSample,nSample,nStepSize);
                nStepIndex   = imaadpcmNextStepIndex(nEncSample2, nStepIndex);
            }

            //
            //  Write out encoded byte.
            //
            *pbDst++ = (BYTE)(nEncSample1 | (nEncSample2 << 4));
        }
    }


    //
    //  Restore the value of the Step Index, to be used on the next buffer.
    //
    (*pnStepIndexL) = nStepIndex;


    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // imaadpcmEncode4Bit_M16()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL imaadpcmEncode4Bit_S08
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
)
{
    HPBYTE                  pbDstStart;
    DWORD                   cSrcSamples;
    UINT                    cBlockSamples;
    int                     nSample;
    int                     nStepSize;
    DWORD                   dwLeft;
    DWORD                   dwRight;
    int                     i;

    int                     nEncSampleL;
    int                     nPredSampleL;
    int                     nStepIndexL;

    int                     nEncSampleR;
    int                     nPredSampleR;
    int                     nStepIndexR;


    pbDstStart = pbDst;
    cSrcSamples = pcmS08BytesToSamples(cbSrcLength);

    //
    //  Restore the Step Index to that of the final convert of the previous
    //  buffer.  Remember to restore this value to psi->nStepIndexL,R.
    //
    nStepIndexL = (*pnStepIndexL);
    nStepIndexR = (*pnStepIndexR);


    //
    //
    //
    //
    while( 0 != cSrcSamples )
    {
        //
        //  The samples should always be block aligned.
        //
        ASSERT( cSrcSamples >= cSamplesPerBlock );

        cBlockSamples = cSamplesPerBlock;
        cSrcSamples  -= cBlockSamples;

        //
        //  LEFT channel block header
        //
        nPredSampleL = ((short)*pbSrc++ - 128) << 8;

        *(LONG HUGE_T *)pbDst = MAKELONG(nPredSampleL, nStepIndexL);
        pbDst += sizeof(LONG);

        //
        //  RIGHT channel block header
        //
        nPredSampleR = ((short)*pbSrc++ - 128) << 8;

        *(LONG HUGE_T *)pbDst = MAKELONG(nPredSampleR, nStepIndexR);
        pbDst += sizeof(LONG);


        cBlockSamples--;  // One sample is in the header.


        //
        //  We have written the header for this block--now write the data
        //  chunk.  This consists of 8 left samples (one DWORD of output)
        //  followed by 8 right samples (also one DWORD).  Since the input
        //  samples are interleaved, we create the left and right DWORDs
        //  sample by sample, and then write them both out.
        //
        ASSERT( 0 == cBlockSamples%8 );
        while( 0 != cBlockSamples )
        {
            cBlockSamples -= 8;
            dwLeft  = 0;
            dwRight = 0;

            for( i=0; i<8; i++ )
            {
                //
                //  LEFT channel
                //
                nSample     = ((short)*pbSrc++ - 128) << 8;
                nStepSize   = step[nStepIndexL];
                imaadpcmFastEncode(nEncSampleL,nPredSampleL,nSample,nStepSize);
                nStepIndexL = imaadpcmNextStepIndex(nEncSampleL, nStepIndexL);
                dwLeft     |= ((DWORD)nEncSampleL) << 4*i;

                //
                //  RIGHT channel
                //
                nSample     = ((short)*pbSrc++ - 128) << 8;
                nStepSize   = step[nStepIndexR];
                imaadpcmFastEncode(nEncSampleR,nPredSampleR,nSample,nStepSize);
                nStepIndexR = imaadpcmNextStepIndex(nEncSampleR, nStepIndexR);
                dwRight    |= ((DWORD)nEncSampleR) << 4*i;
            }


            //
            //  Write out encoded DWORDs.
            //
            *(DWORD HUGE_T *)pbDst = dwLeft;
            pbDst += sizeof(DWORD);
            *(DWORD HUGE_T *)pbDst = dwRight;
            pbDst += sizeof(DWORD);
        }
    }


    //
    //  Restore the value of the Step Index, to be used on the next buffer.
    //
    (*pnStepIndexL) = nStepIndexL;
    (*pnStepIndexR) = nStepIndexR;


    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // imaadpcmEncode4Bit_S08()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL imaadpcmEncode4Bit_S16
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
)
{
    HPBYTE                  pbDstStart;
    DWORD                   cSrcSamples;
    UINT                    cBlockSamples;
    int                     nSample;
    int                     nStepSize;
    DWORD                   dwLeft;
    DWORD                   dwRight;
    int                     i;

    int                     nEncSampleL;
    int                     nPredSampleL;
    int                     nStepIndexL;

    int                     nEncSampleR;
    int                     nPredSampleR;
    int                     nStepIndexR;


    pbDstStart = pbDst;
    cSrcSamples = pcmS16BytesToSamples(cbSrcLength);

    //
    //  Restore the Step Index to that of the final convert of the previous
    //  buffer.  Remember to restore this value to psi->nStepIndexL,R.
    //
    nStepIndexL = (*pnStepIndexL);
    nStepIndexR = (*pnStepIndexR);


    //
    //
    //
    //
    while( 0 != cSrcSamples )
    {
        //
        //  The samples should always be block aligned.
        //
        ASSERT( cSrcSamples >= cSamplesPerBlock );

        cBlockSamples = cSamplesPerBlock;
        cSrcSamples  -= cBlockSamples;


        //
        //  LEFT channel block header
        //
        nPredSampleL = *(short HUGE_T *)pbSrc;
        pbSrc += sizeof(short);

        *(LONG HUGE_T *)pbDst = MAKELONG(nPredSampleL, nStepIndexL);
        pbDst += sizeof(LONG);

        //
        //  RIGHT channel block header
        //
        nPredSampleR = *(short HUGE_T *)pbSrc;
        pbSrc += sizeof(short);

        *(LONG HUGE_T *)pbDst = MAKELONG(nPredSampleR, nStepIndexR);
        pbDst += sizeof(LONG);


        cBlockSamples--;  // One sample is in the header.


        //
        //  We have written the header for this block--now write the data
        //  chunk.  This consists of 8 left samples (one DWORD of output)
        //  followed by 8 right samples (also one DWORD).  Since the input
        //  samples are interleaved, we create the left and right DWORDs
        //  sample by sample, and then write them both out.
        //
        ASSERT( 0 == cBlockSamples%8 );
        while( 0 != cBlockSamples )
        {
            cBlockSamples -= 8;
            dwLeft  = 0;
            dwRight = 0;

            for( i=0; i<8; i++ )
            {
                //
                //  LEFT channel
                //
                nSample = *(short HUGE_T *)pbSrc;
                pbSrc  += sizeof(short);

                nStepSize   = step[nStepIndexL];
                imaadpcmFastEncode(nEncSampleL,nPredSampleL,nSample,nStepSize);
                nStepIndexL = imaadpcmNextStepIndex(nEncSampleL, nStepIndexL);
                dwLeft     |= ((DWORD)nEncSampleL) << 4*i;

                //
                //  RIGHT channel
                //
                nSample = *(short HUGE_T *)pbSrc;
                pbSrc  += sizeof(short);

                nStepSize   = step[nStepIndexR];
                imaadpcmFastEncode(nEncSampleR,nPredSampleR,nSample,nStepSize);
                nStepIndexR = imaadpcmNextStepIndex(nEncSampleR, nStepIndexR);
                dwRight    |= ((DWORD)nEncSampleR) << 4*i;
            }


            //
            //  Write out encoded DWORDs.
            //
            *(DWORD HUGE_T *)pbDst = dwLeft;
            pbDst += sizeof(DWORD);
            *(DWORD HUGE_T *)pbDst = dwRight;
            pbDst += sizeof(DWORD);
        }
    }


    //
    //  Restore the value of the Step Index, to be used on the next buffer.
    //
    (*pnStepIndexL) = nStepIndexL;
    (*pnStepIndexR) = nStepIndexR;


    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // imaadpcmEncode4Bit_S16()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\imaadpcm\config.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1998 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  config.c
//
//  Description:
//	    IMA ADPCM codec configuration init and dialog
//
//
//	The configuration parameters for this codec are:
//
//	    MaxRTEncodeSetting:
//	    MaxRTDecodeSetting:
//		These determine the highest mono sample rate that
//		the codec will attempt to convert in real-time.
//
//	    PercentCPU:
//		This configuration parameter is not normally changed
//		by the user and is not presented in the config dialog.
//		This value affects the config dialog's 'Auto-Config'
//		calculation of MaxRTXxcodeSetting.
//
//  These parameters may be set in the registry, using the imaadpcm subkey
//  (which corresponds to the alias name used for installation) under
//  the following key:
//
//      HKEY_CURRENT_USER\Software\Microsoft\Multimedia
//
// 
//  Note:  The configuration dialog is only compiled into the code if the
//      IMAADPCM_USECONFIG symbol is defined.  This is designed to make it
//      easy to remove the dialog box completely for certain platforms,
//      such as MIPS and Alpha under Windows NT.
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "muldiv32.h"

#include "codec.h"
#include "imaadpcm.h"
#include "debug.h"

#ifdef WIN32
#include <tchar.h>
#else
#define _tcstoul strtoul
#define _tcsncpy _fstrncpy
#endif

#include <string.h>
#include <stdlib.h>


#ifndef WIN32
#error Win16 support has been dropped from this codec!  Compile for Win32.
#endif


#ifdef IMAADPCM_USECONFIG


//
//  Strings required to access configuration information in the registry.
//
const TCHAR BCODE gszMaxRTEncodeSetting[]   = TEXT("MaxRTEncodeSetting");
const TCHAR BCODE gszMaxRTDecodeSetting[]   = TEXT("MaxRTDecodeSetting");
const TCHAR BCODE gszPercentCPU[]           = TEXT("PercentCPU");
const TCHAR gszMultimediaKey[] = TEXT("Software\\Microsoft\\Multimedia\\");


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
//  Be careful changing the following!
//
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
//  Data required to access the dialog box help.
//
//  Note that you must write your own help file for your codec, even if
//  the configuration dialog box looks identical.  If you use the file
//  listed here, then the title will say "IMA ADPCM" or something.
//
//  Note:  the number HELPCONTEXT_IMAADPCM must be unique in the file
//          gszHelpFilename, and the number must defined in the [MAP]
//          section of the .hpj help project file.  Then the .rtf file
//          will reference that number (using the keyword defined in
//          the .hpj file).  Then when we call WinHelp with the number,
//          WinHelp will go to the right help entry.
//
const TCHAR BCODE gszHelpFilename[]         = TEXT("audiocdc.hlp");
#define HELPCONTEXT_IMAADPCM          1001
#define IDH_AUDIOCDC_COMPRESSION	  100
#define IDH_AUDIOCDC_DECOMPRESSION    200
#define IDH_AUDIOCDC_AUTOCONFIGURE	  300
static int aKeyWordIds[] = {
				   IDC_COMBO_MAXRTENCODE, IDH_AUDIOCDC_COMPRESSION,
				   IDC_STATIC_COMPRESS, IDH_AUDIOCDC_COMPRESSION,
				   IDC_COMBO_MAXRTDECODE, IDH_AUDIOCDC_DECOMPRESSION,
				   IDC_STATIC_DECOMPRESS, IDH_AUDIOCDC_DECOMPRESSION,
				   IDC_BTN_AUTOCONFIG, IDH_AUDIOCDC_AUTOCONFIGURE,
				   0, 0
			       };




//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  VOID configWriteConfiguration
//  
//  Description:
//
//      This routine writes the configuration data in PDI to the registry.
//      This consists of the max real-time Encode and Decode settings.
//  
//  Arguments:
//      PDRIVERINSTANCE     pdi
//  
//  Return (VOID):  None.
//  
//--------------------------------------------------------------------------;

VOID configWriteConfiguration
(
    PDRIVERINSTANCE     pdi
)
{
    DWORD               dw;


    if( NULL != pdi->hkey )
    {
        dw   = (DWORD)pdi->nConfigMaxRTEncodeSetting;
        (void)RegSetValueEx( pdi->hkey, (LPTSTR)gszMaxRTEncodeSetting, 0,
                                REG_DWORD, (LPBYTE)&dw, sizeof(DWORD) );

        dw   = (DWORD)pdi->nConfigMaxRTDecodeSetting;
        (void)RegSetValueEx( pdi->hkey, (LPTSTR)gszMaxRTDecodeSetting, 0,
                                REG_DWORD, (LPBYTE)&dw, sizeof(DWORD) );
    }
}


//--------------------------------------------------------------------------;
//  
//  DWORD dwReadRegistryDefault
//  
//  Description:
//
//      This routine reads a given value from the registry, and returns a
//      default value if the read is not successful.
//  
//  Arguments:
//      HKEY    hkey:               Registry key to read from.
//      LPTSTR  lpszEntry:
//      DWORD   dwDefault:
//  
//  Return (DWORD):
//  
//--------------------------------------------------------------------------;

INLINE DWORD dwReadRegistryDefault
(
    HKEY                hkey,
    LPTSTR              lpszEntry,
    DWORD               dwDefault
)
{
    DWORD   dwType = (DWORD)~REG_DWORD;  // Init to anything but REG_DWORD.
    DWORD   cbSize = sizeof(DWORD);
    DWORD   dwRet;
    LONG    lError;

    ASSERT( NULL != hkey );
    ASSERT( NULL != lpszEntry );


    lError = RegQueryValueEx( hkey,
                              lpszEntry,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwRet,
                              &cbSize );

    if( ERROR_SUCCESS != lError  ||  REG_DWORD != dwType )
        dwRet = dwDefault;

    return dwRet;
}


//--------------------------------------------------------------------------;
//  
//  VOID configSetDefaults
//  
//  Description:
//
//      This routine sets the configuration parameters to their default
//      values.
//  
//  Arguments:
//      PDRIVERINSTANCE pdi:
//  
//--------------------------------------------------------------------------;

VOID configSetDefaults
(
    PDRIVERINSTANCE     pdi
)
{
    pdi->nConfigMaxRTEncodeSetting =
            IMAADPCM_CONFIG_DEFAULT_MAXRTENCODESETTING;

    pdi->nConfigMaxRTDecodeSetting =
            IMAADPCM_CONFIG_DEFAULT_MAXRTDECODESETTING;

    pdi->nConfigPercentCPU =
            IMAADPCM_CONFIG_DEFAULT_PERCENTCPU;
}


//--------------------------------------------------------------------------;
//  
//  UINT configAutoConfig
//  
//  Description:
//
//	We will determine how much time it takes to encode and then decode
//	2 seconds of data and use this to guess at the max sample
//	rate we can convert in real-time.
//
//	The max is computed with essentially 100% of the CPU.  Practically,
//	we won't have 100% of the CPU available.  So we take a percentage
//	of the computed max and use that as the max in the config dialog.
//
//	The percentage that we use can be set in the ini file imaadpcm
//	section by PercentCPU=xx.
//
//  
//  Arguments:
//      HWND hwnd:
//  
//  Return (UINT):  String identifier (IDS) of error message, or zero if
//      the call succeeded.
//  
//--------------------------------------------------------------------------;

UINT FNLOCAL configAutoConfig
(
    PDRIVERINSTANCE             pdi,
    UINT                        *pnEncodeSetting,
    UINT                        *pnDecodeSetting
)
{
    LPPCMWAVEFORMAT             pwfPCM = NULL;
    LPIMAADPCMWAVEFORMAT        pwfADPCM = NULL;
    LPACMDRVFORMATSUGGEST       padfs = NULL;
    LPACMDRVSTREAMINSTANCE      padsi = NULL;
    LPACMDRVSTREAMHEADER        padsh = NULL;
    LPACMDRVSTREAMSIZE          padss = NULL;
    PSTREAMINSTANCE             psi = NULL;

    LPBYTE                      pBufPCM;
    LPBYTE                      pBufADPCM;
    DWORD                       cbPCM;
    DWORD                       cbADPCM;

    DWORD                       dwEncodeTime;
    DWORD                       dwDecodeTime;
    DWORD                       dwStartTime;
    DWORD                       dwMaxEncodeRate;
    DWORD                       dwMaxDecodeRate;

    UINT                        nConfig;

    UINT                        uIDS;
    HCURSOR                     hCursorSave;


    //
    //  We divide by this!
    //
    ASSERT( 0 != pdi->nConfigPercentCPU );


    uIDS = 0;       // No errors yet - this is our "success" return.
    

    //
    // This function may take a while.  Set hour glass cursor
    //
    hCursorSave     = SetCursor(LoadCursor(NULL, IDC_WAIT));


    //
    //  Set up the input PCM wave format structure.
    //
    pwfPCM  = (LPPCMWAVEFORMAT)GlobalAllocPtr( GPTR, sizeof(*pwfPCM) );
    if( NULL == pwfPCM )
    {
        uIDS = IDS_ERROR_NOMEM;
        goto errReturn;
    }

    pwfPCM->wf.wFormatTag       = WAVE_FORMAT_PCM;      // Mono 16-bit!!!
    pwfPCM->wf.nChannels        = 1;
    pwfPCM->wf.nSamplesPerSec   = 8000;
    pwfPCM->wf.nBlockAlign      = 2;
    pwfPCM->wBitsPerSample      = 16;
    pwfPCM->wf.nAvgBytesPerSec  = pwfPCM->wf.nSamplesPerSec *
                                    pwfPCM->wf.nBlockAlign;


    //
    //  Get this driver to suggest a format to convert to.  Note:  we may
    //  want to constrain the suggestion partly, depending on the
    //  capabilities of the codec.  We should always choose the most
    //  complex conversion if there are several possibilities.
    //
    padfs       = (LPACMDRVFORMATSUGGEST)GlobalAllocPtr( GPTR, sizeof(*padfs) );
    pwfADPCM    = (LPIMAADPCMWAVEFORMAT)GlobalAllocPtr( GPTR, sizeof(*pwfADPCM) );
    if( NULL == padfs  ||  NULL == pwfADPCM )
    {
        uIDS = IDS_ERROR_NOMEM;
        goto errReturn;
    }

    padfs->cbStruct             = sizeof(*padfs);
    padfs->fdwSuggest           = 0;                // Default everything.
    padfs->pwfxSrc              = (LPWAVEFORMATEX)pwfPCM;
    padfs->cbwfxSrc             = sizeof(*pwfPCM);
    padfs->pwfxDst              = (LPWAVEFORMATEX)pwfADPCM;
    padfs->cbwfxDst             = sizeof(*pwfADPCM);

    (void)acmdFormatSuggest( pdi, padfs );  // This will always work, right?


    //
    //  Set stream instance data.  Note: we assume that the members that
    //  we don't set here never actually get used.  Make sure that this
    //  is really true!
    //
    padsi       = (LPACMDRVSTREAMINSTANCE)GlobalAllocPtr( GPTR, sizeof(*padsi) );
    psi         = (PSTREAMINSTANCE)LocalAlloc( LPTR, sizeof(*psi) );
    if( NULL == padsi  ||  NULL == psi )
    {
        uIDS = IDS_ERROR_NOMEM;
        goto errReturn;
    }

    // Make sure that psi->fnConvert matches the PCM format in pwfPCM!!!
    psi->fnConvert              = imaadpcmEncode4Bit_M16;
    psi->fdwConfig              = pdi->fdwConfig;
    psi->nStepIndexL            = 0;
    psi->nStepIndexR            = 0;

    //  Make sure that no other members of padsi are used!!!
    padsi->cbStruct             = sizeof(*padsi);
    padsi->pwfxSrc              = (LPWAVEFORMATEX)pwfPCM;
    padsi->pwfxDst              = (LPWAVEFORMATEX)pwfADPCM;
    padsi->dwDriver             = (DWORD_PTR)psi;


    //
    //  Now, get the driver to tell us how much space is required for the
    //  destination buffer.
    //
    cbPCM       = IMAADPCM_CONFIGTESTTIME * pwfPCM->wf.nAvgBytesPerSec;

    padss       = (LPACMDRVSTREAMSIZE)GlobalAllocPtr( GPTR, sizeof(*padss) );
    if( NULL == padss )
    {
        uIDS = IDS_ERROR_NOMEM;
        goto errReturn;
    }

    padss->cbStruct             = sizeof(padss);
    padss->fdwSize              = ACM_STREAMSIZEF_SOURCE;
    padss->cbSrcLength          = cbPCM;

    (void)acmdStreamSize( padsi, padss );   // This will always work, right?


    //
    //  Allocate source and destination buffers.  Note that we specifically
    //  don't zero-initialize them, so that we will get random PCM data in
    //  the PCM buffer.                           
    //
    cbADPCM     = padss->cbDstLength;
    pBufPCM     = (LPBYTE)GlobalAllocPtr( GMEM_FIXED, (UINT)cbPCM );
    pBufADPCM   = (LPBYTE)GlobalAllocPtr( GMEM_FIXED, (UINT)cbADPCM );
    if( NULL == pBufPCM  || NULL == pBufADPCM )
    {
        uIDS = IDS_ERROR_NOMEM;
        goto errReturn;
    }


    //
    //  Now, tell the driver to convert our buffer and measure the time.
    //  Note that we don't care what is in the source buffer, we only
    //  care how long it takes.
    //
    padsh       = (LPACMDRVSTREAMHEADER)GlobalAllocPtr( GPTR, sizeof(*padsh) );
    if( NULL == padsh )
    {
        uIDS = IDS_ERROR_NOMEM;
        goto errReturn;
    }

    //  Make sure that no other members of padsh are used!!!
    padsh->cbStruct             = sizeof(*padsh);
    padsh->pbSrc                = pBufPCM;
    padsh->cbSrcLength          = cbPCM;
    padsh->pbDst                = pBufADPCM;
    padsh->cbDstLength          = cbADPCM;
    padsh->fdwConvert           = 0;        // Should be 0 already, but...

    dwStartTime     = timeGetTime();
    (void)acmdStreamConvert( pdi, padsi, padsh );   // Won't fail?!
    dwEncodeTime    = timeGetTime() - dwStartTime;


    //
    //  Now, we have an encoded IMA ADPCM buffer.  Tell the driver to
    //  convert it back to PCM, measuring the time.  First we reset the
    //  size of the ADPCM buffer to correspond with the buffer returned
    //  by the convert.  Then we zero out our structure buffers and reset
    //  them for the new conversion.  Note: we assume that the PCM buffer
    //  is already large enough to handle the conversion.
    //
    cbADPCM                     = padsh->cbDstLengthUsed;

#ifdef WIN32
    ZeroMemory( psi, sizeof(*psi) );
    ZeroMemory( padsi, sizeof(*padsi) );
    ZeroMemory( padsh, sizeof(*padsh) );
#else
    _fmemset( psi, 0, sizeof(*psi) );
    _fmemset( padsi, 0, sizeof(*padsi) );
    _fmemset( padsh, 0, sizeof(*padsh) );
#endif

    // Make sure that psi->fnConvert matches the format in pfwADPCM!!!
    psi->fnConvert              = imaadpcmDecode4Bit_M16;
    psi->fdwConfig              = pdi->fdwConfig;
    psi->nStepIndexL            = 0;
    psi->nStepIndexR            = 0;

    //  Make sure that no other members of padsi are used!!!
    padsi->cbStruct             = sizeof(*padsi);
    padsi->pwfxSrc              = (LPWAVEFORMATEX)pwfADPCM;
    padsi->pwfxDst              = (LPWAVEFORMATEX)pwfPCM;
    padsi->dwDriver             = (DWORD_PTR)psi;

    //  Make sure that no other members of padsh are used!!!
    padsh->cbStruct             = sizeof(*padsh);
    padsh->pbSrc                = pBufADPCM;
    padsh->cbSrcLength          = cbADPCM;
    padsh->pbDst                = pBufPCM;
    padsh->cbDstLength          = cbPCM;
    padsh->fdwConvert           = 0;        // Should be 0 already, but...

    dwStartTime     = timeGetTime();
    (void)acmdStreamConvert( pdi, padsi, padsh );   // Won't fail?!
    dwDecodeTime    = timeGetTime() - dwStartTime;


    //
    //  Now, figure out the max encode and decode rates implied by the
    //  times required by the conversions.
    //
    if( dwEncodeTime == 0 )
        dwMaxEncodeRate = 0xFFFFFFFFL;
    else
        dwMaxEncodeRate = MulDiv32( pwfPCM->wf.nSamplesPerSec,
                                    1000L * IMAADPCM_CONFIGTESTTIME,
                                    dwEncodeTime )  *
                                pdi->nConfigPercentCPU / 100;

    if( dwDecodeTime == 0 )
        dwMaxDecodeRate = 0xFFFFFFFFL;
    else
        dwMaxDecodeRate = MulDiv32( pwfPCM->wf.nSamplesPerSec,
                                    1000L * IMAADPCM_CONFIGTESTTIME,
                                    dwDecodeTime )  *
                                pdi->nConfigPercentCPU / 100;

    DPF(1,"dwEncodeTime=%d, dwMaxEncodeRate=%d", dwEncodeTime,dwMaxEncodeRate);
    DPF(1,"dwDecodeTime=%d, dwMaxDecodeRate=%d", dwDecodeTime,dwMaxDecodeRate);


    //
    //  Now set the configuration based on these values.  We scan the
    //  gaRateListFormat[] array looking at the dwMonoRate to determine
    //  the appropriate setting.
    //
    //  Encode.
    //
    nConfig = 0;                                                
    while( gaRateListFormat[nConfig].dwMonoRate < dwMaxEncodeRate  &&
           IMAADPCM_CONFIG_NUMSETTINGS > nConfig )
    {
        nConfig++;
    }
    *pnEncodeSetting = nConfig - 1;  // We went too far.

    //
    //  Decode.
    //
    nConfig = 0;                                                
    while( gaRateListFormat[nConfig].dwMonoRate < dwMaxDecodeRate  &&
           IMAADPCM_CONFIG_NUMSETTINGS > nConfig )
    {
        nConfig++;
    }
    *pnDecodeSetting = nConfig - 1;  // We went too far.


    //
    //  Free structure allocations and exit.
    //
    //
errReturn:

    if( NULL != pwfPCM )
        GlobalFreePtr( pwfPCM );

    if( NULL != pwfADPCM )
        GlobalFreePtr( pwfADPCM );
    
    if( NULL != padfs )
        GlobalFreePtr( padfs );
    
    if( NULL != padsi )
        GlobalFreePtr( padsi );
    
    if( NULL != padsh )
        GlobalFreePtr( padsh );
    
    if( NULL != padss )
        GlobalFreePtr( padss );
    
    if( NULL != psi )
        LocalFree( (HLOCAL)psi );

    SetCursor( hCursorSave );

    return uIDS;
}


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  INT_PTR acmdDlgProcConfigure
//  
//  Description:
//      This routine handles the configuration dialog box.
//  
//  Arguments:
//      HWND hwnd:
//  
//      UINT uMsg:
//  
//      WPARAM wParam:
//  
//      LPARAM lParam:
//  
//  Return (BOOL):
//
//
//  Note:  In order to avoid using a static fHelpRunning flag which will
//          still be here after we exit, we allocate an fHelpRunning
//          variable in the DRIVERINSTANCE structure.  This is purely to
//          avoid static variables (which force us to have a data segment
//          of 4K); the fHelpRunning is not used in any other procedures.
//  
//--------------------------------------------------------------------------;

INT_PTR FNWCALLBACK acmdDlgProcConfigure
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    PDRIVERINSTANCE     pdi;
    
    HWND                hctrlEnc;
    HWND                hctrlDec;
    UINT                uCmdId;
    UINT                u;
    int                 n;
    TCHAR               szFormat[IMAADPCM_CONFIG_TEXTLEN];
    TCHAR               szOutput[IMAADPCM_CONFIG_TEXTLEN];

    UINT                nConfigMaxRTEncodeSetting;
    UINT                nConfigMaxRTDecodeSetting;


    switch (uMsg)
    {
        case WM_INITDIALOG:

            pdi = (PDRIVERINSTANCE)(UINT_PTR)lParam;
            pdi->fHelpRunning = FALSE;  // Used only in this procedure.

#ifdef WIN4
            //
            //  This driver is marked Windows Subsystem version 3.5 in order
            //  that it be compatible with Daytona - however, that means that
            //  Chicago will think it is a Win 3.1 application and give it
            //  Win 3.1 default colors.  This makes the config dialog look
            //  white, whereas the Chicago default uses 3DFACE.  This code
            //  (and the CTLCOLOR messages) sets the colors explicitly.
            //
            pdi->hbrDialog = CreateSolidBrush( GetSysColor(COLOR_3DFACE) );
#endif
	    
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);

            nConfigMaxRTEncodeSetting = pdi->nConfigMaxRTEncodeSetting;
            nConfigMaxRTDecodeSetting = pdi->nConfigMaxRTDecodeSetting;

            hctrlEnc = GetDlgItem(hwnd, IDC_COMBO_MAXRTENCODE);
            hctrlDec = GetDlgItem(hwnd, IDC_COMBO_MAXRTDECODE);

            for( u=0; u<IMAADPCM_CONFIG_NUMSETTINGS; u++ )
            {
                LoadString( pdi->hinst, gaRateListFormat[u].idsFormat,
                            szFormat, SIZEOF(szFormat) );

                switch( gaRateListFormat[u].uFormatType )
                {
                    case CONFIG_RLF_NONUMBER:
                        lstrcpy( szOutput, szFormat );
                        break;

                    case CONFIG_RLF_MONOONLY:
                        wsprintf( szOutput, szFormat,
                                    gaRateListFormat[u].dwMonoRate );
                        break;

                    case CONFIG_RLF_STEREOONLY:
                        wsprintf( szOutput, szFormat,
                                    gaRateListFormat[u].dwMonoRate / 2 );
                        break;

                    case CONFIG_RLF_MONOSTEREO:
                        wsprintf( szOutput, szFormat,
                                    gaRateListFormat[u].dwMonoRate,
                                    gaRateListFormat[u].dwMonoRate / 2 );
                        break;
                }

                ComboBox_AddString(hctrlEnc, szOutput);
                ComboBox_AddString(hctrlDec, szOutput);
            }

            ComboBox_SetCurSel( hctrlEnc, nConfigMaxRTEncodeSetting );
            ComboBox_SetCurSel( hctrlDec, nConfigMaxRTDecodeSetting );

            return (TRUE);

	case WM_DESTROY:

            pdi = (PDRIVERINSTANCE)GetWindowLongPtr(hwnd, DWLP_USER);
	    if (pdi->fHelpRunning)
	    {
		WinHelp(hwnd, gszHelpFilename, HELP_QUIT, 0L);
	    }
#ifdef WIN4
            DeleteObject( pdi->hbrDialog );
#endif

	    //
	    // Let dialog box process this message
	    //
	    //
	    return (FALSE);

#ifdef WIN4
        //
        //  Handle CTLCOLOR messages to get the dialog boxes to the default
        //  Chicago colors.  See the INITDIALOG message, above.
        //
        case WM_CTLCOLORSTATIC:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLORBTN:
            SetTextColor( (HDC)wParam, GetSysColor(COLOR_WINDOWTEXT) );
            SetBkColor( (HDC)wParam, GetSysColor(COLOR_3DFACE) );
            pdi = (PDRIVERINSTANCE)GetWindowLongPtr(hwnd, DWLP_USER);
            return (UINT_PTR)pdi->hbrDialog;
#endif

		case WM_HELP:
			WinHelp(((LPHELPINFO)lParam)->hItemHandle, gszHelpFilename,
				HELP_WM_HELP, (ULONG_PTR)aKeyWordIds);
			return (TRUE);

        case WM_COMMAND:

            pdi = (PDRIVERINSTANCE)GetWindowLongPtr(hwnd, DWLP_USER);

            uCmdId = (UINT) wParam;

            switch (uCmdId)
            {
                case IDC_BTN_AUTOCONFIG:
                    {
                        UINT        uErrorIDS;

                        uErrorIDS   = configAutoConfig( pdi,
                                            &nConfigMaxRTEncodeSetting,
                                            &nConfigMaxRTDecodeSetting );
                        if( 0==uErrorIDS )
                        {
                            //
                            //  No error - set dialog box settings.
                            //
                            hctrlEnc = GetDlgItem( hwnd, IDC_COMBO_MAXRTENCODE );
                            ComboBox_SetCurSel( hctrlEnc, nConfigMaxRTEncodeSetting );
                            hctrlDec = GetDlgItem( hwnd, IDC_COMBO_MAXRTDECODE );
                            ComboBox_SetCurSel( hctrlDec, nConfigMaxRTDecodeSetting );
                        }
                        else
                        {
                            //
                            //  Display error message.
                            //
                            TCHAR       tstrErr[200];
                            TCHAR       tstrErrTitle[200];

                            if (0 == LoadString(pdi->hinst, IDS_ERROR, tstrErrTitle, SIZEOF(tstrErrTitle)))
                                break;
                            if (0 == LoadString(pdi->hinst, uErrorIDS, tstrErr, SIZEOF(tstrErr)))
                                break;
                            MessageBox(hwnd, tstrErr, tstrErrTitle, MB_ICONEXCLAMATION | MB_OK);
                        }
                    }
                    break;


                case IDOK:
                    n = DRVCNF_CANCEL;

                    //
                    //  RT Encode setting
                    //
                    hctrlEnc = GetDlgItem(hwnd, IDC_COMBO_MAXRTENCODE);
                    nConfigMaxRTEncodeSetting = ComboBox_GetCurSel( hctrlEnc );
                    if (nConfigMaxRTEncodeSetting != pdi->nConfigMaxRTEncodeSetting)
                    {
                        pdi->nConfigMaxRTEncodeSetting = nConfigMaxRTEncodeSetting;
                        n = DRVCNF_OK;
                    }

                    //
                    //  RT Decode setting
                    //
                    hctrlDec = GetDlgItem(hwnd, IDC_COMBO_MAXRTDECODE);
                    nConfigMaxRTDecodeSetting = ComboBox_GetCurSel( hctrlDec );
                    if (nConfigMaxRTDecodeSetting != pdi->nConfigMaxRTDecodeSetting)
                    {
                        pdi->nConfigMaxRTDecodeSetting = nConfigMaxRTDecodeSetting;
                        n = DRVCNF_OK;
                    }

                    //
                    //  If we changed something, write the data to the
                    //  registry.
                    //
                    if( DRVCNF_OK == n )
                    {
                        configWriteConfiguration( pdi );
                    }

                    EndDialog(hwnd, DRVCNF_OK);
                    break;


                case IDCANCEL:
                    EndDialog(hwnd, DRVCNF_CANCEL);
                    break;

                case IDC_BTN_HELP:
		    pdi->fHelpRunning = TRUE;
		    WinHelp(hwnd, gszHelpFilename, HELP_CONTEXT, HELPCONTEXT_IMAADPCM);
                    break;
            }
            return (TRUE);
    }

    return (FALSE);
} // acmdDlgProcConfigure()


//--------------------------------------------------------------------------;
//  
//  BOOL acmdDriverConfigInit
//  
//  Description:
//      This routine initializes the configuration parameters by reading them
//      from the registry.  If there are no entries in the registry, this
//      codec auto-configures itself and writes the results to the registry.
//      If the auto-configure fails, or if we don't know our alias name,
//      then we set the configuration to default values.
//  
//  Arguments:
//      PDRIVERINSTANCE pdi:
//  
//      LPCTSTR pszAliasName:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL acmdDriverConfigInit
(
    PDRIVERINSTANCE         pdi,
    LPCTSTR		    pszAliasName
)
{
    HKEY    hkey;
    UINT    nEncodeSetting;
    UINT    nDecodeSetting;
    UINT    uErrorIDS;


    //
    //	If pszAliasName is NULL then just set all defaults
    //
    //
    if (NULL == pszAliasName)
    {
        DPF(2,"acmdDriverConfigInit: no alias name; using default settings.");

        configSetDefaults( pdi );
        return (TRUE);
    }

    
    //
    //  If we haven't got an open hkey, then open it.  Note that this routine
    //  may be called more than once; on the second time, we should not
    //  re-open the key.
    //
    if( NULL == pdi->hkey )
    {
        RegCreateKeyEx( IMAADPCM_CONFIG_DEFAULTKEY, gszMultimediaKey, 0,
                        NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hkey, NULL );

        if( NULL != hkey )
        {
            ASSERT( NULL != pszAliasName );

            RegCreateKeyEx( hkey, pszAliasName, 0, NULL, 0,
                    KEY_SET_VALUE | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                    NULL, &pdi->hkey, NULL );

            RegCloseKey( hkey );
        }
    }


    //
    //  Read configuration data from registry.
    //
    if( NULL == pdi->hkey )
    {
        configSetDefaults( pdi );
    }
    else
    {
        pdi->nConfigMaxRTEncodeSetting =
                    (UINT)dwReadRegistryDefault( pdi->hkey,
                    (LPTSTR)gszMaxRTEncodeSetting,
                    IMAADPCM_CONFIG_UNCONFIGURED );

        pdi->nConfigMaxRTDecodeSetting =
                    (UINT)dwReadRegistryDefault( pdi->hkey,
                    (LPTSTR)gszMaxRTDecodeSetting,
                    IMAADPCM_CONFIG_UNCONFIGURED );

        pdi->nConfigPercentCPU =
                    (UINT)dwReadRegistryDefault( pdi->hkey,
                    (LPTSTR)gszPercentCPU,
                    IMAADPCM_CONFIG_DEFAULT_PERCENTCPU );
        
        //
        //  Check that nConfigPercentCPU is a valid value.
        //
        if( pdi->nConfigPercentCPU <= 0 )
        {
            pdi->nConfigPercentCPU = IMAADPCM_CONFIG_DEFAULT_PERCENTCPU;
        }
    }


	//
    //  If either the encode or decode setting is out of range, then
    //  we call the auto-configure routine and write out the results.
    //  This should only happen the first time the codec is run.
    //
    if( IMAADPCM_CONFIG_NUMSETTINGS <= pdi->nConfigMaxRTEncodeSetting ||
        IMAADPCM_CONFIG_NUMSETTINGS <= pdi->nConfigMaxRTDecodeSetting )
    {
        DPF( 1, "acmdDriverConfigInit: performing initial auto-config." );
        uErrorIDS = configAutoConfig( pdi,
                                      &nEncodeSetting,
                                      &nDecodeSetting );

        if( 0 != uErrorIDS )
        {
            //
            //  Error in auto-config.  Use defaults instead.
            //
            nEncodeSetting = IMAADPCM_CONFIG_DEFAULT_MAXRTENCODESETTING;
            nDecodeSetting = IMAADPCM_CONFIG_DEFAULT_MAXRTDECODESETTING;
        }

        pdi->nConfigMaxRTEncodeSetting = nEncodeSetting;
        pdi->nConfigMaxRTDecodeSetting = nDecodeSetting;

        //
        //  Always write the results to the registry, even if we hit an
        //  error, so we won't hit the automatic auto-config next
        //  time we run.  One failure is enough!
        //
        configWriteConfiguration( pdi );
    }

    return (TRUE);
} // acmdDriverConfigInit()

#endif // IMAADPCM_USECONFIG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\imaadpcm\codec.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1998 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.h
//
//  Description:
//      This file contains codec definitions, Win16/Win32 compatibility
//      definitions, and instance structure definitions.
//
//
//==========================================================================;

#ifndef _INC_CODEC
#define _INC_CODEC                  // #defined if codec.h has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Version:
//
//  the version is a 32 bit number that is broken into three parts as
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows (in decimal form):
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) &
//      wBuild = LOWORD(dwVersion)
//
//  VERSION_ACM_DRIVER is the version of this driver.
//  VERSION_MSACM is the version of the ACM that this driver
//  was designed for (requires).
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
//
//  32-bit versions
//
#if (WINVER >= 0x0400)
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(4,  0, 0)
#else
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(3, 51, 0)
#endif
#define VERSION_MSACM       MAKE_ACM_VERSION(3, 50, 0)

#else
//
//  16-bit versions
//
#define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(2, 3, 0)
#define VERSION_MSACM       MAKE_ACM_VERSION(2, 1, 0)

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16/32 portability stuff...
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNWCALLBACK FAR PASCAL __loadds
        #define FNEXPORT    FAR PASCAL __export
    #else
        #define FNWCALLBACK FAR PASCAL
        #define FNEXPORT    FAR PASCAL __export
    #endif
    #endif

    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif

    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))

    #define HUGE            _huge

    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)
    #define SIZEOFACMSTR(x) sizeof(x)
#else
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    #ifndef try
    #define try         __try
    #define leave       __leave
    #define except      __except
    #define finally     __finally
    #endif


    //
    //  there is no reason to have based stuff in win 32
    //
    #define BCODE

    #define HUGE
    #define HTASK                   HANDLE
    #define SELECTOROF(a)           (a)
    typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD_PTR, HDRVR, UINT, LPARAM, LPARAM);

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif
    #define SIZEOFACMSTR(x)	(sizeof(x)/sizeof(WCHAR))
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Compilation options:
//
//      If IMAADPCM_USECONFIG is defined, then the codec will be compiled
//      with a configuration dialog.  If not, then the codec will not be
//      configurable.  It is expected that the configuration is only
//      necessary for certain platforms...
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define IMAADPCM_USECONFIG


#ifdef IMAADPCM_USECONFIG

//
//  See codec.c for a description of this structure and its use.
//
typedef struct tRATELISTFORMAT
{
    UINT        uFormatType;
    UINT        idsFormat;
    DWORD       dwMonoRate;
} RATELISTFORMAT;
typedef RATELISTFORMAT *PRATELISTFORMAT;

#define CONFIG_RLF_NONUMBER     1
#define CONFIG_RLF_MONOONLY     2
#define CONFIG_RLF_STEREOONLY   3
#define CONFIG_RLF_MONOSTEREO   4

#endif // IMAADPCM_USECONFIG



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//
//
#define SIZEOF_ARRAY(ar)            (sizeof(ar)/sizeof((ar)[0]))

//
//
//
typedef BOOL FAR*   LPBOOL;


//
//  macros to compute block alignment and convert between samples and bytes
//  of PCM data. note that these macros assume:
//
//      wBitsPerSample  =  8 or 16
//      nChannels       =  1 or 2
//
//  the pwfx argument is a pointer to a WAVEFORMATEX structure.
//
#define PCM_BLOCKALIGNMENT(pwfx)        (UINT)(((pwfx)->wBitsPerSample >> 3) << ((pwfx)->nChannels >> 1))
#define PCM_AVGBYTESPERSEC(pwfx)        (DWORD)((pwfx)->nSamplesPerSec * (pwfx)->nBlockAlign)
#define PCM_BYTESTOSAMPLES(pwfx, cb)    (DWORD)(cb / PCM_BLOCKALIGNMENT(pwfx))
#define PCM_SAMPLESTOBYTES(pwfx, dw)    (DWORD)(dw * PCM_BLOCKALIGNMENT(pwfx))



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tDRIVERINSTANCE
{
    //
    //  although not required, it is suggested that the first two members
    //  of this structure remain as fccType and DriverProc _in this order_.
    //  the reason for this is that the driver will be easier to combine
    //  with other types of drivers (defined by AVI) in the future.
    //
    FOURCC          fccType;        // type of driver: 'audc'
    DRIVERPROC      fnDriverProc;   // driver proc for the instance

    //
    //  the remaining members of this structure are entirely open to what
    //  your driver requires.
    //
    HDRVR           hdrvr;          // driver handle we were opened with
    HINSTANCE       hinst;          // DLL module handle.
    DWORD           vdwACM;         // current version of ACM opening you
    DWORD           fdwOpen;        // flags from open description

    DWORD           fdwConfig;      // stream instance configuration flags

#ifdef IMAADPCM_USECONFIG
    LPDRVCONFIGINFO pdci;
    HKEY            hkey;
    UINT            nConfigMaxRTEncodeSetting;
    UINT            nConfigMaxRTDecodeSetting;
    UINT    	    nConfigPercentCPU;
    BOOL            fHelpRunning;           // Used by config DlgProc only.
#ifdef WIN4
    HBRUSH          hbrDialog;              // Used by config DlgProc only.
#endif
#endif

} DRIVERINSTANCE, *PDRIVERINSTANCE, FAR *LPDRIVERINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;


//
//  This define deals with unaligned data for Win32, and huge data for Win16.
//  Basically, any time you cast an HPBYTE to a non-byte variable (ie long or
//  short), you should cast it to ( {short,long} HUGE_T *).  This will cast
//  it to _huge for Win16, and make sure that there are no alignment problems
//  for Win32 on MIPS and Alpha machines.
//

typedef BYTE HUGE *HPBYTE;

#ifdef WIN32
    #define HUGE_T  UNALIGNED
#else
    #define HUGE_T  _huge
#endif


//
//
//
//
typedef DWORD (FNGLOBAL *STREAMCONVERTPROC)
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);


//
//
//
//
typedef struct tSTREAMINSTANCE
{
    STREAMCONVERTPROC   fnConvert;  // stream instance conversion proc
    DWORD               fdwConfig;  // stream instance configuration flags

    int                 nStepIndexL; // Used to ensure that the step index
    int                 nStepIndexR; //  is maintained across converts.  For
                                     //  mono signals, the index is stored in
                                     //  nStepIndexL.

} STREAMINSTANCE, *PSTREAMINSTANCE, FAR *LPSTREAMINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  resource id's
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define IDS_ACM_DRIVER_SHORTNAME    (1)     // ACMDRIVERDETAILS.szShortName
#define IDS_ACM_DRIVER_LONGNAME     (2)     // ACMDRIVERDETAILS.szLongName
#define IDS_ACM_DRIVER_COPYRIGHT    (3)     // ACMDRIVERDETAILS.szCopyright
#define IDS_ACM_DRIVER_LICENSING    (4)     // ACMDRIVERDETAILS.szLicensing
#define IDS_ACM_DRIVER_FEATURES     (5)     // ACMDRIVERDETAILS.szFeatures

#define IDS_ACM_DRIVER_TAG_NAME     (20)    // ACMFORMATTAGDETAILS.szFormatTag

#ifdef IMAADPCM_USECONFIG
//
//  resource id's for the configuration dialog box
//

#define IDS_CONFIG_NORATES          (30)
#define IDS_CONFIG_ALLRATES         (31)
#define IDS_CONFIG_MONOONLY         (32)
#define IDS_CONFIG_STEREOONLY       (33)
#define IDS_CONFIG_MONOSTEREO       (34)
#define IDS_ERROR                   (35)
#define IDS_ERROR_NOMEM             (36)

#define IDD_CONFIG                      RCID(100)
#define IDC_BTN_AUTOCONFIG              1001
#define IDC_BTN_HELP                    1002
#define IDC_COMBO_MAXRTENCODE           1003
#define IDC_COMBO_MAXRTDECODE           1004
#define IDC_STATIC_COMPRESS				1005
#define IDC_STATIC_DECOMPRESS			1006
#define IDC_STATIC                      -1

#endif


//
//  global variables, etc...
//
#ifdef IMAADPCM_USECONFIG

extern const UINT   gauFormatIndexToSampleRate[];
extern const UINT   ACM_DRIVER_MAX_SAMPLE_RATES;
extern const UINT   ACM_DRIVER_MAX_CHANNELS;
extern const RATELISTFORMAT gaRateListFormat[];
extern const UINT   IMAADPCM_CONFIG_NUMSETTINGS;

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  function prototypes
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef IMAADPCM_USECONFIG

BOOL FNGLOBAL acmdDriverConfigInit
(
    PDRIVERINSTANCE	    pdi,
    LPCTSTR		    pszAliasName
);

INT_PTR FNWCALLBACK acmdDlgProcConfigure
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

LRESULT FNLOCAL acmdFormatSuggest
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVFORMATSUGGEST   padfs
);

LRESULT FNLOCAL acmdStreamSize
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
);

LRESULT FNLOCAL acmdStreamConvert
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
);

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" {
#endif

#endif // _INC_CODEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\imaadpcm\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code to support easy-to-use debugging support.
//      All code compiles to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifndef WIN32
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
#if DBG
        DebugBreak();
#endif
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()


//--------------------------------------------------------------------------;
//  
//  void _Assert
//  
//  Description:
//      This routine is called if the ASSERT macro (defined in debug.h)
//      tests and expression that evaluates to FALSE.  This routine 
//      displays an "assertion failed" message box allowing the user to
//      abort the program, enter the debugger (the "retry" button), or
//      ignore the assertion and continue executing.  The message box
//      displays the file name and line number of the _Assert() call.
//  
//  Arguments:
//      char *  szFile: Filename where assertion occurred.
//      int     iLine:  Line number of assertion.
//  
//--------------------------------------------------------------------------;

void WINAPI _Assert
(
    char *  szFile,
    int     iLine
)
{
    static CHAR     ach[300];       // debug output (avoid stack overflow)
    int	            id;


    wsprintfA(ach, "Assertion failed in file %s, line %d.  [Press RETRY to debug.]", (LPSTR)szFile, iLine);

    id = MessageBoxA(NULL, ach, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE );

	switch (id)
	{

	case IDABORT:               // Kill the application.
        FatalAppExit(0, TEXT("Good Bye"));
		break;

	case IDRETRY:               // Break into the debugger.
#if DBG
		DebugBreak();
#endif
		break;

	case IDIGNORE:              // Ignore assertion, continue executing.
		break;
	}
} // _Assert

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\imaadpcm\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#ifdef WIN32

    //----------------------------------------------------------------------;
    //
    //  Win 32
    //
    //----------------------------------------------------------------------;

    #ifdef _X86_
    
        //
        //  Use 32-bit x86 assembly.
        //

        #pragma warning(disable:4035 4704)

        INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     imul    ebx              //  imul ebx
            _asm     idiv    ecx              //  idiv ecx
            _asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     shr     ebx,1            //  sar  ebx,1
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     dec     ebx              //  dec  ebx
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRU32()

        INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRD32()

        #pragma warning(default:4035 4704)


    #else

        //
        //  Use C9 __int64 support for Daytona RISC platforms.
        //

        INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
        {
            return (LONG)( Int32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( UInt32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c/2) / c );
        }


        INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c-1) / c );
        }

    #endif


#else

    //----------------------------------------------------------------------;
    //
    //  Win 16
    //
    //----------------------------------------------------------------------;

    #pragma warning(disable:4035 4704)

    //
    //  Compile for 16-bit - we can use x86 with proper opcode prefixes
    //	    to get 32-bit instructions.
    //

    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    imul    bx              //  imul ebx
        _asm _emit 0x66 _asm    idiv    cx              //  idiv ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    shr     bx,1            //  sar  ebx,1
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    dec     bx              //  dec  ebx
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRU32()


    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRD32()

    #pragma warning(default:4035 4704)

#endif


//
//  some code references these by other names.
//
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\imaadpcm\imaadpcm.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  imaadpcm.h
//
//  Description:
//      This file contains prototypes for the filtering routines.
//
//
//==========================================================================;

#ifndef _IMAADPCM_H_
#define _IMAADPCM_H_

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern 
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif


//
//
//
//
#define IMAADPCM_MAX_CHANNELS       2
#define IMAADPCM_BITS_PER_SAMPLE    4
#define IMAADPCM_WFX_EXTRA_BYTES    (sizeof(IMAADPCMWAVEFORMAT) - sizeof(WAVEFORMATEX))
#define IMAADPCM_HEADER_LENGTH      4    // In bytes, per channel.

#ifdef IMAADPCM_USECONFIG
#define IMAADPCM_CONFIGTESTTIME     4   // seconds of PCM data for test.
#define IMAADPCM_CONFIG_DEFAULT                             0x0000
#define IMAADPCM_CONFIG_DEFAULT_MAXRTENCODESETTING          5
#define IMAADPCM_CONFIG_DEFAULT_MAXRTDECODESETTING          6
#define IMAADPCM_CONFIG_UNCONFIGURED                        0x0999
#define IMAADPCM_CONFIG_DEFAULT_PERCENTCPU	        	    50
#define IMAADPCM_CONFIG_TEXTLEN                             80
#define IMAADPCM_CONFIG_DEFAULTKEY                          HKEY_CURRENT_USER
#endif


//
//  Conversion function prototypes.
//
DWORD FNGLOBAL imaadpcmDecode4Bit_M08
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);

DWORD FNGLOBAL imaadpcmDecode4Bit_M16
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);

DWORD FNGLOBAL imaadpcmDecode4Bit_S08
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);

DWORD FNGLOBAL imaadpcmDecode4Bit_S16
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);

DWORD FNGLOBAL imaadpcmEncode4Bit_M08
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);

DWORD FNGLOBAL imaadpcmEncode4Bit_M16
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);

DWORD FNGLOBAL imaadpcmEncode4Bit_S08
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);

DWORD FNGLOBAL imaadpcmEncode4Bit_S16
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    int                 *   pnStepIndexL,
    int                 *   pnStepIndexR
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _IMAADPCM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\acm.c ===
//==========================================================================;
//
//  acm.c
//
//  Copyright (c) 1991-1999 Microsoft Corporation
//
//  Description:
//      This module provides the Audio Compression Manager API to the
//      installable audio drivers
//
//  History:
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include <stdlib.h>
#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "profile.h"
#include "uchelp.h"
#include "debug.h"


//
//
//
#ifndef WIN32
#ifdef DEBUG
EXTERN_C HANDLE FAR PASCAL GetTaskDS(void);
#endif
EXTERN_C UINT FAR PASCAL LocalCountFree(void);
EXTERN_C UINT FAR PASCAL LocalHeapSize(void);
#endif


//
//
//
CONST TCHAR gszKeyDrivers[]	    = TEXT("System\\CurrentControlSet\\Control\\MediaResources\\acm");
CONST TCHAR gszDevNode[]	    = TEXT("DevNode");
TCHAR BCODE gszFormatDriverKey[]    = TEXT("%s\\%s");
TCHAR BCODE gszDriver[]		    = TEXT("Driver");
TCHAR BCODE gszDriverCache[]	    = TEXT("Software\\Microsoft\\AudioCompressionManager\\DriverCache");
TCHAR gszValfdwSupport[]	    = TEXT("fdwSupport");
TCHAR gszValcFormatTags[]	    = TEXT("cFormatTags");
TCHAR gszValaFormatTagCache[]	    = TEXT("aFormatTagCache");
TCHAR gszValcFilterTags[]	    = TEXT("cFilterTags");
TCHAR gszValaFilterTagCache[]	    = TEXT("aFilterTagCache");


//==========================================================================;
//
//
//
//
//
//==========================================================================;

MMRESULT FNLOCAL IDriverLoad( HACMDRIVERID hadid, DWORD fdwLoad );

//==========================================================================;
//
//
//
//
//
//==========================================================================;

#if defined(WIN32) && defined(_MT)
//
//  Handle support routines
//

HLOCAL NewHandle(UINT cbSize)
{
    PACM_HANDLE pacmh;

    pacmh = (PACM_HANDLE)LocalAlloc(LPTR, sizeof(ACM_HANDLE) + cbSize);
    if (pacmh) {
	try {
	    InitializeCriticalSection(&pacmh->CritSec);
	} except(EXCEPTION_EXECUTE_HANDLER) {
	    LocalFree((HLOCAL)pacmh);
	    pacmh = NULL;
	}
    }

    if (pacmh) {
	return (HLOCAL)(pacmh + 1);
    } else {
	return NULL;
    }
}

VOID DeleteHandle(HLOCAL h)
{
    DeleteCriticalSection(&HtoPh(h)->CritSec);

    LocalFree((HLOCAL)HtoPh(h));
}

#endif // WIN32 && _MT

//==========================================================================;
//
//
//  ACMGARB routines
//
//  These routines are used to access the linked list of ACMGARB structures.
//  Each structure is associated with one process id.  whenever the acm is
//  called it finds the acmgarb structure associated with the process in
//  which it is called and then uses the data stored in that acmgarb structure.
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  DWORD GetCurrentProcessId
//
//  Description:
//	This function returns the current process id
//
//  Arguments:
//
//  Return (DWORD):
//	Id of current process
//
//  History:
//      04/25/94    frankye
//
//  Notes:
//
//	WIN32:
//	This function exists in the 32-bit kernels on both Chicago and
//	Daytona and we provide no prototype for WIN32 compiles.
//
//	16-bit Chicago:
//	It is exported as in internal API by the 16-bit Chicago kernel.
//	We provide the prototype here and import it in the def file.
//
//	16-bit Daytona:
//	Has no such 16-bit function and really doesn't need one since all
//	16-bit tasks are part of the same process under Daytona.  Therefore
//	we just #define this to return (1) for 16-bit non-Chicago builds.
//
//--------------------------------------------------------------------------;
#ifndef WIN32
#ifdef  WIN4
DWORD WINAPI GetCurrentProcessId(void);
#else
#define GetCurrentProcessId() (1)
#endif
#endif

//--------------------------------------------------------------------------;
//
//  PACMGARB pagFind
//
//  Description:
//	This function searches the linked list of ACMGARB structures for
//	one that is associated with the current process.
//
//	CHICAGO:
//	This function calls GetCurrentProcessId() and searches the linked
//	list of ACMGARBs (gplag) for an ACMGARB for the current process.
//	See notes for the GetCurrentProcessId() function above.
//
//	DAYTONA:
//	The pag list always contains only one node (since msacm32.dll is
//	always loaded into seperate process address spaces, and since
//	msacm.dll is loaded only once into each wow address space).  Since
//	the pag list always contains only one node, this function is simply
//	#defined in acmi.h to return gplag instead of searching the pag list.
//
//  Arguments:
//
//  Return (PACMGARB):
//	Pointer to ACMGARB structure for the current process.  Returns
//	NULL if none found.
//
//  History:
//      04/25/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
#ifdef WIN4
PACMGARB FNGLOBAL pagFind(void)
{
    PACMGARB	pag;
    DWORD	pid;

    pag = gplag;

    pid = GetCurrentProcessId();

    while (pag && (pag->pid != pid)) pag = pag->pagNext;

    return (pag);
}
#endif

//--------------------------------------------------------------------------;
//
//  PACMGARB pagFindAndBoot
//
//  Description:
//	This function searches for a pag that is associated with
//	the current process.  It will then boot drivers if there
//	are any that need to be booted.
//
//  Arguments:
//	(void)
//
//  Return (PACMGARB):
//	Pointer to ACMGARB structure for the current process.  Returns
//	NULL if none found.
//
//  History:
//      04/25/94    frankye
//
//  Notes:
//
//	DAYTONA:
//	acmBootXDrivers is called from acmInitialize, so there
//	is no need to check for booting drivers.  Furthermore, given the
//	reasons stated in the description of pagFind() below, this
//	function is simply #defined in acmi.h to return gplag.
//
//--------------------------------------------------------------------------;
#ifdef WIN4
PACMGARB FNGLOBAL pagFindAndBoot(void)
{
    PACMGARB	pag;

    pag = pagFind();
    if (NULL == pag)
    {
	return(pag);
    }

#ifndef WIN32
    if( pag->fWOW )
    {
        pagFindAndBoot32(pag);
    }
#endif

    //
    //	If this thread already has a shared lock on the driver list,
    //	then don't bother trying to boot drivers.  (It is possible for
    //	this thread to have a shared lock if, for example, it is calling
    //	into an ACM API from an acmDriverEnumCallback.)
    //
    //	It is important to do this before entering csBoot, because the
    //	owner of csBoot might be waiting for this thread to release the
    //	list lock.  Note we are assuming that this thread does NOT own an
    //	exclusive lock on the list.
    //
    if (threadQueryInListShared(pag))
    {
	return(pag);
    }

	
#ifdef WIN32
    //
    //  This critical section protects the boot-related flags and counters,
    //  ie, fDriversBooted and the dwXXXChangeNotify counters.
    //
    EnterCriticalSection(&pag->csBoot);
#endif

    //
    //  See if we need to do the initial boot of the drivers.
    //
    if (FALSE == pag->fDriversBooted)
    {
	//
	//  Since we haven't done the initial boot of the drivers,
	//  nobody should have any kind of a lock right now.  Also,
	//  since we've entered the csBoot critical section, no
	//  other threads can get into any APIs in order to attempt
	//  to get a lock.  Therefore, there really isn't any need
	//  for us to grab a list lock.
	//
	//  Furthermore, we should not reenter the boot code.
	//
	ASSERT(FALSE == pag->fDriversBooting);
		
#ifdef DEBUG
	pag->fDriversBooting = TRUE;
#endif
	
#ifndef WIN32
	pag->dw32BitLastChangeNotify = pag->dw32BitChangeNotify;
	acmBoot32BitDrivers(pag);
#endif

	acmBootDrivers(pag);

	pag->dwPnpLastChangeNotify = *pag->lpdwPnpChangeNotify;
	acmBootPnpDrivers(pag);

#ifdef DEBUG
	pag->fDriversBooting = FALSE;
#endif

	pag->fDriversBooted = TRUE;
    }



    //
    //  Check for pnp changes
    //
    if (pag->dwPnpLastChangeNotify != *pag->lpdwPnpChangeNotify)
    {
	//
	//  Looks like there's been a change in the pnp drivers.
	//
	ASSERT(FALSE==pag->fDriversBooting);
	
	ENTER_LIST_EXCLUSIVE;
	
#ifdef DEBUG
	pag->fDriversBooting = TRUE;
#endif
	pag->dwPnpLastChangeNotify = *pag->lpdwPnpChangeNotify;
	acmBootPnpDrivers(pag);
		
#ifdef DEBUG
	pag->fDriversBooting = FALSE;
#endif
		
	LEAVE_LIST_EXCLUSIVE;

    }


#ifndef WIN32
    //
    //  Check for 32-bit driver changes
    //
    if (pag->dw32BitLastChangeNotify != pag->dw32BitChangeNotify)
    {
	//
	//  Looks like there's been a change in the 32bit drivers.
	//
	ASSERT(FALSE==pag->fDriversBooting);
		
	ENTER_LIST_EXCLUSIVE;

#ifdef DEBUG
	pag->fDriversBooting = TRUE;
#endif
		
	pag->dw32BitLastChangeNotify = pag->dw32BitChangeNotify;
	acmBoot32BitDrivers(pag);
		
#ifdef DEBUG
	pag->fDriversBooting = FALSE;
#endif
		
	LEAVE_LIST_EXCLUSIVE;

    }
#endif
	
	
#ifdef WIN32
    LeaveCriticalSection(&pag->csBoot);
#endif
	
    return (pag);

}
#endif

//--------------------------------------------------------------------------;
//
//  PACMGARB pagNew
//
//  Description:
//	This function allocs a new ACMGARB structure, fills in the pid
//	member with the current process id, initializes the boot flags
//	critical section, and inserts the struture into the linked list
//	of ACMGARB structures.
//
//  Arguments:
//
//  Return (PACMGARB):
//	Pointer to ACMGARB structure for the current process.  Returns
//	NULL if couldn't create one.
//
//  History:
//      04/25/94    frankye
//
//  Notes:
//	Since this function writes to the change notify counters, we are
//	assuming that this function is protected from multiple threads.  Since
//	this is only called from within DllEntryPoint on DLL_PROCESS_ATTACH,
//	I think we are safe.
//
//--------------------------------------------------------------------------;
PACMGARB FNGLOBAL pagNew(void)
{
    PACMGARB pag;

    pag = (PACMGARB)LocalAlloc(LPTR, sizeof(*pag));

    if (NULL != pag)
    {
	pag->pid = GetCurrentProcessId();

	//
	//  As a default, we point lpdwPnpChangeNotify at our own notify
	//  counter.  Unless we get a pointer to some other notify counter
	//  (ie, from mmdevldr) we leave it this way.
	//
	pag->dwPnpLastChangeNotify = 0;
	pag->lpdwPnpChangeNotify = &pag->dwPnpLastChangeNotify;

#ifdef WIN32
	pag->lpdw32BitChangeNotify = NULL;
#else
	pag->dw32BitLastChangeNotify = 0;
	pag->dw32BitChangeNotify = 0;
#endif
	
	pag->pagNext = gplag;
	gplag = pag;
    }

    return (pag);
}

//--------------------------------------------------------------------------;
//
//  PACMGARB pagDelete
//
//  Description:
//	This function removes an ACMGARB structure from the linked list
//	and frees it.
//
//  Arguments:
//	PACMGARB pag: pointer to ACMGARB to remove from list.
//
//  Return (void):
//
//  History:
//      04/25/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
void FNGLOBAL pagDelete(PACMGARB pag)
{
    PACMGARB pagPrev, pagT;

    if (gplag == pag)
    {
	gplag = pag->pagNext;
    }
    else
    {
	if (NULL != gplag)
	{
	    pagPrev = gplag;
	    pagT = pagPrev->pagNext;
	    while ( pagT && (pagT != pag) )
	    {
		pagPrev = pagT;
		pagT = pagT->pagNext;
	    }

	    if (pagT == pag)
	    {
		pagPrev->pagNext = pagT->pagNext;
	    }
	}
    }

    LocalFree((HLOCAL)pag);
}

//==========================================================================;
//
//
//  Thread routines for tracking shared locks
//
//  The incentive for having these routines is to prevent scenarios like
//  this:  Supposed FranksBadApp calls acmDriverEnum to enumerate drivers.
//  This API will obtain a shared lock on the driver list while it
//  enumerates the drivers.  FranksEvilDriverEnumCallback function
//  decides to call acmDriverAdd.  The acmDriverAdd API wants
//  to obtain an exclusive lock on the driver list so that it can write to
//  the driver list.  But, it can't because it already has a shared lock.
//  Without the following routines and associated logic, this thread would
//  deadlock waiting to obtain an exclusive lock.
//
//  Furthermore, some APIs that we wouldn't expect to write to the driver list
//  actually do, usually to update driver priorities.  Fixing the above
//  problem leads to an easy solution for this as well.  If the thread already
//  has an shared lock, then the API can simply blow off updating priorities
//  but still succeed the call if possible.  By doing this, we allow callback
//  functions to still make API calls to seemingly harmless functions
//  like acmMetrics.
//
//
//  These routines are used to track shared locks on the driver list
//  on a per thread basis.  Each time a thread obtains a shared lock, it
//  increments a per-thread counter which tracks the number of shared locks
//  held by that thread.  Whenever we try to obtain on exclusive lock, we
//  query whether the current thread already has a shared lock.  If it does,
//  then there is NO WAY this thread can obtain an exclusive lock.  We MUST
//  either get by without obtaining the exclusive lock or fail the call.
//
//  Behavior/implementation for various compiles:
//
//	32-bit Chicago or Daytona:
//	    The per-thread counter is maintained using the Tls (Thread
//	    local storage) APIs.  The dwTlsIndex is stored in the process
//	    wide pag (pointer to ACMGARB) structure.  If a thread within a
//	    process tries to obtain an exclusive lock when that same thread
//	    already owns a shared lock, then we fail or work-around.
//	    Other threads in that process will either immediately get
//	    the lock or wait, depending on the type of lock.
//
//	16-bit (Chicago and Daytona):
//	    We don't really have a locking mechanism, but the concept of
//	    the shared lock counter does help prevent us from writing
//	    to the driver list at the same time that we are reading from it.
//
//	16-bit Chicago:
//	    The shared lock counter is maintained in the pag (in a variable
//	    that, for some strange reason, is called dwTlsIndex).  Since
//	    in Chicago every win 16 task is a seperate process, we have
//	    a seperate pag, driver list, and shared-lock counter for each
//	    win 16 app.  So, app1 can call acmDriverEnum, yield in its
//	    callback, and app2 can successfully call acmDriverAdd.  However,
//	    app1 cannot try to do acmDriverAdd from within its
//	    acmDriverEnumCallback.
//
//	16-bit Daytona:
//	    The shared lock counter is maintained in the pag (in a variable
//	    that, for some strange reason, is called dwTlsIndex).  Since
//	    in Daytona all win 16 tasks are one process, we have only
//	    one pag, driver list, and shared-lock counter for all
//	    win 16 apps.  So, if app1 calls acmDriverEnum, yields in its
//	    callback, app2 CANNOT successfully call acmDriverAdd.  Furthermore
//	    app1 cannot try to do acmDriverAdd from within its
//	    acmDriverEnumCallback.
//
//	
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  VOID threadInitializeProcess
//
//  Description:
//	Should be called once during process initialization to initialize
//	the thread local storage mechanism.
//
//  Arguments:
//	PACMGARB pag: pointer to usual garbage
//
//  Return (void):
//
//  History:
//      06/27/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
VOID FNGLOBAL threadInitializeProcess(PACMGARB pag)
{
#ifdef WIN32
    pag->dwTlsIndex = TlsAlloc();
#else
    pag->dwTlsIndex = 0;
#endif
    return;
}

//--------------------------------------------------------------------------;
//
//  VOID threadTerminateProcess
//
//  Description:
//	Should be called once during process termination to clean up and
//	terminate the thread local storage mechanism.
//
//  Arguments:
//	PACMGARB pag: pointer to usual garbage
//
//  Return (void):
//
//  History:
//      06/27/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
VOID FNGLOBAL threadTerminateProcess(PACMGARB pag)
{
#ifdef WIN32
    if (0xFFFFFFFF != pag->dwTlsIndex)
    {
	TlsFree(pag->dwTlsIndex);
    }
#else
    pag->dwTlsIndex = 0;
#endif
    return;
}

//--------------------------------------------------------------------------;
//
//  VOID threadInitialize
//
//  Description:
//	Should be called once for each thread to initialize the
//	thread local storage on a per-thread basis.
//
//  Arguments:
//	PACMGARB pag: pointer to usual garbage
//
//  Return (void):
//
//  History:
//      06/27/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
VOID FNGLOBAL threadInitialize(PACMGARB pag)
{
    if (NULL == pag) return;
#ifdef WIN32
    if (0xFFFFFFFF != pag->dwTlsIndex)
    {
	TlsSetValue(pag->dwTlsIndex, 0);
    }
#else
    pag->dwTlsIndex = 0;
#endif
    return;
}

//--------------------------------------------------------------------------;
//
//  VOID threadTerminate
//
//  Description:
//	Should be called once for each thread to terminate the
//	thread local storage on a per-thread basis.
//
//  Arguments:
//	PACMGARB pag: pointer to usual garbage
//
//  Return (void):
//
//  History:
//      06/27/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
VOID FNGLOBAL threadTerminate(PACMGARB pag)
{
    return;
}

//--------------------------------------------------------------------------;
//
//  VOID threadEnterListShared
//
//  Description:
//	Should be called by ENTER_LIST_SHARED (ie, each time a shared
//	lock is aquired on the driver list)
//
//  Arguments:
//	PACMGARB pag: pointer to usual garbage
//
//  Return (void):
//
//  History:
//      06/27/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
VOID FNGLOBAL threadEnterListShared(PACMGARB pag)
{
#ifdef WIN32
    INT_PTR Count;

    if (0xFFFFFFFF != pag->dwTlsIndex)
    {
	Count = (INT_PTR)TlsGetValue(pag->dwTlsIndex);
	TlsSetValue(pag->dwTlsIndex, (LPVOID)++Count);
    }
#else
    pag->dwTlsIndex++;
#endif
    return;
}

//--------------------------------------------------------------------------;
//
//  VOID threadLeaveListShared
//
//  Description:
//	Should be called by LEAVE_LIST_SHARED (ie, each time a shared
//	lock on the driver list is released).
//
//  Arguments:
//	PACMGARB pag: pointer to usual garbage
//
//  Return (void):
//
//  History:
//      06/27/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
VOID FNGLOBAL threadLeaveListShared(PACMGARB pag)
{
#ifdef WIN32
    INT_PTR Count;

    if (0xFFFFFFFF != pag->dwTlsIndex)
    {
	Count = (INT_PTR)TlsGetValue(pag->dwTlsIndex);
	TlsSetValue(pag->dwTlsIndex, (LPVOID)--Count);
    }
#else
    pag->dwTlsIndex--;
#endif
    return;
}

//--------------------------------------------------------------------------;
//
//  DWORD threadQueryInListShared
//
//  Description:
//	Can be called to determine whether the current thread has a
//	shared lock on the driver list.  Should call this before EVERY
//	call to ENTER_LIST_EXCLUSIVE.  If this function returns non-zero,
//	then the current thread already has a shared lock and
//	ENTER_LIST_EXCLUSIVE will deadlock!!!  Caller should figure out what
//	to do from there...
//
//  Arguments:
//	PACMGARB pag: pointer to usual garbage
//
//  Return (BOOL): TRUE if shared locks are held by this thread.  FALSE
//	if this thread does not hold a shared lock on the driver list.
//
//  History:
//      06/27/94    frankye
//
//  Notes:
//
//--------------------------------------------------------------------------;
BOOL FNGLOBAL threadQueryInListShared(PACMGARB pag)
{
#ifdef WIN32
    if (0xFFFFFFFF != pag->dwTlsIndex)
    {
	return (0 != TlsGetValue(pag->dwTlsIndex));
    }
    else
    {
	return 0;
    }
#else
    return (0 != pag->dwTlsIndex);
#endif
}

//==========================================================================;
//
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT IDriverMessageId
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      UINT uMsg:
//
//      LPARAM lParam1:
//
//      LPARAM lParam2:
//
//  Return (LRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL IDriverMessageId
(
    HACMDRIVERID        hadid,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
)
{
    PACMDRIVERID    padid;
    LRESULT         lr;

    //
    //  only validate hadid in DEBUG build for this function (it is internal
    //  and will only be called by us...)
    //
    DV_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

    padid = (PACMDRIVERID)hadid;

    //
    //	Better make sure the driver is loaded if we're going to use the hadid
    //
    if (0 == (ACMDRIVERID_DRIVERF_LOADED & padid->fdwDriver))
    {
	if ( (DRV_LOAD != uMsg) && (DRV_ENABLE != uMsg) && (DRV_OPEN != uMsg) )
	{
	    lr = (LRESULT)IDriverLoad(hadid, 0L);
	    if (MMSYSERR_NOERROR != lr) {
		return (lr);
	    }
	}
    }

#ifndef WIN32
    //
    //  Are we thunking?
    //

    if (padid->fdwAdd & ACM_DRIVERADDF_32BIT) {
        return IDriverMessageId32(padid->hadid32, uMsg, lParam1, lParam2);
    }
#endif // !WIN32

    if (NULL != padid->fnDriverProc)
    {
        if ((ACMDRIVERPROC)(DWORD_PTR)-1L == padid->fnDriverProc)
        {
            return (MMSYSERR_ERROR);
        }

        if (IsBadCodePtr((FARPROC)padid->fnDriverProc))
        {
            DPF(0, "!IDriverMessageId: bad function pointer for driver");

            padid->fnDriverProc = (ACMDRIVERPROC)(DWORD_PTR)-1L;

            return (MMSYSERR_ERROR);
        }

        //
        //
        //
        lr = padid->fnDriverProc(padid->dwInstance, hadid, uMsg, lParam1, lParam2);
        return (lr);
    }

    //
    //
    //
    if (NULL != padid->hdrvr)
    {
        lr = SendDriverMessage(padid->hdrvr, uMsg, lParam1, lParam2);
        return (lr);
    }

    //
    //  NOTE: this is very bad--and we don't really know what to return
    //  since anything could be valid depending on the message... so we
    //  assume that people follow the ACM conventions and return MMRESULT's.
    //
    DPF(0, "!IDriverMessageId: invalid hadid passed! %.04Xh", hadid);

    return (MMSYSERR_INVALHANDLE);
} // IDriverMessageId()


//--------------------------------------------------------------------------;
//
//  LRESULT IDriverMessage
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVER had:
//
//      UINT uMsg:
//
//      LPARAM lParam1:
//
//      LPARAM lParam2:
//
//  Return (LRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL IDriverMessage
(
    HACMDRIVER          had,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
)
{
    PACMDRIVER      pad;
    LRESULT         lr;

    //
    //  only validate hadid in DEBUG build for this function (it is internal
    //  and will only be called by us...)
    //
    DV_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

    pad = (PACMDRIVER)had;

#ifndef WIN32
    //
    //  Are we thunking?
    //

    if (((PACMDRIVERID)pad->hadid)->fdwAdd & ACM_DRIVERADDF_32BIT) {
        return IDriverMessage32(pad->had32, uMsg, lParam1, lParam2);
    }
#endif // !WIN32

    if (NULL != pad->fnDriverProc)
    {
        if ((ACMDRIVERPROC)(DWORD_PTR)-1L == pad->fnDriverProc)
        {
            return (MMSYSERR_ERROR);
        }

        if (IsBadCodePtr((FARPROC)pad->fnDriverProc))
        {
            DPF(0, "!IDriverMessage: bad function pointer for driver");

            pad->fnDriverProc = (ACMDRIVERPROC)(DWORD_PTR)-1L;

            return (MMSYSERR_ERROR);
        }

        //
        //
        //
        lr = pad->fnDriverProc(pad->dwInstance, pad->hadid, uMsg, lParam1, lParam2);
        return (lr);
    }

    //
    //
    //
    if (NULL != pad->hdrvr)
    {
        lr = SendDriverMessage(pad->hdrvr, uMsg, lParam1, lParam2);
        return (lr);
    }

    //
    //  NOTE: this is very bad--and we don't really know what to return
    //  since anything could be valid depending on the message... so we
    //  assume that people follow the ACM conventions and return MMRESULT's.
    //
    DPF(0, "!IDriverMessage: invalid had passed! %.04Xh", had);

    return (MMSYSERR_INVALHANDLE);
} // IDriverMessage()


//==========================================================================;
//
//
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT IDriverConfigure
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      HWND hwnd:
//
//  Return (LRESULT):
//
//  History:
//      10/01/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL IDriverConfigure
(
    HACMDRIVERID            hadid,
    HWND                    hwnd
)
{
    LRESULT             lr;
    PACMDRIVERID        padid;
#ifdef WIN4
    DRVCONFIGINFOEX     dci;
#else
    DRVCONFIGINFO       dci;
#endif
    HACMDRIVER          had;
    LPARAM              lParam2;

    padid = (PACMDRIVERID)hadid;
    if (TYPE_HACMDRIVER == padid->uHandleType)
    {
        had   = (HACMDRIVER)hadid;
        hadid = ((PACMDRIVER)had)->hadid;
    }
    else if (TYPE_HACMDRIVERID == padid->uHandleType)
    {
        had   = NULL;
    }
    else
    {
        DPF(0, "!IDriverConfigure(): bogus handle passed!");
        return (DRVCNF_CANCEL);
    }

    padid = (PACMDRIVERID)hadid;


    //
    //
    //
    if (0 != (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver))
    {
        DebugErr(DBF_ERROR, "acmDriverMessage(): notification handles cannot be configured.");
        return (MMSYSERR_INVALHANDLE);
    }


    //
    //
    //
    {
	//
	//
	//
	lParam2 = 0L;
	if (ACM_DRIVERADDF_NAME == (ACM_DRIVERADDF_TYPEMASK & padid->fdwAdd))
	{
	    dci.dwDCISize          = sizeof(dci);
	    dci.lpszDCISectionName = padid->pszSection;
	    dci.lpszDCIAliasName   = padid->szAlias;
#ifdef WIN4
	    dci.dnDevNode	   = padid->dnDevNode;
#endif

	    lParam2 = (LPARAM)(LPVOID)&dci;
	}

	//
	//
	//
	//
	if (NULL != had)
	{
	    lr = IDriverMessage(had, DRV_CONFIGURE, (LPARAM)(UINT_PTR)hwnd, lParam2);
	}
	else
	{
	    lr = IDriverMessageId(hadid, DRV_CONFIGURE, (LPARAM)(UINT_PTR)hwnd, lParam2);
	}
    }

    return (lr);
} // IDriverConfigure()


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverDetails
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      LPACMDRIVERDETAILS padd:
//
//      DWORD fdwDetails:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverDetails
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILS      padd,
    DWORD                   fdwDetails
)
{
    MMRESULT            mmr;
    PACMDRIVERDETAILS	paddT;
    DWORD               cbStruct;
    PACMDRIVERID        padid;

    paddT = NULL;

    DV_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);
    DV_DFLAGS(fdwDetails, IDRIVERDETAILS_VALIDF, IDriverDetails, MMSYSERR_INVALFLAG);
    DV_WPOINTER(padd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    DV_WPOINTER(padd, padd->cbStruct, MMSYSERR_INVALPARAM);

    padid = (PACMDRIVERID)hadid;

    //
    //
    //
    if (0 != (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver))
    {
        DebugErr(DBF_ERROR, "acmDriverDetails(): notification handles have no details.");
        return (MMSYSERR_NOTSUPPORTED);
    }


    paddT = (PACMDRIVERDETAILS)LocalAlloc(LPTR, sizeof(*paddT));
    if (NULL == paddT)
    {
	DPF(0, "!IDriverDetails: out of memory for caching details!");
	return (MMSYSERR_NOMEM);
    }


    //
    //  default all info then call driver to fill in what it wants
    //
    paddT->cbStruct = sizeof(*padd);
    mmr = (MMRESULT)IDriverMessageId(hadid,
				     ACMDM_DRIVER_DETAILS,
				     (LPARAM)(LPACMDRIVERDETAILS)paddT,
				     0L);
    if ((MMSYSERR_NOERROR != mmr) || (0L == paddT->vdwACM))
    {
	DPF(0, "!IDriverDetails: mmr=%u getting details for hadid=%.04Xh!", mmr, hadid);
	mmr = MMSYSERR_NOTSUPPORTED;
	goto Destruct;
    }

#ifndef WIN32
        //
        //  If this driver is a 32-bit driver, then the 32-bit side will
        //  already have set the DISABLED and LOCAL flags.  These are not
        //  really part of the drivers add, so we mask them off.  These
        //  flags are set below, and should be set every time IDriverDetails
        //  is called, rather than being cached.
        //
        if (padid->fdwAdd & ACM_DRIVERADDF_32BIT)
        {
            paddT->fdwSupport &= 0x0000001FL;
        }
#endif // !WIN32


    //
    //  copy the info from our cache
    //
    cbStruct = min(paddT->cbStruct, padd->cbStruct);
    _fmemcpy(padd, paddT, (UINT)cbStruct);
    padd->cbStruct = cbStruct;


    //
    //  Check that the driver didn't set any of the reserved flags; then
    //  set the DISABLED and LOCAL flags.
    //
    if (~0x0000001FL & padd->fdwSupport)
    {
#ifdef WIN32
        DebugErr1(DBF_ERROR, "%ls: driver set reserved bits in fdwSupport member of details struct.", (LPWSTR)padid->szAlias);
#else
        DebugErr1(DBF_ERROR, "%s: driver set reserved bits in fdwSupport member of details struct.", (LPTSTR)padid->szAlias);
#endif
	mmr = MMSYSERR_ERROR;
	goto Destruct;
    }

    if (0 != (ACMDRIVERID_DRIVERF_DISABLED & padid->fdwDriver))
    {
        padd->fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_DISABLED;
    }

    if (0 != (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver))
    {
        padd->fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_LOCAL;
    }

    //
    //
    //
Destruct:
    if (NULL != paddT) {
	LocalFree((HLOCAL)paddT);
    }

    return (mmr);
} // IDriverDetails()


//==========================================================================;
//
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverGetFormatTags
//
//  Description:
//
//
//  Arguments:
//      PACMDRIVERID padid:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IDriverGetFormatTags
(
    PACMDRIVERID            padid
)
{
    MMRESULT                mmr;
    UINT                    u;
    ACMFORMATTAGDETAILS     aftd;
    PACMFORMATTAGCACHE	    paftc = NULL;
    DWORD                   cb;

    DV_HANDLE((HACMDRIVERID)padid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

    if (NULL != padid->paFormatTagCache) {
	LocalFree((HLOCAL)padid->paFormatTagCache);
    }
    padid->paFormatTagCache = NULL;

    //
    //  check to see if there are no formats for this driver. if not, dump
    //  them...
    //
    if (0 == padid->cFormatTags)
    {
        DebugErr(DBF_ERROR, "IDriverLoad(): driver reports no format tags?");
        mmr = MMSYSERR_ERROR;
        goto Destruct;
    }


    //
    //  alloc an array of tag data structures to hold info for format tags
    //
    cb    = sizeof(*paftc) * padid->cFormatTags;
    paftc = (PACMFORMATTAGCACHE)LocalAlloc(LPTR, (UINT)cb);
    if (NULL == paftc)
    {
        DebugErr(DBF_ERROR, "IDriverGetFormatTags(): out of memory for format cache!");
        mmr = MMSYSERR_NOMEM;
        goto Destruct;
    }


    //
    //
    //
    padid->paFormatTagCache = paftc;
    for (u = 0; u < padid->cFormatTags; u++)
    {
        aftd.cbStruct         = sizeof(aftd);
        aftd.dwFormatTagIndex = u;

        mmr = (MMRESULT)IDriverMessageId((HACMDRIVERID)padid,
					 ACMDM_FORMATTAG_DETAILS,
					 (LPARAM)(LPVOID)&aftd,
					 ACM_FORMATTAGDETAILSF_INDEX);
        if (MMSYSERR_NOERROR != mmr)
        {
            DebugErr(DBF_ERROR, "IDriverGetFormatTags(): driver failed format tag details query!");
            goto Destruct;
        }

	//
	//  Following switch is just some validation for debug
	//
#ifdef RDEBUG
        switch (aftd.dwFormatTag)
        {
            case WAVE_FORMAT_UNKNOWN:
                DebugErr(DBF_ERROR, "IDriverGetFormatTags(): driver returned format tag 0!");
                mmr = MMSYSERR_ERROR;
                goto Destruct;

            case WAVE_FORMAT_PCM:
                if ('\0' != aftd.szFormatTag[0])
                {
                    DebugErr(DBF_WARNING, "IDriverGetFormatTags(): driver returned custom PCM format tag name! ignoring it!");
                }
                break;

            case WAVE_FORMAT_DEVELOPMENT:
                DebugErr(DBF_WARNING, "IDriverGetFormatTags(): driver returned DEVELOPMENT format tag--do not ship this way.");
                break;

        }
#endif

	paftc[u].dwFormatTag = aftd.dwFormatTag;
	paftc[u].cbFormatSize = aftd.cbFormatSize;

    }

    //
    //
    //
Destruct:
    if (MMSYSERR_NOERROR != mmr)
    {
	if (NULL != paftc ) {
	    LocalFree((HLOCAL)paftc);
	}
    }

    return (mmr);

} // IDriverGetFormatTags()


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverGetFilterTags
//
//  Description:
//
//
//  Arguments:
//      PACMDRIVERID padid:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IDriverGetFilterTags
(
    PACMDRIVERID    padid
)
{
    MMRESULT                mmr;
    UINT                    u;
    ACMFILTERTAGDETAILS     aftd;
    PACMFILTERTAGCACHE	    paftc = NULL;
    DWORD                   cb;

    DV_HANDLE((HACMDRIVERID)padid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

    if (NULL != padid->paFilterTagCache) {
	LocalFree((HLOCAL)padid->paFilterTagCache);
    }
    padid->paFilterTagCache = NULL;

    //
    //  check to see if there are no filters for this driver. if not, null
    //  our cache pointers and succeed..
    //
    if (0 != (ACMDRIVERDETAILS_SUPPORTF_FILTER & padid->fdwSupport))
    {
        if (0 == padid->cFilterTags)
        {
            DebugErr(DBF_ERROR, "IDriverLoad(): filter driver reports no filter tags?");
            mmr = MMSYSERR_ERROR;
            goto Destruct;
        }
    }
    else
    {
        if (0 == padid->cFilterTags)
            return (MMSYSERR_NOERROR);

        DebugErr(DBF_ERROR, "IDriverLoad(): non-filter driver reports filter tags?");
        mmr = MMSYSERR_ERROR;
        goto Destruct;
    }



    //
    //  alloc an array of details structures to hold info for filter tags
    //
    cb    = sizeof(*paftc) * padid->cFilterTags;
    paftc = (PACMFILTERTAGCACHE)LocalAlloc(LPTR, (UINT)cb);
    if (NULL == paftc)
    {
        DebugErr(DBF_ERROR, "IDriverGetFilterTags(): out of memory for filter cache!");
        mmr = MMSYSERR_NOMEM;
        goto Destruct;
    }


    //
    //
    //
    padid->paFilterTagCache = paftc;
    for (u = 0; u < padid->cFilterTags; u++)
    {

        aftd.cbStruct         = sizeof(aftd);
        aftd.dwFilterTagIndex = u;

        mmr = (MMRESULT)IDriverMessageId((HACMDRIVERID)padid,
                                         ACMDM_FILTERTAG_DETAILS,
                                         (LPARAM)(LPVOID)&aftd,
					 ACM_FILTERTAGDETAILSF_INDEX);
        if (MMSYSERR_NOERROR != mmr)
        {
            DebugErr(DBF_ERROR, "IDriverGetFilterTags(): driver failed filter tag details query!");
            goto Destruct;
        }

	//
	//  Following switch is just some validation for debug
	//
#ifdef RDEBUG
        switch (aftd.dwFilterTag)
        {
            case WAVE_FILTER_UNKNOWN:
                DebugErr(DBF_ERROR, "IDriverGetFilterTags(): driver returned filter tag 0!");
                mmr = MMSYSERR_ERROR;
                goto Destruct;

            case WAVE_FILTER_DEVELOPMENT:
                DebugErr(DBF_WARNING, "IDriverGetFilterTags(): driver returned DEVELOPMENT filter tag--do not ship this way.");
                break;
        }
#endif

        paftc[u].dwFilterTag = aftd.dwFilterTag;
        paftc[u].cbFilterSize = aftd.cbFilterSize;
	
    }


    //
    //
    //
Destruct:
    if (MMSYSERR_NOERROR != mmr)
    {
	if (NULL != paftc ) {
	    LocalFree((HLOCAL)paftc);
	}
    }

    return (mmr);

} // IDriverGetFilterTags()


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverGetWaveIdentifier
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      LPDWORD pdw:
//
//      BOOL fInput:
//
//  Return (MMRESULT):
//
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverGetWaveIdentifier
(
    HACMDRIVERID            hadid,
    LPDWORD                 pdw,
    BOOL                    fInput
)
{
    PACMDRIVERID        padid;
    MMRESULT            mmr;
    UINT                u;
    UINT                cDevs;
    UINT                uId;

    DV_WPOINTER(pdw, sizeof(DWORD), MMSYSERR_INVALPARAM);

    *pdw = (DWORD)-1L;

    DV_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

    padid = (PACMDRIVERID)hadid;

    uId = (UINT)WAVE_MAPPER;

    //
    //  check to see if there is hardware support
    //
    if (0 == (ACMDRIVERDETAILS_SUPPORTF_HARDWARE & padid->fdwSupport))
    {
        DebugErr1(DBF_ERROR, "IDriverGetWaveIdentifier: driver (%ls) does not support _HARDWARE.", (LPTSTR)padid->szAlias);
        return (MMSYSERR_INVALHANDLE);
    }

    if (fInput)
    {
        WAVEINCAPS          wic;
        WAVEINCAPS          wicSearch;

        _fmemset(&wic, 0, sizeof(wic));
        mmr = (MMRESULT)IDriverMessageId(hadid,
                                         ACMDM_HARDWARE_WAVE_CAPS_INPUT,
                                         (LPARAM)(LPVOID)&wic,
                                         sizeof(wic));
        if (MMSYSERR_NOERROR == mmr)
        {
            mmr   = MMSYSERR_NODRIVER;

            wic.szPname[SIZEOF(wic.szPname) - 1] = '\0';

            cDevs = waveInGetNumDevs();

            for (u = 0; u < cDevs; u++)
            {
                _fmemset(&wicSearch, 1, sizeof(wicSearch));
		if (0 != waveInGetDevCaps(u, &wicSearch, sizeof(wicSearch)))
                {
                    continue;
                }

                wicSearch.szPname[SIZEOF(wicSearch.szPname) - 1] = '\0';

                if (0 == lstrcmp(wic.szPname, wicSearch.szPname))
                {
                    uId = u;
                    mmr = MMSYSERR_NOERROR;
                    break;
                }
            }
        }
    }
    else
    {
        WAVEOUTCAPS         woc;
        WAVEOUTCAPS         wocSearch;

        _fmemset(&woc, 0, sizeof(woc));
        mmr = (MMRESULT)IDriverMessageId(hadid,
                                         ACMDM_HARDWARE_WAVE_CAPS_OUTPUT,
                                         (LPARAM)(LPVOID)&woc,
                                         sizeof(woc));
        if (MMSYSERR_NOERROR == mmr)
        {
            mmr   = MMSYSERR_NODRIVER;

            woc.szPname[SIZEOF(woc.szPname) - 1] = '\0';

            cDevs = waveOutGetNumDevs();

            for (u = 0; u < cDevs; u++)
            {
                _fmemset(&wocSearch, 1, sizeof(wocSearch));
                if (0 != waveOutGetDevCaps(u, (LPWAVEOUTCAPS)&wocSearch, sizeof(wocSearch)))
                {
                    continue;
                }

                wocSearch.szPname[SIZEOF(wocSearch.szPname) - 1] = '\0';

                if (0 == lstrcmp(woc.szPname, wocSearch.szPname))
                {
                    uId = u;
                    mmr = MMSYSERR_NOERROR;
                    break;
                }
            }
        }

    }

    *pdw = (DWORD)(long)(int)uId;

    //
    //
    //
    return (mmr);
} // IDriverGetWaveIdentifier()


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverFree
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      DWORD fdwFree:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IDriverFree
(
    HACMDRIVERID            hadid,
    DWORD                   fdwFree
)
{
    PACMDRIVERID        padid;
    BOOL                f;

    DV_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);
    DV_DFLAGS(fdwFree, IDRIVERFREE_VALIDF, IDriverFree, MMSYSERR_INVALFLAG);

    padid = (PACMDRIVERID)hadid;

    //
    //
    //
    if (0 == (ACMDRIVERID_DRIVERF_LOADED & padid->fdwDriver))
    {
        DebugErr1(DBF_WARNING, "ACM driver (%ls) is not loaded.", (LPTSTR)padid->szAlias);
        return (MMSYSERR_NOERROR);
    }

#ifdef WIN32
    DPF(1, "IDriverFree(): freeing ACM driver (%ls).", (LPWSTR)padid->szAlias);
#else
    DPF(1, "IDriverFree(): freeing ACM driver (%s).",  (LPTSTR)padid->szAlias);
#endif

    //
    //
    //
    //
    if (NULL != padid->padFirst)
    {
        DebugErr1(DBF_ERROR, "ACM driver (%ls) has open instances--unable to unload.", (LPTSTR)padid->szAlias);
        return (MMSYSERR_ALLOCATED);
    }

#ifndef WIN32

    //
    //  We never really remove a 32-bit driver like this from
    //  the 16-bit side - but we can remove our knowledge of it - so
    //  we don't do the driver close bit in this case.
    //

    if (padid->fdwAdd & ACM_DRIVERADDF_32BIT) {
        f = TRUE;
        padid->hadid32 = 0;
    } else
#endif // !WIN32
    {
        //
        //  clear the rest of the table entry
        //
        f = TRUE;
        if (NULL != padid->fnDriverProc)
        {
            if (0 == (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver))
            {
                //
                //  bogus the CloseDriver sequence to the driver function
                //
                f = (0L != IDriverMessageId(hadid, DRV_CLOSE, 0L, 0L));
                if (f)
                {
                    IDriverMessageId(hadid, DRV_DISABLE, 0L, 0L);
                    IDriverMessageId(hadid, DRV_FREE, 0L, 0L);
                }
            }
        }
        else if (NULL != padid->hdrvr)
        {
            f = 0L != CloseDriver(padid->hdrvr, 0L, 0L);
        }
    }

    if (!f)
    {
        DebugErr1(DBF_WARNING, "ACM driver (%ls) is refusing to close.", (LPTSTR)padid->szAlias);
        return (MMSYSERR_ERROR);
    }

    //
    //
    //
    padid->fdwDriver  &= ~ACMDRIVERID_DRIVERF_LOADED;
    padid->dwInstance  = 0L;
    padid->hdrvr       = NULL;

    return (MMSYSERR_NOERROR);
} // IDriverFree()


//==========================================================================;
//
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverWriteRegistryData
//
//  Description:
//	Writes to the registry some data which describes a driver.
//
//  Arguments:
//      PACMDRIVERID padid:
//	    Pointer to ACMDRIVERID.
//
//  Return (MMRESULT):
//
//  History:
//      08/30/94    frankye
//
//  Notes:
//	This function will succeed only for drivers added with
//	ACM_DRIVERADDF_NAME.  The function attempts to open a key having
//	the same name as the szAlias member of ACMDRIVERID.  The data
//	stored under that key is:
//
//		    !!! TBD !!!
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IDriverWriteRegistryData(PACMDRIVERID padid)
{
    DWORD		fdwSupport;
    DWORD		cFormatTags;
    PACMFORMATTAGCACHE	paFormatTagCache;
    UINT		cbaFormatTagCache;
    DWORD		cFilterTags;
    PACMFILTERTAGCACHE	paFilterTagCache;
    UINT		cbaFilterTagCache;
    HKEY		hkeyDriverCache;
    HKEY		hkeyCache = NULL;
    TCHAR		szAlias[MAX_DRIVER_NAME_CHARS];
    MMRESULT		mmr;

#ifdef DEBUG
    DWORD   dwTime;

    dwTime = timeGetTime();
#endif

    hkeyDriverCache	= NULL;
    hkeyCache		= NULL;

    //
    //  We only keep registry data for ACM_DRIVERADDF_NAME drivers.
    //
    if (ACM_DRIVERADDF_NAME != (padid->fdwAdd & ACM_DRIVERADDF_TYPEMASK))
    {
	mmr = MMSYSERR_NOTSUPPORTED;
	goto Destruct;
    }

    //
    //	Get fdwSupport and counts of format/filter tags and ptrs to their
    //	cache arrays into more convenient variables.  Also compute the size
    //	of the cache arrays.
    //
    fdwSupport  = padid->fdwSupport;
    cFormatTags = padid->cFormatTags;
    paFormatTagCache = padid->paFormatTagCache;
    cbaFormatTagCache = (UINT)cFormatTags * sizeof(*paFormatTagCache);

    cFilterTags = padid->cFilterTags;
    paFilterTagCache = padid->paFilterTagCache;
    cbaFilterTagCache = (UINT)cFilterTags * sizeof(*paFilterTagCache);

    ASSERT( (0 == cFormatTags) || (NULL != paFormatTagCache) );
    ASSERT( (0 == cFilterTags) || (NULL != paFilterTagCache) );

    //
    //	Open/create registry keys under which we store the cache information.
    //
    if (ERROR_SUCCESS != XRegCreateKey( HKEY_LOCAL_MACHINE, gszDriverCache, &hkeyDriverCache ))
    {
	hkeyDriverCache = NULL;
	mmr = MMSYSERR_NOMEM;	// Can't think of anything better
	goto Destruct;
    }

#if defined(WIN32) && !defined(UNICODE)
    Iwcstombs(szAlias, padid->szAlias, SIZEOF(szAlias));
#else
    lstrcpy(szAlias, padid->szAlias);
#endif
    if (ERROR_SUCCESS != XRegCreateKey( hkeyDriverCache, szAlias, &hkeyCache ))
    {
	mmr = MMSYSERR_NOMEM;	// Can't think of anything better
	goto Destruct;
    }

    //
    //	Write all our cache information to the registry.
    //	    fdwSupport
    //	    cFormatTags
    //	    aFormatTagCache
    //	    cFilterTags
    //	    aFilterTagCache
    //
    XRegSetValueEx( hkeyCache, gszValfdwSupport, 0L, REG_DWORD,
		   (LPBYTE)&fdwSupport, sizeof(fdwSupport) );

    XRegSetValueEx( hkeyCache, gszValcFormatTags, 0L, REG_DWORD,
		   (LPBYTE)&cFormatTags, sizeof(cFormatTags) );

    if (0 != cFormatTags) {
	XRegSetValueEx( hkeyCache, gszValaFormatTagCache, 0L, REG_BINARY,
		       (LPBYTE)paFormatTagCache, cbaFormatTagCache );
    }

    XRegSetValueEx( hkeyCache, gszValcFilterTags, 0L, REG_DWORD,
		   (LPBYTE)&cFilterTags, sizeof(cFilterTags) );

    if (0 != cFilterTags) {
	XRegSetValueEx( hkeyCache, gszValaFilterTagCache, 0L, REG_BINARY,
		       (LPBYTE)paFilterTagCache, cbaFilterTagCache );
    }

    //
    //
    //
    mmr	    = MMSYSERR_NOERROR;

    //
    //	Clean up and return
    //
Destruct:
    if (NULL != hkeyCache) {
	XRegCloseKey(hkeyCache);
    }
    if (NULL != hkeyDriverCache) {
	XRegCloseKey(hkeyDriverCache);
    }

#ifdef DEBUG
    dwTime = timeGetTime() - dwTime;
    DPF(4, "IDriverWriteRegistryData: took %d ms", dwTime);
#endif
	
    return (mmr);
}

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverReadRegistryData
//
//  Description:
//	Reads from the registry data which describes a driver.
//
//  Arguments:
//      PACMDRIVERID padid:
//	    Pointer to ACMDRIVERID.
//
//  Return (MMRESULT):
//
//  History:
//      08/30/94    frankye
//
//  Notes:
//	This function will succeed only for drivers added with
//	ACM_DRIVERADDF_NAME.  The function attempts to open a key having
//	the same name as the szAlias member of ACMDRIVERID.  The data
//	stored under that key is described in the comment header for
//	IDriverWriteRegistryData().
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IDriverReadRegistryData(PACMDRIVERID padid)
{

    HKEY		    hkeyDriverCache;
    HKEY		    hkeyCache;
    DWORD		    fdwSupport;
    DWORD		    cFormatTags;
    DWORD		    cFilterTags;
    PACMFORMATTAGCACHE	    paFormatTagCache;
    UINT		    cbaFormatTagCache;
    PACMFILTERTAGCACHE	    paFilterTagCache;
    UINT		    cbaFilterTagCache;
    TCHAR		    szAlias[MAX_DRIVER_NAME_CHARS];
    DWORD		    dwType;
    DWORD		    cbData;
    LONG		    lr;
    MMRESULT		    mmr;

#ifdef DEBUG
    DWORD dwTime;

    dwTime = timeGetTime();
#endif

    hkeyDriverCache	= NULL;
    hkeyCache		= NULL;
    paFormatTagCache	= NULL;
    paFilterTagCache	= NULL;

    //
    //  We only keep registry data for ACM_DRIVERADDF_NAME drivers.
    //
    if (ACM_DRIVERADDF_NAME != (padid->fdwAdd & ACM_DRIVERADDF_TYPEMASK))
    {
	mmr = MMSYSERR_NOTSUPPORTED;
	goto Destruct;
    }

    //
    //	Open the registry keys under which we store the cache information
    //
    lr = XRegOpenKey( HKEY_LOCAL_MACHINE, gszDriverCache, &hkeyDriverCache );
    if ( ERROR_SUCCESS != lr )
    {
	hkeyDriverCache = NULL;
	mmr = MMSYSERR_NOMEM;	// Can't think of anything better
	goto Destruct;
    }

#if defined(WIN32) && !defined(UNICODE)
    Iwcstombs(szAlias, padid->szAlias, SIZEOF(szAlias));
#else
    lstrcpy(szAlias, padid->szAlias);
#endif
    lr = XRegOpenKey( hkeyDriverCache, szAlias, &hkeyCache );
    if (ERROR_SUCCESS != lr)
    {
	mmr = ACMERR_NOTPOSSIBLE;    // Can't think of anything better
	goto Destruct;
    }

    //
    //	Attempt to read the fdwSupport for this driver
    //
    cbData = sizeof(fdwSupport);
    lr = XRegQueryValueEx( hkeyCache, gszValfdwSupport, 0L, &dwType,
			  (LPBYTE)&fdwSupport, &cbData );

    if ( (ERROR_SUCCESS != lr) ||
	 (REG_DWORD != dwType) ||
	 (sizeof(fdwSupport) != cbData) )
    {
	mmr = ACMERR_NOTPOSSIBLE;
	goto Destruct;
    }

    //
    //	Attempt to read cFormatTags for this driver.  If more than zero
    //	format tags, then allocate a FormatTagCache array and attempt to
    //	read the cache array from the registry.
    //
    cbData = sizeof(cFormatTags);
    lr = XRegQueryValueEx( hkeyCache, gszValcFormatTags, 0L, &dwType,
			  (LPBYTE)&cFormatTags, &cbData );

    if ( (ERROR_SUCCESS != lr) ||
	 (REG_DWORD != dwType) ||
	 (sizeof(cFormatTags) != cbData) )
    {
	mmr = ACMERR_NOTPOSSIBLE;
	goto Destruct;
    }

    if (0 != cFormatTags)
    {
	cbaFormatTagCache = (UINT)cFormatTags * sizeof(*paFormatTagCache);
	paFormatTagCache = (PACMFORMATTAGCACHE)LocalAlloc(LPTR, cbaFormatTagCache);
	if (NULL == paFormatTagCache) {
	    mmr = MMSYSERR_NOMEM;
	    goto Destruct;
	}

	cbData = cbaFormatTagCache;
	lr = XRegQueryValueEx( hkeyCache, gszValaFormatTagCache, 0L, &dwType,
			      (LPBYTE)paFormatTagCache, &cbData );

	if ( (ERROR_SUCCESS != lr) ||
	     (REG_BINARY != dwType) ||
	     (cbaFormatTagCache != cbData) )
	{
	    mmr = ACMERR_NOTPOSSIBLE;
	    goto Destruct;
	}

    }

    //
    //	Attempt to read cFilterTags for this driver.  If more than zero
    //	filter tags, then allocate a FilterTagCache array and attempt to
    //	read the cache array from the registry.
    //
    cbData = sizeof(cFilterTags);
    lr = XRegQueryValueEx( hkeyCache, gszValcFilterTags, 0L, &dwType,
			  (LPBYTE)&cFilterTags, &cbData );

    if ( (ERROR_SUCCESS != lr) ||
	 (REG_DWORD != dwType) ||
	 (sizeof(cFilterTags) != cbData) )
    {
	mmr = ACMERR_NOTPOSSIBLE;
	goto Destruct;
    }

    if (0 != cFilterTags)
    {
	cbaFilterTagCache = (UINT)cFilterTags * sizeof(*paFilterTagCache);
	paFilterTagCache = (PACMFILTERTAGCACHE)LocalAlloc(LPTR, cbaFilterTagCache);
	if (NULL == paFilterTagCache) {
	    mmr = MMSYSERR_NOMEM;
	    goto Destruct;
	}

	cbData = cbaFilterTagCache;
	lr = XRegQueryValueEx( hkeyCache, gszValaFilterTagCache, 0L, &dwType,
			      (LPBYTE)paFilterTagCache, &cbData );

	if ( (ERROR_SUCCESS != lr) ||
	     (REG_BINARY != dwType) ||
	     (cbaFilterTagCache != cbData) )
	{
	    mmr = ACMERR_NOTPOSSIBLE;
	    goto Destruct;
	}

    }

    //
    //	Copy all the cache information to the ACMDRIVERID structure for
    //	this driver.  Note that we use the cache arrays that were allocated
    //	in this function.
    //
    padid->fdwSupport	    = fdwSupport;
    padid->cFormatTags	    = (UINT)cFormatTags;
    padid->paFormatTagCache = paFormatTagCache;
    padid->cFilterTags	    = (UINT)cFilterTags;
    padid->paFilterTagCache = paFilterTagCache;

    mmr			    = MMSYSERR_NOERROR;

    //
    //	Clean up and return.
    //
Destruct:
    if (MMSYSERR_NOERROR != mmr)
    {
	if (NULL != paFormatTagCache) {
	    LocalFree((HLOCAL)paFormatTagCache);
	}
	if (NULL != paFilterTagCache) {
	    LocalFree((HLOCAL)paFilterTagCache);
	}
    }
    if (NULL != hkeyCache) {
	XRegCloseKey(hkeyCache);
    }
    if (NULL != hkeyDriverCache) {
	XRegCloseKey(hkeyDriverCache);
    }

#ifdef DEBUG
    dwTime = timeGetTime() - dwTime;
    DPF(4, "IDriverReadRegistryData: took %d ms", dwTime);
#endif

    return (mmr);
}


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverLoad
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      DWORD fdwLoad:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IDriverLoad
(
    HACMDRIVERID            hadid,
    DWORD                   fdwLoad
)
{
    BOOL                f;
    PACMDRIVERID        padid;
    PACMDRIVERDETAILS   padd;
    MMRESULT            mmr;

    DV_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);
    DV_DFLAGS(fdwLoad, IDRIVERLOAD_VALIDF, IDriverLoad, MMSYSERR_INVALFLAG);

    padd  = NULL;
    padid = (PACMDRIVERID)hadid;

    //
    //
    //
    if (0 != (ACMDRIVERID_DRIVERF_LOADED & padid->fdwDriver))
    {
        DPF(0, "!IDriverLoad: driver is already loaded!");
	mmr = MMSYSERR_NOERROR;
	goto Destruct;
    }

    //
    //
    //
#ifdef WIN32
    DPF(1, "IDriverLoad(): loading ACM driver (%ls).", (LPWSTR)padid->szAlias);
#else
    DPF(1, "IDriverLoad(): loading ACM driver (%s).",  (LPTSTR)padid->szAlias);
#endif

    //
    //  note that lParam2 is set to 0L in this case to signal the driver
    //  that it is merely being loaded to put it in the list--not for an
    //  actual conversion. therefore, drivers do not need to allocate
    //  any instance data on this initial DRV_OPEN (unless they want to)
    //
    mmr = MMSYSERR_NOERROR;

#ifndef WIN32
    if (padid->fdwAdd & ACM_DRIVERADDF_32BIT)
    {
	mmr = IDriverLoad32(padid->hadid32, padid->fdwAdd);
    }
    else
#endif // !WIN32
    {
        if (NULL == padid->fnDriverProc)
        {
	    if (padid->fdwAdd & ACM_DRIVERADDF_PNP)
	    {
		padid->hdrvr = OpenDriver(padid->pstrPnpDriverFilename, NULL, 0L);
	    }
	    else
	    {
		padid->hdrvr = OpenDriver(padid->szAlias, padid->pszSection, 0L);
	    }
	
	    if (padid->hdrvr == NULL)
            {
                mmr = MMSYSERR_NODRIVER;
            }
        }
        //
        //  if the driver is a ACM_DRIVERADDF_FUNCTION, then we bogus
        //  what an OpenDriver() call would look like to the function.
        //
        else if (0 == (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver))
        {
            if (!IDriverMessageId(hadid, DRV_LOAD, 0L, 0L))
            {
                mmr = MMSYSERR_NODRIVER;
            }
            else
            {
                IDriverMessageId(hadid, DRV_ENABLE, 0L, 0L);

                padid->dwInstance = IDriverMessageId(hadid, DRV_OPEN, 0L, 0L);
                if (0L == padid->dwInstance)
                {
                    mmr = MMSYSERR_NODRIVER;
                }
            }
        }
    }

    if (MMSYSERR_NOERROR != mmr)
    {
        DebugErr1(DBF_WARNING, "ACM driver (%ls) failed to load.", (LPTSTR)padid->szAlias);
	padid->fRemove = TRUE;	    // Try to remove next chance.
	goto Destruct;
    }


    //
    //  mark driver as loaded (although we may dump it back out if something
    //  is bogus below...)
    //
    padid->fdwDriver |= ACMDRIVERID_DRIVERF_LOADED;

    if (0 != (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver))
    {
	mmr = (MMSYSERR_NOERROR);
	goto Destruct;
    }


    //
    //	In case any of the following validation fails, flag this driver
    //	to be removed next chance
    //
    padid->fRemove = TRUE;

    //
    //  now get the driver details--we use this all the time, so we will
    //  cache it. this also enables us to free a driver until it is needed
    //  for real work...
    //
    padd = (PACMDRIVERDETAILS)LocalAlloc(LPTR, sizeof(*padd));
    if (NULL == padd) {
	mmr = MMSYSERR_NOMEM;
	goto Destruct;
    }
    padd->cbStruct = sizeof(*padd);
    mmr = IDriverDetails(hadid, padd, 0L);

    if (MMSYSERR_NOERROR != mmr)
    {
        DebugErr1(DBF_ERROR, "%ls: failed driver details query.", (LPTSTR)padid->szAlias);
	goto Destruct;
    }

    if (HIWORD(VERSION_MSACM) < HIWORD(padd->vdwACM))
    {
        DebugErr2(DBF_ERROR, "%ls: driver requires V%.04Xh of ACM.", (LPTSTR)padid->szAlias, HIWORD(padd->vdwACM));
	mmr = (MMSYSERR_ERROR);
	goto Destruct;
    }

    if (sizeof(*padd) != padd->cbStruct)
    {
        DebugErr1(DBF_ERROR, "%ls: driver returned incorrect driver details struct size.", (LPTSTR)padid->szAlias);
	mmr = (MMSYSERR_ERROR);
	goto Destruct;
    }

    if ((ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != padd->fccType) ||
        (ACMDRIVERDETAILS_FCCCOMP_UNDEFINED  != padd->fccComp))
    {
        DebugErr1(DBF_ERROR, "%ls: driver returned incorrect fccType or fccComp in driver details.", (LPTSTR)padid->szAlias);
	mmr = (MMSYSERR_ERROR);
	goto Destruct;
    }

    if ((0 == padd->wMid) || (0 == padd->wPid))
    {
        DebugErr1(DBF_WARNING, "%ls: wMid/wPid must be finalized before shipping.", (LPTSTR)padid->szAlias);
    }

#if defined(WIN32) && !defined(UNICODE)
    if ( (!_V_STRINGW(padd->szShortName, SIZEOFW(padd->szShortName))) ||
	 (!_V_STRINGW(padd->szLongName,  SIZEOFW(padd->szLongName)))  ||
	 (!_V_STRINGW(padd->szCopyright, SIZEOFW(padd->szCopyright))) ||
	 (!_V_STRINGW(padd->szLicensing, SIZEOFW(padd->szLicensing))) ||
	 (!_V_STRINGW(padd->szFeatures,  SIZEOFW(padd->szFeatures))) )
    {
	mmr = MMSYSERR_ERROR;
	goto Destruct;
    }
#else
    if ( (!_V_STRING(padd->szShortName, SIZEOF(padd->szShortName))) ||
	 (!_V_STRING(padd->szLongName, SIZEOF(padd->szLongName)))   ||
	 (!_V_STRING(padd->szCopyright, SIZEOF(padd->szCopyright))) ||
	 (!_V_STRING(padd->szLicensing, SIZEOF(padd->szLicensing))) ||
	 (!_V_STRING(padd->szFeatures, SIZEOF(padd->szFeatures))) )
    {
	mmr = MMSYSERR_ERROR;
	goto Destruct;
    }
#endif

    //
    //	Above validation succeeded.  Reset the fRemove flag.
    //
    padid->fRemove = FALSE;

    //
    //	We don't keep the DISABLED flag in the fdwSupport cache.
    //
    padid->fdwSupport = padd->fdwSupport & ~ACMDRIVERDETAILS_SUPPORTF_DISABLED;

    padid->cFormatTags = (UINT)padd->cFormatTags;
    mmr = IDriverGetFormatTags(padid);
    if (MMSYSERR_NOERROR != mmr)
    {
	padid->fRemove = TRUE;
	goto Destruct;
    }

    padid->cFilterTags = (UINT)padd->cFilterTags;
    mmr = IDriverGetFilterTags(padid);
    if (MMSYSERR_NOERROR != mmr)
    {
	padid->fRemove = TRUE;
	goto Destruct;
    }

    //
    //  now get some info about the driver so we don't have to keep
    //  asking all the time...
    //
    f = (0L != IDriverMessageId(hadid, DRV_QUERYCONFIGURE, 0L, 0L));
    if (f)
    {
        padid->fdwDriver |= ACMDRIVERID_DRIVERF_CONFIGURE;
    }

    f = (MMSYSERR_NOERROR == IDriverMessageId(hadid, ACMDM_DRIVER_ABOUT, -1L, 0L));
    if (f)
    {
        padid->fdwDriver |= ACMDRIVERID_DRIVERF_ABOUT;
    }

    //
    //	Save some of the ACMDRIVERID stuff to the registry
    //
    IDriverWriteRegistryData(padid);

    mmr = MMSYSERR_NOERROR;

    //
    //
    //
Destruct:
    if (NULL != padd) {
	LocalFree((HLOCAL)padd);
    }
    return (mmr);

} // IDriverLoad()


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverGetNext
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//      LPHACMDRIVERID phadidNext:
//
//      HACMDRIVERID hadid:
//
//      DWORD fdwGetNext:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverGetNext
(
    PACMGARB		    pag,
    LPHACMDRIVERID          phadidNext,
    HACMDRIVERID            hadid,
    DWORD                   fdwGetNext
)
{
    HTASK               htask;
    PACMDRIVERID        padid;
    BOOL                fDisabled;
    BOOL                fLocal;
    BOOL                fNotify;
    BOOL                fEverything;
    BOOL		fRemove;

    DV_WPOINTER(phadidNext, sizeof(HACMDRIVERID), MMSYSERR_INVALPARAM);

    *phadidNext = NULL;

    if (-1L == fdwGetNext)
    {
        fEverything = TRUE;
    }
    else
    {
        DV_DFLAGS(fdwGetNext, IDRIVERGETNEXT_VALIDF, IDriverGetNext, MMSYSERR_INVALFLAG);

        fEverything = FALSE;

        //
        //  put flags in more convenient (cheaper) variables
        //
        fDisabled = (0 != (ACM_DRIVERENUMF_DISABLED & fdwGetNext));
        fLocal    = (0 == (ACM_DRIVERENUMF_NOLOCAL & fdwGetNext));
        fNotify   = (0 != (ACM_DRIVERENUMF_NOTIFY & fdwGetNext));
	fRemove   = (0 != (ACM_DRIVERENUMF_REMOVED & fdwGetNext));
    }

    //
    //  init where to start searching from
    //
    if (NULL != hadid)
    {
        DV_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

        padid = (PACMDRIVERID)hadid;
	if (pag != padid->pag)
	{
	    return (MMSYSERR_INVALHANDLE);
	}
        htask = padid->htask;
        padid = padid->padidNext;
    }
    else
    {
        padid = pag->padidFirst;
        htask = GetCurrentTask();
    }

    if (fEverything)
    {
        htask = NULL;
    }

Driver_Get_Next_Find_Driver:

    for ( ; padid; padid = padid->padidNext)
    {
        if (fEverything)
        {
            *phadidNext = (HACMDRIVERID)padid;
            return (MMSYSERR_NOERROR);
        }

        //
        //  htask will be NULL for global drivers--do not return padid
        //  if it is a local driver to another task
        //
        if (padid->htask != htask)
            continue;

        if (!fNotify && (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver))
            continue;

        if (!fLocal && (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver))
            continue;

        //
        //  if we are not supposed to include disabled drivers and
        //  padid is disabled, then skip it
        //
        if (!fDisabled && (ACMDRIVERID_DRIVERF_DISABLED & padid->fdwDriver))
            continue;

	//
	//  if we are not supposed to include drivers to be removed and
	//  this padid is to be removed then skip it.
	//
	if (!fRemove && padid->fRemove)
	    continue;

        *phadidNext = (HACMDRIVERID)padid;

        return (MMSYSERR_NOERROR);
    }

    if (NULL != htask)
    {
        //
        //  all done with the local drivers, now go try the global ones.
        //
        htask = NULL;
        padid = pag->padidFirst;

        goto Driver_Get_Next_Find_Driver;
    }

    //
    //  no more drivers in the list--*phadNext is set to NULL and we
    //  return the stopping condition error (not really an error...)
    //
    DPF(5, "IDriverGetNext()--NO MORE DRIVERS");

    //
    //  We should be returning NULL in *phadidNext ... let's just make sure.
    //
    ASSERT( NULL == *phadidNext );

    return (MMSYSERR_BADDEVICEID);
} // IDriverGetNext()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverSupport
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      LPDWORD pfdwSupport:
//
//      BOOL fFullSupport:
//
//  Return (MMRESULT):
//
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverSupport
(
    HACMDRIVERID            hadid,
    LPDWORD                 pfdwSupport,
    BOOL                    fFullSupport
)
{
    PACMDRIVERID        padid;
    DWORD               fdwSupport;

    DV_WPOINTER(pfdwSupport, sizeof(DWORD), MMSYSERR_INVALPARAM);

    *pfdwSupport = 0L;

    DV_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);


    padid = (PACMDRIVERID)hadid;

    fdwSupport = padid->fdwSupport;

    if (fFullSupport)
    {
        if (0 != (ACMDRIVERID_DRIVERF_DISABLED & padid->fdwDriver))
        {
            fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_DISABLED;
        }

        if (0 != (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver))
        {
            fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_LOCAL;
        }

        if (0 != (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver))
        {
            fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_NOTIFY;
        }
    }

    *pfdwSupport = fdwSupport;

    return (MMSYSERR_NOERROR);
} // IDriverSupport()


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverCount
//
//  Description:
//
//
//  Arguments:
//
//	PACMGARB pag:
//
//      DWORD pdwCount:
//
//      DWORD fdwSupport:
//
//      DWORD fdwEnum:
//
//  Return (MMRESULT):
//
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverCount
(
    PACMGARB		    pag,
    LPDWORD                 pdwCount,
    DWORD                   fdwSupport,
    DWORD                   fdwEnum
)
{
    MMRESULT            mmr;
    DWORD               fdw;
    DWORD               cDrivers;
    HACMDRIVERID        hadid;

    DV_WPOINTER(pdwCount, sizeof(DWORD), MMSYSERR_INVALPARAM);

    *pdwCount = 0;

    DV_DFLAGS(fdwEnum, ACM_DRIVERENUMF_VALID, IDriverCount, MMSYSERR_INVALFLAG);

    cDrivers = 0;

    hadid = NULL;

    ENTER_LIST_SHARED;

    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, fdwEnum))
    {
        mmr = IDriverSupport(hadid, &fdw, TRUE);
        if (MMSYSERR_NOERROR != mmr)
            continue;

        if (fdwSupport == (fdw & fdwSupport))
        {
            cDrivers++;
        }
    }

    LEAVE_LIST_SHARED;

    *pdwCount = cDrivers;

    return (MMSYSERR_NOERROR);
} // IDriverCount()


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverCountGlobal
//
//  Description:
//      You can't really count the number of global drivers with
//      IDriverCount, so rather than mess with it I'm writing another
//      routine.
//
//  Arguments:
//
//	PACMGARB pag:
//
//      DWORD pdwCount:
//
//  Return (MMRESULT):
//
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL IDriverCountGlobal
(
    PACMGARB	            pag
)
{
    DWORD               cDrivers = 0;
    HACMDRIVERID        hadid;
    DWORD               fdwEnum;

    ASSERT( NULL != pag );


    //
    //  We can enumerate all global drivers using the following flags.
    //
    fdwEnum = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_NOLOCAL;

    hadid   = NULL;


    ENTER_LIST_SHARED;
    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, fdwEnum))
    {
        cDrivers++;
    }
    LEAVE_LIST_SHARED;


    return cDrivers;

} // IDriverCount()


//--------------------------------------------------------------------------;
//
//  VOID IDriverRefreshPriority
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//      HTASK htask:
//
//  Return (MMRESULT):
//
//  History:
//      09/28/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

VOID FNGLOBAL IDriverRefreshPriority
(
    PACMGARB		    pag
)
{
    HACMDRIVERID        hadid;
    PACMDRIVERID        padid;
    UINT                uPriority;
    DWORD               fdwEnum;


    //
    //  We only set priorities for non-local and non-notify drivers.
    //
    fdwEnum   = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_NOLOCAL;

    uPriority = 1;

    hadid = NULL;
    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, fdwEnum))
    {
        padid = (PACMDRIVERID)hadid;

        padid->uPriority = uPriority;

        uPriority++;
    }

} // IDriverRefreshPriority()


//--------------------------------------------------------------------------;
//
//  BOOL IDriverBroadcastNotify
//
//  Description:
//
//
//  Arguments:
//      None.
//
//  Return (BOOL):
//
//  History:
//      10/04/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL IDriverBroadcastNotify
(
    PACMGARB		pag
)
{
    HACMDRIVERID        hadid;
    PACMDRIVERID        padid;

    DPF(1, "IDriverBroadcastNotify: begin notification...");

    ASSERT( !IDriverLockPriority( pag, GetCurrentTask(), ACMPRIOLOCK_ISLOCKED ) );


    hadid = NULL;
    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, (DWORD)-1L))
    {
        padid = (PACMDRIVERID)hadid;

        //
        //  skip drivers that are not loaded--when we load them, they
        //  can refresh themselves...
        //
        if (0 == (ACMDRIVERID_DRIVERF_LOADED & padid->fdwDriver))
            continue;

        //
        //  skip disabled drivers also
        //
        if (0 != (ACMDRIVERID_DRIVERF_DISABLED & padid->fdwDriver))
            continue;

        if (ACM_DRIVERADDF_NOTIFYHWND == (ACM_DRIVERADDF_TYPEMASK & padid->fdwAdd))
        {
            HWND        hwnd;
            UINT        uMsg;

            hwnd = (HWND)padid->lParam;
            uMsg = (UINT)padid->dwInstance;

            if (IsWindow(hwnd))
            {
                DPF(1, "IDriverBroadcastNotify: posting hwnd notification");
                PostMessage(hwnd, uMsg, 0, 0L);
            }
        }
        else
        {
            IDriverMessageId(hadid, ACMDM_DRIVER_NOTIFY, 0L, 0L);
        }
    }

    DPF(1, "IDriverBroadcastNotify: end notification...");

    return (TRUE);
} // IDriverBroadcastNotify()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  PACMDRIVERID IDriverFind
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//      LPARAM lParam:
//
//      DWORD fdwAdd:
//
//  Return (PACMDRIVERID):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

PACMDRIVERID FNLOCAL IDriverFind
(
    PACMGARB		    pag,
    LPARAM                  lParam,
    DWORD                   fdwAdd
)
{
    PACMDRIVERID        padid;
    HTASK               htask;
    DWORD               fdwAddType;

    if (NULL == pag->padidFirst)
    {
        return (NULL);
    }

    //
    //  !!! hack for sndPlaySound() and local drivers. !!!
    //
    htask = NULL;
    if (0 == (ACM_DRIVERADDF_GLOBAL & fdwAdd))
    {
        htask = GetCurrentTask();
    }

    fdwAddType = (ACM_DRIVERADDF_TYPEMASK & fdwAdd);


    //
    //
    //
    //
    for (padid = pag->padidFirst; padid; padid = padid->padidNext)
    {
        if (padid->htask != htask)
            continue;

        switch (fdwAddType)
        {
            case ACM_DRIVERADDF_NOTIFY:
            case ACM_DRIVERADDF_FUNCTION:
            case ACM_DRIVERADDF_NOTIFYHWND:
                if (padid->lParam == lParam)
                {
                    return (padid);
                }
                break;

            case ACM_DRIVERADDF_NAME:
                //
                //  This driver's alias is in lParam.
                //
#if defined(WIN32) && !defined(UNICODE)
                if( 0==Ilstrcmpwcstombs( (LPTSTR)lParam, padid->szAlias ) )
#else
                if( 0==lstrcmp( (LPTSTR)lParam, padid->szAlias ) )
#endif
                {
                    return padid;
                }
                break;

            default:
                return (NULL);
        }
    }

    return (padid);
} // IDriverFind()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverRemove
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      DWORD fdwRemove:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverRemove
(
    HACMDRIVERID            hadid,
    DWORD                   fdwRemove
)
{
    PACMDRIVERID        padid;
    PACMDRIVERID        padidT;
    MMRESULT            mmr;
    PACMGARB		pag;

    padid   = (PACMDRIVERID)hadid;
    ASSERT( NULL != padid );

    pag	    = padid->pag;

    //
    //	Uninstall this driver from system.ini?  Note that this is currently
    //	an internal flag used by the control panel.
    //
    if (ACM_DRIVERREMOVEF_UNINSTALL & fdwRemove)
    {
	TCHAR	szDummy[] = TEXT(" default ");
	TCHAR	szReturn[128];
	TCHAR	szAlias[MAX_DRIVER_NAME_CHARS];
	TCHAR	szSection[MAX_DRIVER_NAME_CHARS];
	HKEY	hkey;

	//
	//
	//
#if defined(WIN32) && !defined(UNICODE)
	Iwcstombs(szAlias, padid->szAlias, SIZEOF(szAlias));
#else
	lstrcpy(szAlias, padid->szAlias);
#endif
	
	//
	//  Dont allow uninstall of pnp drivers
	//
	if (ACM_DRIVERADDF_PNP & padid->fdwAdd) {
	    return(ACMERR_NOTPOSSIBLE);
	}
	
	//
	//  Verify that the alias is really there in system.ini.
	//
#if defined(WIN32) && !defined(UNICODE)
	Iwcstombs(szSection, padid->pszSection, SIZEOF(szSection));
#else
	lstrcpy(szSection, padid->pszSection);
#endif

	GetPrivateProfileString(szSection, szAlias, szDummy, szReturn, SIZEOF(szReturn), gszIniSystem);

	if (!lstrcmp(szDummy, szReturn))
	{
	    //
	    //	This driver is not one installed in system.ini.  Then what the
	    //	heck is it?  Maybe it's the internal PCM codec.
	    //
	    return(MMSYSERR_NODRIVER);
	}

	//
	//  Remove the alias from system.ini
	//
	WritePrivateProfileString(szSection, szAlias, NULL, gszIniSystem);

	//
	//  Remove it from the registry as well
	//
	if ( ERROR_SUCCESS == XRegOpenKey(HKEY_LOCAL_MACHINE,
					 gszKeyDrivers,
					 &hkey) )
	{
	    XRegDeleteKey(hkey, szAlias);
	    XRegCloseKey(hkey);
	}
    }
	
    //
    //
    //
    //
    if (0 != (ACMDRIVERID_DRIVERF_LOADED & padid->fdwDriver))
    {
        mmr = IDriverFree(hadid, 0L);
        if (MMSYSERR_NOERROR != mmr)
        {
            if (pag->hadidDestroy != hadid)
            {
                DebugErr1(DBF_ERROR, "acmDriverRemove(%.04Xh): driver cannot be removed while in use.", hadid);
                return (mmr);
            }

            DebugErr1(DBF_WARNING, "acmDriverRemove(%.04Xh): driver in use--forcing removal.", hadid);
        }
    }


    //
    //
    //
    DebugErr1(DBF_TRACE, "removing ACM driver (%ls).", (LPTSTR)padid->szAlias);


    //
    //  remove the driver from the linked list and free its memory
    //
    if (padid == pag->padidFirst)
    {
        pag->padidFirst = padid->padidNext;
    }
    else
    {
        for (padidT = pag->padidFirst;
             padidT && (padidT->padidNext != padid);
             padidT = padidT->padidNext)
            ;

        if (NULL == padidT)
        {
            DPF(0, "!IDriverRemove(%.04Xh): driver not in list!!!", padid);
            return (MMSYSERR_INVALHANDLE);
        }

        padidT->padidNext = padid->padidNext;
    }

    padid->padidNext = NULL;



    //
    //  free all resources allocated for this thing
    //
    if (NULL != padid->paFormatTagCache)
    {
        LocalFree((HLOCAL)padid->paFormatTagCache);
    }

    if (NULL != padid->paFilterTagCache)
    {
        LocalFree((HLOCAL)padid->paFilterTagCache);
    }

    if (NULL != padid->pstrPnpDriverFilename)
    {
	LocalFree((HLOCAL)padid->pstrPnpDriverFilename);
    }


    //
    //  set handle type to 'dead'
    //
    padid->uHandleType = TYPE_HACMNOTVALID;
    DeleteHandle((HLOCAL)padid);

    //
    //	notify 16-bit acm of driver change
    //
#ifdef WIN32
    if (NULL != pag->lpdw32BitChangeNotify)
    {
	(*pag->lpdw32BitChangeNotify)++;
    }
#endif

    return (MMSYSERR_NOERROR);
} // IDriverRemove()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverAdd
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//      LPHACMDRIVERID phadidNew:
//
//      HINSTANCE hinstModule:
//
//      LPARAM lParam:
//
//      DWORD dwPriority:
//
//      DWORD fdwAdd:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverAdd
(
    PACMGARB		    pag,
    LPHACMDRIVERID          phadidNew,
    HINSTANCE               hinstModule,
    LPARAM                  lParam,
    DWORD                   dwPriority,
    DWORD                   fdwAdd
)
{
    PACMDRIVERID        padid;
    PACMDRIVERID        padidT;
    TCHAR               szAlias[MAX_DRIVER_NAME_CHARS];
    BOOL                fGlobal;
    MMRESULT            mmr;
    DWORD               fdwAddType;
#ifndef WIN32
    DWORD		hadid32;
    DWORD		dnDevNode32;
#endif

    DV_WPOINTER(phadidNew, sizeof(HACMDRIVERID), MMSYSERR_INVALPARAM);

    *phadidNew = NULL;

    DV_DFLAGS(fdwAdd, IDRIVERADD_VALIDF | ACM_DRIVERADDF_32BIT | ACM_DRIVERADDF_PNP, IDriverAdd, MMSYSERR_INVALFLAG);

#ifndef WIN32
    //
    //
    //
    if (fdwAdd & ACM_DRIVERADDF_32BIT)
    {
	ACMDRIVERPROC	fnDriverProc;
	DWORD		fdwAdd32;

	ASSERT(0 == (fdwAdd & ~ACM_DRIVERADDF_32BIT));
	
	//
	//  For 32-bit driver adds, lParam is the 32-bit hadid.  Get some
	//  info about the 32-bit hadid and prepare it to fall through to
	//  rest of this function.
	//
	hadid32 = (DWORD)lParam;
	mmr = IDriverGetInfo32(pag, hadid32, szAlias, &fnDriverProc, &dnDevNode32, &fdwAdd32);
	if (MMSYSERR_NOERROR != mmr)
	{
	    return (mmr);
	}

	//
	//  Use same add flags as 32-bit side (along with ACM_DRIVERADDF_32BIT)
	//
	fdwAdd |= fdwAdd32;
	
	//
	//  Set up lParam to fall through
	//
	fdwAddType = (ACM_DRIVERADDF_TYPEMASK & fdwAdd);
	if (ACM_DRIVERADDF_NAME == fdwAddType)
	{
	    lParam = (LPARAM)szAlias;
	}
	if (ACM_DRIVERADDF_FUNCTION == fdwAddType)
	{
	    lParam = (LPARAM)fnDriverProc;
	}
    }
#endif

    //
    //
    //
    //
    fGlobal    = (0 != (ACM_DRIVERADDF_GLOBAL & fdwAdd));
    fdwAddType = (ACM_DRIVERADDF_TYPEMASK & fdwAdd);


    switch (fdwAddType)
    {
        case ACM_DRIVERADDF_NAME:
            if (IsBadStringPtr((LPTSTR)lParam, SIZEOF(szAlias)))
            {
                return (MMSYSERR_INVALPARAM);
            }

            lstrcpy(szAlias, (LPTSTR)lParam);
            break;

//#pragma message(REMIND("IDriverAdd: no validation for global function pointers in DLL's"))

        case ACM_DRIVERADDF_FUNCTION:
            if (0 != dwPriority)
            {
                DebugErr(DBF_ERROR, "acmDriverAdd: dwPriority must be zero.");
                return (MMSYSERR_INVALPARAM);
            }

	    //
	    //	For 32-bit codecs, szAlias is already setup, don't
	    //	validate the function pointer, so don't fall through.
	    //
#ifndef WIN32
	    if (0 != (fdwAdd & ACM_DRIVERADDF_32BIT))
	    {
		break;
	    }
#endif

	    //	fall through //
	
        case ACM_DRIVERADDF_NOTIFY:
            if (IsBadCodePtr((FARPROC)lParam))
            {
                DebugErr1(DBF_ERROR, "acmDriverAdd: function pointer %.08lXh is invalid.", lParam);
                return (MMSYSERR_INVALPARAM);
            }

            if ((NULL == hinstModule) ||
                !GetModuleFileName(hinstModule, szAlias, SIZEOF(szAlias)))
            {
                return (MMSYSERR_INVALPARAM);
            }

            //
            //  Make sure that we always use the lower-case version;
            //  otherwise the priorities will not necessarily work right
            //  because the case of the module name will be different and
            //  the comparison may fail.
            //
#ifdef WIN32
            CharLowerBuff( szAlias, MAX_DRIVER_NAME_CHARS );
#else
            AnsiLowerBuff( szAlias, MAX_DRIVER_NAME_CHARS );
#endif

            break;

        case ACM_DRIVERADDF_NOTIFYHWND:
            if (fGlobal)
            {
                DebugErr1(DBF_ERROR, "acmDriverAdd: ACM_DRIVERADDF_NOTIFYHWND cannot be used with ACM_DRIVERADDF_GLOBAL.", lParam);
                return (MMSYSERR_INVALPARAM);
            }

            if (!IsWindow((HWND)lParam))
            {
                DebugErr1(DBF_ERROR, "acmDriverAdd: window handle %.08lXh is invalid.", lParam);
                return (MMSYSERR_INVALHANDLE);
            }

            if ((NULL == hinstModule) ||
                !GetModuleFileName(hinstModule, szAlias, SIZEOF(szAlias)))
            {
                DebugErr1(DBF_ERROR, "acmDriverAdd: hinstModule %.08lXh is invalid.", hinstModule);
                return (MMSYSERR_INVALPARAM);
            }

#ifdef WIN32
            CharLowerBuff( szAlias, MAX_DRIVER_NAME_CHARS );
#else
            AnsiLowerBuff( szAlias, MAX_DRIVER_NAME_CHARS );
#endif

            break;

        default:
            DebugErr1(DBF_ERROR, "acmDriverAdd: invalid driver add type (%.08lXh).", fdwAddType);
            return (MMSYSERR_INVALPARAM);
    }


    DebugErr1(DBF_TRACE, "adding ACM driver (%ls).", (LPTSTR)szAlias);

    //
    //  if the driver has already been added (by the same task) then
    //  fail.. we don't support this currently--and may never.
    //
    padid = IDriverFind(pag, lParam, fdwAdd);
    if (NULL != padid)
    {
	if (fdwAdd & ACM_DRIVERADDF_32BIT)
	{
	    DPF(3, "acmDriverAdd: 32-bit driver already added");
	}
	else if (fdwAdd & ACM_DRIVERADDF_PNP)
	{
	    DPF(3, "acmDriverAdd: Pnp driver already added");
	}
	else
	{
	    DPF(3, "acmDriverAdd: attempt to add duplicate reference to driver.");
	    DebugErr(DBF_WARNING, "acmDriverAdd: attempt to add duplicate reference to driver.");
	}
        return (MMSYSERR_ERROR);
    }

    //
    //  new driver - Alloc space for the new driver identifier.
    //
    //  NOTE: we rely on this memory being zero-init'd!!
    //
    padid = (PACMDRIVERID)NewHandle(sizeof(ACMDRIVERID));
    if (NULL == padid)
    {
        DPF(0, "!IDriverAdd: local heap full--cannot create identifier!!!");
        return (MMSYSERR_NOMEM);
    }


    //
    //  save the filename, function ptr or hinst, and ptr back to garb
    //
    padid->pag		= pag;
    padid->uHandleType  = TYPE_HACMDRIVERID;
    padid->uPriority    = 0;
    padid->lParam       = lParam;
    padid->fdwAdd       = fdwAdd;
#ifndef WIN32
    padid->hadid32	= hadid32;
    padid->dnDevNode	= dnDevNode32;
#endif
#if defined(WIN32) && !defined(UNICODE)
    Imbstowcs(padid->szAlias, szAlias, SIZEOFW(padid->szAlias));
#else
    lstrcpy(padid->szAlias, szAlias);
#endif

    //
    //	Set up the section name for this driver
    //
    if (fdwAdd & ACM_DRIVERADDF_PNP)
    {
	//
	//  A pnp driver (may/may not be native bitness)
	//
	padid->pszSection = NULL;
    }
    else
    {
#ifndef WIN32
	if (fdwAdd & ACM_DRIVERADDF_32BIT)
	{
	    //
	    //  A thunked non-pnp driver (system.ini driver)
	    //
	    padid->pszSection = gszSecDrivers32;
	}
	else
#endif
	{
	    //
	    //	A native bitness non-pnp driver
	    //
#ifdef WIN32
	    padid->pszSection = gszSecDriversW;
#else
	    padid->pszSection = gszSecDrivers;
#endif
	}
    }

	
#ifdef WIN32
    if (fdwAdd & ACM_DRIVERADDF_PNP)
    {
	//
	//  Need to get the pnp devnode id the the driver filename from
	//  the registry.
	//
	
	LONG	lr;
	TCHAR	achDriverKey[SIZEOF(gszKeyDrivers) + MAX_DRIVER_NAME_CHARS];
	DWORD	cbData;
	DWORD	dwType;
	DWORD	cbDriverFilename;
	DWORD	cchDriverFilename;
	DWORD	cbPnpDriverFilename;
	PTSTR	pstrDriverFilename;
	HKEY	hkeyDriver;

	pstrDriverFilename = NULL;
	padid->pstrPnpDriverFilename = NULL;
	
	wsprintf(achDriverKey, gszFormatDriverKey, gszKeyDrivers, szAlias);
	lr = XRegOpenKeyEx(HKEY_LOCAL_MACHINE,
			  achDriverKey,
			  0L,
			  KEY_QUERY_VALUE,
			  &hkeyDriver);

	if (ERROR_SUCCESS == lr)
	{
	    //
	    //  Get pnp devnode id from the registry.
	    //

	    cbData = sizeof(padid->dnDevNode);
	    lr = XRegQueryValueEx(hkeyDriver,
				 (LPTSTR)gszDevNode,
				 NULL,
				 &dwType,
				 (LPBYTE)&padid->dnDevNode,
				 &cbData);

	    if (ERROR_SUCCESS == lr)
	    {
		if ( (dwType != REG_DWORD && dwType != REG_BINARY) ||
		     (sizeof(padid->dnDevNode) != cbData) )
		{
		    lr = ERROR_CANTOPEN;	// whatever
		}
	    }		


	    if (ERROR_SUCCESS == lr)
	    {
		//
		//  Get the driver filename of the pnp driver
		//
	
		//
		//  Determine size of buffer needed to store the filename
		//
		lr = XRegQueryValueEx(hkeyDriver,
				     (LPTSTR)gszDriver,
				     NULL,
				     NULL,
				     NULL,
				     &cbDriverFilename);

		if (ERROR_SUCCESS == lr)
		{
		    //
		    //
		    //
		    pstrDriverFilename = (PTSTR)LocalAlloc(LPTR, cbDriverFilename);
		
		    if (NULL == pstrDriverFilename) {
			lr = ERROR_OUTOFMEMORY;
		    } else {
			lr = XRegQueryValueEx(hkeyDriver,
					     (LPTSTR)gszDriver,
					     NULL,
					     &dwType,
					     (LPBYTE)pstrDriverFilename,
					     &cbDriverFilename);
			if (ERROR_SUCCESS == lr)
			{
			    if (REG_SZ != dwType) {
				lr = ERROR_CANTOPEN;
			    }
			}
		    }
		}
	    }

	    XRegCloseKey(hkeyDriver);
	}

	if (ERROR_SUCCESS == lr)
	{
	    cchDriverFilename = cbDriverFilename / sizeof(TCHAR);
#if defined(WIN32) && !defined(UNICODE)
	    cbPnpDriverFilename = cchDriverFilename * sizeof(WCHAR);
	    padid->pstrPnpDriverFilename = (PWSTR)LocalAlloc( LPTR, cbPnpDriverFilename);
	    if (NULL == padid->pstrPnpDriverFilename) {
		lr = ERROR_OUTOFMEMORY;
	    } else {
		Imbstowcs(padid->pstrPnpDriverFilename, pstrDriverFilename, cbPnpDriverFilename);
	    }
#else
	    cbPnpDriverFilename = cchDriverFilename * sizeof(TCHAR);
	    padid->pstrPnpDriverFilename = (PTSTR)LocalAlloc( LPTR, cbPnpDriverFilename);
	    if (NULL == padid->pstrPnpDriverFilename) {
		lr = ERROR_OUTOFMEMORY;
	    } else {
		lstrcpy(padid->pstrPnpDriverFilename, pstrDriverFilename);
	    }
#endif
	    LocalFree((HLOCAL)pstrDriverFilename);
	    DPF(0, "IDriverAdd: added pnp driver filename %s for devnode %08lXh", pstrDriverFilename, padid->dnDevNode);
	}

	switch (lr)
	{
	    //
	    //	Try to return a sensible MMSYSERR_* given ERROR_*
	    //
	    case ERROR_SUCCESS:
		mmr = MMSYSERR_NOERROR;
		break;
	    case ERROR_OUTOFMEMORY:
		mmr = MMSYSERR_NOMEM;
		break;
	    // case ERROR_FILE_NOT_FOUND:	
	    // case ERROR_BADDB:
	    // case ERROR_MORE_DATA:
	    // case ERROR_BADKEY:
	    // case ERROR_CANTOPEN:
	    // case ERROR_CANTREAD:
	    // case ERROR_CANT_WRITE:
	    // case ERROR_REGISTRY_CORRUPT:
	    // case ERROR_REGISTRY_IO_FAILED:
	    // case ERROR_KEY_DELETED:
	    // case ERROR_INVALID_PARAMETER:
	    // case ERROR_LOCK_FAILED:
	    // case ERROR_NO_MORE_ITEMS:
	    default:
		mmr = MMSYSERR_ERROR;
		break;
	}

	if (MMSYSERR_NOERROR != mmr)
	{
	    return (mmr);
	}
    }
#endif

	

    switch (fdwAddType)
    {
        case ACM_DRIVERADDF_NOTIFYHWND:
            padid->fdwDriver   |= ACMDRIVERID_DRIVERF_NOTIFY;
            padid->fnDriverProc = (ACMDRIVERPROC)(DWORD_PTR)-1L;
            padid->dwInstance   = dwPriority;
            break;

        case ACM_DRIVERADDF_NOTIFY:
            padid->fdwDriver   |= ACMDRIVERID_DRIVERF_NOTIFY;
            padid->dwInstance   = dwPriority;

            // -- fall through -- //

        case ACM_DRIVERADDF_FUNCTION:
            padid->fnDriverProc = (ACMDRIVERPROC)lParam;
            break;
    }



    //
    //  if the driver is 'GLOBAL' then set fGlobal to TRUE
    //
    //  if this is not a global driver, then we need to associate the
    //  current task with this driver so it will only be enumerated
    //  and used in the context of the task that is adding it.
    //
    //  THIS PRESENTS A PROBLEM for applications that want to add a local
    //  driver and expect it to work with sndPlaySound because all
    //  processing for the sndPlaySound is on a separate task--meaning
    //  that the local driver will not be used when the application
    //  calls sndPlaySound... currently, we are just going to require
    //  that drivers be global if they are to work with sndPlaySound.
    //
    if (fGlobal)
    {
        padid->htask = NULL;
    }
    else
    {
        padid->fdwDriver |= ACMDRIVERID_DRIVERF_LOCAL;
        padid->htask      = GetCurrentTask();
    }


    //
    //  add the driver to the linked list of drivers
    //
    //  PRIORITY RULES:
    //
    //  o   GLOBAL drivers always get added to the _END_ of the list
    //
    //  o   LOCAL drivers always get added to the _HEAD_ of the list so
    //      the latest installed local drivers are queried first
    //
    if (!fGlobal)
    {
        padid->padidNext = pag->padidFirst;
	pag->padidFirst = padid;
    }
    else
    {
        padidT = pag->padidFirst;
        for ( ; padidT && padidT->padidNext; padidT = padidT->padidNext)
            ;

        if (NULL != padidT)
            padidT->padidNext = padid;
        else
            pag->padidFirst = padid;
    }


    //
    //	We need to get some data about this driver into the ACMDRIVERID
    //	for this driver.  First see if we can get this data from the
    //	registry.  If that doesn't work, then we'll load the driver
    //	and that will load the necessary data into ACMDRIVERID.
    //
    mmr = IDriverReadRegistryData(padid);
    if (MMSYSERR_NOERROR != mmr)
    {
	//
	//  Registry information doesn't exist or appears out of date.  Load
	//  the driver now so we can get some information about the driver
	//  into the ACMDRIVERID for this driver.
	//
	DPF(3, "IDriverAdd: Couldn't load registry data for driver.  Attempting to load.");
	mmr = IDriverLoad((HACMDRIVERID)padid, 0L);
    }

    if (MMSYSERR_NOERROR != mmr)
    {
        DebugErr(DBF_TRACE, "IDriverAdd(): driver had fatal error during load--unloading it now.");
	IDriverRemove((HACMDRIVERID)padid, 0L);
	return (mmr);
    }


    //
    //  Success!  Store the new handle, notify 16-bit side of driver change,
    //	and return.
    //
    *phadidNew = (HACMDRIVERID)padid;
#ifdef WIN32
    if (NULL != pag->lpdw32BitChangeNotify)
    {
	(*pag->lpdw32BitChangeNotify)++;
    }
#endif

    return (MMSYSERR_NOERROR);
} // IDriverAdd()



//--------------------------------------------------------------------------;
//
//  BOOL IDriverLockPriority
//
//  Description:
//      This routine manages the htaskPriority lock (pag->htaskPriority).
//
//      ACMPRIOLOCK_GETLOCK:     If the lock is free, set it to this task.
//      ACMPRIOLOCK_RELEASELOCK: If the lock is yours, release it.
//      ACMPRIOLOCK_ISMYLOCK:    Return TRUE if this task has the lock.
//      ACMPRIOLOCK_ISLOCKED:    Return TRUE if some task has the lock.
//      ACMPRIOLOCK_LOCKISOK:    Return TRUE if it's unlocked, or if it's
//                                  my lock - ie. if it's not locked for me.
//
//  Arguments:
//      PACMGARB pag:
//      HTASK htask:    The current task.
//      UINT flags:
//
//  Return (BOOL):  Success or failure.  Failure on RELEASELOCK means that
//                  the lock didn't really belong to this task.
//
//--------------------------------------------------------------------------;

BOOL IDriverLockPriority
(
    PACMGARB                pag,
    HTASK                   htask,
    UINT                    uRequest
)
{
    ASSERT( uRequest >= ACMPRIOLOCK_FIRST );
    ASSERT( uRequest <= ACMPRIOLOCK_LAST );
    ASSERT( htask == GetCurrentTask() );

    switch( uRequest )
    {
        case ACMPRIOLOCK_GETLOCK:
            if( NULL != pag->htaskPriority )
                return FALSE;
            pag->htaskPriority = htask;
            return TRUE;

        case ACMPRIOLOCK_RELEASELOCK:
            if( htask != pag->htaskPriority )
                return FALSE;
            pag->htaskPriority = NULL;
            return TRUE;

        case ACMPRIOLOCK_ISMYLOCK:
            return ( htask == pag->htaskPriority );

        case ACMPRIOLOCK_ISLOCKED:
            return ( NULL != pag->htaskPriority );

        case ACMPRIOLOCK_LOCKISOK:
            return ( htask == pag->htaskPriority ||
                     NULL == pag->htaskPriority );
    }

    DPF( 1, "!IDriverLockPriority: invalid uRequest (%u) received.",uRequest);
    return FALSE;
}


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverPriority
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      DWORD dwPriority:
//
//      DWORD fdwPriority:
//
//  Return (MMRESULT):
//
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverPriority
(
    PACMGARB                pag,
    PACMDRIVERID            padid,
    DWORD                   dwPriority,
    DWORD                   fdwPriority
)
{
    PACMDRIVERID        padidT;
    PACMDRIVERID        padidPrev;
    DWORD               fdwAble;
    UINT                uCurPriority;


    ASSERT( NULL != padid );


    //
    //  Enable or disable the driver.
    //
    fdwAble = ( ACM_DRIVERPRIORITYF_ABLEMASK & fdwPriority );

    switch (fdwAble)
    {
        case ACM_DRIVERPRIORITYF_ENABLE:
            padid->fdwDriver &= ~ACMDRIVERID_DRIVERF_DISABLED;
            break;

        case ACM_DRIVERPRIORITYF_DISABLE:
            padid->fdwDriver |= ACMDRIVERID_DRIVERF_DISABLED;
            break;
    }


    //
    //  Change the priority.  If dwPriority==0, then we only want to
    //  enable/disable the driver - leave the priority alone.
    //
    if( 0L != dwPriority  &&  dwPriority != padid->uPriority )
    {
        //
        //  first remove the driver from the linked list
        //
        if (padid == pag->padidFirst)
        {
            pag->padidFirst = padid->padidNext;
        }
        else
        {
            padidT = pag->padidFirst;

            for ( ; NULL != padidT; padidT = padidT->padidNext)
            {
                if (padidT->padidNext == padid)
                    break;
            }

            if (NULL == padidT)
            {
                DebugErr1(DBF_ERROR, "acmDriverPriority(): driver (%.04Xh) not in list. very strange.", (HACMDRIVERID)padid);
                return (MMSYSERR_INVALHANDLE);
            }

            padidT->padidNext = padid->padidNext;
        }

        padid->padidNext = NULL;


        //
        //  now add the driver at the correct position--this will be in
        //  the position of the current global driver
        //
        //  robinsp: i'm really sorry about all this linked list
        //  stuff--if i had one free day, i would fix all of this before you
        //  ever looked at it... but i am in 'just get it done' mode!
        //
        uCurPriority = 1;

        padidPrev = NULL;
        for (padidT = pag->padidFirst; NULL != padidT; )
        {
            //
            //  skip local and notify handles
            //
            if (0 == ((ACMDRIVERID_DRIVERF_LOCAL | ACMDRIVERID_DRIVERF_NOTIFY) & padidT->fdwDriver))
            {
                if (uCurPriority == dwPriority)
                {
                    break;
                }

                uCurPriority++;
            }

            padidPrev = padidT;
            padidT = padidT->padidNext;
        }

        if (NULL == padidPrev)
        {
            padid->padidNext = pag->padidFirst;
            pag->padidFirst = padid;
        }
        else
        {
            padid->padidNext = padidPrev->padidNext;
            padidPrev->padidNext = padid;
        }
    }

    //
    //	We need to keep the enable/disable state consistent on the 32-bit side.
    //	Otherwise, if the 32-bit side booted with a driver disabled, we may
    //	not be able to IDriverOpen32 it.  So, we'll call the 32-bit side's
    //	IDriverPriority as well.  This may adjust priorities on the 32-bit side
    //	in addition to enable/disable, but that doesn't matter.
    //
#ifndef WIN32
    if (padid->fdwAdd & ACM_DRIVERADDF_32BIT) {
	if (MMSYSERR_NOERROR != IDriverPriority32(pag, padid->hadid32, dwPriority, fdwPriority)) {
	    DPF(0, "!IDriverPriority: IDriverPriority32 failed!");
	}
    }
#endif // !WIN32


    return (MMSYSERR_NOERROR);
} // IDriverPriority()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverClose
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVER had:
//
//      DWORD fdwClose:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverClose
(
    HACMDRIVER              had,
    DWORD                   fdwClose
)
{
    BOOL                f;
    PACMDRIVERID        padid;
    PACMDRIVER          pad;
    PACMGARB		pag;

    DV_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
    DV_DFLAGS(fdwClose, IDRIVERCLOSE_VALIDF, IDriverClose, MMSYSERR_INVALFLAG);


    //
    //
    //
    pad	    = (PACMDRIVER)had;
    padid   = (PACMDRIVERID)pad->hadid;
    pag	    = padid->pag;


    //
    //  Kill all the streams
    //
    if (NULL != pad->pasFirst)
    {
        if (pag->hadDestroy != had)
        {
            DebugErr1(DBF_ERROR, "acmDriverClose(%.04Xh): driver has open streams--cannot be closed!", had);
            return (ACMERR_BUSY);
        }

        DebugErr1(DBF_WARNING, "acmDriverClose(%.04Xh): driver has open streams--forcing close!", had);
    }

#ifdef WIN32
    DPF(1, "closing ACM driver instance (%ls).", (LPWSTR)padid->szAlias);
#else
    DPF(1, "closing ACM driver instance (%s).",  (LPTSTR)padid->szAlias);
#endif

    //
    //  if the driver is open for this instance, then close it down...
    //
    //
#ifndef WIN32
    if (padid->fdwAdd & ACM_DRIVERADDF_32BIT) {
        f = 0L == IDriverClose32(pad->had32, fdwClose);
        if (!f)
        {
            DebugErr1(DBF_WARNING, "acmDriverClose(%.04Xh): driver failed close message!?!", had);

            if (pag->hadDestroy != had)
            {
                return (MMSYSERR_ERROR);
            }
        }
    }
    else
#endif // !WIN32
    {
        if ((NULL != pad->hdrvr) || (0L != pad->dwInstance))
        {
            //
            //  clear the rest of the table entry
            //
            f = FALSE;
            if (NULL != pad->fnDriverProc)
            {
                f = (0L != IDriverMessage(had, DRV_CLOSE, 0L, 0L));
            }
            else if (NULL != pad->hdrvr)
            {
                f = (0L != (
                CloseDriver(pad->hdrvr, 0L, 0L)));
            }

            if (!f)
            {
                DebugErr1(DBF_WARNING, "acmDriverClose(%.04Xh): driver failed close message!?!", had);

                if (pag->hadDestroy != had)
                {
                    return (MMSYSERR_ERROR);
                }
            }
        }
    }

    //
    //  remove the driver instance from the linked list and free its memory
    //
    if (pad == padid->padFirst)
    {
        padid->padFirst = pad->padNext;
    }
    else
    {
        PACMDRIVER  padCur;

        //
        //
        //
        for (padCur = padid->padFirst;
             (NULL != padCur) && (pad != padCur->padNext);
             padCur = padCur->padNext)
            ;

        if (NULL == padCur)
        {
            DPF(0, "!IDriverClose(%.04Xh): driver not in list!!!", pad);
            return (MMSYSERR_INVALHANDLE);
        }

        padCur->padNext = pad->padNext;
    }

    pad->uHandleType = TYPE_HACMNOTVALID;
    DeleteHandle((HLOCAL)pad);

    return (MMSYSERR_NOERROR);
} // IDriverClose()


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverOpen
//
//  Description:
//
//
//  Arguments:
//      LPHACMDRIVER phadNew:
//
//      HACMDRIVERID hadid:
//
//      DWORD fdwOpen:
//
//  Return (MMRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverOpen
(
    LPHACMDRIVER            phadNew,
    HACMDRIVERID            hadid,
    DWORD                   fdwOpen
)
{
    ACMDRVOPENDESC      aod;
    PACMDRIVERID        padid;
    PACMDRIVER          pad;
    MMRESULT            mmr;
    PACMGARB		pag;

    DV_WPOINTER(phadNew, sizeof(HACMDRIVER), MMSYSERR_INVALPARAM);

    *phadNew = NULL;

    DV_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);
    DV_DFLAGS(fdwOpen, IDRIVEROPEN_VALIDF, IDriverOpen, MMSYSERR_INVALFLAG);


    padid   = (PACMDRIVERID)hadid;
    pag	    = padid->pag;


    //
    //  if the driver has never been loaded, load it and keep it loaded.
    //
    if (0L == (ACMDRIVERID_DRIVERF_LOADED & padid->fdwDriver))
    {
        //
        //
        //
        mmr = IDriverLoad(hadid, 0L);
        if (MMSYSERR_NOERROR != mmr)
        {
            DebugErr1(DBF_TRACE, "acmDriverOpen(%.04Xh): driver had fatal error during load", hadid);
            return (mmr);
        }
    }


    //
    //
    //
    if (0 != (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver))
    {
        DebugErr1(DBF_ERROR, "acmDriverOpen(%.04Xh): notification handles cannot be opened.", hadid);
        return (MMSYSERR_INVALHANDLE);
    }


    //
    //  do not allow opening of a disabled driver
    //
    if (0 != (ACMDRIVERID_DRIVERF_DISABLED & padid->fdwDriver))
    {
        DebugErr1(DBF_ERROR, "acmDriverOpen(%.04Xh): driver is disabled.", hadid);
        return (MMSYSERR_NOTENABLED);
    }


    //
    //
    //
#ifdef WIN32
    DPF(1, "opening ACM driver instance (%ls).", (LPWSTR)padid->szAlias);
#else
    DPF(1, "opening ACM driver instance (%s).",  (LPTSTR)padid->szAlias);
#endif

    //
    //  alloc space for the new driver instance.
    //
    pad = (PACMDRIVER)NewHandle(sizeof(ACMDRIVER));
    if (NULL == pad)
    {
        DPF(0, "!IDriverOpen: local heap full--cannot create instance!");
        return (MMSYSERR_NOMEM);
    }

    pad->uHandleType = TYPE_HACMDRIVER;
    pad->pasFirst    = NULL;
    pad->hadid       = hadid;
    pad->htask       = GetCurrentTask();
    pad->fdwOpen     = fdwOpen;


    //
    //  add the new driver instance to the head of our list of open driver
    //  instances for this driver identifier.
    //
    pad->padNext    = padid->padFirst;
    padid->padFirst = pad;


#ifndef WIN32
    if (padid->fdwAdd & ACM_DRIVERADDF_32BIT) {

        //
        //  The 32-bit hadid is the hdrvr of our hadid.
        //  The 32-bit had will be returned in our had's hdrvr
        //
        mmr = IDriverOpen32(&pad->had32, padid->hadid32, fdwOpen);
        if (mmr != MMSYSERR_NOERROR) {
            IDriverClose((HACMDRIVER)pad, 0L);
            return mmr;
        }
    } else
#endif // !WIN32
    {
        //
        //
        //
        //
        //
        aod.cbStruct       = sizeof(aod);
        aod.fccType        = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
        aod.fccComp        = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;
        aod.dwVersion      = VERSION_MSACM;
        aod.dwFlags        = fdwOpen;
        aod.dwError        = MMSYSERR_NOERROR;
        aod.pszSectionName = padid->pszSection;
        aod.pszAliasName   = padid->szAlias;
	aod.dnDevNode	   = padid->dnDevNode;

        //
        //  send the DRV_OPEN message that contains the ACMDRVOPENDESC info
        //
        //
        if (NULL != padid->hdrvr)
        {
            HDRVR       hdrvr;

	    if (padid->fdwAdd & ACM_DRIVERADDF_PNP)
	    {
		//
		//  Note thunked 32-bit [pnp] drivers were handled above.
		//
		hdrvr = OpenDriver(padid->pstrPnpDriverFilename, NULL, (LPARAM)(LPVOID)&aod);
	    }
	    else
	    {
		hdrvr = OpenDriver(padid->szAlias, padid->pszSection, (LPARAM)(LPVOID)&aod);
	    }
	
            if (NULL == hdrvr)
            {
                DebugErr1(DBF_WARNING, "ACM driver instance (%ls) failed open.", (LPTSTR)padid->szAlias);
                IDriverClose((HACMDRIVER)pad, 0L);

                if (MMSYSERR_NOERROR == aod.dwError)
                    return (MMSYSERR_ERROR);

                return ((MMRESULT)aod.dwError);
            }

            pad->hdrvr = hdrvr;
        }
        else
        {
            LRESULT lr;

            lr = IDriverMessageId(hadid, DRV_OPEN, 0L, (LPARAM)(LPVOID)&aod);
            if (0 == lr)
            {
                IDriverClose((HACMDRIVER)pad, 0L);

                if (MMSYSERR_NOERROR == aod.dwError)
                    return (MMSYSERR_ERROR);

                return ((MMRESULT)aod.dwError);
            }

            pad->dwInstance   = lr;
            pad->fnDriverProc = padid->fnDriverProc;
        }
    }

    *phadNew = (HACMDRIVER)pad;

    return (MMSYSERR_NOERROR);
} // IDriverOpen()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT IDriverAppExit
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//      HTASK htask:
//
//      BOOL fNormalExit:
//
//  Return (LRESULT):
//
//  History:
//      07/18/93    cjp     [curtisp]
//	07/19/94    fdy	    [frankye]
//	    !!!HACK- When the ACM is shutting down, we are within our
//	    DllEntryPoint and we can't use our thunks.  So, for unreleased
//	    streams and driver handles, we can't do much about the 32-bit
//	    codecs from the 16-bit side.
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL IDriverAppExit
(
    PACMGARB		    pag,
    HTASK                   htask,
    LPARAM                  lParam
)
{
    HACMDRIVERID        hadid;
    BOOL                fNormalExit;
    DWORD               fdwEnum;
    UINT                fuDebugFlags;
#if !defined(WIN32) && defined(DEBUG)
    TCHAR               szTask[128];
#endif


    if (NULL == pag)
    {
	return (0L);
    }

    fNormalExit = (DRVEA_NORMALEXIT == lParam);

#ifdef DEBUG
#ifndef WIN32
    szTask[0] = '\0';
    if (0 != GetModuleFileName((HINSTANCE)GetTaskDS(), szTask, SIZEOF(szTask)))
    {
        DPF(2, "IDriverAppExit(htask=%.04Xh [%s], fNormalExit=%u) BEGIN", htask, (LPSTR)szTask, fNormalExit);
    }
    else
#endif
    {
        DPF(2, "IDriverAppExit(htask=%.04Xh, fNormalExit=%u) BEGIN", htask, fNormalExit);
    }
#endif

#ifdef DEBUG
    if (NULL != pag->hadidDestroy)
    {
        DPF(0, "!Hey! IDriverAppExit has been re-entered!");
    }
#endif

    //
    //  either log a error or a warning depending on wether it was
    //  a normal exit or not.
    //
    if (fNormalExit)
    {
        fuDebugFlags = DBF_ERROR;
    }
    else
    {
        fuDebugFlags = DBF_WARNING; // DBF_TRACE?
        DPF(0, "*** abnormal app termination ***");
    }

    //
    //
    //
    //
    if (NULL == htask)
        fdwEnum = (DWORD)-1L;
    else
        fdwEnum = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_NOTIFY;

IDriver_App_Exit_Again:

    hadid = NULL;
    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, fdwEnum))
    {
        PACMDRIVERID        padid;
        PACMDRIVER          pad;
        PACMSTREAM          pas;

	pag->hadidDestroy = hadid;

        padid = (PACMDRIVERID)hadid;

        for (pad = padid->padFirst; NULL != pad; pad = pad->padNext)
        {
            //
            //  if htask is NULL, then acm is unloading--so kill all!
            //
            if (NULL != htask)
            {
                if (htask != pad->htask)
                    continue;
            }

	    pag->hadDestroy = (HACMDRIVER)pad;

            for (pas = pad->pasFirst; NULL != pas; pas = pas->pasNext)
            {
                DebugErr1(fuDebugFlags, "ACM stream handle (%.04Xh) was not released.", pas);

		if (padid->fdwAdd & ACM_DRIVERADDF_32BIT) {
		    continue;
		} else {
		    acmStreamReset((HACMSTREAM)pas, 0L);
		    acmStreamClose((HACMSTREAM)pas, 0L);

		    goto IDriver_App_Exit_Again;
		}
            }

            DebugErr1(fuDebugFlags, "ACM driver handle (%.04Xh) was not released.", pad);

	    if (padid->fdwAdd & ACM_DRIVERADDF_32BIT) {
		continue;
	    } else {
		acmDriverClose((HACMDRIVER)pad, 0L);
	    }

            goto IDriver_App_Exit_Again;
        }

        if ((NULL != htask) && (htask == padid->htask))
        {
            DebugErr1(fuDebugFlags, "ACM driver (%.04Xh) was not removed.", hadid);

            acmDriverRemove(hadid, 0L);

            goto IDriver_App_Exit_Again;
        }
    }


    //
    //
    //
    pag->hadidDestroy = NULL;
    pag->hadDestroy   = NULL;


    if( NULL != htask )
    {
        if( IDriverLockPriority( pag, htask, ACMPRIOLOCK_ISMYLOCK ) )
        {
            IDriverLockPriority( pag, htask, ACMPRIOLOCK_RELEASELOCK );
            DebugErr(fuDebugFlags, "acmApplicationExit: exiting application owns deferred notification lock!");

            //
            //  do NOT do a broadcast of changes during app exit! might
            //  be very bad!
            //
            // !!! IDriverBroadcastNotify();
        }
    }



    //
    //  shrink our heap, down to minimal size.
    //
#ifndef WIN32
{
    UINT                cFree;
    UINT                cHeap;

    if ((cFree = LocalCountFree()) > 8192)
    {
        cHeap = LocalHeapSize() - (cFree - 512);
        LocalShrink(NULL, cHeap);

        DPF(1, "shrinking the heap (%u)", cHeap);
    }
}
#endif

#ifndef WIN32
    DPF(2, "IDriverAppExit(htask=%.04Xh [%s], fNormalExit=%u) END", htask, (LPSTR)szTask, fNormalExit);
#else
    DPF(2, "IDriverAppExit(htask=%.04Xh, fNormalExit=%u) END", htask, fNormalExit);
#endif


    //
    //  the return value is ignored--but return zero..
    //
    return (0L);
} // IDriverAppExit()


//--------------------------------------------------------------------------;
//
//  LRESULT acmApplicationExit
//
//  Description:
//
//
//  Arguments:
//      HTASK htask:
//
//      LPARAM lParam:
//
//  Return (LRESULT):
//
//  History:
//      09/26/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;
#ifndef WIN32
LRESULT ACMAPI acmApplicationExit
(
    HTASK                   htask,
    LPARAM                  lParam
)
{
    LRESULT             lr;

    lr = IDriverAppExit(pagFind(), htask, lParam);

    return (lr);
} // acmApplicationExit()
#endif


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT DriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      that the driver is opened, through the DrvOpen API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//  History:
//      11/16/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;
#ifndef WIN32
EXTERN_C LRESULT FNEXPORT DriverProc
(
    DWORD_PTR               dwId,
    HDRVR                   hdrvr,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT             lr;

    switch (uMsg)
    {
        case DRV_LOAD:
        case DRV_FREE:
        case DRV_OPEN:
        case DRV_CLOSE:
        case DRV_ENABLE:
        case DRV_DISABLE:
            return (1L);

        case DRV_EXITAPPLICATION:
            lr = IDriverAppExit(pagFind(), GetCurrentTask(), lParam1);
            return (lr);

        case DRV_INSTALL:
        case DRV_REMOVE:
            return (DRVCNF_RESTART);
    }

    return (DefDriverProc(dwId, hdrvr, uMsg, lParam1, lParam2));
} // DriverProc()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\acmi.h ===
//==========================================================================;
//
//  acmi.h
//
//  Copyright (c) 1991-1999 Microsoft Corporation
//
//  Description:
//      Internal Audio Compression Manager header file. Defines internal
//      data structures and things not needed outside of the ACM itself.
//
//  History:
//
//==========================================================================;


#ifndef _INC_ACMI
#define _INC_ACMI       /* #defined if acmi.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */


#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
//
//
#ifdef DEBUG
    #define RDEBUG
#endif

#ifndef MMREVISION
#include <verinfo.h>
#endif

#ifdef WIN32
#include "locks.h"
#endif

//
//  If we're in Daytona, manually initialize friendly name stuff into
//  HKCU.
//
#if defined(WIN32) && !defined(WIN4)
#define USEINITFRIENDLYNAMES
#endif

//
//
//
//
#if defined(NTWOW)
//  Version number needs to be updated every product cycle!!
#define VERSION_MSACM_MAJOR     4
#define VERSION_MSACM_MINOR     00
#define VERSION_MSACM_MINOR_REQ 00
#else
#define VERSION_MSACM_MAJOR     MMVERSION
#define VERSION_MSACM_MINOR     MMREVISION
#endif

//
//  make build number returned only in _[retail] debug_ version
//
#ifdef RDEBUG
#define VERSION_MSACM_BUILD     MMRELEASE
#else
#define VERSION_MSACM_BUILD     0
#endif

#define VERSION_MSACM           MAKE_ACM_VERSION(VERSION_MSACM_MAJOR,   \
						 VERSION_MSACM_MINOR,   \
						 VERSION_MSACM_BUILD)

// The version of ACM the builtin PCM codec requires
#define VERSION_MSACM_REQ       MAKE_ACM_VERSION(3,50,0)


//
//
//
#ifndef SIZEOF_WAVEFORMATEX
#define SIZEOF_WAVEFORMATEX(pwfx)   ((WAVE_FORMAT_PCM==(pwfx)->wFormatTag)?sizeof(PCMWAVEFORMAT):(sizeof(WAVEFORMATEX)+(pwfx)->cbSize))
#endif

#ifdef WIN32
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  When compiling msacm for WIN32, define all functions as unicode.
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#undef acmDriverAdd

#undef acmDriverDetails

#undef acmFormatTagDetails

#undef ACMFORMATTAGENUMCB
#undef acmFormatTagEnum

#undef acmFormatDetails

#undef ACMFORMATENUMCB
#undef acmFormatEnum

#undef ACMFORMATCHOOSEHOOKPROC

#undef acmFormatChoose

#undef acmFilterTagDetails

#undef ACMFILTERTAGENUMCB
#undef acmFilterTagEnum

#undef acmFilterDetails

#undef ACMFILTERENUMCB
#undef acmFilterEnum

#undef ACMFILTERCHOOSEHOOKPROC

#undef acmFilterChoose

#define acmDriverAdd                acmDriverAddW

#define acmDriverDetails            acmDriverDetailsW

#define acmFormatTagDetails         acmFormatTagDetailsW

#define ACMFORMATTAGENUMCB          ACMFORMATTAGENUMCBW
#define acmFormatTagEnum            acmFormatTagEnumW

#define acmFormatDetails            acmFormatDetailsW

#define ACMFORMATENUMCB             ACMFORMATENUMCBW
#define acmFormatEnum               acmFormatEnumW

#define ACMFORMATCHOOSEHOOKPROC     ACMFORMATCHOOSEHOOKPROCW

#define acmFormatChoose             acmFormatChooseW

#define acmFilterTagDetails         acmFilterTagDetailsW

#define ACMFILTERTAGENUMCB          ACMFILTERTAGENUMCBW
#define acmFilterTagEnum            acmFilterTagEnumW

#define acmFilterDetails            acmFilterDetailsW

#define ACMFILTERENUMCB             ACMFILTERENUMCBW
#define acmFilterEnum               acmFilterEnumW

#define ACMFILTERCHOOSEHOOKPROC     ACMFILTERCHOOSEHOOKPROCW

#define acmFilterChoose             acmFilterChooseW

#endif

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16/32 portability stuff...
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef RC_INVOKED
#ifdef WIN32
    #ifndef FNLOCAL
	#define FNLOCAL     _stdcall
	#define FNCLOCAL    _stdcall
	#define FNGLOBAL    _stdcall
	#define FNCGLOBAL   _stdcall
	#define FNWCALLBACK CALLBACK
	#define FNEXPORT    CALLBACK
    #endif

    #ifndef try
    #define try         __try
    #define leave       __leave
    #define except      __except
    #define finally     __finally
    #endif


    //
    //  there is no reason to have based stuff in win 32
    //
    #define BCODE                   CONST

    #define HUGE
    #define HTASK                   HANDLE
    #define SELECTOROF(a)           (a)

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)    \
	((DWORD)SendMessage((hwndCtl), EM_GETSEL, (WPARAM)pnS, (LPARAM)pnE))

    //
    //  for compiling Unicode
    //
    #define SIZEOFW(x) (sizeof(x)/sizeof(WCHAR))
    #define SIZEOFA(x) (sizeof(x))
    #ifdef UNICODE
	#define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
	#define SIZEOF(x)   sizeof(x)
    #endif

    #define GetCurrentTask()  (HTASK)ULongToPtr(GetCurrentThreadId())

    //
    //  we need to try to quit using this if possible...
    //
    void WINAPI DirectedYield(HTASK);
#endif // #ifdef WIN32


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
	#define FNLOCAL     NEAR PASCAL
	#define FNCLOCAL    NEAR _cdecl
	#define FNGLOBAL    FAR PASCAL
	#define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
	#define FNWCALLBACK FAR PASCAL _loadds
	#define FNEXPORT    FAR PASCAL _export
    #else
	#define FNWCALLBACK FAR PASCAL
	#define FNEXPORT    FAR PASCAL _export
    #endif
    #endif


    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))

    #define HUGE            _huge


    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif


    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
	#define _TCHAR_DEFINED
	typedef char            TCHAR, *PTCHAR;
	typedef unsigned char   TBYTE, *PTUCHAR;

	typedef PSTR            PTSTR, PTCH;
	typedef LPSTR           LPTSTR, LPTCH;
	typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)

    //
    //
    //
    #define CharNext        AnsiNext
    #define CharPrev        AnsiPrev

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)                        \
    {                                                               \
	DWORD   dw;                                                 \
	dw = (DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L);       \
	*pnE = (int)HIWORD(dw);                                     \
	*pnS = (int)LOWORD(dw);                                     \
    }

    //
    //  common message cracker macros available in windowx.h on NT--these
    //  should be added to the Win 16 windowsx.h and probably will be
    //  in the future.
    //
    //  there is a windowsx.h16 that ships with the NT PDK that defines
    //  these macros. so if that version is being used, don't redefine
    //  message crackers.
    //

#ifndef WM_CTLCOLORMSGBOX
    #define WM_CTLCOLORMSGBOX           0x0132
    #define WM_CTLCOLOREDIT             0x0133
    #define WM_CTLCOLORLISTBOX          0x0134
    #define WM_CTLCOLORBTN              0x0135
    #define WM_CTLCOLORDLG              0x0136
    #define WM_CTLCOLORSCROLLBAR        0x0137
    #define WM_CTLCOLORSTATIC           0x0138
#endif

#ifndef GET_WM_ACTIVATE_STATE
    #define GET_WM_ACTIVATE_STATE(wp, lp)           (wp)
    #define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      (BOOL)HIWORD(lp)
    #define GET_WM_ACTIVATE_HWND(wp, lp)            (HWND)LOWORD(lp)
    #define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)      (WPARAM)(s), MAKELONG(hwnd, fmin)

    #define GET_WM_CHARTOITEM_CHAR(wp, lp)          (CHAR)(wp)
    #define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(lp)
    #define GET_WM_CHARTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd)    (WPARAM)(ch), MAKELONG(hwnd, pos)

    #define GET_WM_COMMAND_ID(wp, lp)               (wp)
    #define GET_WM_COMMAND_HWND(wp, lp)             (HWND)LOWORD(lp)
    #define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(lp)
    #define GET_WM_COMMAND_MPS(id, hwnd, cmd)       (WPARAM)(id), MAKELONG(hwnd, cmd)

    #define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
    #define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)LOWORD(lp)
    #define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       HIWORD(lp)
    #define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type)    (WPARAM)(hdc), MAKELONG(hwnd, type)

    #define GET_WM_MENUSELECT_CMD(wp, lp)           (wp)
    #define GET_WM_MENUSELECT_FLAGS(wp, lp)         LOWORD(lp)
    #define GET_WM_MENUSELECT_HMENU(wp, lp)         (HMENU)HIWORD(lp)
    #define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)    (WPARAM)(cmd), MAKELONG(f, hmenu)

    // Note: the following are for interpreting MDIclient to MDI child messages.
    #define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)
    #define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
    #define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)

    // Note: the following is for sending to the MDI client window.
    #define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA) (WPARAM)(hwndA), 0

    #define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW)   0, MAKELONG(hmenuF, hmenuW)

    #define GET_WM_MENUCHAR_CHAR(wp, lp)            (CHAR)(wp)
    #define GET_WM_MENUCHAR_HMENU(wp, lp)           (HMENU)LOWORD(lp)
    #define GET_WM_MENUCHAR_FMENU(wp, lp)           (BOOL)HIWORD(lp)
    #define GET_WM_MENUCHAR_MPS(ch, hmenu, f)       (WPARAM)(ch), MAKELONG(hmenu, f)

    #define GET_WM_PARENTNOTIFY_MSG(wp, lp)         (wp)
    #define GET_WM_PARENTNOTIFY_ID(wp, lp)          HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)   (HWND)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_X(wp, lp)           (INT)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_Y(wp, lp)           (INT)HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd)  (WPARAM)(msg), MAKELONG(hwnd, id)
    #define GET_WM_PARENTNOTIFY2_MPS(msg, x, y)     (WPARAM)(msg), MAKELONG(x, y)

    #define GET_WM_VKEYTOITEM_CODE(wp, lp)          (wp)
    #define GET_WM_VKEYTOITEM_ITEM(wp, lp)          (INT)HIWORD(lp)
    #define GET_WM_VKEYTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) (WPARAM)(code), MAKELONG(hwnd, item)

    #define GET_EM_SETSEL_START(wp, lp)             LOWORD(lp)
    #define GET_EM_SETSEL_END(wp, lp)               HIWORD(lp)
    #define GET_EM_SETSEL_MPS(iStart, iEnd)         0, MAKELONG(iStart, iEnd)

    #define GET_EM_LINESCROLL_MPS(vert, horz)       0, MAKELONG(vert, horz)

    #define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)   (HWND)LOWORD(lp)

    #define GET_WM_HSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_HSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_HSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_HSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)

    #define GET_WM_VSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_VSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_VSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_VSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)
#endif

#endif // #ifndef WIN32
#endif // #ifndef RC_INVOKED


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  A few unicode APIs that we implement internally if not
//  compiled for UNICODE.
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
#ifndef UNICODE

#define lstrcmpW IlstrcmpW
#define lstrcpyW IlstrcpyW
#define lstrlenW IlstrlenW
#define DialogBoxParamW IDialogBoxParamW
#define LoadStringW ILoadStringW

#endif
#endif

//--------------------------------------------------------------------------;
//
//  Description:
//      The following are inline wrappers for some of the ComboBox message
//      crackers.  Using these allows better type checking on the parameters
//      used in the cracker.
//
//      The W32 suffix means that the strings are always Wide if WIN32 is
//      defined.  The strings are still Ansi when not WIN32.
//
//  History:
//      03/17/93    fdy     [frankye]
//
//--------------------------------------------------------------------------;
#if defined (WIN32) && !defined(UNICODE)
#define IComboBox_GetLBTextW32          IComboBox_GetLBText_mbstowcs
#define IComboBox_FindStringExactW32    IComboBox_FindStringExact_wcstombs
#define IComboBox_AddStringW32          IComboBox_AddString_wcstombs
#else
#define IComboBox_GetLBTextW32          IComboBox_GetLBText
#define IComboBox_FindStringExactW32    IComboBox_FindStringExact
#define IComboBox_AddStringW32          IComboBox_AddString
#endif

DWORD __inline IComboBox_GetLBText(HWND hwndCtl, int index, LPTSTR lpszBuffer)
{
    return ComboBox_GetLBText(hwndCtl, index, lpszBuffer);
}

int __inline IComboBox_FindStringExact(HWND hwndCtl, int indexStart, LPCTSTR lpszFind)
{
    return ComboBox_FindStringExact(hwndCtl, indexStart, lpszFind);
}

int __inline IComboBox_InsertString(HWND hwndCtl, int index, LPCTSTR lpsz)
{
    return ComboBox_InsertString(hwndCtl, index, lpsz);
}

int __inline IComboBox_AddString(HWND hwndCtl, LPCTSTR lpsz)
{
    return ComboBox_AddString(hwndCtl, lpsz);
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//
//
#define MAX_DRIVER_NAME_CHARS           144 // path + name or other...


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Internal structure for driver management
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Format/Filter structures containing minimal infomation
//  about a filter tag
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tACMFORMATTAGCACHE
{
    DWORD           dwFormatTag;
    DWORD           cbFormatSize;
} ACMFORMATTAGCACHE, *PACMFORMATTAGCACHE, FAR *LPACMFORMATTAGCACHE;

typedef struct tACMFILTERTAGCACHE
{
    DWORD           dwFilterTag;
    DWORD           cbFilterSize;
} ACMFILTERTAGCACHE, *PACMFILTERTAGCACHE, FAR *LPACMFILTERTAGCACHE;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Stream Instance Structure
//
//  this structure is used to maintain an open stream (acmStreamOpen)
//  and maps directly to the HACMSTREAM returned to the caller. this is
//  an internal structure to the ACM and will not be exposed.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tACMSTREAM      *PACMSTREAM;
typedef struct tACMSTREAM
{
    UINT                    uHandleType;    // for param validation (TYPE_HACMSTREAM)
    DWORD                   fdwStream;      // stream state flags, etc.
    PACMSTREAM              pasNext;        // next stream for driver instance (had)
    HACMDRIVER              had;            // handle to driver.
    UINT                    cPrepared;      // number of headers prepared
    ACMDRVSTREAMINSTANCE    adsi;           // passed to driver

} ACMSTREAM;

#define ACMSTREAM_STREAMF_USERSUPPLIEDDRIVER    0x00000001L
#define ACMSTREAM_STREAMF_ASYNCTOSYNC		0x00000002L


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Instance Structure
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tACMDRIVER      *PACMDRIVER;
typedef struct tACMDRIVER
{
    UINT                uHandleType;    // param validation (TYPE_HACMDRIVER)

    PACMDRIVER          padNext;        //
    PACMSTREAM          pasFirst;       //

    HACMDRIVERID        hadid;          // identifier to driver
    HTASK               htask;          // task handle of client
    DWORD               fdwOpen;        // flags used when opened

    HDRVR               hdrvr;          // open driver handle (if driver)
    ACMDRIVERPROC       fnDriverProc;   // function entry (if not driver)
    DWORD_PTR           dwInstance;     // instance data for functions..
#ifndef WIN32
    DWORD               had32;          // 32-bit had for 32-bit drivers
#endif

} ACMDRIVER;


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Identifier Structure
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tACMGARB        *PACMGARB;
typedef struct tACMDRIVERID    *PACMDRIVERID;
typedef struct tACMDRIVERID
{
    //
    // !!! prmval16.asm relies on uHandleType as first int in this struct !!!
    //
    UINT                uHandleType;    // param validation (TYPE_HACMDRIVERID)

    //
    //
    //
    PACMGARB            pag;            // ptr back to garb

    BOOL		fRemove;	// this driver needs to be removed

    UINT                uPriority;      // current global priority
    PACMDRIVERID        padidNext;      // next driver identifier in list
    PACMDRIVER          padFirst;       // first open instance of driver

    HTASK               htask;          // task handle if driver is local

    LPARAM              lParam;         // lParam used when 'added'
    DWORD               fdwAdd;         // flags used when 'added'

    DWORD               fdwDriver;      // ACMDRIVERID_DRIVERF_* info bits

    //
    //	The following members of this structure are cached in the
    //	registry for each driver alias.
    //
    //	    fdwSupport
    //	    cFormatTags
    //	    *paFormatTagCache (for each format tag)
    //	    cFilterTags
    //	    *paFilterTagCache (for each filter tag)
    //

    DWORD               fdwSupport;     // ACMDRIVERID_SUPPORTF_* info bits

    UINT                cFormatTags;
    PACMFORMATTAGCACHE	paFormatTagCache;

    UINT                cFilterTags;    // from aci.cFilterTags
    PACMFILTERTAGCACHE	paFilterTagCache;

    //
    //
    //
    HDRVR               hdrvr;          // open driver handle (if driver)
    ACMDRIVERPROC       fnDriverProc;   // function entry (if not driver)
    DWORD_PTR           dwInstance;     // instance data for functions..

#ifdef WIN32
    LPCWSTR		pszSection;
    WCHAR               szAlias[MAX_DRIVER_NAME_CHARS];
    PWSTR		pstrPnpDriverFilename;
    DWORD		dnDevNode;
#else
    LPCTSTR		pszSection;
    TCHAR               szAlias[MAX_DRIVER_NAME_CHARS];
    PTSTR		pstrPnpDriverFilename;
    DWORD		dnDevNode;

    DWORD               hadid32;        // 32-bit had for 32-bit drivers
#endif


} ACMDRIVERID;

#define ACMDRIVERID_DRIVERF_LOADED      0x00000001L // driver has been loaded
#define ACMDRIVERID_DRIVERF_CONFIGURE   0x00000002L // supports configuration
#define ACMDRIVERID_DRIVERF_ABOUT       0x00000004L // supports custom about
#define ACMDRIVERID_DRIVERF_NOTIFY      0x10000000L // notify only proc
#define ACMDRIVERID_DRIVERF_LOCAL       0x40000000L //
#define ACMDRIVERID_DRIVERF_DISABLED    0x80000000L //




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  This structure is used to store priorities for drivers that aren't
//  actually installed.  This occurs because Win32 doesn't load 16-bit
//  drivers, but Win16 loads both 16- and 32-bit drivers.
//
//  This structure, and all routines that process it, are only used if
//  USETHUNKLIST is defined.  Here, we define it for Win32 only.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
#define USETHUNKLIST
#endif


#ifdef USETHUNKLIST

    typedef struct tPRIORITIESTHUNKLIST *PPRIORITIESTHUNKLIST;
    typedef struct tPRIORITIESTHUNKLIST
    {
	BOOL                fFakeDriver;
	union
	{
	    LPTSTR          pszPrioritiesText;  // if( fFakeDriver )
	    HACMDRIVERID    hadid;              // if( fFakeDriver )
	};
	PPRIORITIESTHUNKLIST pptNext;
    } PRIORITIESTHUNKLIST;

#endif // USETHUNKLIST



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Internal ACM Driver Manager API's in ACM.C
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

LRESULT FNGLOBAL IDriverMessageId
(
    HACMDRIVERID            hadid,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
);

LRESULT FNGLOBAL IDriverConfigure
(
    HACMDRIVERID            hadid,
    HWND                    hwnd
);

MMRESULT FNGLOBAL IDriverGetNext
(
    PACMGARB                pag,
    LPHACMDRIVERID          phadidNext,
    HACMDRIVERID            hadid,
    DWORD                   fdwGetNext
);

MMRESULT FNGLOBAL IDriverAdd
(
    PACMGARB                pag,
    LPHACMDRIVERID          phadidNew,
    HINSTANCE               hinstModule,
    LPARAM                  lParam,
    DWORD                   dwPriority,
    DWORD                   fdwAdd
);

MMRESULT FNGLOBAL IDriverRemove
(
    HACMDRIVERID            hadid,
    DWORD                   fdwRemove
);

MMRESULT FNGLOBAL IDriverOpen
(
    LPHACMDRIVER            phadNew,
    HACMDRIVERID            hadid,
    DWORD                   fdwOpen
);

MMRESULT FNGLOBAL IDriverClose
(
    HACMDRIVER              had,
    DWORD                   fdwClose
);

LRESULT FNGLOBAL IDriverMessage
(
    HACMDRIVER              had,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
);

MMRESULT FNGLOBAL IDriverDetails
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILS      padd,
    DWORD                   fdwDetails
);


MMRESULT FNGLOBAL IDriverPriority
(
    PACMGARB                pag,
    PACMDRIVERID            padid,
    DWORD                   dwPriority,
    DWORD                   fdwPriority
);

MMRESULT FNGLOBAL IDriverSupport
(
    HACMDRIVERID            hadid,
    LPDWORD                 pfdwSupport,
    BOOL                    fFullSupport
);

MMRESULT FNGLOBAL IDriverCount
(
    PACMGARB                pag,
    LPDWORD                 pdwCount,
    DWORD                   fdwSupport,
    DWORD                   fdwEnum
);

MMRESULT FNGLOBAL IDriverGetWaveIdentifier
(
    HACMDRIVERID            hadid,
    LPDWORD                 pdw,
    BOOL                    fInput
);

#ifndef WIN32
MMRESULT FNGLOBAL acmBoot32BitDrivers
(
    PACMGARB    pag
);
#endif

MMRESULT FNGLOBAL acmBootPnpDrivers
(
    PACMGARB    pag
);

MMRESULT FNGLOBAL acmBootDrivers
(
    PACMGARB    pag
);

VOID FNGLOBAL IDriverRefreshPriority
(
    PACMGARB    pag
);

BOOL FNGLOBAL IDriverPrioritiesRestore
(
    PACMGARB pag
);

BOOL FNGLOBAL IDriverPrioritiesSave
(
    PACMGARB pag
);

BOOL FNGLOBAL IDriverBroadcastNotify
(
    PACMGARB            pag
);

MMRESULT FNGLOBAL IMetricsMaxSizeFormat
(
    PACMGARB		pag,
    HACMDRIVER          had,
    LPDWORD             pdwSize
);

MMRESULT FNGLOBAL IMetricsMaxSizeFilter
(
    PACMGARB		pag,
    HACMDRIVER          had,
    LPDWORD             pdwSize
);

DWORD FNGLOBAL IDriverCountGlobal
(
    PACMGARB                pag
);


//
//  Priorities locking stuff.
//
#define ACMPRIOLOCK_GETLOCK             1
#define ACMPRIOLOCK_RELEASELOCK         2
#define ACMPRIOLOCK_ISMYLOCK            3
#define ACMPRIOLOCK_ISLOCKED            4
#define ACMPRIOLOCK_LOCKISOK            5

#define ACMPRIOLOCK_FIRST               ACMPRIOLOCK_GETLOCK
#define ACMPRIOLOCK_LAST                ACMPRIOLOCK_LOCKISOK

BOOL IDriverLockPriority
(
    PACMGARB                pag,
    HTASK                   htask,
    UINT                    uRequest
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Resource defines
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ICON_MSACM                  RCID(10)

#define IDS_TXT_TAG                     150
#define IDS_TXT_NONE                    (IDS_TXT_TAG+0)
#define IDS_TXT_UNTITLED                (IDS_TXT_TAG+1)
#define IDS_TXT_UNAVAILABLE             (IDS_TXT_TAG+2)

#define IDS_FORMAT_TAG_BASE             300
#define IDS_FORMAT_TAG_PCM              (IDS_FORMAT_TAG_BASE + 0)

#define IDS_FORMAT_BASE                     350
#define IDS_FORMAT_FORMAT_MONOSTEREO        (IDS_FORMAT_BASE + 0)
#define IDS_FORMAT_FORMAT_MONOSTEREO_0BIT   (IDS_FORMAT_BASE + 1)
#define IDS_FORMAT_FORMAT_MULTICHANNEL      (IDS_FORMAT_BASE + 2)
#define IDS_FORMAT_FORMAT_MULTICHANNEL_0BIT (IDS_FORMAT_BASE + 3)
#define IDS_FORMAT_CHANNELS_MONO            (IDS_FORMAT_BASE + 4)
#define IDS_FORMAT_CHANNELS_STEREO          (IDS_FORMAT_BASE + 5)
#define IDS_FORMAT_MASH                     (IDS_FORMAT_BASE + 6)



//
//  these are defined in PCM.H
//
#define IDS_PCM_TAG                     500

#define IDS_CHOOSER_TAG                 600

    // unused				(IDS_CHOOSER_TAG+0)
    // unused				(IDS_CHOOSER_TAG+1)
    // unused				(IDS_CHOOSER_TAG+2)
#define IDS_CHOOSEFMT_APPTITLE          (IDS_CHOOSER_TAG+3)
#define IDS_CHOOSEFMT_RATE_FMT          (IDS_CHOOSER_TAG+4)

#define IDS_CHOOSE_FORMAT_DESC          (IDS_CHOOSER_TAG+8)
#define IDS_CHOOSE_FILTER_DESC          (IDS_CHOOSER_TAG+9)

#define IDS_CHOOSE_QUALITY_CD           (IDS_CHOOSER_TAG+10)
#define IDS_CHOOSE_QUALITY_RADIO        (IDS_CHOOSER_TAG+11)
#define IDS_CHOOSE_QUALITY_TELEPHONE    (IDS_CHOOSER_TAG+12)

#define IDS_CHOOSE_QUALITY_DEFAULT      (IDS_CHOOSE_QUALITY_RADIO)

#define IDS_CHOOSE_ERR_TAG              650

#define IDS_ERR_FMTSELECTED             (IDS_CHOOSE_ERR_TAG+0)
#define IDS_ERR_FMTEXISTS               (IDS_CHOOSE_ERR_TAG+1)
#define IDS_ERR_BLANKNAME               (IDS_CHOOSE_ERR_TAG+2)
#define IDS_ERR_INVALIDNAME             (IDS_CHOOSE_ERR_TAG+3)



#define DLG_CHOOSE_SAVE_NAME            RCID(75)
#define IDD_EDT_NAME                    100
#define IDD_STATIC_DESC                 101



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#pragma pack(push, 8)

typedef struct tACMGARB
{
    PACMGARB        pagNext;            // next garb structure
    DWORD           pid;                // process id associated with this garb
    UINT            cUsage;             // usage count for this process

    //
    //	boot flags
    //
    BOOL            fDriversBooted;     // have we booted drivers?
#if defined(WIN32) && defined(WIN4)
    CRITICAL_SECTION csBoot;		// protects boot code from multiple threads
#endif
#ifdef DEBUG
    BOOL            fDriversBooting;    // are we already booting drivers?
#endif

    //
    //	change notification counters.  used to determine when there has been
    //	a change in pnp drivers or in 32-bit drivers.  when the counters
    //	become inconsistent then we know something may have changed and
    //	we need to look for drivers that may have been added or removed.
    //
    DWORD	    dwPnpLastChangeNotify;
    LPDWORD	    lpdwPnpChangeNotify;

#ifdef WIN32
    LPDWORD	    lpdw32BitChangeNotify;
#else
    DWORD	    dw32BitLastChangeNotify;
    DWORD	    dw32BitChangeNotify;
#endif

    //
    //
    //
    HINSTANCE       hinst;              // hinst of ACM module

    PACMDRIVERID    padidFirst;         // list of installed drivers

    HACMDRIVERID    hadidDestroy;       // driver being destroyed
    HACMDRIVER      hadDestroy;         // driver handle being destroyed

    HTASK           htaskPriority;      // !!! hack !!!

    //
    //	For implementing driver list locking.
    //
#ifdef WIN32
    LOCK_INFO       lockDriverIds;
#endif
    DWORD	    dwTlsIndex;		// index for thread local storage.  For
					// 16-bit, this IS the local storage.

    //
    //  Cache of ACM registry keys, so we don't have to open and close them
    //  all the time.  They should be initialized on startup and released
    //  on shutdown.
    //
//    HKEY            hkeyACM;            //  Key name:  gszSecACM
//    HKEY            hkeyPriority;       //  Key name:  gszSecPriority

    //
    //  Thunking stuff
    //
#ifndef WIN32
    BOOL            fWOW;               // thunks connected
#ifndef WIN4
    DWORD           (FAR PASCAL *lpfnCallproc32W_6)(DWORD, DWORD, DWORD,
	                                            DWORD, DWORD, DWORD,
						    LPVOID, DWORD, DWORD);
    LPVOID          lpvAcmThunkEntry;

    DWORD           (FAR PASCAL *lpfnCallproc32W_9)(DWORD, DWORD, DWORD,
	                                            DWORD, DWORD, DWORD,
	                                            DWORD, DWORD, DWORD,
						    LPVOID, DWORD, DWORD);
    LPVOID          lpvXRegThunkEntry;

    DWORD           dwMsacm32Handle;
#endif
#endif // !WIN32


} ACMGARB, *PACMGARB, FAR *LPACMGARB;

#pragma pack(pop)

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN4
PACMGARB FNGLOBAL pagFind(void);
PACMGARB FNGLOBAL pagFindAndBoot(void);
#else
#define pagFind() gplag
#define pagFindAndBoot() gplag
#endif
PACMGARB FNGLOBAL pagNew(void);
void     FNGLOBAL pagDelete(PACMGARB pag);

VOID FNGLOBAL threadInitializeProcess(PACMGARB pag);
VOID FNGLOBAL threadTerminateProcess(PACMGARB pag);
VOID FNGLOBAL threadInitialize(PACMGARB pag);
VOID FNGLOBAL threadTerminate(PACMGARB pag);
VOID FNGLOBAL threadEnterListShared(PACMGARB pag);
VOID FNGLOBAL threadLeaveListShared(PACMGARB pag);
BOOL FNGLOBAL threadQueryInListShared(PACMGARB pag);

#ifndef WIN32
BOOL FNLOCAL acmInitThunks
(
    VOID
);

LRESULT FNGLOBAL IDriverMessageId32
(
    DWORD               hadid32,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
);
LRESULT FNGLOBAL IDriverMessage32
(
    DWORD               hadid32,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
);
MMRESULT FNGLOBAL IDriverLoad32
(
    DWORD   hadid32,
    DWORD   fdwFlags
);
MMRESULT FNGLOBAL IDriverOpen32
(
    LPDWORD             lpahadNew,
    DWORD               hadid32,
    DWORD               fdwOpen
);
LRESULT FNGLOBAL IDriverClose32
(
    DWORD               hdrvr,
    DWORD               fdwClose
);

MMRESULT FNGLOBAL IDriverPriority32
(
    PACMGARB                pag,
    DWORD		    padid32,
    DWORD                   dwPriority,
    DWORD                   fdwPriority
);

MMRESULT FNGLOBAL IDriverGetInfo32
(
    PACMGARB		pag,
    DWORD		hadid32,
    LPSTR		lpstrAlias,
    LPACMDRIVERPROC	lpfnDriverProc,
    LPDWORD		lpdnDevNode,
    LPDWORD		lpfdwAdd
);

MMRESULT FNGLOBAL IDriverGetNext32
(
    PACMGARB		    pag,
    LPDWORD		    phadid32Next,
    DWORD		    hadid32,
    DWORD                   fdwGetNext
);

MMRESULT FNGLOBAL pagFindAndBoot32
(
    PACMGARB		    pag
);

#endif // !WIN32

//
//
//
extern PACMGARB         gplag;
extern CONST TCHAR	gszKeyDrivers[];
extern CONST TCHAR	gszDevNode[];
extern CONST TCHAR	gszSecDrivers[];
#ifdef WIN32
extern CONST WCHAR	gszSecDriversW[];
#endif
extern CONST TCHAR	gszSecDrivers32[];
extern CONST TCHAR	gszIniSystem[];


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Parameter Validation stuff
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  handle types for V_HANDLE (these can be anything except zero!) for
//  HACMOBJ, the parameter validation will test to make sure the handle
//  is one of the three types..
//
#define TYPE_HACMOBJ            0
#define TYPE_HACMDRIVERID       1
#define TYPE_HACMDRIVER         2
#define TYPE_HACMSTREAM         3
#define TYPE_HACMNOTVALID       666


//
//  for parameter validation of flags...
//
#define IDRIVERGETNEXT_VALIDF   (ACM_DRIVERENUMF_VALID)
#define IDRIVERADD_VALIDF       (ACM_DRIVERADDF_VALID)
#define IDRIVERREMOVE_VALIDF    (0L)
#define IDRIVERLOAD_VALIDF      (0L)
#define IDRIVERFREE_VALIDF      (0L)
#define IDRIVEROPEN_VALIDF      (0L)
#define IDRIVERCLOSE_VALIDF     (0L)
#define IDRIVERDETAILS_VALIDF   (0L)


//
//  No error logging for Win32
//

#ifdef WIN32

#define DRVEA_NORMALEXIT    0x0001
#define DRVEA_ABNORMALEXIT  0x0002


#ifndef NOLOGERROR

#if 0
void    WINAPI LogError(UINT err, void FAR* lpInfo);
void    WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);
#else
#define LogError(a, b)
#define LogParamError(a, b, c)
#endif

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING     0x8000
#define ERR_PARAM       0x4000

#define ERR_SIZE_MASK   0x3000
#define ERR_BYTE        0x1000
#define ERR_WORD        0x2000
#define ERR_DWORD       0x3000

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE       0x6001
#define ERR_BAD_FLAGS       0x6002
#define ERR_BAD_INDEX       0x6003
#define ERR_BAD_DVALUE      0x7004
#define ERR_BAD_DFLAGS      0x7005
#define ERR_BAD_DINDEX      0x7006
#define ERR_BAD_PTR         0x7007
#define ERR_BAD_FUNC_PTR    0x7008
#define ERR_BAD_SELECTOR    0x6009
#define ERR_BAD_STRING_PTR  0x700a
#define ERR_BAD_HANDLE      0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS          0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069

/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

#if 0
    /* Debugging support (DEBUG SYSTEM ONLY) */
    typedef struct tagWINDEBUGINFO
    {
	UINT    flags;
	DWORD   dwOptions;
	DWORD   dwFilter;
	char    achAllocModule[8];
	DWORD   dwAllocBreak;
	DWORD   dwAllocCount;
    #if (WINVER >= 0x0400)
	WORD    chDefRIP;
    #endif /* WINVER >= 0x0400 */
    } WINDEBUGINFO;

    BOOL    WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
    BOOL    WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);
#endif

void    FAR _cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS             0x0001
#define WDI_FILTER              0x0002
#define WDI_ALLOCBREAK          0x0004
#define WDI_DEFRIP              0x0008

/* dwOptions values */
#define DBO_CHECKHEAP           0x0001
#define DBO_BUFFERFILL          0x0004
#define DBO_DISABLEGPTRAPPING   0x0010
#define DBO_CHECKFREE           0x0020

#define DBO_SILENT              0x8000

#define DBO_TRACEBREAK          0x2000
#define DBO_WARNINGBREAK        0x1000
#define DBO_NOERRORBREAK        0x0800
#define DBO_NOFATALBREAK        0x0400
#define DBO_INT3BREAK           0x0100

/* DebugOutput flags values */
#define DBF_TRACE               0x0000
#define DBF_WARNING             0x4000
#define DBF_ERROR               0x8000
#define DBF_FATAL               0xc000

/* dwFilter values */
#define DBF_KERNEL              0x1000
#define DBF_KRN_MEMMAN          0x0001
#define DBF_KRN_LOADMODULE      0x0002
#define DBF_KRN_SEGMENTLOAD     0x0004
#define DBF_USER                0x0800
#define DBF_GDI                 0x0400
#define DBF_MMSYSTEM            0x0040
#define DBF_PENWIN              0x0020
#define DBF_APPLICATION         0x0008
#define DBF_DRIVER              0x0010

#endif  /* NOLOGERROR */
#endif // WIN32



//
//
//
BOOL FNGLOBAL ValidateHandle(HANDLE h, UINT uType);
BOOL FNGLOBAL ValidateReadWaveFormat(LPWAVEFORMATEX pwfx);
BOOL FNGLOBAL ValidateReadWaveFilter(LPWAVEFILTER pwf);
BOOL FNGLOBAL ValidateReadPointer(const void FAR* p, DWORD len);
BOOL FNGLOBAL ValidateWritePointer(const void FAR* p, DWORD len);
BOOL FNGLOBAL ValidateDriverCallback(DWORD_PTR dwCallback, UINT uFlags);
BOOL FNGLOBAL ValidateCallback(FARPROC lpfnCallback);

#ifdef WIN32
BOOL FNGLOBAL ValidateStringA(LPCSTR lsz, UINT cchMaxLen);
BOOL FNGLOBAL ValidateStringW(LPCWSTR lsz, UINT cchMaxLen);
#ifdef UNICODE
#define ValidateString      ValidateStringW
#else
#define ValidateString      ValidateStringA
#endif
#else // WIN32
BOOL FNGLOBAL ValidateString(LPCSTR lsz, UINT cchMaxLen);
#endif


//
//  unless we decide differently, ALWAYS do parameter validation--even
//  in retail. this is the 'safest' thing we can do. note that we do
//  not LOG parameter errors in retail (see prmvalXX).
//
#if 1

#define V_HANDLE(h, t, r)       { if (!ValidateHandle(h, t)) return (r); }
#define V_RWAVEFORMAT(p, r)     { if (!ValidateReadWaveFormat(p)) return (r); }
#define V_RWAVEFILTER(p, r)     { if (!ValidateReadWaveFilter(p)) return (r); }
#define V_RPOINTER(p, l, r)     { if (!ValidateReadPointer((p), (l))) return (r); }
#define V_WPOINTER(p, l, r)     { if (!ValidateWritePointer((p), (l))) return (r); }
#define V_DCALLBACK(d, w, r)    { if (!ValidateDriverCallback((d), (w))) return (r); }
#define V_CALLBACK(f, r)        { if (!ValidateCallback(f)) return (r); }
#define V_STRING(s, l, r)       { if (!ValidateString(s,l)) return (r); }
#define V_STRINGW(s, l, r)      { if (!ValidateStringW(s,l)) return (r); }
#define _V_STRING(s, l)         (ValidateString(s,l))
#define _V_STRINGW(s, l)        (ValidateStringW(s,l))
#ifdef DEBUG
#define V_DFLAGS(t, b, f, r)    { if ((t) & ~(b)) {LogParamError(ERR_BAD_DFLAGS, (FARPROC)(f), (LPVOID)(DWORD)(t)); return (r); }}
#else
#define V_DFLAGS(t, b, f, r)    { if ((t) & ~(b))  return (r); }
#endif
#define V_FLAGS(t, b, f, r)     V_DFLAGS(t, b, f, r)
#define V_MMSYSERR(e, f, t, r)  { LogParamError(e, (FARPROC)(f), (LPVOID)(DWORD)(t)); return (r); }

#else

#define V_HANDLE(h, t, r)       { if (!(h)) return (r); }
#define V_RWAVEFORMAT(p, r)     { if (!(p)) return (r); }
#define V_RWAVEFILTER(p, r)     { if (!(p)) return (r); }
#define V_RPOINTER(p, l, r)     { if (!(p)) return (r); }
#define V_WPOINTER(p, l, r)     { if (!(p)) return (r); }
#define V_DCALLBACK(d, w, r)    0
#define V_CALLBACK(f, r)        { if (!(f)) return (r); }
#define V_STRING(s, l, r)       { if (!(s)) return (r); }
#define V_STRINGW(s, l, r)      { if (!(s)) return (r); }
#define _V_STRING(s, l)         (s)
#define _V_STRINGW(s, l)        (s)
#define V_DFLAGS(t, b, f, r)    { if ((t) & ~(b))  return (r); }
#define V_FLAGS(t, b, f, r)     V_DFLAGS(t, b, f, r)

#endif


//
//  the DV_xxxx macros are for internal DEBUG builds--aid to debugging.
//  we do 'loose' parameter validation in retail builds...
//
#ifdef DEBUG

#define DV_HANDLE(h, t, r)      V_HANDLE(h, t, r)
#define DV_RWAVEFORMAT(p, r)    V_RWAVEFORMAT(p, r)
#define DV_RPOINTER(p, l, r)    V_RPOINTER(p, l, r)
#define DV_WPOINTER(p, l, r)    V_WPOINTER(p, l, r)
#define DV_DCALLBACK(d, w, r)   V_DCALLBACK(d, w, r)
#define DV_CALLBACK(f, r)       V_CALLBACK(f, r)
#define DV_STRING(s, l, r)      V_STRING(s, l, r)
#define DV_DFLAGS(t, b, f, r)   V_DFLAGS(t, b, f, r)
#define DV_FLAGS(t, b, f, r)    V_FLAGS(t, b, f, r)
#define DV_MMSYSERR(e, f, t, r) V_MMSYSERR(e, f, t, r)

#else

#define DV_HANDLE(h, t, r)      { if (!(h)) return (r); }
#define DV_RWAVEFORMAT(p, r)    { if (!(p)) return (r); }
#define DV_RPOINTER(p, l, r)    { if (!(p)) return (r); }
#define DV_WPOINTER(p, l, r)    { if (!(p)) return (r); }
#define DV_DCALLBACK(d, w, r)   0
#define DV_CALLBACK(f, r)       { if (!(f)) return (r); }
#define DV_STRING(s, l, r)      { if (!(s)) return (r); }
#define DV_DFLAGS(t, b, f, r)   { if ((t) & ~(b))  return (r); }
#define DV_FLAGS(t, b, f, r)    DV_DFLAGS(t, b, f, r)
#define DV_MMSYSERR(e, f, t, r) { return (r); }

#endif

//
//  Locking stuff
//

#if defined(WIN32) && defined(_MT)
    //
    //
    //
    typedef struct {
	CRITICAL_SECTION CritSec;
    } ACM_HANDLE, *PACM_HANDLE;
    #define HtoPh(h) (((PACM_HANDLE)(h)) - 1)
    HLOCAL NewHandle(UINT length);
    VOID   DeleteHandle(HLOCAL h);
    #define EnterHandle(h) EnterCriticalSection(&HtoPh(h)->CritSec)
    #define LeaveHandle(h) LeaveCriticalSection(&HtoPh(h)->CritSec)
    #define ENTER_LIST_EXCLUSIVE AcquireLockExclusive(&pag->lockDriverIds)
    #define LEAVE_LIST_EXCLUSIVE ReleaseLock(&pag->lockDriverIds)
    #define ENTER_LIST_SHARED {AcquireLockShared(&pag->lockDriverIds); threadEnterListShared(pag);}
    #define LEAVE_LIST_SHARED {threadLeaveListShared(pag); ReleaseLock(&pag->lockDriverIds);}
#else
    #define NewHandle(length) LocalAlloc(LPTR, length)
    #define DeleteHandle(h)   LocalFree(h)
    #define EnterHandle(h)
    #define LeaveHandle(h)
    #define ENTER_LIST_EXCLUSIVE
    #define LEAVE_LIST_EXCLUSIVE
    #define ENTER_LIST_SHARED threadEnterListShared(pag)
    #define LEAVE_LIST_SHARED threadLeaveListShared(pag)
#endif // !(WIN32 && _MT)

;
//
//  Event stuff for async conversion to sync conversion support
//
//	Since the code should never try to call these APIs in WIN16
//	compiles, we just #define these WIN32 APIs to return failures
//
#ifndef WIN32
#define CreateEvent(a, b, c, d) ((HANDLE)(0))
#define ResetEvent(x) ((BOOL)(FALSE))
#define WaitForSingleObject(x,y) ((DWORD)(0xFFFFFFFF))
#define CloseHandle(x) ((BOOL)(FALSE))
#define WAIT_OBJECT_0  (0x00000000)
#define INFINITE (0xFFFFFFFF)
#endif


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_ACMI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\acmthunk.c ===
//==========================================================================;
//
//  acmthunk.c
//
//  Copyright (c) 1991-1998 Microsoft Corporation
//
//  Description:
//      This module contains routines for assisting thunking of the ACM
//      APIs from 16-bit Windows to 32-bit WOW.
//
//  History:
//
//==========================================================================;

/*

    WOW Thunking design:

        Thunks are generated as follows :

        16-bit :
	    acmInitialize->acmThunkInit :

		Initialize the thunk connection with the 32-bit side.

	    pagFindAndBoot->pagFindAndBoot32 :

		For Daytona, both bitness pagFindAndBoot[32] are called
		during LibMain/DllMain.

		For Chicago, pagFindAndBoot calls pagFindAndBoot32 to
		make sure the 32-bit side has booted all drivers.

	    pagFindAndBoot->acmBoot32BitDrivers->IDriverGetNext32 :

		acmBoot32BitDrivers will enumerate and IDriverAdd
		all 32-bit hadids.
	
		The internal flag ACM_DRIVERADDF_32BIT is specified when
		calling IDriverAdd and this flag is stored in the ACMDRIVERID
		structure.  The 32-bit hadid is the lParam for IDriverAdd.

           IDriverAdd->IDriverLoad->IDriverLoad32

	       IDriverAdd saves the 32-bit hadid in the hadid32 field of
	       the newly allocated 16-bit padid and calls the 32-bit side
	       passing in hadid32 which is used to compare against the hadids
	       on the 32-bit side.  This isn't a very usefull step and simply
	       verifies that the 32-bit hadid exists on the 32-bit size.

           IDriverOpen->IDriverOpen32

               The parameters are passed to the 32-bit side using the hadid32
               field deduced from the HACMDRIVERID as the 32-bit HACMDRIVERID.

           IDriverMessageId->IDriverMessageId32 :

               If the driver is 32-bit (as identified in the ACMDRIVERID
               structure) then call IDriverMessageId32.  The hadid for
               the 32-bit driver is stored in the hadid32 field of ACMDRIVERID
               on the 16-bit side.

           IDriverMessage->IDriverMessage32

               If the driver is 32-bit (as identified in the ACMDRIVERID
               structure pointed to by the ACMDRIVER structure) then call
               IDriverMessage32.  The had for the 32-bit driver is stored
               in the hadid32 field of ACMDRIVER on the 16-bit side.

           Stream headers

               These must be persistent on the 32-bit side too and kept
               in synch.

               They are allocated on the 32-bit side for ACMDM_STREAM_PREPARE
               and freed on ACMDM_STREAM_UNPREPARE.  While in existence
               the 32-bit stream header is stored in the dwDriver field in

*/

/*
    Additional Chicago implementation notes:

	PUT SOMETHING HERE FRANK!!!

*/

#ifndef _WIN64

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>

#ifdef WIN32
#ifndef WIN4
#include <wownt32.h>
#endif
#endif // WIN32

#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "pcm.h"
#include "chooseri.h"
#include "uchelp.h"
#include "acmthunk.h"
#include "debug.h"


//
//  Daytona PPC Merge:  The Chicago source uses DRVCONFIGINFOEX, a stucture
//  which isn't defined on Daytona.  In order to avoid hacking the code, I'm
//  defining DCI to be either DRVCONFIGINFO or DRVCONFIGINFOEX.
//  The only difference between the two structures is
//  that DRVCONFIGINFOEX has a dnDevNode member, so accesses to that member
//  have "#if WINVER >= 0x0400" around them.  These defined are marked by a "PPC"
//  comment.
//
#if (WINVER >= 0x0400) // !PPC
typedef DRVCONFIGINFOEX   DCI;
typedef PDRVCONFIGINFOEX  PDCI;
typedef LPDRVCONFIGINFOEX LPDCI;
#else
typedef DRVCONFIGINFO     DCI;
typedef PDRVCONFIGINFO    PDCI;
typedef LPDRVCONFIGINFO   LPDCI;
#endif



#ifdef WIN32


/* -------------------------------------------------------------------------
** Handle and memory mapping functions.
** -------------------------------------------------------------------------
*/

//
//  16-bit structures
//

typedef struct {
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
#if (WINVER >= 0x0400) // !PPC
    DWORD   dnDevNode;
#endif
} DCI16;



#ifdef WIN4
PVOID FNLOCAL ptrFixMap16To32(const VOID * pv)
{
    return MapSLFix(pv);
}

VOID FNLOCAL ptrUnFix16(const VOID * pv)
{
    UnMapSLFixArray(1, &pv);
}

#else
LPWOWHANDLE32          lpWOWHandle32;
LPWOWHANDLE16          lpWOWHandle16;
LPGETVDMPOINTER        GetVdmPointer;
int                    ThunksInitialized;

PVOID FNLOCAL ptrFixMap16To32(const VOID * pv)
{
    return WOW32ResolveMemory(pv);
}

VOID FNLOCAL ptrUnFix16(const VOID * pv)
{
    return;
}

#endif

//
//  Useful functions
//

#define WaveFormatSize(pv)                                            \
    (((WAVEFORMATEX UNALIGNED *)(pv))->wFormatTag == WAVE_FORMAT_PCM ?\
        sizeof(PCMWAVEFORMAT) :                                       \
        ((WAVEFORMATEX UNALIGNED *)pv)->cbSize + sizeof(WAVEFORMATEX))

PVOID CopyAlloc(
    PVOID   pvSrc,
    UINT    uSize
)
{
    PVOID   pvDest;

    pvDest = (PVOID)LocalAlloc(LMEM_FIXED, uSize);

    if (pvDest != NULL) {
        CopyMemory(pvDest, pvSrc, uSize);
    }

    return pvDest;
}

//
//  Thunking callbacks to WOW32 (or wherever)
//


MMRESULT IThunkFilterDetails
(
    HACMDRIVERID                 hadid,
    ACMFILTERDETAILSA UNALIGNED *pafd16,
    DWORD                        fdwDetails
)
{
    ACMFILTERDETAILSA UNALIGNED *pafd;
    ACMFILTERDETAILSW afdw;
    PWAVEFILTER       pwfl;
    UINT              uRet;

    //
    //  Map pointers to 32-bit
    //

    pafd = ptrFixMap16To32((PVOID)pafd16);
    pwfl = ptrFixMap16To32((PVOID)pafd->pwfltr);

    //
    //  Thunk the format details structure
    //  The validation on the 16-bit side ensures that the 16-bit
    //  structure contains all the necessary fields.
    //
    afdw.cbStruct       = sizeof(afdw);
    afdw.dwFilterIndex  = pafd->dwFilterIndex;
    afdw.dwFilterTag    = pafd->dwFilterTag;
    afdw.fdwSupport     = pafd->fdwSupport;
    afdw.pwfltr         = (PWAVEFILTER)CopyAlloc(pwfl, pafd->cbwfltr);


    if (afdw.pwfltr == NULL) {
	ptrUnFix16((PVOID)pafd->pwfltr);
	ptrUnFix16((PVOID)pafd16);
        return MMSYSERR_NOMEM;
    }

    afdw.cbwfltr        = pafd->cbwfltr;

    //
    //  Copy the string if it's used.
    //
    // Imbstowcs(afdw.szFilter, (LPSTR)pafd->szFilter, sizeof(pafd->szFilter));

    //
    //  Call the driver
    //

    uRet =
        ((PACMDRIVER)hadid)->uHandleType == TYPE_HACMDRIVERID ?
         IDriverMessageId(
            hadid,
            ACMDM_FILTER_DETAILS,
            (DWORD)&afdw,
            fdwDetails) :
         IDriverMessage(
            (HACMDRIVER)hadid,
            ACMDM_FILTER_DETAILS,
            (DWORD)&afdw,
            fdwDetails);

    //
    //  If successful copy back the format info
    //

    if (uRet == MMSYSERR_NOERROR) {
        pafd->dwFilterTag    = afdw.dwFilterTag;
        pafd->fdwSupport     = afdw.fdwSupport;
        CopyMemory((PVOID)pwfl, (PVOID)afdw.pwfltr, afdw.cbwfltr);
        Iwcstombs((LPSTR)pafd->szFilter, afdw.szFilter, sizeof(pafd->szFilter));

    }

    LocalFree((HLOCAL)afdw.pwfltr);

    ptrUnFix16((PVOID)pafd->pwfltr);
    ptrUnFix16((PVOID)pafd16);

    return uRet;
}

MMRESULT IThunkFormatDetails
(
    HACMDRIVERID                 hadid,
    ACMFORMATDETAILSA UNALIGNED *pafd16,
    DWORD                        fdwDetails
)
{
    ACMFORMATDETAILSA UNALIGNED *pafd;
    ACMFORMATDETAILSW afdw;
    PWAVEFORMATEX     pwfx;
    UINT              uRet;

    //
    //  Map pointers to 32-bit
    //

    pafd = ptrFixMap16To32((PVOID)pafd16);
    pwfx = ptrFixMap16To32((PVOID)pafd->pwfx);


    //
    //  Thunk the format details structure
    //  The validation on the 16-bit side ensures that the 16-bit
    //  structure contains all the necessary fields.
    //
    afdw.cbStruct       = sizeof(afdw);
    afdw.dwFormatIndex  = pafd->dwFormatIndex;
    afdw.dwFormatTag    = pafd->dwFormatTag;
    afdw.fdwSupport     = pafd->fdwSupport;
    afdw.pwfx           = (PWAVEFORMATEX)CopyAlloc(pwfx, pafd->cbwfx);

    if (afdw.pwfx == NULL) {
    	ptrUnFix16((PVOID)pafd->pwfx);
	    ptrUnFix16((PVOID)pafd16);
        return MMSYSERR_NOMEM;
    }

    afdw.cbwfx          = pafd->cbwfx;

    //
    //  Copy the string if it's used
    //
    // Imbstowcs(afdw.szFormat, (LPSTR)pafd->szFormat, sizeof(pafd->szFormat));

    //
    //  Call the driver
    //

    uRet =
        ((PACMDRIVER)hadid)->uHandleType == TYPE_HACMDRIVERID ?
         IDriverMessageId(
            hadid,
            ACMDM_FORMAT_DETAILS,
            (DWORD)&afdw,
            fdwDetails) :
         IDriverMessage(
            (HACMDRIVER)hadid,
            ACMDM_FORMAT_DETAILS,
            (DWORD)&afdw,
            fdwDetails);

    //
    //  If successful copy back the format info
    //

    if (uRet == MMSYSERR_NOERROR) {

        //
        //  Someone should be shot for designing interfaces with
        //  inputs and outputs in the same structure!!
        //
        pafd->dwFormatTag    = afdw.dwFormatTag;
        pafd->fdwSupport     = afdw.fdwSupport;
        CopyMemory((PVOID)pwfx, (PVOID)afdw.pwfx, afdw.cbwfx);
        Iwcstombs((LPSTR)pafd->szFormat, afdw.szFormat, sizeof(pafd->szFormat));
    }

    LocalFree((HLOCAL)afdw.pwfx);
    ptrUnFix16((PVOID)pafd->pwfx);
    ptrUnFix16((PVOID)pafd16);

    return uRet;
}
MMRESULT IThunkFormatSuggest
(
    HACMDRIVERID                    hadid,
    ACMDRVFORMATSUGGEST UNALIGNED  *pafs16
)
{
    ACMDRVFORMATSUGGEST UNALIGNED  *pafs;
    ACMDRVFORMATSUGGEST afs;
    PWAVEFORMATEX       pwfxSrc;
    PWAVEFORMATEX       pwfxDst;
    UINT                uRet;

    //
    //  Map pointers to 32-bit
    //

    pafs    = ptrFixMap16To32((PVOID)pafs16);
    pwfxSrc = ptrFixMap16To32((PVOID)pafs->pwfxSrc);
    pwfxDst = ptrFixMap16To32((PVOID)pafs->pwfxDst);

    //
    //  Thunk the format details structure
    //  The validation on the 16-bit side ensures that the 16-bit
    //  structure contains all the necessary fields.
    //
    CopyMemory((PVOID)&afs, (PVOID)pafs, sizeof(afs));

    //
    //  Deal with the wave format pointers
    //
    afs.pwfxSrc        =
        (PWAVEFORMATEX)CopyAlloc((PVOID)pwfxSrc, pafs->cbwfxSrc);

    if (afs.pwfxSrc == NULL) {
    	ptrUnFix16((PVOID)pafs->pwfxDst);
	    ptrUnFix16((PVOID)pafs->pwfxSrc);
    	ptrUnFix16((PVOID)pafs16);
        return MMSYSERR_NOMEM;
    }

    afs.pwfxDst        =
        (PWAVEFORMATEX)CopyAlloc((PVOID)pwfxDst, pafs->cbwfxDst);

    if (afs.pwfxDst == NULL) {
        LocalFree((HLOCAL)afs.pwfxSrc);
	    ptrUnFix16((PVOID)pafs->pwfxDst);
    	ptrUnFix16((PVOID)pafs->pwfxSrc);
	    ptrUnFix16((PVOID)pafs16);
        return MMSYSERR_NOMEM;
    }

    //
    //  Call the driver
    //

    uRet =
        ((PACMDRIVER)hadid)->uHandleType == TYPE_HACMDRIVERID ?
         IDriverMessageId(
            hadid,
            ACMDM_FORMAT_SUGGEST,
            (DWORD)&afs,
            0L) :
         IDriverMessage(
            (HACMDRIVER)hadid,
            ACMDM_FORMAT_SUGGEST,
            (DWORD)&afs,
            0L);

     //
     //  If successful copy back the format info
     //

     if (uRet == MMSYSERR_NOERROR) {
         CopyMemory((PVOID)pwfxDst, (PVOID)afs.pwfxDst, afs.cbwfxDst);
     }

     LocalFree((HLOCAL)afs.pwfxSrc);
     LocalFree((HLOCAL)afs.pwfxDst);
     ptrUnFix16((PVOID)pafs->pwfxDst);
     ptrUnFix16((PVOID)pafs->pwfxSrc);
     ptrUnFix16((PVOID)pafs16);

     return uRet;
}

LRESULT IThunkConfigure
(
    HACMDRIVERID      hadid,
    HWND              hwnd,
    DCI16 UNALIGNED * pdci1616
)
{
    DCI16 UNALIGNED * pdci16 = NULL;
    DCI           dci;
    LRESULT       lResult;
    LPSTR         lpszDCISectionNameA;
    LPSTR         lpszDCIAliasNameA;
    LPWSTR        lpszDCISectionNameW;
    LPWSTR        lpszDCIAliasNameW;

    //
    //  Thunk the hwnd if necessary
    //

    if (hwnd != NULL && hwnd != (HWND)-1L) {
#ifdef WIN4
	//  ??? Don't think I need to do anything for Win4 ???
#else
	hwnd = (HWND)(*lpWOWHandle32)( (WORD)hwnd, WOW_TYPE_HWND);
#endif
    }

    dci.dwDCISize = sizeof(dci);

    //
    //  Thunk the config info if necessary
    //

    if (pdci1616 != NULL) {
	    //
	    //  Map all the pointers
	    //
        pdci16              = ptrFixMap16To32((PVOID)pdci1616);
    	lpszDCISectionNameA = ptrFixMap16To32((PVOID)pdci16->lpszDCISectionName);
    	lpszDCIAliasNameA   = ptrFixMap16To32((PVOID)pdci16->lpszDCIAliasName);
	
        dci.dwDCISize = sizeof(dci);
        lpszDCISectionNameW =
            (LPWSTR)
            LocalAlloc(LPTR,
                       (lstrlenA(lpszDCISectionNameA) + 1) * sizeof(WCHAR));

        if (lpszDCISectionNameW == NULL) {
	    ptrUnFix16((PVOID)pdci16->lpszDCISectionName);
	    ptrUnFix16((PVOID)pdci16->lpszDCIAliasName);
	    ptrUnFix16((PVOID)pdci1616);
	    return MMSYSERR_NOMEM;
        }

        lpszDCIAliasNameW =
            (LPWSTR)
            LocalAlloc(LPTR,
                       (lstrlenA(lpszDCIAliasNameA) + 1) * sizeof(WCHAR));

        if (lpszDCIAliasNameW == NULL) {
            LocalFree((HLOCAL)lpszDCISectionNameW);
	    ptrUnFix16((PVOID)pdci16->lpszDCISectionName);
	    ptrUnFix16((PVOID)pdci16->lpszDCIAliasName);
	    ptrUnFix16((PVOID)pdci1616);
	    return MMSYSERR_NOMEM;
        }

        Imbstowcs(lpszDCISectionNameW,
		  lpszDCISectionNameA,
		  lstrlenA(lpszDCISectionNameA) + 1);

        Imbstowcs(lpszDCIAliasNameW,
		  lpszDCIAliasNameA,
		  lstrlenA(lpszDCIAliasNameA) + 1);

        dci.lpszDCISectionName  = lpszDCISectionNameW;
        dci.lpszDCIAliasName    = lpszDCIAliasNameW;
#if (WINVER >= 0x0400) // !PPC
	dci.dnDevNode	    = pdci16->dnDevNode;
#endif
    }

    //
    //  Make the call
    //

    lResult =
        ((PACMDRIVER)hadid)->uHandleType == TYPE_HACMDRIVERID ?
         IDriverMessageId(
            hadid,
            DRV_CONFIGURE,
            (LPARAM)hwnd,
            (LPARAM)(pdci16 == NULL ? NULL : &dci)) :
         IDriverMessage(
            (HACMDRIVER)hadid,
            DRV_CONFIGURE,
            (LPARAM)hwnd,
            (LPARAM)(pdci16 == NULL ? NULL : &dci));

    if (pdci16 != NULL) {
        LocalFree((HLOCAL)dci.lpszDCISectionName);
        LocalFree((HLOCAL)dci.lpszDCIAliasName);
        ptrUnFix16((PVOID)pdci16->lpszDCISectionName);
        ptrUnFix16((PVOID)pdci16->lpszDCIAliasName);
        ptrUnFix16((PVOID)pdci1616);
    }

    return lResult;
}

BOOL IThunkStreamInstance
(
    ACMDRVSTREAMINSTANCE UNALIGNED *padsi16,
    PACMDRVSTREAMINSTANCE          padsi32
)
{
    PWAVEFORMATEX pwfxSrc;
    PWAVEFORMATEX pwfxDst;
    PWAVEFILTER   pwfltr16;

    pwfxSrc  = (PWAVEFORMATEX)ptrFixMap16To32((PVOID)padsi16->pwfxSrc);
    pwfxDst  = (PWAVEFORMATEX)ptrFixMap16To32((PVOID)padsi16->pwfxDst);
    pwfltr16 = (PWAVEFILTER)  ptrFixMap16To32((PVOID)padsi16->pwfltr);

    //
    //  The 16-bit side has 2 fewer bytes in the stream instance data
    //  because the handle is only 2 bytes
    //

    padsi32->has = NULL;
    CopyMemory((PVOID)padsi32, (PVOID)padsi16, sizeof(*padsi32) - 2);

    //
    //  Fix up the pointers
    //

    if (pwfxSrc != NULL) {
        padsi32->pwfxSrc = CopyAlloc((PVOID)pwfxSrc, WaveFormatSize(pwfxSrc));
        if (padsi32->pwfxSrc == NULL) {
	    ptrUnFix16((PVOID)padsi16->pwfltr);
	    ptrUnFix16((PVOID)padsi16->pwfxDst);
	    ptrUnFix16((PVOID)padsi16->pwfxSrc);
            return FALSE;
        }
    } else {
        padsi32->pwfxSrc = NULL;
    }


    if (pwfxDst != NULL) {
        padsi32->pwfxDst = CopyAlloc((PVOID)pwfxDst, WaveFormatSize(pwfxDst));
        if (padsi32->pwfxDst == NULL) {
            if (padsi32->pwfxSrc != NULL) {
                LocalFree((HLOCAL)padsi32->pwfxSrc);
            }
	    ptrUnFix16((PVOID)padsi16->pwfltr);
	    ptrUnFix16((PVOID)padsi16->pwfxDst);
	    ptrUnFix16((PVOID)padsi16->pwfxSrc);
	    return FALSE;
        }
    } else {
        padsi32->pwfxDst = NULL;
    }


    if (padsi16->pwfltr != NULL) {
        padsi32->pwfltr = CopyAlloc(pwfltr16, pwfltr16->cbStruct);

        if (padsi32->pwfltr == NULL) {
            if (padsi32->pwfxSrc != NULL) {
                LocalFree((HLOCAL)padsi32->pwfxSrc);
            }
            if (padsi32->pwfxDst != NULL) {
                LocalFree((HLOCAL)padsi32->pwfxDst);
            }
	        ptrUnFix16((PVOID)padsi16->pwfltr);
	        ptrUnFix16((PVOID)padsi16->pwfxDst);
	        ptrUnFix16((PVOID)padsi16->pwfxSrc);
            return FALSE;
        }
    } else {
        padsi32->pwfltr = NULL;
    }

    ptrUnFix16((PVOID)padsi16->pwfltr);
    ptrUnFix16((PVOID)padsi16->pwfxDst);
    ptrUnFix16((PVOID)padsi16->pwfxSrc);
    return TRUE;
}

VOID IUnThunkStreamInstance
(
    PACMDRVSTREAMINSTANCE  padsi
)
{
    if (padsi->pwfxSrc != NULL) {
        LocalFree((HLOCAL)padsi->pwfxSrc);
    }
    if (padsi->pwfxDst != NULL) {
        LocalFree((HLOCAL)padsi->pwfxDst);
    }
    if (padsi->pwfltr != NULL) {
        LocalFree((HLOCAL)padsi->pwfltr);
    }

}

//--------------------------------------------------------------------------;
//
//  LRESULT IOpenDriver32
//
//  Description:
//
//      Open a 32-bit driver
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      UINT uMsg:
//
//      LPARAM lParam1:
//
//      LPARAM lParam2:
//
//  Return (LRESULT):
//
//  History:
//
//--------------------------------------------------------------------------;
MMRESULT IDriverOpen32
(
    HACMDRIVER UNALIGNED * phad16,
    HACMDRIVERID           hadid,
    DWORD                  fdwOpen
)
{
    HACMDRIVER UNALIGNED * phad;
    HACMDRIVER      had;
    MMRESULT        mmr;

    mmr = IDriverOpen(&had, hadid, fdwOpen);

    if (mmr == MMSYSERR_NOERROR) {
        phad = (HACMDRIVER*)ptrFixMap16To32((PVOID)phad16);
        *phad = had;
	ptrUnFix16((PVOID)phad16);
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
//  LRESULT IDriverMessageId32
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      UINT uMsg:
//
//      LPARAM lParam1:
//
//      LPARAM lParam2:
//
//  Return (LRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;
LRESULT FNLOCAL IDriverMessageId32
(
    HACMDRIVERID        hadid,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
)
{

    switch (uMsg) {

    //
    //  Common with IDriverMessage32
    //
    case DRV_CONFIGURE:
        return IThunkConfigure(hadid,
                               (HWND)lParam1,
                               (DCI16 UNALIGNED *)lParam2);

    case ACMDM_FILTER_DETAILS:
        //
        //
        //
        return IThunkFilterDetails(hadid,
                                   (ACMFILTERDETAILSA UNALIGNED *)lParam1,
                                   (DWORD)lParam2);
        break;

    case ACMDM_FORMAT_DETAILS:
        return IThunkFormatDetails(hadid,
                                   (ACMFORMATDETAILSA UNALIGNED *)lParam1,
                                   (DWORD)lParam2);

    case ACMDM_FORMAT_SUGGEST:
        return IThunkFormatSuggest(hadid,
                                   (PACMDRVFORMATSUGGEST)lParam1);



    //
    //
    //
    case DRV_QUERYCONFIGURE:
        //
        //  Just pass the message on
        //
        return IDriverMessageId(hadid, uMsg, lParam1, lParam2);

    case ACMDM_DRIVER_DETAILS:
        {
            ACMDRIVERDETAILSA  acmd;
            MMRESULT uRet;

            acmd.cbStruct = sizeof(acmd);
            uRet = acmDriverDetailsA(hadid, &acmd, 0L);

            if (uRet == MMSYSERR_NOERROR) {
                PVOID pvStart;
                WORD  wicon;

                /*
                **  No async support - we don't want to support callbacks
                */
                acmd.fdwSupport &= ~ACMDRIVERDETAILS_SUPPORTF_ASYNC;

		//
		//  Map pointer from 16- to 32-bits
		//
		pvStart = ptrFixMap16To32((PVOID)lParam1);

                /*
                **  Copy it all back but remember HICON is 16-bit
                **  on the 16-bit side
                */
		
                CopyMemory(pvStart,
                           (PVOID)&acmd,
                           FIELD_OFFSET(ACMDRIVERDETAILSA, hicon) );

                /*
                ** map and copy the icon handle
                **
                ** Note: There is not a WOW_TYPE_ICON in the WOW_HANDLE_TYPE
                ** enumeration.
                */
#ifdef WIN4
		wicon = (WORD)acmd.hicon;
#else
                wicon = (*lpWOWHandle16)( acmd.hicon, WOW_TYPE_HWND);
#endif

                CopyMemory((PVOID)((PBYTE)pvStart +
			   FIELD_OFFSET(ACMDRIVERDETAILSA, hicon)),
			   &wicon,
                           sizeof(WORD) );

                CopyMemory((PVOID)((PBYTE)pvStart +
                               FIELD_OFFSET(ACMDRIVERDETAILSA, hicon) +
                               sizeof(WORD)),
                           (PVOID)acmd.szShortName,
                           sizeof(acmd) -
                               FIELD_OFFSET(ACMDRIVERDETAILSA, szShortName[0]));

		//
		//  Unmap pointer
		//
		ptrUnFix16((PVOID)lParam1);
            }
            return uRet;
        }

    case ACMDM_FORMATTAG_DETAILS:
        {
            ACMFORMATTAGDETAILS             acmf;
            ACMFORMATTAGDETAILSA UNALIGNED *pvacmf;
            MMRESULT                        uRet;

            pvacmf = (ACMFORMATTAGDETAILSA UNALIGNED *)
                          ptrFixMap16To32((PVOID)lParam1);

#ifdef TRUE	// UNICODE
            CopyMemory((PVOID)&acmf, (PVOID)pvacmf,
                       FIELD_OFFSET(ACMFORMATTAGDETAILS, szFormatTag[0]));

            acmf.cbStruct = sizeof(acmf);

	    //
	    //	szFormatTag is never an input arg so no need to thunk it
	    //
	    // Imbstowcs(acmf.szFormatTag,
	    //		 (LPSTR)pvacmf->szFormatTag,
	    //           sizeof(pvacmf->szFormatTag));
	    //
#else
	    CopyMemory((PVOID)&acmf, (PVOID)pvacmf, sizeof(acmf));
	    acmf.cbStruct = sizeof(acmf);
#endif

            uRet = IDriverMessageId(hadid,
                                    uMsg,
                                    (LPARAM)&acmf,
                                    lParam2);

            if (uRet == MMSYSERR_NOERROR) {
#ifdef TRUE	// UNICODE
                CopyMemory((PVOID)pvacmf, (PVOID)&acmf,
                           FIELD_OFFSET(ACMFORMATTAGDETAILS, szFormatTag[0]));

		pvacmf->cbStruct = sizeof(*pvacmf);
		
                Iwcstombs((LPSTR)pvacmf->szFormatTag,
                         acmf.szFormatTag,
                         sizeof(pvacmf->szFormatTag));
#else
		CopyMemory((PVOID)pvacmf, (PVOID)&acmf, sizeof(acmf));
		pvacmf->cbStruct = sizeof(*pvacmf);
#endif
            }
	    ptrUnFix16((PVOID)lParam1);
            return uRet;
        }
        break;

    case ACMDM_FILTERTAG_DETAILS:
        {
            ACMFILTERTAGDETAILS             acmf;
            ACMFILTERTAGDETAILSA UNALIGNED *pvacmf;
            MMRESULT                        uRet;

            pvacmf = (ACMFILTERTAGDETAILSA UNALIGNED *)
			 ptrFixMap16To32((PVOID)lParam1);

#ifdef TRUE	// UNICODE
            CopyMemory((PVOID)&acmf, (PVOID)pvacmf,
                       FIELD_OFFSET(ACMFILTERTAGDETAILS, szFilterTag[0]));

            acmf.cbStruct = sizeof(acmf);

	    //
	    //	szFilterTag is never an input arg so no need to thunk it
	    //
	    // Imbstowcs(acmf.szFilterTag,
	    //           (LPSTR)pvacmf->szFilterTag,
	    //           sizeof(pvacmf->szFilterTag));
	    //
#else
	    CopyMemory((PVOID)&acmf, (PVOID)pvacmf, sizeof(acmf));
	    acmf.cbStruct = sizeof(acmf);
#endif

            uRet = IDriverMessageId(hadid,
                                    uMsg,
                                    (LPARAM)&acmf,
                                    lParam2);


            if (uRet == MMSYSERR_NOERROR) {
#ifdef TRUE	// UNICODE
                CopyMemory((PVOID)pvacmf, (PVOID)&acmf,
                           FIELD_OFFSET(ACMFILTERTAGDETAILS, szFilterTag[0]));

		pvacmf->cbStruct = sizeof(*pvacmf);
		
                Iwcstombs((LPSTR)pvacmf->szFilterTag,
                         acmf.szFilterTag,
                         sizeof(pvacmf->szFilterTag));
#else
		CopyMemory((PVOID)pvacmf, (PVOID)&acmf, sizeof(acmf));
		pvacmf->cbStruct = sizeof(*pvacmf);
#endif
            }
	    ptrUnFix16((PVOID)lParam1);
            return uRet;
        }
        break;

    case ACMDM_HARDWARE_WAVE_CAPS_INPUT:
        {
            //
            //  wave input
            //
            WAVEINCAPSA  wica;
            WAVEINCAPSW  wicw;
            MMRESULT     uRet;

            uRet = IDriverMessageId(hadid,
                                    uMsg,
                                    (LPARAM)&wicw,
                                    sizeof(wicw));

            if (uRet == MMSYSERR_NOERROR) {
                CopyMemory((PVOID)&wica, (PVOID)&wicw,
                           FIELD_OFFSET(WAVEINCAPS, szPname[0]));

                Iwcstombs(wica.szPname, wicw.szPname, sizeof(wica.szPname));

                CopyMemory(ptrFixMap16To32((PVOID)lParam1),
                           (PVOID)&wica,
                           lParam2);
		ptrUnFix16((PVOID)lParam1);
            }

            return uRet;
        }

    case ACMDM_HARDWARE_WAVE_CAPS_OUTPUT:
        {
            //
            //  wave output
            //
            WAVEOUTCAPSA  woca;
            WAVEOUTCAPSW  wocw;
            MMRESULT uRet;

            uRet = IDriverMessageId(hadid,
                                    uMsg,
                                    (LPARAM)&wocw,
                                    sizeof(wocw));

            if (uRet == MMSYSERR_NOERROR) {
                CopyMemory((PVOID)&woca, (PVOID)&wocw,
                           FIELD_OFFSET(WAVEOUTCAPS, szPname[0]));

                Iwcstombs(woca.szPname, wocw.szPname, sizeof(woca.szPname));

                CopyMemory(ptrFixMap16To32((PVOID)lParam1),
                           (PVOID)&woca,
                           lParam2);
		ptrUnFix16((PVOID)lParam1);
            }

            return uRet;
        }
        break;

    case ACMDM_DRIVER_ABOUT:

        //
        //  Map the window handle
        //
#ifndef WIN4
        lParam1 = (LPARAM)(*lpWOWHandle32)( (WORD)lParam1, WOW_TYPE_HWND);
#endif

        return IDriverMessageId(hadid, uMsg, lParam1, lParam2);

    case ACMDM_DRIVER_NOTIFY:
    default:
        return MMSYSERR_NOTSUPPORTED;

    }

}

//--------------------------------------------------------------------------;
//
//  LRESULT IDriverMessage32
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      UINT uMsg:
//
//      LPARAM lParam1:
//
//      LPARAM lParam2:
//
//  Return (LRESULT):
//
//  History:
//      09/05/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;
LRESULT FNLOCAL IDriverMessage32
(
    HACMDRIVER          had,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
)
{
    DWORD		dwSave;

    switch (uMsg) {
    //
    //  Common with IDriverMessageId32
    //
    case DRV_CONFIGURE:
        //
        //  16-bit apps can configure 32-bit drivers
        //
        return IThunkConfigure((HACMDRIVERID)had,
                               (HWND)lParam1,
                               (DCI16 UNALIGNED *)lParam2);

    case ACMDM_FILTER_DETAILS:
        //
        //
        //
        return IThunkFilterDetails((HACMDRIVERID)had,
                                   (ACMFILTERDETAILSA UNALIGNED *)lParam1,
                                   (DWORD)lParam2);
        break;

    case ACMDM_FORMAT_DETAILS:
        return IThunkFormatDetails((HACMDRIVERID)had,
                                   (ACMFORMATDETAILSA UNALIGNED *)lParam1,
                                   (DWORD)lParam2);

    case ACMDM_FORMAT_SUGGEST:
        return IThunkFormatSuggest((HACMDRIVERID)had,
                                   (ACMDRVFORMATSUGGEST UNALIGNED *)lParam1);


    //
    //
    //
    case ACMDM_STREAM_OPEN:
    case ACMDM_STREAM_CLOSE:
    case ACMDM_STREAM_RESET:
    case ACMDM_STREAM_SIZE:
        //
        //  Passes in PACMDRVSTREAMINSTANCE in lPararm1
        //
        {
            ACMDRVSTREAMINSTANCE  adsi;
            ACMDRVSTREAMINSTANCE UNALIGNED *padsi;    // unaligned 16-bit version
            MMRESULT              uRet;
            ACMDRVSTREAMSIZE      adss;
            ACMDRVSTREAMSIZE UNALIGNED *lpadss16;     // unaligned 16-bit version

            padsi = (ACMDRVSTREAMINSTANCE*)ptrFixMap16To32((PVOID)lParam1);

            if (!IThunkStreamInstance(padsi, &adsi)) {
		ptrUnFix16((PVOID)lParam1);
                return MMSYSERR_NOMEM;
            }

            if (uMsg == ACMDM_STREAM_SIZE) {
                lpadss16 = (LPACMDRVSTREAMSIZE)ptrFixMap16To32((PVOID)lParam2);
                CopyMemory( (PVOID)&adss, (PVOID)lpadss16, sizeof(adss));
            }

            //
            //  Call the driver
            //

            uRet = IDriverMessage(had,
                                  uMsg,
                                  (LPARAM)&adsi,
                                  uMsg == ACMDM_STREAM_SIZE ?
                                      (LPARAM)&adss : lParam2);

            IUnThunkStreamInstance(&adsi);

            if (uRet == MMSYSERR_NOERROR) {

                //
                //  Don't lose data the driver may have set up
                //
                padsi->fdwDriver = adsi.fdwDriver;
                padsi->dwDriver  = adsi.dwDriver;

                //
                //  Return the size stuff if requested
                //

                if (uMsg == ACMDM_STREAM_SIZE) {
                    CopyMemory( (PVOID)lpadss16, (PVOID)&adss, sizeof(adss) );
                }
            }

	    ptrUnFix16((PVOID)lParam2);
	    ptrUnFix16((PVOID)lParam1);
            return uRet;
        }

    case ACMDM_STREAM_PREPARE:
    case ACMDM_STREAM_UNPREPARE:
    case ACMDM_STREAM_CONVERT:
        //
        //  Passes in PACMDRVSTREAMINSTANCE in lPararm1
        //
        {
            ACMDRVSTREAMINSTANCE  adsi;
            ACMDRVSTREAMINSTANCE UNALIGNED *padsi;    // unaligned 16-bit version
            MMRESULT              uRet;
            ACMDRVSTREAMHEADER UNALIGNED *padsh;
            PACMDRVSTREAMHEADER   padsh32;

            padsi = ptrFixMap16To32((PVOID)lParam1);
            padsh = ptrFixMap16To32((PVOID)lParam2);

            if (!IThunkStreamInstance(padsi, &adsi)) {
		ptrUnFix16((PVOID)lParam2);
		ptrUnFix16((PVOID)lParam1);
                return MMSYSERR_NOMEM;
            }

            //
            //  If this not prepare we already have a 32-bit
            //  stream header.
            //

            if (uMsg == ACMDM_STREAM_PREPARE) {
                padsh->dwDriver = (DWORD)LocalAlloc(LMEM_FIXED, sizeof(*padsh));
            }
            padsh32 = (PACMDRVSTREAMHEADER)padsh->dwDriver;

            if (padsh32 != NULL) {

                //  Thunk the stream header
                //
                //  NOTE - NO ATTEMPT is made to align the byte fields,
                //  this is up to the drivers.
                //
		
		dwSave = padsh32->dwDriver;
                CopyMemory((PVOID)padsh32, (PVOID)padsh, sizeof(*padsh));
		padsh32->dwDriver = dwSave;

                padsh32->pbSrc  = (PBYTE)ptrFixMap16To32((PVOID)padsh32->pbSrc);
                padsh32->pbDst  = (PBYTE)ptrFixMap16To32((PVOID)padsh32->pbDst);

                //
                //  Call the driver
                //

                uRet = IDriverMessage(had,
                                      uMsg,
                                      (LPARAM)&adsi,
                                      (LPARAM)padsh32);
            } else {
                uRet = MMSYSERR_NOMEM;
            }

            IUnThunkStreamInstance(&adsi);

            if (uRet == MMSYSERR_NOERROR) {

                //
                //  Don't lose data the driver may have set up
                //
                padsi->fdwDriver = adsi.fdwDriver;
                padsi->dwDriver  = adsi.dwDriver;

                //
                //  Copy back the stream header (don't mess up the pointers
                //  or driver instance data though!).
                //

                padsh32->pbSrc    = padsh->pbSrc;
                padsh32->pbDst    = padsh->pbDst;
		dwSave = padsh32->dwDriver;
                padsh32->dwDriver = padsh->dwDriver;
                CopyMemory((PVOID)padsh, (PVOID)padsh32, sizeof(*padsh));
		padsh32->dwDriver = dwSave;

            }

            //
            //  Free if this is unprepare (note that this must be done
            //  whether the driver succeeds of not since the driver may not
            //  support unprepare.
            //

            if (uMsg == ACMDM_STREAM_UNPREPARE) {
                LocalFree((HLOCAL)padsh->dwDriver);
                padsh->dwDriver = 0;
            }

	    if (NULL != padsh32)
	    {
		ptrUnFix16((PVOID)padsh->pbDst);
		ptrUnFix16((PVOID)padsh->pbSrc);
	    }
	    ptrUnFix16((PVOID)lParam2);
	    ptrUnFix16((PVOID)lParam1);
	    return uRet;
        }
	
    }

    return MMSYSERR_NOTSUPPORTED;       // None of the switchs hit.  Return not supported
}

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverGetNext32
//
//  Description:
//	Called on 32-bit side of thunk to get the next hadid in the
//	driver list.
//
//  Arguments:
//	PACMGARB pag:
//
//      LPHACMDRIVERID phadidNext:
//
//      HACMDRIVERID hadid:
//
//      DWORD fdwGetNext:
//
//  Return (MMRESULT):
//
//  History:
//      06/25/94    fdy	    [frankye]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IDriverGetNext32
(
    PACMGARB		    pag,
    LPHACMDRIVERID          phadidNext,
    HACMDRIVERID            hadid,
    DWORD                   fdwGetNext
)
{
    ASSERT(NULL != phadidNext);
    return IDriverGetNext(pag, phadidNext, hadid, fdwGetNext);
}

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverGetInfo32
//
//  Description:
//	Gets the szAlias, fnDriverProc, dnDevNode, and fdwAdd for
//	a 32-bit hadid.
//
//  Arguments:
//	PACMGARB pag: Usual garbage pointer.
//
//      HACMDRIVERID hadid: handle to driver id for which to get info.
//
//	LPSTR lpstrAlias: pointer to buffer to receive alias string.
//
//	LPACMDRIVERPROC lpfnDriverProc: pointer to ACMDRIVERPROC variable
//	    to receive the driver proc pointer.
//
//	LPDWORD lpdnDevNode: pointer to a DWORD to receive dnDevNode.
//
//      LPDWORD lpfdwAdd: pointer to DWORD to receive the add flags.
//
//  Return (MMRESULT):
//	MMSYSERR_NOERROR:
//	MMSYSERR_INVALHANDLE: hadid not in driver list.
//
//  History:
//      06/25/94    fdy	    [frankye]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IDriverGetInfo32
(
    PACMGARB		pag,
    HACMDRIVERID	hadid,
    LPSTR           lpstrAlias,
    LPACMDRIVERPROC	lpfnDriverProc,
    LPDWORD         lpdnDevNode,
    LPDWORD         lpfdwAdd
)
{
    HACMDRIVERID	hadidT;
    PACMDRIVERID	padid;
    DWORD		fdwEnum;

    ASSERT( (NULL != lpstrAlias) &&
	    (NULL != lpfnDriverProc) &&
	    (NULL != lpdnDevNode) &&
	    (NULL != lpfdwAdd) );

    //
    //	Search for this hadid in the driver list.  If found,
    //	return some information on it.
    //

    hadidT = NULL;
    fdwEnum = ACM_DRIVERENUMF_DISABLED;
    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadidT, hadidT, fdwEnum))
    {
	if (hadidT == hadid)
	{
	    padid = (PACMDRIVERID)hadid;

	    Iwcstombs(lpstrAlias, padid->szAlias, MAX_DRIVER_NAME_CHARS);

	    *lpfnDriverProc = padid->fnDriverProc;

	    *lpdnDevNode = padid->dnDevNode;

	    *lpfdwAdd = padid->fdwAdd;

	    return MMSYSERR_NOERROR;
	}
    }

    return MMSYSERR_INVALHANDLE;
}
	

//--------------------------------------------------------------------------;
//
//  DWORD acmMessage32
//
//  Description:
//
//      32-bit function dispatcher for thunks.
//
//  Arguments:
//      DWORD dwThunkId:
//
//      DWORD dw1:
//
//      DWORD dw2:
//
//      DWORD dw3:
//
//      DWORD dw4:
//
//	DWORD dw5:
//
//  Return (DWORD):
//
//  History:
//
//--------------------------------------------------------------------------;

#ifdef WIN4
DWORD WINAPI acmMessage32
#else
DWORD acmMessage32
#endif
(
    DWORD dwThunkId,
    DWORD dw1,
    DWORD dw2,
    DWORD dw3,
    DWORD dw4,
    DWORD dw5
)
{
    // DPF(4,"acmMessage32(dwThunkId=%08lxh, dw1=%08lxh, dw2=%08lxh, dw3=%08lxh, dw4=%08lxh, dw5=%08lxh);", dwThunkId, dw1, dw2, dw3, dw4, dw5);
#ifndef WIN4
    //
    //  Make sure we've got thunking functionality
    //

    if (ThunksInitialized <= 0) {

        HMODULE hMod;

        if (ThunksInitialized == -1) {
            return MMSYSERR_ERROR;
        }

        hMod = GetModuleHandle(GET_MAPPING_MODULE_NAME);
        if (hMod != NULL) {

            GetVdmPointer =
                (LPGETVDMPOINTER)GetProcAddress(hMod, GET_VDM_POINTER_NAME);
            lpWOWHandle32 =
                (LPWOWHANDLE32)GetProcAddress(hMod, GET_HANDLE_MAPPER32 );
            lpWOWHandle16 =
                (LPWOWHANDLE16)GetProcAddress(hMod, GET_HANDLE_MAPPER16 );
        }

        if ( GetVdmPointer == NULL
          || lpWOWHandle16 == NULL
          || lpWOWHandle32 == NULL ) {

            ThunksInitialized = -1;
            return MMSYSERR_ERROR;

        } else {
            ThunksInitialized = 1;
        }
    }
#endif


    //
    //  Perform the requested function
    //

    switch (dwThunkId) {

        case acmThunkDriverMessageId32:
            return (DWORD)IDriverMessageId32(
                              (HACMDRIVERID)dw1,
                              (UINT)dw2,
                              (LPARAM)dw3,
                              (LPARAM)dw4);

        case acmThunkDriverMessage32:
            return (DWORD)IDriverMessage32(
                              (HACMDRIVER)dw1,
                              (UINT)dw2,
                              (LPARAM)dw3,
                              (LPARAM)dw4);

	case acmThunkDriverGetNext32:
	{
	    PACMGARB	            pag;
	    HACMDRIVERID UNALIGNED* lphadidNext;
	    HACMDRIVERID            hadid;
	    DWORD	            fdwGetNext;
	    HACMDRIVERID            hadidNext;
	    DWORD	            dwReturn;

	    pag = pagFind();
	    if (NULL == pag)
	    {
		DPF(0, "acmThunkDriverGetNext32: NULL pag!!!");
		return (MMSYSERR_ERROR);
	    }

	    //
	    //	parameters from 16-bit side
	    //
	    lphadidNext	= (HACMDRIVERID UNALIGNED*)ptrFixMap16To32((PVOID)dw1);
	    hadid	= (HACMDRIVERID)dw2;
	    fdwGetNext	= (DWORD)dw3;
	
	    //
	    //	in parameters
	    //	    hadid
	    //	    fdwGetNext
	    //
	    //	out parameters
	    //	    lphadidNext	    *
	    //
	    //	* Need to use aligned buffers, therefore use local buffers
	    //

	    dwReturn = (DWORD)IDriverGetNext32(pag,
					       &hadidNext,
					       hadid,
					       fdwGetNext);

	    //
	    //	Copy output data from aligned buffers to unaligned
	    //	buffers (on 16-bit side).
	    //
	    *lphadidNext = hadidNext;

	    //
	    //	Unmap pointers from 16-bit side
	    //
	    ptrUnFix16((PVOID)dw1);

	    return (dwReturn);
	}

	case acmThunkDriverGetInfo32:
	{
	    PACMGARB	             pag;
	    HACMDRIVERID             hadid;
	    LPSTR	             lpstrAlias;
	    ACMDRIVERPROC UNALIGNED* lpfnDriverProc;
	    DWORD UNALIGNED*	     lpdnDevNode;
	    DWORD UNALIGNED*         lpfdwAdd;
	    ACMDRIVERPROC            fnDriverProc;
	    DWORD                    dnDevNode;
	    DWORD                    fdwAdd;
	    DWORD	             dwReturn;

	    pag = pagFind();
	    if (NULL == pag)
	    {
		DPF(0, "acmDriverGetInfo32: NULL pag!!!");
		return (MMSYSERR_ERROR);
	    }

	    //
	    //	parameters from 16-bit side
	    //
	    hadid	    = (HACMDRIVERID)dw1;
	    lpstrAlias	    = (LPSTR)ptrFixMap16To32((PVOID)dw2);
	    lpfnDriverProc  = (ACMDRIVERPROC UNALIGNED*)ptrFixMap16To32((PVOID)dw3);
	    lpdnDevNode	    = (DWORD UNALIGNED*)ptrFixMap16To32((PVOID)dw4);
	    lpfdwAdd	    = (DWORD UNALIGNED*)ptrFixMap16To32((PVOID)dw5);

	    //
	    //	in parameters
	    //	    hadid
	    //
	    //	out parameters
	    //	    lpstrAlias
	    //	    lpfnDriverProc  *
	    //	    lpdnDevNode	    *
	    //	    lpfdwAdd	    *
	    //
	    //	* Need to use aligned buffers, therefore use local buffers
	    //

	    //
	    //	make the call
	    //
	    dwReturn = (DWORD)IDriverGetInfo32(pag, hadid, lpstrAlias, &fnDriverProc, &dnDevNode, &fdwAdd);

	    //
	    //	Copy output data from aligned buffers to unaligned
	    //	buffers (on 16-bit side).
	    //
	    *lpfnDriverProc = fnDriverProc;
	    *lpdnDevNode    = dnDevNode;
	    *lpfdwAdd       = fdwAdd;

	    //
	    //	Unmap pointers from 16-bit side
	    //
	    ptrUnFix16((PVOID)dw5);
	    ptrUnFix16((PVOID)dw4);
	    ptrUnFix16((PVOID)dw3);
	    ptrUnFix16((PVOID)dw2);

	    return dwReturn;
	}

        case acmThunkDriverLoad32:
        {
	    PACMGARB	    pag;
            PACMDRIVERID    padid;

            //
            //
            //
	    pag = pagFind();
	    if (NULL == pag)
	    {
		DPF(1, "acmThunkDriverLoad32: NULL pag!!!");
		return (DWORD)(MMSYSERR_ERROR);
	    }
	
            for (padid = pag->padidFirst;
                 padid != NULL;
                 padid = padid->padidNext)
            {
		if (padid == (PACMDRIVERID)(dw1))
		{
		    return (MMSYSERR_NOERROR);
		}
            }
            return (DWORD)(MMSYSERR_NODRIVER);
        }

	case acmThunkDriverOpen32:
            return (DWORD)IDriverOpen32(
                              (HACMDRIVER UNALIGNED *)dw1,
                              (HACMDRIVERID)dw2,
                              (DWORD)dw3);

        case acmThunkDriverClose32:

            //
            //  Call close directly
            //
            return (DWORD)IDriverClose((HACMDRIVER)dw1, dw2);

	case acmThunkDriverPriority32:
	    return (DWORD)IDriverPriority( (PACMGARB)((PACMDRIVERID)dw1)->pag,
					   (PACMDRIVERID)dw1,
					   (DWORD)dw2,
					   (DWORD)dw3 );
	
	case acmThunkFindAndBoot32:
	{
	    PACMGARB	pag;
	
	    //
	    //
	    //
	    pag = pagFind();
	    if (NULL == pag)
	    {
		DPF(1, "acmThunkFindAndBoot32: NULL pag!!!");
		return (DWORD)(MMSYSERR_ERROR);
	    }

	    if (NULL == pag->lpdw32BitChangeNotify)
	    {
		pag->lpdw32BitChangeNotify = ptrFixMap16To32((PVOID)dw1);
	    }
	
	    pagFindAndBoot();
	
	    return (DWORD)(MMSYSERR_NOERROR);
	}

    }
    return MMSYSERR_NOTSUPPORTED;       // None of the switchs hit.  Return not supported
}

#else // !WIN32

//--------------------------------------------------------------------------;
//
//
//
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
//  MMRESULT acmBootDrivers32
//
//  Description:
//
//  Arguments:
//	PACMGARB pag:
//
//  Return (MMRESULT):
//
//  History:
//
//--------------------------------------------------------------------------;
MMRESULT FNGLOBAL pagFindAndBoot32
(
    PACMGARB pag
)
{
    MMRESULT mmr;

    DPF(5,"pagFindAndBoot32();");

#ifdef WIN4
    mmr = (MMRESULT) acmMessage32(acmThunkFindAndBoot32,
				  (DWORD)(LPUINT)&pag->dw32BitChangeNotify,
				  (DWORD)0,
				  (DWORD)0,
				  (DWORD)0,
				  (DWORD)0 );

#else
    mmr = (MMRESULT)(*pag->lpfnCallproc32W_6)(acmThunkFindAndBoot32,
					      (DWORD)(LPUINT)&pag->dw32BitChangeNotify,
					      (DWORD)0,
					      (DWORD)0,
					      (DWORD)0,
					      (DWORD)0,
					      pag->lpvAcmThunkEntry,
					      0L,    // Don't map pointers
					      6L);
#endif

    return mmr;
}

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverGetNext32
//
//  Description:
//	Called on 16-bit side of thunk to get the next 32-bit hadid in the
//	32-bit driver list.
//
//  Arguments:
//	PACMGARB pag:
//
//      LPDWORD phadid32Next:
//
//      DWORD hadid:
//
//      DWORD fdwGetNext:
//
//  Return (MMRESULT):
//
//  History:
//      06/25/94    fdy	    [frankye]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverGetNext32
(
    PACMGARB		    pag,
    LPDWORD		    phadid32Next,
    DWORD		    hadid32,
    DWORD                   fdwGetNext
)
{
    MMRESULT mmr;

    DPF(5,"IDriverGetNext32();");

#ifdef WIN4
    mmr = (MMRESULT) acmMessage32(acmThunkDriverGetNext32,
				  (DWORD)phadid32Next,
				  (DWORD)hadid32,
				  (DWORD)fdwGetNext,
				  (DWORD)0,
				  (DWORD)0 );

#else
    mmr = (MMRESULT)(*pag->lpfnCallproc32W_6)(acmThunkDriverGetNext32,
					      (DWORD)phadid32Next,
					      (DWORD)hadid32,
					      (DWORD)fdwGetNext,
					      (DWORD)0,
					      (DWORD)0,
					      pag->lpvAcmThunkEntry,
					      0L,    // Don't map pointers
					      6L);
#endif

    return mmr;
}

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverGetInfo32
//
//  Description:
//	16-bit side.  Gets the alias and the add flags for a 32-bit hadid.
//
//  Arguments:
//	PACMGARB pag:
//
//      DWORD hadid32:
//
//	LPSTR lpstrAlias:
//
//	LPACMDRIVERPROC lpfnDriverProc:
//
//      LPDWORD lpfdwAdd:
//
//  Return (MMRESULT):
//
//  History:
//      06/25/94    fdy	    [frankye]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverGetInfo32
(
    PACMGARB		pag,
    DWORD		hadid32,
    LPSTR		lpstrAlias,
    LPACMDRIVERPROC	lpfnDriverProc,
    LPDWORD		lpdnDevNode,
    LPDWORD		lpfdwAdd
)
{
    MMRESULT mmr;

    DPF(5,"IDriverGetInfo32();");

#ifdef WIN4
    mmr = (MMRESULT) acmMessage32(acmThunkDriverGetInfo32,
				  (DWORD)hadid32,
				  (DWORD)lpstrAlias,
				  (DWORD)lpfnDriverProc,
				  (DWORD)lpdnDevNode,
				  (DWORD)lpfdwAdd);

#else
    mmr = (MMRESULT)(*pag->lpfnCallproc32W_6)(acmThunkDriverGetInfo32,
					      (DWORD)hadid32,
					      (DWORD)lpstrAlias,
					      (DWORD)lpfnDriverProc,
					      (DWORD)lpdnDevNode,
					      (DWORD)lpfdwAdd,
					      pag->lpvAcmThunkEntry,
					      0L,    // Don't map pointers
					      6L);
#endif

    return mmr;
}


//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverPriority32
//
//  Description:
//	16-bit side.
//
//  Arguments:
//	PACMGARB pag:
//
//      DWORD padid32:
//
//	DWORD dwPriority:
//
//	DWORD fdwPriority:
//
//  Return (MMRESULT):
//
//  History:
//      10/28/94    fdy	    [frankye]
//
//--------------------------------------------------------------------------;
MMRESULT FNGLOBAL IDriverPriority32
(
    PACMGARB	pag,
    DWORD       padid32,
    DWORD	dwPriority,
    DWORD	fdwPriority
)
{
    MMRESULT mmr;

    DPF(5,"IDriverPriority32();");

#ifdef WIN4
    mmr = (MMRESULT) acmMessage32(acmThunkDriverPriority32,
				  (DWORD)padid32,
				  (DWORD)dwPriority,
				  (DWORD)fdwPriority,
				  (DWORD)0,
				  (DWORD)0);

#else
    mmr = (MMRESULT)(*pag->lpfnCallproc32W_6)(acmThunkDriverPriority32,
					      (DWORD)padid32,
					      (DWORD)dwPriority,
					      (DWORD)fdwPriority,
					      (DWORD)0,
					      (DWORD)0,
					      pag->lpvAcmThunkEntry,
					      0L,    // Don't map pointers
					      6L);
#endif

    return mmr;
}


//--------------------------------------------------------------------------;
//
//  LRESULT IDriverMessageId32
//
//  Description:
//
//      Pass a message to a 32-bit driver using the driver id.
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      UINT uMsg:
//
//      LPARAM lParam1:
//
//      LPARAM lParam2:
//
//  Return (LRESULT):
//
//  History:
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL IDriverMessageId32
(
    DWORD               hadid,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
)
{
    LRESULT lr;

    DPF(5,"IDriverMessageId32();");

#ifdef WIN4
    lr = acmMessage32(acmThunkDriverMessageId32,
		      (DWORD)hadid,
		      (DWORD)uMsg,
		      (DWORD)lParam1,
		      (DWORD)lParam2,
		      (DWORD)0 );

#else
    {
        PACMGARB pag;

        pag = pagFind();
        lr = (LRESULT)(*pag->lpfnCallproc32W_6)(acmThunkDriverMessageId32,
					        (DWORD)hadid,
					        (DWORD)uMsg,
					        (DWORD)lParam1,
					        (DWORD)lParam2,
					        (DWORD) 0,
					        pag->lpvAcmThunkEntry,
					        0L,    // Don't map pointers
					        6L);
    }
#endif

    return lr;
}


//--------------------------------------------------------------------------;
//
//  LRESULT IDriverMessage32
//
//  Description:
//
//      Pass a message to a 32-bit driver using the instance handle.
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      UINT uMsg:
//
//      LPARAM lParam1:
//
//      LPARAM lParam2:
//
//  Return (LRESULT):
//
//  History:
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL IDriverMessage32
(
    DWORD               hadid,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
)
{
    LRESULT lr;

    DPF(5,"IDriverMessage32();");

#ifdef WIN4
    lr = acmMessage32(acmThunkDriverMessage32,
		      (DWORD)hadid,
		      (DWORD)uMsg,
		      (DWORD)lParam1,
		      (DWORD)lParam2,
		      (DWORD)0 );

#else
    {
        PACMGARB pag;

        pag = pagFind();
        lr = (LRESULT)(*pag->lpfnCallproc32W_6)(acmThunkDriverMessage32,
					        (DWORD)hadid,
					        (DWORD)uMsg,
					        (DWORD)lParam1,
					        (DWORD)lParam2,
					        (DWORD)0,
					        pag->lpvAcmThunkEntry,
					        0L,    // Don't map pointers
					        6L);
    }
#endif

    return (lr);

}

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverLoad32
//
//  Description:
//
//      Load a 32-bit ACM driver (actually just find its hadid)
//
//  Arguments:
//	DWORD hadid32:
//      DWORD  fdwFlags
//
//  Return (HDRVR):
//
//  History:
//
//--------------------------------------------------------------------------;
MMRESULT FNGLOBAL IDriverLoad32
(
    DWORD   hadid32,
    DWORD   fdwFlags
)
{
#ifdef WIN4
    MMRESULT mmr;

    DPF(5,"IDriverLoad(hadid32=%08lxh,fdwFlags=%08lxh);", hadid32, fdwFlags);

    mmr = (MMRESULT)acmMessage32(acmThunkDriverLoad32,
				 (DWORD)hadid32,
				 (DWORD)fdwFlags,
				 (DWORD)0L,
				 (DWORD)0L,
				 (DWORD)0L );

#else
    MMRESULT mmr;
    PACMGARB pag;

    DPF(5,"IDriverLoad(hadid32=%08lxh,fdwFlags=%08lxh);", hadid32, fdwFlags);

    pag = pagFind();
    mmr = (MMRESULT)(*pag->lpfnCallproc32W_6)(acmThunkDriverLoad32,
					      (DWORD)hadid32,
					      (DWORD)fdwFlags,
					      (DWORD)0L,
					      (DWORD)0L,
					      (DWORD)0L,
					      pag->lpvAcmThunkEntry,
					      0L,    // Don't map pointers
					      6L);

#endif

    return (mmr);
}

//--------------------------------------------------------------------------;
//
//  MMERESULT IDriverOpen32
//
//  Description:
//
//      Open a 32-bit ACM driver
//
//  Arguments:
//      LPHACMDRIVER lphadNew:
//
//      HACMDRIVERID hadid:
//
//      DWORD fdwOpen:
//
//  Return (MMRESULT):
//
//  History:
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IDriverOpen32
(
    LPDWORD             lphadNew,
    DWORD               hadid,
    DWORD               fdwOpen
)
{
    MMRESULT mmr;

    DPF(5,"IDriverOpen32();");

#ifdef WIN4
    mmr = (MMRESULT)acmMessage32(acmThunkDriverOpen32,
				 (DWORD)lphadNew,
				 (DWORD)hadid,
				 (DWORD)fdwOpen,
				 (DWORD)0L,
				 (DWORD)0L );

#else
    {
        PACMGARB pag;

        pag = pagFind();
        mmr = (MMRESULT)(*pag->lpfnCallproc32W_6)(acmThunkDriverOpen32,
						  (DWORD)lphadNew,
						  (DWORD)hadid,
						  (DWORD)fdwOpen,
						  (DWORD)0L,
						  (DWORD)0L,
						  pag->lpvAcmThunkEntry,
						  0L,    // Don't map pointers
						  6L);
    }
#endif

    return (mmr);

}

//--------------------------------------------------------------------------;
//
//  MMRESULT IDriverClose32
//
//  Description:
//
//      Cloase a 32-bit ACM driver
//
//  Arguments:
//      HDRVR hdrvr:
//
//      DWORD fdwClose:
//
//  Return (MMRESULT):
//
//  History:
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL IDriverClose32
(
    DWORD               hdrvr,
    DWORD               fdwClose
)
{
#ifdef WIN4
    LRESULT lr;

    DPF(5,"IDriverClose32();");

    lr = acmMessage32(acmThunkDriverClose32,
		      (DWORD)hdrvr,
		      (DWORD)fdwClose,
		      (DWORD)0L,
		      (DWORD)0L,
		      (DWORD)0L);

#else
    LRESULT lr;
    PACMGARB pag;

    DPF(5,"IDriverClose32();");

    pag = pagFind();
    lr = (LRESULT)(*pag->lpfnCallproc32W_6)(acmThunkDriverClose32,
					    (DWORD)hdrvr,
					    (DWORD)fdwClose,
					    (DWORD)0L,
					    (DWORD)0L,
					    (DWORD)0L,
					    pag->lpvAcmThunkEntry,
					    0L,    // Don't map pointers
					    6L);

#endif

    return (lr);

}


#endif // !WIN32

#endif // !_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\acmdrvr.c ===
/****************************************************************************
 *
 *   acmdrvr.c
 *
 *   Copyright (c) 1991-1999 Microsoft Corporation
 *
 *   This module provides ACM driver add/remove/enumeration
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include "msacm.h"
#include "msacmdrv.h"
#include <stdlib.h>
#include "acmi.h"
#include "uchelp.h"
#include "debug.h"


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmDriverID | Returns the handle to an Audio Compression
 *      Manager (ACM) driver identifier associated with an open ACM driver
 *      instance or stream handle. <t HACMOBJ> is the handle to an ACM
 *      object, such as an open <t HACMDRIVER> or <t HACMSTREAM>.
 *
 *  @parm HACMOBJ | hao | Specifies the open driver instance or stream
 *      handle.
 *
 *  @parm LPHACMDRIVERID | phadid | Specifies a pointer to an <t HACMDRIVERID>
 *      handle. This location is filled with a handle identifying the
 *      installed driver that is associated with the <p hao>.
 *
 *  @parm DWORD | fdwDriverID | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *  @xref <f acmDriverDetails> <f acmDriverOpen>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmDriverID
(
    HACMOBJ                 hao,
    LPHACMDRIVERID          phadid,
    DWORD                   fdwDriverID
)
{
    V_HANDLE(hao, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);
    V_WPOINTER(phadid, sizeof(HACMDRIVERID), MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwDriverID, ACM_DRIVERIDF_VALID, acmDriverID, MMSYSERR_INVALFLAG);

    switch (*(UINT *)hao)
    {
        case TYPE_HACMDRIVERID:
            V_HANDLE(hao, TYPE_HACMDRIVERID, MMSYSERR_INVALPARAM);

            *phadid = (HACMDRIVERID)hao;
            break;

        case TYPE_HACMDRIVER:
            V_HANDLE(hao, TYPE_HACMDRIVER, MMSYSERR_INVALPARAM);

            *phadid = ((PACMDRIVER)hao)->hadid;
            break;

        case TYPE_HACMSTREAM:
            V_HANDLE(hao, TYPE_HACMSTREAM, MMSYSERR_INVALPARAM);

            *phadid = ((PACMDRIVER)((PACMSTREAM)hao)->had)->hadid;
            break;

        default:
            return (MMSYSERR_INVALPARAM);
    }

    return (MMSYSERR_NOERROR);
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api LRESULT CALLBACK | acmDriverProc | The <f acmDriverProc> function
 *      is a placeholder for an application-defined function name, and refers to the
 *      callback function used with the ACM. The actual name
 *      must be exported by including it in the module-deefinition file of the
 *      executable or DLL.
 *
 *  @parm DWORD | dwID | Specifies an identifier of the installable ACM
 *      driver.
 *
 *  @parm HDRIVER | hdrvr | Identifies the installable ACM driver. This
 *      argument is a unique handle the ACM assigns to the driver.
 *
 *  @parm UINT | uMsg | Specifies an ACM driver message.
 *
 *  @parm LPARAM | lParam1 | Specifies the first message parameter.
 *
 *  @parm LPARAM | lParam2 | Specifies the second message parameter.
 *
 *  @xref <f acmDriverAdd> <f acmDriverRemove> <f acmDriverDetails>
 *      <f acmDriverOpen> <f DriverProc>
 *
 ***************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmDriverAdd | Adds a driver to the list of available
 *      Audio Compression Manager (ACM) drivers. The driver type and
 *      location are dependent on the <p fdwAdd> flags. Once a driver is
 *      successfully added, the driver entry function will receive ACM
 *      driver messages.
 *
 *  @parm LPHACMDRIVERID | phadid | Specifies a pointer to an <t HACMDRIVERID>
 *      handle. This location is filled with a handle identifying the
 *      installed driver. Use the handle to identify the driver when
 *      calling other ACM functions.
 *
 *  @parm HINSTANCE | hinstModule | Identifies the instance of the module
 *      whose executable or dynamic link library (DLL) contains the driver
 *      entry function.
 *
 *  @parm LPARAM | lParam | <p lParam> is a handle to an installable driver
 *      or a driver function address, depending on the <p fdwAdd> flags.
 *
 *  @parm DWORD | dwPriority | This parameter is currently only used with
 *      the ACM_DRIVERADDF_NOTIFYHWND flag to specify the window message
 *      to send for notification broadcasts. All other flags require that
 *      this member be set to zero.
 *
 *  @parm DWORD | fdwAdd | Specifies flags for adding ACM drivers.
 *
 *      @flag ACM_DRIVERADDF_GLOBAL | Specifies if the driver can be used
 *      by any application in the system. This flag may not be used with
 *      functions contained in executables.
 *
 *      @flag ACM_DRIVERADDF_FUNCTION | Specifies that <p lParam> is a driver
 *      function address conforming to the <f acmDriverProc> prototype. The
 *      function may reside in either an executable or a DLL. If the
 *      ACM_DRIVERADDF_GLOBAL flag is specified, then the function must
 *      reside in a .DLL.
 *
 *      @flag ACM_DRIVERADDF_NOTIFYHWND | Specifies that <p lParam> is a
 *      notification window handle to receive messages when changes to
 *      global driver priorities and states are made. The window message
 *      to receive is defined by the application and must be passed in
 *      the <p dwPriority> argument. The <p wParam> and <p lParam> arguments
 *      passed with the window message are reserved for future use and
 *      should be ignored. The ACM_DRIVERADDF_GLOBAL flag cannot be
 *      specified in conjunction with the ACM_DRIVERADDF_NOTIFYHWND flag.
 *      See the description for <f acmDriverPriority> for more information
 *      on driver priorities.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed is invalid.
 *
 *      @flag MMSYSERR_NOMEM | Unable to allocate resources.
 *
 *  @comm If the ACM_DRIVERADDF_GLOBAL flag is not set, only the current
 *      task when the driver entry is added will be able to use it. Global
 *      drivers that are added as functions must reside in a DLL.
 *
 *  @xref <f acmDriverProc> <f acmDriverRemove> <f acmDriverDetails>
 *      <f acmDriverOpen>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmDriverAdd
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam,
    DWORD                   dwPriority,
    DWORD                   fdwAdd
)
{
    PACMGARB                pag;
    MMRESULT                mmr;
    PACMDRIVERID            padid;
    BOOL                    fIsNotify;
    BOOL                    fIsLocal;

    V_WPOINTER(phadid, sizeof(HACMDRIVERID), MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwAdd, ACM_DRIVERADDF_VALID, acmDriverAdd, MMSYSERR_INVALFLAG);

    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmDriverAdd: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }
    

    if (threadQueryInListShared(pag))
    {
	return (ACMERR_NOTPOSSIBLE);
    }
    ENTER_LIST_EXCLUSIVE;
    mmr = IDriverAdd(pag, phadid, hinstModule, lParam, dwPriority, fdwAdd);
    LEAVE_LIST_EXCLUSIVE;

    if( MMSYSERR_NOERROR != mmr )
        return mmr;


    //
    //  if deferred broadcast is not enabled, then do a change broadcast
    //
    //  do NOT refresh global cache for local and notification handles
    //
    padid     = (PACMDRIVERID)(*phadid);
    fIsNotify = (0 != (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver));
    fIsLocal  = (0 != (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver));

    if( !fIsLocal && !fIsNotify )
    {
        IDriverRefreshPriority( pag );
        if( !IDriverLockPriority( pag,
                                  GetCurrentTask(),
                                  ACMPRIOLOCK_ISLOCKED ) )
        {
            IDriverPrioritiesSave( pag );
            IDriverBroadcastNotify( pag );
        }
    }

    return MMSYSERR_NOERROR;
}


#ifdef WIN32
#if TRUE    // defined(UNICODE)
MMRESULT ACMAPI acmDriverAddA
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam,
    DWORD                   dwPriority,
    DWORD                   fdwAdd
)
{
    WCHAR               szAlias[MAX_DRIVER_NAME_CHARS];


    if (ACM_DRIVERADDF_NAME == (ACM_DRIVERADDF_TYPEMASK & fdwAdd))
    {
        szAlias[0] = L'\0';     // Init to emptry string in case Imbstowcs fails

	Imbstowcs(szAlias, (LPSTR)lParam, SIZEOF(szAlias));

        lParam = (LPARAM)szAlias;
    }

    return acmDriverAdd( phadid, hinstModule, lParam, dwPriority, fdwAdd );
}
#else
MMRESULT ACMAPI acmDriverAddW
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam,
    DWORD                   dwPriority,
    DWORD                   fdwAdd
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmDriverRemove | Removes an Audio Compression Manager
 *      (ACM) driver from the list of available ACM drivers.
 *
 *  @parm HACMDRIVERID | hadid | Handle to the driver identifier to be
 *      removed.
 *
 *  @parm DWORD | fdwRemove | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag ACMERR_BUSY | The driver is in use and cannot be removed.
 *
 *  @xref <f acmDriverAdd>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmDriverRemove
(
    HACMDRIVERID            hadid,
    DWORD                   fdwRemove
)
{
    PACMGARB                pag;
    MMRESULT                mmr;
    PACMDRIVERID            padid;
    BOOL                    fIsNotify;
    BOOL                    fIsLocal;

    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmDriverRemove: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }
    
    V_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);
    V_DFLAGS(fdwRemove, ACM_DRIVERREMOVEF_VALID, acmDriverRemove, MMSYSERR_INVALFLAG);


    padid     = (PACMDRIVERID)hadid;

    fIsNotify = (0 != (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver));
    fIsLocal  = (0 != (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver));


    if (threadQueryInListShared(pag))
    {
	return (ACMERR_NOTPOSSIBLE);
    }
    ENTER_LIST_EXCLUSIVE;
    mmr = IDriverRemove( hadid, fdwRemove );
    LEAVE_LIST_EXCLUSIVE;

    if( MMSYSERR_NOERROR != mmr )
        return mmr;


    //
    //  if deferred broadcast is not enabled, then do a change broadcast
    //
    //  do NOT refresh global cache for local and notification handles
    //
    if( !fIsLocal && !fIsNotify )
    {
        IDriverRefreshPriority( pag );
        if( !IDriverLockPriority( pag,
                                  GetCurrentTask(),
                                  ACMPRIOLOCK_ISLOCKED ) )
        {
            IDriverPrioritiesSave( pag );
            IDriverBroadcastNotify( pag );
        }
    }

    return MMSYSERR_NOERROR;
}



/****************************************************************************
 *
 *  @doc EXTERNAL ACM_API
 *
 *  @api BOOL ACMDRIVERENUMCB | acmDriverEnumCallback | The
 *      <f acmDriverEnumCallback> function is a placeholder for an
 *      application-defined function name, and refers to the callback function
 *     used with <f acmDriverEnum>.
 *
 *  @parm HACMDRIVERID | hadid | Specifies an ACM driver identifier.
 *
 *  @parm DWORD | dwInstance | Specifies the application-defined value
 *      specified in the <f acmDriverEnum> function.
 *
 *  @parm DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the driver identifier <p hadid>. These flags are identical to the
 *      <e ACMDRIVERDETAILS.fdwSupport> flags of the <t ACMDRIVERDETAILS>
 *      structure. This argument can be a combination of the following
 *      values:
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags. For example,
 *      if a driver supports compression from WAVE_FORMAT_PCM to
 *      WAVE_FORMAT_ADPCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      same format tag. For example, if a driver supports resampling of
 *      WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes). For example, if a driver supports volume
 *      or echo operations on WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_DISABLED | Specifies that this
 *      driver has been disabled. An application must specify the
 *      ACM_DRIVERENUMF_DISABLED to the <f acmDriverEnum> function to
 *      include disabled drivers in the enumeration.
 *
 *  @rdesc The callback function must return TRUE to continue enumeration;
 *      to stop enumeration, it must return FALSE.
 *
 *  @comm The <f acmDriverEnum> function will return MMSYSERR_NOERROR (zero)
 *      if no ACM drivers are installed. Moreover, the callback function will
 *      not be called.
 *
 *  @xref <f acmDriverEnum> <f acmDriverDetails> <f acmDriverOpen>
 *
 ***************************************************************************/


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmDriverEnum | The <f acmDriverEnum> function enumerates
 *      the available Audio Compression Manager (ACM) drivers, continuing
 *      until there are no more ACM drivers or the callback function returns FALSE.
 *
 *  @parm ACMDRIVERENUMCB | fnCallback | Specifies the procedure-instance
 *      address of the application-defined callback function. The callback
 *      address must be created by the <f MakeProcInstance> function, or
 *      the callback function must contain the proper prolog and epilog code
 *      for callbacks.
 *
 *  @parm DWORD | dwInstance | Specifies a 32-bit application-defined value
 *      that is passed to the callback function along with ACM driver
 *      information.
 *
 *  @parm DWORD | fdwEnum | Specifies flags for enumerating ACM drivers.
 *
 *      @flag ACM_DRIVERENUMF_DISABLED | Specifies that disabled ACM drivers
 *      should be included in the enumeration. Drivers can be disabled
 *      through the Sound Mapper Control Panel option. If a driver is
 *      disabled, the <p fdwSupport> argument to the callback function will
 *      have the ACMDRIVERDETAILS_SUPPORTF_DISABLED flag set.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *  @comm The <f acmDriverEnum> function will return MMSYSERR_NOERROR (zero)
 *      if no ACM drivers are installed. Moreover, the callback function will
 *      not be called.
 *
 *  @xref <f acmDriverEnumCallback> <f acmDriverDetails> <f acmDriverOpen>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmDriverEnum
(
    ACMDRIVERENUMCB         fnCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwEnum
)
{
    PACMGARB	    pag;
    MMRESULT        mmr;
    HACMDRIVERID    hadid;
    BOOL            f;
    DWORD           fdwSupport;
    HTASK           htask;

    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmDriverEnum: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }
    
    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwEnum, ACM_DRIVERENUMF_VALID, acmDriverEnum, MMSYSERR_INVALFLAG);


    //
    //  If we don't have it locked, then update the priorities from the
    //  INI file before changing anything.  The GETLOCK call will fail
    //  if we already have it locked...
    //
    if (!threadQueryInListShared(pag))
    {
	htask = GetCurrentTask();
	if( !IDriverLockPriority( pag, htask, ACMPRIOLOCK_ISLOCKED ) )
	{
	    ENTER_LIST_EXCLUSIVE;
            if( IDriverPrioritiesRestore(pag) ) {   // Something changed!
                IDriverBroadcastNotify( pag );      
            }
	    LEAVE_LIST_EXCLUSIVE;
	}
    }


    hadid = NULL;

    ENTER_LIST_SHARED;

    while (!IDriverGetNext(pag, &hadid, hadid, fdwEnum))
    {
        mmr = IDriverSupport(hadid, &fdwSupport, TRUE);
        if (MMSYSERR_NOERROR != mmr)
        {
            continue;
        }

        //
        //  do the callback--if the client returns FALSE we need to
        //  terminate the enumeration process...
        //
        f = (* fnCallback)(hadid, dwInstance, fdwSupport);
        if (FALSE == f)
            break;
    }

    LEAVE_LIST_SHARED;

    return (MMSYSERR_NOERROR);
}


/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @types ACMDRIVERDETAILS | The <t ACMDRIVERDETAILS> structure describes
 *      various details of an Audio Compression Manager (ACM) driver.
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes,  of the valid
 *      information contained in the <t ACMDRIVERDETAILS> structure.
 *      An application should initialize this member to the size, in bytes, of
 *      the desired information. The size specified in this member must be
 *      large enough to contain the <e ACMDRIVERDETAILS.cbStruct> member of
 *      the <t ACMDRIVERDETAILS> structure. When the <f acmDriverDetails>
 *      function returns, this member contains the actual size of the
 *      information returned. The returned information will never exceed
 *      the requested size.
 *
 *  @field FOURCC | fccType | Specifies the type of the driver. For ACM drivers, set
 *      this member  to <p audc>, which represents ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC.
 *
 *  @field FOURCC | fccComp | Specifies the sub-type of the driver. This
 *      member is currently set to ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (zero).
 *
 *  @field WORD | wMid | Specifies a manufacturer ID for the ACM driver.
 *
 *  @field WORD | wPid | Specifies a product ID for the ACM driver.
 *
 *  @field DWORD | vdwACM | Specifies the version of the ACM for which
 *      this driver was compiled. The version number is a hexadecimal number
 *      in the format 0xAABBCCCC, where AA is the major version number,
 *      BB is the minor version number, and CCCC is the build number.
 *      Note that the version parts (major, minor, and build) should be
 *      displayed as decimal numbers.
 *
 *  @field DWORD | vdwDriver | Specifies the version of the driver.
 *      The version number is a hexadecimal number in the format 0xAABBCCCC, where
 *      AA is the major version number, BB is the minor version number,
 *      and CCCC is the build number. Note that the version parts (major,
 *      minor, and build) should be displayed as decimal numbers.
 *
 *  @field DWORD | fdwSupport | Specifies support flags for the driver.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags. For example,
 *      if a driver supports compression from WAVE_FORMAT_PCM to
 *      WAVE_FORMAT_ADPCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      same format tag. For example, if a driver supports resampling of
 *      WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes). For example, if a driver supports volume
 *      or echo operations on WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output through a waveform device. An
 *      application should use <f acmMetrics> with the
 *      ACM_METRIC_HARDWARE_WAVE_INPUT and ACM_METRIC_HARDWARE_WAVE_OUTPUT
 *      metric indexes to get the waveform device identifiers associated with
 *      the supporting ACM driver.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_DISABLED | Specifies that this driver
 *      has been disabled. This flag is set by the ACM for a driver when
 *      it has been disabled for any of a number of reasons. Disabled
 *      drivers cannot be opened and can only be used under very limited
 *      circumstances.
 *
 *  @field DWORD | cFormatTags | Specifies the number of unique format tags
 *      supported by this driver.
 *
 *  @field DWORD | cFilterTags | Specifies the number of unique filter tags
 *      supported by this driver.
 *
 *  @field HICON | hicon | Specifies an optional handle to a custom icon for
 *      this driver. An application can use this icon for referencing the
 *      driver visually. This member can be NULL.
 *
 *  @field char | szShortName[ACMDRIVERDETAILS_SHORTNAME_CHARS] | Specifies
 *      a NULL-terminated string that describes the name of the driver. This
 *      string is intended to be displayed in small spaces.
 *
 *  @field char | szLongName[ACMDRIVERDETAILS_LONGNAME_CHARS] | Specifies a
 *      NULL-terminated string that describes the full name of the driver.
 *      This string is intended to be displayed in large (descriptive)
 *      spaces.
 *
 *  @field char | szCopyright[ACMDRIVERDETAILS_COPYRIGHT_CHARS] | Specifies
 *      a NULL-terminated string that provides copyright information for the
 *      driver.
 *
 *  @field char | szLicensing[ACMDRIVERDETAILS_LICENSING_CHARS] | Specifies a
 *      NULL-terminated string that provides special licensing information
 *      for the driver.
 *
 *  @field char | szFeatures[ACMDRIVERDETAILS_FEATURES_CHARS] | Specifies a
 *      NULL-terminated string that provides special feature information for
 *      the driver.
 *
 *  @xref <f acmDriverDetails>
 *
 ****************************************************************************/


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmDriverDetails | This function queries a specified
 *      Audio Compression Manager (ACM) driver to determine its capabilities.
 *
 *  @parm HACMDRIVERID | hadid | Handle to the driver identifier of an
 *      installed ACM driver. Disabled drivers can be queried for details.
 *
 *  @parm LPACMDRIVERDETAILS | padd | Pointer to an <t ACMDRIVERDETAILS>
 *      structure that will receive the driver details. The
 *      <e ACMDRIVERDETAILS.cbStruct> member must be initialized to the
 *      size, in bytes,  of the structure.
 *
 *  @parm DWORD | fdwDetails | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *  @xref <f acmDriverAdd> <f acmDriverEnum> <f acmDriverID>
 *      <f acmDriverOpen>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmDriverDetails
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILS      padd,
    DWORD                   fdwDetails
)
{
    //
    //  note that we allow both HACMDRIVERID's and HACMDRIVER's
    //
    V_HANDLE(hadid, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);
    if (TYPE_HACMDRIVER == ((PACMDRIVERID)hadid)->uHandleType)
    {
        hadid = ((PACMDRIVER)hadid)->hadid;
    }
    V_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);
    V_WPOINTER(padd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(DWORD) > padd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmDriverDetails: cbStruct must be >= sizeof(DWORD).");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(padd, padd->cbStruct, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwDetails, ACM_DRIVERDETAILSF_VALID, acmDriverDetails, MMSYSERR_INVALFLAG);

    return (IDriverDetails(hadid, padd, fdwDetails));
}

#ifdef WIN32
#if TRUE    // defined(UNICODE)
MMRESULT ACMAPI acmDriverDetailsA
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILSA     padd,
    DWORD                   fdwDetails
)
{
    MMRESULT            mmr;
    LPACMDRIVERDETAILSA paddA;
    LPACMDRIVERDETAILSW paddW;

    V_WPOINTER(padd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(DWORD) > padd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmDriverDetails: cbStruct must be >= sizeof(DWORD).");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(padd, padd->cbStruct, MMSYSERR_INVALPARAM);

    paddA = (LPACMDRIVERDETAILSA)GlobalAlloc(GPTR, sizeof(*paddA));
    if (NULL == paddA)
    {
	return(MMSYSERR_NOMEM);
    }
    paddW = (LPACMDRIVERDETAILSW)GlobalAlloc(GPTR, sizeof(*paddW));
    if (NULL == paddW)
    {
	GlobalFree((HGLOBAL)paddA);
	return(MMSYSERR_NOMEM);
    }

    paddW->cbStruct = sizeof(ACMDRIVERDETAILSW);

    mmr = acmDriverDetailsW(hadid, paddW, fdwDetails);
    if (MMSYSERR_NOERROR == mmr)
    {
        memcpy(paddA, paddW, FIELD_OFFSET(ACMDRIVERDETAILSA, szShortName[0]));

        if (padd->cbStruct > (DWORD)FIELD_OFFSET(ACMDRIVERDETAILSA, szShortName[0]))
        {
            Iwcstombs(paddA->szShortName, paddW->szShortName, sizeof(paddA->szShortName));
            Iwcstombs(paddA->szLongName,  paddW->szLongName,  sizeof(paddA->szLongName));
            Iwcstombs(paddA->szCopyright, paddW->szCopyright, sizeof(paddA->szCopyright));
            Iwcstombs(paddA->szLicensing, paddW->szLicensing, sizeof(paddA->szLicensing));
            Iwcstombs(paddA->szFeatures,  paddW->szFeatures,  sizeof(paddA->szFeatures));
        }

        padd->cbStruct = min(padd->cbStruct, sizeof(*paddA));
        memcpy(&padd->fccType,
               &paddA->fccType,
               padd->cbStruct - FIELD_OFFSET(ACMDRIVERDETAILSA, fccType));
    }

    GlobalFree((HGLOBAL)paddW);
    GlobalFree((HGLOBAL)paddA);

    return (mmr);
}
#else
MMRESULT ACMAPI acmDriverDetailsW
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILSW     padd,
    DWORD                   fdwDetails
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmDriverPriority | This function modifies the priority
 *      and state of an Audio Compression Manager (ACM) driver.
 *
 *  @parm HACMDRIVERID | hadid | Handle to the driver identifier of an
 *      installed ACM driver. This argument must be NULL when specifying
 *      the ACM_DRIVERPRIORITYF_BEGIN and ACM_DRIVERPRIORITYF_END flags.
 *
 *  @parm DWORD | dwPriority | Specifies the new priority for a global
 *      ACM driver identifier. A zero value specifies that the priority of
 *      the driver identifier should remain unchanged. A value of one (1)
 *      specifies that the driver should be placed as the highest search
 *      priority driver. A value of (DWORD)-1 specifies that the driver
 *      should be placed as the lowest search priority driver. Priorities
 *      are only used for global drivers.
 *
 *  @parm DWORD | fdwPriority | Specifies flags for setting priorities of
 *      ACM drivers.
 *
 *      @flag ACM_DRIVERPRIORITYF_ENABLE | Specifies that the ACM driver
 *      should be enabled if it is currently disabled. Enabling an already
 *      enabled driver does nothing.
 *
 *      @flag ACM_DRIVERPRIORITYF_DISABLE | Specifies that the ACM driver
 *      should be disabled if it is currently enabled. Disabling an already
 *      disabled driver does nothing.
 *
 *      @flag ACM_DRIVERPRIORITYF_BEGIN | Specifies that the calling task
 *      wants to defer change notification broadcasts. An application must
 *      take care to reenable notification broadcasts as soon as possible
 *      with the ACM_DRIVERPRIORITYF_END flag. Note that <p hadid> must be
 *      NULL, <p dwPriority> must be zero, and only the
 *      ACM_DRIVERPRIORITYF_BEGIN flag can be set.
 *
 *      @flag ACM_DRIVERPRIORITYF_END | Specifies that the calling task
 *      wants to reenable change notification broadcasts. An application
 *      must call <f acmDriverPriority> with ACM_DRIVERPRIORITYF_END for
 *      each successful call with the ACM_DRIVERPRIORITYF_BEGIN flag. Note
 *      that <p hadid> must be NULL, <p dwPriority> must be zero, and only
 *      the ACM_DRIVERPRIORITYF_END flag can be set.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_ALLOCATED | Returned if the deferred broadcast lock
 *      is owned by a different task.
 *
 *      @flag MMSYSERR_NOTSUPPORTED | The requested operation is not
 *      supported for the specified driver. For example, local and notify
 *      driver identifiers do not support priorities (but can be enabled
 *      and disabled). This error will therefore be returned if an
 *      application specifies a non-zero <p dwPriority> for a local and
 *      notify driver identifiers.
 *
 *  @comm All driver identifiers can be enabled and disabled; this includes
 *      global, local and notification driver identifiers.
 *
 *      If more than one global driver identifier needs to be enabled,
 *      disabled or shifted in priority, then an application should defer
 *      change notification broadcasts using the ACM_DRIVERPRIORITYF_BEGIN
 *      flag. A single change notification will be broadcast when the
 *      ACM_DRIVERPRIORITYF_END flag is specified.
 *
 *      An application can use the <f acmMetrics> function with the
 *      ACM_METRIC_DRIVER_PRIORITY metric index to retrieve the current
 *      priority of a global driver. Also note that drivers are always
 *      enumerated from highest to lowest priority by the <f acmDriverEnum>
 *      function.
 *
 *      All enabled driver identifiers will receive change notifications.
 *      An application can register a notification message using the
 *      <f acmDriverAdd> function in conjunction with the
 *      ACM_DRIVERADDF_NOTIFYHWND flag. Note that changes to non-global
 *      driver identifiers will not be broadcast.
 *
 *      Note that global priorities are simply used for the search order
 *      when an application does not specify a driver. Boosting the
 *      priority of a driver will have no effect on the performance of
 *      a driver.
 *
 *  @xref <f acmDriverAdd> <f acmDriverEnum> <f acmDriverDetails>
 *      <f acmMetrics>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmDriverPriority
(
    HACMDRIVERID            hadid,
    DWORD                   dwPriority,
    DWORD                   fdwPriority
)
{
    PACMGARB                pag;
    MMRESULT                mmr;
    HTASK                   htask;
    PACMDRIVERID            padid;
    DWORD                   fdwDeferred;
    BOOL                    fIsNotify;
    BOOL                    fIsLocal;
    DWORD                   cTotalGlobal;
    BOOL                    fSucceeded;


    DPF(2, "acmDriverPriorities: prio %ld f %.08Xh ", dwPriority, fdwPriority);


    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmDriverPriority: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }

    //
    //	If this thread already has a shared lock on the driver list, then
    //	we can't do much with priorities, so we'll just bail in that case.
    //
    if (threadQueryInListShared(pag))
    {
	return ACMERR_NOTPOSSIBLE;
    }


    htask = GetCurrentTask();

    //
    //  Validate the flags.
    //
    V_DFLAGS(fdwPriority, ACM_DRIVERPRIORITYF_VALID, acmDriverPriority, MMSYSERR_INVALFLAG);


    //
    //  Make sure that we are allowed to access the list.
    //
    if( !IDriverLockPriority( pag, htask, ACMPRIOLOCK_LOCKISOK ) )
    {
        DebugErr(DBF_WARNING, "acmDriverPriority: deferred lock owned by different task.");
        return (MMSYSERR_ALLOCATED);
    }


    //
    //  If we don't have it locked, then update the priorities from the
    //  INI file before changing anything.  The GETLOCK call will fail
    //  if we already have it locked...
    //
	if( !IDriverLockPriority( pag, htask, ACMPRIOLOCK_ISLOCKED ) )
    {
	ENTER_LIST_EXCLUSIVE;
        if( IDriverPrioritiesRestore(pag) ) {   // Something changed!
            IDriverBroadcastNotify( pag );      
        }
	LEAVE_LIST_EXCLUSIVE;
    }


    //
    //  If hadid is NULL, then they are requesting a lock on the priorities
    //  list.  On the BEGIN flag, give them the lock.  On the END flag,
    //  unlock the list and broadcast the new priorities.
    //
    if (NULL == hadid)
    {
        fdwDeferred = (ACM_DRIVERPRIORITYF_DEFERMASK & fdwPriority);

        switch (fdwDeferred)
        {
            case ACM_DRIVERPRIORITYF_BEGIN:
                fSucceeded = IDriverLockPriority( pag,
                                                  htask,
                                                  ACMPRIOLOCK_GETLOCK );
                if( !fSucceeded )
                {
                    DebugErr(DBF_WARNING, "acmDriverPriority: deferred lock already owned.");
                    return (MMSYSERR_ALLOCATED);
                }
                return (MMSYSERR_NOERROR);

            case ACM_DRIVERPRIORITYF_END:
                fSucceeded = IDriverLockPriority( pag,
                                                  htask,
                                                  ACMPRIOLOCK_RELEASELOCK );
                if( !fSucceeded )
                {
                    DebugErr(DBF_ERROR, "acmDriverPriority: deferred lock unowned.");
                    return (MMSYSERR_ALLOCATED);
                }

                //
                //  We don't need to refresh the priorities first, because
                //  they are refreshed (below) every time a change is made,
                //  even if the priorities lock is set.
                //
                IDriverPrioritiesSave( pag );
                IDriverBroadcastNotify( pag );
                return (MMSYSERR_NOERROR);
        }

        DebugErr(DBF_ERROR, "acmDriverPriority: deferred flag must be specified with NULL hadid.");
        return (MMSYSERR_INVALFLAG);
    }


    //
    //  Validate the hadid.
    //
    V_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

    padid = (PACMDRIVERID)hadid;


    //
    //  Check the type of handle...
    //
    fIsNotify = (0 != (ACMDRIVERID_DRIVERF_NOTIFY & padid->fdwDriver));
    fIsLocal  = (0 != (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver));

    if (0L != dwPriority)
    {
        if (fIsNotify)
        {
            DebugErr(DBF_ERROR, "acmDriverPriority(): notification handles have no priority.");
            return (MMSYSERR_NOTSUPPORTED);
        }

        if (fIsLocal)
        {
            DebugErr(DBF_ERROR, "acmDriverPriority(): local drivers have no priority.");
            return (MMSYSERR_NOTSUPPORTED);
        }
    }


    //
    //  Check that the requested priority is in range.  dwPriority == -1
    //  means that we add it on the end, so that's OK.  0 means that we don't
    //  change the priority at all.
    //
    if( ((DWORD)-1L) != dwPriority  &&  0L != dwPriority )
    {
        cTotalGlobal = IDriverCountGlobal( pag );
        if( dwPriority > cTotalGlobal )
        {
            DebugErr1(DBF_ERROR, "acmDriverPriority(): priority value %lu out of range.", dwPriority);
            return (MMSYSERR_INVALPARAM);
        }
    }


    //
    //  Change the priority!
    //
    ENTER_LIST_EXCLUSIVE;
    mmr = IDriverPriority( pag, padid, dwPriority, fdwPriority );
    LEAVE_LIST_EXCLUSIVE;

    if( MMSYSERR_NOERROR != mmr )
        return mmr;


    //
    //  if deferred broadcast is not enabled, then do a change broadcast
    //
    //  do NOT refresh global cache for local and notification handles
    //
    if( !fIsLocal && !fIsNotify )
    {
        IDriverRefreshPriority( pag );
        if( !IDriverLockPriority( pag, htask, ACMPRIOLOCK_ISLOCKED ) )
        {
            IDriverPrioritiesSave( pag );
            IDriverBroadcastNotify( pag );
        }
    }

    return MMSYSERR_NOERROR;
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmDriverOpen | This function opens the specified Audio
 *      Compression Manager (ACM) driver and returns a driver-instance handle
 *      that can be used to communicate with the driver.
 *
 *  @parm LPHACMDRIVER | phad | Specifies a pointer to a <t HACMDRIVER>
 *      handle that will receive the new driver instance handle that can
 *      be used to communicate with the driver.
 *
 *  @parm HACMDRIVERID | hadid | Handle to the driver identifier of an
 *      installed and enabled ACM driver.
 *
 *  @parm DWORD | fdwOpen | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_NOTENABLED | The driver is not enabled.
 *
 *      @flag MMSYSERR_NOMEM | Unable to allocate resources.
 *
 *  @xref <f acmDriverAdd> <f acmDriverEnum> <f acmDriverID>
 *      <f acmDriverClose>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmDriverOpen
(
    LPHACMDRIVER            phad,
    HACMDRIVERID            hadid,
    DWORD                   fdwOpen
)
{
    MMRESULT mmr;

    V_WPOINTER(phad, sizeof(HACMDRIVER), MMSYSERR_INVALPARAM);
    *phad = NULL;
    V_HANDLE(hadid, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);
    V_DFLAGS(fdwOpen, ACM_DRIVEROPENF_VALID, acmDriverOpen, MMSYSERR_INVALFLAG);

    EnterHandle(hadid);
    mmr = IDriverOpen(phad, hadid, fdwOpen);
    LeaveHandle(hadid);

    return mmr;
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmDriverClose | Closes a previously opened Audio
 *      Compression Manager (ACM) driver instance. If the function is
 *      successful, the handle is invalidated.
 *
 *  @parm HACMDRIVER | had | Identifies the open driver instance to be
 *      closed.
 *
 *  @parm DWORD | fdwClose | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag ACMERR_BUSY | The driver is in use and cannot be closed.
 *
 *  @xref <f acmDriverOpen>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmDriverClose
(
    HACMDRIVER              had,
    DWORD                   fdwClose
)
{
    MMRESULT     mmr;
#ifdef WIN32
    HACMDRIVERID hadid;
#endif // WIN32

    V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
    V_DFLAGS(fdwClose, ACM_DRIVERCLOSEF_VALID, acmDriverClose, MMSYSERR_INVALFLAG);

#ifdef WIN32
    hadid = ((PACMDRIVER)had)->hadid;
#endif // WIN32
    EnterHandle(hadid);
    mmr = IDriverClose(had, fdwClose);
    LeaveHandle(hadid);

    return mmr;
}


/*****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api LRESULT | acmDriverMessage | This function sends a user-defined
 *      message to a given Audio Compression Manager (ACM) driver instance.
 *
 *  @parm HACMDRIVER | had | Specifies the ACM driver instance to which the
 *      message will be sent.
 *
 *  @parm UINT | uMsg | Specifies the message that the ACM driver must
 *      process. This message must be in the <m ACMDM_USER> message range
 *      (above or equal to <m ACMDM_USER> and less than
 *      <m ACMDM_RESERVED_LOW>). The exception to this restriction is
 *      the <m ACMDM_DRIVER_ABOUT> message.
 *
 *  @parm LPARAM | lParam1 | Specifies the first message parameter.
 *
 *  @parm LPARAM | lParam2 | Specifies the second message parameter.
 *
 *  @rdesc The return value is specific to the user-defined ACM driver
 *      message <p uMsg> sent. However, the following return values are
 *      possible:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | <p uMsg> is not in the ACMDM_USER range.
 *
 *      @flag MMSYSERR_NOTSUPPORTED | The ACM driver did not process the
 *      message.
 *
 *  @comm The <f acmDriverMessage> function is provided to allow ACM driver-
 *      specific messages to be sent to an ACM driver. The messages that
 *      can be sent through this function must be above or equal to the
 *      <m ACMDM_USER> message and less than <m ACMDM_RESERVED_LOW>. The
 *      exceptions to this restriction are the <m ACMDM_DRIVER_ABOUT>,
 *      <m DRV_QUERYCONFIGURE> and <m DRV_CONFIGURE> messages.
 *
 *      To display a custom About dialog box from an ACM driver,an application
 *      must send the <m ACMDM_DRIVER_ABOUT> message to the
 *      driver. The <p lParam1> argument should be the handle of the
 *      owner window for the custom about box; <p lParam2> must be set to
 *      zero. If the driver does not support a custom about box, then
 *      MMSYSERR_NOTSUPPORTED will be returned and it is up to the calling
 *      application to display its own dialog box. For example, the
 *      Control Panel Sound Mapper option will display a default about
 *      box based on the <t ACMDRIVERDETAILS> structure when an ACM driver
 *      returns MMSYSERR_NOTSUPPORTED. An application can query a driver
 *      for custom about box support without the dialog box being displayed
 *      by setting <p lParam1> to -1L. If the driver supports a custom
 *      about box, then MMSYSERR_NOERROR will be returned. Otherwise,
 *      the return value is MMSYSERR_NOTSUPPORTED.
 *
 *      User-defined messages must only be sent to an ACM driver that
 *      specifically supports the messages. The caller should verify that
 *      the ACM driver is in fact the correct driver by getting the
 *      driver details and checking the <e ACMDRIVERDETAILS.wMid>,
 *      <e ACMDRIVERDETAILS.wPid>, and <e ACMDRIVERDETAILS.vdwDriver> members.
 *
 *      Never send user-defined messages to an unknown ACM driver.
 *
 *  @xref <f acmDriverOpen> <f acmDriverDetails>
 *
 ****************************************************************************/

LRESULT ACMAPI acmDriverMessage
(
    HACMDRIVER              had,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT             lr;
    BOOL                fAllowDriverId;

    //
    //  assume no driver id allowed
    //
    fAllowDriverId = FALSE;

    //
    //  do not allow non-user range messages through!
    //
    //  we have to allow ACMDM_DRIVER_ABOUT through because we define no
    //  other interface to bring up the about box for a driver. so special
    //  case this message and validate the arguments for it...
    //
    //  we also have to allow DRV_QUERYCONFIGURE and DRV_CONFIGURE through.
    //
    if ((uMsg < ACMDM_USER) || (uMsg >= ACMDM_RESERVED_LOW))
    {
        switch (uMsg)
        {
            case DRV_QUERYCONFIGURE:
                if ((0L != lParam1) || (0L != lParam2))
                {
                    DebugErr(DBF_ERROR, "acmDriverMessage: DRV_QUERYCONFIGURE requires lParam1 = lParam2 = 0.");
                    return (MMSYSERR_INVALPARAM);
                }

                fAllowDriverId = TRUE;
                break;

            case DRV_CONFIGURE:
                if ((0L != lParam1) && !IsWindow((HWND)lParam1))
                {
                    DebugErr(DBF_ERROR, "acmDriverMessage: DRV_CONFIGURE, lParam1 must contain a valid window handle.");
                    return (DRVCNF_CANCEL);
                }

                if (0L != lParam2)
                {
                    DebugErr(DBF_ERROR, "acmDriverMessage: DRV_CONFIGURE, lParam2 must be zero.");
                    return (DRVCNF_CANCEL);
                }

                V_HANDLE(had, TYPE_HACMOBJ, DRVCNF_CANCEL);

                EnterHandle(had);
                lr = IDriverConfigure((HACMDRIVERID)had, (HWND)lParam1);
                LeaveHandle(had);
                return (lr);

            case ACMDM_DRIVER_ABOUT:
                if ((-1L != lParam1) && (0L != lParam1) && !IsWindow((HWND)lParam1))
                {
                    DebugErr(DBF_ERROR, "acmDriverMessage: ACMDM_DRIVER_ABOUT, lParam1 must contain a valid window handle.");
                    return (MMSYSERR_INVALHANDLE);
                }

                if (0L != lParam2)
                {
                    DebugErr(DBF_ERROR, "acmDriverMessage: ACMDM_DRIVER_ABOUT, lParam2 must be zero.");
                    return (MMSYSERR_INVALPARAM);
                }

                fAllowDriverId = TRUE;
                break;

            default:
                DebugErr(DBF_ERROR, "acmDriverMessage: non-user range messages are not allowed.");
                return (MMSYSERR_INVALPARAM);
        }
    }


    //
    //  validate handle as an HACMOBJ. this API can take an HACMDRIVERID
    //  as well as an HACMDRIVER. an HACMDRIVERID can only be used with
    //  the following messages:
    //
    //      DRV_QUERYCONFIGURE
    //      DRV_CONFIGURE
    //      ACMDM_DRIVER_ABOUT
    //
    V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);
    if (TYPE_HACMDRIVER == ((PACMDRIVER)had)->uHandleType)
    {
        EnterHandle(had);
        lr = IDriverMessage(had, uMsg, lParam1, lParam2);
        LeaveHandle(had);
        return (lr);
    }

    if (!fAllowDriverId)
    {
        V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
    }

    V_HANDLE(had, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

    EnterHandle(had);
    lr = IDriverMessageId((HACMDRIVERID)had, uMsg, lParam1, lParam2);
    LeaveHandle(had);
    return (lr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\acmfltr.c ===
/****************************************************************************
 *
 *   acmfltr.c
 *
 *   Copyright (c) 1991-1998 Microsoft Corporation
 *
 *   This module provides the wave filter enumeration and string API's.
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include "msacm.h"
#include "msacmdrv.h"
#include <stdlib.h>
#include "acmi.h"
#include "uchelp.h"
#include "debug.h"


//--------------------------------------------------------------------------;
//  
//  MMRESULT IFilterTagDetails
//  
//  Description:
//  
//  
//  Arguments:
//	PACMGARB pag:
//
//	HACMDRIVERID hadid:
//
//      LPACMFILTERTAGDETAILS pafd:
//
//	DWORD fdwDetails:
//  
//  Return (UINT):
//  
//  History:
//      08/31/94    frankye
//  
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IFilterTagDetails
(
    PACMGARB		    pag,
    HACMDRIVERID	    hadid,
    LPACMFILTERTAGDETAILS   paftd,
    DWORD                   fdwDetails
)
{
    PACMDRIVERID            padid;
    UINT                    u;
    DWORD                   fdwQuery;
    MMRESULT		    mmr;

    ASSERT( NULL != pag );
    ASSERT( NULL != hadid );

    
    padid	= (PACMDRIVERID)hadid;
    fdwQuery	= (ACM_FILTERTAGDETAILSF_QUERYMASK & fdwDetails);
    mmr		= ACMERR_NOTPOSSIBLE;
	
    switch (fdwQuery)
    {
	case ACM_FILTERTAGDETAILSF_FILTERTAG:
	{
	    for (u=0; u<padid->cFilterTags; u++)
	    {
		if (padid->paFilterTagCache[u].dwFilterTag == paftd->dwFilterTag)
		{
		    mmr = MMSYSERR_NOERROR;
		    break;
		}
	    }
	    break;
	}

	case ACM_FILTERTAGDETAILSF_LARGESTSIZE:
	case ACM_FILTERTAGDETAILSF_INDEX:
	    mmr = MMSYSERR_NOERROR;
	    break;
    }

    //
    //
    //
    if (MMSYSERR_NOERROR == mmr)
    {
	EnterHandle((HACMDRIVERID)padid);
	mmr = (MMRESULT)IDriverMessageId((HACMDRIVERID)padid,
					 ACMDM_FILTERTAG_DETAILS,
					 (LPARAM)(LPVOID)paftd,
					 fdwDetails);
	LeaveHandle((HACMDRIVERID)padid);
    }
	
    
    if (MMSYSERR_NOERROR != mmr)
    {
	return (mmr);
    }

    switch (paftd->dwFilterTag)
    {
	case WAVE_FILTER_UNKNOWN:
	    DebugErr(DBF_ERROR, "IDriverGetFilterTags(): driver returned Filter tag 0!");
	    return (MMSYSERR_ERROR);

	case WAVE_FILTER_DEVELOPMENT:
	    DebugErr(DBF_WARNING, "IDriverGetFilterTags(): driver returned DEVELOPMENT Filter tag--do not ship this way.");
	    break;

    }

    return(mmr);

}


/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 * 
 *  @types WAVEFILTER | The <t WAVEFILTER> structure defines a filter
 *      for waveform data. Only filter information common to all
 *      waveform data filters is included in this structure. For filters
 *      that require additional information, this structure is included
 *      as the first member in another structure, along with the additional
 *      information.
 * 
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t WAVEFILTER> structure. The size specified in this member must be
 *      large enough to contain the base <t WAVEFILTER> structure.
 * 
 *  @field DWORD | dwFilterTag | Specifies the waveform filter type. Filter
 *      tags are registered with Microsoft for various filter algorithms.
 *      A complete list of filter tags can be found in the MMREG.H header
 *      file available from Microsoft. For more information on filter
 *      tags, contact Microsoft for availability of the Multimedia Developer
 *      Registration Kit:
 *  
 *          Microsoft Corporation
 *          Advanced Consumer Technology
 *          Product Marketing
 *          One Microsoft Way
 *          Redmond, WA 98052-6399
 * 
 *  @field DWORD | fdwFilter | Specifies flags for the <e WAVEFILTER.dwFilterTag>.
 *      The flags defined for this member are universal to all filters.
 *      Currently, no flags are defined.
 * 
 *  @field DWORD | dwReserved[5] | This member is reserved for system use and should not
 *      be examined or modified by an application.
 * 
 *  @tagname wavefilter_tag
 * 
 *  @othertype WAVEFILTER FAR * | LPWAVEFILTER | A pointer to a <t WAVEFILTER>
 *      structure.
 *
 *  @xref <t WAVEFORMAT> <t WAVEFORMATEX> <t PCMWAVEFORMAT>
 *
 ****************************************************************************/


/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 * 
 *  @types ACMFILTERTAGDETAILS | The <t ACMFILTERTAGDETAILS> structure
 *      details a wave filter tag for an Audio Compression Manager (ACM)
 *      filter driver.
 *
 *  @field DWORD | cbStruct | Specifies the size in bytes of the
 *      <t ACMFILTERTAGDETAILS> structure. This member must be initialized 
 *      before calling the <f acmFilterTagDetails> or <f acmFilterTagEnum>
 *      functions. The size specified in this member must be large enough to
 *      contain the base <t ACMFILTERTAGDETAILS> structure. When the
 *      <f acmFilterTagDetails> function returns, this member contains the
 *      actual size of the information returned. The returned information
 *      will never exceed the requested size.
 *
 *  @field DWORD | dwFilterTagIndex | Specifies the index of the filter tag
 *      to retrieve details for. The index ranges from zero to one
 *      less than the number of filter tags supported by an ACM driver. The
 *      number of filter tags supported by a driver is contained in the 
 *      <e ACMDRIVERDETAILS.cFilterTags> member of the <t ACMDRIVERDETAILS>
 *      structure. The <e ACMFILTERTAGDETAILS.dwFilterTagIndex> member is
 *      only used when querying filter tag details on a driver by index;
 *      otherwise, this member should be zero.
 *
 *  @field DWORD | dwFilterTag | Specifies the wave filter tag that the
 *      <t ACMFILTERTAGDETAILS> structure describes. This member is used
 *      as an input for the ACM_FILTERTAGDETAILSF_FILTERTAG and
 *      ACM_FILTERTAGDETAILSF_LARGESTSIZE query flags. This member is always
 *      returned if the <f acmFilterTagDetails> is successful. This member
 *      should be set to WAVE_FILTER_UNKNOWN for all other query flags.
 *
 *  @field DWORD | cbFilterSize | Specifies the largest total size in bytes
 *      of a wave filter of the <e ACMFILTERTAGDETAILS.dwFilterTag> type.
 *      For example, this member will be 40 for WAVE_FILTER_ECHO and 36 for
 *      WAVE_FILTER_VOLUME.
 *
 *  @field DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the filter tag. These flags are identical to the <e ACMDRIVERDETAILS.fdwSupport>
 *      flags of the <t ACMDRIVERDETAILS> structure. This argument can be a
 *      combination of the following values and identifies which operations the
 *      driver supports with the filter tag:
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags while using
 *      the specified filter tag. For example, if a driver supports
 *      compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the
 *      specifed filter tag, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      same format tag while using the specified filter tag. For example,
 *      if a driver supports resampling of WAVE_FORMAT_PCM with the specified
 *      filter tag, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes). For example, if a driver supports volume
 *      or echo operations on WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions with the specified format tag.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output with the specified filter tag
 *      through a waveform device. An application should use <f acmMetrics>
 *      with the ACM_METRIC_HARDWARE_WAVE_INPUT and
 *      ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform
 *      device identifiers associated with the supporting ACM driver.
 *
 *  @field DWORD | cStandardFilters | Specifies the number of standard filters of the
 *      <e ACMFILTERTAGDETAILS.dwFilterTag> type. (that is, the combination of all
 *      filter characteristics). This value cannot specify all filters supported by the driver.
 *
 *  @field char | szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS] |
 *      Specifies a string that describes the <e ACMFILTERTAGDETAILS.dwFilterTag>
 *      type. This string is always returned if the <f acmFilterTagDetails>
 *      function is successful.
 * 
 *  @xref <f acmFilterTagDetails> <f acmFilterTagEnum>
 * 
 ****************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *                                     
 *  @api MMRESULT | acmFilterTagDetails | This function queries the Audio Compression 
 *      Manager (ACM) for details on a specific wave filter tag.
 *
 *  @parm HACMDRIVER | had | Optionally specifies an ACM driver to query
 *      for wave filter tag details. If this argument is NULL, then the
 *      ACM uses the details from the first suitable ACM driver. Note that
 *      an application must specify a valid <t HACMDRIVER> or <t HACMDRIVERID>
 *      when using the ACM_FILTERTAGDETAILSF_INDEX query type. Driver
 *      identifiers for disabled drivers are not allowed.
 *
 *  @parm LPACMFILTERTAGDETAILS | paftd | Specifies a pointer to the
 *      <t ACMFILTERTAGDETAILS> structure that is to receive the filter
 *      tag details.
 *
 *  @parm DWORD | fdwDetails | Specifies flags for getting the details.
 *
 *      @flag ACM_FILTERTAGDETAILSF_INDEX | Indicates that a filter tag index
 *      was given in the <e ACMFILTERTAGDETAILS.dwFilterTagIndex> member of
 *      the <t ACMFILTERTAGDETAILS> structure. The filter tag and details
 *      will be returned in the structure defined by <p paftd>. The index
 *      ranges from zero to one less than the <e ACMDRIVERDETAILS.cFilterTags>
 *      member returned in the <t ACMDRIVERDETAILS> structure for an ACM
 *      driver. An application must specify a driver handle (<p had>) when
 *      retrieving filter tag details with this flag.
 *
 *      @flag ACM_FILTERTAGDETAILSF_FILTERTAG | Indicates that a filter tag
 *      was given in the <e ACMFILTERTAGDETAILS.dwFilterTag> member of
 *      the <t ACMFILTERTAGDETAILS> structure. The filter tag details will
 *      be returned in the structure defined by <p paftd>. If an application
 *      specifies an ACM driver handle (<p had>), then details on the filter
 *      tag will be returned for that driver. If an application specifies
 *      NULL for <p had>, then the ACM finds the first acceptable driver
 *      to return the details.
 *
 *      @flag ACM_FILTERTAGDETAILSF_LARGESTSIZE | Indicates that the details
 *      on the filter tag with the largest filter size in bytes is to be
 *      returned. The <e ACMFILTERTAGDETAILS.dwFilterTag> member must either
 *      be WAVE_FILTER_UNKNOWN or the filter tag to find the largest size
 *      for. If an application specifies an ACM driver handle (<p had>), then
 *      details on the largest filter tag will be returned for that driver.
 *      If an application specifies NULL for <p had>, then the ACM finds an
 *      acceptable driver with the largest filter tag requested to return 
 *      the details.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The details requested are not available.
 *
 *  @xref <f acmDriverDetails> <f acmDriverOpen> <f acmFilterDetails>
 *      <f acmFilterTagEnum> <f acmFormatTagDetails>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFilterTagDetails
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILS   paftd,
    DWORD                   fdwDetails
)
{
    PACMGARB		    pag;
    PACMDRIVER		    pad;
    HACMDRIVERID            hadid;
    PACMDRIVERID            padid;
    DWORD                   fdwQuery;
    MMRESULT		    mmr;
    UINT                    u;

    pad	    = NULL;
    padid   = NULL;
    
    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFilterTagDetails: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }


    //
    //
    //
    V_DFLAGS(fdwDetails, ACM_FILTERTAGDETAILSF_VALID, acmFilterTagDetails, MMSYSERR_INVALFLAG);
    V_WPOINTER(paftd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(ACMFILTERTAGDETAILS) > paftd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterTagDetails: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(paftd, paftd->cbStruct, MMSYSERR_INVALPARAM);

    if (0L != paftd->fdwSupport)
    {
        DebugErr(DBF_ERROR, "acmFilterTagDetails: fdwSupport member must be set to zero.");
        return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    //
    fdwQuery = (ACM_FILTERTAGDETAILSF_QUERYMASK & fdwDetails);

    switch (fdwQuery)
    {
        case ACM_FILTERTAGDETAILSF_INDEX:
            //
            //  we don't (currently) support index based enumeration across
            //  all drivers... may never support this. so validate the
            //  handle and fail if not valid (like NULL).
            //
            V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);

            if (WAVE_FILTER_UNKNOWN != paftd->dwFilterTag)
            {
                DebugErr(DBF_ERROR, "acmFilterTagDetails: dwFilterTag must be WAVE_FILTER_UNKNOWN for index query.");
                return (MMSYSERR_INVALPARAM);
            }
            break;

        case ACM_FILTERTAGDETAILSF_FILTERTAG:
            if (WAVE_FILTER_UNKNOWN == paftd->dwFilterTag)
            {
                DebugErr(DBF_ERROR, "acmFilterTagDetails: dwFilterTag cannot be WAVE_FILTER_UNKNOWN for tag query.");
                return (MMSYSERR_INVALPARAM);
            }
            break;

        case ACM_FILTERTAGDETAILSF_LARGESTSIZE:
            break;


        //
        //  we don't (currently) support the requested query type--so return
        //  not supported.
        //
        default:
            DebugErr(DBF_ERROR, "acmFilterTagDetails: unknown query type specified.");
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //
    //
    if (NULL != had)
    {
        V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);

        pad = (PACMDRIVER)had;
        if (TYPE_HACMDRIVERID == pad->uHandleType)
        {
            padid = (PACMDRIVERID)pad;
	    pad	  = NULL;

            if (0 != (ACMDRIVERID_DRIVERF_DISABLED & padid->fdwDriver))
            {
		DebugErr1(DBF_ERROR, "acmFilterTagDetails: driver (%.04Xh) is disabled.", padid);
                return (MMSYSERR_NOTENABLED);
            }
        }
        else
        {
            V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
            padid = (PACMDRIVERID)pad->hadid;
        }
    }


    if (NULL == padid)
    {
	PACMDRIVERID    padidT;
	DWORD		cbFilterSizeLargest;

	padidT		    = NULL;
	cbFilterSizeLargest = 0;
	hadid = NULL;
		
	ENTER_LIST_SHARED;

	while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, 0L))
	{
	    padidT = (PACMDRIVERID)hadid;
	    
	    switch (fdwQuery)
	    {
		case ACM_FILTERTAGDETAILSF_FILTERTAG:
		{
		    for (u=0; u<padidT->cFilterTags; u++)
		    {
			if (padidT->paFilterTagCache[u].dwFilterTag == paftd->dwFilterTag)
			{
			    padid = padidT;
			    break;
			}
		    }
		    break;
		}

		case ACM_FILTERTAGDETAILSF_LARGESTSIZE:
		{
		    for (u=0; u<padidT->cFilterTags; u++)
		    {
			if (WAVE_FORMAT_UNKNOWN != paftd->dwFilterTag)
			{
			    if (padidT->paFilterTagCache[u].dwFilterTag != paftd->dwFilterTag)
			    {
				continue;
			    }
			}
			if (padidT->paFilterTagCache[u].cbFilterSize > cbFilterSizeLargest)
			{
			    cbFilterSizeLargest = padidT->paFilterTagCache[u].cbFilterSize;
			    padid = padidT;
			}
		    }
		    break;
		}

		default:
		{
		    DPF(0, "!acmFilterTagDetails(): unknown query type got through param validation?!?!");
		}
	    }
	}

	LEAVE_LIST_SHARED;
    }

    if (NULL != padid)
    {

	mmr = IFilterTagDetails(pag, (HACMDRIVERID)padid, paftd, fdwDetails);
	
    }
    else
    {

	mmr = ACMERR_NOTPOSSIBLE;

    }

    return(mmr);

} // acmFilterTagDetails()


#ifdef WIN32
#if TRUE    // defined(UNICODE)
MMRESULT ACMAPI acmFilterTagDetailsA
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSA  paftd,
    DWORD                   fdwDetails
)
{
    MMRESULT                mmr;
    ACMFILTERTAGDETAILSW    aftdW;

    V_WPOINTER(paftd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(*paftd) > paftd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterTagDetails: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(paftd, paftd->cbStruct, MMSYSERR_INVALPARAM);

    aftdW.cbStruct = sizeof(aftdW);
    memcpy(&aftdW.dwFilterTagIndex,
           &paftd->dwFilterTagIndex,
           FIELD_OFFSET(ACMFILTERTAGDETAILSA, szFilterTag) -
           FIELD_OFFSET(ACMFILTERTAGDETAILSA, dwFilterTagIndex));

    mmr = acmFilterTagDetailsW(had, &aftdW, fdwDetails);
    if (MMSYSERR_NOERROR == mmr)
    {
        memcpy(&paftd->dwFilterTagIndex,
               &aftdW.dwFilterTagIndex,
               FIELD_OFFSET(ACMFILTERTAGDETAILSA, szFilterTag) -
               FIELD_OFFSET(ACMFILTERTAGDETAILSA, dwFilterTagIndex));

        paftd->cbStruct = min(paftd->cbStruct, sizeof(*paftd));
        Iwcstombs(paftd->szFilterTag, aftdW.szFilterTag, sizeof(paftd->szFilterTag));
    }

    return (mmr);
}
#else
MMRESULT ACMAPI acmFilterTagDetailsW
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSW  paftd,
    DWORD                   fdwDetails
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif



/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 * 
 *  @types ACMFILTERDETAILS | The <t ACMFILTERDETAILS> structure details a
 *      wave filter for a specific filter tag for an Audio Compression
 *      Manager (ACM) driver.
 *
 *  @field DWORD | cbStruct | Specifies the size in bytes of the
 *      <t ACMFILTERDETAILS> structure. This member must be initialized 
 *      before calling the <f acmFilterDetails> or <f acmFilterEnum>
 *      functions. The size specified in this member must be large enough to
 *      contain the base <t ACMFILTERDETAILS> structure. When the
 *      <f acmFilterDetails> function returns, this member contains the
 *      actual size of the information returned. The returned information
 *      will never exceed the requested size.
 *
 *  @field DWORD | dwFilterIndex | Specifies the index of the filter about which
 *      details will be retrieved. The index ranges from zero to one
 *      less than the number of standard filters supported by an ACM driver
 *      for a filter tag. The number of standard filters supported by a
 *      driver for a filter tag is contained in the
 *      <e ACMFILTERTAGDETAILS.cStandardFilters> member of the
 *      <t ACMFILTERTAGDETAILS> structure. The
 *      <e ACMFILTERDETAILS.dwFilterIndex> member is only used when querying
 *      standard filter details on a driver by index; otherwise, this member
 *      should be zero. Also note that this member will be set to zero
 *      by the ACM when an application queries for details on a filter; in
 *      other words, this member is only used as an input argument and is
 *      never returned by the ACM or an ACM driver.
 *
 *  @field DWORD | dwFilterTag | Specifies the wave filter tag that the
 *      <t ACMFILTERDETAILS> structure describes. This member is used
 *      as an input for the ACM_FILTERDETAILSF_INDEX query flag.  For
 *      the ACM_FILTERDETAILSF_FORMAT query flag, this member
 *      must be initialized to the same filter tag as the
 *      <e ACMFILTERDETAILS.pwfltr> member specifies.
 *      This member is always returned if the <f acmFilterDetails> function is
 *      successful. This member should be set to WAVE_FILTER_UNKNOWN for all 
 *      other query flags.
 *
 *  @field DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the specified filter. These flags are identical to the
 *      <e ACMDRIVERDETAILS.fdwSupport> flags of the <t ACMDRIVERDETAILS>
 *      structure, but are specific to the filter that is being queried.
 *      This argument can be a combination of the following values and
 *      identifies which operations the driver supports for the filter tag:
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags while using the
 *      specified filter. For example, if a driver supports compression from 
 *      WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specifed
 *      filter, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      same format tag while using the specified filter. For example, if a
 *      driver supports resampling of WAVE_FORMAT_PCM with the specified
 *      filter, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes). For example, if a driver supports volume
 *      or echo operations on WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions with the specified filter tag.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output with the specified filter
 *      through a waveform device. An application should use <f acmMetrics>
 *      with the ACM_METRIC_HARDWARE_WAVE_INPUT and
 *      ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform
 *      device identifiers associated with the supporting ACM driver.
 *
 *  @field LPWAVEFILTER | pwfltr | Specifies a pointer to a <t WAVEFILTER>
 *      data structure that will receive the filter details. This structure
 *      requires no initialization by the application unless the
 *      ACM_FILTERDETAILSF_FILTER flag is specified to <f acmFilterDetails>.
 *      In this case, the <e WAVEFILTER.dwFilterTag> must be equal to
 *      the <e ACMFILTERDETAILS.dwFilterTag> of the <t ACMFILTERDETAILS>
 *      structure.
 *
 *  @field DWORD | cbwfltr | Specifies the size, in bytes, available for 
 *      the <e ACMFILTERDETAILS.pwfltr> to receive the filter details. The
 *      <f acmMetrics> and <f acmFilterTagDetails> functions can be used to
 *      determine the maximum size required for any filter available for the
 *      specified driver (or for all installed ACM drivers).
 *
 *  @field char | szFilter[ACMFILTERDETAILS_FILTER_CHARS] |
 *      Specifies a string that describes the filter for the
 *      <e ACMFILTERDETAILS.dwFilterTag> type. This string is always returned
 *      if the <f acmFilterDetails> function is successful.
 * 
 *  @xref <f acmFilterDetails> <f acmFilterEnum> <f acmFilterTagDetails>
 *      <f acmFilterTagEnum>
 * 
 ****************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *                                     
 *  @api MMRESULT | acmFilterDetails | This function queries the Audio Compression 
 *      Manager (ACM) for details about a filter with a specific wave filter tag.
 *
 *  @parm HACMDRIVER | had | Optionally specifies an ACM driver to query
 *      for wave filter details for a filter tag. If this argument is NULL,
 *      then the ACM uses the details from the first suitable ACM driver.
 *
 *  @parm LPACMFILTERDETAILS | pafd | Specifies a pointer to the
 *      <t ACMFILTERDETAILS> structure that is to receive the filter
 *      details for the given filter tag.
 *
 *  @parm DWORD | fdwDetails | Specifies flags for getting the details.
 *
 *      @flag ACM_FILTERDETAILSF_INDEX | Indicates that a filter index for
 *      the filter tag was given in the <e ACMFILTERDETAILS.dwFilterIndex>
 *      member of the <t ACMFILTERDETAILS> structure. The filter details
 *      will be returned in the structure defined by <p pafd>. The index
 *      ranges from zero to one less than the
 *      <e ACMFILTERTAGDETAILS.cStandardFilters> member returned in the
 *      <t ACMFILTERTAGDETAILS> structure for a filter tag. An application
 *      must specify a driver handle (<p had>) when retrieving
 *      filter details with this flag. Refer to the description for the
 *      <t ACMFILTERDETAILS> structure for information on what members
 *      should be initialized before calling this function.
 *
 *      @flag ACM_FILTERDETAILSF_FILTER | Indicates that a <t WAVEFILTER>
 *      structure pointed to by <e ACMFILTERDETAILS.pwfltr> of the 
 *      <t ACMFILTERDETAILS> structure was given and the remaining details
 *      should be returned. The <e ACMFILTERDETAILS.dwFilterTag> member 
 *      of the <t ACMFILTERDETAILS> structure must be initialized to the same filter
 *      tag as the <e ACMFILTERDETAILS.pwfltr> member specifies. This 
 *      query type can be used to get a string description of an arbitrary
 *      filter structure. If an application specifies an ACM driver handle
 *      (<p had>), then details on the filter will be returned for that
 *      driver. If an application specifies NULL for <p had>, then the ACM
 *      finds the first acceptable driver to return the details.
 *
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The details requested are not available.
 *
 *  @xref <f acmFilterTagDetails> <f acmDriverDetails> <f acmDriverOpen>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFilterDetails
(
    HACMDRIVER              had,
    LPACMFILTERDETAILS      pafd,
    DWORD                   fdwDetails
)
{
    PACMGARB	    pag;
    MMRESULT        mmr;
    PACMDRIVER      pad;
    HACMDRIVERID    hadid;
    PACMDRIVERID    padid;
    DWORD           dwQuery;

    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFilterDetails: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }

    //
    //
    //
    V_DFLAGS(fdwDetails, ACM_FILTERDETAILSF_VALID, acmFilterDetails, MMSYSERR_INVALFLAG);
    V_WPOINTER(pafd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(ACMFILTERDETAILS) > pafd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterDetails: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd, pafd->cbStruct, MMSYSERR_INVALPARAM);

    if (sizeof(WAVEFILTER) > pafd->cbwfltr)
    {
        DebugErr(DBF_ERROR, "acmFilterDetails: cbwfltr member must be at least sizeof(WAVEFILTER).");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd->pwfltr, pafd->cbwfltr, MMSYSERR_INVALPARAM);

    if (0L != pafd->fdwSupport)
    {
        DebugErr(DBF_ERROR, "acmFilterDetails: fdwSupport member must be set to zero.");
        return (MMSYSERR_INVALPARAM);
    }


    //
    //
    //
    dwQuery = ACM_FILTERDETAILSF_QUERYMASK & fdwDetails;

    switch (dwQuery)
    {
        case ACM_FILTERDETAILSF_FILTER:
            if (pafd->dwFilterTag != pafd->pwfltr->dwFilterTag)
            {
                DebugErr(DBF_ERROR, "acmFilterDetails: filter tags must match.");
                return  (MMSYSERR_INVALPARAM);
            }

            // -- fall through -- //

        case ACM_FILTERDETAILSF_INDEX:
            if (WAVE_FILTER_UNKNOWN == pafd->dwFilterTag)
            {
                DebugErr(DBF_ERROR, "acmFilterDetails: dwFilterTag cannot be WAVE_FILTER_UNKNOWN for requested details query.");
                return (MMSYSERR_INVALPARAM);
            }

            //
            //  we don't (currently) support index based enumeration across
            //  all drivers... may never support this. so validate the
            //  handle and fail if not valid (like NULL).
            //
            if (ACM_FILTERDETAILSF_INDEX == dwQuery)
            {
                ACMFILTERTAGDETAILS aftd;

                V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);

                _fmemset(&aftd, 0, sizeof(aftd));
                aftd.cbStruct    = sizeof(aftd);
                aftd.dwFilterTag = pafd->dwFilterTag;
                mmr = acmFilterTagDetails(had, &aftd, ACM_FILTERTAGDETAILSF_FILTERTAG);
                if (MMSYSERR_NOERROR != mmr)
                {
                    return (mmr);
                }

                if (pafd->dwFilterIndex >= aftd.cStandardFilters)
                {
                    DebugErr1(DBF_ERROR, "acmFilterTagDetails: dwFilterIndex (%lu) out of range.", pafd->dwFilterIndex);
                    return (MMSYSERR_INVALPARAM);
                }
            }
            break;

        default:
            DebugErr(DBF_ERROR, "acmFilterDetails: unknown query type specified.");
            return  (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  if we are passed a driver handle, then use it
    //
    if (NULL != had)
    {
        pad = (PACMDRIVER)had;
        if (TYPE_HACMDRIVERID == pad->uHandleType)
        {
            V_HANDLE(had, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

            //
            //  !!! yes, this is right !!!
            //
            padid = (PACMDRIVERID)had;

            if (0 == (ACMDRIVERDETAILS_SUPPORTF_FILTER & padid->fdwSupport))
            {
                DebugErr(DBF_ERROR, "acmFilterDetails: driver does not support filter operations.");
                return (MMSYSERR_INVALPARAM);
            }


            //
            //
            //
            EnterHandle(had);
            mmr = (MMRESULT)IDriverMessageId((HACMDRIVERID)had,
                                             ACMDM_FILTER_DETAILS,
                                             (LPARAM)pafd,
                                             fdwDetails);
            LeaveHandle(had);
        }
        else
        {
            V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

            pad   = (PACMDRIVER)had;
            padid = (PACMDRIVERID)pad->hadid;

            if (0 == (ACMDRIVERDETAILS_SUPPORTF_FILTER & padid->fdwSupport))
            {
                DebugErr(DBF_ERROR, "acmFilterDetails: driver does not support filter operations.");
                return (MMSYSERR_INVALPARAM);
            }


            //
            //
            //
            EnterHandle(had);
            mmr = (MMRESULT)IDriverMessage(had,
                                           ACMDM_FILTER_DETAILS,
                                           (LPARAM)pafd,
                                           fdwDetails);
            LeaveHandle(had);
        }

        if (MMSYSERR_NOERROR == mmr)
        {
            //
            //  if caller is asking for details on a specific filter, then
            //  always return index equal to zero (it means nothing)
            //
            if (ACM_FILTERDETAILSF_FILTER == dwQuery)
            {
                pafd->dwFilterIndex = 0;
            }
        }

        return (mmr);
    }


    //
    //
    //
    hadid = NULL;
    mmr   = MMSYSERR_NODRIVER;

    ENTER_LIST_SHARED;

    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, 0L))
    {
        padid = (PACMDRIVERID)hadid;

        if (0 == (ACMDRIVERDETAILS_SUPPORTF_FILTER & padid->fdwSupport))
        {
            continue;
        }

        //
        //
        //
        EnterHandle(hadid);
        mmr = (MMRESULT)IDriverMessageId(hadid,
                                         ACMDM_FILTER_DETAILS,
                                         (LPARAM)pafd,
                                         fdwDetails);
        LeaveHandle(hadid);

        if (MMSYSERR_NOERROR == mmr)
        {
            //
            //  if caller is asking for details on a specific filter, then
            //  always return index equal to zero (it means nothing)
            //
            if (ACM_FILTERDETAILSF_FILTER == dwQuery)
            {
                pafd->dwFilterIndex = 0;
            }
            break;
        }
    }
    
    LEAVE_LIST_SHARED;

    return (mmr);
} // acmFilterDetails()


#ifdef WIN32
#if TRUE    // defined(UNICODE)
MMRESULT ACMAPI acmFilterDetailsA
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSA     pafd,
    DWORD                   fdwDetails
)
{
    MMRESULT                mmr;
    ACMFILTERDETAILSW       afdW;

    V_WPOINTER(pafd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(*pafd) > pafd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterDetails: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd, pafd->cbStruct, MMSYSERR_INVALPARAM);

    afdW.cbStruct = sizeof(afdW);
    memcpy(&afdW.dwFilterIndex,
           &pafd->dwFilterIndex,
           FIELD_OFFSET(ACMFILTERDETAILSA, szFilter) -
           FIELD_OFFSET(ACMFILTERDETAILSA, dwFilterIndex));

    mmr = acmFilterDetailsW(had, &afdW, fdwDetails);
    if (MMSYSERR_NOERROR == mmr)
    {
        memcpy(&pafd->dwFilterIndex,
               &afdW.dwFilterIndex,
               FIELD_OFFSET(ACMFILTERDETAILSA, szFilter) -
               FIELD_OFFSET(ACMFILTERDETAILSA, dwFilterIndex));

        pafd->cbStruct = min(pafd->cbStruct, sizeof(*pafd));
        Iwcstombs(pafd->szFilter, afdW.szFilter, sizeof(pafd->szFilter));
    }

    return (mmr);
}
#else
MMRESULT ACMAPI acmFilterDetailsW
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSW     pafd,
    DWORD                   fdwDetails
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *                                     
 *  @api BOOL ACMFILTERTAGENUMCB | acmFilterTagEnumCallback |
 *      The <f acmFilterTagEnumCallback> function  is a placeholder for an
 *      application-supplied function name and refers to the callback function
 *      used for Audio Compression Manager (ACM) wave filter tag enumeration. 
 *      
 *
 *  @parm HACMDRIVERID | hadid | Specifies an ACM driver identifier.
 *
 *  @parm  LPACMFILTERTAGDETAILS | paftd | Specifies a pointer to an
 *      <t ACMFILTERTAGDETAILS> structure that contains the enumerated
 *      filter tag details.
 *
 *  @parm DWORD | dwInstance | Specifies the application-defined value
 *      specified in the <f acmFilterTagEnum> function.
 *
 *  @parm DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the driver identifier <p hadid>. These flags are identical to the
 *      <e ACMDRIVERDETAILS.fdwSupport> flags of the <t ACMDRIVERDETAILS>
 *      structure. This argument can be a combination of the following
 *      values and identifies which operations the driver supports with the
 *      filter tag
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags while using
 *      the specified filter tag. For example, if a driver supports
 *      compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the
 *      specifed filter tag, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      same format tag while using the specified filter tag. For example,
 *      if a driver supports resampling of WAVE_FORMAT_PCM with the specified
 *      filter tag, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes). For example, if a driver supports volume
 *      or echo operations on WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions with the specified filter tag.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output with the specified filter tag
 *      through a waveform device. An application should use <f acmMetrics>
 *      with the ACM_METRIC_HARDWARE_WAVE_INPUT and
 *      ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform
 *      device identifiers associated with the supporting ACM driver.
 *
 *  @rdesc The callback function must return TRUE to continue enumeration;
 *      to stop enumeration, it must return FALSE.
 *
 *  @comm The <f acmFilterTagEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no filter tags are to be enumerated. Moreover, the callback
 *      function will not be called.
 *
 *  @xref <f acmFilterTagEnum> <f acmFilterTagDetails> <f acmDriverOpen>
 *
 ***************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *                                     
 *  @api MMRESULT | acmFilterTagEnum | The <f acmFilterTagEnum> function
 *      enumerates wave filter tags available from an Audio Compression
 *      Manager (ACM) driver. The <f acmFilterTagEnum> function continues
 *      enumerating until there are no more suitable filter tags or the
 *      callback function returns FALSE.
 *
 *  @parm HACMDRIVER | had | Optionally specifies an ACM driver to query
 *      for wave filter tag details. If this argument is NULL, then the
 *      ACM uses the details from the first suitable ACM driver.
 *
 *  @parm LPACMFILTERTAGDETAILS | paftd | Specifies a pointer to the
 *      <t ACMFILTERTAGDETAILS> structure that is to receive the filter
 *      tag details passed to the <p fnCallback> function. This structure
 *      must have the <e ACMFILTERTAGDETAILS.cbStruct> member of the
 *      <t ACMFILTERTAGDETAILS> structure initialized.
 *
 *  @parm ACMFILTERTAGENUMCB | fnCallback | Specifies the procedure-instance
 *      address of the application-defined callback function. The callback
 *      address must be created by the <f MakeProcInstance> function, or
 *      the callback function must contain the proper prolog and epilog code
 *      for callbacks.
 *
 *  @parm DWORD_PTR | dwInstance | Specifies a pointer sized,
 *      application-defined value that is passed to the callback function
 *      along with ACM filter tag details.
 *
 *  @parm DWORD | fdwEnum | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *  @comm The <f acmFilterTagEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no suitable ACM drivers are installed. Moreover, the
 *      callback function will not be called.
 *
 *  @xref <f acmFilterTagEnumCallback> <f acmFilterTagDetails>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFilterTagEnum
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILS   paftd,
    ACMFILTERTAGENUMCB      fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
)
{
    PACMGARB		pag;
    PACMDRIVER          pad;
    PACMDRIVERID        padid;
    UINT                uIndex;
    UINT                uFilterTag;
    BOOL                f;
    HACMDRIVERID        hadid;
    PACMDRIVERID        padidCur;
    HACMDRIVERID        hadidCur;
    BOOL                fSent;
    DWORD               cbaftd;
    DWORD               fdwSupport;
    MMRESULT		mmr;
    
    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFilterTagEnum: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }
    
    //
    //
    //
    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwEnum, ACM_FILTERTAGENUMF_VALID, acmFilterTagEnum, MMSYSERR_INVALFLAG);
    
    V_WPOINTER(paftd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(ACMFILTERTAGDETAILS) > paftd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterTagEnum: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(paftd, paftd->cbStruct, MMSYSERR_INVALPARAM);
    
    if (0L != paftd->fdwSupport)
    {
        DebugErr(DBF_ERROR, "acmFilterTagEnum: fdwSupport member must be set to zero.");
        return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    cbaftd = min(paftd->cbStruct, sizeof(ACMFILTERTAGDETAILS));


    //
    //
    //
    //
    if (NULL != had)
    {
        V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

        //
        //  enum filter tags for this driver only.
        //
        pad   = (PACMDRIVER)had;
        padid = (PACMDRIVERID)pad->hadid;

        //
        //  do NOT include the 'disabled' bit!
        //
        fdwSupport = padid->fdwSupport;

        //
        //  while there are Filters to enumerate and we have not been
        //  told to stop (client returns FALSE to stop enum)
        //
	mmr = MMSYSERR_NOERROR;
        for (uIndex = 0; uIndex < padid->cFilterTags; uIndex++)
        {
	    paftd->cbStruct = cbaftd;
	    paftd->dwFilterTagIndex = uIndex;
	    mmr = IFilterTagDetails(pag, (HACMDRIVERID)padid, paftd, ACM_FILTERTAGDETAILSF_INDEX);
	    if (MMSYSERR_NOERROR != mmr) {
		break;
	    }
	    
            f = (* fnCallback)(pad->hadid, paftd, dwInstance, fdwSupport);
            if (FALSE == f)
                break;
        }

        return (mmr);
    }


    //
    //
    //
    //
    hadidCur = NULL;

    ENTER_LIST_SHARED;

    while (!IDriverGetNext(pag, &hadidCur, hadidCur, 0L))
    {
        padidCur = (PACMDRIVERID)hadidCur;

        for (uIndex = 0; uIndex < padidCur->cFilterTags; uIndex++)
        {
            uFilterTag = (UINT)(padidCur->paFilterTagCache[uIndex].dwFilterTag);
            fSent = FALSE;
            hadid = NULL;
            while (!fSent && !IDriverGetNext(pag, &hadid, hadid, 0L))
            {
                UINT    u;

                //
                //  same driver ?
                //
                if (hadid == hadidCur)
                    break;


                //
                //  for every previous driver 
                //
                padid = (PACMDRIVERID)hadid;

                for (u = 0; u < padid->cFilterTags; u++)
                {
                    //
                    //  for every FilterTag in the driver 
                    //
                    if (uFilterTag == padid->paFilterTagCache[u].dwFilterTag)
                    {
                        //
                        //  we have a match, but this was already given.
                        //
                        fSent = TRUE;
                        break;
                    }
                }
            }

            if (!fSent)
            {
                //
                //  we have a filter that has not been sent yet.
                //
		paftd->dwFilterTagIndex = uIndex;
		paftd->cbStruct = cbaftd;
		mmr = IFilterTagDetails(pag, (HACMDRIVERID)padidCur,
					paftd, ACM_FILTERTAGDETAILSF_INDEX);
		if (MMSYSERR_NOERROR != mmr)
		{
		    LEAVE_LIST_SHARED;
		    return mmr;
		}

                //
                //  do NOT include the 'disabled' bit!
                //
                fdwSupport = padidCur->fdwSupport;

                f = (* fnCallback)(hadidCur, paftd, dwInstance, fdwSupport);
                if (FALSE == f) {
                    LEAVE_LIST_SHARED;
                    return (MMSYSERR_NOERROR);
		}
            }
        }
    }

    LEAVE_LIST_SHARED;

    return (MMSYSERR_NOERROR);
}


#ifdef WIN32
#if TRUE    // defined(UNICODE)

typedef struct tIFILTERTAGENUMCBINSTANCEW
{
    ACMFILTERTAGENUMCBA         fnCallback;
    DWORD_PTR                   dwInstance;
    LPACMFILTERTAGDETAILSA      paftd;

} IFILTERTAGENUMCBINSTANCEW, *PIFILTERTAGENUMCBINSTANCEW;

BOOL FNWCALLBACK IFilterTagEnumCallbackW
(
    HACMDRIVERID            hadid,
    LPACMFILTERTAGDETAILSW  paftdW,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
)
{
    PIFILTERTAGENUMCBINSTANCEW  pfti;
    BOOL                        f;

    pfti = (PIFILTERTAGENUMCBINSTANCEW)dwInstance;

    memcpy(&pfti->paftd->dwFilterTagIndex,
           &paftdW->dwFilterTagIndex,
           FIELD_OFFSET(ACMFILTERTAGDETAILSA, szFilterTag) -
           FIELD_OFFSET(ACMFILTERTAGDETAILSA, dwFilterTagIndex));

    pfti->paftd->cbStruct = sizeof(*pfti->paftd);
    Iwcstombs(pfti->paftd->szFilterTag, paftdW->szFilterTag, sizeof(pfti->paftd->szFilterTag));

    f = pfti->fnCallback(hadid, pfti->paftd, pfti->dwInstance, fdwSupport);

    return (f);
}


MMRESULT ACMAPI acmFilterTagEnumA
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSA  paftd,
    ACMFILTERTAGENUMCBA     fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT                    mmr;
    ACMFILTERTAGDETAILSW        aftdW;
    IFILTERTAGENUMCBINSTANCEW   fti;

    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_WPOINTER(paftd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(*paftd) > paftd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterTagEnum: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(paftd, paftd->cbStruct, MMSYSERR_INVALPARAM);

    aftdW.cbStruct = sizeof(aftdW);
    memcpy(&aftdW.dwFilterTagIndex,
           &paftd->dwFilterTagIndex,
           FIELD_OFFSET(ACMFILTERTAGDETAILSA, szFilterTag) -
           FIELD_OFFSET(ACMFILTERTAGDETAILSA, dwFilterTagIndex));

    fti.fnCallback = fnCallback;
    fti.dwInstance = dwInstance;
    fti.paftd      = paftd;

    mmr = acmFilterTagEnumW(had, &aftdW, IFilterTagEnumCallbackW, (DWORD_PTR)&fti, fdwEnum);

    return (mmr);
}
#else
MMRESULT ACMAPI acmFilterTagEnumW
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSW  paftd,
    ACMFILTERTAGENUMCBW     fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif


//--------------------------------------------------------------------------;
//  
//  MMRESULT IFilterEnum
//  
//  Description:
//  
//  
//  Arguments:
//      HACMDRIVERID hadid:
//  
//      LPACMFILTERTAGDETAILS paftd:
//  
//      LPACMFILTERDETAILS pafd:
//  
//      ACMFILTERENUMCB fnCallback:
//  
//      DWORD_PTR dwInstance:
//  
//  Return (MMRESULT):
//  
//  History:
//      06/17/93    cjp     [curtisp]
//  
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IFilterEnum
(
    HACMDRIVERID            hadid,
    LPACMFILTERTAGDETAILS   paftd,
    LPACMFILTERDETAILS      pafd,
    ACMFILTERENUMCB         fnCallback,
    DWORD_PTR               dwInstance
)
{
    MMRESULT            mmr;
    BOOL                f;
    DWORD               cbafd;
    LPWAVEFILTER        pwfltr;
    DWORD               cbwfltr;
    UINT                u;
    PACMDRIVERID        padid;
    DWORD               fdwSupport;

    //
    //  be a bit paranoid and save some stuff so we can always reinit
    //  the structure between calling the driver (i just don't trust
    //  driver writers... though Media Vision is bound to find a way
    //  to cause trouble anyway)
    //
    cbafd   = pafd->cbStruct;
    pwfltr  = pafd->pwfltr;
    cbwfltr = pafd->cbwfltr;

    padid = (PACMDRIVERID)hadid;

    //
    //  do NOT include whether the 'disabled' bit!
    //
    fdwSupport = padid->fdwSupport;


    //
    //
    //
    for (u = 0; u < paftd->cStandardFilters; u++)
    {
        pafd->cbStruct      = cbafd;
        pafd->dwFilterIndex = u;
        pafd->dwFilterTag   = paftd->dwFilterTag;
        pafd->fdwSupport    = 0;
        pafd->pwfltr        = pwfltr;
        pafd->cbwfltr       = cbwfltr;

        if (FIELD_OFFSET(ACMFILTERDETAILS, szFilter) < cbafd)
            pafd->szFilter[0] = '\0';
        
        mmr = acmFilterDetails((HACMDRIVER)hadid,
                                pafd,
                                ACM_FILTERDETAILSF_INDEX);
        if (MMSYSERR_NOERROR != mmr)
            continue;

        f = (* fnCallback)(hadid, pafd, dwInstance, fdwSupport);
        if (FALSE == f)
            return (MMSYSERR_ERROR);
    }

    return (MMSYSERR_NOERROR);
} // IFilterEnum()


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *                                     
 *  @api BOOL ACMFILTERENUMCB | acmFilterEnumCallback |
 *      <f acmFilterEnumCallback>  is a placeholder for an application-
 *      supplied function name and refers to the callback function used for
 *      Audio Compression Manager (ACM) wave filter detail enumeration.
 *     
 *
 *  @parm HACMDRIVERID | hadid | Specifies an ACM driver identifier.
 *
 *  @parm  LPACMFILTERDETAILS | pafd | Specifies a pointer to an
 *      <t ACMFILTERDETAILS> structure that contains the enumerated
 *      filter details for a filter tag.
 *
 *  @parm DWORD | dwInstance | Specifies the application-defined value
 *      specified in the <f acmFilterEnum> function.
 *
 *  @parm DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the driver identifier <p hadid> for the specified filter. These flags
 *      are identical to the <e ACMDRIVERDETAILS.fdwSupport> flags of the
 *      <t ACMDRIVERDETAILS> structure, but are specific to the filter that
 *      is being enumerated. This argument can be a combination of the
 *      following values and identifies which operations the driver supports
 *      for the filter tag.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags while using
 *      the specified filter. For example, if a driver supports compression
 *      from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specifed
 *      filter, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      same format tag while using the specified filter. For example, if a
 *      driver supports resampling of WAVE_FORMAT_PCM with the specified
 *      filter, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes). For example, if a driver supports volume
 *      or echo operations on WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions with the specified filter tag.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output with the specified filter
 *      through a waveform device. An application should use <f acmMetrics>
 *      with the ACM_METRIC_HARDWARE_WAVE_INPUT and
 *      ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform
 *      device identifiers associated with the supporting ACM driver.
 *
 *  @rdesc The callback function must return TRUE to continue enumeration;
 *      to stop enumeration, it must return FALSE.
 *
 *  @comm The <f acmFilterEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no filters are to be enumerated. Moreover, the callback
 *      function will not be called.
 *
 *  @xref <f acmFilterEnum> <f acmFilterTagDetails> <f acmDriverOpen>
 *
 ***************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *                                     
 *  @api MMRESULT | acmFilterEnum | The <f acmFilterEnum> function
 *      enumerates wave filters available for a given filter tag from
 *      an Audio Compression Manager (ACM) driver. The <f acmFilterEnum>
 *      function continues enumerating until there are no more suitable
 *      filters for the filter tag or the callback function returns FALSE.
 *
 *  @parm HACMDRIVER | had | Optionally specifies an ACM driver to query
 *      for wave filter details. If this argument is NULL, then the
 *      ACM uses the details from the first suitable ACM driver.
 *
 *  @parm LPACMFILTERDETAILS | pafd | Specifies a pointer to the
 *      <t ACMFILTERDETAILS> structure that is to receive the filter details
 *      passed to the <p fnCallback> function. This structure must have the
 *      <e ACMFILTERDETAILS.cbStruct>, <e ACMFILTERDETAILS.pwfltr>, and
 *      <e ACMFILTERDETAILS.cbwfltr> members of the <t ACMFILTERDETAILS>
 *      structure initialized. The <e ACMFILTERDETAILS.dwFilterTag> member
 *      must also be initialized to either WAVE_FILTER_UNKNOWN or a 
 *      valid filter tag.
 *
 *  @parm ACMFILTERENUMCB | fnCallback | Specifies the procedure-instance
 *      address of the application-defined callback function. The callback
 *      address must be created by the <f MakeProcInstance> function, or
 *      the callback function must contain the proper prolog and epilog code
 *      for callbacks.
 *
 *  @parm DWORD | dwInstance | Specifies a 32-bit, application-defined value
 *      that is passed to the callback function along with ACM filter details.
 *
 *  @parm DWORD | fdwEnum | Specifies flags for enumerating the filters for
 *      a given filter tag.
 *
 *      @flag ACM_FILTERENUMF_DWFILTERTAG | Specifies that the
 *      <e WAVEFILTER.dwFilterTag> member of the <t WAVEFILTER> structure
 *      referred to by the <e ACMFILTERDETAILS.pwfltr> member of the 
 *      <t ACMFILTERDETAILS> structure is valid. The enumerator will only
 *      enumerate a filter that conforms to this attribute. Note that the
 *      <e ACMFILTERDETAILS.dwFilterTag> member of the <t ACMFILTERDETAILS>
 *      structure must be equal to the <e WAVEFILTER.dwFilterTag> member.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The details for the filter cannot be
 *      returned.
 *
 *  @comm The <f acmFilterEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no suitable ACM drivers are installed. Moreover, the
 *      callback function will not be called.
 *
 *  @xref <f acmFilterEnumCallback> <f acmFilterDetails> <f acmFilterSuggest>
 *      <f acmFilterTagDetails> <f acmFormatEnum>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFilterEnum
(
    HACMDRIVER          had,
    LPACMFILTERDETAILS  pafd,
    ACMFILTERENUMCB     fnCallback,
    DWORD_PTR           dwInstance, 
    DWORD               fdwEnum
)
{
    PACMGARB		pag;
    MMRESULT		mmr;
    PACMDRIVER		pad;
    PACMDRIVERID	padid;
    HACMDRIVERID	hadid;
    PACMDRIVERID	padidCur;
    PACMDRIVERID	padidBestCount;
    DWORD		cBestCount;
    HACMDRIVERID	hadidCur;
    ACMFILTERTAGDETAILS	aftd;
    UINT		u;
    UINT		uBestCount;
    UINT		uIndex;
    UINT		uFilterTag;
    BOOL		fDone;
    BOOL		fStop;
    
    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFilterEnum: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }
    
    V_WPOINTER(pafd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(ACMFILTERDETAILS) > pafd->cbStruct)
    {                     
        DebugErr(DBF_ERROR, "acmFilterEnum: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd, pafd->cbStruct, MMSYSERR_INVALPARAM);
    if (NULL != had)
    {
        V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
    }
    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwEnum, ACM_FILTERENUMF_VALID, acmFilterEnum, MMSYSERR_INVALFLAG);
    if (sizeof(WAVEFILTER) > pafd->cbwfltr)
    {
        DebugErr(DBF_ERROR, "acmFilterEnum: cbwfltr member must be at least sizeof(WAVEFILTER).");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd->pwfltr, pafd->cbwfltr, MMSYSERR_INVALPARAM);
    
    if (0L != pafd->fdwSupport)
    {
        DebugErr(DBF_ERROR, "acmFilterEnum: fdwSupport member must be set to zero.");
        return (MMSYSERR_INVALPARAM);
    }


    //
    //  Get the restrictions on the enum.
    //
    if( fdwEnum & ACM_FILTERENUMF_DWFILTERTAG ) {
        uFilterTag = (UINT)(pafd->pwfltr->dwFilterTag);

        if (WAVE_FILTER_UNKNOWN == uFilterTag)
        {
            DebugErr(DBF_ERROR, "acmFilterEnum: ACM_FILTERENUMF_DWFILTERTAG cannot be used with WAVE_FILTER_UNKNOWN.");
            return (MMSYSERR_INVALPARAM);
        }

#if 0
        if (pafd->dwFilterTag != uFilterTag)
        {
            DebugErr(DBF_ERROR, "acmFilterEnum: filter tags must match.");
            return  (MMSYSERR_INVALPARAM);
        }
#endif
    } else {
        uFilterTag = WAVE_FILTER_UNKNOWN;
    }

    //
    //
    //
    mmr = MMSYSERR_NOERROR;


    //
    //
    //
    //
    if (NULL != had)
    {
        pad   = (PACMDRIVER)had;
        padid = (PACMDRIVERID)pad->hadid;

        //
        //  step through all Filter tags that the caller is interested in
        //  and enumerate the Filters...
        //
        for (u = 0; u < padid->cFilterTags; u++)
        {
            if( fdwEnum & ACM_FILTERENUMF_DWFILTERTAG ) {
                if (uFilterTag != padid->paFilterTagCache[u].dwFilterTag)
                    continue;
            }

	    aftd.cbStruct = sizeof(aftd);
	    aftd.dwFilterTagIndex = u;
	    mmr = IFilterTagDetails( pag, (HACMDRIVERID)padid,
				     &aftd, ACM_FILTERTAGDETAILSF_INDEX );

	    if (MMSYSERR_NOERROR == mmr)
	    {

		mmr = IFilterEnum( pad->hadid,
				   &aftd,
				   pafd,
				   fnCallback,
				   dwInstance );

	    }
            
            if( mmr == MMSYSERR_ERROR ) {
                // Returned generic error to stop the enumeration.
                mmr = MMSYSERR_NOERROR;
                break;
            }
            if( fdwEnum & ACM_FILTERENUMF_DWFILTERTAG ) {
                break;
            }
        }
    } else if( fdwEnum & ACM_FILTERENUMF_DWFILTERTAG ) {
        hadid = NULL;
        fDone = FALSE;
	padidBestCount = NULL;
	cBestCount     = 0;

        ENTER_LIST_SHARED;

        while( !IDriverGetNext(pag, &hadid, hadid, 0L) ) {
            padid = (PACMDRIVERID)hadid;

            //
            //  find the Filter tag that the caller is interested in and
            //  enumerate the Filters...
            //
            for (u = 0; u < padid->cFilterTags; u++)
            {
                if (uFilterTag != padid->paFilterTagCache[u].dwFilterTag)
                    continue;

		aftd.cbStruct = sizeof(aftd);
		aftd.dwFilterTagIndex = u;
		mmr = IFilterTagDetails( pag, (HACMDRIVERID)padid,
					 &aftd, ACM_FILTERTAGDETAILSF_INDEX );

		if( !padidBestCount ||
		    (aftd.cStandardFilters > cBestCount) ) {
		    padidBestCount = padid;
		    uBestCount = u;
		    cBestCount = aftd.cStandardFilters;
		}
		break;
            }
	}

	if( padidBestCount ) {
	    
	    aftd.cbStruct = sizeof(aftd);
	    aftd.dwFilterTagIndex = uBestCount;
	    mmr = IFilterTagDetails( pag, (HACMDRIVERID)padidBestCount,
				     &aftd, ACM_FILTERTAGDETAILSF_INDEX );

	    if (MMSYSERR_NOERROR == mmr)
	    {
		mmr = IFilterEnum( (HACMDRIVERID)padidBestCount,
				   &aftd,
				   pafd,
                                   fnCallback,
                                   dwInstance);
	    }
	    
	    if( mmr == MMSYSERR_ERROR ) {
		// Returned generic error to stop the enumeration.
		mmr = MMSYSERR_NOERROR;
	    }
	    fDone = TRUE;
        }

        LEAVE_LIST_SHARED;

    } else {
        // Enum Filters across all drivers.

        fStop = FALSE;
        hadidCur = NULL;

        ENTER_LIST_SHARED;

        while( !fStop && !IDriverGetNext(pag, &hadidCur, hadidCur, 0L)) {
            padidCur = (PACMDRIVERID)hadidCur;

            for (uIndex = 0; (uIndex < padidCur->cFilterTags)
                              && !fStop; uIndex++) {
                uFilterTag =
                        (UINT)(padidCur->paFilterTagCache[uIndex].dwFilterTag);
                fDone = FALSE;
                hadid = NULL;
                while (!fDone && !IDriverGetNext(pag, &hadid, hadid, 0L)) {

                    //
                    //  same driver ?
                    //
                    if (hadid == hadidCur)
                        break;


                    //
                    //  for every previous driver 
                    //
                    padid = (PACMDRIVERID)hadid;

                    for (u = 0; u < padid->cFilterTags; u++) {
                        //
                        //  for every FilterTag in the driver 
                        //
                        if (uFilterTag ==
                                padid->paFilterTagCache[u].dwFilterTag) {
                            //
                            //  we have a match, but this was already given.
                            //
                            fDone = TRUE;
                            break;
                        }
                    }
                }

                if (!fDone) {
                    //
                    //  we have a Filter that has not been sent yet.
                    //
		    aftd.cbStruct = sizeof(aftd);
		    aftd.dwFilterTagIndex = uIndex;
		    mmr = IFilterTagDetails( pag, hadid, &aftd,
					     ACM_FILTERTAGDETAILSF_INDEX );
		    
		    if (MMSYSERR_NOERROR == mmr)
		    {
			mmr = IFilterEnum( hadid,
					   &aftd,
					   pafd,
					   fnCallback,
					   dwInstance );
		    }
		    
                    if( mmr == MMSYSERR_ERROR ) {
                        // Returned generic error to stop the enumeration.
                        mmr = MMSYSERR_NOERROR;
                        fStop = TRUE;
                        break;
                    }
                }
            }
        }

        LEAVE_LIST_SHARED;
    }


    //
    //
    //
    //
    return (mmr);
 }

#ifdef WIN32
#if TRUE    // defined(UNICODE)

typedef struct tIFILTERENUMCBINSTANCEW
{
    ACMFILTERENUMCBA            fnCallback;
    DWORD_PTR                   dwInstance;
    LPACMFILTERDETAILSA         pafd;

} IFILTERENUMCBINSTANCEW, *PIFILTERENUMCBINSTANCEW;

BOOL FNWCALLBACK IFilterEnumCallbackW
(
    HACMDRIVERID            hadid,
    LPACMFILTERDETAILSW     pafdW,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
)
{
    PIFILTERENUMCBINSTANCEW     pfi;
    BOOL                        f;

    pfi = (PIFILTERENUMCBINSTANCEW)dwInstance;

    memcpy(&pfi->pafd->dwFilterIndex,
           &pafdW->dwFilterIndex,
           FIELD_OFFSET(ACMFILTERDETAILSA, szFilter) -
           FIELD_OFFSET(ACMFILTERDETAILSA, dwFilterIndex));

    pfi->pafd->cbStruct = sizeof(*pfi->pafd);
    Iwcstombs(pfi->pafd->szFilter, pafdW->szFilter, sizeof(pfi->pafd->szFilter));

    f = pfi->fnCallback(hadid, pfi->pafd, pfi->dwInstance, fdwSupport);

    return (f);
}


MMRESULT ACMAPI acmFilterEnumA
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSA     pafd,
    ACMFILTERENUMCBA        fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT                    mmr;
    ACMFILTERDETAILSW           afdW;
    IFILTERENUMCBINSTANCEW      fi;

    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_WPOINTER(pafd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(*pafd) > pafd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterEnum: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd, pafd->cbStruct, MMSYSERR_INVALPARAM);

    afdW.cbStruct = sizeof(afdW);
    memcpy(&afdW.dwFilterIndex,
           &pafd->dwFilterIndex,
           FIELD_OFFSET(ACMFILTERDETAILSA, szFilter) -
           FIELD_OFFSET(ACMFILTERDETAILSA, dwFilterIndex));

    fi.fnCallback = fnCallback;
    fi.dwInstance = dwInstance;
    fi.pafd       = pafd;

    mmr = acmFilterEnumW(had, &afdW, IFilterEnumCallbackW, (DWORD_PTR)&fi, fdwEnum);

    return (mmr);
}
#else
MMRESULT ACMAPI acmFilterEnumW
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSW     pafd,
    ACMFILTERENUMCBW        fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\acmfmt.c ===
/****************************************************************************
 *
 *   acmfmt.c
 *
 *   Copyright (c) 1991-1998 Microsoft Corporation
 *
 *   This module provides the wave format enumeration and string API's.
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include "msacm.h"
#include "msacmdrv.h"
#include <stdlib.h>
#include "acmi.h"
#include "pcm.h"
#include "uchelp.h"
#include "debug.h"



/**************************************************************
 *
 *  Special case PCM enumeration for no codec case.
 *
 **************************************************************/


#define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))

//
//  array of _standard_ sample rates supported
//
//
static const UINT auFormatIndexToSampleRate[] =
{
    8000,
    11025,
    22050,
    44100
};

#define CODEC_MAX_SAMPLE_RATES  SIZEOF_ARRAY(auFormatIndexToSampleRate)

//
//
//
//
#define CODEC_MAX_CHANNELS      (MSPCM_MAX_CHANNELS)

//
//  array of bits per sample supported
//
//
static const UINT auFormatIndexToBitsPerSample[] =
{
    8,
    16
};

#define CODEC_MAX_BITSPERSAMPLE_PCM SIZEOF_ARRAY(auFormatIndexToBitsPerSample)




//
//  number of formats we enumerate per channels is number of sample rates
//  times number of channels times number of
//  (bits per sample) types.
//
#define CODEC_MAX_STANDARD_FORMATS_PCM  (CODEC_MAX_SAMPLE_RATES *   \
                                         CODEC_MAX_CHANNELS *       \
                                         CODEC_MAX_BITSPERSAMPLE_PCM)

//
//
//
#ifdef WIN32
WCHAR BCODE gszWavemapper[] = L"wavemapper";
#else
char  BCODE gszWavemapper[] = "wavemapper";
#endif






/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @types WAVEFORMATEX | The <t WAVEFORMATEX> structure defines the
 *      format of waveform data. Only format information common to all
 *      waveform data formats is included in this structure. For formats
 *      that require additional information, this structure is included
 *      as the first member in another structure, along with the additional
 *      information.
 *
 *  @field WORD | wFormatTag | Specifies the waveform format type. Format
 *      tags are registered with Microsoft for many compression algorithms.
 *      A complete list of format tags can be found in the MMREG.H header
 *      file available from Microsoft. For more information on format
 *      tags, contact Microsoft for availability of the Multimedia Developer
 *      Registration Kit:
 *
 *          Microsoft Corporation
 *          Advanced Consumer Technology
 *          Product Marketing
 *          One Microsoft Way
 *          Redmond, WA 98052-6399
 *
 *  @field WORD | nChannels | Specifies the number of channels in the
 *      waveform data. Monaural data uses one channel and stereo data uses
 *      two channels.
 *
 *  @field DWORD | nSamplesPerSec | Specifies the sample rate, in samples
 *      per second (Hertz), that each channel should be played or recorded.
 *      If <e WAVEFORMATEX.wFormatTag> is WAVE_FORMAT_PCM, then common values
 *      for <e WAVEFORMATEX.nSamplesPerSec> are 8.0 kHz, 11.025 kHz,
 *      22.05 kHz, and 44.1 kHz. For non-PCM formats, this member must be
 *      computed according to the manufacturer's specification of the format
 *      tag.
 *
 *  @field DWORD | nAvgBytesPerSec | Specifies the required average
 *      data-transfer rate, in bytes per second, for the format tag. If
 *      <e WAVEFORMATEX.wFormatTag> is WAVE_FORMAT_PCM, then
 *      <e WAVEFORMATEX.nAvgBytesPerSec> should be equal to the product
 *      of <e WAVEFORMATEX.nSamplesPerSec> and <e WAVEFORMATEX.nBlockAlign>.
 *      For non-PCM formats, this member must be computed according to the
 *      manufacturer's specification of the format tag.
 *
 *      Playback and record software can estimate buffer sizes using the
 *      <e WAVEFORMATEX.nAvgBytesPerSec> member.
 *
 *  @field WORD | nBlockAlign | Specifies the block alignment, in bytes.
 *      The block alignment is the minimum atomic unit of data for the
 *      <e WAVEFORMATEX.wFormatTag>. If <e WAVEFORMATEX.wFormatTag> is
 *      WAVE_FORMAT_PCM, then <e WAVEFORMATEX.nBlockAlign> should be equal
 *      to the product of <e WAVEFORMATEX.nChannels> and
 *      <e WAVEFORMATEX.wBitsPerSample> divided by 8 (bits per byte).
 *      For non-PCM formats, this member must be computed according to the
 *      manufacturer's specification of the format tag.
 *
 *      Playback and record software must process a multiple of
 *      <e WAVEFORMATEX.nBlockAlign> bytes of data at a time. Data written
 *      and read from a device must always start at the beginning of a
 *      block. For example, it is illegal to start playback of PCM data
 *      in the middle of a sample (that is, on a non-block-aligned boundary).
 *
 *  @field WORD | wBitsPerSample | Specifies the bits per sample for the
 *      <e WAVEFORMATEX.wFormatTag>. If <e WAVEFORMATEX.wFormatTag> is
 *      WAVE_FORMAT_PCM, then <e WAVEFORMATEX.wBitsPerSample> should be
 *      equal to 8 or 16. For non-PCM formats, this member must be set
 *      according to the manufacturer's specification of the format tag.
 *      Note that some compression schemes cannot define a value for
 *      <e WAVEFORMATEX.wBitsPerSample>, so this member can be zero.
 *
 *  @field WORD | cbSize | Specifies the size, in bytes, of extra format
 *      information appended to the end of the <t WAVEFORMATEX> structure.
 *      This information can be used by non-PCM formats to store extra
 *      attributes for the <e WAVEFORMATEX.wFormatTag>. If no extra
 *      information is required by the <e WAVEFORMATEX.wFormatTag>, then
 *      this member must be set to zero. Note that for WAVE_FORMAT_PCM
 *      formats (and only WAVE_FORMAT_PCM formats), this member is ignored.
 *
 *      An example of a format that uses extra information is the
 *      Microsoft Adaptive Delta Pulse Code Modulation (MS-ADPCM) format.
 *      The <e WAVEFORMATEX.wFormatTag> for MS-ADPCM is WAVE_FORMAT_ADPCM.
 *      The <e WAVEFORMATEX.cbSize> member will normally be set to 32.
 *      The extra information stored for WAVE_FORMAT_ADPCM is coefficient
 *      pairs required for encoding and decoding the waveform data.
 *
 *  @tagname tWAVEFORMATEX
 *
 *  @othertype WAVEFORMATEX FAR * | LPWAVEFORMATEX | A pointer to a
 *      <t WAVEFORMATEX> structure.
 *
 *  @xref <t WAVEFORMAT> <t PCMWAVEFORMAT> <t WAVEFILTER>
 *
 ****************************************************************************/


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api DWORD | acmGetVersion | This function returns the version number of the Audio
 *      Compression Manager (ACM).
 *
 *  @rdesc The version number is returned as a hexadecimal number of the form
 *      0xAABBCCCC, where AA is the major version number, BB is the minor
 *      version number, and CCCC is the build number.
 *
 *  @comm An application must verify that the ACM version is at least
 *      0x02000000 or greater before attempting to use any other ACM
 *      functions. Versions earlier than version 2.00 of the ACM only support
 *      <f acmGetVersion>. Also note that the build number (CCCC) is always
 *      zero for the retail (non-debug) version of the ACM. The debug
 *      version of the ACM will always return a non-zero value for the
 *      build number.
 *
 *  @ex To display the ACM version for a user, an application
 *      should use the following format (note that the values should be printed
 *      as unsigned decimals). |
 *      {
 *          DWORD   dw;
 *          char    ach[10];
 *
 *          dw = acmGetVersion();
 *          wsprintf(ach, "%u.%.02u", HIWORD(dw) >> 8, HIWORD(dw) & 0x00FF);
 *      }
 *
 ***************************************************************************/

DWORD ACMAPI acmGetVersion(void)
{
    //
    //	We only do pagFind instead of pagFindAndBoot cuz there's no real
    //	to get the driver's booted just for a version call.
    //
    if (NULL == pagFind())
    {
	DPF(1, "acmGetVersion: NULL pag!!!");
	return (0);
    }

    DPF(3, "acmGetVersion() called--returning Version %u.%.02u.%.03u",
        VERSION_MSACM_MAJOR,
        VERSION_MSACM_MINOR,
        VERSION_MSACM_BUILD);

    return (VERSION_MSACM);
}


//--------------------------------------------------------------------------;
//
//  MMRESULT IMetricsMaxSizeFormat
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag: Can be NULL if caller doesn't have one available
//	    to pass.
//
//	HACMOBJECT had:
//
//	LPDWORD pdwSize:
//
//  Return (MMRESULT):
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IMetricsMaxSizeFormat
(
    PACMGARB		pag,	    // NULL is OK.
    HACMDRIVER          had,        // NULL is OK.
    LPDWORD             pdwSize
)
{
    PACMDRIVERID	padid;
    DWORD		cbFormatSizeLargest;
    UINT		u;

    ASSERT( NULL != pdwSize );

    if (NULL == pag) {
	pag = pagFind();
    }
    ASSERT( NULL != pag );


    cbFormatSizeLargest = 0;

    if (NULL == had)
    {
	HACMDRIVERID	hadid;
	
	hadid = NULL;
	while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, 0L))
	{
	    padid = (PACMDRIVERID)hadid;

	    for (u=0; u<padid->cFormatTags; u++)
	    {
		if (padid->paFormatTagCache[u].cbFormatSize > cbFormatSizeLargest)
		{
		    cbFormatSizeLargest = padid->paFormatTagCache[u].cbFormatSize;
		}
	    }
	}
    }
    else
    {
        V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);

        if (TYPE_HACMDRIVERID == ((PACMDRIVER)had)->uHandleType)
        {
            padid = (PACMDRIVERID)had;
        }
        else
        {
            V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
            padid = (PACMDRIVERID)((PACMDRIVER)had)->hadid;
        }
	

	for (u=0; u<padid->cFormatTags; u++)
	{
	    if (padid->paFormatTagCache[u].cbFormatSize > cbFormatSizeLargest)
	    {
		cbFormatSizeLargest = padid->paFormatTagCache[u].cbFormatSize;
	    }
	}
    }


    *pdwSize = cbFormatSizeLargest;

    return ( 0 == cbFormatSizeLargest ? ACMERR_NOTPOSSIBLE : MMSYSERR_NOERROR );

}


//--------------------------------------------------------------------------;
//
//  MMRESULT IMetricsMaxSizeFilter
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag: Can be NULL if caller doesn't have one available
//	    to pass.
//
//	HACMOBJECT had:
//
//	LPDWORD pdwSize:
//
//  Return (MMRESULT):
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IMetricsMaxSizeFilter
(
    PACMGARB		pag,	    // NULL is OK.
    HACMDRIVER          had,        // NULL is OK.
    LPDWORD             pdwSize
)
{
    PACMDRIVERID	padid;
    DWORD		cbFilterSizeLargest;
    UINT		u;

    ASSERT( NULL != pdwSize );

    if (NULL == pag) {
	pag = pagFind();
    }
    ASSERT( NULL != pag );


    cbFilterSizeLargest = 0;

    if (NULL == had)
    {
	HACMDRIVERID	hadid;
	
	hadid = NULL;
	while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, 0L))
	{
	    padid = (PACMDRIVERID)hadid;

	    for (u=0; u<padid->cFilterTags; u++)
	    {
		if (padid->paFilterTagCache[u].cbFilterSize > cbFilterSizeLargest)
		{
		    cbFilterSizeLargest = padid->paFilterTagCache[u].cbFilterSize;
		}
	    }
	}
    }
    else
    {
        V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);

        if (TYPE_HACMDRIVERID == ((PACMDRIVER)had)->uHandleType)
        {
            padid = (PACMDRIVERID)had;
        }
        else
        {
            V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
            padid = (PACMDRIVERID)((PACMDRIVER)had)->hadid;
        }
	

	for (u=0; u<padid->cFilterTags; u++)
	{
	    if (padid->paFilterTagCache[u].cbFilterSize > cbFilterSizeLargest)
	    {
		cbFilterSizeLargest = padid->paFilterTagCache[u].cbFilterSize;
	    }
	}
    }


    *pdwSize = cbFilterSizeLargest;

    return ( 0 == cbFilterSizeLargest ? ACMERR_NOTPOSSIBLE : MMSYSERR_NOERROR );

}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmMetrics | This function returns various metrics for the Audio
 *      Compression Manager (ACM) or related ACM objects.
 *
 *  @parm HACMOBJ | hao | Specifies the ACM object to query for the metric
 *      specified in <p uMetric>. This argument may be NULL for some
 *      queries.
 *
 *  @parm UINT | uMetric | Specifies the metric index to be returned in
 *      <p pMetric>.
 *
 *      @flag ACM_METRIC_COUNT_DRIVERS | Specifies that the returned value is
 *      the total number of enabled global ACM drivers (of all support types)
 *      in the system. The <p hao> argument must be NULL for this metric
 *      index. The <p pMetric> argument must point to buffer of size equal
 *      to a DWORD.
 *
 *      @flag ACM_METRIC_COUNT_CODECS | Specifies that the returned value is
 *      the number of global ACM compressor or decompressor drivers in
 *      the system. The <p hao> argument must be NULL for this metric index.
 *      The <p pMetric> argument must point to a buffer of a size equal to a
 *      DWORD.
 *
 *      @flag ACM_METRIC_COUNT_CONVERTERS | Specifies that the returned value
 *      is the number of global ACM converter drivers in the system. The
 *      <p hao> argument must be NULL for this metric index. The <p pMetric>
 *      argument must point to a buffer of a size equal to a DWORD.
 *
 *      @flag ACM_METRIC_COUNT_FILTERS | Specifies that the returned value
 *      is the number of global ACM filter drivers in the system. The <p hao>
 *      argument must be NULL for this metric index. The <p pMetric> argument
 *      must point to buffer of size equal to a DWORD.
 *
 *      @flag ACM_METRIC_COUNT_DISABLED | Specifies that the returned value
 *      is the total number of global disabled ACM drivers (of all support
 *      types) in the system. The <p hao> argument must be NULL for this
 *      metric index. The <p pMetric> argument must point to a buffer of a size
 *      equal to a DWORD. The sum of the ACM_METRIC_COUNT_DRIVERS and
 *      ACM_METRIC_COUNT_DISABLED metrics is the total number of globally
 *      installed ACM drivers.
 *
 *      @flag ACM_METRIC_COUNT_HARDWARE | Specifies that the returned value
 *      is the number of global ACM hardware drivers in the system. The <p hao>
 *      argument must be NULL for this metric index. The <p pMetric> argument
 *      must point to buffer of size equal to a DWORD.
 *
 *      @flag ACM_METRIC_COUNT_LOCAL_DRIVERS | Specifies that the returned
 *      value is the total number of enabled local ACM drivers (of all
 *      support types) for the calling task. The <p hao> argument must be
 *      NULL for this metric index. The <p pMetric> argument must point to
 *      a buffer of a size equal to a DWORD.
 *
 *      @flag ACM_METRIC_COUNT_LOCAL_CODECS | Specifies that the returned
 *      value is the number of local ACM compressor and/or decompressor
 *      drivers for the calling task. The <p hao> argument must be NULL for
 *      this metric index. The <p pMetric> argument must point to a buffer of
 *      a size equal to a DWORD.
 *
 *      @flag ACM_METRIC_COUNT_LOCAL_CONVERTERS | Specifies that the returned
 *      value is the number of local ACM converter drivers for the calling
 *      task. The <p hao> argument must be NULL for this metric index. The
 *      <p pMetric> argument must point to a buffer of a size equal to a DWORD.
 *
 *      @flag ACM_METRIC_COUNT_LOCAL_FILTERS | Specifies that the returned
 *      value is the number of local ACM filter drivers for the calling
 *      task. The <p hao> argument must be NULL for this metric index. The
 *      <p pMetric> argument must point to a buffer of a size equal to a DWORD.
 *
 *      @flag ACM_METRIC_COUNT_LOCAL_DISABLED | Specifies that the returned
 *      value is the total number of local disabled ACM drivers, of all
 *      support types, for the calling task. The <p hao> argument must be
 *      NULL for this metric index. The <p pMetric> argument must point to a
 *      buffer of a size equal to a DWORD. The sum of the
 *      ACM_METRIC_COUNT_LOCAL_DRIVERS and ACM_METRIC_COUNT_LOCAL_DISABLED
 *      metrics is the total number of locally installed ACM drivers.
 *
 *      @flag ACM_METRIC_HARDWARE_WAVE_INPUT | Specifies that the returned
 *      value is the waveform input device identifier associated with the
 *      specified driver. The <p hao> argument must be a valid ACM driver
 *      identifier (<t HACMDRIVERID>) that supports the
 *      ACMDRIVERDETAILS_SUPPORTF_HARDWARE flag. If no waveform input device
 *      is associated with the driver, then MMSYSERR_NOTSUPPORTED is returned.
 *      The <p pMetric> argument must point to a buffer of a size equal to a
 *      DWORD.
 *
 *      @flag ACM_METRIC_HARDWARE_WAVE_OUTPUT | Specifies that the returned
 *      value is the waveform output device identifier associated with the
 *      specified driver. The <p hao> argument must be a valid ACM driver
 *      identifier (<t HACMDRIVERID>) that supports the
 *      ACMDRIVERDETAILS_SUPPORTF_HARDWARE flag. If no waveform output device
 *      is associated with the driver, then MMSYSERR_NOTSUPPORTED is returned.
 *      The <p pMetric> argument must point to a buffer of a size equal to a
 *      DWORD.
 *
 *      @flag ACM_METRIC_MAX_SIZE_FORMAT | Specifies that the returned value
 *      is the size of the largest <t WAVEFORMATEX> structure. If <p hao>
 *      is NULL, then the return value is the largest <t WAVEFORMATEX>
 *      structure in the system. If <p hao> identifies an open instance
 *      of an ACM driver (<t HACMDRIVER>) or an ACM driver identifier
 *      (<t HACMDRIVERID>), then the largest <t WAVEFORMATEX>
 *      structure for that driver is returned. The <p pMetric> argument must
 *      point to a buffer of a size equal to a DWORD. This metric is not allowed
 *      for an ACM stream handle (<t HACMSTREAM>).
 *
 *      @flag ACM_METRIC_MAX_SIZE_FILTER | Specifies that the returned value
 *      is the size of the largest <t WAVEFILTER> structure. If <p hao>
 *      is NULL, then the return value is the largest <t WAVEFILTER> structure
 *      in the system. If <p hao> identifies an open instance of an ACM
 *      driver (<t HACMDRIVER>) or an ACM driver identifier (<t HACMDRIVERID>),
 *      then the largest <t WAVEFILTER> structure for that driver is returned.
 *      The <p pMetric> argument must point to a buffer of a size equal to a
 *      DWORD. This metric is not allowed for an ACM stream handle
 *      (<t HACMSTREAM>).
 *
 *      @flag ACM_METRIC_DRIVER_SUPPORT | Specifies that the returned value
 *      is the <e ACMDRIVERDETAILS.fdwSupport> flags for the specified driver.
 *      The <p hao> argument must be a valid ACM driver identifier
 *      (<t HACMDRIVERID>). The <p pMetric> argument must point to a buffer of
 *      a size equal to a DWORD.
 *
 *      @flag ACM_METRIC_DRIVER_PRIORITY | Specifies that the returned value
 *      is the current priority for the specified driver.
 *      The <p hao> argument must be a valid ACM driver identifier
 *      (<t HACMDRIVERID>). The <p pMetric> argument must point to a buffer of
 *      a size equal to a DWORD.
 *
 *  @parm LPVOID | pMetric | Specifies a pointer to the buffer that will
 *      receive the metric details. The exact definition depends on the
 *      <p uMetric> index.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_NOTSUPPORTED | The <p uMetric> index is not supported.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The <p uMetric> index cannot be returned
 *      for the specified <p hao>.
 *
 *  @xref <f acmDriverDetails> <f acmFormatTagDetails> <f acmFormatDetails>
 *      <f acmFilterTagDetails> <f acmFilterDetails>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmMetrics
(
    HACMOBJ                 hao,
    UINT                    uMetric,
    LPVOID                  pMetric
)
{
    PACMGARB		pag;
    MMRESULT            mmr;
    DWORD               fdwSupport;
    DWORD               fdwEnum;
    PACMDRIVERID        padid;
    BOOL                f;
    HTASK               htask;


    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmMetrics: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }

    //
    //
    //
    if (NULL != hao)
    {
        V_HANDLE(hao, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);
    }

    //
    //
    //
    mmr = ACMERR_NOTPOSSIBLE;

    //
    //
    //
    switch (uMetric)
    {
        case ACM_METRIC_COUNT_LOCAL_DRIVERS:
        case ACM_METRIC_COUNT_DRIVERS:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            if (NULL != hao)
            {
acm_Metrics_Rip_Non_Null_Handle:

                DebugErr(DBF_ERROR, "acmMetrics: ACM object handle must be NULL for specified metric.");
                *((LPDWORD)pMetric) = 0L;
                mmr = MMSYSERR_INVALHANDLE;
                break;
            }

            //
            //  include all global enabled drivers
            //
            fdwSupport = 0L;
            if (ACM_METRIC_COUNT_LOCAL_DRIVERS == uMetric)
            {
                fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_LOCAL;
            }

            fdwEnum    = 0L;
            mmr = IDriverCount(pag, pMetric, fdwSupport, fdwEnum);
            break;

        case ACM_METRIC_COUNT_LOCAL_CODECS:
        case ACM_METRIC_COUNT_CODECS:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            if (NULL != hao)
            {
                goto acm_Metrics_Rip_Non_Null_Handle;
            }

            fdwSupport = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            if (ACM_METRIC_COUNT_LOCAL_CODECS == uMetric)
            {
                fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_LOCAL;
            }

            fdwEnum    = 0L;
            mmr = IDriverCount(pag, pMetric, fdwSupport, fdwEnum);
            break;

        case ACM_METRIC_COUNT_LOCAL_CONVERTERS:
        case ACM_METRIC_COUNT_CONVERTERS:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            if (NULL != hao)
            {
                goto acm_Metrics_Rip_Non_Null_Handle;
            }

            fdwSupport = ACMDRIVERDETAILS_SUPPORTF_CONVERTER;
            if (ACM_METRIC_COUNT_LOCAL_CONVERTERS == uMetric)
            {
                fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_LOCAL;
            }

            fdwEnum    = 0L;
            mmr = IDriverCount(pag, pMetric, fdwSupport, fdwEnum);
            break;

        case ACM_METRIC_COUNT_LOCAL_FILTERS:
        case ACM_METRIC_COUNT_FILTERS:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            if (NULL != hao)
            {
                goto acm_Metrics_Rip_Non_Null_Handle;
            }

            fdwSupport = ACMDRIVERDETAILS_SUPPORTF_FILTER;
            if (ACM_METRIC_COUNT_LOCAL_FILTERS == uMetric)
            {
                fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_LOCAL;
            }

            fdwEnum    = 0L;
            mmr = IDriverCount(pag, pMetric, fdwSupport, fdwEnum);
            break;

        case ACM_METRIC_COUNT_LOCAL_DISABLED:
        case ACM_METRIC_COUNT_DISABLED:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            if (NULL != hao)
            {
                goto acm_Metrics_Rip_Non_Null_Handle;
            }

            fdwSupport = ACMDRIVERDETAILS_SUPPORTF_DISABLED;
            if (ACM_METRIC_COUNT_LOCAL_DISABLED == uMetric)
            {
                fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_LOCAL;
            }

            fdwEnum    = ACM_DRIVERENUMF_DISABLED;
            mmr = IDriverCount(pag, pMetric, fdwSupport, fdwEnum);
            break;


        case ACM_METRIC_COUNT_HARDWARE:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            if (NULL != hao)
            {
                goto acm_Metrics_Rip_Non_Null_Handle;
            }

            fdwSupport = ACMDRIVERDETAILS_SUPPORTF_HARDWARE;
            fdwEnum    = 0L;
            mmr = IDriverCount(pag, pMetric, fdwSupport, fdwEnum);
            break;


        case ACM_METRIC_HARDWARE_WAVE_INPUT:
        case ACM_METRIC_HARDWARE_WAVE_OUTPUT:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            *((LPDWORD)pMetric) = (DWORD)-1L;

            V_HANDLE(hao, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

            f = (ACM_METRIC_HARDWARE_WAVE_INPUT == uMetric);
            mmr = IDriverGetWaveIdentifier((HACMDRIVERID)hao, pMetric, f);
            break;


        case ACM_METRIC_MAX_SIZE_FORMAT:

            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            mmr = IMetricsMaxSizeFormat( pag, (HACMDRIVER)hao, (LPDWORD)pMetric );

            break;


        case ACM_METRIC_MAX_SIZE_FILTER:

            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            mmr = IMetricsMaxSizeFilter( pag, (HACMDRIVER)hao, (LPDWORD)pMetric );

            break;


        case ACM_METRIC_DRIVER_SUPPORT:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            *((LPDWORD)pMetric) = 0L;

            V_HANDLE(hao, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

            mmr = IDriverSupport((HACMDRIVERID)hao, pMetric, TRUE);
            break;

        case ACM_METRIC_DRIVER_PRIORITY:
            V_WPOINTER(pMetric, sizeof(DWORD), MMSYSERR_INVALPARAM);

            *((LPDWORD)pMetric) = 0L;

            V_HANDLE(hao, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);


            //
            //  Restore the priorities, just in case some other instance
            //  has re-written them.  We don't do this if someone has
            //  the priorities lock, even if it's us!
            //
	    if (!threadQueryInListShared(pag))
	    {
		htask = GetCurrentTask();
		if( IDriverLockPriority( pag, htask, ACMPRIOLOCK_GETLOCK ) )
		{
		    ENTER_LIST_EXCLUSIVE;
            if( IDriverPrioritiesRestore(pagFind()) ) { // Something changed!
                IDriverBroadcastNotify( pag );
            }
		    LEAVE_LIST_EXCLUSIVE;

                    IDriverLockPriority( pag, htask, ACMPRIOLOCK_RELEASELOCK );
		}
            }


            padid = (PACMDRIVERID)hao;

            *((LPDWORD)pMetric) = (UINT)padid->uPriority;
            mmr = MMSYSERR_NOERROR;
            break;

        default:
            mmr = MMSYSERR_NOTSUPPORTED;
            break;
    }

    return (mmr);
}

//--------------------------------------------------------------------------;
//
//  MMRESULT IFormatTagDetails
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//	HACMDRIVERID hadid:
//
//      LPACMFORMATTAGDETAILS pafd:
//
//	DWORD fdwDetails:
//
//  Return (UINT):
//
//  History:
//      08/31/94    frankye
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL IFormatTagDetails
(
    PACMGARB		    pag,
    HACMDRIVERID	    hadid,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD                   fdwDetails
)
{
    PACMDRIVERID            padid;
    UINT                    u;
    DWORD                   fdwQuery;
    MMRESULT		    mmr;

    ASSERT( NULL != pag );
    ASSERT( NULL != hadid );


    padid	= (PACMDRIVERID)hadid;
    fdwQuery	= (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails);
    mmr		= ACMERR_NOTPOSSIBLE;
	
    switch (fdwQuery)
    {
	case ACM_FORMATTAGDETAILSF_FORMATTAG:
	{
	    for (u=0; u<padid->cFormatTags; u++)
	    {
		if (padid->paFormatTagCache[u].dwFormatTag == paftd->dwFormatTag)
		{
		    mmr = MMSYSERR_NOERROR;
		    break;
		}
	    }
	    break;
	}

	case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
	case ACM_FORMATTAGDETAILSF_INDEX:
	    mmr = MMSYSERR_NOERROR;
	    break;
    }

    //
    //
    //
    if (MMSYSERR_NOERROR == mmr)
    {
	EnterHandle((HACMDRIVERID)padid);
	mmr = (MMRESULT)IDriverMessageId((HACMDRIVERID)padid,
					 ACMDM_FORMATTAG_DETAILS,
					 (LPARAM)(LPVOID)paftd,
					 fdwDetails);
	LeaveHandle((HACMDRIVERID)padid);
    }
	

    if (MMSYSERR_NOERROR != mmr)
    {
	return (mmr);
    }

    switch (paftd->dwFormatTag)
    {
	case WAVE_FORMAT_UNKNOWN:
	    DebugErr(DBF_ERROR, "IDriverGetFormatTags(): driver returned format tag 0!");
	    return (MMSYSERR_ERROR);

	case WAVE_FORMAT_PCM:
	    if ('\0' != paftd->szFormatTag[0])
	    {
		DebugErr1(DBF_WARNING, "IDriverGetFormatTags(): driver returned custom PCM format tag name (%s)! ignoring it!", (LPSTR)paftd->szFormatTag);
	    }

#if defined(WIN32) && !defined(UNICODE)
	    LoadStringW(pag->hinst,
			IDS_FORMAT_TAG_PCM,
			paftd->szFormatTag,
			SIZEOFW(paftd->szFormatTag));
#else
	    LoadString(pag->hinst,
		       IDS_FORMAT_TAG_PCM,
		       paftd->szFormatTag,
		       SIZEOF(paftd->szFormatTag));
#endif
	    break;

	case WAVE_FORMAT_DEVELOPMENT:
	    DebugErr(DBF_WARNING, "IDriverGetFormatTags(): driver returned DEVELOPMENT format tag--do not ship this way.");
	    break;

    }

    return(mmr);

}


/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @types ACMFORMATTAGDETAILS | The <t ACMFORMATTAGDETAILS> structure
 *      details a wave format tag for an Audio Compression Manager (ACM)
 *      driver.
 *
 *  @field DWORD | cbStruct | Specifies the size in bytes of the
 *      <t ACMFORMATTAGDETAILS> structure. This member must be initialized
 *      before calling the <f acmFormatTagDetails> or <f acmFormatTagEnum>
 *      functions. The size specified in this member must be large enough to
 *      contain the base <t ACMFORMATTAGDETAILS> structure. When the
 *      <f acmFormatTagDetails> function returns, this member contains the
 *      actual size of the information returned. The returned information
 *      will never exceed the requested size.
 *
 *  @field DWORD | dwFormatTagIndex | Specifies the index of the format tag
 *      for which details will be retrieved. The index ranges from zero to one
 *      less than the number of format tags supported by an ACM driver. The
 *      number of format tags supported by a driver is contained in the
 *      <e ACMDRIVERDETAILS.cFormatTags> member of the <t ACMDRIVERDETAILS>
 *      structure. The <e ACMFORMATTAGDETAILS.dwFormatTagIndex> member is
 *      only used when querying format tag details on a driver by index;
 *      otherwise, this member should be zero.
 *
 *  @field DWORD | dwFormatTag | Specifies the wave format tag that the
 *      <t ACMFORMATTAGDETAILS> structure describes. This member is used
 *      as an input for the ACM_FORMATTAGDETAILSF_FORMATTAG and
 *      ACM_FORMATTAGDETAILSF_LARGESTSIZE query flags. This member is always
 *      returned if the <f acmFormatTagDetails>  function is successful. This member
 *      should be set to WAVE_FORMAT_UNKNOWN for all other query flags.
 *
 *  @field DWORD | cbFormatSize | Specifies the largest total size in bytes
 *      of a wave format of the <e ACMFORMATTAGDETAILS.dwFormatTag> type.
 *      For example, this member will be 16 for WAVE_FORMAT_PCM and 50 for
 *      WAVE_FORMAT_ADPCM.
 *
 *  @field DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the format tag. These flags are identical to the
 *      <e ACMDRIVERDETAILS.fdwSupport> flags of the <t ACMDRIVERDETAILS>
 *      structure. This argument may be some combination of the following
 *      values and refer to what operations the driver supports with the
 *      format tag:
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags where one of
 *      the tags is the specified format tag. For example, if a driver
 *      supports compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM,
 *      then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      specified format tag. For example, if a driver supports resampling
 *      of WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes). For example, if a driver supports volume
 *      or echo operations on the specified format tag, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions with the specified format tag.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output of the specified format tag
 *      through a waveform device. An application should use <f acmMetrics>
 *      with the ACM_METRIC_HARDWARE_WAVE_INPUT and
 *      ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform
 *      device identifiers associated with the supporting ACM driver.
 *
 *  @field DWORD | cStandardFormats | Specifies the number of standard
 *      formats of the <e ACMFORMATTAGDETAILS.dwFormatTag> type; that is, the
 *      combination of all sample rates, bits per sample, channels, and so on.
 *      This value can specify all formats supported by the driver, but not necessarily.
 *
 *  @field char | szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS] |
 *      Specifies a string that describes the <e ACMFORMATTAGDETAILS.dwFormatTag>
 *      type. This string is always returned if the <f acmFormatTagDetails>
 *      function is successful.
 *
 *  @xref <f acmFormatTagDetails> <f acmFormatTagEnum>
 *
 ****************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmFormatTagDetails | This function queries the Audio Compression
 *      Manager (ACM) for details on a specific wave format tag.
 *
 *  @parm HACMDRIVER | had | Optionally specifies an ACM driver to query
 *      for wave format tag details. If this argument is NULL, then the
 *      ACM uses the details from the first suitable ACM driver. Note that
 *      an application must specify a valid <t HACMDRIVER> or <t HACMDRIVERID>
 *      when using the ACM_FORMATTAGDETAILSF_INDEX query type. Driver
 *      identifiers for disabled drivers are not allowed.
 *
 *  @parm LPACMFORMATTAGDETAILS | paftd | Specifies a pointer to the
 *      <t ACMFORMATTAGDETAILS> structure that is to receive the format
 *      tag details.
 *
 *  @parm DWORD | fdwDetails | Specifies flags for getting the details.
 *
 *      @flag ACM_FORMATTAGDETAILSF_INDEX | Indicates that a format tag index
 *      was given in the <e ACMFORMATTAGDETAILS.dwFormatTagIndex> member of
 *      the <t ACMFORMATTAGDETAILS> structure. The format tag and details
 *      will be returned in the structure defined by <p paftd>. The index
 *      ranges from zero to one less than the <e ACMDRIVERDETAILS.cFormatTags>
 *      member returned in the <t ACMDRIVERDETAILS> structure for an ACM
 *      driver. An application must specify a driver handle (<p had>) when
 *      retrieving format tag details with this flag.
 *
 *      @flag ACM_FORMATTAGDETAILSF_FORMATTAG | Indicates that a format tag
 *      was given in the <e ACMFORMATTAGDETAILS.dwFormatTag> member of
 *      the <t ACMFORMATTAGDETAILS> structure. The format tag details will
 *      be returned in the structure defined by <p paftd>. If an application
 *      specifies an ACM driver handle (<p had>), then details on the format
 *      tag will be returned for that driver. If an application specifies
 *      NULL for <p had>, then the ACM finds the first acceptable driver
 *      to return the details.
 *
 *      @flag ACM_FORMATTAGDETAILSF_LARGESTSIZE | Indicates that the details
 *      on the format tag with the largest format size in bytes is to be
 *      returned. The <e ACMFORMATTAGDETAILS.dwFormatTag> member must either
 *      be WAVE_FORMAT_UNKNOWN or the format tag to find the largest size
 *      for. If an application specifies an ACM driver handle (<p had>), then
 *      details on the largest format tag will be returned for that driver.
 *      If an application specifies NULL for <p had>, then the ACM finds an
 *      acceptable driver with the largest format tag requested to return
 *      the details.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The details requested are not available.
 *
 *  @xref <f acmDriverDetails> <f acmDriverOpen> <f acmFormatDetails>
 *      <f acmFormatTagEnum> <f acmFilterTagDetails>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFormatTagDetails
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD                   fdwDetails
)
{
    PACMGARB		    pag;
    PACMDRIVER              pad;
    HACMDRIVERID            hadid;
    PACMDRIVERID            padid;
    DWORD                   fdwQuery;
    MMRESULT		    mmr;
    UINT                    u;

    pad		= NULL;
    padid	= NULL;

    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFormatTagDetails: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }


    //
    //
    //
    V_DFLAGS(fdwDetails, ACM_FORMATTAGDETAILSF_VALID, acmFormatTagDetails, MMSYSERR_INVALFLAG);
    V_WPOINTER(paftd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(ACMFORMATTAGDETAILS) > paftd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatTagDetails: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(paftd, paftd->cbStruct, MMSYSERR_INVALPARAM);

    if (0L != paftd->fdwSupport)
    {
        DebugErr(DBF_ERROR, "acmFormatTagDetails: fdwSupport member must be set to zero.");
        return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    //
    fdwQuery = (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails);

    switch (fdwQuery)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            //
            //  we don't (currently) support index based enumeration across
            //  all drivers... may never support this. so validate the
            //  handle and fail if not valid (like NULL).
            //
            V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);

            if (WAVE_FORMAT_UNKNOWN != paftd->dwFormatTag)
            {
                DebugErr(DBF_ERROR, "acmFormatTagDetails: dwFormatTag must be WAVE_FORMAT_UNKNOWN for index query.");
                return (MMSYSERR_INVALPARAM);
            }
            break;

        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            if (WAVE_FORMAT_UNKNOWN == paftd->dwFormatTag)
            {
                DebugErr(DBF_ERROR, "acmFormatTagDetails: dwFormatTag cannot be WAVE_FORMAT_UNKNOWN for tag query.");
                return (MMSYSERR_INVALPARAM);
            }
            break;

        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
            break;


        //
        //  we don't (currently) support the requested query type--so return
        //  not supported.
        //
        default:
            DebugErr(DBF_ERROR, "acmFormatTagDetails: unknown query type specified.");
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //
    //
    if (NULL != had)
    {
        V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);

        pad = (PACMDRIVER)had;
        if (TYPE_HACMDRIVERID == pad->uHandleType)
        {
            padid = (PACMDRIVERID)pad;
	    pad	  = NULL;

            if (0 != (ACMDRIVERID_DRIVERF_DISABLED & padid->fdwDriver))
            {
                DebugErr1(DBF_ERROR, "acmFormatTagDetails: driver (%.04Xh) is disabled.", padid);
                return (MMSYSERR_NOTENABLED);
            }
        }
        else
        {
            V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
            padid = (PACMDRIVERID)pad->hadid;
        }
    }

    if (NULL == padid)
    {
	PACMDRIVERID    padidT;
	DWORD		cbFormatSizeLargest;

	padidT		    = NULL;
	cbFormatSizeLargest = 0;
	hadid = NULL;
		
	ENTER_LIST_SHARED;

	while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, 0L))
	{
	    padidT = (PACMDRIVERID)hadid;
	
	    switch (fdwQuery)
	    {
		case ACM_FORMATTAGDETAILSF_FORMATTAG:
		{
		    for (u=0; u<padidT->cFormatTags; u++)
		    {
			if (padidT->paFormatTagCache[u].dwFormatTag == paftd->dwFormatTag)
			{
			    padid = padidT;
			    break;
			}
		    }
		    break;
		}

		case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
		{
		    for (u=0; u<padidT->cFormatTags; u++)
		    {
			if (WAVE_FORMAT_UNKNOWN != paftd->dwFormatTag)
			{
			    if (padidT->paFormatTagCache[u].dwFormatTag != paftd->dwFormatTag)
			    {
				continue;
			    }
			}
			if (padidT->paFormatTagCache[u].cbFormatSize > cbFormatSizeLargest)
			{
			    cbFormatSizeLargest = padidT->paFormatTagCache[u].cbFormatSize;
			    padid = padidT;
			}
		    }
		    break;
		}

		default:
		{
		    DPF(0, "!acmFormatTagDetails(): unknown query type got through param validation?!?!");
		}
	    }
	}

	LEAVE_LIST_SHARED;
    }

    if (NULL != padid)
    {

	mmr = IFormatTagDetails(pag, (HACMDRIVERID)padid, paftd, fdwDetails);
	
    }
    else
    {
	//
	//  Caller didn't pass us a driver, nor could we find a driver.
	//  Unless caller was requesting a specific format tag other than
	//  PCM, let's go ahead and return PCM.
	//

        if ((ACM_FORMATTAGDETAILSF_FORMATTAG == fdwQuery) &&
            (WAVE_FORMAT_PCM != paftd->dwFormatTag))
        {
            return (ACMERR_NOTPOSSIBLE);
        }

        paftd->dwFormatTagIndex = 0;
        paftd->dwFormatTag      = WAVE_FORMAT_PCM;
        paftd->cbFormatSize     = sizeof(PCMWAVEFORMAT);
        paftd->fdwSupport       = 0;
        paftd->cStandardFormats = CODEC_MAX_STANDARD_FORMATS_PCM;
	
#if defined(WIN32) && !defined(UNICODE)
	LoadStringW(pag->hinst,
		    IDS_FORMAT_TAG_PCM,
		    paftd->szFormatTag,
		    SIZEOFW(paftd->szFormatTag));
#else
	LoadString(pag->hinst,
		   IDS_FORMAT_TAG_PCM,
		   paftd->szFormatTag,
		   SIZEOF(paftd->szFormatTag));
#endif
	
        mmr = MMSYSERR_NOERROR;
    }

    return(mmr);

} // acmFormatTagDetails()


#ifdef WIN32
#if TRUE    // defined(UNICODE)
MMRESULT ACMAPI acmFormatTagDetailsA
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSA  paftd,
    DWORD                   fdwDetails
)
{
    MMRESULT                mmr;
    ACMFORMATTAGDETAILSW    aftdW;

    V_WPOINTER(paftd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(*paftd) > paftd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatTagDetails: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(paftd, paftd->cbStruct, MMSYSERR_INVALPARAM);

    aftdW.cbStruct = sizeof(aftdW);
    memcpy(&aftdW.dwFormatTagIndex,
           &paftd->dwFormatTagIndex,
           FIELD_OFFSET(ACMFORMATTAGDETAILSA, szFormatTag) -
           FIELD_OFFSET(ACMFORMATTAGDETAILSA, dwFormatTagIndex));

    mmr = acmFormatTagDetailsW(had, &aftdW, fdwDetails);
    if (MMSYSERR_NOERROR == mmr)
    {
        memcpy(&paftd->dwFormatTagIndex,
               &aftdW.dwFormatTagIndex,
               FIELD_OFFSET(ACMFORMATTAGDETAILSA, szFormatTag) -
               FIELD_OFFSET(ACMFORMATTAGDETAILSA, dwFormatTagIndex));

        paftd->cbStruct = min(paftd->cbStruct, sizeof(*paftd));
        Iwcstombs(paftd->szFormatTag, aftdW.szFormatTag, sizeof(paftd->szFormatTag));
    }

    return (mmr);
}
#else
MMRESULT ACMAPI acmFormatTagDetailsW
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSW  paftd,
    DWORD                   fdwDetails
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif


//--------------------------------------------------------------------------;
//
//  UINT IFormatDetailsToString
//
//  Description:
//
//
//  Arguments:
//      LPACMFORMATDETAILS pafd:
//
//  Return (UINT):
//
//  History:
//      08/01/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

TCHAR BCODE gszIntl[]           = TEXT("Intl");
TCHAR BCODE gszIntlList[]       = TEXT("sList");
TCHAR BCODE gszIntlDecimal[]    = TEXT("sDecimal");
TCHAR       gchIntlList         = ',';
TCHAR       gchIntlDecimal      = '.';

UINT FNLOCAL IFormatDetailsToString
(
    LPACMFORMATDETAILS      pafd
)
{
    PACMGARB	    pag;
    TCHAR           ach[ACMFORMATDETAILS_FORMAT_CHARS];
    TCHAR           szChannels[24];
    UINT            u;
    LPWAVEFORMATEX  pwfx;
    UINT            uBits;
    UINT            uIds;


    //
    //
    //
    //
{
    TCHAR       ach[2];

    ach[0] = gchIntlList;
    ach[1] = '\0';

    GetProfileString(gszIntl, gszIntlList, ach, ach, sizeof(ach));
    gchIntlList = ach[0];

    ach[0] = gchIntlDecimal;
    ach[1] = '\0';

    GetProfileString(gszIntl, gszIntlDecimal, ach, ach, sizeof(ach));
    gchIntlDecimal = ach[0];
}

    //
    //
    //
    pag = pagFind();
    if (NULL == pag)
    {
	return (0);
    }

    pwfx = pafd->pwfx;

    uBits = pwfx->wBitsPerSample;
#if 0
    uBits = (UINT)(pwfx->nAvgBytesPerSec * 8 /
                    pwfx->nSamplesPerSec /
                    pwfx->nChannels);
#endif

    if ((1 == pwfx->nChannels) || (2 == pwfx->nChannels))
    {
        if (0 == uBits)
            uIds = IDS_FORMAT_FORMAT_MONOSTEREO_0BIT;
        else
            uIds = IDS_FORMAT_FORMAT_MONOSTEREO;

        LoadString(pag->hinst, uIds, ach, SIZEOF(ach));

        u = (1 == pwfx->nChannels) ? IDS_FORMAT_CHANNELS_MONO : IDS_FORMAT_CHANNELS_STEREO;
        LoadString(pag->hinst, u, szChannels, SIZEOF(szChannels));

        if (0 == uBits)
	{
#if defined(WIN32) && !defined(UNICODE)
	    u = Iwsprintfmbstowcs(SIZEOFW(pafd->szFormat),
#else
	    u = wsprintf(
#endif
			 pafd->szFormat, ach,
			 pwfx->nSamplesPerSec / 1000,
			 gchIntlDecimal,
			 (UINT)(pwfx->nSamplesPerSec % 1000),
			 gchIntlList,
			 (LPSTR)szChannels);
        }
        else
        {
#if defined(WIN32) && !defined(UNICODE)
	    u = Iwsprintfmbstowcs(SIZEOFW(pafd->szFormat),
#else
	    u = wsprintf(
#endif
			 pafd->szFormat, ach,
			 pwfx->nSamplesPerSec / 1000,
			 gchIntlDecimal,
			 (UINT)(pwfx->nSamplesPerSec % 1000),
			 gchIntlList,
			 uBits,
			 gchIntlList,
			 (LPSTR)szChannels);
        }
    }
    else
    {
        if (0 == uBits)
            uIds = IDS_FORMAT_FORMAT_MULTICHANNEL_0BIT;
        else
            uIds = IDS_FORMAT_FORMAT_MULTICHANNEL;

        LoadString(pag->hinst, uIds, ach, SIZEOF(ach));

        if (0 == uBits)
        {
#if defined(WIN32) && !defined(UNICODE)
	    //	
	    u = Iwsprintfmbstowcs(SIZEOFW(pafd->szFormat),
#else
	    u = wsprintf(
#endif
			 pafd->szFormat, ach,
			 pwfx->nSamplesPerSec / 1000,
			 gchIntlDecimal,
			 (UINT)(pwfx->nSamplesPerSec % 1000),
			 gchIntlList,
			 pwfx->nChannels);
        }
        else
        {
#if defined(WIN32) && !defined(UNICODE)
	    u = Iwsprintfmbstowcs(SIZEOFW(pafd->szFormat),
#else
	    u = wsprintf(
#endif
			 pafd->szFormat, ach,
			 pwfx->nSamplesPerSec / 1000,
			 gchIntlDecimal,
			 (UINT)(pwfx->nSamplesPerSec % 1000),
			 gchIntlList,
			 uBits,
			 gchIntlList,
			 pwfx->nChannels);
        }

    }

    return (u);
} // IFormatDetailsToString()


/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @types ACMFORMATDETAILS | The <t ACMFORMATDETAILS> structure details a
 *      wave format for a specific format tag for an Audio Compression
 *      Manager (ACM) driver.
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t ACMFORMATDETAILS> structure. This member must be initialized
 *      before calling the <f acmFormatDetails> or <f acmFormatEnum>
 *      functions. The size specified in this member must be large enough to
 *      contain the base <t ACMFORMATDETAILS> structure. When the
 *      <f acmFormatDetails> function returns, this member contains the
 *      actual size of the information returned. The returned information
 *      will never exceed the requested size.
 *
 *  @field DWORD | dwFormatIndex | Specifies the index of the format
 *      to retrieve details for. The index ranges from zero to one
 *      less than the number of standard formats supported by an ACM driver
 *      for a format tag. The number of standard formats supported by a
 *      driver for a format tag is contained in the
 *      <e ACMFORMATTAGDETAILS.cStandardFormats> member of the
 *      <t ACMFORMATTAGDETAILS> structure. The
 *      <e ACMFORMATDETAILS.dwFormatIndex> member is only used when querying
 *      standard format details on a driver by index; otherwise, this member
 *      should be zero. Also note that this member will be set to zero
 *      by the ACM when an application queries for details on a format. In
 *      other words, this member is only used as an input argument and is
 *      never returned by the ACM or an ACM driver.
 *
 *  @field DWORD | dwFormatTag | Specifies the wave format tag that the
 *      <t ACMFORMATDETAILS> structure describes. This member is used
 *      as an input for the ACM_FORMATDETAILSF_INDEX query flag.  For
 *      the ACM_FORMATDETAILSF_FORMAT query flag, this member
 *      must be initialized to the same format tag as the
 *      <e ACMFORMATDETAILS.pwfx> member specifies.  This member is always
 *      returned if the <f acmFormatDetails> is successful. This member
 *      should be set to WAVE_FORMAT_UNKNOWN for all other query flags.
 *
 *  @field DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the specified format. These flags are identical to the
 *      <e ACMDRIVERDETAILS.fdwSupport> flags of the <t ACMDRIVERDETAILS>
 *      structure. This argument can be a combination of the following
 *      values and indicates which operations the driver supports for the
 *      format tag:
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags for the
 *      specified format. For example, if a driver supports compression
 *      from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specifed
 *      format, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      same format tag while using the specified format. For example, if a
 *      driver supports resampling of WAVE_FORMAT_PCM to the specified
 *      format, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (which modifies data without changing any
 *      format attributes) with the specified format. For example,
 *      if a driver supports volume or echo operations on WAVE_FORMAT_PCM,
 *      then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions with the specified format.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output of the specified format
 *      through a waveform device. An application should use <f acmMetrics>
 *      with the ACM_METRIC_HARDWARE_WAVE_INPUT and
 *      ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform
 *      device identifiers associated with the supporting ACM driver.
 *
 *  @field LPWAVEFORMATEX | pwfx | Specifies a pointer to a <t WAVEFORMATEX>
 *      data structure that will receive the format details. This structure requires no initialization
 *      by the application unless the ACM_FORMATDETAILSF_FORMAT flag is specified
 *      to <f acmFormatDetails>. In this case, the<e WAVEFORMATEX.wFormatTag> must be
 *      equal to the <e ACMFORMATDETAILS.dwFormatTag> of the <t ACMFORMATDETAILS>
 *      structure.
 *
 *  @field DWORD | cbwfx | Specifies the size, in bytes, available for
 *      the <e ACMFORMATDETAILS.pwfx> to receive the format details. The
 *      <f acmMetrics> and <f acmFormatTagDetails> functions can be used to
 *      determine the maximum size required for any format available for the
 *      specified driver (or for all installed ACM drivers).
 *
 *  @field char | szFormat[ACMFORMATDETAILS_FORMAT_CHARS] |
 *      Specifies a string that describes the format for the
 *      <e ACMFORMATDETAILS.dwFormatTag> type. This string is always returned
 *      if the <f acmFormatDetails> function is successful.
 *
 *  @xref <f acmFormatDetails> <f acmFormatEnum> <f acmFormatTagDetails>
 *      <f acmFormatTagEnum>
 *
 ****************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmFormatDetails | This function queries the Audio Compression
 *      Manager (ACM) for details on format for a specific wave format tag.
 *
 *  @parm HACMDRIVER | had | Optionally specifies an ACM driver to query
 *      for wave format details for a format tag. If this argument is NULL,
 *      then the ACM uses the details from the first suitable ACM driver.
 *
 *  @parm LPACMFORMATDETAILS | pafd | Specifies a pointer to the
 *      <t ACMFORMATDETAILS> structure that is to receive the format
 *      details for the given format tag.
 *
 *  @parm DWORD | fdwDetails | Specifies flags for getting the wave format tag details.
 *
 *      @flag ACM_FORMATDETAILSF_INDEX | Indicates that a format index for
 *      the format tag was given in the <e ACMFORMATDETAILS.dwFormatIndex>
 *      member of the <t ACMFORMATDETAILS> structure. The format details
 *      will be returned in the structure defined by <p pafd>. The index
 *      ranges from zero to one less than the
 *      <e ACMFORMATTAGDETAILS.cStandardFormats> member returned in the
 *      <t ACMFORMATTAGDETAILS> structure for a format tag. An application
 *      must specify a driver handle (<p had>) when retrieving
 *      format details with this flag. Refer to the description for the
 *      <t ACMFORMATDETAILS> structure for information on what members
 *      should be initialized before calling this function.
 *
 *      @flag ACM_FORMATDETAILSF_FORMAT | Indicates that a <t WAVEFORMATEX>
 *      structure pointed to by the <e ACMFORMATDETAILS.pwfx> member of the
 *      <t ACMFORMATDETAILS> structure was given and the remaining details
 *      should be returned. The <e ACMFORMATDETAILS.dwFormatTag> member
 *      of the <t ACMFORMATDETAILS> structure must be initialized to the same format
 *      tag as the <e ACMFORMATDETAILS.pwfx> member specifies. This
 *      query type can be used to get a string description of an arbitrary
 *      format structure. If an application specifies an ACM driver handle
 *      (<p had>), then details on the format will be returned for that
 *      driver. If an application specifies NULL for <p had>, then the ACM
 *      finds the first acceptable driver to return the details.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The details requested are not available.
 *
 *  @xref <f 