lease(This)	\
    (This)->lpVtbl -> Release(This)


#define IMTSCall_OnCall(This)	\
    (This)->lpVtbl -> OnCall(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMTSCall_OnCall_Proxy( 
    IMTSCall __RPC_FAR * This);


void __RPC_STUB IMTSCall_OnCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMTSCall_INTERFACE_DEFINED__ */


#ifndef __IMTSActivity_INTERFACE_DEFINED__
#define __IMTSActivity_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMTSActivity
 * at Thu Sep 11 16:03:09 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IMTSActivity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372AF0-CAE7-11CF-BE81-00AA00A2FA25")
    IMTSActivity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SynchronousCall( 
            /* [in] */ IMTSCall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AsyncCall( 
            /* [in] */ IMTSCall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AsyncCallWithAdvice( 
            /* [in] */ IMTSCall __RPC_FAR *pCall,
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual void STDMETHODCALLTYPE BindToCurrentThread( void) = 0;
        
        virtual void STDMETHODCALLTYPE UnbindFromThread( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMTSActivityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMTSActivity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMTSActivity __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMTSActivity __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SynchronousCall )( 
            IMTSActivity __RPC_FAR * This,
            /* [in] */ IMTSCall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AsyncCall )( 
            IMTSActivity __RPC_FAR * This,
            /* [in] */ IMTSCall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AsyncCallWithAdvice )( 
            IMTSActivity __RPC_FAR * This,
            /* [in] */ IMTSCall __RPC_FAR *pCall,
            /* [in] */ REFCLSID rclsid);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *BindToCurrentThread )( 
            IMTSActivity __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *UnbindFromThread )( 
            IMTSActivity __RPC_FAR * This);
        
        END_INTERFACE
    } IMTSActivityVtbl;

    interface IMTSActivity
    {
        CONST_VTBL struct IMTSActivityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMTSActivity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMTSActivity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMTSActivity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMTSActivity_SynchronousCall(This,pCall)	\
    (This)->lpVtbl -> SynchronousCall(This,pCall)

#define IMTSActivity_AsyncCall(This,pCall)	\
    (This)->lpVtbl -> AsyncCall(This,pCall)

#define IMTSActivity_AsyncCallWithAdvice(This,pCall,rclsid)	\
    (This)->lpVtbl -> AsyncCallWithAdvice(This,pCall,rclsid)

#define IMTSActivity_BindToCurrentThread(This)	\
    (This)->lpVtbl -> BindToCurrentThread(This)

#define IMTSActivity_UnbindFromThread(This)	\
    (This)->lpVtbl -> UnbindFromThread(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMTSActivity_SynchronousCall_Proxy( 
    IMTSActivity __RPC_FAR * This,
    /* [in] */ IMTSCall __RPC_FAR *pCall);


void __RPC_STUB IMTSActivity_SynchronousCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMTSActivity_AsyncCall_Proxy( 
    IMTSActivity __RPC_FAR * This,
    /* [in] */ IMTSCall __RPC_FAR *pCall);


void __RPC_STUB IMTSActivity_AsyncCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMTSActivity_AsyncCallWithAdvice_Proxy( 
    IMTSActivity __RPC_FAR * This,
    /* [in] */ IMTSCall __RPC_FAR *pCall,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB IMTSActivity_AsyncCallWithAdvice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IMTSActivity_BindToCurrentThread_Proxy( 
    IMTSActivity __RPC_FAR * This);


void __RPC_STUB IMTSActivity_BindToCurrentThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IMTSActivity_UnbindFromThread_Proxy( 
    IMTSActivity __RPC_FAR * This);


void __RPC_STUB IMTSActivity_UnbindFromThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMTSActivity_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\reftrace.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reftrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging reference count problems. This module uses the generic
    TRACE_LOG facility in tracelog.h.

    Ref count trace logs can be dumped via the !inetdbg.ref command
    in either NTSD or CDB.

Author:

    Keith Moore (keithmo)        01-May-1997

Revision History:

--*/


#ifndef _REFTRACE_H_
#define _REFTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


#include <tracelog.h>


//
// This is the number of stack backtrace values captured in each
// trace log entry. This value is chosen to make the log entry
// exactly twelve dwords long, making it a bit easier to interpret
// from within the debugger without the debugger extension.
//

#define REF_TRACE_LOG_STACK_DEPTH   9

// No-op value for the Context1,2,3 parameters of WriteRefTraceLogEx
#define REF_TRACE_EMPTY_CONTEXT ((PVOID) -1)


//
// This defines the entry written to the trace log.
//

typedef struct _REF_TRACE_LOG_ENTRY {

    LONG NewRefCount;
    PVOID Context;
    PVOID Context1;
    PVOID Context2;
    PVOID Context3;
    DWORD Thread;
    PVOID Stack[REF_TRACE_LOG_STACK_DEPTH];

} REF_TRACE_LOG_ENTRY, *PREF_TRACE_LOG_ENTRY;


//
// Manipulators.
//

PTRACE_LOG
CreateRefTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    );

VOID
DestroyRefTraceLog(
    IN PTRACE_LOG Log
    );

LONG
__cdecl
WriteRefTraceLog(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context
    );

LONG
__cdecl
WriteRefTraceLogEx(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context,
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Context3
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _REFTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\sharelok.h ===
#ifndef __SHARELOCK_H__
#define __SHARELOCK_H__

//////////////////////////////////////////////////////////////////////
//
//   The standard include files.
//
//   The standard include files setup a consistent environment
//   for all of the modules in a program.  The structure of each
//   header file is as follows:
//      1. Standard include files.
//      2. Include files for inherited classes.
//      3. Constants exported from the class.
//      4. Data structures exported from the class.
//      5. Class specification.
//      6. Inline functions.
//   Sections that are not required are omitted.
//
//////////////////////////////////////////////////////////////////////

// #include "Global.h"
// #include "NewEx.h"
// #include "Standard.h"
// #include "System.h"

#include <irtlmisc.h>

typedef int SBIT32;

//////////////////////////////////////////////////////////////////////
//
//   Sharelock and Semaphore locking.
//
//   This class provides a very conservative locking scheme.
//   The assumption behind the code is that locks will be
//   held for a very short time.  A lock can be obtained in
//   either exclusive mode or shared mode.  If the lock is not
//   available the caller waits by spinning or if that fails
//   by sleeping.
//
//////////////////////////////////////////////////////////////////////

class IRTL_DLLEXP CSharelock
{ 
	private:

		// internally used constants

		enum Internal
		{
			//   The Windows NT kernel requires a maximum wakeup count when
			//   creating a semaphore.
			m_MaxShareLockUsers      = 256
		};

        //
        //   Private data.
        //
        volatile LONG                 m_lExclusive;
        volatile LONG                 m_lTotalUsers;

		SBIT32                        m_lMaxSpins;
		SBIT32                        m_lMaxUsers;
        HANDLE                        m_hSemaphore;
        volatile LONG                 m_lWaiting;

#ifdef _DEBUG

        //
        //   Counters for debugging builds.
        //
        volatile LONG                 m_lTotalExclusiveLocks;
        volatile LONG                 m_lTotalShareLocks;
        volatile LONG                 m_lTotalSleeps;
        volatile LONG                 m_lTotalSpins;
        volatile LONG                 m_lTotalTimeouts;
        volatile LONG                 m_lTotalWaits;
#endif

    public:
        //
        //   Public functions.
        //
        CSharelock( SBIT32 lNewMaxSpins = 4096, SBIT32 lNewMaxUsers = 256 );

        inline SBIT32 ActiveUsers( void ) { return (SBIT32) m_lTotalUsers; }

        inline void ChangeExclusiveLockToSharedLock( void );

        inline BOOLEAN ChangeSharedLockToExclusiveLock( SBIT32 lSleep = INFINITE );

        inline BOOLEAN ClaimExclusiveLock( SBIT32 lSleep = INFINITE );

        inline BOOLEAN ClaimShareLock( SBIT32 lSleep = INFINITE );

        inline void ReleaseExclusiveLock( void );

        inline void ReleaseShareLock( void );

        BOOLEAN UpdateMaxSpins( SBIT32 lNewMaxSpins );

        BOOLEAN UpdateMaxUsers( SBIT32 lNewMaxUsers );

        ~CSharelock( void );


	private:
        //
        //   Private functions.
        //
        BOOLEAN SleepWaitingForLock( SBIT32 lSleep );

        BOOLEAN WaitForExclusiveLock( SBIT32 lSleep );

        BOOLEAN WaitForShareLock( SBIT32 lSleep );

        void WakeAllSleepers( void );      

    private:
        //
        //   Disabled operations.
        //
        CSharelock( const CSharelock & Copy );

        void operator=( const CSharelock & Copy );
};

/********************************************************************/
/*                                                                  */
/*   Change an exclusive lock to a shread lock.                     */
/*                                                                  */
/*   Downgrade the existing exclusive lock to a shared lock.        */
/*                                                                  */
/********************************************************************/

inline void CSharelock::ChangeExclusiveLockToSharedLock( void )
{
	(void) InterlockedDecrement( (LPLONG) & m_lExclusive );
    
#ifdef _DEBUG
    
	(void) InterlockedIncrement( (LPLONG) & m_lTotalShareLocks );
#endif
}

/********************************************************************/
/*                                                                  */
/*   Change a shared lock to an exclusive lock.                     */
/*                                                                  */
/*   Upgrade the existing shared lock to an exclusive lock.         */
/*                                                                  */
/********************************************************************/

inline BOOLEAN CSharelock::ChangeSharedLockToExclusiveLock( SBIT32 lSleep )
{
	(void) InterlockedIncrement( (LPLONG) & m_lExclusive );
    
	if ( m_lTotalUsers != 1 )
    {
		if ( ! WaitForExclusiveLock( lSleep ) )
        { return FALSE; }
    }
#ifdef _DEBUG
    
	(void) InterlockedIncrement( (LPLONG) & m_lTotalExclusiveLocks );
#endif
    
    return TRUE;
}


//////////////////////////////////////////////////////////////////////
//
//   Claim an exclusive lock.
//
//   Claim an exclusive lock if available else wait or exit.
//
//////////////////////////////////////////////////////////////////////

inline BOOLEAN CSharelock::ClaimExclusiveLock( SBIT32 lSleep )
{
	(void) InterlockedIncrement( (LPLONG) & m_lExclusive );
	(void) InterlockedIncrement( (LPLONG) & m_lTotalUsers );

	if ( m_lTotalUsers != 1 )
	{
		if ( ! WaitForExclusiveLock( lSleep ) )
		{ 
			return FALSE; 
		}
	}
#ifdef _DEBUG

	InterlockedIncrement( (LPLONG) & m_lTotalExclusiveLocks );
#endif

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Claim a shared lock.
//
//   Claim a shared lock if available else wait or exit.
//
//////////////////////////////////////////////////////////////////////

inline BOOLEAN CSharelock::ClaimShareLock( SBIT32 lSleep )
{
	(void) InterlockedIncrement( (LPLONG) & m_lTotalUsers );

	if ( (m_lExclusive > 0) || (m_lTotalUsers > m_lMaxUsers) )
	{
		if ( ! WaitForShareLock( lSleep ) )
		{ 
			return FALSE; 
		}
	}
#ifdef _DEBUG

	InterlockedIncrement( (LPLONG) & m_lTotalShareLocks );
#endif

	return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Release an exclusive lock.
//
//   Release an exclusive lock and if needed wakeup any sleepers.
//
//////////////////////////////////////////////////////////////////////

inline void CSharelock::ReleaseExclusiveLock( void )
{
	(void) InterlockedDecrement( (LPLONG) & m_lTotalUsers );
	(void) InterlockedDecrement( (LPLONG) & m_lExclusive );

    if ( m_lWaiting > 0 )
    { 
		WakeAllSleepers(); 
	}
}

//////////////////////////////////////////////////////////////////////
//
//   Release a shared lock.
//
//   Release a shared lock and if needed wakeup any sleepers.
//
//////////////////////////////////////////////////////////////////////

inline void CSharelock::ReleaseShareLock( void )
{
	(void) InterlockedDecrement( (LPLONG) & m_lTotalUsers );

    if ( m_lWaiting > 0 )
    { 
		WakeAllSleepers(); 
	}
}

#endif // __SHARELOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\package.h ===
//*****************************************************************************
//
// Microsoft Viper 97 (Microsoft Confidential)
// Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// Project:		MTxEx.DLL
// Module:		Package.H
// Description:	IMTSPackage et al header
// Author:		wilfr
// Create:		03/13/97
//-----------------------------------------------------------------------------
// Notes:
//
//	none
//
//-----------------------------------------------------------------------------
// Issues:
//
//	UNDONE: these methods accept a flag indicating the system package. Determining the
//			system package should be done by a lookup in our catalog instead.
//
//-----------------------------------------------------------------------------
// Architecture:
//
//  This class is a result of a CoCI -- must be done from the MTA or CoCI will fail
//
//******************************************************************************
#ifndef _Package_H_
#define _Package_H_

#include <objbase.h>


//
// IMTSPackageControl callback interface (NOTE: this is a local interface only and therefore
//												does not require HRESULTs as retvals.
//
DEFINE_GUID( IID_IMTSPackageControl, 0x51372af1,
			 0xcae7, 0x11cf, 0xbe, 0x81, 0x00, 0xaa, 0x00, 0xa2, 0xfa, 0x25);

DECLARE_INTERFACE_( IMTSPackageControl, IUnknown )
{
	// called when shutdown idle time has lapsed
	STDMETHOD_(void, IdleTimeExpiredForShutdown)( THIS ) PURE;

	// called when adminstrator executes "Shutdown all server processes" from MTS Explorer.
	STDMETHOD_(void, ForcedShutdownRequested)( THIS ) PURE;
};


//
// IMTSPackage
//
DEFINE_GUID( IID_IMTSPackage, 0x51372af2,
			 0xcae7, 0x11cf, 0xbe, 0x81, 0x00, 0xaa, 0x00, 0xa2, 0xfa, 0x25);

DECLARE_INTERFACE_( IMTSPackage, IUnknown )
{
	STDMETHOD(LoadPackageByGUID)( THIS_ GUID guidPackage ) PURE;
	STDMETHOD(LoadPackageByName)( THIS_ BSTR bstrPackage ) PURE;
	STDMETHOD(Run)( THIS_ IMTSPackageControl* pControl ) PURE;
	STDMETHOD(Shutdown)( THIS_ BOOL bForced ) PURE;
};


//
// IThreadEvents
//
DEFINE_GUID( IID_IThreadEvents, 0x51372af9,
			 0xcae7, 0x11cf, 0xbe, 0x81, 0x00, 0xaa, 0x00, 0xa2, 0xfa, 0x25);

DECLARE_INTERFACE_( IThreadEvents, IUnknown )
{
	STDMETHOD(OnStartup)(THIS) PURE;
	STDMETHOD(OnShutdown)(THIS) PURE;
};


//
// IThreadEventSource
//
DEFINE_GUID( IID_IThreadEventSource, 0x51372afa,
			 0xcae7, 0x11cf, 0xbe, 0x81, 0x00, 0xaa, 0x00, 0xa2, 0xfa, 0x25);

DECLARE_INTERFACE_( IThreadEventSource, IUnknown )
{
	// Register a thread startup callback
	STDMETHOD(RegisterThreadEventSink)(THIS_ IThreadEvents* psink) PURE;
};

//
// IFailfastControl
//
DEFINE_GUID( IID_IFailfastControl, 0x51372af8,
			 0xcae7, 0x11cf, 0xbe, 0x81, 0x00, 0xaa, 0x00, 0xa2, 0xfa, 0x25);

DECLARE_INTERFACE_( IFailfastControl, IUnknown )
{
	// gets configuration for runtime handling of application errors 
	STDMETHOD(GetApplFailfast)( THIS_ BOOL* bFailfast ) PURE;

	// sets configuration for runtime handling of application errors 
	STDMETHOD(SetApplFailfast)( THIS_ BOOL bFailfast ) PURE;

};


//
// INonMTSActivation (51372afb-cae7-11cf-be81-00aa00a2fa25)
//
DEFINE_GUID( IID_INonMTSActivation, 0x51372afb, 
			0xcae7, 0x11cf, 0xbe, 0x81, 0x00, 0xaa, 0x00, 0xa2, 0xfa, 0x25);

DECLARE_INTERFACE_( INonMTSActivation, IUnknown )
{
	// TRUE (default) allows MTS to CoCI using CLSCTX_SERVER vs. CLSCTX_INPROC_SERVER only
	STDMETHOD(OutOfProcActivationAllowed)( THIS_ BOOL bOutOfProcOK ) PURE;
};


//
// IImpersonationControl (51372aff-cae7-11cf-be81-00aa00a2fa25)
//
DEFINE_GUID( IID_IImpersonationControl, 0x51372aff, 
			0xcae7, 0x11cf, 0xbe, 0x81, 0x00, 0xaa, 0x00, 0xa2, 0xfa, 0x25);

DECLARE_INTERFACE_( IImpersonationControl, IUnknown )
{
	// FALSE (default) tells us that our base clients may use impersonation
	STDMETHOD(ClientsImpersonate)( THIS_ BOOL bClientsImpersonate ) PURE;
};


// CLSID_MTSPackage
DEFINE_GUID( CLSID_MTSPackage, 0x51372af3, 
			 0xcae7, 0x11cf, 0xbe, 0x81, 0x00, 0xaa, 0x00, 0xa2, 0xfa, 0x25);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\spxinfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    spxinfo.h

Abstract:

    Common constants, etc, for SPX service location

Author:

    Richard L Firth (rfirth) 18-Sep-1995

Revision History:

    18-Sep-1995 rfirth
        Created

--*/

#if !defined(_SPXINFO_)
#define _SPXINFO_

#define INTERNET_SERVICE_SAP_ID         0x64e
#define GATEWAY_SERVER_SECURITY_NAME    "GatewayServerApp"
#define GATEWAY_SERVER_SECURITY         L"GatewayServerApp"
#define GATEWAY_SERVER_SECURITY_AUTH_ID 10
#define GATEWAY_SERVER_PORT_TEXT        "47"
#define GATEWAY_SERVER_PORT             L"47"

#endif // _SPXINFO_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\smalprox.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

/*
    smalprox.h

    This module contains the small proxy common code

    FILE HISTORY:
        Johnl       04-Apr-1995     Created

*/

#ifndef _SMALPROX_H_
#define _SMALPROX_H_

#include <urlutil.h>
#include <dirlist.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef BOOL (*PFN_INTERNET_PROTOCOL)(
    IN  struct _INET_DATA_CONTEXT * pIC,
    OUT VOID *                      pBuffer,
    IN  DWORD                       cbBuffer,
    OUT DWORD *                     pcbWritten
    );

#define INET_STATE_UNINITIALIZED    0
#define INET_STATE_OPENNED          1
#define INET_STATE_DONE             2

typedef struct _INET_DATA_CONTEXT
{
    HINTERNET             hServer;         // InternetConnect handle
    HINTERNET             hRequest;        // Protocol request handle
    PFN_INTERNET_PROTOCOL pfnProtocol;
    DWORD                 dwServiceType;   // Protocol Type
    DWORD                 dwState;

    URL_DESCRIPTOR        UrlDesc;         // Various URL bits and pieces
    CHAR *                pszUrlData;      // Allocated buffer for UrlDesc

    //
    //  If an error occurred on open, dwLastError records the error
    //  so we can feed back a nice error during InternetReadFile
    //
    //  pszErrAPI will point to the API which generated the error
    //

    DWORD          dwLastError;

    //
    //  When ftp or gopher return extended errors, we store the text here.
    //  It's inline because we're not guaranteed a CloseInternetData will
    //  happen after an error
    //

    CHAR           achExtError[1024];
    DWORD dwErrorTextLength;
    DWORD dwErrorTextLeft;
    DWORD dwErrorCategory;

#if DBG
    CHAR *         pszErrAPI;
#endif

} INET_DATA_CONTEXT, *LPINET_DATA_CONTEXT;

//
//  Macro for conditionally setting the error API string
//

#if DBG
#define RECORD_ERROR_API( pIC, API )    (pIC)->pszErrAPI = (#API)
#else
#define RECORD_ERROR_API( pIC, API )
#endif

BOOL
OpenInternetData(
    IN HINTERNET               hInternet,
    IN OUT CHAR *              pszHttpProxyReq,
    IN     DWORD               cbHttpProxyReq,
    IN     VOID *              pvOptionalData,
    IN     DWORD               cbOptionalData,
    IN OUT INET_DATA_CONTEXT * pIC,
    IN     BOOL                fCheckHeaders
    );

BOOL
ReadInternetData(
    IN  INET_DATA_CONTEXT * pInetContext,
    OUT VOID *              pBuffer,
    IN  DWORD               cbBuffer,
    OUT DWORD *             pcbRead
    );

#if 0
BOOL
WriteInternetData(
    IN  INET_DATA_CONTEXT * pInetContext,
    IN  VOID *              pBuffer,
    IN  DWORD               cbBuffer,
    OUT DWORD *             pcbWritten
    );
#endif

BOOL
CloseInternetData(
    IN     INET_DATA_CONTEXT * pInetContext
    );

BOOL
FormatInternetError(
    IN  DWORD               dwWin32Error,
    IN  CHAR *              pszErrorAPI OPTIONAL,
    OUT VOID *              pBuffer,
    IN  DWORD               cbBuffer,
    OUT DWORD *             pcbRead,
    IN  const CHAR *        pszErrorMessage OPTIONAL
    );

#ifdef __cplusplus
}
#endif

#endif //_SMALPROX_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\stktrace.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stktrace.h

Abstract:

    This module contains public declarations and definitions for capturing
    stack back traces.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#ifndef _STKTRACE_H_
#define _STKTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


USHORT
NTAPI
IISCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _STKTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\perfutil.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      perfutil.h

   Abstract:

      This file supports routines used to parse and create Performance Monitor
       Data structures, used by all the Internet Services product.

   Author:

       Murali R. Krishnan    ( MuraliK )    16-Nov-1995  
         From the common code for perfmon interface (Russ Blake's).

   Environment:

      User Mode

   Project:
   
       Internet Services Common Runtime code

   Revision History:

       Sophia Chung  (sophiac)  05-Nov-1996
         Added supports for mutlitple instances.

--*/

# ifndef _PERFUTIL_H_
# define _PERFUTIL_H_

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
#define QWORD_MULTIPLE(x) ((((x)+sizeof(LONGLONG)-1)/sizeof(LONGLONG))*sizeof(LONGLONG))


/************************************************************
 *     Symbolic Constants
 ************************************************************/


#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4


/************************************************************
 *     Function Declarations
 ************************************************************/

DWORD
GetQueryType (IN LPWSTR lpwszValue);

BOOL
IsNumberInUnicodeList (IN DWORD dwNumber, IN LPWSTR lpwszUnicodeList);

VOID
MonBuildInstanceDefinition(
    OUT PERF_INSTANCE_DEFINITION *pBuffer,
    OUT PVOID *pBufferNext,
    IN DWORD ParentObjectTitleIndex,
    IN DWORD ParentObjectInstance,
    IN DWORD UniqueID,
    IN LPWSTR Name
    );

# endif // _PERFUTIL_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\pudebug.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        pudebug.h

   Abstract:

      This module declares the DEBUG_PRINTS object helpful in
       testing the programs

   Author:

      Murali R. Krishnan    ( MuraliK )    14-Dec-1994
      Modified to include a and other functions ( 22-Dec-1994)

   Revision History:
      MuraliK  16-May-1995   Added function to read debug flags.
      MuraliK  12-Sept-1996  Added functions to dump the output.
      JasAndre Dec-1998      Replaced tracing mechanism with WMI Eventing

--*/

# ifndef _PUDEBUG_H_
# define _PUDEBUG_H_


/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

#ifndef _NO_TRACING_
#include <wmistr.h>
#include <evntrace.h>
#endif

# ifndef dllexp
# define dllexp   __declspec( dllexport)
# endif // dllexp

/***********************************************************
 *    Macros
 ************************************************************/

#ifdef _NO_TRACING_
enum  PRINT_REASONS {
    PrintNone     = 0x0,   // Nothing to be printed
    PrintError    = 0x1,   // An error message
    PrintWarning  = 0x2,   // A  warning message
    PrintLog      = 0x3,   // Just logging. Indicates a trace of where ...
    PrintMsg      = 0x4,   // Echo input message
    PrintCritical = 0x5,   // Print and Exit
    PrintAssertion= 0x6    // Printing for an assertion failure
  };


enum  DEBUG_OUTPUT_FLAGS {
    DbgOutputNone     = 0x0,            // None
    DbgOutputKdb      = 0x1,            // Output to Kernel Debugger
    DbgOutputLogFile  = 0x2,            // Output to LogFile
    DbgOutputTruncate = 0x4,            // Truncate Log File if necessary
    DbgOutputStderr   = 0x8,            // Send output to std error
    DbgOutputBackup   = 0x10,           // Make backup of debug file ?
    DbgOutputAll      = 0xFFFFFFFF      // All the bits set.
  };
#endif // _NO_TRACING_


# define MAX_LABEL_LENGTH                 ( 100)

// The WINNT defined tests are required so that the ui\setup\osrc project still
// compiles
#if !defined(_NO_TRACING_) && (defined(_WINNT_) || defined(WINNT))

#define REG_TRACE_IIS                   TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Tracing\\IIS")
#define REG_TRACE_IIS_ENABLED           TEXT("EnableTracing")
#define REG_TRACE_IIS_ODS               TEXT("AlwaysODS")

#define REG_TRACE_IIS_LOG_FILE_NAME     TEXT("LogFileName")
#define REG_TRACE_IIS_LOG_SESSION_NAME  TEXT("LogSessionName")
#define REG_TRACE_IIS_LOG_BUFFER_SIZE   TEXT("BufferSize")
#define REG_TRACE_IIS_LOG_MIN_BUFFERS   TEXT("MinBuffers")
#define REG_TRACE_IIS_LOG_MAX_BUFFERS   TEXT("MaxBuffers")
#define REG_TRACE_IIS_LOG_MAX_FILESIZE  TEXT("MaxFileSize")
#define REG_TRACE_IIS_LOG_REAL_TIME     TEXT("EnableRealTimeMode")
#define REG_TRACE_IIS_LOG_IN_MEMORY     TEXT("EnableInMemoryMode")
#define REG_TRACE_IIS_LOG_USER_MODE     TEXT("EnableUserMode")

#define REG_TRACE_IIS_ACTIVE            TEXT("Active")
#define REG_TRACE_IIS_CONTROL           TEXT("ControlFlags")
#define REG_TRACE_IIS_LEVEL             TEXT("Level")
#define REG_TRACE_IIS_GUID              L"Guid"

// Structure used to send trace information to the WMI eventing mechanism
typedef struct _TRACE_INFO
{
    EVENT_TRACE_HEADER TraceHeader;             // WMI Event header required at start of trace info
    MOF_FIELD MofFields[5];                     // Trace info. A MOF_FIELD is a {pointer, size} pair
} TRACE_INFO, *PTRACE_INFO;

/*++
  class DEBUG_PRINTS

  This class is responsible for printing messages to log file / kernel debugger

  Currently the class supports only member functions for <ANSI> char.
   ( not unicode-strings).

--*/

typedef struct _DEBUG_PRINTS {

    CHAR         m_rgchLabel[MAX_LABEL_LENGTH]; // Name of the module
    BOOL         m_bBreakOnAssert;              // Control flag for DBG_ASSERT
    GUID         m_guidControl;                 // Identifying GUID for the module
    int          m_iControlFlag;                // Control flag used for IF_DEBUG macros
    int          *m_piErrorFlags;               // Bit mapped error flag used for DBGINFO etc macros
    TRACEHANDLE  m_hRegistration;               // WMI identifying handle for the module
    TRACEHANDLE  m_hLogger;                     // WMI logfile handle for the module

} DEBUG_PRINTS, *LPDEBUG_PRINTS;


// Structure used by IISRTL to maintain the list of GUID's that can be 
// registered with the WMI eventing system
typedef struct _SGuidList {
    enum {
        TRACESIG = (('T') | ('R' << 8) | ('C' << 16) | ('$' << 24)),
    } dwSig;

    LIST_ENTRY   m_leEntry;
    DEBUG_PRINTS m_dpData;
    int          m_iDefaultErrorLevel;
    int          m_iInitializeFlags;
} SGuidList, *PSGuidList;

#else // _NO_TRACING_

typedef struct _DEBUG_PRINTS {

    CHAR         m_rgchLabel[MAX_LABEL_LENGTH];
    CHAR         m_rgchLogFilePath[MAX_PATH];
    CHAR         m_rgchLogFileName[MAX_PATH];
    HANDLE       m_LogFileHandle;
    HANDLE       m_StdErrHandle;
    BOOL         m_fInitialized;
    DWORD        m_dwOutputFlags;
    BOOL         m_fBreakOnAssert;

} DEBUG_PRINTS, FAR * LPDEBUG_PRINTS;

#endif // _NO_TRACING_


// The WINNT defined tests are required so that the ui\setup\osrc project still
// compiles
#if !defined(_NO_TRACING_) && (defined(_WINNT_) || defined(WINNT))

dllexp VOID
PuInitiateDebug(VOID);
dllexp VOID
PuUninitiateDebug(VOID);

LPDEBUG_PRINTS
PuCreateDebugPrintsObject(
    IN const char * pszPrintLabel,
    IN GUID *       ControlGuid,
    IN int *        ErrorFlags,
    IN int          DefaultControlFlags);

//
// frees the debug prints object and closes any file if necessary.
//  Returns NULL on success or returns pDebugPrints on failure.
//
VOID
PuDeleteDebugPrintsObject(
   IN OUT LPDEBUG_PRINTS  pDebugPrints
   );

VOID
PuDbgPrint(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFormat,
   ...);                               // arglist

dllexp VOID
PuDbgPrintW(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const WCHAR *        pszFormat,
   ...);                               // arglist

/*++
  PuDbgDump() does not do any formatting of output.
  It just dumps the given message onto the debug destinations.
--*/
VOID
PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   );

dllexp VOID
PuDbgDumpW(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const WCHAR *        pszDump
   );

//
// PuDbgAssertFailed() *must* be __cdecl to properly capture the
// thread context at the time of the failure.
//

VOID
__cdecl
PuDbgAssertFailed(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszExpression);

VOID
PuDbgCaptureContext (
    OUT PCONTEXT ContextRecord
    );

#else // _NO_TRACING_

LPDEBUG_PRINTS
PuCreateDebugPrintsObject(
   IN const char * pszPrintLabel,
   IN DWORD  dwOutputFlags);

//
// frees the debug prints object and closes any file if necessary.
//  Returns NULL on success or returns pDebugPrints on failure.
//
LPDEBUG_PRINTS
PuDeleteDebugPrintsObject(
   IN OUT LPDEBUG_PRINTS  pDebugPrints);


VOID
PuDbgPrint(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFormat,
   ...);                               // arglist

/*++
  PuDbgDump() does not do any formatting of output.
  It just dumps the given message onto the debug destinations.
--*/
VOID
PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   );

//
// PuDbgAssertFailed() *must* be __cdecl to properly capture the
// thread context at the time of the failure.
//

VOID
__cdecl
PuDbgAssertFailed(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszExpression,
   IN const char *         pszMessage);

VOID
PuDbgCaptureContext (
    OUT PCONTEXT ContextRecord
    );

dllexp 
VOID
PuDbgPrintCurrentTime(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum
    );

dllexp 
VOID
PuSetDbgOutputFlags(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN DWORD                dwFlags);

dllexp 
DWORD
PuGetDbgOutputFlags(
   IN const LPDEBUG_PRINTS       pDebugPrints);


//
// Following functions return Win32 error codes.
// NO_ERROR if success
//

dllexp 
DWORD
PuOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFileName,
   IN const char *         pszPathForFile);

dllexp 
DWORD
PuReOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints);

dllexp 
DWORD
PuCloseDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints);

dllexp 
DWORD
PuLoadDebugFlagsFromReg(IN HKEY hkey, IN DWORD dwDefault, IN LPDEBUG_PRINTS pDebugPrints);

dllexp 
DWORD
PuLoadDebugFlagsFromRegStr(IN LPCSTR pszRegKey, IN DWORD dwDefault, IN LPDEBUG_PRINTS pDebugPrints);

dllexp 
DWORD
PuSaveDebugFlagsInReg(IN HKEY hkey, IN DWORD dwDbg);


# define PuPrintToKdb( pszOutput)    \
                    if ( pszOutput != NULL)   {   \
                        OutputDebugString( pszOutput);  \
                    } else {}

#endif // _NO_TRACING_


# ifdef __cplusplus
};
# endif // __cplusplus

// begin_user_unmodifiable
// The WINNT defined tests are required so that the ui\setup\osrc project still
// compiles
#if !defined(_NO_TRACING_) && (defined(_WINNT_) || defined(WINNT))

// The following enumerations are the values supplied by the user to select
// a particular logging level
#define DEBUG_LEVEL_INFO        3
#define DEBUG_LEVEL_WARN        2
#define DEBUG_LEVEL_ERROR       1

// The following flags are used internally to track what level of tracing we 
// are currently using. Bitmapped for extensibility.
#define DEBUG_FLAG_ODS          0x00000001
#define DEBUG_FLAG_INFO         0x00000002
#define DEBUG_FLAG_WARN         0x00000004
#define DEBUG_FLAG_ERROR        0x00000008
// The top 8 bits are reserved for control fields, sometimes we need to mask
// these out
#define DEBUG_FLAG_LEVEL_MASK   (DEBUG_FLAG_ODS | DEBUG_FLAG_INFO | DEBUG_FLAG_WARN | DEBUG_FLAG_ERROR)
// Deferred means that we have initialized with WMI but not actually loaded the
// module yet, so save the state for later
#define DEBUG_FLAG_DEFERRED_START 0x4000000
// Initialize means that we want to register this with WMI when we start up
#define DEBUG_FLAG_INITIALIZE   0x8000000

// The following are used internally to determine whether to log or not based 
// on what the current state is
#define DEBUG_FLAGS_INFO        (DEBUG_FLAG_ODS | DEBUG_FLAG_INFO)
#define DEBUG_FLAGS_WARN        (DEBUG_FLAG_ODS | DEBUG_FLAG_INFO | DEBUG_FLAG_WARN)
#define DEBUG_FLAGS_ERROR       (DEBUG_FLAG_ODS | DEBUG_FLAG_INFO | DEBUG_FLAG_WARN | DEBUG_FLAG_ERROR)

#define DEBUG_FLAGS_ANY         (DEBUG_FLAG_INFO | DEBUG_FLAG_WARN | DEBUG_FLAG_ERROR)

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
DEBUG_PRINTS *g_pDebug;         // define a global debug variable

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
int g_fErrorFlags;              // define a global error level variable

# if DBG

// For the CHK build we want ODS enabled. For an explanation of these flags see 
// the comment just after the definition of DBG_CONTEXT
# define DECLARE_DEBUG_PRINTS_OBJECT()                      \
         DEBUG_PRINTS  *  g_pDebug = NULL;                  \
         int              g_fErrorFlags = DEBUG_FLAG_ODS;

#else // !DBG

# define DECLARE_DEBUG_PRINTS_OBJECT()          \
         DEBUG_PRINTS  *  g_pDebug = NULL;      \
         int              g_fErrorFlags = 0;

#endif // !DBG

// The DEFAULT_TRACE_FLAGS is used in the CREATE_DEBUG macros to set the start
// up state for the control flags, m_iControlFlag, used in the IF_DEBUG macros.
// This define is added for the cases where there are no default flags.
# ifndef DEFAULT_TRACE_FLAGS
# define DEFAULT_TRACE_FLAGS     0
# endif

//
// Call the following macro only from the main of you executable, or COM object.
// The aim is to have this called only once per process so at the moment that
// means in Inetinfo, WAM and a few EXE files
//
# define CREATE_INITIALIZE_DEBUG()  \
        PuInitiateDebug();

//
// Call the following macro only from the main of you executable, or COM object.
// This must called only once per process so at the last possible moment that 
// means in Inetinfo, WAM and a few EXE files. Its job is to test to see if a 
// trace file was created in the initiate and if so shut it down now
//
# define DELETE_INITIALIZE_DEBUG() \
        PuUninitiateDebug();

//
// Call the following macro as a normal part of your initialization for programs
//  planning to use the debugging class. This should be done inside the 
//  PROCESS_ATTTACH for most DLL's and COM objects
//
# define CREATE_DEBUG_PRINT_OBJECT( pszLabel, ControlGuid)  \
    { \
        g_pDebug = PuCreateDebugPrintsObject(pszLabel, (LPGUID) &ControlGuid, &g_fErrorFlags, DEFAULT_TRACE_FLAGS);\
    }

//
// Call the following macro once as part of the termination of programs
//    which uses the debugging class.
//
# define DELETE_DEBUG_PRINT_OBJECT( )  \
    { \
        PuDeleteDebugPrintsObject(g_pDebug); \
        g_pDebug = NULL; \
    }

# define VALID_DEBUG_PRINT_OBJECT()     \
        (NULL != g_pDebug)

//
//  Use the DBG_CONTEXT without any surrounding braces.
//  This is used to pass the values for global DebugPrintObject
//     and File/Line information
//
# define DBG_CONTEXT        g_pDebug, __FILE__, __LINE__

// The 3 main tracing macros, each one corresponds to a different level of 
// tracing
# define DBGINFO(args)      {if (g_fErrorFlags & DEBUG_FLAGS_INFO) { PuDbgPrint args; }}
# define DBGWARN(args)      {if (g_fErrorFlags & DEBUG_FLAGS_WARN) { PuDbgPrint args; }}
# define DBGERROR(args)     {if (g_fErrorFlags & DEBUG_FLAGS_ERROR) { PuDbgPrint args; }}

# define DBGINFOW(args)     {if (g_fErrorFlags & DEBUG_FLAGS_INFO) { PuDbgPrintW args; }}
# define DBGWARNW(args)     {if (g_fErrorFlags & DEBUG_FLAGS_WARN) { PuDbgPrintW args; }}
# define DBGERRORW(args)    {if (g_fErrorFlags & DEBUG_FLAGS_ERROR) { PuDbgPrintW args; }}

# if DBG

# define DBG_CODE(s)        s          /* echoes code in debugging mode */

// The same 3 main tracing macros however in this case the macros are only compiled
// into the CHK build. This is necessary because some tracing info used functions or
// variables which are not compiled into the FRE build.
# define CHKINFO(args)      {if (g_fErrorFlags & DEBUG_FLAGS_INFO) { PuDbgPrint args; }}
# define CHKWARN(args)      {if (g_fErrorFlags & DEBUG_FLAGS_WARN) { PuDbgPrint args; }}
# define CHKERROR(args)     {if (g_fErrorFlags & DEBUG_FLAGS_ERROR) { PuDbgPrint args; }}

# define CHKINFOW(args)     {if (g_fErrorFlags & DEBUG_FLAGS_INFO) { PuDbgPrintW args; }}
# define CHKWARNW(args)     {if (g_fErrorFlags & DEBUG_FLAGS_WARN) { PuDbgPrintW args; }}
# define CHKERRORW(args)    {if (g_fErrorFlags & DEBUG_FLAGS_ERROR) { PuDbgPrintW args; }}

# define DBG_ASSERT( exp)   if ( !(exp)) { \
                                PuDbgAssertFailed( DBG_CONTEXT, #exp); \
                            } else {}

# define DBG_REQUIRE( exp)  DBG_ASSERT( exp)

# else // !DBG

# define DBG_CODE(s)        ((void)0) /* Do Nothing */

# define CHKINFO(args)      ((void)0) /* Do Nothing */
# define CHKWARN(args)      ((void)0) /* Do Nothing */
# define CHKERROR(args)     ((void)0) /* Do Nothing */

# define CHKINFOW(args)     ((void)0) /* Do Nothing */
# define CHKWARNW(args)     ((void)0) /* Do Nothing */
# define CHKERRORW(args)    ((void)0) /* Do Nothing */

# define DBG_ASSERT(exp)    ((void)0) /* Do Nothing */

# define DBG_REQUIRE( exp)  ((void) (exp))

# endif // !DBG

//
//  DBGPRINTF() is printing function ( much like printf) but always called
//    with the DBG_CONTEXT as follows
//   DBGPRINTF( ( DBG_CONTEXT, format-string, arguments for format list);
//
# define DBGPRINTF          DBGINFO

# define DBGDUMP(args)      PuDbgDump  args

# define DBGDUMPW(args)     PuDbgDumpW  args

#else // _NO_TRACING_

// Map the new debugging macros to DBGPRINTF so that we can make modifications 
// to the code which still compile in both the tracing and no-tracing versions.
// Unfortunately there is no equivalent of the unicode versions so map them to
// nothing
# define DBGINFO            DBGPRINTF  
# define DBGWARN            DBGPRINTF
# define DBGERROR           DBGPRINTF

# define DBGINFOW(args)     ((void)0) /* Do Nothing */
# define DBGWARNW(args)     ((void)0) /* Do Nothing */
# define DBGERRORW(args)    ((void)0) /* Do Nothing */

# define DBGDUMPW(args)     ((void)0) /* Do Nothing */



# if DBG


/***********************************************************
 *    Macros
 ************************************************************/


extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
DEBUG_PRINTS  *  g_pDebug;        // define a global debug variable

# define DECLARE_DEBUG_PRINTS_OBJECT()          \
         DEBUG_PRINTS  *  g_pDebug = NULL;      \
         int              g_fErrorFlags = 0;

//
// Call the following macro as part of your initialization for program
//  planning to use the debugging class.
//
# define CREATE_DEBUG_PRINT_OBJECT( pszLabel)  \
        g_pDebug = PuCreateDebugPrintsObject( pszLabel, DEFAULT_OUTPUT_FLAGS);\
         if  ( g_pDebug == NULL) {   \
               OutputDebugStringA( "Unable to Create Debug Print Object \n"); \
         }

//
// Call the following macro once as part of the termination of program
//    which uses the debugging class.
//
# define DELETE_DEBUG_PRINT_OBJECT( )  \
        g_pDebug = PuDeleteDebugPrintsObject( g_pDebug);


# define VALID_DEBUG_PRINT_OBJECT()     \
        ( ( g_pDebug != NULL) && g_pDebug->m_fInitialized)


//
//  Use the DBG_CONTEXT without any surrounding braces.
//  This is used to pass the values for global DebugPrintObject
//     and File/Line information
//
# define DBG_CONTEXT        g_pDebug, __FILE__, __LINE__



# define DBG_CODE(s)          s          /* echoes code in debugging mode */

# define DBG_ASSERT( exp)    if ( !(exp)) { \
                                 PuDbgAssertFailed( DBG_CONTEXT, #exp, NULL); \
                             } else {}

# define DBG_ASSERT_MSG( exp, pszMsg)    \
                             if ( !(exp)) { \
                                  PuDbgAssertFailed( DBG_CONTEXT, #exp, pszMsg); \
                              } else {}

# define DBG_REQUIRE( exp)    DBG_ASSERT( exp)

# define DBG_LOG()            PuDbgPrint( DBG_CONTEXT, "\n")

# define DBG_OPEN_LOG_FILE( pszFile, pszPath)   \
                  PuOpenDbgPrintFile( g_pDebug, (pszFile), (pszPath))

# define DBG_CLOSE_LOG_FILE( )   \
                  PuCloseDbgPrintFile( g_pDebug)


//
//  DBGPRINTF() is printing function ( much like printf) but always called
//    with the DBG_CONTEXT as follows
//   DBGPRINTF( ( DBG_CONTEXT, format-string, arguments for format list);
//
# define DBGPRINTF( args)     PuDbgPrint args

# define DBGDUMP( args)       PuDbgDump  args

# define DBGPRINT_CURRENT_TIME()  PuDbgPrintCurrentTime( DBG_CONTEXT)

# else // !DBG


# define DECLARE_DEBUG_PRINTS_OBJECT()           /* Do Nothing */
# define CREATE_DEBUG_PRINT_OBJECT( pszLabel)    ((void)0) /* Do Nothing */
# define DELETE_DEBUG_PRINT_OBJECT( )            ((void)0) /* Do Nothing */
# define VALID_DEBUG_PRINT_OBJECT()              ( TRUE)

# define DBG_CODE(s)                             ((void)0) /* Do Nothing */

# define DBG_ASSERT(exp)                         ((void)0) /* Do Nothing */

# define DBG_ASSERT_MSG(exp, pszMsg)             ((void)0) /* Do Nothing */

# define DBG_REQUIRE( exp)                       ( (void) (exp))

# define DBGPRINTF( args)                        ((void)0) /* Do Nothing */

# define DBGDUMP( args)                          ((void)0) /* Do nothing */

# define DBG_LOG()                               ((void)0) /* Do Nothing */

# define DBG_OPEN_LOG_FILE( pszFile, pszPath)    ((void)0) /* Do Nothing */

# define DBG_CLOSE_LOG_FILE()                    ((void)0) /* Do Nothing */

# define DBGPRINT_CURRENT_TIME()                 ((void)0) /* Do Nothing */

# endif // !DBG

# endif // _NO_TRACING_

// end_user_unmodifiable

// begin_user_unmodifiable


#ifdef ASSERT
# undef ASSERT
#endif


# define ASSERT( exp)           DBG_ASSERT( exp)

// The WINNT defined tests are required so that the ui\setup\osrc project still
// compiles
#if !defined(_NO_TRACING_) && (defined(_WINNT_) || defined(WINNT))

# define GET_DEBUG_FLAGS()        ( g_pDebug ? g_pDebug->m_iControlFlag : 0)

# define DEBUG_IF( arg, s)        if ( DEBUG_ ## arg & GET_DEBUG_FLAGS()) { \
                                       s \
                                  } else {}

# define IF_DEBUG( arg)           if ( DEBUG_## arg & GET_DEBUG_FLAGS())

# if DBG

# define CHKDEBUG_IF( arg, s)     if ( DEBUG_ ## arg & GET_DEBUG_FLAGS()) { \
                                       s \
                                  } else {}

# define IF_CHKDEBUG( arg)        if ( DEBUG_## arg & GET_DEBUG_FLAGS())


# else   // !DBG

# define CHKDEBUG_IF( arg, s)     /* Do Nothing */
# define IF_CHKDEBUG( arg)        if ( 0)

# endif // !DBG

# else // !_NO_TRACING_

# if DBG

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
 DWORD  g_dwDebugFlags;           // Debugging Flags

# define DECLARE_DEBUG_VARIABLE()     \
             DWORD  g_dwDebugFlags;

# define SET_DEBUG_FLAGS( dwFlags)         g_dwDebugFlags = dwFlags
# define GET_DEBUG_FLAGS()                 ( g_dwDebugFlags)

# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault)  \
             g_dwDebugFlags = PuLoadDebugFlagsFromReg((hkey), (dwDefault), g_pDebug)

# define LOAD_DEBUG_FLAGS_FROM_REG_STR(pszRegKey, dwDefault)  \
             g_dwDebugFlags = PuLoadDebugFlagsFromRegStr((pszRegKey), (dwDefault), g_pDebug)

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)  \
               PuSaveDebugFlagsInReg((hkey), (dwDbg))

# define DEBUG_IF( arg, s)     if ( DEBUG_ ## arg & GET_DEBUG_FLAGS()) { \
                                       s \
                                } else {}

# define IF_DEBUG( arg)        if ( DEBUG_## arg & GET_DEBUG_FLAGS())


# else   // !DBG


# define DECLARE_DEBUG_VARIABLE()                /* Do Nothing */
# define SET_DEBUG_FLAGS( dwFlags)               /* Do Nothing */
# define GET_DEBUG_FLAGS()                       ( 0)
# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault) /* Do Nothing */

# define LOAD_DEBUG_FLAGS_FROM_REG_STR(pszRegKey, dwDefault)  /* Do Nothing */

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)    /* Do Nothing */

# define DEBUG_IF( arg, s)                       /* Do Nothing */
# define IF_DEBUG( arg)                          if ( 0)

# endif // !DBG

# endif // !_NO_TRACING_

// end_user_unmodifiable

// begin_user_modifiable

//
//  Debugging constants consist of two pieces.
//  All constants in the range 0x0 to 0x8000 are reserved
//  User extensions may include additional constants (bit flags)
//

# define DEBUG_API_ENTRY                  0x00000001L
# define DEBUG_API_EXIT                   0x00000002L
# define DEBUG_INIT_CLEAN                 0x00000004L
# define DEBUG_ERROR                      0x00000008L

                   // End of Reserved Range
# define DEBUG_RESERVED                   0x00000FFFL

// end_user_modifiable




/***********************************************************
 *    Platform Type related variables and macros
 ************************************************************/

//
// Enum for product types
//

typedef enum _PLATFORM_TYPE {

    PtInvalid = 0,                 // Invalid
    PtNtWorkstation = 1,           // NT Workstation
    PtNtServer = 2,                // NT Server
    PtWindows95 = 3,               // Windows 95
    PtWindows9x = 4                // Windows 9x - not implemented

} PLATFORM_TYPE;

//
// IISGetPlatformType is the function used to the platform type
//

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
PLATFORM_TYPE
IISGetPlatformType(
        VOID
        );

//
// External Macros
//

#define InetIsNtServer( _pt )           ((_pt) == PtNtServer)
#define InetIsNtWksta( _pt )            ((_pt) == PtNtWorkstation)
#define InetIsWindows95( _pt )          ((_pt) == PtWindows95)
#define InetIsValidPT(_pt)              ((_pt) != PtInvalid)

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
PLATFORM_TYPE    g_PlatformType;


// Use the DECLARE_PLATFORM_TYPE macro to declare the platform type
#define DECLARE_PLATFORM_TYPE()  \
   PLATFORM_TYPE    g_PlatformType = PtInvalid;

// Use the INITIALIZE_PLATFORM_TYPE to init the platform type
// This should typically go inside the DLLInit or equivalent place.
#define INITIALIZE_PLATFORM_TYPE()  \
   g_PlatformType = IISGetPlatformType();

//
// Additional Macros to use the Platform Type
//

#define TsIsNtServer( )         InetIsNtServer(g_PlatformType)
#define TsIsNtWksta( )          InetIsNtWksta(g_PlatformType)
#define TsIsWindows95()         InetIsWindows95(g_PlatformType)
#define IISIsValidPlatform()    InetIsValidPT(g_PlatformType)
#define IISPlatformType()       (g_PlatformType)


/***********************************************************
 *    Some utility functions for Critical Sections
 ************************************************************/

//
// IISSetCriticalSectionSpinCount() provides a thunk for the
// original NT4.0sp3 API SetCriticalSectionSpinCount() for CS with Spin counts
// Users of this function should definitely dynlink with kernel32.dll,
// Otherwise errors will surface to a large extent
//
extern
# ifdef __cplusplus
"C"
# endif // _cplusplus
DWORD
IISSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
);


//
// Macro for the calls to SetCriticalSectionSpinCount()
//
# define SET_CRITICAL_SECTION_SPIN_COUNT( lpCS, dwSpins) \
  IISSetCriticalSectionSpinCount( (lpCS), (dwSpins))

//
// IIS_DEFAULT_CS_SPIN_COUNT is the default value of spins used by
//  Critical sections defined within IIS.
// NYI: We should have to switch the individual values based on experiments!
// Current value is an arbitrary choice
//
# define IIS_DEFAULT_CS_SPIN_COUNT   (1000)

//
// Initializes a critical section and sets its spin count
// to IIS_DEFAULT_CS_SPIN_COUNT.  Equivalent to
// InitializeCriticalSectionAndSpinCount(lpCS, IIS_DEFAULT_CS_SPIN_COUNT),
// but provides a safe thunking layer for older systems that don't provide
// this API.
//
extern
# ifdef __cplusplus
"C"
# endif // _cplusplus
VOID
IISInitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
);

//
// Macro for the calls to InitializeCriticalSection()
//
# define INITIALIZE_CRITICAL_SECTION(lpCS) IISInitializeCriticalSection(lpCS)

# endif  /* _DEBUG_HXX_ */

//
// The following macros allow the automatic naming of certain Win32 objects.
// See IIS\SVCS\IISRTL\WIN32OBJ.C for details on the naming convention.
//
// Set IIS_NAMED_WIN32_OBJECTS to a non-zero value to enable named events,
// semaphores, and mutexes.
//

#if DBG
#define IIS_NAMED_WIN32_OBJECTS 1
#else
#define IIS_NAMED_WIN32_OBJECTS 0
#endif

#ifdef __cplusplus
extern "C" {
#endif

HANDLE
PuDbgCreateEvent(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL ManualReset,
    IN BOOL InitialState
    );

HANDLE
PuDbgCreateSemaphore(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN LONG InitialCount,
    IN LONG MaximumCount
    );

HANDLE
PuDbgCreateMutex(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL InitialOwner
    );

#ifdef __cplusplus
}   // extern "C"
#endif

#if IIS_NAMED_WIN32_OBJECTS

#define IIS_CREATE_EVENT( membername, address, manual, state )              \
    PuDbgCreateEvent(                                                       \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (manual),                                                           \
        (state)                                                             \
        )

#define IIS_CREATE_SEMAPHORE( membername, address, initial, maximum )       \
    PuDbgCreateSemaphore(                                                   \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (initial),                                                          \
        (maximum)                                                           \
        )

#define IIS_CREATE_MUTEX( membername, address, initial )                     \
    PuDbgCreateMutex(                                                       \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (initial)                                                           \
        )

#else   // !IIS_NAMED_WIN32_OBJECTS

#define IIS_CREATE_EVENT( membername, address, manual, state )              \
    CreateEventA(                                                           \
        NULL,                                                               \
        (manual),                                                           \
        (state),                                                            \
        NULL                                                                \
        )

#define IIS_CREATE_SEMAPHORE( membername, address, initial, maximum )       \
    CreateSemaphoreA(                                                       \
        NULL,                                                               \
        (initial),                                                          \
        (maximum),                                                          \
        NULL                                                                \
        )

#define IIS_CREATE_MUTEX( membername, address, initial )                     \
    CreateMutexA(                                                           \
        NULL,                                                               \
        (initial),                                                          \
        NULL                                                                \
        )

#endif  // IIS_NAMED_WIN32_OBJECTS


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\pwsctrl.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pwsctrl.cpp

Abstract:

    This is the main routine for the Internet Services suite.

Author:

    Boyd Multerer       (BoydM)     29-Apr-1997

--*/
BOOL W95StartW3SVC( void );
//BOOL W95StartW3SVC( LPCSTR pszPath, LPCSTR pszPathDir, PCHAR pszParams );
BOOL W95ShutdownW3SVC( VOID );
BOOL W95ShutdownIISADMIN( VOID );
BOOL IsIISAdminRunning( VOID );
BOOL IsInetinfoRunning( VOID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\tracelog.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tracelog.h

Abstract:

    This module contains public declarations and definitions for creating
    trace logs.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

    Note that the creator of the log has the option of adding "extra"
    bytes to the log header. This can be useful if the creator wants to
    create a set of global logs, each on a linked list.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#ifndef _TRACELOG_H_
#define _TRACELOG_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


typedef struct _TRACE_LOG {

    //
    // Signature.
    //

    LONG Signature;

    //
    // The total number of entries available in the log.
    //

    LONG LogSize;

    //
    // The index of the next entry to use.
    //

    LONG NextEntry;

    //
    // The byte size of each entry.
    //

    LONG EntrySize;

    //
    // Pointer to the start of the circular buffer.
    //

    PUCHAR LogBuffer;

    //
    // The extra header bytes and actual log entries go here.
    //
    // BYTE ExtraHeaderBytes[ExtraBytesInHeader];
    // BYTE Entries[LogSize][EntrySize];
    //

} TRACE_LOG, *PTRACE_LOG;


//
// Log header signature.
//

#define TRACE_LOG_SIGNATURE   ((DWORD)'gOlT')
#define TRACE_LOG_SIGNATURE_X ((DWORD)'golX')


//
// This macro maps a TRACE_LOG pointer to a pointer to the 'extra'
// data associated with the log.
//

#define TRACE_LOG_TO_EXTRA_DATA(log)    (PVOID)( (log) + 1 )


//
// Manipulators.
//

PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    );

VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    );

LONG
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    );

VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _TRACELOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\srvvarid.h ===
/*++

    Copyright    (c)    1995-1996    Microsoft Corporation

    Module  Name :
        srvvarid.h

    Abstract:
   

    Author:

        Taylor Weiss    ( TaylorW )     19-Apr-1999

    Environment:


    Project:

        w3svc.dll       private\inet\iis\svcs\w3\server
        wam.dll         private\inet\iis\svcs\wam\object

    Functions Exported:


    Revision History:

--*/

#ifndef SRVVARID_H
#define SRVVARID_H

/*

All server variables that we may want to cache for out of
process performance.

Currently this list includes the following:
    
    All HTTP 1.1 - General, Request and Content headers
    
    All the non-header server variables exposed in the ASP server variables
    collection. Except those that pose for headers (like HTTP_ALL)
    
    All the headers included in the http fast map

*/

#define ALL_SERVER_VARIABLES()              \
    DEFINE_SV( APPL_MD_PATH )               \
    DEFINE_SV( APPL_PHYSICAL_PATH )         \
    DEFINE_SV( AUTH_PASSWORD )              \
    DEFINE_SV( AUTH_TYPE )                  \
    DEFINE_SV( AUTH_USER )                  \
    DEFINE_SV( CERT_COOKIE )                \
    DEFINE_SV( CERT_FLAGS )                 \
    DEFINE_SV( CERT_ISSUER )                \
    DEFINE_SV( CERT_KEYSIZE )               \
    DEFINE_SV( CERT_SECRETKEYSIZE )         \
    DEFINE_SV( CERT_SERIALNUMBER )          \
    DEFINE_SV( CERT_SERVER_ISSUER )         \
    DEFINE_SV( CERT_SERVER_SUBJECT )        \
    DEFINE_SV( CERT_SUBJECT )               \
    DEFINE_SV( CONTENT_LENGTH )             \
    DEFINE_SV( CONTENT_TYPE )               \
    DEFINE_SV( GATEWAY_INTERFACE )          \
    DEFINE_SV( HTTPS )                      \
    DEFINE_SV( HTTPS_KEYSIZE )              \
    DEFINE_SV( HTTPS_SECRETKEYSIZE )        \
    DEFINE_SV( HTTPS_SERVER_ISSUER )        \
    DEFINE_SV( HTTPS_SERVER_SUBJECT )       \
    DEFINE_SV( INSTANCE_ID )                \
    DEFINE_SV( INSTANCE_META_PATH )         \
    DEFINE_SV( LOCAL_ADDR )                 \
    DEFINE_SV( LOGON_USER )                 \
    DEFINE_SV( PATH_INFO )                  \
    DEFINE_SV( PATH_TRANSLATED )            \
    DEFINE_SV( QUERY_STRING )               \
    DEFINE_SV( REMOTE_ADDR )                \
    DEFINE_SV( REMOTE_HOST )                \
    DEFINE_SV( REMOTE_USER )                \
    DEFINE_SV( REQUEST_METHOD )             \
    DEFINE_SV( SCRIPT_NAME )                \
    DEFINE_SV( SERVER_NAME )                \
    DEFINE_SV( SERVER_PORT )                \
    DEFINE_SV( SERVER_PORT_SECURE )         \
    DEFINE_SV( SERVER_PROTOCOL )            \
    DEFINE_SV( SERVER_SOFTWARE )            \
    DEFINE_SV( URL )                        \
    DEFINE_SV( HTTP_CACHE_CONTROL )         \
    DEFINE_SV( HTTP_CONNECTION )            \
    DEFINE_SV( HTTP_DATE )                  \
    DEFINE_SV( HTTP_PRAGMA )                \
    DEFINE_SV( HTTP_TRANSFER_ENCODING )     \
    DEFINE_SV( HTTP_UPGRADE )               \
    DEFINE_SV( HTTP_TRAILER )               \
    DEFINE_SV( HTTP_VIA )                   \
    DEFINE_SV( HTTP_ACCEPT )                \
    DEFINE_SV( HTTP_ACCEPT_CHARSET )        \
    DEFINE_SV( HTTP_ACCEPT_ENCODING )       \
    DEFINE_SV( HTTP_AUTHORIZATION )         \
    DEFINE_SV( HTTP_EXPECT )                \
    DEFINE_SV( HTTP_FROM )                  \
    DEFINE_SV( HTTP_HOST )                  \
    DEFINE_SV( HTTP_IF_MODIFIED_SINCE )     \
    DEFINE_SV( HTTP_IF_MATCH )              \
    DEFINE_SV( HTTP_IF_NONE_MATCH )         \
    DEFINE_SV( HTTP_IF_RANGE )              \
    DEFINE_SV( HTTP_IF_UNMODIFIED_SINCE )   \
    DEFINE_SV( HTTP_MAX_FORWARDS )          \
    DEFINE_SV( HTTP_PROXY_AUTHORIZATION )   \
    DEFINE_SV( HTTP_RANGE )                 \
    DEFINE_SV( HTTP_REFERER )               \
    DEFINE_SV( HTTP_TE )                    \
    DEFINE_SV( HTTP_USER_AGENT )            \
    DEFINE_SV( HTTP_ALLOW )                 \
    DEFINE_SV( HTTP_CONTENT_ENCODING )      \
    DEFINE_SV( HTTP_CONTENT_LANGUAGE )      \
    DEFINE_SV( HTTP_CONTENT_LENGTH )        \
    DEFINE_SV( HTTP_CONTENT_LOCATION )      \
    DEFINE_SV( HTTP_CONTENT_MD5 )           \
    DEFINE_SV( HTTP_CONTENT_RANGE )         \
    DEFINE_SV( HTTP_CONTENT_TYPE )          \
    DEFINE_SV( HTTP_EXPIRES )               \
    DEFINE_SV( HTTP_LAST_MODIFIED )         \
    DEFINE_SV( HTTP_VERSION )               \
    DEFINE_SV( HTTP_UA_OS )                 \

// Define ordinals for each of the cachable server variables. 

#define DEFINE_SV( token )                  \
    SVID_##token, 

#define END_SVID()                          \
    SVID_COUNT

enum SV_IDS
{
    ALL_SERVER_VARIABLES()
    END_SVID()
};

#undef DEFINE_SV


#endif // SRVVARID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\tcpproc.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    tcpproc.hxx

    Exports misc. bits of TCP services helper DLL stuff

    FILE HISTORY:
        Johnl       09-Oct-1994 Created.


        MuraliK     31-July-1995 ReadRegistryString added +
                                 Schedule items function decls moved out.

        MuraliK     23-Feb-1996  Added IslFormatDate()

*/

#ifndef _TCPPROC_H_
#define _TCPPROC_H_

//
// Heap Routines
//
#ifdef __cplusplus

#include <string.hxx>

extern "C" {

dllexp
BOOL
ReadRegistryStr(
    IN HKEY hkeyReg,
    OUT STR & str,
    IN LPCTSTR lpszValueName,
    IN LPCTSTR lpszDefaultValue = NULL,
    IN BOOL  fExpand = FALSE);

#endif // __cplusplus


#define TCP_ALLOC(cb)          (VOID *)LocalAlloc( LPTR, cb )
#define TCP_FREE(p)            LocalFree( (HLOCAL) p )
#define TCP_DUMP_RESIDUE()     /* NOTHING */

//
//  Registry functions
//


dllexp
LPSTR
ConvertUnicodeToAnsi(
    IN LPCWSTR  lpszUnicode,
    IN LPSTR    lpszAnsi,
    IN DWORD    cbAnsi
    );

//
//  Quick macro to initialize a unicode string
//

#define InitUnicodeString( pUnicode, pwch )                                \
            {                                                              \
                (pUnicode)->Buffer    = pwch;                              \
                (pUnicode)->Length    = wcslen( pwch ) * sizeof(WCHAR);    \
                (pUnicode)->MaximumLength = (pUnicode)->Length + sizeof(WCHAR);\
            }

dllexp
DWORD
ReadRegistryDwordA(
    HKEY     hkey,
    LPCSTR   pszValueName,
    DWORD    dwDefaultValue
    );

dllexp
DWORD
WriteRegistryDwordA(
    HKEY        hkey,
    LPCSTR      pszValueName,
    DWORD       dwDefaultValue
    );

dllexp
DWORD
WriteRegistryStringA(
    HKEY        hkey,
    LPCSTR      pszValueName,
    LPCSTR      pszValue,               // null-terminated string
    DWORD       cbValue,                // including terminating null character
    DWORD       fdwType                 // REG_SZ, REG_MULTI_SZ ...
    );

dllexp
DWORD
WriteRegistryStringW(
    HKEY        hkey,
    LPCWSTR     pszValueName,
    LPCWSTR     pszValue,               // null-terminated string
    DWORD       cbValue,                // including terminating null character
    DWORD       fdwType                 // REG_SZ, REG_MULTI_SZ ...
    );

#define ReadRegistryDword       ReadRegistryDwordA
#define WriteRegistryDword      WriteRegistryDwordA
#define WriteRegistryString     WriteRegistryStringA


dllexp
TCHAR *
ReadRegistryString(
    HKEY     hkey,
    LPCTSTR  pszValueName,
    LPCTSTR  pszDefaultValue,
    BOOL     fExpand
    );

dllexp
TCHAR *
KludgeMultiSz(
    HKEY hkey,
    LPDWORD lpdwLength
    );

//
//  Simple wrapper around ReadRegistryString that restores ppchstr if the
//  call fails for any reason.  Environment variables are always expanded
//

dllexp
BOOL
ReadRegString(
    HKEY     hkey,
    CHAR * * ppchstr,
    LPCSTR   pchValue,
    LPCSTR   pchDefault
    );


//
//  MIDL_user_allocates space for pch and does a unicode conversion into *ppwch
//

dllexp
BOOL
ConvertStringToRpc(
    WCHAR * * ppwch,
    LPCSTR    pch
    );

//
//  MIDL_user_frees string allocated with ConvertStringToRpc.  Noop if pwch is
//  NULL
//

dllexp
VOID
FreeRpcString(
    WCHAR * pwch
    );


dllexp
DWORD
InetNtoa( IN struct in_addr inaddr,
          OUT CHAR * pchBuffer  /* at least 16 byte buffer */
        );

//
// Async Socket send/recv with timeouts
//

BOOL
TcpSockSend(
    SOCKET      sock,
    LPVOID      pBuffer,
    DWORD       cbBuffer,
    PDWORD      nSent,
    DWORD       nTimeout
    );

BOOL
TcpSockRecv(
    SOCKET      sock,
    LPVOID      pBuffer,
    DWORD       cbBuffer,
    PDWORD      nReceived,
    DWORD       nTimeout
    );

dllexp
INT
WaitForSocketWorker(
    IN SOCKET   sockRead,
    IN SOCKET   sockWrite,
    IN LPBOOL   pfRead,
    IN LPBOOL   pfWrite,
    IN DWORD    nTimeout
    );

//
// Test socket if still connected
//

dllexp
BOOL
TcpSockTest(
    SOCKET      sock
    );

//
// Do synchronous readfile
//

dllexp
BOOL
DoSynchronousReadFile(
    IN HANDLE hFile,
    IN PCHAR  Buffer,
    IN DWORD  nBuffer,
    OUT PDWORD nRead,
    IN LPOVERLAPPED Overlapped
    );

//
//  Dll initialization and termination
//

dllexp
BOOL
InitCommonDlls(
    VOID
    );

dllexp
BOOL
TerminateCommonDlls(
    VOID
    );

#ifdef __cplusplus
}; // extern "C"
#endif // __cplusplus

#endif // !_TCPPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\timer.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.h

Abstract:

    Domain Name System (DNS) Server

    Wrap-proof timer routines.

    The purpose of this module is to create a timer function which
    returns a time in seconds and eliminates all timer wrapping issues.

    These routines are non-DNS specific and may be picked up
    cleanly by any module.

Author:

    Jim Gilroy (jamesg)     9-Sep-1995

Revision History:

--*/


#ifndef _TIMER_INCLUDED_
#define _TIMER_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

VOID
InitializeSecondsTimer(
    VOID
    );


VOID
TerminateSecondsTimer(
    VOID
    );


DWORD
GetCurrentTimeInSeconds(
    VOID
    );


__int64
GetCurrentTimeInMilliseconds(
    VOID
    );

#ifdef __cplusplus
}
#endif

#endif  // _TIMER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\svcloc.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    svcloc.h

Abstract:

    contains proto-type and data-type definitions for service location
    APIs

Author:

    Madan Appiah (madana)  15-May-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SVCLOC_
#define _SVCLOC_

#include <inetcom.h>    // for internet service identifier

#ifdef __cplusplus
extern "C" {
#endif

//
// constant definitions.
//

//
// internet service identifier mask.
//  each  service is assigned a bit, so that we can
//  accomodate up to 64 service in ULONGLONG type.
//

#if 0
#define INET_FTP_SERVICE            (ULONGLONG)(INET_FTP)
#define INET_GOPHER_SERVICE         (ULONGLONG)(INET_GOPHER)
#define INET_W3_SERVICE             (ULONGLONG)(INET_HTTP)
#define INET_W3_PROXY_SERVICE       (ULONGLONG)(INET_HTTP_PROXY)
#define INET_MSN_SERVICE            (ULONGLONG)(INET_MSN)
#define INET_NNTP_SERVICE           (ULONGLONG)(INET_NNTP)
#define INET_SMTP_SERVICE           (ULONGLONG)(INET_SMTP)
#define INET_POP3_SERVICE           (ULONGLONG)(INET_POP3)
#define INET_GATEWAY_SERVICE        (ULONGLONG)(INET_GATEWAY)
#define INET_CHAT_SERVICE           (ULONGLONG)(INET_CHAT)
#define INET_LDAP_SERVICE           (ULONGLONG)(INET_LDAP)
#define INET_IMAP_SERVICE           (ULONGLONG)(INET_IMAP)
#endif

//
// IIS 3.0 Service location id
//

// When adding a new service ID, add it the INET_ALL_SERVICES_ID
#define INET_FTP_SVCLOC_ID          (ULONGLONG)(0x0000000000000001)
#define INET_GOPHER_SVCLOC_ID       (ULONGLONG)(0x0000000000000002)
#define INET_W3_SVCLOC_ID           (ULONGLONG)(0x0000000000000004)
#define INET_MW3_SVCLOC_ID          (ULONGLONG)(0x8000000000000000)
#define INET_MFTP_SVCLOC_ID         (ULONGLONG)(0x4000000000000000)

#define INET_ALL_SERVICES_ID        ( INET_FTP_SVCLOC_ID |          \
                                      INET_W3_SVCLOC_ID )

//
// default wait time for server discovery.
//

#define SVC_DEFAULT_WAIT_TIME   0x5    // 5 secs.

//
// Datatype definitions.
//
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

typedef enum _INET_SERVICE_STATE {
    INetServiceStopped,
        // the service has invoked de-registration or
        // the service has never called registration.
    INetServiceRunning,
        // the service is running.
    INetServicePaused
        //  the service is paused.
} INET_SERVICE_STATE, *LPINET_SERVICE_STATE;

typedef struct _INET_BIND_INFO {
    DWORD Length;   // length of bind data.
    PVOID BindData; // bind data, such as binding string or sock addr.
} INET_BIND_INFO, *LPINET_BIND_INFO;

typedef INET_BIND_INFO INET_SERVER_ADDRESS;
typedef LPINET_BIND_INFO LPINET_SERVER_ADDRESS;

typedef struct _INET_BINDINGS {
    DWORD NumBindings;
    LPINET_BIND_INFO BindingsInfo;  // array of bind info structures.
} INET_BINDINGS, *LPINET_BINDINGS;

typedef struct _INET_SERVICE_INFO {
    ULONGLONG ServiceMask;
    INET_SERVICE_STATE ServiceState;
    LPSTR ServiceComment;
    INET_BINDINGS Bindings;
} INET_SERVICE_INFO, *LPINET_SERVICE_INFO;

typedef struct _INET_SERVICES_LIST {
    DWORD NumServices;
    LPINET_SERVICE_INFO *Services; // array of service struct. pointers
} INET_SERVICES_LIST, *LPINET_SERVICES_LIST;

typedef union _INET_VERSION_NUM {
    DWORD VersionNumber;
    struct {
        WORD Major;
        WORD Minor;
    } Version;
} INET_VERSION_NUM, *LPINET_VERSION_NUM;

typedef struct _INET_SERVER_INFO {
    INET_SERVER_ADDRESS ServerAddress; // pointer to a sock addr.
    INET_VERSION_NUM VersionNum;
    LPSTR ServerName;
    DWORD LoadFactor; // in percentage, 0 - idle and 100 - fully loaded
    ULONGLONG ServicesMask;
    INET_SERVICES_LIST Services;
} INET_SERVER_INFO, *LPINET_SERVER_INFO;

typedef struct _INET_SERVERS_LIST {
    DWORD NumServers;
    LPINET_SERVER_INFO *Servers;
} INET_SERVERS_LIST, *LPINET_SERVERS_LIST;

//
// APIs
//

DWORD
WINAPI
INetDiscoverServers(
    IN ULONGLONG ServicesMask,
    IN DWORD WaitTime,
    OUT LPINET_SERVERS_LIST *ServersList
    )
/*++

Routine Description:

    This API discovers all servers on the network that support and run the
    internet services  specified.

    This API is called by the client side code, such as the internet admin
    tool or wininet.dll.

Arguments:

    SevicesMask : A bit mask that specifies to discover servers with the
        these services running.

        ex: 0x0000000E, will discovers all servers running any of the
            following services :

                1. FTP_SERVICE
                2. GOPHER_SERVICE
                3. WEB_SERVICE

    DiscoverBindings : if this flag is set, this API talks to each of the
        discovered server and queries the services and bindings
        supported. If the flag is set to FALSE, it quickly returns with
        the list of servers only.

    WaitTime : Response wait time in secs. If this value is zero, it
        returns what ever discovered so far by the previous invocation of
        this APIs, otherwise it waits for the specified secs to collect
        responses from the servers.

    ServersList : Pointer to a location where the pointer to list of
        servers info is returned. The API allocates dynamic memory for
        this return data, the caller should free it by calling
        INetFreeDiscoverServerList after it has been used.

Return Value:

    Windows Error Code.

--*/
    ;

DWORD
WINAPI
INetGetServerInfo(
    IN LPSTR ServerName,
    IN ULONGLONG ServicesMask,
    IN DWORD WaitTime,
    OUT LPINET_SERVER_INFO *ServerInfo
    )
/*++

Routine Description:

    This API returns the server info and a list of services supported by
    the server and lists of bindings supported by each of the services.

Arguments:

    ServerName : name of the server whose info to be queried.

    ServicesMask : services to be queried

    WaitTime : Time in secs to wait.

    ServerInfo : pointer to a location where the pointer to the server
        info structure will be returned. The caller should  call
        INetFreeServerInfo to free up the list after use.

Return Value:

    Windows Error Code.

--*/
    ;

VOID
WINAPI
INetFreeDiscoverServersList(
    IN OUT LPINET_SERVERS_LIST *ServersList
    )
/*++

Routine Description:

    This API frees the memory chunks that were allotted for the servers
    list by the INetDiscoverServers call.

Arguments:

    ServersList : pointer to a location where the pointer to the server
        list to be freed is stored.

Return Value:

    NONE.

--*/
    ;

VOID
WINAPI
INetFreeServerInfo(
    IN OUT LPINET_SERVER_INFO *ServerInfo
    )
/*++

Routine Description:

    This API frees the memory chunks that were allotted for the server
    info structure by the INetGetServerInfo call.

Arguments:

    ServerInfo : pointer to a location where the pointer to the server
        info structure to be freed is stored.

Return Value:

    NONE.

--*/
    ;

DWORD
WINAPI
INetRegisterService(
    IN ULONGLONG ServiceMask,
    IN INET_SERVICE_STATE ServiceState,
    IN LPSTR ServiceComment,
    IN LPINET_BINDINGS Bindings
    )
/*++

Routine Description:

    This API registers an internet service.  The service writers should
    call this API just after successfully started the service and the
    service is ready to accept incoming RPC calls.  This API accepts an
    array of RPC binding strings that the service is listening on for the
    incoming RPC connections.  This list will be distributed to the
    clients that are discovering this service.

Arguments:

    ServiceMask : service mask, such as 0x00000001 (GATEWAY_SERVICE)

    ServiceState : State of the service, INetServiceRunning and
        INetServicePaused are valid states to pass.

    ServiceComment : Service comment specified by the admin.

    Bindings : list of bindings that are supported by the service. The
        bindings can be binding strings are those returned by the
        RpcBindingToStringBinding call or the sockaddrs.

Return Value:

    Windows Error Code.

--*/
    ;

typedef
DWORD
(WINAPI *INET_REGISTER_SVC_FN)(
    ULONGLONG,
    INET_SERVICE_STATE,
    LPSTR,
    LPINET_BINDINGS
    );


DWORD
WINAPI
INetDeregisterService(
    IN ULONGLONG ServiceMask
    )
/*++

Routine Description:

    This API de-registers an internet service from being announced to the
    discovering clients. The service writers should call this API just
    before shutting down the service.

Arguments:

    ServiceMask : service mask, such as 0x00000001 (GATEWAY_SERVICE)

Return Value:

    Windows Error Code.

--*/
    ;

typedef
DWORD (WINAPI *INET_DEREGISTER_SVC_FN)(
    ULONGLONG
    );

typedef
BOOL (WINAPI * INET_INIT_CONTROL_SVC_FN)(
    VOID
    );

DWORD
DllProcessAttachSvcloc(
    VOID
    );

DWORD
DllProcessDetachSvcloc(
    VOID
    );

//
//  Initializes and terminates the service locator - must call these
//  before using the other APIs
//

BOOL
WINAPI
InitSvcLocator(
    VOID
    );

BOOL
WINAPI
TerminateSvcLocator(
    VOID
    );


extern INET_INIT_CONTROL_SVC_FN         pfnInitSvcLoc;
extern INET_INIT_CONTROL_SVC_FN         pfnTerminateSvcLoc;


#ifdef __cplusplus
}
#endif


#endif  // _SVCLOC_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\trie.h ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       trie.h

   Abstract:
       Declares a trie

   Author:
       George V. Reilly      (GeorgeRe)     21-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


// A trie is a multiway search tree (aka a radix tree).  See a good
// algorithms text, like Knuth or Sedgewick, for a complete description.
//
// Briefly, given a list of strings such as
//      cab, car, carts, cats, dog, doge, doggy, dogs
// you get a trie that looks like this:
//
//                /-[b]
//               /
//        <c>--<a>--[r]--<t>--[s]
//       /       \
//      /         \-<t>--[s]
//     *             
//      \              /-[e]
//       \            /
//        <d>--<o>--[g]--<g>--[y]
//                    \
//                     \-[s]
//
// where `[r]' denotes the end of a word and `<a>', the middle.
//
// A trie has several useful properties:
//  * fast
//  * easily handles longest substring matches
//  * fairly compact, especially when there are many overlapping strings
//
// The multiway tree is implemented as a binary tree with child and sibling
// pointers.
//
// The CTrie template takes three parameters:
//      class _TOKEN:        up to you
//      bool  fIgnoreCase:   case-sensitivity for searches
//      bool  fDeleteTokens: delete _TOKEN* when Flush() called?
// and it exposes three methods:
//      bool AddToken(ptszToken, _TOKEN*)
//      _TOKEN* Search(ptszSearch, pctchMatched = NULL, nMaxLen = 0)
//      void Flush()
//
// Use them like this:
//      CTrie<CToken, true, true> trie;
//      CToken* ptokHello = new CToken(...);
//
//      IRTLVERIFY(trie.AddToken(_T("Hello"), ptokHello));
//
//      CToken* ptok = trie.Search(_T("Goodbye"));
//      if (ptok != NULL) {...}
//
//      if (fIniFileChanged)
//      {
//          trie.Flush();   // will delete all tokens
//          AddTokensFromIniFile(trie);
//      }
//
// Note: If you use DUMP(&trie) or ASSERT_VALID(&trie), your _TOKEN class must
// have Dump() or AssertValid() methods, respectively, in its _DEBUG version.
//
//
// TODO:
//  * template really ought to be parameterized on ANSI/Unicode too
//  * STLify it: add iterators, turn it into a container, etc
//  * remove Win32 dependencies (TCHAR)
//  * add operator= and copy ctor
//
//
// George V. Reilly  <gvr@halcyon.com>  Oct 1995  Initial implementation
// George V. Reilly  <gvr@halcyon.com>  Sep 1996  Add CharPresent for ANSI
// George V. Reilly  <gvr@halcyon.com>  Mar 1997  Templatized; removed MFC


#ifndef __TRIE_H__
#define __TRIE_H__

#include <tchar.h>
#include <limits.h>
#include <malloc.h>
#include <irtldbg.h>

// Workaround for bool being a "reserved extension" in Visual C++ 4.x
#if _MSC_VER<1100
# ifndef bool
#  define bool  BOOL
# endif
# ifndef true
#  define true  TRUE
# endif
# ifndef false
#  define false FALSE
# endif
#endif


// forward declaration
template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens> class CTrie;


//+---------------------------------------------------------------------
//  Class:      CTrieNode (tn)
//      one node for each letter

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
class CTrieNode
{
    friend class CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>;
    typedef CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens> _Node;

public:
    CTrieNode();

    CTrieNode(
        _Node*        pParent,
        const _TOKEN* ptok,
        const TCHAR   tch,
        LPCTSTR       ptszToken);

    bool
    SetData(
        const _TOKEN* ptok,
        LPCTSTR       ptszToken);

    ~CTrieNode();

protected:
    const _Node*  m_pParent;
    _Node*        m_pSibling;
    _Node*        m_pChild;
    const _TOKEN* m_ptok;
#ifdef _DEBUG
    LPTSTR        m_ptszToken;
#endif
    const TCHAR   m_tch;
    TCHAR         m_tchMaxChild;    // Maximum m_tch of child nodes (1 level)

// Diagnostics
public:
#ifdef _DEBUG
    void
    AssertValid() const;

    virtual void
    Dump() const;

protected:
    bool
    CheckNodeToken() const;
#endif

private:
    // private, unimplemented copy ctor and op= to prevent
    // compiler synthesizing them
    CTrieNode(const CTrieNode&);
    CTrieNode& operator=(const CTrieNode&);
};



//+---------------------------------------------------------------------
//  Class:      CTrie (trie)

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
class CTrie
{
    typedef CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens> _Node;

public:
    CTrie();

    virtual
    ~CTrie();

    virtual bool
    AddToken(
        LPCTSTR             ptszToken,
        const _TOKEN* const ptok);

    virtual const _TOKEN*
    Search(
        LPCTSTR   ptszSearch,
        int*      pctchMatched = NULL,
        const int nMaxLen = 0) const;

    virtual void
    Flush();

protected:
    _Node  m_tnRoot;
    TCHAR  m_tchMinChild;
    TCHAR  m_tchMaxChild;

    void
    _DeleteTrie(
        _Node* ptn);

#ifndef _UNICODE
    // bit array for first letter of all tokens
    BYTE  m_afCharPresent[(CHAR_MAX - CHAR_MIN + 1 + 7) / 8];

    bool
    _CharPresent(
        CHAR ch) const;

    void
    _SetCharPresent(
        CHAR ch,
        bool f);
#endif // !UNICODE


// Diagnostics
public:
#ifdef _DEBUG
    virtual void
    AssertValid() const;

    virtual void
    Dump() const;

protected:
    int   m_ctchMaxTokenLen;    // length of longest token string

    void
    _AssertWalk(
        _Node* ptn,
        LPTSTR ptszName,
        int    iLevel) const;

    void
    _DumpWalk(
        _Node* ptn,
        LPTSTR ptszName,
        int    iLevel,
        int&   rcNodes,
        int&   rcTokens) const;
#endif

private:
    // private, unimplemented copy ctor and op= to prevent
    // compiler synthesizing them
    CTrie(const CTrie&);
    CTrie& operator=(const CTrie&);
};



#ifdef _UNICODE
# define TCHAR_MIN L'\0'
#else // !UNICODE
# define TCHAR_MIN CHAR_MIN
#endif // !UNICODE



//-----------------------------------------------------------------------------
// CTrieNode implementation

// CTrieNode::CTrieNode
//      default ctor (needed for CTrie::m_tnRoot)

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::CTrieNode()
    : m_pParent(NULL),
      m_pSibling(NULL),
      m_pChild(NULL),
      m_ptok(NULL),
#ifdef _DEBUG
      m_ptszToken(NULL),
#endif
      m_tch(TCHAR_MIN),
      m_tchMaxChild(TCHAR_MIN)
{
}



// CTrieNode::CTrieNode
//      ctor

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::CTrieNode(
    _Node*        pParent,
    const _TOKEN* ptok,
    const TCHAR   tch,
    LPCTSTR       ptszToken)
    : m_pParent(pParent),
      m_pSibling(NULL),
      m_pChild(NULL),
      m_ptok(ptok),
#ifdef _DEBUG
      m_ptszToken(NULL),
#endif
      m_tch(tch),
      m_tchMaxChild(TCHAR_MIN)
{
    IRTLASSERT(m_pParent != NULL);
    IRTLASSERT(m_tch > TCHAR_MIN);
    
    _Node* ptnPrev = NULL;
    _Node* ptn = m_pParent->m_pChild;
        
    // find where in the list of pParent's children to insert `this'
    while (ptn != NULL  &&  ptn->m_tch < m_tch)
    {
        ptnPrev = ptn;
        ptn = ptn->m_pSibling;
    }
    
    IRTLASSERT(ptn == NULL  ||  ptn->m_tch != m_tch);
    
    if (ptnPrev == NULL)
    {
        IRTLASSERT(pParent->m_pChild == ptn);
        pParent->m_pChild = this;
    }
    else
        ptnPrev->m_pSibling = this;

    this->m_pSibling = ptn;

    if (pParent->m_tchMaxChild < m_tch)
        pParent->m_tchMaxChild = m_tch;

#ifdef _DEBUG
    if (ptszToken != NULL)
    {
        IRTLASSERT(m_ptok != NULL);
        m_ptszToken = new TCHAR [_tcslen(ptszToken) + 1];
        _tcscpy(m_ptszToken, ptszToken);
    }
#endif
}


    
// CTrieNode::SetData
//      sets the data if it's NULL.  Needed if you do
//      AddToken("foobar", &tokFoobar) and then AddToken("foo", &tokFoo)
//      to set the data for tokFoo.

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
bool
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::SetData(
    const _TOKEN* ptok,
    LPCTSTR       ptszToken)
{
    // Don't set data if ptok is NULL
    if (ptok == NULL)
        return false;
    
    // overwrite m_ptok only if it is NULL
    if (m_ptok == NULL)
    {
        m_ptok = ptok;
#ifdef _DEBUG
        IRTLASSERT(m_ptszToken == NULL);
        IRTLASSERT(ptszToken != NULL);
        m_ptszToken = new TCHAR [_tcslen(ptszToken) + 1];
        _tcscpy(m_ptszToken, ptszToken);
#endif
    }

    return true;
}



// CTrieNode::~CTrieNode
//      dtor

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::~CTrieNode()
{
#ifdef _DEBUG
    delete [] m_ptszToken;
#endif

    // Is this an auto-delete trie, i.e., do we take care of deleting
    // the _TOKENs?
    if (fDeleteTokens)
    {
        // cast away constness so that delete will work
        delete const_cast<_TOKEN*> (m_ptok);
    }

    IRTLASSERT(m_pChild == NULL);
}


    
//-----------------------------------------------------------------------------
// CTrieNode diagnostics

#ifdef _DEBUG

// CTrieNode::CheckNodeToken
//      Do the real work of validating a CTrieNode object

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
bool
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::CheckNodeToken() const
{
    // If there's no m_ptok, it's automatically valid
    if (m_ptok == NULL)
        return true;

    IRTLASSERT(m_ptszToken != NULL);
    const int cLen = _tcslen(m_ptszToken);
    const _Node* ptn = this;

    IRTLASSERT((m_pChild == NULL  &&  m_tchMaxChild == TCHAR_MIN)
           ||  (m_pChild != NULL  &&  m_tchMaxChild > TCHAR_MIN));

    // Walk back up towards CTrie::m_tnRoot
    for (int i = cLen;  --i >= 0;  )
    {
        IRTLASSERT(ptn != NULL);
        IRTLASSERT(ptn->m_tch != TCHAR_MIN);

        const TCHAR tch = (fIgnoreCase
                           ? (TCHAR) _totlower(this->m_ptszToken[i])
                           : this->m_ptszToken[i]);

        if (ptn->m_tch != tch)
            IRTLASSERT(false);

        IRTLASSERT(ptn->m_pParent != NULL && ptn->m_pParent->m_pChild != NULL);

        const _Node* ptn2;

        // check to see if ptn really is a child of its parent
        for (ptn2 = ptn->m_pParent->m_pChild;
             ptn2 != ptn  &&  ptn2 != NULL;
             ptn2 = ptn2->m_pSibling)
        {}
        IRTLASSERT(ptn2 == ptn);

        // check that ptn->m_pParent->m_tchMaxChild is correct
        for (ptn2 = ptn->m_pParent->m_pChild;
             ptn2->m_pSibling != NULL;
             ptn2 = ptn2->m_pSibling)
        {
            IRTLASSERT(ptn2->m_tch > TCHAR_MIN
                   &&  ptn2->m_tch < ptn2->m_pSibling->m_tch);
        }
        IRTLASSERT(ptn->m_pParent->m_tchMaxChild == ptn2->m_tch);

        ptn = ptn->m_pParent;
        IRTLASSERT(ptn->m_ptok != this->m_ptok);
    }

    // check to see if ptn == CTrie::m_tnRoot
    IRTLASSERT(ptn->m_pParent == NULL  &&  ptn->m_pSibling == NULL
           &&  ptn->m_tch == TCHAR_MIN  &&  ptn->m_ptok == NULL);

    return true;
}



// CTrieNode::AssertValid
//      Validate a CTrieNode object

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::AssertValid() const
{
    IRTLASSERT(CheckNodeToken());
}



// CTrieNode::Dump
//      Dump a CTrieNode object

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrieNode<_TOKEN, fIgnoreCase, fDeleteTokens>::Dump() const
{
    // TODO: flesh out
}

#endif // _DEBUG



//-----------------------------------------------------------------------------
// CTrie implementation

// CTrie::CTrie
//      ctor

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::CTrie()
{
    Flush();
}



// CTrie::~CTrie
//      dtor

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::~CTrie()
{
    Flush();
}



#ifndef _UNICODE

// CTrie::_CharPresent

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
inline bool
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::_CharPresent(
    CHAR ch) const
{
    IRTLASSERT(CHAR_MIN <= ch  &&  ch <= CHAR_MAX);
    const UINT i = ch - CHAR_MIN;   // CHAR_MIN is -128 for `signed char'

    return m_afCharPresent[i >> 3] & (1 << (i & 7))  ?  true  :  false;
}



// CTrie::_SetCharPresent

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
inline void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::_SetCharPresent(
    CHAR ch,
    bool f)
{
    IRTLASSERT(CHAR_MIN <= ch  &&  ch <= CHAR_MAX);
    const UINT i = ch - CHAR_MIN;

    if (f)
        m_afCharPresent[i >> 3] |=  (1 << (i & 7));
    else
        m_afCharPresent[i >> 3] &= ~(1 << (i & 7));
}

#endif // !UNICODE



// CTrie::AddToken
//      Add search string `ptszToken' to trie, which will return `ptok'
//      if searched for in Search().

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
bool
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::AddToken(
    LPCTSTR             ptszToken,
    const _TOKEN* const ptok)
{
    if (ptok == NULL  ||  ptszToken == NULL  ||  *ptszToken == _T('\0'))
    {
        IRTLASSERT(false);
        return false;
    }

    const int cLen = _tcslen(ptszToken);
    _Node* ptnParent = &m_tnRoot;
    
    for (int i = 0;  i < cLen;  ++i)
    {
        IRTLASSERT(ptnParent != NULL);
        
        _Node* ptn = ptnParent->m_pChild;
        const TCHAR tch = (fIgnoreCase
                           ? (TCHAR) _totlower(ptszToken[i])
                           : ptszToken[i]);
        const _TOKEN* ptok2 = (i == cLen - 1)  ?  ptok       :  NULL;
        LPCTSTR ptsz2 =       (i == cLen - 1)  ?  ptszToken  :  NULL;

        while (ptn != NULL  &&  ptn->m_tch < tch)
            ptn = ptn->m_pSibling;
            
        if (ptn == NULL  ||  ptn->m_tch > tch)
        {
            ptnParent = new _Node(ptnParent, ptok2, tch, ptsz2);
        }
        else
        {
            IRTLASSERT(ptn->m_tch == tch);
            
            ptn->SetData(ptok2, ptsz2);
            ptnParent = ptn;
        }

        IRTLASSERT(ptnParent->CheckNodeToken());
    }

    m_tchMinChild = m_tnRoot.m_pChild->m_tch;
    m_tchMaxChild = m_tnRoot.m_tchMaxChild;
#ifdef _DEBUG
    m_ctchMaxTokenLen = max(m_ctchMaxTokenLen, cLen);
#endif

    IRTLASSERT(TCHAR_MIN < m_tchMinChild  &&  m_tchMinChild <= m_tchMaxChild);

#ifndef _UNICODE
    // Keep a map of the initial letter of each token, to speed up searches
    if (fIgnoreCase)
    {
        _SetCharPresent(tolower(ptszToken[0]), true);
        _SetCharPresent(toupper(ptszToken[0]), true);
    }
    else
        _SetCharPresent(ptszToken[0], true);
#endif // !UNICODE

#ifdef _DEBUG
    int nTemp;
    const _TOKEN* ptok2 = Search(ptszToken, &nTemp);

    IRTLASSERT(ptok2 == ptok  &&  nTemp == cLen);
#endif // _DEBUG

    return true;
}



// CTrie::Search
//      Search trie for `ptszSearch', returning count of characters
//      matched in `pctchMatched' (if non-NULL), matching at most `nMaxLen'
//      characters, if nMaxLen != 0, or _tcslen(ptszSearch) otherwise.

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
const _TOKEN*
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::Search(
    LPCTSTR   ptszSearch,
    int*      pctchMatched /* = NULL */,
    const int nMaxLen /* = 0 */) const
{
    // Set count of matched characters
    if (pctchMatched != NULL)
        *pctchMatched = 0;

#ifndef _UNICODE
    if (! _CharPresent(ptszSearch[0]))
        return NULL;

    TCHAR tch;
#else    // UNICODE
    TCHAR tch = fIgnoreCase ? (TCHAR) _totlower(ptszSearch[0]) : ptszSearch[0];

    if (tch < m_tchMinChild  ||  m_tchMaxChild < tch)
        return NULL;
#endif // UNICODE

    // For some uses (e.g., ptszSearch is not '\0'-terminated), nMaxLen is
    // specified.  If it's not specified, use the length of the string.
    const int cLen = (nMaxLen != 0)  ?  nMaxLen  :  _tcslen(ptszSearch);
    IRTLASSERT(0 < cLen);

    bool fOvershot = true;
    const _Node* ptnParent = &m_tnRoot;
    const _Node* ptn = NULL;
    int i;

    // Find the longest approximate match.  For example, if we have "foo"
    // and "foobar" in the trie and we're asked to match "fool", we'll work
    // our way down to "foob", then backtrack up to "foo".

    for (i = 0;  i < cLen;  ++i)
    {
        IRTLASSERT(ptnParent != NULL);

        ptn = ptnParent->m_pChild;
        IRTLASSERT(ptn != NULL  &&  ptn->m_pParent == ptnParent);

        tch = fIgnoreCase ? (TCHAR) _totlower(ptszSearch[i]) : ptszSearch[i];
        IRTLASSERT(tch >= TCHAR_MIN);

        if (ptnParent->m_tchMaxChild < tch)
        {
            IRTLASSERT(i > 0);
            break;
        }
        
        while (ptn != NULL  &&  ptn->m_tch < tch)
            ptn = ptn->m_pSibling;

        // failed to match?
        if (ptn == NULL  ||  ptn->m_tch > tch)
        {
            IRTLASSERT(ptn == NULL  || ptn->m_tch <= ptnParent->m_tchMaxChild);
            
            if (i == 0)
                return NULL;
            break;
        }
        else
        {
            IRTLASSERT(ptn->m_tch == tch);
            IRTLASSERT(ptn->m_pParent->m_tchMaxChild >= tch);

            if (ptn->m_pChild == NULL)
            {
                IRTLASSERT(ptn->m_ptok != NULL);
                fOvershot = false;
                break;
            }

            ptnParent = ptn;
        }
    }

    if (fOvershot)
    {
        --i;  ptn = ptnParent;  // back up one character
    }
    else
        IRTLASSERT(ptn->m_pChild == NULL);

    IRTLASSERT(0 <= i  &&  i < cLen);
    IRTLASSERT(ptn != NULL  &&  ptn != &m_tnRoot);
    
    // we've found an approximate match; backtrack until we find an exact match
    do
    {
        IRTLASSERT(ptn != NULL);
        IRTLASSERT(ptn->m_tch == (fIgnoreCase
                                  ? (TCHAR) _totlower(ptszSearch[i])
                                  : ptszSearch[i]));
        IRTLASSERT(ptn->CheckNodeToken());
        
        const _TOKEN* const ptok = ptn->m_ptok;

        if (ptok != NULL)
        {
            IRTLASSERT(i == (int) _tcslen(ptn->m_ptszToken) - 1);

            if (pctchMatched != NULL)
                *pctchMatched = i+1;

            return ptok;
        }

        ptn = ptn->m_pParent;
    } while (--i >= 0);

    return NULL;
}



// CTrie::Flush
//      flush all nodes leaving an empty trie

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::Flush()
{
    if (m_tnRoot.m_pChild != NULL)
        _DeleteTrie(m_tnRoot.m_pChild);

    m_tnRoot.m_pChild = NULL;  // or ~CTrieNode will ASSERT
    m_tnRoot.m_tchMaxChild = TCHAR_MIN;

    m_tchMinChild = m_tchMaxChild = TCHAR_MIN;
#ifdef _DEBUG
    m_ctchMaxTokenLen = 0;
#endif
#ifndef _UNICODE
    memset(m_afCharPresent, 0, sizeof(m_afCharPresent));
#endif
}



// CTrie::_DeleteTrie
//      recursively delete a subtrie

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::_DeleteTrie(
    _Node* ptn)
{
    if (ptn == NULL)
    {
        IRTLASSERT(false);
        return;
    }
    
    do
    {
        if (ptn->m_pChild != NULL)
        {
            _DeleteTrie(ptn->m_pChild);
            ptn->m_pChild = NULL;   // or ~CTrieNode will ASSERT
        }

        _Node* ptnSibling = ptn->m_pSibling;
        delete ptn;
        ptn = ptnSibling;   // tail recursion
    } while (ptn != NULL);
}



//-----------------------------------------------------------------------------
// CTrie diagnostics

#ifdef _DEBUG

// CTrie::AssertValid

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::AssertValid() const
{
    TCHAR* ptszName = static_cast<TCHAR*>
                        (_alloca(sizeof(TCHAR) * (m_ctchMaxTokenLen+1)));
    *ptszName = _T('\0');

    ASSERT_VALID(&m_tnRoot);
    IRTLASSERT(m_tnRoot.m_tchMaxChild == m_tchMaxChild);

    if (m_tnRoot.m_pChild != NULL)
    {
        IRTLASSERT(m_tchMinChild == m_tnRoot.m_pChild->m_tch);
        IRTLASSERT(m_ctchMaxTokenLen > 0);
        _AssertWalk(m_tnRoot.m_pChild, ptszName, 0);
    }
    else
    {
        IRTLASSERT(m_tchMinChild == TCHAR_MIN
                   &&  m_tchMinChild == m_tchMaxChild);
        IRTLASSERT(m_ctchMaxTokenLen == 0);
    }
}



// CTrie::_AssertWalk
//      recursively validate a subtrie

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::_AssertWalk(
    _Node* ptn,
    LPTSTR ptszName,
    int    iLevel) const
{
    IRTLASSERT(iLevel < m_ctchMaxTokenLen);
    
    do
    {
        ASSERT_VALID(ptn);
        
        ptszName[iLevel] = ptn->m_tch;
        ptszName[iLevel+1] = _T('\0');

        if (ptn->m_ptok != NULL)
        {
            IRTLASSERT(ptn->m_ptszToken != NULL);
            if (fIgnoreCase)
                IRTLASSERT(_tcsicmp(ptszName, ptn->m_ptszToken) == 0);
            else
                IRTLASSERT(_tcscmp(ptszName, ptn->m_ptszToken) == 0);
            ASSERT_VALID(ptn->m_ptok);
        }
        
        if (ptn->m_pChild != NULL)
            _AssertWalk(ptn->m_pChild, ptszName, iLevel+1);

        ptn = ptn->m_pSibling;   // tail recursion
    } while (ptn != NULL);
}



// CTrie::Dump

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::Dump() const
{
    int cNodes = 0, cTokens = 0;
    TCHAR* ptszName = static_cast<TCHAR*>
                        (_alloca(sizeof(TCHAR) * (m_ctchMaxTokenLen+1)));
    *ptszName = _T('\0');

    TRACE0("Dumping trie...\n");

    if (m_tnRoot.m_pChild != NULL)
        _DumpWalk(m_tnRoot.m_pChild, ptszName, 0, cNodes, cTokens);

    TRACE2("%d nodes, %d tokens\n", cNodes, cTokens);
}



// CTrie::_DumpWalk
//      recursively dump a subtrie

template <class _TOKEN, bool fIgnoreCase, bool fDeleteTokens>
void
CTrie<_TOKEN, fIgnoreCase, fDeleteTokens>::_DumpWalk(
    _Node* ptn,
    LPTSTR ptszName,
    int    iLevel,
    int&   rcNodes,
    int&   rcTokens) const
{
    IRTLASSERT(iLevel < m_ctchMaxTokenLen);

    do
    {
        ASSERT_VALID(ptn);
        
        ++rcNodes;
        ptszName[iLevel] = ptn->m_tch;
        ptszName[iLevel+1] = _T('\0');

        if (ptn->m_ptok != NULL)
        {
            ++rcTokens;
            IRTLASSERT(ptn->m_ptszToken != NULL);
            TRACE2("\t%s (%s): ", ptszName, ptn->m_ptszToken);
            DUMP(ptn->m_ptok);
            TRACE0("\n");
        }
        
        if (ptn->m_pChild != NULL)
            _DumpWalk(ptn->m_pChild, ptszName, iLevel+1, rcNodes, rcTokens);

        ptn = ptn->m_pSibling;   // tail recursion
    } while (ptn != NULL);
}

#endif // _DEBUG

#endif // __TRIE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\tsrc.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name:
      tsrc.h

   Abstract:
      This file declares resource IDs

   Environment:

       Win32 User Mode

   Project:

       Internet Services Common DLL

   Revision History:

--*/

#define IDS_IIS_OP	100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\svmap.h ===
/*++

    Copyright    (c)    1995-1996    Microsoft Corporation

    Module  Name :
        svmap.h

    Abstract:
   

    Author:

        Taylor Weiss    ( TaylorW )     19-Apr-1999

    Environment:


    Project:
        
        svmap.lib       private\inet\iis\isrtl\svmap

        Clients:

        w3svc.dll       private\inet\iis\svcs\w3\server
        wam.dll         private\inet\iis\svcs\wam\object

    Functions Exported:


    Revision History:

--*/
#ifndef SVMAP_H
#define SVMAP_H

#include <srvvarid.h>

#define SV_DATA_INVALID_OFFSET      (~0)

// Possibly derive from data dictionary
class SV_CACHE_MAP
/*++

Class Description:

    Provides a lookup map for server variable names. Maps names onto
    IDs. Used to cache server variables for out of process applications.

    The interface for this class is similar to that for the HTTP header
    map.

    Note: This mapping mechanism is specific to the intended use of this
    class. May want to replace the implementation with an LKR hash.
    The assumption I made was that we would have a lower overhead mapping
    mechanism if it was customized for this purpose.

--*/
{
public:
    
    SV_CACHE_MAP()
    /*++

    Routine Description:

        Create a server variable map.
    
    --*/
    {
        // Init the memory for the cache entries - 0xFF is an empty
        // entry

        ::FillMemory( m_rgHashTable, sizeof(m_rgHashTable), ~0 );
    }

    BOOL    Initialize( VOID );

    BOOL    FindOrdinal( IN LPCSTR pszName,
                         IN INT    cchName,
                         OUT DWORD * pdwOrdinal
                         ) const;

    LPCSTR  FindName( IN DWORD dwOrdinal ) const
    /*++

    Routine Description:

        Return the name of the server variable corresponding to dwOrdinal
    
    --*/
    {
        DBG_ASSERT( dwOrdinal < SVID_COUNT );
        return SV_CACHE_MAP::sm_rgNames[dwOrdinal].name;
    }

    DWORD   NumItems( VOID ) const
    /*++

    Routine Description:

        Return the number of items held in the map.
    
    --*/
    {
        return SV_COUNT;
    }

    DWORD   FindLen( IN DWORD dwOrdinal ) const
    /*++

    Routine Description:

        Return the length of the server variable corresponding to dwOrdinal
    
    --*/
    {
        DBG_ASSERT( dwOrdinal < SVID_COUNT );
        return SV_CACHE_MAP::sm_rgNames[dwOrdinal].len;
    }

    // The Print functions are unsafe and should only be used when
    // debugging and not in regular CHK builds
    VOID    PrintToBuffer( IN CHAR *       pchBuffer,
                           IN OUT LPDWORD  pcch
                           ) const;

    VOID    Print( VOID ) const;

private:

    enum 
    { 
        SV_COUNT                = SVID_COUNT, 

        // Table size based on initial choice of which server variables
        // to cache.
        TABLE_SIZE              = 256, 
        HASH_MODULUS            = 251,
    };

    // Holds the server variable id.
    struct HASH_TABLE_ENTRY
    /*++

    Class Description:

        Since the server variables that are designated as cachable
        are preselected, we can use a simple hash entry structure.
        Each entry can handle four possible values (slots). Since
        the number of server variables is < 128 we use the high bit
        to determine if a slot is empty. 
        
        The data value is the id of the server variable.

    --*/
    {
        enum 
        { 
            MAX_ITEMS               = 4,
            ITEM_EMPTY_FLAG         = 0x80,
        };

        BOOL InsertValue( DWORD dwValue )
        {
            DBG_ASSERT( !(dwValue & ITEM_EMPTY_FLAG) );
            
            BOOL fReturn = FALSE;
            for( int i = 0; i < MAX_ITEMS; ++i )
            {
                if( items[i] & ITEM_EMPTY_FLAG )
                {
                    items[i] = (BYTE)dwValue;
                    fReturn = TRUE;
                    break;
                }
            }
            return fReturn;
        }

        BOOL IsSlotEmpty( int item ) const
        {
            DBG_ASSERT( item >= 0 && item < MAX_ITEMS );
            return ( items[item] & ITEM_EMPTY_FLAG );
        }

        DWORD GetSlotValue( int item ) const
        {
            DBG_ASSERT( item >= 0 && item < MAX_ITEMS );
            return items[item];           
        }

        BYTE    items[MAX_ITEMS];
    };

    // Internal struct used to generate a static table of the
    // server variables that we will cache.
    struct SV_NAME
    {
        LPCSTR      name;
        DWORD       len;
    };

    // String hashing routines based on those used by LKR hash.

    // These are pretty generic and should be customizable given
    // our limited data set. But I wasn't able to come up with
    // anything better.

    inline DWORD
    HashString( LPCSTR psz ) const
    {
        DWORD dwHash = 0;

        for (  ;  *psz;  ++psz)
        {
            dwHash = 37 * dwHash  +  *psz;
        }
        return dwHash % HASH_MODULUS;
    }

    inline DWORD
    HashStringWithCount( LPCSTR psz, DWORD *pch ) const
    {
        DWORD dwHash = 0;
        DWORD cch = 0;

        for (  ;  *psz;  ++psz, ++cch)
        {
            dwHash = 37 * dwHash  +  *psz;
        }
        *pch = cch;
        return dwHash % HASH_MODULUS;
    }

    inline BOOL
    StringMatches(
        IN LPCSTR   psz,
        IN DWORD    cch,
        IN DWORD    dwOrdinal
        ) const
    /*++

    Routine Description:

        Compare the given string to the server variable name corresponding
        to dwOrdinal.
    
    --*/
    {
        return ( cch == FindLen(dwOrdinal) && 
                 strcmp( psz, FindName(dwOrdinal) ) == 0 
                 );
    }
    
private:
    
    // Member data

    // Our hash table. Maps SV_NAMES to ordinals
    HASH_TABLE_ENTRY    m_rgHashTable[TABLE_SIZE];

    // Static data

    // Table of the server variables that are cachable
    static SV_NAME      sm_rgNames[SV_COUNT];
};

class SV_CACHE_LIST
/*++

Class Description:

    This actually forms the "cache" of the server variables. We don't
    store any data here only the intent to store data. 
    
    This class is a list of those server variables that we will retrieve 
    and then marshal to the remote application.

--*/
{
public:

    DWORD Size( VOID )
    {
        return SVID_COUNT;
    }

    BOOL GetCacheIt( DWORD item )
    {
        return m_rgItems[item].fCached;
    }

    VOID SetCacheIt( DWORD item, BOOL fCacheIt = TRUE )
    {
        m_rgItems[item].fCached = fCacheIt;
    }

    // This is kinda hokey

    // BUFFER_ITEM and GetBufferItems are use to initialize the
    // array that we will marshal to the remote process. There should
    // be much better way to do this, but I want to avoid any locking
    // issues so keeping around the number of cached items is
    // problematic.

    struct BUFFER_ITEM
    {
        DWORD       svid;
        DWORD       dwOffset;
    };

    VOID 
    GetBufferItems
    ( 
        IN OUT BUFFER_ITEM *    pBufferItems,
        IN OUT DWORD *          pdwBufferItemCount
    );

private:

    // We are using a single bit to indicate the cached/not-cached
    // status. We want to minimize space usage as this may end up
    // being cached on a per-url basis.
        
    struct ITEM
    {
        // Init here or zero the memory in SV_CACHE_LIST ctor
        // It looks like when this is built fre that it does a
        // pretty good job of optimizing it. But if ZeroMemory is
        // linked in locally it might be faster.
        ITEM() : fCached(FALSE) {}
        BOOL    fCached : 1;
    };

    ITEM    m_rgItems[SVID_COUNT];
};


#endif // SVMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\tcpcons.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    TCPcons.hxx

    This file contains the global constant definitions for the
    TCP Service.


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     03-Mar-1995 Modified to remove old definitions for
                                    the new Internet Services DLL

*/


#ifndef _TCPCONS_H_
#define _TCPCONS_H_

//
//  No string resource IDs should be below this value.  Everything below this
//  is reserved for the system error messages
//

#define STR_RES_ID_BASE        7000


//
//  The string resource ID for the error responses is offset by this value
//

#define ID_HTTP_ERROR_BASE          (STR_RES_ID_BASE+1000)
#define ID_HTTP_ERROR_MAX           (STR_RES_ID_BASE+6999)

#define ID_GOPHER_ERROR_BASE        (ID_HTTP_ERROR_MAX+1)
#define ID_GOPHER_ERROR_MAX         (ID_HTTP_ERROR_MAX+6999)

#define ID_FTP_ERROR_BASE           ( ID_GOPHER_ERROR_MAX + 1)
#define ID_FTP_ERROR_MAX            ( ID_FTP_ERROR_BASE + 6998)
 

//
//  TCP API specific access rights.
//

#define TCP_QUERY_SECURITY              0x0001
#define TCP_SET_SECURITY                0x0002
#define TCP_ENUMERATE_USERS             0x0004
#define TCP_DISCONNECT_USER             0x0008
#define TCP_QUERY_STATISTICS            0x0010
#define TCP_CLEAR_STATISTICS            0x0020
#define TCP_QUERY_ADMIN_INFORMATION     0x0040
#define TCP_SET_ADMIN_INFORMATION       0x0080

#define TCP_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED       | \
                                 TCP_QUERY_SECURITY            | \
                                 TCP_SET_SECURITY              | \
                                 TCP_ENUMERATE_USERS           | \
                                 TCP_DISCONNECT_USER           | \
                                 TCP_QUERY_STATISTICS          | \
                                 TCP_CLEAR_STATISTICS          | \
                                 TCP_QUERY_ADMIN_INFORMATION   | \
                                 TCP_SET_ADMIN_INFORMATION       \
                                )

#define TCP_GENERIC_READ       (STANDARD_RIGHTS_READ           | \
                                 TCP_QUERY_SECURITY            | \
                                 TCP_ENUMERATE_USERS           | \
                                 TCP_QUERY_ADMIN_INFORMATION   | \
                                 TCP_QUERY_STATISTICS)

#define TCP_GENERIC_WRITE      (STANDARD_RIGHTS_WRITE          | \
                                 TCP_SET_SECURITY              | \
                                 TCP_DISCONNECT_USER           | \
                                 TCP_SET_ADMIN_INFORMATION     | \
                                 TCP_CLEAR_STATISTICS)

#define TCP_GENERIC_EXECUTE    (STANDARD_RIGHTS_EXECUTE)



#endif  // _TCPCONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\uspud.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    uspud.h

Abstract:

    Contains structures and declarations for SPUD.  SPUD stands for the
    Special Purpose Utility Driver.  This driver enhances the performance
    of IIS.

Author:

    John Ballard (jballard)    21-Oct-1996

Revision History:

    Keith Moore (keithmo)      02-Feb-1998
        Merged with private\inc\spud.h.

--*/


#ifndef _USPUD_H_
#define _USPUD_H_


#ifdef __cplusplus
extern "C" {
#endif


//
// The current SPUD interface version number. This number is passed by
// the user-mode code into SPUDInitialize() and *must* match the number
// expected by the driver.
//
// IIS4 (aka K2, NTOP 4.0, etc) shipped with version 0x00010000
//
// NT5 will ship with 0x00020000
//

#define SPUD_VERSION     0x00020000


//
// Oplock break notification types. This is a bad attempt to make the
// standard NTIO notification types more readable.
//
// SPUD_OPLOCK_BREAK_OPEN is issued after an oplock has been successfully
// acquired and a subsequent open is issued on the target file. This is
// our clue to close the file as soon as practicable. (The thread that issued
// the subsequent open will remain blocked until our file handle is closed,
// thus we must be expeditious in closing the handle.)
//
// SPUD_OPLOCK_BREAK_CLOSE is issued after an oplock has been successfully
// acquired and the target file handle is closed. Think of this as
// STATUS_CANCELLED for oplock IRPs.
//

#define SPUD_OPLOCK_BREAK_OPEN      FILE_OPLOCK_BROKEN_TO_LEVEL_2
#define SPUD_OPLOCK_BREAK_CLOSE     FILE_OPLOCK_BROKEN_TO_NONE


//
// Request type & context, used for batched (XxxAndRecv) APIs.
//

typedef enum {
    TransmitFileAndRecv,
    SendAndRecv
} REQ_TYPE, *PREQ_TYPE;

typedef struct _SPUD_REQ_CONTEXT {
    REQ_TYPE ReqType;
    IO_STATUS_BLOCK IoStatus1;
    IO_STATUS_BLOCK IoStatus2;
    PVOID KernelReqInfo;
} SPUD_REQ_CONTEXT, *PSPUD_REQ_CONTEXT;


//
// File information returned by SPUDCreateFile().
//

typedef struct _SPUD_FILE_INFORMATION {
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
} SPUD_FILE_INFORMATION, *PSPUD_FILE_INFORMATION;


//
// Activity counters.
//

typedef struct _SPUD_COUNTERS {
    ULONG CtrTransmitfileAndRecv;
    ULONG CtrTransRecvFastTrans;
    ULONG CtrTransRecvFastRecv;
    ULONG CtrTransRecvSlowTrans;
    ULONG CtrTransRecvSlowRecv;
    ULONG CtrSendAndRecv;
    ULONG CtrSendRecvFastSend;
    ULONG CtrSendRecvFastRecv;
    ULONG CtrSendRecvSlowSend;
    ULONG CtrSendRecvSlowRecv;
} SPUD_COUNTERS, *PSPUD_COUNTERS;


//
// Exported APIs.
//

NTSTATUS
NTAPI
SPUDInitialize(
    IN ULONG Version,
    IN HANDLE hPort
    );

NTSTATUS
NTAPI
SPUDTerminate(
    VOID
    );

NTSTATUS
NTAPI
SPUDTransmitFileAndRecv(
    IN HANDLE hSocket,
    IN struct _AFD_TRANSMIT_FILE_INFO *transmitInfo,
    IN struct _AFD_RECV_INFO *recvInfo,
    IN PSPUD_REQ_CONTEXT reqContext
    );

NTSTATUS
NTAPI
SPUDSendAndRecv(
    IN HANDLE hSocket,
    IN struct _AFD_SEND_INFO *sendInfo,
    IN struct _AFD_RECV_INFO *recvInfo,
    IN PSPUD_REQ_CONTEXT reqContext
    );

NTSTATUS
NTAPI
SPUDCancel(
    IN PSPUD_REQ_CONTEXT reqContext
    );

NTSTATUS
NTAPI
SPUDGetCounts(
    OUT PSPUD_COUNTERS SpudCounts
    );

NTSTATUS
NTAPI
SPUDCreateFile(
    OUT PHANDLE FileHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateOptions,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecDescBuffer,
    IN ULONG SecDescLength,
    OUT PULONG SecDescLengthNeeded,
    IN PVOID OplockContext,
    IN LARGE_INTEGER OplockMaxFileSize,
    OUT PBOOLEAN OplockGranted,
    OUT PSPUD_FILE_INFORMATION FileInfo
    );


#ifdef __cplusplus
}
#endif


#endif  // _USPUD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\urlutil.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

/*
    urlutil.hxx

    This module contains various URL utility functions

    FILE HISTORY:
        Johnl       04-Apr-1995     Created

*/

#ifndef _URLUTIL_H_
#define _URLUTIL_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  This indicates the URL is an enumerated type that should use
//  InternetFindFirstFile/<Protocol>FindNextFile
//
//  URL_FLAGS_DIR_OR_FILE indicates we can't tell whether the URL is a
//  directory or a file, so assume it's a directory and if that fails, retry
//  as a file (handles ftp case where there isn't a trailing '/')
//

#define URL_FLAGS_DIRECTORY_OP          0x00000001
#define URL_FLAGS_SEARCH_OP             0x00000002
#define URL_FLAGS_GOPHER_PLUS           0x00000004
#define URL_FLAGS_DIR_OR_FILE           0x00000008

typedef struct _URL_DESCRIPTOR
{
    DWORD          dwFlags;
    DWORD          dwServiceType;
    CHAR *         pszProtocol;
    CHAR *         pszServer;
    INTERNET_PORT  sPort;
    CHAR *         pszPath;
    CHAR *         pszUserName;
    CHAR *         pszPassword;
    CHAR *         pszSearchTerms;      // Gopher search items
    CHAR *         pszExtra;            // Gopher+ data
    DWORD          GopherType;

} URL_DESCRIPTOR, *LPURL_DESCRIPTOR;

BOOL
CrackURLInPlace(
    IN OUT CHAR *           pszURL,
    OUT    URL_DESCRIPTOR * pUrlDesc
    );

VOID
Unescape(
    CHAR *        pch
    );

#ifdef __cplusplus
}
#endif

#endif // _URLUTIL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\wmrgexp.h ===
/*===================================================================
Microsoft IIS

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: WAMREG

File: wmrgexp.h

Owner: leijin

Note:
===================================================================*/
#ifndef _WAMREG_EXPORT_H
#define _WAMREG_EXPORT_H

#ifndef _WAMREG_DLL_
#define PACKMGR_LIBAPI __declspec(dllimport)
#else
#define PACKMGR_LIBAPI __declspec(dllexport)
#endif

#define DEFAULT_PACKAGENAME		L"IIS In-Process Applications"
#define APPCMD_NONE				0
#define APPCMD_VERIFY			1
#define APPCMD_GETSTATUS		2
#define APPCMD_CREATE			3
#define APPCMD_CREATEINPROC		4
#define APPCMD_CREATEOUTPROC	5
#define APPCMD_CHANGETOINPROC	6
#define APPCMD_CHANGETOOUTPROC	7
#define APPCMD_DELETE			8
#define APPCMD_UNLOAD			9

#define APPSTATUS_Error             0		// Error while getting status from W3SVC
#define APPSTATUS_UnLoaded          1		// App is successfully found in W3SVC and unloaded.
#define APPSTATUS_Running           2		// App is currently found in W3SVC and is running.
#define APPSTATUS_Stopped           3		// App is found in W3SVC and stopped.
#define APPSTATUS_NotFoundInW3SVC	4		// App is not found in w3svc.
#define APPSTATUS_NOW3SVC			5		// W3SVC is not running.
#define APPSTATUS_PAUSE				6		// App is in PAUSE state.(Halfway in DeleteRecoverable and Recover).

//
// Version String for WAMREG
// Used for update applications in old WAMREG into new WAMREG formats.
//
enum VS_WAMREG {VS_K2Beta2, VS_K2Beta3};

typedef HRESULT (*PFNServiceNotify)	
					(
					LPCSTR		szAppPath,
					const DWORD	dwAction,
					DWORD*	pdwResult
					);

HRESULT	PACKMGR_LIBAPI	CreateIISPackage(void);
HRESULT PACKMGR_LIBAPI	DeleteIISPackage(void);
HRESULT	PACKMGR_LIBAPI	WamReg_RegisterSinkNotify(PFNServiceNotify pfnW3ServiceSink);
HRESULT PACKMGR_LIBAPI	WamReg_UnRegisterSinkNotify(void);
HRESULT	PACKMGR_LIBAPI	UpgradePackages(VS_WAMREG vs_new, VS_WAMREG vs_old);

HRESULT	
PACKMGR_LIBAPI	
CreateCOMPlusApplication( 
    LPCWSTR      szMDPath,
    LPCWSTR      szOOPPackageID,
    LPCWSTR      szOOPWAMCLSID,
    BOOL       * pfAppCreated 
    );

#endif // _WAMREG_EXPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\_ntverp.h ===
/****************************************************************************
 *                                                                          *
 *      ntverp.H        -- Version information for internal builds          *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION, VER_PRODUCTVERSION_STR and             *
 *      VER_PRODUCTBETA_STR values.                                         *
 *                                                                          *
 ****************************************************************************/

/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*                                                              */
/* the VER_PRODUCTBUILD lines must contain the product          */
/* comments (Win9x or NT) and end with the build#<CR><LF>       */
/*                                                              */
/* the VER_PRODUCTBETA_STR lines must contain the product       */
/* comments (Win9x or NT) and end with "some string"<CR><LF>    */
/*--------------------------------------------------------------*/

#define VER_PRODUCTBUILD_QFE        1

#if defined(NASHVILLE)
#define VER_PRODUCTBUILD            /* Win9x */  1089
#define VER_PRODUCTBETA_STR         /* Win9x */  ""
#define VER_PRODUCTVERSION_STR      "4.70"
#define VER_PRODUCTVERSION          4,70,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_W        (0x0446)
#define VER_PRODUCTVERSION_DW       (0x04460000 | VER_PRODUCTBUILD)

#else
#define VER_PRODUCTBUILD            /* NT */     0984
#define VER_PRODUCTBETA_STR         /* NT */     ""
#define VER_PRODUCTVERSION_STR      "5.00.0984"
#define VER_PRODUCTVERSION          5,00,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_W        (0x0500)
#define VER_PRODUCTVERSION_DW       (0x05000000 | VER_PRODUCTBUILD)

#endif

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if DBG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is prerelease */
#if BETA
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILEFLAGS               (VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Microsoft(R) Windows NT(TM) Operating System"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft(R) is a registered trademark of Microsoft Corporation. Windows NT(TM) is a trademark of Microsoft Corporation."
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\chicago\isvctrl.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

      isvctrl.h

   Abstract:

      Declares manifests, functions and macros for Internet Services Control Functions
      needed for Windows9x platforms because Service Controller is not available.

   Author:

       Vlad Sadovsky    ( VladS )    21-Mar-1996

   Environment:

      User Mode -- Win32

   Project:

      Internet Services Common DLL - Windows 9x version

   Revision History:

--*/

# ifndef _ISVCTRL_H_
# define _ISVCTRL_H_

/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <lmcons.h>

# include <inetcom.h>
# include <inetinfo.h>

# define MAX_SERVER_NAME_LEN           ( MAX_COMPUTERNAME_LENGTH + 1)
# define MAX_NT_SERVICE_NAME_LEN       ( SNLEN + 1)

#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif

#ifdef __cplusplus
extern "C" {
#endif

/************************************************************
 *   Type Definitions
 ************************************************************/

typedef struct _INET_SERVICE_DLL_TABLE_ENTRY  {
    DWORD   dwServiceId;
    LPTSTR  lpServiceName;
    LPTSTR  lpDllName;
} INET_SERVICE_DLL_TABLE_ENTRY, *LPINET_SERVICE_DLL_TABLE_ENTRY;


// Name of the window class for server main window
#define INET_SERVER_WINDOW_CLASS    "MS_INetPeerServerWindowClass"

// Name of the event, used to determine if server started
#define INET_SERVER_EVENT "MS_INetPeerServerStarted"

// Window control messages, used to communicate to peer server
#define INETSM_START_SERVICE    (WM_USER+300)
#define INETSM_STOP_SERVICE     (WM_USER+301)
#define INETSM_GET_SERVICE      (WM_USER+302)
#define INETSM_REFRESH_SERVICE_CONFIG (WM_USER+303)
#define INETSM_STARTED_SERVICE (WM_USER+304)
#define INETSM_STOP_TRAY (WM_USER+305)
#define INETSM_START_TRAY (WM_USER+306)


/************************************************************
 *   Function Prototypes
 ************************************************************/

 //
 //
 // INet admin external APIs.
 // Nb: It would be ideal to keep those APIs as RPC along with other INFOADMN
 // APIs. Until it decided to do so, we will keep them here.
 //

dllexp
NET_API_STATUS
NET_API_FUNCTION
InetInfoServiceStart(
    IN  LPWSTR  pszServer OPTIONAL,
    IN  DWORD   dwServiceId
    );

dllexp
NET_API_STATUS
NET_API_FUNCTION
InetInfoServiceStop(
    IN  LPWSTR  pszServer OPTIONAL,
    IN  DWORD   dwServiceId
    );

dllexp
NET_API_STATUS
NET_API_FUNCTION
InetInfoServiceGetStatusMask(
    IN  LPWSTR  pszServer OPTIONAL,
    IN  DWORD   dwServiceId,
    OUT LPDWORD pdwServiceStatus
    );

dllexp
NET_API_STATUS
NET_API_FUNCTION
InetInfoRefreshServiceConfiguration(
    IN  LPWSTR  pszServer OPTIONAL,
    IN  DWORD   dwServiceId
    );


//
// Internally used prototypes for Internet Services control APIs
//
dllexp
VOID
TsInitializeSC(
    IN  DWORD *pGlobalData
      );

/*++
  TsStartService()

  Description:

    This function initializes

  Arguments:

     dwINetServiceId

  Returns:
    Win32 Error code.  NO_ERROR on success.

--*/

dllexp
DWORD
TsStartService(
      IN    DWORD   dwINetServiceId
      );

dllexp
DWORD
TsStopService(
      IN    DWORD   dwINetServiceId
      );

dllexp
DWORD
TsGetServiceStatusMask(
      IN    DWORD   dwINetServiceId,
      OUT   LPDWORD pdwServiceStatus
      );


dllexp
DWORD
GetServiceIdFromName(
    IN LPTSTR pszService
    );

#ifdef __cplusplus
}
#endif

# endif // _ISVCTRL_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\w3svc.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    w3svc.h

    This file contains constants & type definitions shared between the
    W3 Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.
        MuraliK     Redefined service names

*/


#ifndef _W3SVC_H_
#define _W3SVC_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

# include <inetinfo.h>

//
//  Service name.
//

#define IPPORT_W3                      0x50

//
//  Name of the log file, used for logging file accesses.
//

#define W3_LOG_FILE                    TEXT("HTTPSVC.LOG")


//
//  Configuration parameters registry key.
//

#define W3_PARAMETERS_KEY \
            TEXT("System\\CurrentControlSet\\Services\\W3Svc\\Parameters")


//
//  Performance key.
//

#define W3_PERFORMANCE_KEY \
            TEXT("System\\CurrentControlSet\\Services\\W3Svc\\Performance")

//
//  Sub-authenticator configuration key.
//

#define W3_AUTHENTICATOR_KEY \
            TEXT("System\\CurrentControlSet\\Control\\Lsa")

//
//  Configuration value names.
//

#define W3_CHECK_FOR_WAISDB            TEXT("CheckForWAISDB")
#define W3_DEBUG_FLAGS                 TEXT("DebugFlags")
#define W3_DIR_BROWSE_CONTROL          TEXT("Dir Browse Control")
#define W3_DIR_ICON                    TEXT("Folder Image")
#define W3_DIR_ICON_W                  L"Folder Image"
#define W3_DEFAULT_FILE                TEXT("Default Load File")
#define W3_DEFAULT_FILE_W              L"Default Load File"
#define W3_SERVER_AS_PROXY             TEXT("ServerAsProxy")
#define W3_CATAPULT_USER               TEXT("CatapultUser")
#define W3_CATAPULT_USER_W             L"CatapultUser"
#define W3_SCRIPT_TIMEOUT              "ScriptTimeout"
#define W3_CACHE_EXTENSIONS            "CacheExtensions"
#define W3_SSI_ENABLED                 "ServerSideIncludesEnabled"
#define W3_SSI_EXTENSION               "ServerSideIncludesExtension"
#define W3_SSI_EXTENSION_W             L"ServerSideIncludesExtension"
#define W3_GLOBAL_EXPIRE               "GlobalExpire"
#define W3_PROVIDER_LIST               "NTAuthenticationProviders"
#define W3_SECURE_PORT                 "SecurePort"
#define W3_ENC_PROVIDER_LIST           "NTEncryptionProviders"
#define W3_ENC_FLAGS                   "EncryptionFlags"
#define W3_ACCESS_DENIED_MSG           "AccessDeniedMessage"
#define W3_DEFAULT_HOST_NAME           "ReturnUrlUsingHostName"
#define W3_ACCEPT_BYTE_RANGES          "AcceptByteRanges"
#define W3_ALLOW_GUEST                 "AllowGuestAccess"
#define W3_LOG_ERRORS                  "LogErrorRequests"
#define W3_LOG_SUCCESS                 "LogSuccessfulRequests"
#define W3_REALM_NAME                  "Realm"
#define IDC_POOL_CONN                  "PoolIDCConnections"
#define IDC_POOL_CONN_TIMEOUT          "PoolIDCConnectionsTimeout"
#define W3_UPLOAD_READ_AHEAD           "UploadReadAhead"
#define W3_USE_POOL_THREAD_FOR_CGI     "UsePoolThreadForCGI"
#define W3_ALLOW_KEEP_ALIVES           "AllowKeepAlives"
#define W3_AUTH_CHANGE_URL             "AuthChangeUrl"
#define W3_AUTH_EXPIRED_URL            "AuthExpiredUrl"
#define W3_NET_LOGON_WKS               "NetLogonWks"
#define W3_ADV_NOT_PWD_EXP_URL         "AdvNotPwdExpUrl"
#define W3_ADV_NOT_PWD_EXP_IN_DAYS     "AdvNotPwdExpInDays"
#define W3_ADV_CACHE_TTL               "AdvNotPwdExpCacheTTL"
#define W3_TEMP_DIR_NAME               "TempDirectory"
#define W3_VERSION_11                  "ReplyWithHTTP1.1"
#define W3_USE_ANDRECV                 "UseTransmitFileAndRecv"
#define W3_PUT_TIMEOUT                 "PutDeleteTimeout"

//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon.
//

#define W3_ANONYMOUS_SECRET         TEXT("W3_ANONYMOUS_DATA")
#define W3_ANONYMOUS_SECRET_A       "W3_ANONYMOUS_DATA"
#define W3_ANONYMOUS_SECRET_W       L"W3_ANONYMOUS_DATA"

//
//  The set of password/virtual root pairs
//

#define W3_ROOT_SECRET_W            L"W3_ROOT_DATA"

//
//  The password secret for the username to connect to the Catapult gateway if
//  the HTTP server is running as a Catapult proxy client
//

#define W3_PROXY_USER_SECRET_W      L"W3_PROXY_USER_SECRET"

//
//  This is the secret that contains the list of installed SSL keys
//

#define W3_SSL_KEY_LIST_SECRET      L"W3_KEY_LIST"

//
//  CAL Default values
//

#define DEFAULT_W3_CAL_W3_ERROR                     403
#define DEFAULT_W3_CAL_VC_PER_CONNECT               6
#define DEFAULT_W3_CAL_AUTH_RESERVE_TIMEOUT         600
#define DEFAULT_W3_CAL_SSL_RESERVE_TIMEOUT          600

#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _W3SVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\chicago\pbt.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*
*  TITLE:       PBT.H
*
*  VERSION:     1.0
*
*  DATE:        15 Jan 1994
*
*  Definitions for the Virtual Power Management Device.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  15 Jan 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_PBT
#define _INC_PBT

#ifndef WM_POWERBROADCAST
#define WM_POWERBROADCAST               0x218
#endif

#define PBT_APMQUERYSUSPEND             0x0000
#define PBT_APMQUERYSTANDBY             0x0001

#define PBT_APMQUERYSUSPENDFAILED       0x0002
#define PBT_APMQUERYSTANDBYFAILED       0x0003

#define PBT_APMSUSPEND                  0x0004
#define PBT_APMSTANDBY                  0x0005

#define PBT_APMRESUMECRITICAL           0x0006
#define PBT_APMRESUMESUSPEND            0x0007
#define PBT_APMRESUMESTANDBY            0x0008

#define PBTF_APMRESUMEFROMFAILURE       0x00000001

#define PBT_APMBATTERYLOW               0x0009
#define PBT_APMPOWERSTATUSCHANGE        0x000A

#define PBT_APMOEMEVENT                 0x000B

#define PBT_CAPABILITIESCHANGE			0x0010

// APM 1.2 hibernate

// #ifdef SUPPORT_HIBERNATE

#define PBT_APMQUERYHIBERNATE			0x000C
#define PBT_APMQUERYHIBERNATEFAILED		0x000D
#define PBT_APMHIBERNATE				0x000E
#define PBT_APMRESUMEHIBERNATE			0x000F

// #endif

#endif // _INC_PBT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\chicago\svrapi.h ===
/********************************************************************/
/**                     Microsoft Windows                          **/
/**               Copyright(c) Microsoft Corp., 1994               **/
/********************************************************************/

/********************************************************************
 *                                                                  *
 *  About this file ...  SVRAPI.H                                   *
 *                                                                  *
 *  This file contains information about the NetAccess,             *
 *  NetConnection, NetFile, NetServer, NetSession, NetShare and     *
 *  NetSecurity APIs.                                               *
 *  There is a section for each set of APIs.                        *
 *  Each section contains:                                          *
 *                                                                  *
 *      Function prototypes.                                        *
 *                                                                  *
 *      Data structure templates.                                   *
 *                                                                  *
 *      Definition of special values.                               *
 *                                                                  *
 *      Description of level of Win95 peer server support           *
 *
 *  For background information refer to the Lan Manager Programmer's
 *  Reference.
 *
 *  WARNING:
 *      The APIs documented herein are not guaranteed to be supported
 * in future versions of Windows. Their primary purpose is to       *
 * administer Win95 peer servers.                                   *
 *                                                                  *
 ********************************************************************/

/*
 *      NOTE:  Lengths of ASCIIZ strings are given as the maximum
 *      strlen() value.  This does not include space for the
 *      terminating 0-byte.  When allocating space for such an item,
 *      use the form:
 *
 *              char username[LM20_UNLEN+1];
 *
 *      An exception to this is the PATHLEN manifest, which does
 *      include space for the terminating 0-byte.
 *
 *      User names, computer names and share names should be
 *      upper-cased by the caller and drawn from the ANSI
 *      character set.
 *
 */

/*NOINC*/
#ifndef SVRAPI_INCLUDED
#define SVRAPI_INCLUDED

#include <lmcons.h>
#include <lmerr.h>

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#if !defined(_SVRAPI_)
#define API_FUNCTION DECLSPEC_IMPORT API_RET_TYPE APIENTRY
#else
#define API_FUNCTION API_RET_TYPE APIENTRY
#endif

/*INC*/


/****************************************************************
 *                                                              *
 *                 Access Class                                 *
 *                                                              *
 ****************************************************************/


/****************************************************************
 *                                                              *
 *                  Function prototypes - ACCESS                *
 *
 * 	Requires User level security to be enabled
 *                                                              *
 *	Peer Server Support:
 *      Remote support of these APIs on NWSERVER is limited as
 *      described below:
 *
 *		NetAccessAdd -
 *				local and remote VSERVER - level 2
 *              remote NWSERVER -          level 2
 *	    NetAccessCheck - local only
 *      NetAccessDel -
 *              local, remote NWSERVER and remote VSERVER
 *      NetAccessEnum -
 *              sLevel 0 on remote NWSERVER (fRecursive = 1),
 *              slevel 0, 1, 2 on local and remote VSERVER
 *		NetAccessGetInfo -
 *               all sLevels on local and remote VSERVER,
 *      		 sLevel 0, 12 on remote NWSERVER
 *      NetAccessSetInfo -
 *              sLevel 1, 12 on local and remote VSERVER,
 *              sLevel 12 on remote NWSERVER
 *              parmnum = PARMNUM_ALL only
 *      NetAccessGetUserPerms - local and remote VSERVER only
 ****************************************************************/

extern API_FUNCTION
  NetAccessAdd ( const char FAR * pszServer,
                 short            sLevel,
                 char FAR *       pbBuffer,
                 unsigned short   cbBuffer );

extern API_FUNCTION
  NetAccessCheck ( char FAR *           pszReserved,
                   char FAR *           pszUserName,
                   char FAR *           pszResource,
                   unsigned short       usOperation,
                   unsigned short FAR * pusResult );

extern API_FUNCTION
  NetAccessDel ( const char FAR * pszServer,
                 char FAR *       pszResource );

extern API_FUNCTION
  NetAccessEnum ( const char FAR *     pszServer,
                  char FAR *           pszBasePath,
                  short                fsRecursive,
                  short                sLevel,
                  char FAR *           pbBuffer,
                  unsigned short       cbBuffer,
                  unsigned short FAR * pcEntriesRead,
                  unsigned short FAR * pcTotalAvail );

extern API_FUNCTION
  NetAccessGetInfo ( const char FAR *     pszServer,
                     char FAR *           pszResource,
                     short                sLevel,
                     char FAR *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short FAR * pcbTotalAvail );

extern API_FUNCTION
  NetAccessSetInfo ( const char FAR * pszServer,
                     char FAR *       pszResource,
                     short            sLevel,
                     char FAR *       pbBuffer,
                     unsigned short   cbBuffer,
                     short            sParmNum );

extern API_FUNCTION
  NetAccessGetUserPerms ( char FAR *           pszServer,
                          char FAR *           pszUgName,
                          char FAR *           pszResource,
                          unsigned short FAR * pusPerms );


/****************************************************************
 *                                                              *
 *              Data structure templates - ACCESS               *
 *                                                              *
 ****************************************************************/

struct access_list {
        char            acl_ugname[LM20_UNLEN+1];
        char            acl_ugname_pad_1;
        short           acl_access;
};      /* access_list */

struct access_list_2
{
        char FAR *      acl2_ugname;
        unsigned short  acl2_access;
};      /* access_list_2 */

struct access_list_12
{
        char FAR *      acl12_ugname;
        unsigned short  acl12_access;
};      /* access_list_12 */

struct access_info_0 {
        char FAR *      acc0_resource_name;
};      /* access_info_0 */

struct access_info_1 {
        char  FAR *     acc1_resource_name;
        short           acc1_attr;                      /* See values below */
        short           acc1_count;
};      /* access_info_1 */

struct access_info_2
{
        char  FAR *     acc2_resource_name;
        short           acc2_attr;
        short           acc2_count;
};      /* access_info_2 */

struct access_info_10 {
        char FAR *      acc10_resource_name;
};      /* access_info_10 */

struct access_info_12
{
        char  FAR *     acc12_resource_name;
        short           acc12_attr;
        short           acc12_count;
};      /* access_info_12 */


/****************************************************************
 *                                                              *
 *              Special values and constants - ACCESS           *
 *                                                              *
 ****************************************************************/

/*
 *      Maximum number of permission entries for each resource.
 */

#define MAXPERMENTRIES  64


/*
 *      Bit values for the access permissions.  ACCESS_ALL is a handy
 *      way to specify maximum permissions.  These are used in
 *      acl_access field of access_list structures.
 */
/*NOINC*/
#define         ACCESS_NONE     0
#define         ACCESS_ALL     (ACCESS_READ|ACCESS_WRITE|ACCESS_CREATE|ACCESS_EXEC|ACCESS_DELETE|ACCESS_ATRIB|ACCESS_PERM|ACCESS_FINDFIRST)
/*INC*/
#define         ACCESS_READ     0x1
#define         ACCESS_WRITE    0x2
#define         ACCESS_CREATE   0x4
#define         ACCESS_EXEC     0x8
#define         ACCESS_DELETE   0x10
#define         ACCESS_ATRIB    0x20
#define         ACCESS_PERM     0x40
#define         ACCESS_FINDFIRST 0x80

#define         ACCESS_GROUP    0x8000

/*
 *      Bit values for the acc1_attr field of the access_info_1 structure.
 *      Only one bit is currently defined.
 */

#define         ACCESS_AUDIT            0x1

/*
 *      Parmnum value for NetAccessSetInfo.
 */

#define         ACCESS_ATTR_PARMNUM     2


/*
 *      ACCESS_LETTERS defines a letter for each bit position in
 *      the acl_access field of struct access_list.  Note that some
 *      bits have a corresponding letter of ' ' (space).
 */

#define         ACCESS_LETTERS          "RWCXDAP         "



/****************************************************************
 *								*
 *	  	Share Class			                *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - SHARE                     *
 *                                                              *
 *	Peer Server Support
 * 		NetShareAdd() - sLevel 50 on VSERVER and NWSERVER
 * 		NetShareDel() - VSERVER and NWSERVER
 *		NetShareEnum() - sLevel 1,50 on VSERVER; 50 on NWSERVER
 *      NetShareGetInfo() - sLevel 50 on VSERVER, NWSERVER
 * 		NetShareSetInfo() - sLevel 50, sParmNum PARMNUM_ALL
 *						 on VSERVER, NWSERVER
 ****************************************************************/

/***	NetShareAdd - add a new share to the server tables
 *
 *	NetShareAdd( servername, level, buf, buflen )
 *
 *	ENTRY:	servername - asciz string containing name of server
 *                       or NULL if local
 *		level- Must be 50 for Win95 peer servers.
 *		buf - far ptr to struct share_info
 *		buflen - unsigned int length of buffer
 *
 *	EXIT:	0 = success
 *		ERROR_INVALID_LEVEL
 *      ERROR_BAD_NETPATH
 *		ERROR_INVALID_PARAMETER
 *		NERR_UnknownDevDir
 *		NERR_ShareExists
 *		NERR_UnknownServer
 *		NERR_ServerNotStarted
 *		NERR_RedirectedPath
 *		NERR_DuplicateShare
 *		NERR_BufTooSmall
 *		ERROR_NOT_ENOUGH_MEMORY
 *
 */
extern API_FUNCTION
  NetShareAdd ( const char FAR * pszServer,
                short            sLevel,
                const char FAR * pbBuffer,
                unsigned short   cbBuffer );

/***	NetShareDel (Admin only)
 *
 *	API_FUNCTION NetShareDel( servername, netname, reserved )
 *
 *	ENTRY
 *
 *	char FAR *  servername;     asciz remote srv name, NULL if local
 *	char FAR *  netname;        asciz network name of share being deleted
 *	unsigned short reserved;    MBZ
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *  ERROR_BAD_NETPATH
 *	NERR_ServerNotStarted
 *	NERR_NetNameNotFound
 *	ERROR_INVALID_PARAMETER
 *
 *
 *	Note:  Deleting a share will also delete any existing connections
 *		to the shared resource, and close open files within the
 *		connections.
 */
extern API_FUNCTION
  NetShareDel ( const char FAR * pszServer,
                const char FAR * pszNetName,
                unsigned short   usReserved );

/* 2.1  NetShareEnum
 *
 * API_FUNCTION
 * NetShareEnum( servername, level, buf, buflen, entriesread, totalentries )
 * char FAR *          servername;     asciz remote server name or NULL if local
 * short               sLevel;         level of detail requested; 1 or 50
 * char FAR *          pbBuffer;       buffer to return entries in
 * unsigned short      cbBuffer;       size of buffer on call
 * unsigned short FAR *pcEntriesRead;  # of entries supplied on return
 * unsigned short FAR *pcTotalAvail ;  total # of entries available
 *
 * Supply information about existing shares at specified level.
 *
 * Buffer contents on response (format for a single entry):
 *     Level 1 contains a "struct share_info_1".
 *     Level 50 contains a "struct share_info_50".
 *
 * Returns 0 if successful.  Possible error returns:
 *  ERROR_INVALID_LEVEL
 *  ERROR_BAD_NETPATH
 *  NERR_NetNotStarted
 *  NERR_ServerNotStarted
 *  ERROR_MORE_DATA
 */
extern API_FUNCTION
  NetShareEnum ( const char FAR *     pszServer,
                 short                sLevel,
                 char FAR *           pbBuffer,
                 unsigned short       cbBuffer,
                 unsigned short FAR * pcEntriesRead,
                 unsigned short FAR * pcTotalAvail );

/* 2.2  NetShareGetInfo
 *
 * Purpose: Read complete information about a single outstanding share.
 *
 * API_FUNCTION
 * NetShareGetInfo( servername, netname, level, buf, buflen, totalavail )
 * char FAR *          servername;     asciz remote server name or NULL if local
 * char FAR *          netname;        asciz network name of share being queried
 * short               level;          level of info requested (50 for Win95 peer servers)
 * char FAR *          buf;            for returned entry
 * unsigned short      buflen;         size of buffer
 * unsigned short FAR *totalavail;     total size needed for buffer
 *
 * Buffer contents on response:
 *     Level 50 contains a "struct share_info_50".
 *
 * Returns 0 if successful.  Possible error returns:
 *  ERROR_INVALID_LEVEL
 *  ERROR_INVALID_PARAMETER
 *  ERROR_BAD_NETPATH
 *  NERR_NetNotStarted
 *  NERR_ServerNotStarted
 *  NERR_NetNameNotFound
 *  NERR_MoreData
 *  NERR_BufTooSmall
 */
extern API_FUNCTION
  NetShareGetInfo ( const char FAR *     pszServer,
                    const char FAR *     pszNetName,
                    short                sLevel,
                    char FAR *           pbBuffer,
                    unsigned short       cbBuffer,
                    unsigned short FAR * pcbTotalAvail );

/***	NetShareSetInfo (Admin only)
 *
 *	API_FUNCTION NetShareSetInfo( servername,
 *					netname,
 *					level,
 *					buf,
 *					buflen,
 *					parmnum )
 *					
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	netname;        asciz network name of share being set
 *	level;		level of info provided (50 for Win95 peer servers)
 *	buf;            contents described below
 *	buflen;         size of buffer
 *	parmnum;        must be PARMNUM_ALL for Win95 peer servers
 *
 *	Buffer contents on call if parmnum is zero:
 *   	    Level 50 contains a "struct share_info_50".
 *
 *	Settable fields are:
 *          shi_remark
 *          shi_passwd
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	NERR_NetNameNotFound
 *	ERROR_INVALID_LEVEL
 * 	NERR_BufTooSmall
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 *	ERROR_INVALID_PARAMETER
 ***/
extern API_FUNCTION
  NetShareSetInfo ( const char FAR * pszServer,
                    const char FAR * pszNetName,
                    short            sLevel,
                    const char FAR * pbBuffer,
                    unsigned short   cbBuffer,
                    short            sParmNum );


/****************************************************************
 *								*
 *	  	Data structure templates - SHARE		*
 *
 ****************************************************************/

struct share_info_0 {
    char		shi0_netname[LM20_NNLEN+1];
};  /* share_info_0 */

struct share_info_1 {
    char		shi1_netname[LM20_NNLEN+1];
    char		shi1_pad1;
    unsigned short	shi1_type;
    char FAR *		shi1_remark;
};  /* share_info_1 */

struct share_info_2 {
    char		shi2_netname[LM20_NNLEN+1];
    char		shi2_pad1;
    unsigned short	shi2_type;
    char FAR *		shi2_remark;
    unsigned short	shi2_permissions;
    unsigned short	shi2_max_uses;
    unsigned short	shi2_current_uses;
    char FAR *		shi2_path;
    char 		shi2_passwd[SHPWLEN+1];
    char		shi2_pad2;
};  /* share_info_2 */

struct share_info_50 {
	char		shi50_netname[LM20_NNLEN+1];    /* share name */
	unsigned char 	shi50_type;                 /* see below */
    unsigned short	shi50_flags;                /* see below */
	char FAR *	shi50_remark;                   /* ANSI comment string */
	char FAR *	shi50_path;                     /* shared resource */
	char		shi50_rw_password[SHPWLEN+1];   /* read-write password (share-level security) */
	char		shi50_ro_password[SHPWLEN+1];   /* read-only password (share-level security) */
};	/* share_info_50 */


/****************************************************************
 *								*
 *	  	Special values and constants - SHARE		*
 *								*
 ****************************************************************/

/* Field values for shi50_flags; */

/* These flags are relevant for share-level security on VSERVER
 * When operating with user-level security, use SHI50F_FULL - the actual
 * access rights are determined by the NetAccess APIs.
 */
#define	SHI50F_RDONLY		0x0001
#define	SHI50F_FULL			0x0002
#define	SHI50F_DEPENDSON	(SHI50F_RDONLY|SHI50F_FULL)
#define	SHI50F_ACCESSMASK	(SHI50F_RDONLY|SHI50F_FULL)

//
// Attn: Those defines are needed to build MSSHRUI. Still need to confirm
// with BSD SMB team validity of those
//
#define SHI50F_HTTP_READ_ONLY	 0x0010
#define SHI50F_HTTP_EXECUTE	 0x0020
#define SHI50F_HTTP_SECURE	 0x0040
#define SHI50F_HTTP_SHARED	 0x0080
#define SHI50F_FTP_READ_ONLY	 0x1000
#define SHI50F_FTP_WRITE	 0x2000
#define SHI50F_FTP_SHARED	 0x4000

/* The share is restored on system startup */
#define	SHI50F_PERSIST		0x0100
/* The share is not normally visible  */
#define SHI50F_SYSTEM		0x0200


/*
 *	Values for parmnum parameter to NetShareSetInfo.
 */

#ifndef PARMNUM_ALL
#define PARMNUM_ALL				0
#endif

#define	SHI_REMARK_PARMNUM		4
#define	SHI_PERMISSIONS_PARMNUM		5
#define	SHI_MAX_USES_PARMNUM		6
#define	SHI_PASSWD_PARMNUM		9

#define	SHI1_NUM_ELEMENTS		4
#define	SHI2_NUM_ELEMENTS		10


/*
 *	Share types .
 *
 *  STYPE_DISKTREE and STYPE_PRINTQ are recognized on peer servers
 */

#define STYPE_DISKTREE 			0       /* disk share */
#define STYPE_PRINTQ   			1       /* printer share */
#define STYPE_DEVICE   			2
#define STYPE_IPC      			3

#define SHI_USES_UNLIMITED		-1



/****************************************************************
 *								*
 *	  	Session Class			                *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - SESSION                   *
 *
 *	Peer Server Support                                         *
 *  	NetSessionDel() - NWSERVER and VSERVER 					*
 *	    NetSessionEnum() - sLevel 50 on NWSERVER and VSERVER    *
 *		NetSessionGetInfo() - not supported on peer servers     *
 ****************************************************************/

/***	NetSessionDel (Admin only)
 *
 *
 *	API_FUNCTION NetSessionDel( servername, clientname, reserved )
 *
 *	ENTRY
 *
 * 	servername;     asciz remote srv name, NULL if local
 *	clientname;     asciz remote computer name (returned by NetSessionEnum)
 *                               	of session being deleted
 *                  In the case of a Win95 NWSERVER, the clientname should be the
 *                  ascii connection number
 *	reserved;       session key returned by NetSessionEnum
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *  ERROR_BAD_NETPATH
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	NERR_RemoteOnly
 * 	ERROR_ACCESS_DENIED
 *	NERR_BufTooSmall
 *	NERR_ClientNameNotFound
 *
 ***/
extern API_FUNCTION
  NetSessionDel ( const char FAR * pszServer,
                  const char FAR * pszClientName,
                  short            sReserved );

/***	NetSessionEnum
 *
 *	API_FUNCTION NetSessionEnum( servername,
 *				       level,
 *				       buf,
 *				       buflen,
 *				       entriesread,
 *				       totalentries )
 *	ENTRY
 *				
 *	servername;     asciz remote srv name, NULL if local
 * 	level;          level of detail requested; (50 for Win95 peer servers)
 *	buf;            for returned entries
 *	buflen;         size of buffer on call;
 *	entriesread;    # of entries supplied on return
 *	totalentries;   total # of entries available
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *  ERROR_BAD_NETPATH
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *
 *	Buffer contains an array of session_info structures.
 *
 ***/
extern API_FUNCTION
  NetSessionEnum ( const char FAR *     pszServer,
                   short                sLevel,
                   char FAR *           pbBuffer,
                   unsigned short       cbBuffer,
                   unsigned short FAR * pcEntriesRead,
                   unsigned short FAR * pcTotalAvail );


extern API_FUNCTION
  NetSessionGetInfo ( const char FAR *     pszServer,
                      const char FAR *     pszClientName,
                      short                sLevel,
                      char FAR *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *		Data structure templates - SESSION		*
 *								*
 ****************************************************************/


struct session_info_0 {
    char FAR *		sesi0_cname;
};  /* session_info_0 */

struct session_info_1 {
    char FAR *		sesi1_cname;
    char FAR *		sesi1_username;
    unsigned short	sesi1_num_conns;
    unsigned short	sesi1_num_opens;
    unsigned short	sesi1_num_users;
    unsigned long	sesi1_time;
    unsigned long	sesi1_idle_time;
    unsigned long	sesi1_user_flags;
};  /* session_info_1 */

struct session_info_2 {
    char FAR *		 sesi2_cname;
    char FAR *		 sesi2_username;
    unsigned short	 sesi2_num_conns;
    unsigned short	 sesi2_num_opens;
    unsigned short	 sesi2_num_users;
    unsigned long	 sesi2_time;
    unsigned long	 sesi2_idle_time;
    unsigned long	 sesi2_user_flags;
    char FAR *		 sesi2_cltype_name;
};  /* session_info_2 */

struct session_info_10 {
        char FAR *     sesi10_cname;
        char FAR *     sesi10_username;
        unsigned long  sesi10_time;
        unsigned long  sesi10_idle_time;
};  /* session_info_10 */


struct session_info_50 {
	char FAR * sesi50_cname;            //remote computer name (connection id in Netware)
	char FAR * sesi50_username;
	unsigned long sesi50_key;           // used to delete session (not used in Netware)
	unsigned short sesi50_num_conns;
	unsigned short sesi50_num_opens;    //not available in Netware
	unsigned long sesi50_time;
	unsigned long sesi50_idle_time;		//not available in Netware
	unsigned char sesi50_protocol;
	unsigned char pad1;
};	/* session_info_50 */


/****************************************************************
 *								*
 *	  	Special values and constants - SESSION		*
 *								*
 ****************************************************************/

/*
 *	Bits defined in sesi1_user_flags.
 */

#define SESS_GUEST		1	/* session is logged on as a guest */
#define SESS_NOENCRYPTION	2	/* session is not using encryption */


#define SESI1_NUM_ELEMENTS	8
#define SESI2_NUM_ELEMENTS	9



/****************************************************************
 *								*
 *	  	Connection Class			        *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - CONNECTION                *
 *                                                              *
 *  Peer Server Support
 * 		NetConnectionEnum -
 *               sLevel 50 on VSERVER and NWSERVER              *
 *               On NWSERVER, this API doesnt provide more      *
 *               information than NetSessionEnum
 ****************************************************************/

/***	NetConnectionEnum (Admin only)
 *
 *	API_FUNCTION NetConnectionEnum( servername,
 *					  qualifier,
 *					  level,
 *					  buf,
 *					  buflen,
 *					  totalavail )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	qualifier;      netname or client computer name.
 *                  computer name should be prefaced by '\\'.
 *	level;	    	level of info requested
 *	buf;            for returned entry
 *	buflen;         size of buffer
 *	totalavail;     total size needed for buffer
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	NERR_RemoteOnly		(DOS)
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *	NERR_ClientNameNotFound
 *	NERR_NetNameNotFound
 *
 *	Buffer contents on response (format for a single entry):
 *   	    Level 50 contains a "struct connection_info_50".
 ***/
extern API_FUNCTION
  NetConnectionEnum ( const char FAR *     pszServer,
                      const char FAR *     pszQualifier,   /* upper case */
                      short                sLevel,
                      char FAR *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short FAR * pcEntriesRead,
                      unsigned short FAR * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - CONNECTION		*
 *								*
 ****************************************************************/

struct connection_info_0 {
    unsigned short	coni0_id;
};  /* connection_info_0 */

struct connection_info_1 {
    unsigned short	coni1_id;
    unsigned short	coni1_type;
    unsigned short	coni1_num_opens;
    unsigned short	coni1_num_users;
    unsigned long	coni1_time;
    char FAR *		coni1_username;
    char FAR *		coni1_netname;
};  /* connection_info_1 */

struct connection_info_50 {
	unsigned short coni50_type;         // share type
	unsigned short coni50_num_opens;	//not used in Netware
	unsigned long coni50_time;
	char FAR * coni50_netname;          // share name
	char FAR * coni50_username;         // user connected to share
}; /* connection_info_50 */


/****************************************************************
 *								*
 *	  	File Class			                *
 *								*
 ****************************************************************/


/****************************************************************
 *                                                              *
 *              Function prototypes - FILE                      *
 *                                                              *
 *  Peer Server Support
 * 		NetFileEnum - sLevel 50 on VSERVER and NWSERVER        *
 *      NetFileClose2 - VSERVER only
 ****************************************************************/

/***	NetFileClose2
 *
 *	int FAR PASCAL	NetFileClose2( servername, fileid )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	fileid;     	file id supplied by NetFileEnum
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	NERR_RemoteErr
 * 	ERROR_ACCESS_DENIED
 *	NERR_FileIdNotFound
 *
 ***/
extern API_FUNCTION
  NetFileClose2 ( const char FAR * pszServer,
                  unsigned long    ulFileId );

/***	NetFileEnum (Admin Only)
 *
 *	int FAR PASCAL NetFileEnum( servername,
 *				    level,
 *				    buf,
 *				    buflen,
 *				    entriesread,
 *				    totalentries )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	basepath;	path qualifier for file matching
 *              (not used for Win95 NWSERVER)
 *	level;          level of detail requested; (50 for Win95 peer servers)
 *	buf;            for returned entries
 *	buflen;         size of buffer on call;
 *	entriesread;    # of entries supplied on return
 *	totalentries;   total # of entries available
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_RemoteOnly
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *
 *	
 *	Buffer contents on response (format for a single entry):
 *   	    Level 0 contains a "struct file_info_0".
 *   	    Level 50 contains a "struct file_info_50".
 *
 ***/

extern API_FUNCTION
  NetFileEnum ( const char FAR *     pszServer,
                const char FAR *     pszBasePath,
                short                sLevel,
                char FAR *           pbBuffer,
                unsigned short       cbBuffer,
                unsigned short FAR * pcEntriesRead,
                unsigned short FAR * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - FILE			*
 *								*
 ****************************************************************/

struct file_info_0 {
    unsigned short	fi0_id;
};  /* file_info_0 */

struct file_info_1 {
    unsigned short	fi1_id;
    unsigned short	fi1_permissions;
    unsigned short	fi1_num_locks;
    char FAR *		fi1_pathname;
    char FAR *		fi1_username;
};  /* file_info_1 */

struct file_info_2 {
    unsigned long	fi2_id;
};  /* file_info_2 */

struct file_info_3 {
    unsigned long	fi3_id;
    unsigned short	fi3_permissions;
    unsigned short	fi3_num_locks;
    char FAR *		fi3_pathname;
    char FAR *		fi3_username;
};  /* file_info_3 */

struct file_info_50 {
	unsigned long fi50_id;              // not used on NWSERVER
	unsigned short fi50_permissions;    // not available on NWSERVER
	unsigned short fi50_num_locks;      // not available on NWSERVER
	char FAR * fi50_pathname;
	char FAR * fi50_username;
	char FAR * fi50_sharename;
}; /* file_info_50 */

struct res_file_enum_2 {
    unsigned short	res_pad;	 /* not used now */
    unsigned short      res_fs;          /* server type */
    unsigned long	res_pro;	  /* progressive */
};  /* res_file_enum_2 */

/****************************************************************
 *								*
 *		Special values and constants - FILE		*
 *								*
 ****************************************************************/

					/* bit values for permissions */
#define	PERM_FILE_READ		0x1	/* user has read access */
#define	PERM_FILE_WRITE		0x2	/* user has write access */
#define	PERM_FILE_CREATE	0x4	/* user has create access */


typedef struct res_file_enum_2 FRK;

/*NOINC*/
#define FRK_INIT( f )	\
	{		\
		(f).res_pad = 0L;	\
		(f).res_fs = 0;	\
		(f).res_pro = 0;	\
	}

/*INC*/


/****************************************************************
 *								*
 *	  	Server Class			                *
 *								*
 ****************************************************************/


/****************************************************************
 *                                                              *
 *              Function prototypes - SERVER                    *
 *                                                              *
 * Peer Server Support
 * 	NetServerGetInfo - sLevel 1,50 on NWSERVER, VSERVER
 ****************************************************************/

/* 6.2  NetServerGetInfo
 *
 * Purpose: Read the current configuration parameters of the server.
 *
 * int FAR PASCAL
 * NetServerGetInfo( servername, level, buf, buflen, totalavail )
 * char FAR *          servername;   asciz remote server name or NULL if local
 * short               level;          level of information to be returned
 * char FAR *          buf;            for returned data
 * unsigned short      buflen;         size of buffer
 * unsigned short FAR *totalavail;     total size needed for buffer
 *
 * Buffer contents on response (format for a single entry):
 *     Level 1 contains a "struct server_info_1".
 *     Level 50 contains a "struct server_info_50".
 *
 * If the buflen is not large enough for all of the information, the call
 * will return as much as will fit in the buffer.
 *
 * Returns 0 if successful. Error return information:
 *
 *     - ERROR_INVALID_LEVEL       - Level parameter specified is invalid
 *     - ERROR_INVALID_PARAMETER   - An invalid input parameter was detected.
 *     - NERR_NetNotStarted        - Network not installed on local machine
 *     - NERR_ServerNotStarted     - Server is not started
 *     - NERR_BufTooSmall          - The buffer supplied was to small to
 *                                   return the fixed length structure
 *				     requested.
 *     - NERR_MoreData             - The buffer supplied was too small to
 *				     return all the information available
 *				     for this server.
 *
 */


extern API_FUNCTION
  NetServerGetInfo ( const char FAR *     pszServer,
                     short                sLevel,
                     char FAR *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - SERVER		*
 *								*
 ****************************************************************/

struct server_info_0 {
    char	    sv0_name[CNLEN + 1]; 	/* Server name		    */
};	 /* server_info_0 */


struct server_info_1 {
    char	    sv1_name[CNLEN + 1];
    unsigned char   sv1_version_major;		/* Major version # of net   */
    unsigned char   sv1_version_minor;		/* Minor version # of net   */
    unsigned long   sv1_type;	     		/* Server type 		    */
    char FAR *	    sv1_comment; 		/* Exported server comment  */
};	 /* server_info_1 */


/* NOTE struct prefix must equal server_info_1 like below! */

struct server_info_50 {
    char	    sv50_name[CNLEN + 1];
    unsigned char   sv50_version_major;		/* Major version # of net   */
    unsigned char   sv50_version_minor;		/* Minor version # of net   */
    unsigned long   sv50_type;	     		/* Server type 		    */
    char FAR *	    sv50_comment; 		/* Exported server comment  */
    unsigned short  sv50_security;    		/* SV_SECURITY_* (see below) */
    unsigned short  sv50_auditing;    /* 0 = no auditing; nonzero = auditing */
    char FAR *      sv50_container;		/* Security server/domain    */
    char FAR *	    sv50_ab_server;		/* Address book server       */
    char FAR *	    sv50_ab_dll;		/* Address book provider DLL */
};	/* server_info_50 */


struct server_info_2 {
    char            sv2_name[CNLEN + 1];
    unsigned char   sv2_version_major;
    unsigned char   sv2_version_minor;
    unsigned long   sv2_type;	
    char FAR *	    sv2_comment;		
    unsigned long   sv2_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv2_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv2_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv2_users;       /* max number of users allowed          */
    unsigned short  sv2_disc;	    /* auto-disconnect timeout(in minutes)  */
    char FAR *	    sv2_alerts;	    /* alert names (semicolon separated)    */
    unsigned short  sv2_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv2_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv2_numadmin;    /* max number of administrators allowed */
    unsigned short  sv2_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv2_hidden;      /* 0 = visible; nonzero = hidden        */
    unsigned short  sv2_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv2_anndelta;    /* announce randomize interval (sec)    */
                                    /* name of guest account                */
    char            sv2_guestacct[LM20_UNLEN + 1];
    unsigned char   sv2_pad1;	    /* Word alignment pad byte		    */
    char FAR *      sv2_userpath;    /* ASCIIZ path to user directories      */
    unsigned short  sv2_chdevs;      /* max # shared character devices       */
    unsigned short  sv2_chdevq;      /* max # character device queues        */
    unsigned short  sv2_chdevjobs;   /* max # character device jobs          */
    unsigned short  sv2_connections; /* max # of connections		    */
    unsigned short  sv2_shares;	    /* max # of shares			    */
    unsigned short  sv2_openfiles;   /* max # of open files		    */
    unsigned short  sv2_sessopens;   /* max # of open files per session	    */
    unsigned short  sv2_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv2_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv2_opensearch;  /* max # of open searches		    */
    unsigned short  sv2_activelocks; /* max # of active file locks           */
    unsigned short  sv2_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv2_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv2_numbigbuf;   /* number of big (64K) buffers          */
    unsigned short  sv2_numfiletasks;/* number of file worker processes      */
    unsigned short  sv2_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv2_erroralert;  /* error log alerting threshold         */
    unsigned short  sv2_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv2_accessalert; /* access violation alerting threshold  */
    unsigned short  sv2_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv2_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv2_maxauditsz;  /* Maximum audit file size (KB)        */
    char FAR *	    sv2_srvheuristics; /* performance related server switches*/
};	/* server_info_2 */


struct server_info_3 {
    char	    sv3_name[CNLEN + 1];
    unsigned char   sv3_version_major;
    unsigned char   sv3_version_minor;
    unsigned long   sv3_type;
    char FAR *	    sv3_comment;
    unsigned long   sv3_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv3_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv3_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv3_users;	     /* max number of users allowed	     */
    unsigned short  sv3_disc;	    /* auto-disconnect timeout(in minutes)  */
    char FAR *	    sv3_alerts;     /* alert names (semicolon separated)    */
    unsigned short  sv3_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv3_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv3_numadmin;    /* max number of administrators allowed */
    unsigned short  sv3_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv3_hidden;      /* 0 = visible; nonzero = hidden	     */
    unsigned short  sv3_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv3_anndelta;    /* announce randomize interval (sec)    */
				    /* name of guest account		    */
    char	    sv3_guestacct[LM20_UNLEN + 1];
    unsigned char   sv3_pad1;	    /* Word alignment pad byte		    */
    char FAR *	    sv3_userpath;    /* ASCIIZ path to user directories	     */
    unsigned short  sv3_chdevs;      /* max # shared character devices	     */
    unsigned short  sv3_chdevq;      /* max # character device queues	     */
    unsigned short  sv3_chdevjobs;   /* max # character device jobs	     */
    unsigned short  sv3_connections; /* max # of connections		    */
    unsigned short  sv3_shares;     /* max # of shares			    */
    unsigned short  sv3_openfiles;   /* max # of open files		    */
    unsigned short  sv3_sessopens;   /* max # of open files per session     */
    unsigned short  sv3_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv3_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv3_opensearch;  /* max # of open searches		    */
    unsigned short  sv3_activelocks; /* max # of active file locks	     */
    unsigned short  sv3_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv3_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv3_numbigbuf;   /* number of big (64K) buffers	     */
    unsigned short  sv3_numfiletasks;/* number of file worker processes      */
    unsigned short  sv3_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv3_erroralert;  /* error log alerting threshold	     */
    unsigned short  sv3_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv3_accessalert; /* access violation alerting threshold  */
    unsigned short  sv3_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv3_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv3_maxauditsz;  /* Maximum audit file size (KB)	     */
    char FAR *	    sv3_srvheuristics; /* performance related server switches*/
    unsigned long   sv3_auditedevents; /* Audit event control mask	     */
    unsigned short  sv3_autoprofile; /* (0,1,2,3) = (NONE,LOAD,SAVE,or BOTH) */
    char FAR *	    sv3_autopath;    /* file pathname (where to load & save) */
};	/* server_info_3 */



/****************************************************************
 *								*
 *	  	Special values and constants - SERVER		*
 *								*
 ****************************************************************/

/*
 *	Mask to be applied to svX_version_major in order to obtain
 *	the major version number.
 */

#define MAJOR_VERSION_MASK	0x0F

/*
 *	Bit-mapped values for svX_type fields. X = 1, 2 or 3.
 */

#define SV_TYPE_WORKSTATION	0x00000001
#define SV_TYPE_SERVER		0x00000002
#define SV_TYPE_SQLSERVER	0x00000004
#define SV_TYPE_DOMAIN_CTRL	0x00000008
#define SV_TYPE_DOMAIN_BAKCTRL	0x00000010
#define SV_TYPE_TIME_SOURCE	0x00000020
#define SV_TYPE_AFP		0x00000040
#define SV_TYPE_NOVELL		0x00000080      /* This flag is also set by Win95 NWSERVER */
#define SV_TYPE_DOMAIN_MEMBER	0x00000100
#define SV_TYPE_PRINTQ_SERVER	0x00000200
#define SV_TYPE_DIALIN_SERVER	0x00000400
#define SV_TYPE_ALL		0xFFFFFFFF   /* handy for NetServerEnum2 */

/*
 *	Special value for svX_disc that specifies infinite disconnect
 *	time. X = 2 or 3.
 */

#define SV_NODISC		0xFFFF	/* No autodisconnect timeout enforced */

/*
 *	Values of svX_security field. X = 2 or 3.
 */

#define SV_USERSECURITY		1
#define SV_SHARESECURITY	0

/*
 *	Values of svX_security field. X = 50.
 *  For Win95 NWSERVER, the only possible returned value is SV_SECURITY_NETWARE.
 */

#define SV_SECURITY_SHARE	0	/* Share-level */
#define SV_SECURITY_WINNT	1	/* User-level - Windows NT workst'n */
#define SV_SECURITY_WINNTAS	2	/* User-level - Windows NT domain */
#define SV_SECURITY_NETWARE	3	/* User-level - NetWare 3.x bindery */

/*
 *	Values of svX_hidden field. X = 2 or 3.
 */

#define SV_HIDDEN		1
#define SV_VISIBLE		0

#define SVI1_NUM_ELEMENTS	5
#define SVI2_NUM_ELEMENTS	44
#define SVI3_NUM_ELEMENTS	45


/*
 *      Masks describing AUTOPROFILE parameters
 */

#define SW_AUTOPROF_LOAD_MASK	0x1
#define SW_AUTOPROF_SAVE_MASK	0x2



/****************************************************************
 *                                                              *
 *                 Security Class                               *
 *                                                              *
 ****************************************************************/


/****************************************************************
 *                                                              *
 *                  Function prototypes - SECURITY              *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetSecurityGetInfo ( const char FAR *     pszServer,
                       short                sLevel,
                       char FAR *           pbBuffer,
                       unsigned short       cbBuffer,
                       unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - SECURITY		*
 *								*
 ****************************************************************/

struct security_info_1 {
    unsigned long   sec1_security;    	/* SEC_SECURITY_* (see below) */
    char FAR *      sec1_container;	/* Security server/domain     */
    char FAR *	    sec1_ab_server;	/* Address book server        */
    char FAR *	    sec1_ab_dll;	/* Address book provider DLL  */
};	/* security_info_1 */


/****************************************************************
 *								*
 *	  	Special values and constants - SECURITY		*
 *								*
 ****************************************************************/

/*
/*
 *	Values of secX_security field. X = 1.
 */

#define SEC_SECURITY_SHARE	SV_SECURITY_SHARE
#define SEC_SECURITY_WINNT	SV_SECURITY_WINNT
#define SEC_SECURITY_WINNTAS	SV_SECURITY_WINNTAS
#define SEC_SECURITY_NETWARE	SV_SECURITY_NETWARE



/*NOINC*/
#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* SVRAPI_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\inc\oplock\uspud.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1997           **/
/**********************************************************************/

/*
    uspud.h

    This module contains usermode interface to the spud.sys driver.


*/

#ifndef _USPUD_H_
#define _USPUD_H_


#ifdef __cplusplus
extern "C" {
#endif

extern
NTSTATUS
NTAPI
SPUDTransmitFileAndRecv(
    HANDLE                  hSocket,                // Socket handle to use for operation
    PAFD_TRANSMIT_FILE_INFO transmitInfo,           // transmit file req info
    PAFD_RECV_INFO          recvInfo,               // recv req info
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    );


extern
NTSTATUS
NTAPI
SPUDSendAndRecv(
    HANDLE                  hSocket,                // Socket handle to use for operation
    PAFD_SEND_INFO          sendInfo,               // send req info
    PAFD_RECV_INFO          recvInfo,               // recv req info
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    );


extern
NTSTATUS
NTAPI
SPUDCancel(
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    );

extern
NTSTATUS
NTAPI
SPUDCheckStatus(
    PSPUD_REQ_CONTEXT       reqContext              // context info for req
    );

extern
NTSTATUS
NTAPI
SPUDGetCounts(
    PSPUD_COUNTERS      SpudCounts,              // Counters
    DWORD               ClearCounts
    );

extern
NTSTATUS
NTAPI
SPUDInitialize(
    DWORD       Version,        // Version information from Spud.h
    HANDLE      hIoPort,        // Handle of IO completion port for ATQ
    HANDLE      hOplockPort     // Handle of oplock completion port for ATQ
    );

extern
NTSTATUS
NTAPI
SPUDTerminate(
    VOID
    );

extern
NTSTATUS
NTAPI
SPUDCreateFile(
    OUT PHANDLE FileHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateOptions,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Length,
    OUT PULONG LengthNeeded,
    IN PVOID pOplock
    );

extern
NTSTATUS
NTAPI
SPUDOplockAcknowledge(
    IN HANDLE FileHandle,
    IN PVOID pOplock
    );

#ifdef __cplusplus
}
#endif

#endif //!_USPUD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\last\makefile.inc ===
STAXEXPORT=$(_NTTREE)\staxpt\iis

$(O)\asptlb.h: ..\svcs\cmp\aspidl\$(O)\_asptlb.h
    copy $** $@

$(O)\httpext.h: ..\inc\$(O)\iisext.h
    copy $** $@

$(O)\httpfilt.h: ..\inc\$(O)\iisfilt.h
    copy $** $@

copyfiles: $(O)\asptlb.h $(O)\httpext.h $(O)\httpfilt.h 
	xcopy /vyirfda ..\inc\*.* $(STAXEXPORT)\inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\inc\irtldbg.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       irtldbg.h

   Abstract:
       Some simple debugging macros that look and behave a lot like their
       namesakes in MFC.  These macros should work in both C and C++ and do
       something useful with almost any Win32 compiler.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __IRTLDBG_H__
#define __IRTLDBG_H__

#ifndef __IRTLMISC_H__
# include <irtlmisc.h>
#endif

/* Ensure that MessageBoxes can popup */
# define IRTLDBG_RUNNING_AS_SERVICE 1

#include <tchar.h>


// Compile-time (not run-time) assertion. Code will not compile if
// expr is false. Note: there is no non-debug version of this; we
// want this for all builds. The compiler optimizes the code away.
template <bool> struct static_checker;
template <> struct static_checker<true> {};  // specialize only for `true'
#define STATIC_ASSERT(expr) static_checker< (expr) >()


# ifndef _AFX
  /* Assure compatiblity with MFC */

# ifdef _DEBUG
#  define IRTLDEBUG
# endif

# ifdef IRTLDEBUG
#  if defined(IRTLDBG_KERNEL_MODE)
#   define IRTLASSERT(f) ASSERT(f)
#  elif !defined(USE_DEBUG_CRTS)
    /* IIS (and NT) do not ship msvcrtD.dll, per the VC license,
     * so we can't use the assertion code from <crtdbg.h>.  Use similar
     * macros from <pudebug.h> instead. */
#   include <pudebug.h>
#   define IRTLASSERT(f) DBG_ASSERT(f)
#  elif defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
    /* Use the new debugging tools in Visual C++ 4.x */
#   include <crtdbg.h>
    /* _ASSERTE will give a more meaningful message, but the string takes
     * space.  Use _ASSERT if this is an issue. */
#   define IRTLASSERT(f) _ASSERTE(f)
#  else
#   include <assert.h>
#   define IRTLASSERT(f) assert(f)
#  endif

#  define IRTLVERIFY(f)               IRTLASSERT(f)
#  ifndef DEBUG_ONLY
#   define DEBUG_ONLY(f)              (f)
#  endif
#  define IRTLTRACE                   IrtlTrace
#  define IRTLTRACE0(psz)             IrtlTrace(_T("%s"), _T(psz))
#  define IRTLTRACE1(psz, p1)         IrtlTrace(_T(psz), p1)
#  define IRTLTRACE2(psz, p1, p2)     IrtlTrace(_T(psz), p1, p2)
#  define IRTLTRACE3(psz, p1, p2, p3) IrtlTrace(_T(psz), p1, p2, p3)
#  define IRTLTRACE4(psz, p1, p2, p3, p4) \
                                      IrtlTrace(_T(psz), p1, p2, p3, p4)
#  define IRTLTRACE5(psz, p1, p2, p3, p4, p5) \
                                      IrtlTrace(_T(psz), p1, p2, p3, p4, p5)
#  define ASSERT_VALID(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->AssertValid();} while (0)
#  define DUMP(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->Dump();} while (0)

# else /* !IRTLDEBUG */

  /* These macros should all compile away to nothing */
#  define IRTLASSERT(f)           ((void)0)
#  define IRTLVERIFY(f)           ((void)(f))
#  ifndef DEBUG_ONLY
#   define DEBUG_ONLY(f)          ((void)0)
#  endif
#  define IRTLTRACE               1 ? (void)0 : IrtlTrace
#  define IRTLTRACE0(psz)         1 ? (void)0 : IrtlTrace
#  define IRTLTRACE1(psz, p1)     1 ? (void)0 : IrtlTrace
#  define IRTLTRACE2(psz, p1, p2) 1 ? (void)0 : IrtlTrace
#  define IRTLTRACE3(psz, p1, p2, p3)         1 ? (void)0 : IrtlTrace
#  define IRTLTRACE4(psz, p1, p2, p3, p4)     1 ? (void)0 : IrtlTrace
#  define IRTLTRACE5(psz, p1, p2, p3, p4, p5) 1 ? (void)0 : IrtlTrace
#  define ASSERT_VALID(pObj)      ((void)0)
#  define DUMP(pObj)              ((void)0)

# endif /* !IRTLDEBUG */


# define ASSERT_POINTER(p, type) \
    IRTLASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

# define ASSERT_NULL_OR_POINTER(p, type) \
    IRTLASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_STRING(s) \
    IRTLASSERT(((s) != NULL)  &&  IsValidString((s), -1))

#define ASSERT_NULL_OR_STRING(s) \
    IRTLASSERT(((s) == NULL)  ||  IsValidString((s), -1))


/* Declarations for non-Windows apps */

# ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
# endif /* _WINDEF_ */

# ifndef TRUE
#  define FALSE  0
#  define TRUE   1
# endif


# ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

}

# else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength);

# endif /* !__cplusplus */

#else
# define IRTLASSERT(f) _ASSERTE(f)

#endif /* !_AFX */


/* Writes trace messages to debug stream */
extern
#ifdef __cplusplus
"C"
#endif /* !__cplusplus */
IRTL_DLLEXP
void __cdecl
IrtlTrace(
    LPCTSTR pszFormat,
    ...);


#ifdef IRTLDEBUG
# define IRTL_DEBUG_INIT()            IrtlDebugInit()
# define IRTL_DEBUG_TERM()            IrtlDebugTerm()
#else /* !IRTLDEBUG */
# define IRTL_DEBUG_INIT()            ((void)0)
# define IRTL_DEBUG_TERM()            ((void)0)
#endif /* !IRTLDEBUG */


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* should be called from main(), WinMain(), or DllMain() */
IRTL_DLLEXP void
IrtlDebugInit();

IRTL_DLLEXP void
IrtlDebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __IRTLDBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\inc\irtlmisc.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       irtlmisc.h

   Abstract:
       Declares miscellaneous functions and classes in IisRtl.DLL

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


#ifndef __IRTLMISC_H__
#define __IRTLMISC_H__


//--------------------------------------------------------------------
// These declarations are needed to export the template classes from
// IisRtl.DLL and import them into other modules.

#ifndef IRTL_DLLEXP
# ifdef IRTLDBG_KERNEL_MODE
#  define IRTL_DLLEXP
#  define IRTL_EXPIMP
# elif defined(DLL_IMPLEMENTATION)
#  define IRTL_DLLEXP __declspec(dllexport)
#  ifdef IMPLEMENTATION_EXPORT
#   define IRTL_EXPIMP
#  else
#   undef  IRTL_EXPIMP
#  endif 
# else // !IRTLDBG_KERNEL_MODE && !DLL_IMPLEMENTATION
#  define IRTL_DLLEXP __declspec(dllimport)
#  define IRTL_EXPIMP extern
# endif // !IRTLDBG_KERNEL_MODE && !DLL_IMPLEMENTATION 
#endif // !IRTL_DLLEXP


#endif // __IRTLMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\inc\klkrhash.h ===
/*++

   Copyright    (c) 2000    Microsoft Corporation

   Module  Name :
       kLKRhash.h

   Abstract:
       Kernel-mode version of LKRhash: a fast, scalable,
       cache- and MP-friendly hash table

   Author:
       George V. Reilly      (GeorgeRe)     24-Oct-2000

   Environment:
       Win32 - Kernel Mode

   Project:
       Internet Information Server Http.sys

   Revision History:

--*/


#ifndef __KLKRHASH_H__
#define __KLKRHASH_H__

#ifdef __LKRHASH_H__
#error Do not #include <LKRhash.h> before <kLKRhash.h>
#endif

#define LKRHASH_KERNEL_MODE

// BUGBUG: temporarily disable global list of LKRhash tables, to avoid
// dealing with issues of constructing/destructing global objects
#define LKR_NO_GLOBAL_LIST

#ifdef __IRTLDBG_H__
# error Do not #include <IrtlDbg.h> before <kLKRhash.h>
#else // !__IRTLDBG_H__
# define IRTLDBG_KERNEL_MODE
# include <IrtlDbg.h>
#endif // !__IRTLDBG_H__


// Fake up some Windows types for kernel mode
#define WINAPI          NTAPI   /* __stdcall */
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned long   DWORD;
typedef unsigned int    UINT;
typedef unsigned short  WORD;
typedef unsigned char   BYTE;
typedef BYTE*           PBYTE;
typedef BYTE*           LPBYTE;
typedef int             BOOL;
typedef const TCHAR*    LPCTSTR;




#define KLKRHASH_TAG  ((ULONG) 'hRKL')


#ifndef LKRHASH_KERNEL_NO_NEW
// Override operator new and operator delete

extern ULONG __Pool_Tag__;

// Prototype for function that sets the pool tag

inline
void
SetPoolTag(
    ULONG tag)
{
	__Pool_Tag__ = tag;
}

inline
void*
__cdecl
operator new(
    size_t nSize)
{
	return ((nSize > 0)
            ? ExAllocatePoolWithTag(NonPagedPool, nSize, __Pool_Tag__)
            : NULL);
}

inline
void*
__cdecl
operator new(
    size_t    nSize,
    POOL_TYPE iType)
{ 
	return ((nSize > 0)
            ? ExAllocatePoolWithTag(iType, nSize, __Pool_Tag__)
            : NULL);
}

inline
void*
__cdecl
operator new(
    size_t    nSize,
    POOL_TYPE iType,
    ULONG     tag)
{ 
	return ((nSize > 0)
            ? ExAllocatePoolWithTag(iType, nSize, tag)
            : NULL);
}

inline
void
__cdecl
operator delete(
    void* p)
{ 
	if (p != NULL)
        ExFreePool(p);
}

inline
void
__cdecl
operator delete[](
    void* p)
{ 
	if (p != NULL)
        ExFreePool(p);
}

#endif // !LKRHASH_KERNEL_NO_NEW



// Pool Allocators 

template <POOL_TYPE _pt>
class CPoolAllocator
{
private:
    SIZE_T      m_cb;
    const ULONG m_ulTag;

#ifdef IRTLDEBUG
    ULONG       m_cAllocs;
    ULONG       m_cFrees;
#endif // IRTLDEBUG

public:
    CPoolAllocator(
        SIZE_T cb,
        ULONG  ulTag)
        : m_cb(cb),
          m_ulTag(ulTag)
#ifdef IRTLDEBUG
        , m_cAllocs(0)
        , m_cFrees(0)
#endif // IRTLDEBUG
    {}

    ~CPoolAllocator()
    {
        IRTLASSERT(m_cAllocs == m_cFrees);
    }
    
    LPVOID Alloc()
    {
        LPVOID pvMem = ExAllocatePoolWithTag(_pt, m_cb, m_ulTag);
#ifdef IRTLDEBUG
        InterlockedIncrement((PLONG) &m_cAllocs);
#endif // IRTLDEBUG
        return pvMem;
    }

    BOOL   Free(LPVOID pvMem)
    {
        IRTLASSERT(pvMem != NULL);
#ifdef IRTLDEBUG
        InterlockedIncrement((PLONG) &m_cFrees);
#endif // IRTLDEBUG
        // return ExFreePoolWithTag(pvMem, m_ulTag);
        ExFreePool(pvMem);
        return TRUE;
    }

    SIZE_T ByteSize() const
    {
        return m_cb;
    }
}; // class CPoolAllocator<_pt>


class CNonPagedHeap : public CPoolAllocator<NonPagedPool>
{
public:
    static const TCHAR*  ClassName()  {return _TEXT("CNonPagedHeap");}
}; // class CNonPagedHeap


class CPagedHeap : public CPoolAllocator<PagedPool>
{
public:
    static const TCHAR*  ClassName()  {return _TEXT("CPagedHeap");}
}; // class CPagedHeap



// Lookaside Lists

class CNonPagedLookasideList
{
private:
    PNPAGED_LOOKASIDE_LIST m_pnpla;
    const SIZE_T           m_cb;
    const ULONG            m_ulTag;

    enum {
        PNPAGED_LOOKASIDE_LIST_TAG = 'aLPn',
    };

#ifdef IRTLDEBUG
    ULONG                 m_cAllocs;
    ULONG                 m_cFrees;
    
    static PVOID
    AllocateFunction(
        IN POOL_TYPE PoolType,
        IN SIZE_T NumberOfBytes,
        IN ULONG Tag
        )
    {
        IRTLASSERT( PoolType == NonPagedPool );
        // TODO: better bookkeeping
        return ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
    }

    static VOID
    FreeFunction(
        IN PVOID Buffer
        )
    {
        // TODO: better bookkeeping
        ExFreePool(Buffer);
    }
#endif // IRTLDEBUG

public:
    CNonPagedLookasideList(
        SIZE_T cb,
        ULONG  ulTag)
        : m_cb(cb),
          m_ulTag(ulTag)
#ifdef IRTLDEBUG
        , m_cAllocs(0)
        , m_cFrees(0)
#endif // IRTLDEBUG
    {
    
        m_pnpla = static_cast<PNPAGED_LOOKASIDE_LIST>(
                    ExAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof(NPAGED_LOOKASIDE_LIST),
                        PNPAGED_LOOKASIDE_LIST_TAG));

        if (m_pnpla != NULL)
        {
            ExInitializeNPagedLookasideList(
                m_pnpla,            // Lookaside
#ifdef IRTLDEBUG
                AllocateFunction,   // Allocate
                FreeFunction,       // Free
#else  // !IRTLDEBUG
                NULL,               // default Allocate
                NULL,               // default Free
#endif // !IRTLDEBUG
                0,                  // Flags
                m_cb,               // Size
                m_ulTag,            // Tag
                0                   // Depth
                );
        }
    }
    
    ~CNonPagedLookasideList()
    {
        IRTLASSERT(m_cAllocs == m_cFrees);

        if (m_pnpla != NULL)
        {
            ExDeleteNPagedLookasideList(m_pnpla);
            ExFreePool(m_pnpla);
        }
    }
    
    LPVOID Alloc()
    {
        LPVOID pvMem = ExAllocateFromNPagedLookasideList(m_pnpla);
#ifdef IRTLDEBUG
        InterlockedIncrement((PLONG) &m_cAllocs);
#endif // IRTLDEBUG
        return pvMem;
    }

    BOOL   Free(LPVOID pvMem)
    {
        IRTLASSERT(pvMem != NULL);
#ifdef IRTLDEBUG
        InterlockedIncrement((PLONG) &m_cFrees);
#endif // IRTLDEBUG
        ExFreeToNPagedLookasideList(m_pnpla, pvMem);
        return TRUE;
    }

    SIZE_T ByteSize() const
    {
        return m_cb;
    }

    static const TCHAR*  ClassName()  {return _TEXT("CNonPagedLookasideList");}
}; // class CNonPagedLookasideList



class CPagedLookasideList
{
private:
    PPAGED_LOOKASIDE_LIST m_ppla;
    const SIZE_T          m_cb;
    const ULONG           m_ulTag;

    enum {
        PPAGED_LOOKASIDE_LIST_TAG = 'aLPp',
    };

#ifdef IRTLDEBUG
    ULONG                 m_cAllocs;
    ULONG                 m_cFrees;
    
    static PVOID
    AllocateFunction(
        IN POOL_TYPE PoolType,
        IN SIZE_T NumberOfBytes,
        IN ULONG Tag
        )
    {
        IRTLASSERT( PoolType == PagedPool );
        // TODO: better bookkeeping
        return ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
    }

    static VOID
    FreeFunction(
        IN PVOID Buffer
        )
    {
        // TODO: better bookkeeping
        ExFreePool(Buffer);
    }
#endif // IRTLDEBUG

public:
    CPagedLookasideList(
        SIZE_T cb,
        ULONG  ulTag)
        : m_cb(cb),
          m_ulTag(ulTag)
#ifdef IRTLDEBUG
        , m_cAllocs(0)
        , m_cFrees(0)
#endif // IRTLDEBUG
    {
        m_ppla = static_cast<PPAGED_LOOKASIDE_LIST>(
                    ExAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof(PAGED_LOOKASIDE_LIST),
                        PPAGED_LOOKASIDE_LIST_TAG));

        if (m_ppla != NULL)
        {
            ExInitializePagedLookasideList(
                m_ppla,             // Lookaside
#ifdef IRTLDEBUG
                AllocateFunction,   // Allocate
                FreeFunction,       // Free
#else  // !IRTLDEBUG
                NULL,               // Allocate
                NULL,               // Free
#endif // !IRTLDEBUG
                0,                  // Flags
                m_cb,               // Size
                m_ulTag,            // Tag
                0                   // Depth
                );
        }
    }
    
    ~CPagedLookasideList()
    {
        IRTLASSERT(m_cAllocs == m_cFrees);

        if (m_ppla != NULL)
        {
            ExDeletePagedLookasideList(m_ppla);
            ExFreePool(m_ppla);
        }
    }
    
    LPVOID Alloc()
    {
        LPVOID pvMem = ExAllocateFromPagedLookasideList(m_ppla);
#ifdef IRTLDEBUG
        InterlockedIncrement((PLONG) &m_cAllocs);
#endif // IRTLDEBUG
        return pvMem;
    }

    BOOL   Free(LPVOID pvMem)
    {
        IRTLASSERT(pvMem != NULL);
#ifdef IRTLDEBUG
        InterlockedIncrement((PLONG) &m_cFrees);
#endif // IRTLDEBUG
        ExFreeToPagedLookasideList(m_ppla, pvMem);
        return TRUE;
    }

    SIZE_T ByteSize() const
    {
        return m_cb;
    }

    static const TCHAR*   ClassName()  {return _TEXT("CPagedLookasideList");}
}; // class CPagedLookasideList



#if 0

# define LKRHASH_NONPAGEDHEAP
  typedef CNonPagedHeap CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N, Tag) \
    C::sm_palloc = new CNonPagedHeap(sizeof(C), Tag)

#elif 0

# define LKRHASH_PAGEDHEAP
  typedef CPagedHeap CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N, Tag) \
    C::sm_palloc = new CPagedHeap(sizeof(C), Tag)

#elif 1 // <----

# define LKRHASH_NONPAGEDLOOKASIDE
  typedef CNonPagedLookasideList CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N, Tag) \
    C::sm_palloc = new CNonPagedLookasideList(sizeof(C), Tag)

#elif 0

# define LKRHASH_PAGEDLOOKASIDE
  typedef CPagedLookasideList CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N, Tag) \
    C::sm_palloc = new CPagedLookasideList(sizeof(C), Tag)

#endif



// TODO: lookaside lists

#include <kLocks.h>

// #define LKR_TABLE_LOCK  CEResource
// #define LKR_BUCKET_LOCK CSpinLock
#define LKR_TABLE_LOCK  CReaderWriterLock3 
#define LKR_BUCKET_LOCK CSmallSpinLock
#define LSTENTRY_LOCK   LKR_BUCKET_LOCK
    
#include <LKRhash.h>

#endif // __KLKRHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\inc\hashfn.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       HashFn.h

   Abstract:
       Declares and defines a collection of overloaded hash functions.
       It is strongly suggested that you use these functions with LKRhash.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __HASHFN_H__
#define __HASHFN_H__

#include <math.h>
#include <limits.h>

#ifndef __HASHFN_NO_NAMESPACE__
namespace HashFn {
#endif // !__HASHFN_NO_NAMESPACE__

// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKRhash applies this internally
// to all hash signatures for exactly this reason.

inline DWORD
HashScramble(DWORD dwHash)
{
    // Here are 10 primes slightly greater than 10^9
    //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.

    // default value for "scrambling constant"
    const DWORD RANDOM_CONSTANT = 314159269UL;
    // large prime number, also used for scrambling
    const DWORD RANDOM_PRIME =   1000000007UL;

    return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
}


enum {
    // No number in 0..2^31-1 maps to this number after it has been
    // scrambled by HashFn::HashRandomizeBits
    HASH_INVALID_SIGNATURE = 31678523,

    // Given M = A % B, A and B unsigned 32-bit integers greater than zero,
    // there are no values of A or B which yield M = 2^32-1.  Why?  Because
    // M must be less than B. (For numbers scrambled by HashScramble)
    // HASH_INVALID_SIGNATURE = ULONG_MAX
};

// Faster scrambling function suggested by Eric Jacobsen

inline DWORD
HashRandomizeBits(DWORD dw)
{
	return (((dw * 1103515245 + 12345) >> 16)
            | ((dw * 69069 + 1) & 0xffff0000));
}



#undef HASH_SHIFT_MULTIPLY

#ifdef HASH_SHIFT_MULTIPLY

inline DWORD
HASH_MULTIPLY(
    DWORD dw)
{
    // 127 = 2^7 - 1 is prime
    return (dw << 7) - dw;
}

#else // !HASH_SHIFT_MULTIPLY

inline DWORD
HASH_MULTIPLY(
    DWORD dw)
{
    // Small prime number used as a multiplier in the supplied hash functions
    const DWORD HASH_MULTIPLIER = 101;
    return dw * HASH_MULTIPLIER;
}

#endif // !HASH_SHIFT_MULTIPLY


// Fast, simple hash function that tends to give a good distribution.
// Apply HashScramble to the result if you're using this for something
// other than LKRhash.

inline DWORD
HashString(
    const char*  psz,
    DWORD dwHash = 0)
{
    // force compiler to use unsigned arithmetic
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz != '\0';  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *upsz;

    return dwHash;
}


// --------------------------------------------------------
// Compute a hash value from an input string of any type, i.e.
// the input is just treated as a sequence of bytes.
// Based on a hash function originally proposed by J. Zobel.
// Author: Paul Larson, 1999, palarson@microsoft.com
// -------------------------------------------------------- 
inline DWORD
HashString2( 
    const char* pszInputKey,        // ptr to input - any type is OK
    DWORD       dwHash = 314159269) // Initial seed for hash function
{
	// Initialize dwHash to a reasonably large constant so very
	// short keys won't get mapped to small values. Virtually any
	// large odd constant will do. 
    const unsigned char* upsz = (const unsigned char*) pszInputKey;

    for (  ;  *upsz != '\0';  ++upsz)
        dwHash ^= (dwHash << 11) + (dwHash << 5) + (dwHash >> 2) + *upsz;

    return (dwHash & 0x7FFFFFFF);
}



// Unicode version of above

inline DWORD
HashString(
    const wchar_t* pwsz,
    DWORD   dwHash = 0)
{
    for (  ;  *pwsz != L'\0';  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pwsz;

    return dwHash;
}


// Quick-'n'-dirty case-insensitive string hash function.
// Make sure that you follow up with _stricmp or _mbsicmp.  You should
// also cache the length of strings and check those first.  Caching
// an uppercase version of a string can help too.
// Again, apply HashScramble to the result if using with something other
// than LKRhash.
// Note: this is not really adequate for MBCS strings.

inline DWORD
HashStringNoCase(
    const char*  psz,
    DWORD dwHash = 0)
{
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz != '\0';  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)
                     +  (*upsz & 0xDF);  // strip off lowercase bit

    return dwHash;
}


// Unicode version of above

inline DWORD
HashStringNoCase(
    const wchar_t* pwsz,
    DWORD   dwHash = 0)
{
    for (  ;  *pwsz != L'\0';  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  (*pwsz & 0xFFDF);

    return dwHash;
}


// HashBlob returns the hash of a blob of arbitrary binary data.
// 
// Warning: HashBlob is generally not the right way to hash a class object.
// Consider:
//     class CFoo {
//     public:
//         char   m_ch;
//         double m_d;
//         char*  m_psz;
//     };
// 
//     inline DWORD Hash(const CFoo& rFoo)
//     { return HashBlob(&rFoo, sizeof(CFoo)); }
//
// This is the wrong way to hash a CFoo for two reasons: (a) there will be
// a 7-byte gap between m_ch and m_d imposed by the alignment restrictions
// of doubles, which will be filled with random data (usually non-zero for
// stack variables), and (b) it hashes the address (rather than the
// contents) of the string m_psz.  Similarly,
// 
//     bool operator==(const CFoo& rFoo1, const CFoo& rFoo2)
//     { return memcmp(&rFoo1, &rFoo2, sizeof(CFoo)) == 0; }
//
// does the wrong thing.  Much better to do this:
//
//     DWORD Hash(const CFoo& rFoo)
//     {
//         return HashString(rFoo.m_psz,
//                           HASH_MULTIPLIER * Hash(rFoo.m_ch)
//                               +  Hash(rFoo.m_d));
//     }
//
// Again, apply HashScramble if using with something other than LKRhash.

inline DWORD
HashBlob(
    const void*  pv,
    size_t       cb,
    DWORD dwHash = 0)
{
    const BYTE* pb = static_cast<const BYTE*>(pv);

    while (cb-- > 0)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pb++;

    return dwHash;
}



// --------------------------------------------------------
// Compute a hash value from an input string of any type, i.e.
// the input is just treated as a sequence of bytes.
// Based on a hash function originally proposed by J. Zobel.
// Author: Paul Larson, 1999, palarson@microsoft.com
// -------------------------------------------------------- 
inline DWORD
HashBlob2( 
    const void* pvInputKey,         // ptr to input - any type is OK
    size_t      cbKeyLen,           // length of input key in bytes
    DWORD       dwHash = 314159269) // Initial seed for hash function
{
	// Initialize dwHash to a reasonably large constant so very
	// short keys won't get mapped to small values. Virtually any
	// large odd constant will do. 

    const BYTE* pb         = static_cast<const BYTE*>(pvInputKey);
    const BYTE* pbSentinel = pb + cbKeyLen;

    for ( ;  pb < pbSentinel;  ++pb)
        dwHash ^= (dwHash << 11) + (dwHash << 5) + (dwHash >> 2) + *pb;

    return (dwHash & 0x7FFFFFFF);
}



//
// Overloaded hash functions for all the major builtin types.
// Again, apply HashScramble to result if using with something other than
// LKRhash.
//

inline DWORD Hash(const char* psz)
{ return HashString(psz); }

inline DWORD Hash(const unsigned char* pusz)
{ return HashString(reinterpret_cast<const char*>(pusz)); }

inline DWORD Hash(const signed char* pssz)
{ return HashString(reinterpret_cast<const char*>(pssz)); }

inline DWORD Hash(const wchar_t* pwsz)
{ return HashString(pwsz); }

inline DWORD
Hash(
    const GUID* pguid,
    DWORD dwHash = 0)
{
    dwHash += * reinterpret_cast<const DWORD*>(pguid);
    return dwHash;
}

// Identity hash functions: scalar values map to themselves
inline DWORD Hash(char c)
{ return c; }

inline DWORD Hash(unsigned char uc)
{ return uc; }

inline DWORD Hash(signed char sc)
{ return sc; }

inline DWORD Hash(short sh)
{ return sh; }

inline DWORD Hash(unsigned short ush)
{ return ush; }

inline DWORD Hash(int i)
{ return i; }

inline DWORD Hash(unsigned int u)
{ return u; }

inline DWORD Hash(long l)
{ return l; }

inline DWORD Hash(unsigned long ul)
{ return ul; }

inline DWORD Hash(double dbl)
{
    if (dbl == 0.0)
        return 0;
    int nExponent;
    double dblMantissa = frexp(dbl, &nExponent);
    // 0.5 <= |mantissa| < 1.0
    return (DWORD) ((2.0 * fabs(dblMantissa)  -  1.0)  *  ULONG_MAX);
}

inline DWORD Hash(float f)
{ return Hash((double) f); }

inline DWORD Hash(unsigned __int64 ull)
{
    union {
        unsigned __int64 _ull;
        DWORD            dw[2];
    } u = {ull};
    return HASH_MULTIPLY(u.dw[0])  +  u.dw[1];
}

inline DWORD Hash(__int64 ll)
{ return Hash((unsigned __int64) ll); }

#ifndef __HASHFN_NO_NAMESPACE__
}
#endif // !__HASHFN_NO_NAMESPACE__

#endif // __HASHFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\inc\klocks.h ===
/*++

   Copyright    (c) 2000    Microsoft Corporation

   Module  Name :
       kLocks.h

   Abstract:
       A collection of kernel-mode locks for multithreaded access to
       data structures that provide the same abstractions as <locks.h>

   Author:
       George V. Reilly      (GeorgeRe)     24-Oct-2000

   Environment:
       Win32 - Kernel Mode

   Project:
       Internet Information Server Http.sys

   Revision History:

--*/


#ifndef __KLOCKS_H__
#define __KLOCKS_H__

#define LOCKS_KERNEL_MODE

#ifdef __LOCKS_H__
#error Do not #include <locks.h> before <klocks.h>
#endif

#include <locks.h>



//--------------------------------------------------------------------
// CKSpinLock is a mutex lock based on KSPIN_LOCK

class IRTL_DLLEXP CKSpinLock :
    public CLockBase<LOCK_KSPINLOCK, LOCK_MUTEX,
                       LOCK_NON_RECURSIVE, LOCK_WAIT_SPIN, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    // BUGBUG: this data must live in non-paged memory
    mutable KSPIN_LOCK KSpinLock;

    LOCK_INSTRUMENTATION_DECL();

public:

#ifndef LOCK_INSTRUMENTATION

    CKSpinLock()
    {
        KeInitializeSpinLock(&KSpinLock);
    }

#else // LOCK_INSTRUMENTATION

    CKSpinLock(
        const TCHAR* ptszName)
    {
        KeInitializeSpinLock(&KSpinLock);
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }

#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CKSpinLock() {}
#endif // IRTLDEBUG

    typedef KIRQL ResultType;

    // Acquire an exclusive lock for writing.
    // Blocks (if needed) until acquired.
    ResultType WriteLock()
    {
        ResultType OldIrql;
        KeAcquireSpinLock(&KSpinLock, &OldIrql);
        return OldIrql;
    }

    // Acquire a (possibly shared) lock for reading.
    // Blocks (if needed) until acquired.
    ResultType ReadLock()
    {
        return WriteLock();
    }

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    bool TryWriteLock()
    {
        return false;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    bool TryReadLock()
    {
        return TryWriteLock();
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    // Assumes caller owned the lock.
    void WriteUnlock(
        ResultType OldIrql)
    {
        KeReleaseSpinLock(&KSpinLock, OldIrql);
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    // Assumes caller owned the lock.
    void ReadUnlock(
        ResultType OldIrql)
    {
        WriteUnlock(OldIrql);
    }

    // Is the lock already locked for writing by this thread?
    bool IsWriteLocked() const
    {
        return false; // no way of determining this w/o auxiliary info
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return IsWriteLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return !IsWriteLocked();
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return IsWriteUnlocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    // Set the spin count for this lock.
    // Returns true if successfully set the per-lock spincount, false otherwise
    bool SetSpinCount(WORD wSpins)
    {
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)
                   || (LOCK_MINIMUM_SPINS <= wSpins
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));

        return false;
    }

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*   ClassName()  {return _TEXT("CKSpinLock");}
}; // CKSpinLock




//--------------------------------------------------------------------
// CFastMutex is a mutex lock based on FAST_MUTEX

class IRTL_DLLEXP CFastMutex :
    public CLockBase<LOCK_FASTMUTEX, LOCK_MUTEX,
                       LOCK_NON_RECURSIVE, LOCK_WAIT_SPIN, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    mutable FAST_MUTEX FastMutex;

    LOCK_INSTRUMENTATION_DECL();

public:

#ifndef LOCK_INSTRUMENTATION

    CFastMutex()
    {
        ExInitializeFastMutex(&FastMutex);
    }

#else // LOCK_INSTRUMENTATION

    CFastMutex(
        const TCHAR* ptszName)
    {
        ExInitializeFastMutex(&FastMutex);
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }

#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CFastMutex() {}
#endif // IRTLDEBUG

    // Acquire an exclusive lock for writing.
    // Blocks (if needed) until acquired.
    void WriteLock()
    {
        ExAcquireFastMutex(&FastMutex);
    }

    // Acquire a (possibly shared) lock for reading.
    // Blocks (if needed) until acquired.
    void ReadLock()
    {
        WriteLock();
    }

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    bool TryWriteLock()
    {
        return ExTryToAcquireFastMutex(&FastMutex) != FALSE;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    bool TryReadLock()
    {
        return TryWriteLock();
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    // Assumes caller owned the lock.
    void WriteUnlock()
    {
        ExReleaseFastMutex(&FastMutex);
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    // Assumes caller owned the lock.
    void ReadUnlock()
    {
        WriteUnlock();
    }

    // Is the lock already locked for writing by this thread?
    bool IsWriteLocked() const
    {
        return false; // no way of determining this w/o auxiliary info
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return IsWriteLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return !IsWriteLocked();
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return IsWriteUnlocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    // Set the spin count for this lock.
    // Returns true if successfully set the per-lock spincount, false otherwise
    bool SetSpinCount(WORD wSpins)
    {
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)
                   || (LOCK_MINIMUM_SPINS <= wSpins
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));

        return false;
    }

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*   ClassName()  {return _TEXT("CFastMutex");}
}; // CFastMutex




//--------------------------------------------------------------------
// CEResource is a multi-reader, single-writer lock based on ERESOURCE

class IRTL_DLLEXP CEResource :
    public CLockBase<LOCK_ERESOURCE, LOCK_MRSW,
                       LOCK_RECURSIVE, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    mutable ERESOURCE Resource;

public:
    CEResource()
    {
        ExInitializeResourceLite(&Resource);
    }

#ifdef LOCK_INSTRUMENTATION
    CEResource(
        const TCHAR* ptszName)
    {
        ExInitializeResourceLite(&Resource);
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }
#endif // LOCK_INSTRUMENTATION

    ~CEResource()
    {
        ExDeleteResourceLite(&Resource);
    }

    inline void
    WriteLock()
    {
        KeEnterCriticalRegion();
        ExAcquireResourceExclusiveLite(&Resource, TRUE);
    }

    inline void
    ReadLock()
    {
        KeEnterCriticalRegion();
        ExAcquireResourceSharedLite(&Resource, TRUE);
    }

    bool ReadOrWriteLock();

    inline bool
    TryWriteLock()
    {
        KeEnterCriticalRegion();
        BOOLEAN fLocked = ExAcquireResourceExclusiveLite(&Resource, FALSE);
        if (! fLocked)
            KeLeaveCriticalRegion();
        return fLocked != FALSE;
    }

    inline bool
    TryReadLock()
    {
        KeEnterCriticalRegion();
        BOOLEAN fLocked = ExAcquireResourceSharedLite(&Resource, FALSE);
        if (! fLocked)
            KeLeaveCriticalRegion();
        return fLocked != FALSE;
    }

    inline void
    WriteUnlock()
    {
        ExReleaseResourceLite(&Resource);
        KeLeaveCriticalRegion();
    }

    inline void
    ReadUnlock()
    {
        WriteUnlock();
    }

    void ReadOrWriteUnlock(bool fIsReadLocked);

    // Does current thread hold a write lock?
    bool
    IsWriteLocked() const
    {
        return ExIsResourceAcquiredExclusiveLite(&Resource) != FALSE;
    }

    bool
    IsReadLocked() const
    {
        return ExIsResourceAcquiredSharedLite(&Resource) > 0;
    }

    bool
    IsWriteUnlocked() const
    { return !IsWriteLocked(); }

    bool
    IsReadUnlocked() const
    { return !IsReadLocked(); }

    void
    ConvertSharedToExclusive()
    {
        ReadUnlock();
        WriteLock();
    }

    // There is no such window when converting from a writelock to a readlock
    void
    ConvertExclusiveToShared()
    {
#if 0
        ExConvertExclusiveToShared(&Resource);
#else
        WriteUnlock();
        ReadLock();
#endif
    }

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    bool
    SetSpinCount(WORD wSpins)
    {return false;}

    WORD
    GetSpinCount() const
    {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*
    ClassName()
    {return _TEXT("CEResource");}

}; // CEResource


#endif  // __KLOCKS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\kernel\main.cpp ===
/*++

   Copyright    (c) 2000    Microsoft Corporation

   Module  Name :
       main.cpp

   Abstract:
       Driver entrypoints for LKRhash: a fast, scalable,
       cache- and MP-friendly hash table

   Author:
       George V. Reilly      (GeorgeRe)     25-Oct-2000

   Environment:
       Win32 - Kernel Mode

   Project:
       Internet Information Server Http.sys

   Revision History:

--*/

#include "precomp.hxx"

ULONG __Pool_Tag__ = 'RKLk';	// default memory tag

extern "C"
VOID
LkrUnload(
    IN PDRIVER_OBJECT DriverObject);

extern "C"
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    // TODO: other driver initialization

    DriverObject->DriverUnload = &LkrUnload;

    if (!LKR_Initialize(LK_INIT_DEFAULT))
        return STATUS_UNSUCCESSFUL;

    return STATUS_SUCCESS;
}


VOID
LkrUnload(
    IN PDRIVER_OBJECT DriverObject)
{
    LKR_Terminate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\kernel\kirtldbg.cpp ===
/*++

   Copyright    (c) 2000    Microsoft Corporation

   Module  Name :
       kLocks.cpp

   Abstract:
       A collection of kernel-mode locks for multithreaded access
       to data structures

   Author:
       George V. Reilly      (GeorgeRe)     25-Oct-2000

   Environment:
       Win32 - Kernel Mode

   Project:
       Internet Information Server Http.sys

   Revision History:

--*/

#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT

#include <kLKRhash.h>
#include "../src/IrtlDbg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\kernel\klocks.cpp ===
/*++

   Copyright    (c) 2000    Microsoft Corporation

   Module  Name :
       kLocks.cpp

   Abstract:
       A collection of kernel-mode locks for multithreaded access
       to data structures

   Author:
       George V. Reilly      (GeorgeRe)     25-Oct-2000

   Environment:
       Win32 - Kernel Mode

   Project:
       Internet Information Server Http.sys

   Revision History:

--*/

#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT

#include <kLKRhash.h>
#include "../src/Locks.cpp"

//------------------------------------------------------------------------
// CKSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CKSpinLock);
LOCK_STATISTICS_DATA(CKSpinLock);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CKSpinLock);


//------------------------------------------------------------------------
// CFastMutex static member variables

LOCK_DEFAULT_SPIN_DATA(CFastMutex);
LOCK_STATISTICS_DATA(CFastMutex);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CFastMutex);


//------------------------------------------------------------------------
// CEResource static member variables

LOCK_DEFAULT_SPIN_DATA(CEResource);
LOCK_STATISTICS_DATA(CEResource);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CEResource);


//------------------------------------------------------------------------
// Function: CEResource::ReadOrWriteLock
// Synopsis: If already locked, recursively acquires another lock of the
// same kind (read or write). Otherwise, just acquires a read lock.
//------------------------------------------------------------------------

bool
CEResource::ReadOrWriteLock()
{
    if (IsWriteLocked())
    {
        WriteLock();
        return false;   // => not read locked
    }
    else
    {
        ReadLock();
            
        return true;   // => is read locked
    }
} 



//------------------------------------------------------------------------
// Function: CEResource::ReadOrWriteUnlock
// Synopsis: release a lock acquired with ReadOrWriteLock
//------------------------------------------------------------------------

void
CEResource::ReadOrWriteUnlock(
    bool fIsReadLocked)
{
    if (fIsReadLocked)
        ReadUnlock();
    else
        WriteUnlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\kernel\klkrhash.cpp ===
/*++

   Copyright    (c) 2000    Microsoft Corporation

   Module  Name :
       kLKRhash.cpp

   Abstract:
       LKRhash.sys: a fast, scalable,
       cache- and MP-friendly hash table

   Author:
       George V. Reilly      (GeorgeRe)     25-Oct-2000

   Environment:
       Win32 - Kernel Mode

   Project:
       Internet Information Server Http.sys

   Revision History:

--*/

#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <kLKRhash.h>
#include "../src/LKRhash.cpp"
#include "../src/LKR-apply.cpp"
#include "../src/LKR-c-api.cpp"
#include "../src/LKR-old-iter.cpp"
#include "../src/LKR-stats.cpp"
#include "../src/LKR-stl-iter.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\inc\lkr-hash.h ===
/*++

   Copyright    (c) 1998-2000    Microsoft Corporation

   Module  Name :
       LKR-hash.h

   Abstract:
       Declares LKRhash: a fast, scalable, cache- and
       multiprocessor-friendly hash table

   Authors:
       Paul (Per-Ake) Larson, PALarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

--*/


#ifndef __LKR_HASH_H__
#define __LKR_HASH_H__


/* Enable STL-style iterators */
#ifndef LKR_NO_STL_ITERATORS
# define LKR_STL_ITERATORS 1
#endif /* !LKR_NO_STL_ITERATORS */

/* Enable call-back, table visitor routines */
#ifndef LKR_NO_APPLY_IF
# define LKR_APPLY_IF
#endif /* !LKR_NO_APPLY_IF */

/* Expose the table's ReadLock and WriteLock routines */
#ifndef LKR_NO_EXPOSED_TABLE_LOCK
# define LKR_EXPOSED_TABLE_LOCK
#endif /* !LKR_NO_EXPOSED_TABLE_LOCK */


#ifndef __IRTLMISC_H__
# include <irtlmisc.h>
#endif /* !__IRTLMISC_H__ */



#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


typedef struct LkrHashTable* PLkrHashTable;


/*--------------------------------------------------------------------
 * Possible return codes from LKR_functions and TypedLkrHashTable
 */
enum LK_RETCODE {
    /* severe errors < 0 */
    LK_UNUSABLE = -99,  /* Table corrupted: all bets are off */
    LK_ALLOC_FAIL,      /* ran out of memory */
    LK_BAD_ITERATOR,    /* invalid iterator; e.g., points to another table */
    LK_BAD_RECORD,      /* invalid record; e.g., NULL for LKR_InsertRecord */
    LK_BAD_PARAMETERS,  /* invalid parameters; e.g., NULL fnptrs to ctor */
    LK_NOT_INITIALIZED, /* LKRHashTableInit was not called */
    LK_BAD_TABLE,       /* Called with invalid PLkrHashTable */

    LK_SUCCESS = 0,     /* everything's okay */
    LK_KEY_EXISTS,      /* key already present for
                            LKR_InsertRecord(no-overwrite) */
    LK_NO_SUCH_KEY,     /* key not found */
    LK_NO_MORE_ELEMENTS,/* iterator exhausted */
};

#define LKR_SUCCEEDED(lkrc)  ((lkrc) >= LK_SUCCESS)


/*--------------------------------------------------------------------
 * Size parameter to LKR_CreateTable
 */

enum LK_TABLESIZE {
    LK_SMALL_TABLESIZE=  1,     /* < 200 elements */
    LK_MEDIUM_TABLESIZE= 2,     /* 200...10,000 elements */
    LK_LARGE_TABLESIZE=  3,     /* 10,000+ elements */
};


/*--------------------------------------------------------------------
 * Creation flag parameter to LKR_CreateTable
 */

enum {
    LK_CREATE_DEFAULT   =      0,   /* 0 is an acceptable default */
    LK_CREATE_MULTIKEYS = 0x0001,   /* Allow multiple identical keys? */
};


/*--------------------------------------------------------------------
 * Initialization flag parameters to LKR_Initialize
 */

enum {
    LK_INIT_DEFAULT    =      0, /* 0 is an acceptable default */
    LK_INIT_DEBUG_SPEW = 0x1000, /* Enable debug output: debug version only */
};



/*--------------------------------------------------------------------
 * Reference Counting and Lifetime Management
 *
 * Increment the reference count of a record before returning it from
 * LKR_FindKey. It's necessary to do it in LKR_FindKey itself while the
 * bucket is still locked, rather than one of the wrappers, to avoid race
 * conditions. Similarly, the reference count is incremented in
 * LKR_InsertRecord and decremented in LKR_DeleteKey. Finally, if an old
 * record is overwritten in LKR_InsertRecord, its reference count is
 * decremented.
 *
 * Summary of calls to AddRefRecord
 *   +1: add a new reference or owner
 *      - LKR_InsertRecord
 *      - LKR_FindKey
 *      - IncrementIterator
 *   -1: delete a reference => release an owner
 *      - LKR_InsertRecord (overwrite old record with same key)
 *      - LKR_DeleteKey, LKR_DeleteRecord
 *      - ApplyIf(LKP_DELETE), DeleteIf
 *      - IncrementIterator (previous record), CloseIterator, Erase(iter)
 *      - LKR_Clear, table destructor
 *   0: no change (not called)
 *      - LKR_FindRecord (by definition, you already have a ref to the record)
 *
 * It's up to you to decrement the reference count when you're finished
 * with it after retrieving it via LKR_FindKey (e.g., you could call
 * pht->AddRefRecord(pRec, LKAR_EXPLICIT_RELEASE)) and to determine the
 * semantics of what this means. The hashtable itself has no notion of
 * reference counts; this is merely to help with the lifetime management
 * of the record objects.
 */

/* These reason codes help in debugging refcount leaks */
enum LK_ADDREF_REASON {

/* negative reasons => decrement refcount => release ownership */
    LKAR_EXPLICIT_RELEASE    = -29, /* user calls ht.AddRefRecord to */
                                        /* explicitly release a record */
    LKAR_DELETE_KEY          = -28, /* DeleteKey() */
    LKAR_DELETE_RECORD       = -27, /* DeleteRecord() */
    LKAR_INSERT_RELEASE      = -26, /* InsertRecord overwrites prev record */
    LKAR_CLEAR               = -25, /* Clear() */
    LKAR_DTOR                = -24, /* hash table destructor */
    LKAR_APPLY_DELETE        = -23, /* Apply[If] LKP_(PERFORM|_DELETE) */
    LKAR_DELETE_IF_DELETE    = -22, /* DeleteIf  LKP_(PERFORM|_DELETE) */
    LKAR_ITER_RELEASE        = -21, /* ++iter releases previous record */
    LKAR_ITER_ASSIGN_RELEASE = -20, /* iter.operator= releases prev rec */
    LKAR_ITER_DTOR           = -19, /* ~iter */
    LKAR_ITER_ERASE          = -18, /* Erase(iter): iter releases record */
    LKAR_ITER_ERASE_TABLE    = -17, /* Erase(iter); table releases record */
    LKAR_ITER_CLOSE          = -16, /* CloseIterator (obsolete) */

/* positive reasons => increment refcount => add an owner */
    LKAR_INSERT_RECORD       = +11, /* InsertRecord() */
    LKAR_FIND_KEY            = +12, /* FindKey() */
    LKAR_ITER_ACQUIRE        = +13, /* ++iter acquires next record */
    LKAR_ITER_COPY_CTOR      = +14, /* iter copy constructor acquires rec */
    LKAR_ITER_ASSIGN_ACQUIRE = +15, /* iter.operator= acquires new rec */
    LKAR_ITER_INSERT         = +16, /* Insert(iter) */
    LKAR_ITER_FIND           = +17, /* Find(iter) */
    LKAR_EXPLICIT_ACQUIRE    = +18, /* user calls ht.AddRefRecord to */
                                        /* explicitly acquire a ref to a rec */
};


/* Convert an LK_ADDREF_REASON to a string representation.
 * Useful for debugging.
 */
IRTL_DLLEXP
const char*
LKR_AddRefReasonAsString(
    LK_ADDREF_REASON lkar);



/*--------------------------------------------------------------------
 * Callback functions needed by table:
 *     ExtractKey, CalcKeyHash, EqualKeys, AddRefRecord
 * Internally, records are handled as `const void*' and
 * keys are handled as `const DWORD_PTR'. The latter allows for
 * keys to be numbers as well as pointers (polymorphism).
 */


/* Use types defined in recent versions of the Platform SDK in <basetsd.h>.
 */
#ifndef _W64
typedef DWORD DWORD_PTR;    /* integral type big enough to hold a pointer */
#endif


/* Given a record, return its key. Assumes that the key is embedded in
 * the record, or at least somehow derivable from the record. For
 * completely unrelated keys & values, a wrapper class should use
 * something like STL's pair<key,value> template to aggregate them
 * into a record.
 */
typedef
const DWORD_PTR
(WINAPI *LKR_PFnExtractKey)  (
    const void* pvRecord);

/* Given a key, return its hash signature. The hashing functions in
 * hashfn.h (or something that builds upon them) are suggested.
 */
typedef
DWORD
(WINAPI *LKR_PFnCalcKeyHash) (
    const DWORD_PTR pnKey);

/* Compare two keys for equality; e.g., _stricmp, memcmp, operator==
 */
typedef
BOOL
(WINAPI *LKR_PFnEqualKeys) (
    const DWORD_PTR pnKey1,
    const DWORD_PTR pnKey2);


/* Adjust the reference count of a record. See the earlier discussion
 * of reference counting and lifetime management.
 */
typedef
void
(WINAPI *LKR_PFnAddRefRecord)(
    const void*      pvRecord,
    LK_ADDREF_REASON lkar);



#ifdef LKR_APPLY_IF
/*--------------------------------------------------------------------
 * Apply, ApplyIf, and DeleteIf provide one way to visit (enumerate) all
 * records in a table.
 */

/*--------------------------------------------------------------------
 * Return codes from PFnRecordPred.
 */

enum LK_PREDICATE {
    LKP_ABORT = 1,           /* Stop walking the table immediately */
    LKP_NO_ACTION = 2,       /* No action, just keep walking */
    LKP_PERFORM = 3,         /* Perform action and continue walking */
    LKP_PERFORM_STOP = 4,    /* Perform action, then stop */
    LKP_DELETE = 5,          /* Delete record and keep walking */
    LKP_DELETE_STOP = 6,     /* Delete record, then stop */
};


/*--------------------------------------------------------------------
 * Return codes from PFnRecordAction.
 */

enum LK_ACTION {
    LKA_ABORT = 1,          /* Stop walking the table immediately */
    LKA_FAILED = 2,         /* Action failed; continue walking the table */
    LKA_SUCCEEDED = 3,      /* Action succeeded; continue walking the table */
};


/*--------------------------------------------------------------------
 * Parameter to Apply and ApplyIf.
 */

enum LK_LOCKTYPE {
    LKL_READLOCK = 1,       /* Lock the table for reading (for constness) */
    LKL_WRITELOCK = 2,      /* Lock the table for writing */
};



/* LKR_ApplyIf() and LKR_DeleteIf(): Does the record match the predicate?
 */
typedef
LK_PREDICATE
(WINAPI *LKR_PFnRecordPred) (
    const void* pvRecord,
    void* pvState);

/* LKR_Apply() et al: Perform action on record.
 */
typedef
LK_ACTION
(WINAPI *LKR_PFnRecordAction)(
    const void* pvRecord,
    void* pvState);

#endif /* LKR_APPLY_IF */



/* Initialize the global variables needed by other LKR routines.
 */
IRTL_DLLEXP
BOOL
LKR_Initialize(
    DWORD dwInitFlags);

/* Clean up the global variables needed by other LKR routines.
 */
IRTL_DLLEXP
void
LKR_Terminate();

/* Create a new LkrHashTable
 * Returns pointer to new table if successful. NULL, otherwise.
 * The table must be destroyed with LKR_DeleteTable.
 */
IRTL_DLLEXP
PLkrHashTable
LKR_CreateTable(
    LPCSTR              pszName,        /* Identify the table for debugging */
    LKR_PFnExtractKey   pfnExtractKey,  /* Extract key from record */
    LKR_PFnCalcKeyHash  pfnCalcKeyHash, /* Calculate hash signature of key */
    LKR_PFnEqualKeys    pfnEqualKeys,   /* Compare two keys */
    LKR_PFnAddRefRecord pfnAddRefRecord,/* AddRef in LKR_FindKey, etc */
    LK_TABLESIZE        nTableSize,     /* Small/Med/Large number of elements*/
    DWORD               fCreateFlags    /* Mixture of LK_CREATE_* flags. */
    );

/* Destroy an LkrHashTable created by LKR_CreateTable.
 */
IRTL_DLLEXP
void
LKR_DeleteTable(
    PLkrHashTable plkr);

/* Insert a new record into hash table.
 * Returns LKR_SUCCESS if all OK, LKR_KEY_EXISTS if same key already
 * exists (unless fOverwrite), LKR_ALLOC_FAIL if out of space,
 * or LKR_BAD_RECORD for a bad record.
 * If fOverwrite is set and a record with this key is already present,
 * it will be overwritten. If there are multiple records with this key,
 * only the first will be overwritten.
 */
IRTL_DLLEXP
LK_RETCODE
LKR_InsertRecord(
    PLkrHashTable   plkr,
    const void*     pvRecord,
    BOOL            fOverwrite);

/* Delete record with the given key from the table. Does not actually delete
 * record from memory, just calls AddRefRecord(LKAR_DELETE_KEY);
 * Returns LKR_SUCCESS if all OK, or LKR_NO_SUCH_KEY if not found
 * If fDeleteAllSame is set, all records that match pnKey will be deleted
 * from the table; otherwise, only the first matching record is deleted.
 */
IRTL_DLLEXP
LK_RETCODE
LKR_DeleteKey(
    PLkrHashTable   plkr,
    const DWORD_PTR pnKey,
    BOOL            fDeleteAllSame);

/* Delete a record from the table, if present.
 * Returns LKR_SUCCESS if all OK, or LKR_NO_SUCH_KEY if not found
 */
IRTL_DLLEXP
LK_RETCODE
LKR_DeleteRecord(
    PLkrHashTable   plkr,
    const void*     pvRecord);

/* Find record with given key.
 * Returns:  LKR_SUCCESS, if record found (record is returned in *ppvRecord)
 *           LKR_NO_SUCH_KEY, if no record with given key value was found
 *           LKR_BAD_RECORD, if ppvRecord is invalid
 *           LKR_UNUSABLE, if hash table not in usable state
 * Note: the record is AddRef'd. You must decrement the reference
 * count when you are finished with the record (if you're implementing
 * refcounting semantics).
 */
IRTL_DLLEXP
LK_RETCODE
LKR_FindKey(
    PLkrHashTable   plkr,
    const DWORD_PTR pnKey,
    const void**    ppvRecord);

/* Sees if the record is contained in the table
 * Returns:  LKR_SUCCESS, if record found
 *           LKR_NO_SUCH_KEY, if record is not in the table
 *           LKR_BAD_RECORD, if pvRecord is invalid
 *           LKR_UNUSABLE, if hash table not in usable state
 * Note: the record is *not* AddRef'd. By definition, the caller
 * already has a reference to it.
 */
IRTL_DLLEXP
LK_RETCODE
LKR_FindRecord(
    PLkrHashTable   plkr,
    const void*     pvRecord);


#ifdef LKR_APPLY_IF

/* Walk the hash table, applying pfnAction to all records.
 * Locks one subtable after another with either a (possibly
 * shared) readlock or a writelock, according to lkl.
 * Loop is aborted if pfnAction ever returns LKA_ABORT.
 * Returns the number of successful applications.
 */
IRTL_DLLEXP
DWORD
LKR_Apply(
    PLkrHashTable       plkr,
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl);

/* Walk the hash table, applying pfnAction to any records that match
 * pfnPredicate. Locks one subtable after another with either
 * a (possibly shared) readlock or a writelock, according to lkl.
 * Loop is aborted if pfnAction ever returns LKA_ABORT.
 * Returns the number of successful applications.
 */
IRTL_DLLEXP
DWORD
LKR_ApplyIf(
    PLkrHashTable       plkr,
    LKR_PFnRecordPred   pfnPredicate,
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl);

/* Delete any records that match pfnPredicate.
 * Locks one subtable after another with a writelock.
 * Returns the number of deletions.
 *
 * Do *not* walk the hash table by hand with an iterator and call
 * LKR_DeleteKey. The iterator will end up pointing to garbage.
 */
IRTL_DLLEXP
DWORD
LKR_DeleteIf(
    PLkrHashTable       plkr,
    LKR_PFnRecordPred   pfnPredicate,
    void*               pvState);

#endif /* LKR_APPLY_IF */


/* Check table for consistency. Returns 0 if okay, or the number of
 * errors otherwise.
 */
IRTL_DLLEXP
int
LKR_CheckTable(
    PLkrHashTable plkr);

/* Remove all data from the table
 */
IRTL_DLLEXP
void
LKR_Clear(
    PLkrHashTable plkr);

/* Number of elements in the table
 */
IRTL_DLLEXP
DWORD
LKR_Size(
    PLkrHashTable plkr);

/* Maximum possible number of elements in the table
 */
IRTL_DLLEXP
DWORD
LKR_MaxSize(
    PLkrHashTable plkr);

/* Is the hash table usable?
 */
IRTL_DLLEXP
BOOL
LKR_IsUsable(
    PLkrHashTable plkr);

/* Is the hash table consistent and correct?
 */
IRTL_DLLEXP
BOOL
LKR_IsValid(
    PLkrHashTable plkr);

#ifdef LKR_EXPOSED_TABLE_LOCK

/* Lock the table (exclusively) for writing
 */
IRTL_DLLEXP
void
LKR_WriteLock(
    PLkrHashTable plkr);

/* Lock the table (possibly shared) for reading
 */
IRTL_DLLEXP
void
LKR_ReadLock(
    PLkrHashTable plkr);

/* Unlock the table for writing
 */
IRTL_DLLEXP
void
LKR_WriteUnlock(
    PLkrHashTable plkr);

/* Unlock the table for reading
 */
IRTL_DLLEXP
void
LKR_ReadUnlock(
    PLkrHashTable plkr);

/* Is the table already locked for writing?
 */
IRTL_DLLEXP
BOOL
LKR_IsWriteLocked(
    PLkrHashTable plkr);

/* Is the table already locked for reading?
 */
IRTL_DLLEXP
BOOL
LKR_IsReadLocked(
    PLkrHashTable plkr);

/* Is the table unlocked for writing?
 */
IRTL_DLLEXP
BOOL
LKR_IsWriteUnlocked(
    PLkrHashTable plkr);

/* Is the table unlocked for reading?
 */
IRTL_DLLEXP
BOOL
LKR_IsReadUnlocked(
    PLkrHashTable plkr);

/* Convert the read lock to a write lock. Note: another thread may acquire
 * exclusive access to the table before this routine returns.
 */
IRTL_DLLEXP
void
LKR_ConvertSharedToExclusive(
    PLkrHashTable plkr);

/* Convert the write lock to a read lock
 */
IRTL_DLLEXP
void
LKR_ConvertExclusiveToShared(
    PLkrHashTable plkr);

#endif /* LKR_EXPOSED_TABLE_LOCK */


#ifdef __cplusplus
} // extern "C"



// Only provide iterators in the C++ interface. It's too hard to
// provide the correct ownership semantics in a typesafe way in C,
// and C users can always use the LKR_ApplyIf family of callback
// enumerators if they really need to walk the hashtable.


#ifdef LKR_STL_ITERATORS

#pragma message("STL iterators")

// needed for std::forward_iterator_tag, etc
# include <utility>

#include <irtldbg.h>

#define LKR_ITER_TRACE IRTLTRACE


class IRTL_DLLEXP LKR_Iterator
{
private:
    friend IRTL_DLLEXP LKR_Iterator LKR_Begin(PLkrHashTable plkr);
    friend IRTL_DLLEXP LKR_Iterator LKR_End(PLkrHashTable plkr);

    // private ctor
    LKR_Iterator(bool);

public:
    // default ctor
    LKR_Iterator();
    // copy ctor
    LKR_Iterator(const LKR_Iterator& rhs);
    // assignment operator
    LKR_Iterator& operator=(const LKR_Iterator& rhs);
    // dtor
    ~LKR_Iterator();

    // Increment the iterator to point to the next record, or to LKR_End()
    bool Increment();
    // Is the iterator valid?
    bool IsValid() const;

    // Returns the record that the iterator points to.
    // Must point to a valid record.
    const void* Record() const;
    // Returns the key of the record that the iterator points to.
    // Must point to a valid record.
    const DWORD_PTR Key() const;

    // Compare two iterators for equality
    bool operator==(const LKR_Iterator& rhs) const;
    // Compare two iterators for inequality
    bool operator!=(const LKR_Iterator& rhs) const;

    // pointer to implementation object
    void* pImpl;
}; // class LKR_Iterator


/* Return iterator pointing to first item in table
 */
IRTL_DLLEXP
LKR_Iterator
LKR_Begin(
    PLkrHashTable plkr);

/* Return a one-past-the-end iterator. Always empty.
 */
IRTL_DLLEXP
LKR_Iterator
LKR_End(
    PLkrHashTable plkr);

/* Insert a record
 * Returns `true' if successful; iterResult points to that record
 * Returns `false' otherwise; iterResult == End()
 */
IRTL_DLLEXP
bool
LKR_Insert(
              PLkrHashTable plkr,
    /* in */  const void*   pvRecord,
    /* out */ LKR_Iterator& riterResult,
    /* in */  bool          fOverwrite=false);

/* Erase the record pointed to by the iterator; adjust the iterator
 * to point to the next record. Returns `true' if successful.
 */
IRTL_DLLEXP
bool
LKR_Erase(
                 PLkrHashTable plkr,
    /* in,out */ LKR_Iterator& riter);

/* Erase the records in the range [riterFirst, riterLast).
 * Returns `true' if successful.
 */
IRTL_DLLEXP
bool
LKR_Erase(
           PLkrHashTable plkr,
    /*in*/ LKR_Iterator& riterFirst,
    /*in*/ LKR_Iterator& riterLast);

/* Find the (first) record that has its key == pnKey.
 * If successful, returns `true' and iterator points to (first) record.
 * If fails, returns `false' and iterator == End()
 */
IRTL_DLLEXP
bool
LKR_Find(
              PLkrHashTable plkr,
    /* in */  DWORD_PTR     pnKey,
    /* out */ LKR_Iterator& riterResult);

/* Find the range of records that have their keys == pnKey.
 * If successful, returns `true', iterFirst points to first record,
 *     and iterLast points to one-beyond-the last such record.
 * If fails, returns `false' and both iterators == End().
 * Primarily useful when fMultiKeys == TRUE
 */
IRTL_DLLEXP
bool
LKR_EqualRange(
              PLkrHashTable plkr,
    /* in */  DWORD_PTR     pnKey,
    /* out */ LKR_Iterator& riterFirst,     // inclusive
    /* out */ LKR_Iterator& riterLast);     // exclusive

#endif // LKR_STL_ITERATORS



//--------------------------------------------------------------------
// A typesafe wrapper for PLkrHashTable
//
// * _Derived must derive from TypedLkrHashTable and provide certain member
//   functions. It's needed for various downcasting operations.
// * _Record is the type of the record. PLkrHashTable will store
//   pointers to _Record, as const void*.
// * _Key is the type of the key. _Key is used directly; i.e., it is
//   not assumed to be a pointer type. PLkrHashTable assumes that
//   the key is stored in the associated record. See the comments
//   at the declaration of LKR_PFnExtractKey for more details.
//
// You may need to add the following line to your code to disable
// warning messages about truncating extremly long identifiers.
//   #pragma warning (disable : 4786)
//
// The _Derived class should look something like this:
//  class CDerived : public TypedLkrHashTable<CDerived, RecordType, KeyType>
//  {
//  public:
//      CDerived()
//          : TypedLkrHashTable<CDerived, RecordType, KeyType>("CDerived")
//      {/*other ctor actions*/}
//      static KeyType ExtractKey(const RecordType* pTest);
//      static DWORD   CalcKeyHash(const KeyType Key);
//      static bool    EqualKeys(const KeyType Key1, const KeyType Key2);
//      static void    AddRefRecord(RecordType* pRecord,LK_ADDREF_REASON lkar);
//      // optional: other functions
//  };
//
//--------------------------------------------------------------------

template <class _Derived, class _Record, class _Key>
class TypedLkrHashTable
{
public:
    // convenient aliases
    typedef _Derived        Derived;
    typedef _Record         Record;
    typedef _Key            Key;

    typedef TypedLkrHashTable<_Derived, _Record, _Key> HashTable;

#ifdef LKR_APPLY_IF
    // LKR_ApplyIf() and LKR_DeleteIf(): Does the record match the predicate?
    // Note: takes a Record*, not a const Record*. You can modify the
    // record in Pred() or Action(), if you like, but if you do, you
    // should use LKL_WRITELOCK to lock the table.
    typedef LK_PREDICATE (WINAPI *PFnRecordPred) (Record* pRec, void* pvState);

    // Apply() et al: Perform action on record.
    typedef LK_ACTION   (WINAPI *PFnRecordAction)(Record* pRec, void* pvState);
#endif // LKR_APPLY_IF

protected:
    PLkrHashTable m_plkr;

    // Wrappers for the typesafe methods exposed by the derived class

    static const DWORD_PTR WINAPI
    _ExtractKey(const void* pvRecord)
    {
        const _Record* pRec = static_cast<const _Record*>(pvRecord);
        const _Key   key = static_cast<const _Key>(_Derived::ExtractKey(pRec));
        // I would prefer to use reinterpret_cast here and in _CalcKeyHash
        // and _EqualKeys, but the stupid Win64 compiler thinks it knows
        // better than I do.
        return (const DWORD_PTR) key;
    }

    static DWORD WINAPI
    _CalcKeyHash(const DWORD_PTR pnKey)
    {
        const _Key key = (const _Key) (DWORD_PTR) pnKey;
        return _Derived::CalcKeyHash(key);
    }

    static BOOL WINAPI
    _EqualKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2)
    {
        const _Key key1 = (const _Key) (DWORD_PTR) pnKey1;
        const _Key key2 = (const _Key) (DWORD_PTR) pnKey2;
        return _Derived::EqualKeys(key1, key2);
    }

    static void WINAPI
    _AddRefRecord(const void* pvRecord, LK_ADDREF_REASON lkar)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        _Derived::AddRefRecord(pRec, lkar);
    }


#ifdef LKR_APPLY_IF
    // Typesafe wrappers for Apply, ApplyIf, and DeleteIf.

    class CState
    {
    public:
        PFnRecordPred   m_pfnPred;
        PFnRecordAction m_pfnAction;
        void*           m_pvState;

        CState(
            PFnRecordPred   pfnPred,
            PFnRecordAction pfnAction,
            void*           pvState)
            : m_pfnPred(pfnPred), m_pfnAction(pfnAction), m_pvState(pvState)
        {}
    };

    static LK_PREDICATE WINAPI
    _Pred(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnPred)(pRec, pState->m_pvState);
    }

    static LK_ACTION WINAPI
    _Action(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnAction)(pRec, pState->m_pvState);
    }
#endif // LKR_APPLY_IF

public:
    TypedLkrHashTable(
        LPCSTR        pszName,          // An identifier for debugging
        LK_TABLESIZE  nTableSize,       // Small/Med/Large number of elements
        bool          fMultiKeys=false  // Allow multiple identical keys?
        )
        : m_plkr(NULL)
    {
        m_plkr = LKR_CreateTable(pszName, _ExtractKey, _CalcKeyHash,
                                 _EqualKeys, _AddRefRecord,
                                 nTableSize, fMultiKeys);
    }

    ~TypedLkrHashTable()
    {
        LKR_DeleteTable(m_plkr);
    }

    LK_RETCODE   InsertRecord(const _Record* pRec, bool fOverwrite=false)
    { return LKR_InsertRecord(m_plkr, pRec, fOverwrite); }

    LK_RETCODE   DeleteKey(const _Key key, bool fDeleteAllSame=false)
    {
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return LKR_DeleteKey(m_plkr, pnKey, fDeleteAllSame);
    }

    LK_RETCODE   DeleteRecord(const _Record* pRec)
    { return LKR_DeleteRecord(m_plkr, pRec);}

    // Note: returns a _Record**, not a const Record**. Note that you
    // can use a const type for the template parameter to ensure constness.
    LK_RETCODE   FindKey(const _Key key, _Record** ppRec) const
    {
        if (ppRec == NULL)
            return LK_BAD_RECORD;
        *ppRec = NULL;
        const void* pvRec = NULL;
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        LK_RETCODE lkrc = LKR_FindKey(m_plkr, pnKey, &pvRec);
        *ppRec = static_cast<_Record*>(const_cast<void*>(pvRec));
        return lkrc;
    }

    LK_RETCODE   FindRecord(const _Record* pRec) const
    { return LKR_FindRecord(m_plkr, pRec);}

#ifdef LKR_APPLY_IF
    DWORD        Apply(PFnRecordAction pfnAction,
                       void*           pvState=NULL,
                       LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnAction != NULL);
        if (pfnAction == NULL)
            return 0;

        CState   state(NULL, pfnAction, pvState);
        return   LKR_Apply(m_plkr, _Action, &state, lkl);
    }

    DWORD        ApplyIf(PFnRecordPred   pfnPredicate,
                         PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);
        if (pfnPredicate == NULL  ||  pfnAction == NULL)
            return 0;

        CState   state(pfnPredicate, pfnAction, pvState);
        return   LKR_ApplyIf(m_plkr, _Pred, _Action, &state, lkl);
    }

    DWORD        DeleteIf(PFnRecordPred pfnPredicate, void* pvState=NULL)
    {
        IRTLASSERT(pfnPredicate != NULL);
        if (pfnPredicate == NULL)
            return 0;

        CState   state(pfnPredicate, NULL, pvState);
        return   LKR_DeleteIf(m_plkr, _Pred, &state);
    }
#endif // LKR_APPLY_IF

    int          CheckTable() const
    { return LKR_CheckTable(m_plkr); }

    void          Clear()
    { return LKR_Clear(m_plkr); }

    DWORD         Size() const
    { return LKR_Size(m_plkr); }

    DWORD         MaxSize() const
    { return LKR_MaxSize(m_plkr); }

    BOOL          IsUsable() const
    { return LKR_IsUsable(m_plkr); }

    BOOL          IsValid() const
    { return LKR_IsValid(m_plkr); }

#ifdef LKR_EXPOSED_TABLE_LOCK
    void          WriteLock()
    { LKR_WriteLock(m_plkr); }

    void          ReadLock() const
    { LKR_ReadLock(m_plkr); }

    void          WriteUnlock()
    { LKR_WriteUnlock(m_plkr); }

    void          ReadUnlock() const
    { LKR_ReadUnlock(m_plkr); }

    BOOL          IsWriteLocked() const
    { return LKR_IsWriteLocked(m_plkr); }

    BOOL          IsReadLocked() const
    { return LKR_IsReadLocked(m_plkr); }

    BOOL          IsWriteUnlocked() const
    { return LKR_IsWriteUnlocked(m_plkr); }

    BOOL          IsReadUnlocked() const
    { return LKR_IsReadUnlocked(m_plkr); }

    void          ConvertSharedToExclusive() const
    { LKR_ConvertSharedToExclusive(m_plkr); }

    void          ConvertExclusiveToShared() const
    { LKR_ConvertExclusiveToShared(m_plkr); }
#endif // LKR_EXPOSED_TABLE_LOCK


#ifdef LKR_STL_ITERATORS
    friend class LKR_Iterator;

    // TODO: const_iterator

public:
    class iterator
    {
        friend class TypedLkrHashTable<_Derived, _Record, _Key>;

    protected:
        LKR_Iterator            m_iter;

        iterator(
            LKR_Iterator& rhs)
            : m_iter(rhs)
        {
            LKR_ITER_TRACE(_TEXT("Typed::prot ctor, this=%p, rhs=%p\n"),
                           this, &rhs);
        }

    public:
        typedef std::forward_iterator_tag   iterator_category;
        typedef _Record                     value_type;
        typedef ptrdiff_t                   difference_type;
        typedef size_t                      size_type;
        typedef value_type&                 reference;
        typedef value_type*                 pointer;

        iterator()
            : m_iter()
        {
            LKR_ITER_TRACE(_TEXT("Typed::default ctor, this=%p\n"), this);
        }

        iterator(
            const iterator& rhs)
            : m_iter(rhs.m_iter)
        {
            LKR_ITER_TRACE(_TEXT("Typed::copy ctor, this=%p, rhs=%p\n"),
                           this, &rhs);
        }

        iterator& operator=(
            const iterator& rhs)
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator=, this=%p, rhs=%p\n"),
                           this, &rhs);
            m_iter = rhs.m_iter;
            return *this;
        }

        ~iterator()
        {
            LKR_ITER_TRACE(_TEXT("Typed::dtor, this=%p\n"), this);
        }

        reference operator*() const
        {
            void* pvRecord = const_cast<void*>(m_iter.Record());
            return reinterpret_cast<reference>(pvRecord);
        }

        pointer   operator->() const  { return &(operator*()); }

        // pre-increment
        iterator& operator++()
        {
            LKR_ITER_TRACE(_TEXT("Typed::pre-increment, this=%p\n"), this);
            m_iter.Increment();
            return *this;
        }

        // post-increment
        iterator  operator++(int)
        {
            LKR_ITER_TRACE(_TEXT("Typed::post-increment, this=%p\n"), this);
            iterator iterPrev = *this;
            m_iter.Increment();
            return iterPrev;
        }

        bool operator==(
            const iterator& rhs) const
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator==, this=%p, rhs=%p\n"),
                           this, &rhs);
            return m_iter == rhs.m_iter;
        }

        bool operator!=(
            const iterator& rhs) const
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator!=, this=%p, rhs=%p\n"),
                           this, &rhs);
            return m_iter != rhs.m_iter;
        }

        _Record*  Record() const
        {
            LKR_ITER_TRACE(_TEXT("Typed::Record, this=%p\n"), this);
            return reinterpret_cast<_Record*>(
                        const_cast<void*>(m_iter.Record()));
        }

        _Key      Key() const
        {
            LKR_ITER_TRACE(_TEXT("Typed::Key, this=%p\n"), this);
            return reinterpret_cast<_Key>(
                        reinterpret_cast<void*>(m_iter.Key()));
        }
    }; // class iterator

    // Return iterator pointing to first item in table
    iterator begin()
    {
        LKR_ITER_TRACE(_TEXT("Typed::begin()\n"));
        return LKR_Begin(m_plkr);
    }

    // Return a one-past-the-end iterator. Always empty.
    iterator end() const
    {
        LKR_ITER_TRACE(_TEXT("Typed::end()\n"));
        return LKR_End(m_plkr);
    }

    template <class _InputIterator>
    TypedLkrHashTable(
        LPCSTR pszName,             // An identifier for debugging
        _InputIterator f,           // first element in range
        _InputIterator l,           // one-beyond-last element
        LK_TABLESIZE  nTableSize,   // Small/Med/Large number of elements
        bool   fMultiKeys=false     // Allow multiple identical keys?
        )
    {
        m_plkr = LKR_CreateTable(pszName, _ExtractKey, _CalcKeyHash,
                                 _EqualKeys, _AddRefRecord,
                                 nTableSize, fMultiKeys);
        insert(f, l);
    }

    template <class _InputIterator>
    void insert(_InputIterator f, _InputIterator l)
    {
        for ( ;  f != l;  ++f)
            InsertRecord(&(*f));
    }

    bool
    Insert(
        const _Record* pRecord,
        iterator& riterResult,
        bool fOverwrite=false)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Insert\n"));
        return LKR_Insert(m_plkr, pRecord, riterResult.m_iter, fOverwrite);
    }

    bool
    Erase(
        iterator& riter)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Erase\n"));
        return LKR_Erase(m_plkr, riter.m_iter);
    }

    bool
    Erase(
        iterator& riterFirst,
        iterator& riterLast)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Erase2\n"));
        return LKR_Erase(m_plkr, riterFirst.m_iter, riterLast.m_iter);
    }

    bool
    Find(
        const _Key key,
        iterator& riterResult)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Find\n"));
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return LKR_Find(m_plkr, pnKey, riterResult.m_iter);
    }

    bool
    EqualRange(
        const _Key key,
        iterator& riterFirst,
        iterator& riterLast)
    {
        LKR_ITER_TRACE(_TEXT("Typed::EqualRange\n"));
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return LKR_EqualRange(m_plkr, pnKey, riterFirst.m_iter,
                              riterLast.m_iter);
    }

#undef LKR_ITER_TRACE

#endif // LKR_STL_ITERATORS

}; // class TypedLkrHashTable

#endif /* __cplusplus */

#endif /* __LKR_HASH_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\inc\locks.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       Locks.h

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __LOCKS_H__
#define __LOCKS_H__

//--------------------------------------------------------------------
// File: locks.h
//
// A collection of different implementations of read/write locks that all
// share the same interface.  This allows different locks to be plugged
// into C++ templates as parameters.
//
// The implementations are:
//      CSmallSpinLock      lightweight critical section
//      CSpinLock           variant of CSmallSpinLock
//      CFakeLock           do-nothing class; useful as a template parameter
//      CCritSec            Win32 CRITICAL_SECTION
//   Multi-Reader/Single-Writer locks:
//      CReaderWriterLock   MRSW lock from Neel Jain
//      CReaderWriterLock2  smaller implementation of CReaderWriterLock
//      CReaderWriterLock3  CReaderWriterLock2 with recursive WriteLock
//
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> can used as
// exception-safe wrappers.
//
// TODO:
// * Add per-class lock-contention statistics
// * Add a timeout feature to Try{Read,Write}Lock
// * Add some way of tracking all the owners of a multi-reader lock
//--------------------------------------------------------------------


#if defined(_MSC_VER)  &&  (_MSC_VER >= 1200)
// The __forceinline keyword is new to VC6
// # define LOCK_FORCEINLINE __forceinline
# define LOCK_FORCEINLINE
#else
# define LOCK_FORCEINLINE inline
#endif

#ifndef LOCKS_KERNEL_MODE
# define LOCKS_ENTER_CRIT_REGION()   ((void) 0)
# define LOCKS_LEAVE_CRIT_REGION()   ((void) 0)
#else
# define LOCKS_ENTER_CRIT_REGION()   KeEnterCriticalRegion()
# define LOCKS_LEAVE_CRIT_REGION()   KeLeaveCriticalRegion()
#endif



#ifndef __IRTLDBG_H__
# include <irtldbg.h>
#endif


enum LOCK_LOCKTYPE {
    LOCK_FAKELOCK = 1,
    LOCK_SMALLSPINLOCK,
    LOCK_SPINLOCK,
    LOCK_CRITSEC,
    LOCK_READERWRITERLOCK,
    LOCK_READERWRITERLOCK2,
    LOCK_READERWRITERLOCK3,
    LOCK_KSPINLOCK,
    LOCK_FASTMUTEX,
    LOCK_ERESOURCE,
};


// Forward declarations
class IRTL_DLLEXP CSmallSpinLock;
class IRTL_DLLEXP CSpinLock;
class IRTL_DLLEXP CFakeLock;
class IRTL_DLLEXP CCritSec;
class IRTL_DLLEXP CReaderWriterLock;
class IRTL_DLLEXP CReaderWriterLock2;
class IRTL_DLLEXP CReaderWriterLock3;




//--------------------------------------------------------------------
// Spin count values.

enum LOCK_SPINS {
    LOCK_MAXIMUM_SPINS =      10000,    // maximum allowable spin count
    LOCK_DEFAULT_SPINS =       4000,    // default spin count
    LOCK_MINIMUM_SPINS =        100,    // minimum allowable spin count
    LOCK_USE_DEFAULT_SPINS = 0xFFFF,    // use class default spin count
    LOCK_DONT_SPIN =              0,    // don't spin at all
};


#ifndef LOCKS_KERNEL_MODE

// Boilerplate code for the per-class default spincount and spinfactor

#define LOCK_DEFAULT_SPIN_IMPLEMENTATION()                                  \
protected:                                                                  \
    /* per-class variables */                                               \
    static   WORD   sm_wDefaultSpinCount;   /* global default spin count */   \
    static   double sm_dblDfltSpinAdjFctr;  /* global spin adjustment factor*/\
                                                                            \
public:                                                                     \
    /* Set the default spin count for all locks */                          \
    static void SetDefaultSpinCount(WORD wSpins)                            \
    {                                                                       \
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)                               \
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)                    \
                   || (LOCK_MINIMUM_SPINS <= wSpins                         \
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));                  \
                                                                            \
        if ((LOCK_MINIMUM_SPINS <= wSpins  &&  wSpins <= LOCK_MAXIMUM_SPINS)\
                || (wSpins == LOCK_DONT_SPIN))                              \
            sm_wDefaultSpinCount = wSpins;                                  \
        else if (wSpins == LOCK_USE_DEFAULT_SPINS)                          \
            sm_wDefaultSpinCount = LOCK_DEFAULT_SPINS;                      \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static WORD GetDefaultSpinCount()                                       \
    {                                                                       \
        return sm_wDefaultSpinCount;                                        \
    }                                                                       \
                                                                            \
    /* Set the adjustment factor for the spincount, used in each iteration */\
    /* of countdown-and-sleep by the backoff algorithm. */                  \
    static void SetDefaultSpinAdjustmentFactor(double dblAdjFactor)         \
    {                                                                       \
        IRTLASSERT(0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0);          \
        if (0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0)                  \
            sm_dblDfltSpinAdjFctr = dblAdjFactor;                           \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static double GetDefaultSpinAdjustmentFactor()                          \
    {                                                                       \
        return sm_dblDfltSpinAdjFctr;                                       \
    }                                                                       \

#endif // !LOCKS_KERNEL_MODE



//--------------------------------------------------------------------
// Various Lock Traits

// Is the lock a simple mutex or a multi-reader/single-writer lock?
enum LOCK_RW_MUTEX {
    LOCK_MUTEX = 1,         // mutexes allow only one thread to hold the lock
    LOCK_MRSW,              // multi-reader, single-writer
};


// Can the lock be recursively acquired?
enum LOCK_RECURSION {
    LOCK_RECURSIVE = 1,     // Write and Read locks can be recursively acquired
    LOCK_READ_RECURSIVE,    // Read locks can be reacquired, but not Write
    LOCK_NON_RECURSIVE,     // Will deadlock if attempt to acquire recursively
};


// Does the lock Sleep in a loop or block on a kernel synch object handle?
// May (or may not) spin first before sleeping/blocking.
enum LOCK_WAIT_TYPE {
    LOCK_WAIT_SLEEP = 1,    // Calls Sleep() in a loop
    LOCK_WAIT_HANDLE,       // Blocks on a kernel mutex, semaphore, or event
    LOCK_WAIT_SPIN,         // Spins until lock acquired. Never sleeps.
};


// When the lock is taken, how are the waiters dequeued?
enum LOCK_QUEUE_TYPE {
    LOCK_QUEUE_FIFO = 1,    // First in, first out.  Fair.
    LOCK_QUEUE_LIFO,        // Unfair but CPU cache friendly
    LOCK_QUEUE_KERNEL,      // Determined by vagaries of scheduler
};


// Can the lock's spincount be set on a per-lock basis, or is it only
// possible to modify the default spincount for all the locks in this class?
enum LOCK_PERLOCK_SPIN {
    LOCK_NO_SPIN = 1,       // The locks do not spin at all
    LOCK_CLASS_SPIN,        // Can set class-wide spincount, not individual
    LOCK_INDIVIDUAL_SPIN,   // Can set a spincount on an individual lock
};


//--------------------------------------------------------------------
// CLockBase: bundle the above attributes

template < LOCK_LOCKTYPE     locktype,
           LOCK_RW_MUTEX     mutextype,
           LOCK_RECURSION    recursiontype,
           LOCK_WAIT_TYPE    waittype,
           LOCK_QUEUE_TYPE   queuetype,
           LOCK_PERLOCK_SPIN spintype
         >
class CLockBase
{
public:
    static LOCK_LOCKTYPE     LockType()     {return locktype;}
    static LOCK_RW_MUTEX     MutexType()    {return mutextype;}
    static LOCK_RECURSION    Recursion()    {return recursiontype;}
    static LOCK_WAIT_TYPE    WaitType()     {return waittype;}
    static LOCK_QUEUE_TYPE   QueueType()    {return queuetype;}
    static LOCK_PERLOCK_SPIN PerLockSpin()  {return spintype;}
};



// Lock instrumentation causes all sorts of interesting statistics about
// lock contention, etc., to be gathered, but makes locks considerably fatter
// and somewhat slower.  Turned off by default.

// #define LOCK_INSTRUMENTATION 1

#ifdef LOCK_INSTRUMENTATION

//--------------------------------------------------------------------
// CLockStatistics: statistics for an individual lock

class IRTL_DLLEXP CLockStatistics
{
public:
    enum {
        L_NAMELEN = 8,
    };

    double   m_nContentions;     // #times this lock was already locked
    double   m_nSleeps;          // Total #Sleep()s needed
    double   m_nContentionSpins; // Total iterations this lock spun
    double   m_nAverageSpins;    // Average spins each contention needed
    double   m_nReadLocks;       // Number of times lock acquired for reading
    double   m_nWriteLocks;      // Number of times lock acquired for writing
    TCHAR    m_tszName[L_NAMELEN];// Name of this lock

    CLockStatistics()
        : m_nContentions(0),
          m_nSleeps(0),
          m_nContentionSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {
        m_tszName[0] = _TEXT('\0');
    }
};



//--------------------------------------------------------------------
// CGlobalLockStatistics: statistics for all the known locks

class IRTL_DLLEXP CGlobalLockStatistics
{
public:
    LONG     m_cTotalLocks;     // Total number of locks created
    LONG     m_cContendedLocks; // Total number of contended locks
    LONG     m_nSleeps;         // Total #Sleep()s needed by all locks
    LONGLONG m_cTotalSpins;     // Total iterations all locks spun
    double   m_nAverageSpins;   // Average spins needed for each contended lock
    LONG     m_nReadLocks;      // Total ReadLocks
    LONG     m_nWriteLocks;     // Total WriteLocks

    CGlobalLockStatistics()
        : m_cTotalLocks(0),
          m_cContendedLocks(0),
          m_nSleeps(0),
          m_cTotalSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {}
};

# define LOCK_INSTRUMENTATION_DECL() \
private:                                                                    \
    volatile LONG   m_nContentionSpins; /* #iterations this lock spun */    \
    volatile WORD   m_nContentions;     /* #times lock was already locked */\
    volatile WORD   m_nSleeps;          /* #Sleep()s needed */              \
    volatile WORD   m_nReadLocks;       /* #ReadLocks */                    \
    volatile WORD   m_nWriteLocks;      /* #WriteLocks */                   \
    TCHAR           m_tszName[CLockStatistics::L_NAMELEN]; /* Name of lock */\
                                                                            \
    static   LONG   sm_cTotalLocks;     /* Total number of locks created */ \
    static   LONG   sm_cContendedLocks; /* Total number of contended locks */\
    static   LONG   sm_nSleeps;         /* Total #Sleep()s by all locks */  \
    static LONGLONG sm_cTotalSpins;     /* Total iterations all locks spun */\
    static   LONG   sm_nReadLocks;      /* Total ReadLocks */               \
    static   LONG   sm_nWriteLocks;     /* Total WriteLocks */              \
                                                                            \
public:                                                                     \
    const TCHAR* Name() const       {return m_tszName;}                     \
                                                                            \
    CLockStatistics                 Statistics() const;                     \
    static CGlobalLockStatistics    GlobalStatistics();                     \
    static void                     ResetGlobalStatistics();                \
private:                                                                    \


// Add this to constructors

# define LOCK_INSTRUMENTATION_INIT(ptszName)        \
    m_nContentionSpins = 0;                         \
    m_nContentions = 0;                             \
    m_nSleeps = 0;                                  \
    m_nReadLocks = 0;                               \
    m_nWriteLocks = 0;                              \
    ++sm_cTotalLocks;                               \
    if (ptszName == NULL)                           \
        m_tszName[0] = _TEXT('\0');                 \
    else                                            \
        _tcsncpy(m_tszName, ptszName, sizeof(m_tszName)/sizeof(TCHAR))

// Note: we are not using Interlocked operations for the shared
// statistical counters.  We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.

# define LOCK_READLOCK_INSTRUMENTATION()    \
      { ++m_nReadLocks;                     \
        ++sm_nReadLocks; }

# define LOCK_WRITELOCK_INSTRUMENTATION()   \
      { ++m_nWriteLocks;                    \
        ++sm_nWriteLocks; }

#else // !LOCK_INSTRUMENTATION

# define LOCK_INSTRUMENTATION_DECL()
# define LOCK_READLOCK_INSTRUMENTATION()    ((void) 0)
# define LOCK_WRITELOCK_INSTRUMENTATION()   ((void) 0)

#endif // !LOCK_INSTRUMENTATION



//--------------------------------------------------------------------
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> provide exception-safe
// acquisition and release of the other locks defined below

template <class _Lock>
class IRTL_DLLEXP CAutoReadLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoReadLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }
    ~CAutoReadLock()
    {
        Unlock();
    }

    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.ReadLock();
        }
    }

    void Unlock()
    {
        if (m_fLocked)
        {
            m_Lock.ReadUnlock();
            m_fLocked = false;
        }
    }
};



template <class _Lock>
class IRTL_DLLEXP CAutoWriteLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoWriteLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }

    ~CAutoWriteLock()
    {
        Unlock();
    }

    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.WriteLock();
        }
    }

    void Unlock()
    {
        if (m_fLocked)
        {
            m_fLocked = false;
            m_Lock.WriteUnlock();
        }
    }
};




//--------------------------------------------------------------------
// A dummy class, primarily useful as a template parameter

class IRTL_DLLEXP CFakeLock :
    public CLockBase<LOCK_FAKELOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_FIFO,
                       LOCK_NO_SPIN
                      >
{
private:
    LOCK_INSTRUMENTATION_DECL();

public:
    CFakeLock()                     {}
#ifdef LOCK_INSTRUMENTATION
    CFakeLock(const char*)          {}
#endif // LOCK_INSTRUMENTATION
    ~CFakeLock()                    {}
    void WriteLock()                {}
    void ReadLock()                 {}
    bool ReadOrWriteLock()          {return true;}
    bool TryWriteLock()             {return true;}
    bool TryReadLock()              {return true;}
    void WriteUnlock()              {}
    void ReadUnlock()               {}
    void ReadOrWriteUnlock(bool)    {}
    bool IsWriteLocked() const      {return true;}
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}
    bool IsReadUnlocked() const     {return true;}
    void ConvertSharedToExclusive() {}
    void ConvertExclusiveToShared() {}

    bool SetSpinCount(WORD dwSpins) {return false;}
    WORD GetSpinCount() const       {return LOCK_DONT_SPIN;}

#ifndef LOCKS_KERNEL_MODE
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // !LOCKS_KERNEL_MODE

    static const TCHAR*   ClassName()  {return _TEXT("CFakeLock");}
}; // CFakeLock




//--------------------------------------------------------------------
// A spinlock is a sort of lightweight critical section.  Its main
// advantage over a true Win32 CRITICAL_SECTION is that it occupies 4 bytes
// instead of 24 (+ another 32 bytes for the RTL_CRITICAL_SECTION_DEBUG data),
// which is important when we have many thousands of locks
// and we're trying to be L1 cache-conscious.  A CRITICAL_SECTION also
// contains a HANDLE to a semaphore, although this is not initialized until
// the first time that the CRITICAL_SECTION blocks.
//
// On a multiprocessor machine, a spinlock tries to acquire the lock.  If
// it fails, it sits in a tight loop, testing the lock and decrementing a
// counter.  If the counter reaches zero, it does a Sleep(0), yielding the
// processor to another thread.  When control returns to the thread, the
// lock is probably free.  If not, the loop starts again and it is
// terminated only when the lock is acquired.  The theory is that it is
// less costly to spin in a busy loop for a short time rather than
// immediately yielding the processor, forcing an expensive context switch
// that requires the old thread's state (registers, etc) be saved, the new
// thread's state be reloaded, and the L1 and L2 caches be left full of
// stale data.
//
// You can tune the spin count (global only: per-lock spin counts are
// disabled) and the backoff algorithm (the factor by which the spin
// count is multiplied after each Sleep).
//
// On a 1P machine, the loop is pointless---this thread has control,
// hence no other thread can possibly release the lock while this thread
// is looping---so the processor is yielded immediately.
//
// The kernel uses spinlocks internally and spinlocks were also added to
// CRITICAL_SECTIONs in NT 4.0 sp3.  In the CRITICAL_SECTION implementation,
// however, the counter counts down only once and waits on a semaphore
// thereafter (i.e., the same blocking behavior that it exhibits without
// the spinlock).
//
// A disadvantage of a user-level spinlock such as this is that if the
// thread that owns the spinlock blocks for any reason (or is preempted by
// the scheduler), all the other threads will continue to spin on the
// spinlock, wasting CPU, until the owning thread completes its wait and
// releases the lock.  (The kernel spinlocks, however, are smart enough to
// switch to another runnable thread instead of wasting time spinning.)
// The backoff algorithm decreases the spin count on each iteration in an
// attempt to minimize this effect.  The best policy---and this is true for
// all locks---is to hold the lock for as short as time as possible.
//
// Note: unlike a CRITICAL_SECTION, a CSmallSpinLock cannot be recursively
// acquired; i.e., if you acquire a spinlock and then attempt to acquire it
// again *on the same thread* (perhaps from a different function), the
// thread will hang forever.  Use CSpinLock instead, which is safe though a
// little slower than a CSmallSpinLock.  If you own all the code
// that is bracketed by Lock() and Unlock() (e.g., no callbacks or passing
// back of locked data structures to callers) and know for certain that it
// will not attempt to reacquire the lock, you can use CSmallSpinLock.
//
// See also http://muralik/work/performance/spinlocks.htm and John Vert's
// MSDN article, "Writing Scalable Applications for Windows NT".
//
// The original implementation is due to PALarson.

class IRTL_DLLEXP CSmallSpinLock :
    public CLockBase<LOCK_SMALLSPINLOCK, LOCK_MUTEX,
                       LOCK_NON_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lTid;              // The lock state variable

    enum {
        SL_UNOWNED = 0,
#ifdef LOCK_SMALL_SPIN_NO_THREAD_ID
        SL_LOCKED  = 1,
#endif // LOCK_SMALL_SPIN_NO_THREAD_ID
    };

    LOCK_INSTRUMENTATION_DECL();

    LOCK_FORCEINLINE static LONG _CurrentThreadId()
    {
#ifdef LOCK_SMALL_SPIN_NO_THREAD_ID
        DWORD dwTid = SL_LOCKED;
#else  // !LOCK_SMALL_SPIN_NO_THREAD_ID
 #ifdef LOCKS_KERNEL_MODE
        DWORD dwTid = (DWORD) HandleToULong(::PsGetCurrentThreadId());
 #else // !LOCKS_KERNEL_MODE
        DWORD dwTid = ::GetCurrentThreadId();
 #endif // !LOCKS_KERNEL_MODE
#endif // !LOCK_SMALL_SPIN_NO_THREAD_ID
        return (LONG) (dwTid);
    }

private:
    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

    // Attempt to acquire the lock
    bool _TryLock();

    // Release the lock
    void _Unlock();

public:

#ifndef LOCK_INSTRUMENTATION

    CSmallSpinLock()
        : m_lTid(SL_UNOWNED)
    {}

#else // LOCK_INSTRUMENTATION

    CSmallSpinLock(
        const TCHAR* ptszName)
        : m_lTid(SL_UNOWNED)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }

#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CSmallSpinLock()
    {
        IRTLASSERT(m_lTid == SL_UNOWNED);
    }
#endif // IRTLDEBUG

    // Acquire an exclusive lock for writing.
    // Blocks (if needed) until acquired.
    inline void WriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Optimize for the common case by helping the processor's branch
        // prediction algorithm.
        if (_TryLock())
            return;

        _LockSpin();
    }

    // Acquire a (possibly shared) lock for reading.
    // Blocks (if needed) until acquired.
    inline void ReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_READLOCK_INSTRUMENTATION();

        if (_TryLock())
            return;

        _LockSpin();
    }

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    inline bool TryWriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();
        else
            LOCKS_LEAVE_CRIT_REGION();

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    inline bool TryReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();
        else
            LOCKS_LEAVE_CRIT_REGION();

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    // Assumes caller owned the lock.
    inline void WriteUnlock()
    {
        _Unlock();
        LOCKS_LEAVE_CRIT_REGION();
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    // Assumes caller owned the lock.
    inline void ReadUnlock()
    {
        _Unlock();
        LOCKS_LEAVE_CRIT_REGION();
    }

    // Is the lock already locked for writing by this thread?
    bool IsWriteLocked() const
    {
        return (m_lTid == _CurrentThreadId());
    }

    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return IsWriteLocked();
    }

    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return (m_lTid == SL_UNOWNED);
    }

    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return IsWriteUnlocked();
    }

    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    // Set the spin count for this lock.
    // Returns true if successfully set the per-lock spincount, false otherwise
    bool SetSpinCount(WORD wSpins)
    {
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)
                   || (LOCK_MINIMUM_SPINS <= wSpins
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));

        return false;
    }

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*   ClassName()  {return _TEXT("CSmallSpinLock");}
}; // CSmallSpinLock




//--------------------------------------------------------------------
// CSpinLock is a spinlock that doesn't deadlock if recursively acquired.
// This version occupies only 4 bytes.  Uses 28 bits for the thread id.

class IRTL_DLLEXP CSpinLock :
    public CLockBase<LOCK_SPINLOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    // a union for convenience
    volatile LONG m_lTid;

    enum {
        SL_THREAD_SHIFT = 0,
        SL_THREAD_BITS  = 28,
        SL_OWNER_SHIFT  = SL_THREAD_BITS,
        SL_OWNER_BITS   = 4,
        SL_THREAD_MASK  = ((1 << SL_THREAD_BITS) - 1) << SL_THREAD_SHIFT,
        SL_OWNER_INCR   = 1 << SL_THREAD_BITS,
        SL_OWNER_MASK   = ((1 << SL_OWNER_BITS) - 1) << SL_OWNER_SHIFT,
        SL_UNOWNED      = 0,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    // Get the current thread ID.  Assumes that it can fit into 28 bits,
    // which is fairly safe as NT recycles thread IDs and failing to fit into
    // 28 bits would mean that more than 268,435,456 threads were currently
    // active.  This is improbable in the extreme as NT runs out of
    // resources if there are more than a few thousands threads in
    // existence and the overhead of context swapping becomes unbearable.
    LOCK_FORCEINLINE static DWORD _GetCurrentThreadId()
    {
#ifdef LOCKS_KERNEL_MODE
        return (DWORD) HandleToULong(::PsGetCurrentThreadId());
#else // !LOCKS_KERNEL_MODE
        return ::GetCurrentThreadId();
#endif // !LOCKS_KERNEL_MODE
    }

    LOCK_FORCEINLINE static LONG _CurrentThreadId()
    {
        DWORD dwTid = _GetCurrentThreadId();
        // Thread ID 0 is used by the System Idle Process (Process ID 0).
        // We use a thread-id of zero to indicate that the lock is unowned.
        // NT uses +ve thread ids, Win9x uses -ve ids
        IRTLASSERT(dwTid != SL_UNOWNED
                   && ((dwTid <= SL_THREAD_MASK) || (dwTid > ~SL_THREAD_MASK)));
        return (LONG) (dwTid & SL_THREAD_MASK);
    }

    // Attempt to acquire the lock without blocking
    bool _TryLock();

    // Acquire the lock, recursively if need be
    void _Lock();

    // Release the lock
    void _Unlock();

    // Return true if the lock is owned by this thread
    bool _IsLocked() const
    {
        const LONG lTid = m_lTid;

        if (lTid == SL_UNOWNED)
            return false;

        bool fLocked = ((lTid ^ _GetCurrentThreadId()) << SL_OWNER_BITS) == 0;

        IRTLASSERT(!fLocked
                   || ((lTid & SL_OWNER_MASK) > 0
                       && (lTid & SL_THREAD_MASK) == _CurrentThreadId()));

        return fLocked;
    }

    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

public:

#ifndef LOCK_INSTRUMENTATION

    CSpinLock()
        : m_lTid(SL_UNOWNED)
    {}

#else // LOCK_INSTRUMENTATION

    CSpinLock(
        const TCHAR* ptszName)
        : m_lTid(SL_UNOWNED)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }

#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CSpinLock()
    {
        IRTLASSERT(m_lTid == SL_UNOWNED);
    }
#endif // IRTLDEBUG

    // Acquire an exclusive lock for writing.  Blocks until acquired.
    inline void WriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (_TryLock())
            return; // got the lock

        _Lock();
    }


    // Acquire a (possibly shared) lock for reading.  Blocks until acquired.
    inline void ReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_READLOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (_TryLock())
            return; // got the lock

        _Lock();
    }

    // See the description under CReaderWriterLock3::ReadOrWriteLock
    inline bool ReadOrWriteLock()
    {
        ReadLock();
        return true;
    }

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    inline bool TryWriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();
        else
            LOCKS_LEAVE_CRIT_REGION();

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    inline bool TryReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();
        else
            LOCKS_LEAVE_CRIT_REGION();

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    inline void WriteUnlock()
    {
        _Unlock();
        LOCKS_LEAVE_CRIT_REGION();
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    inline void ReadUnlock()
    {
        _Unlock();
        LOCKS_LEAVE_CRIT_REGION();
    }

    // Unlock the lock after a call to ReadOrWriteLock().
    inline void ReadOrWriteUnlock(bool)
    {
        ReadUnlock();
    }

    // Is the lock already locked for writing?
    bool IsWriteLocked() const
    {
        return _IsLocked();
    }

    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return _IsLocked();
    }

    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return !IsWriteLocked();
    }

    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return !IsReadLocked();
    }

    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    // Set the spin count for this lock.
    bool SetSpinCount(WORD dwSpins)     {return false;}

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*   ClassName()    {return _TEXT("CSpinLock");}
}; // CSpinLock




#ifndef LOCKS_KERNEL_MODE

//--------------------------------------------------------------------
// A Win32 CRITICAL_SECTION

class IRTL_DLLEXP CCritSec :
    public CLockBase<LOCK_CRITSEC, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_INDIVIDUAL_SPIN
                      >
{
private:
    CRITICAL_SECTION m_cs;

    LOCK_INSTRUMENTATION_DECL();

public:
    CCritSec()
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }

#ifdef LOCK_INSTRUMENTATION
    CCritSec(const char*)
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }
#endif // LOCK_INSTRUMENTATION

    ~CCritSec()         { DeleteCriticalSection(&m_cs); }

    void WriteLock()    { EnterCriticalSection(&m_cs); }
    void ReadLock()     { WriteLock(); }
    bool ReadOrWriteLock() { ReadLock(); return true; }
    bool TryWriteLock();
    bool TryReadLock()  { return TryWriteLock(); }
    void WriteUnlock()  { LeaveCriticalSection(&m_cs); }
    void ReadUnlock()   { WriteUnlock(); }
    void ReadOrWriteUnlock(bool) { ReadUnlock(); }

    bool IsWriteLocked() const      {return true;}  // TODO: fix this
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}  // TODO: fix this
    bool IsReadUnlocked() const     {return true;}  // TODO: fix this

    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }

    // Wrapper for ::SetCriticalSectionSpinCount which was introduced
    // in NT 4.0 sp3 and hence is not available on all platforms
    static DWORD SetSpinCount(LPCRITICAL_SECTION pcs,
                              DWORD dwSpinCount=LOCK_DEFAULT_SPINS);

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    bool SetSpinCount(WORD wSpins)
    {SetSpinCount(&m_cs, wSpins); return true;}

    WORD GetSpinCount() const       { return sm_wDefaultSpinCount; }    // TODO

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*   ClassName()  {return _TEXT("CCritSec");}
}; // CCritSec

#endif // !LOCKS_KERNEL_MODE



//--------------------------------------------------------------------
// CReaderWriterlock is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. Use CReaderWriterLock3.

class IRTL_DLLEXP CReaderWriterLock :
    public CLockBase<LOCK_READERWRITERLOCK, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile  LONG  m_nState;   // > 0 => that many readers
    volatile  LONG  m_cWaiting; // number of would-be writers

    LOCK_INSTRUMENTATION_DECL();

private:
    enum {
        SL_FREE = 0,
        SL_EXCLUSIVE = -1,
    };

    void _LockSpin(bool fWrite);
    void _WriteLockSpin() { _LockSpin(true); }
    void _ReadLockSpin()  { _LockSpin(false); }

    bool _CmpExch(LONG lNew, LONG lCurrent);
    bool _TryWriteLock();
    bool _TryReadLock();

public:
    CReaderWriterLock()
        : m_nState(SL_FREE),
          m_cWaiting(0)
    {
    }

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock(
        const TCHAR* ptszName)
        : m_nState(SL_FREE),
          m_cWaiting(0)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock()
    {
        IRTLASSERT(m_nState == SL_FREE  &&  m_cWaiting == 0);
    }
#endif // IRTLDEBUG

    void WriteLock();
    void ReadLock();

    bool TryWriteLock();
    bool TryReadLock();

    void WriteUnlock();
    void ReadUnlock();

    bool IsWriteLocked() const      {return m_nState == SL_EXCLUSIVE;}
    bool IsReadLocked() const       {return m_nState > SL_FREE;}
    bool IsWriteUnlocked() const    {return m_nState != SL_EXCLUSIVE;}
    bool IsReadUnlocked() const     {return m_nState <= SL_FREE;}

    void ConvertSharedToExclusive();
    void ConvertExclusiveToShared();

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    bool SetSpinCount(WORD wSpins)      {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*   ClassName()    {return _TEXT("CReaderWriterLock");}
}; // CReaderWriterLock



//--------------------------------------------------------------------
// CReaderWriterlock2 is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. The difference between this and CReaderWriterLock is
// that all the state is packed into a single LONG, instead of two LONGs.

class IRTL_DLLEXP CReaderWriterLock2 :
    public CLockBase<LOCK_READERWRITERLOCK2, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;

    // LoWord is state. ==0 => free; >0 => readers; ==0xFFFF => 1 writer.
    // HiWord is count of writers, W.
    //      If LoWord==0xFFFF => W-1 waiters, 1 writer;
    //      otherwise W waiters.
    enum {
        SL_FREE =         0x00000000,
        SL_STATE_MASK =   0x0000FFFF,
        SL_STATE_SHIFT =           0,
        SL_WAITING_MASK = 0xFFFF0000,   // waiting writers
        SL_WAITING_SHIFT =        16,
        SL_READER_INCR =  0x00000001,
        SL_READER_MASK =  0x00007FFF,
        SL_EXCLUSIVE =    0x0000FFFF,   // one writer
        SL_WRITER_INCR =  0x00010000,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + 1),
        SL_WRITERS_MASK = ~SL_READER_MASK,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    void _LockSpin(bool fWrite);
    void _WriteLockSpin();
    void _ReadLockSpin()  { _LockSpin(false); }


    bool _CmpExch(LONG lNew, LONG lCurrent);
    bool _TryWriteLock(LONG nIncr);
    bool _TryReadLock();

public:
    CReaderWriterLock2()
        : m_lRW(SL_FREE)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock2(
        const TCHAR* ptszName)
        : m_lRW(SL_FREE)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock2()
    {
        IRTLASSERT(m_lRW == SL_FREE);
    }
#endif // IRTLDEBUG

    inline void WriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryWriteLock(SL_WRITER_INCR))
            return;

        _WriteLockSpin();
    }

    inline void ReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_READLOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryReadLock())
            return;

        _ReadLockSpin();
    }

    inline bool TryWriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        if (_TryWriteLock(SL_WRITER_INCR))
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }
        else
        {
            LOCKS_LEAVE_CRIT_REGION();
            return false;
        }
    }

    inline bool TryReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }
        else
        {
            LOCKS_LEAVE_CRIT_REGION();
            return false;
        }
    }

    void WriteUnlock();
    void ReadUnlock();

    bool IsWriteLocked() const
    {return (m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE;}

    bool IsReadLocked() const
    {return (m_lRW & SL_READER_MASK) >= SL_READER_INCR ;}

    bool IsWriteUnlocked() const
    {return !IsWriteLocked();}

    bool IsReadUnlocked() const
    {return !IsReadLocked();}

    void ConvertSharedToExclusive();
    void ConvertExclusiveToShared();

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    bool SetSpinCount(WORD wSpins)      {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*   ClassName()    {return _TEXT("CReaderWriterLock2");}
}; // CReaderWriterLock2



//--------------------------------------------------------------------
// CReaderWriterLock3 is a multi-reader, single-writer spinlock due
// to NJain, which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. Much like CReaderWriterLock2, except that the WriteLock
// can be acquired recursively.

class IRTL_DLLEXP CReaderWriterLock3 :
    public CLockBase<LOCK_READERWRITERLOCK3, LOCK_MRSW,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;    // Reader-Writer state
    volatile LONG m_lTid;   // Owning Thread ID + recursion count

    // m_lRW:
    //  LoWord is state. ==0 => free;  >0 => readers;  ==0xFFFF => 1 writer
    //  HiWord is count of writers. If LoWord==0xFFFF => N-1 waiters, 1 writer;
    //      otherwise N waiters.
    // m_lTid:
    //  If readers, then 0; if a write lock, then thread id + recursion count

    enum {
        // m_lRW
        SL_FREE =         0x00000000,
        SL_STATE_MASK =   0x0000FFFF,
        SL_STATE_SHIFT =           0,
        SL_WAITING_MASK = 0xFFFF0000,   // waiting writers
        SL_WAITING_SHIFT =        16,
        SL_READER_INCR =  0x00000001,
        SL_READER_MASK =  0x00007FFF,
        SL_EXCLUSIVE =    0x0000FFFF,   // one writer
        SL_WRITER_INCR =  0x00010000,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + 1),
        SL_WRITERS_MASK = ~SL_READER_MASK,

        // m_lTid
        SL_UNOWNED      = 0,
        SL_THREAD_SHIFT = 0,
        SL_THREAD_BITS  = 28,
        SL_OWNER_SHIFT  = SL_THREAD_BITS,
        SL_OWNER_BITS   = 4,
        SL_THREAD_MASK  = ((1 << SL_THREAD_BITS) - 1) << SL_THREAD_SHIFT,
        SL_OWNER_INCR   = 1 << SL_THREAD_BITS,
        SL_OWNER_MASK   = ((1 << SL_OWNER_BITS) - 1) << SL_OWNER_SHIFT,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    enum SPIN_TYPE {
        SPIN_WRITE = 1,
        SPIN_READ,
        SPIN_READ_RECURSIVE,
    };

    void _LockSpin(SPIN_TYPE st);
    void _WriteLockSpin();
    void _ReadLockSpin(SPIN_TYPE st)  { _LockSpin(st); }

    bool _CmpExch(LONG lNew, LONG lCurrent);
    LONG _SetTid(LONG lNewTid);
    bool _TryWriteLock(LONG nIncr);
    bool _TryReadLock();
    bool _TryReadLockRecursive();

    // Get the current thread ID.  Assumes that it can fit into 28 bits,
    // which is fairly safe as NT recycles thread IDs and failing to fit into
    // 28 bits would mean that more than 268,435,456 threads were currently
    // active.  This is improbable in the extreme as NT runs out of
    // resources if there are more than a few thousands threads in
    // existence and the overhead of context swapping becomes unbearable.
    LOCK_FORCEINLINE static DWORD _GetCurrentThreadId()
    {
#ifdef LOCKS_KERNEL_MODE
        return (DWORD) HandleToULong(::PsGetCurrentThreadId());
#else // !LOCKS_KERNEL_MODE
        return ::GetCurrentThreadId();
#endif // !LOCKS_KERNEL_MODE
    }

    LOCK_FORCEINLINE static LONG _CurrentThreadId()
    {
        DWORD dwTid = _GetCurrentThreadId();
        // Thread ID 0 is used by the System Idle Process (Process ID 0).
        // We use a thread-id of zero to indicate that the lock is unowned.
        // NT uses +ve thread ids, Win9x uses -ve ids
        IRTLASSERT(dwTid != SL_UNOWNED
                  && ((dwTid <= SL_THREAD_MASK) || (dwTid > ~SL_THREAD_MASK)));
        return (LONG) (dwTid & SL_THREAD_MASK);
    }

public:
    CReaderWriterLock3()
        : m_lRW(SL_FREE),
          m_lTid(SL_UNOWNED)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock3(
        const TCHAR* ptszName)
        : m_lRW(SL_FREE),
          m_lTid(SL_UNOWNED)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock3()
    {
        IRTLASSERT(m_lRW == SL_FREE  &&  m_lTid == SL_UNOWNED);
    }
#endif // IRTLDEBUG

    inline void
    WriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryWriteLock(SL_WRITER_INCR))
            return;

        _WriteLockSpin();
    }

    inline void
    ReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_READLOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryReadLock())
            return;

        _ReadLockSpin(SPIN_READ);
    }

    // If already locked, recursively acquires another lock of the same
    // kind (read or write). Otherwise, just acquires a read lock.
    // Needed for cases like this.
    //      pTable->WriteLock();
    //      if (!pTable->FindKey(&SomeKey))
    //          InsertRecord(&Whatever);
    //      pTable->WriteUnlock();
    // where FindKey looks like
    //  Table::FindKey(pKey) {
    //      ReadOrWriteLock();
    //      // find pKey if present in table
    //      ReadOrWriteUnlock();
    //  }
    // and InsertRecord looks like
    //  Table::InsertRecord(pRecord) {
    //      WriteLock();
    //      // insert pRecord into table
    //      WriteUnlock();
    //  }
    // If FindKey called ReadLock while the thread already had done a
    // WriteLock, the thread would deadlock.

    bool ReadOrWriteLock();

    inline bool
    TryWriteLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        if (_TryWriteLock(SL_WRITER_INCR))
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }
        else
        {
            LOCKS_LEAVE_CRIT_REGION();
            return false;
        }
    }

    inline bool
    TryReadLock()
    {
        LOCKS_ENTER_CRIT_REGION();

        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }
        else
        {
            LOCKS_LEAVE_CRIT_REGION();
            return false;
        }
    }

    void WriteUnlock();
    void ReadUnlock();
    void ReadOrWriteUnlock(bool fIsReadLocked);

    // Does current thread hold a write lock?
    bool
    IsWriteLocked() const
    {
        const LONG lTid = m_lTid;

        if (lTid == SL_UNOWNED)
            return false;

        bool fLocked = ((lTid ^ _GetCurrentThreadId()) << SL_OWNER_BITS) == 0;

        IRTLASSERT(!fLocked
                   || ((m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE
                       && (lTid & SL_THREAD_MASK) == _CurrentThreadId()
                       && (lTid & SL_OWNER_MASK) > 0));
        return fLocked;
    }

    bool
    IsReadLocked() const
    { return (m_lRW & SL_READER_MASK) >= SL_READER_INCR; }

    bool
    IsWriteUnlocked() const
    { return !IsWriteLocked(); }

    bool
    IsReadUnlocked() const
    { return !IsReadLocked(); }

    // Note: if there's more than one reader, then there's a window where
    // another thread can acquire and release a writelock before this routine
    // returns.
    void
    ConvertSharedToExclusive();

    // There is no such window when converting from a writelock to a readlock
    void
    ConvertExclusiveToShared();

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    bool
    SetSpinCount(WORD wSpins)
    {return false;}

    WORD
    GetSpinCount() const
    {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    static const TCHAR*
    ClassName()
    {return _TEXT("CReaderWriterLock3");}

}; // CReaderWriterLock3

#endif // __LOCKS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\inc\lkrhash.h ===
/*++

   Copyright    (c) 1998-2001    Microsoft Corporation

   Module  Name :
       LKRhash.h

   Abstract:
       Declares LKRhash: a fast, scalable, cache- and MP-friendly hash table

   Author:
       Paul (Per-Ake) Larson, PALarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       10/01/1998 - Change name from LKhash to LKRhash
       10/2000 - Port to kernel mode

--*/


#ifndef __LKRHASH_H__
#define __LKRHASH_H__

#ifndef __LKR_HASH_H__
// external definitions
# include <LKR-hash.h>
#endif //  !__LKR_HASH_H__

#ifndef __IRTLDBG_H__
# include <IrtlDbg.h>
#endif // !__IRTLDBG_H__

#ifndef LKR_NO_GLOBAL_LIST
# ifndef __LSTENTRY_H__
#  include <LstEntry.h>
# endif // !__LSTENTRY_H__
#else  // LKR_NO_GLOBAL_LIST
# ifndef __LOCKS_H__
#  include <Locks.h>
# endif // !__LOCKS_H__
#endif // LKR_NO_GLOBAL_LIST

#ifndef __HASHFN_H__
# include <HashFn.h>
#endif // !__HASHFN_H__


// Disable old-style deprecated iterators, by default
#ifndef LKR_DEPRECATED_ITERATORS
# define LKR_NO_DEPRECATED_ITERATORS
#endif // !LKR_DEPRECATED_ITERATORS

#ifndef LKR_NO_DEPRECATED_ITERATORS
# undef  LKR_DEPRECATED_ITERATORS
# define LKR_DEPRECATED_ITERATORS 1
#endif // !LKR_NO_DEPRECATED_ITERATORS

#undef  LKR_COUNTDOWN

// #define __LKRHASH_NO_NAMESPACE__
// #define __HASHFN_NO_NAMESPACE__

// #define LKR_TABLE_LOCK  CReaderWriterLock3
// #define LKR_BUCKET_LOCK CSmallSpinLock

#ifndef LKR_TABLE_LOCK
# if defined(LKR_EXPOSED_TABLE_LOCK) || defined(LKR_DEPRECATED_ITERATORS)
   // need recursive writelocks
#  define LKR_TABLE_LOCK  CReaderWriterLock3
# else
   // use non-recursive writelocks
#  define LKR_TABLE_LOCK  CReaderWriterLock2
# endif
#endif // !LKR_TABLE_LOCK

#ifndef LKR_BUCKET_LOCK
# ifdef LKR_DEPRECATED_ITERATORS
#  define LKR_BUCKET_LOCK CReaderWriterLock3
# else // !LKR_DEPRECATED_ITERATORS
#  define LKR_BUCKET_LOCK CSmallSpinLock
# endif // !LKR_DEPRECATED_ITERATORS
#endif // !LKR_BUCKET_LOCK



//=====================================================================
//  The class CLKRLinearHashTable defined in this file provides dynamic hash
//  tables, i.e. tables that grow and shrink dynamically with
//  the number of records in the table.
//  The basic method used is linear hashing, as explained in:
//
//    P.-A. Larson, Dynamic Hash Tables, Comm. of the ACM, 31, 4 (1988)
//
//  This version has the following characteristics:
//  - It is thread-safe and uses spin locks for synchronization.
//  - It was designed to support very high rates of concurrent
//    operations (inserts/deletes/lookups). It achieves this by
//    (a) partitioning a CLKRHashTable into a collection of
//        CLKRLinearHashTables to reduce contention on the global table lock.
//    (b) minimizing the hold time on a table lock, preferring to lock
//        down a bucket chain instead.
//  - The design is L1 cache-conscious. See CNodeClump.
//  - It is designed for sets varying in size from a dozen
//    elements to several million.
//
//  Main classes:
//    CLKRLinearHashTable: thread-safe linear hash table
//    CLKRHashTable:       collection of CLKRLinearHashTables
//    CTypedHashTable:     typesafe wrapper for CLKRHashTable
//
//
//  Paul Larson, palarson@microsoft.com, July 1997
//   Original implementation with input from Murali R. Krishnan,
//   muralik@microsoft.com.
//
//  George V. Reilly, georgere@microsoft.com, Dec 1997-Jan 1998
//   Massive cleanup and rewrite. Added templates.
//=====================================================================


// 1) Linear Hashing
// ------------------
//
// Linear hash tables grow and shrink dynamically with the number of
// records in the table. The growth or shrinkage is smooth: logically,
// one bucket at a time but physically in larger increments
// (64 buckets). An insertion (deletion) may cause an expansion
// (contraction) of the table. This causes relocation of a small number
// of records (at most one bucket worth). All operations (insert,
// delete, lookup) take constant expected time, regardless of the
// current size or the growth of the table.
//
// 2) LKR extensions to Linear hash table
// --------------------------------------
//
// Larson-Krishnan-Reilly extensions to Linear hash tables for multiprocessor
// scalability and improved cache performance.
//
// Traditional implementations of linear hash tables use one global lock
// to prevent interference between concurrent operations
// (insert/delete/lookup) on the table. The single lock easily becomes
// the bottleneck in SMP scenarios when multiple threads are used.
//
// Traditionally, a (hash) bucket is implemented as a chain of
// single-item nodes. Every operation results in chasing down a chain
// looking for an item. However, pointer chasing is very slow on modern
// systems because almost every jump results in a cache miss. L2 (or L3)
// cache misses are very expensive in missed CPU cycles and the cost is
// increasing (going to 100s of cycles in the future).
//
// LKR extensions offer
//    1) Partitioning (by hashing) of records among multiple subtables.
//       Each subtable has locks but there is no global lock. Each
//       subtable receives a much lower rate of operations, resulting in
//       fewer conflicts.
//
//    2) Improved cache locality by grouping keys and their hash values
//       into contigous chunks that fit exactly into one (or a few)
//       cache lines.
//
// Specifically the implementation that exists here achieves this using
// the following techniques.
//
// Class CLKRHashTable is the top-level data structure that dynamically
// creates m_cSubTables linear hash tables. The CLKRLinearHashTables act as
// the subtables to which items and accesses are fanned out. A good
// hash function multiplexes requests uniformly to various subtables,
// thus minimizing traffic to any single subtable. The implemenation
// uses a home-grown version of bounded spinlocks, that is, a thread
// does not spin on a lock indefinitely, instead yielding after a
// predetermined number of loops.
//
// Each CLKRLinearHashTable consists of a CDirEntry pointing to segments
// each holding m_dwSegSize CBuckets. Each CBucket in turn consists of a
// chain of CNodeClumps. Each CNodeClump contains a group of
// NODES_PER_CLUMP hash values (aka hash keys or signatures) and
// pointers to the associated data items. Keeping the signatures
// together increases the cache locality in scans for lookup.
//
// Traditionally, people store a link-list element right inside the
// object that is hashed and use this link-list for the chaining of data
// blocks. However, keeping just the pointers to the data object and
// not chaining through them limits the need for bringing in the data
// object to the cache. We need to access the data object only if the
// hash values match. This limits the cache-thrashing behaviour
// exhibited by conventional implementations. It has the additional
// benefit that the objects themselves do not need to be modified
// in order to be collected in the hash table (i.e., it's non-invasive).



#ifdef LKR_STL_ITERATORS

// needed for std::forward_iterator_tag, etc
# include <utility>

// The iterators have very verbose tracing. Don't want it on all the time
// in debug builds.
# if defined(IRTLDEBUG)  &&  (LKR_STL_ITERATORS >= 2)
#  define LKR_ITER_TRACE  IrtlTrace
# else // !defined(IRTLDEBUG)  ||  LKR_STL_ITERATORS < 2
#  define LKR_ITER_TRACE  1 ? (void)0 : IrtlTrace
# endif // !defined(IRTLDEBUG)  ||  LKR_STL_ITERATORS < 2

#endif // LKR_STL_ITERATORS



//--------------------------------------------------------------------
// Default values for the hashtable constructors
enum {
#ifdef _WIN64
    LK_DFLT_MAXLOAD=     4, // 64-byte nodes => NODES_PER_CLUMP = 4
#else
    LK_DFLT_MAXLOAD=     7, // Default upperbound on average chain length.
#endif
    LK_DFLT_INITSIZE=LK_MEDIUM_TABLESIZE, // Default initial size of hash table
    LK_DFLT_NUM_SUBTBLS= 0, // Use a heuristic to choose #subtables
};


/*--------------------------------------------------------------------
 * Undocumented additional creation flag parameters to LKR_CreateTable
 */

enum {
    LK_CREATE_NON_PAGED_ALLOCS = 0x1000, // Use paged or NP pool in kernel
};



//--------------------------------------------------------------------
// Custom memory allocators (optional)
//--------------------------------------------------------------------


#if !defined(LKR_NO_ALLOCATORS) && !defined(LKRHASH_KERNEL_MODE)
// # define LKRHASH_ACACHE 1
// # define LKRHASH_ROCKALL_FAST 1
#endif // !LKR_NO_ALLOCATORS && !LKRHASH_KERNEL_MODE


#if defined(LKRHASH_ACACHE)

# include <acache.hxx>

class ACache : public ALLOC_CACHE_HANDLER
{
private:
    SIZE_T m_cb;

public:
    ACache(IN LPCSTR pszName, IN const ALLOC_CACHE_CONFIGURATION* pacConfig)
        : ALLOC_CACHE_HANDLER(pszName, pacConfig),
          m_cb(m_acConfig.cbSize)
    {}

    SIZE_T ByteSize() const
    {
        return m_cb;
    }

    static const TCHAR*  ClassName()  {return _TEXT("ACache");}
}; // class ACache

  typedef ACache CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N, Tag)                       \
    const ALLOC_CACHE_CONFIGURATION acc = { 1, N, sizeof(C) };  \
    C::sm_palloc = new ACache("LKRhash:" #C, &acc);

#elif defined(LKRHASH_ROCKALL_FAST)

# include <FastHeap.hpp>

class FastHeap : public FAST_HEAP
{
private:
    SIZE_T m_cb;

public:
    FastHeap(SIZE_T cb)
        : m_cb(cb)
    {}

    LPVOID Alloc()
    { return New(m_cb, NULL, false); }

    BOOL   Free(LPVOID pvMem)
    { return Delete(pvMem); }

    SIZE_T ByteSize() const
    {
        return m_cb;
    }

    static const TCHAR*  ClassName()  {return _TEXT("FastHeap");}
}; // class FastHeap

  typedef FastHeap CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N, Tag) \
    C::sm_palloc = new FastHeap(sizeof(C))

#endif // LKRHASH_ROCKALL_FAST



#ifdef LKRHASH_ALLOCATOR_NEW

// placed inline in the declaration of class C
# define LKRHASH_ALLOCATOR_DEFINITIONS(C)                       \
    protected:                                                  \
        friend class CLKRLinearHashTable;                       \
        friend BOOL LKR_Initialize();                           \
        friend void LKR_Terminate();                            \
    public:                                                     \
        static CLKRhashAllocator* sm_palloc;                    \
        static void*  operator new(size_t s)                    \
        {                                                       \
            IRTLASSERT(s == sizeof(C));                         \
            IRTLASSERT(sm_palloc != NULL);                      \
            return sm_palloc->Alloc();                          \
        }                                                       \
        static void   operator delete(void* pv)                 \
        {                                                       \
            IRTLASSERT(pv != NULL);                             \
            IRTLASSERT(sm_palloc != NULL);                      \
            sm_palloc->Free(pv);                                \
        }


// used in LKRHashTableInit()
# define LKRHASH_ALLOCATOR_INIT(C, N, Tag, f)                   \
    {                                                           \
        if (f)                                                  \
        {                                                       \
            IRTLASSERT(C::sm_palloc == NULL);                   \
            LKRHASH_ALLOCATOR_NEW(C, N, Tag);                   \
            f = (C::sm_palloc != NULL);                         \
        }                                                       \
    }


// used in LKRHashTableUninit()
# define LKRHASH_ALLOCATOR_UNINIT(C)                            \
    {                                                           \
        if (C::sm_palloc != NULL)                               \
        {                                                       \
            delete C::sm_palloc;                                \
            C::sm_palloc = NULL;                                \
        }                                                       \
    }


#else // !LKRHASH_ALLOCATOR_NEW

# define LKRHASH_ALLOCATOR_DEFINITIONS(C)
# define LKRHASH_ALLOCATOR_INIT(C, N, Tag, f)
# define LKRHASH_ALLOCATOR_UNINIT(C)

class CLKRhashAllocator
{
public:
    static const TCHAR*  ClassName()  {return _TEXT("global new");}
};

#endif // !LKRHASH_ALLOCATOR_NEW



#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__


//--------------------------------------------------------------------
// forward declarations

class IRTL_DLLEXP CLKRLinearHashTable;

class IRTL_DLLEXP CLKRHashTable;

template <class _Der, class _Rcd, class _Ky, class _HT
#ifdef LKR_DEPRECATED_ITERATORS
          , class _Iter
#endif // LKR_DEPRECATED_ITERATORS
          >
class CTypedHashTable;

class CNodeClump;
class CBucket;
class CSegment;
class CDirEntry;
class IRTL_DLLEXP CLKRHashTableStats;


//--------------------------------------------------------------------
// Statistical information returned by GetStatistics
//--------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION

class IRTL_DLLEXP CAveragedLockStats : public CLockStatistics
{
public:
    int m_nItems;

    CAveragedLockStats();
}; // class CAveragedLockStats

#endif // LOCK_INSTRUMENTATION


#ifndef LKRHASH_KERNEL_MODE

class IRTL_DLLEXP CLKRHashTableStats
{
public:
    int      RecordCount;           // number of records in the table
    int      TableSize;             // table size in number of slots
    int      DirectorySize;         // number of entries in directory
    int      LongestChain;          // longest hash chain in the table
    int      EmptySlots;            // number of unused hash slots
    double   SplitFactor;           // fraction of buckets split
    double   AvgSearchLength;       // average length of a successful search
    double   ExpSearchLength;       // theoretically expected length
    double   AvgUSearchLength;      // average length of an unsuccessful search
    double   ExpUSearchLength;      // theoretically expected length
    int      NodeClumpSize;         // number of slots in a node clump
    int      CBucketSize;           // sizeof(CBucket)

#ifdef LOCK_INSTRUMENTATION
    CAveragedLockStats      m_alsTable;  // stats for table lock
    CAveragedLockStats      m_alsBucketsAvg; // avg of stats for bucket locks
    CGlobalLockStatistics   m_gls;      // global statistics for all locks
#endif // LOCK_INSTRUMENTATION

    enum {
        MAX_BUCKETS = 40,
    };

    // histogram of bucket lengths
    LONG    m_aBucketLenHistogram[MAX_BUCKETS];

    CLKRHashTableStats();

    static const LONG*
    BucketSizes();

    static LONG
    BucketSize(
        LONG nBucketIndex);

    static LONG
    BucketIndex(
        LONG nBucketLength);
}; // class CLKRHashTableStats

#endif // !LKRHASH_KERNEL_MODE



//--------------------------------------------------------------------
// Global table lock code. This is only used to measure how much of a
// slowdown having a global lock on the CLKRHashTable causes. It is
// *never* used in production code.


// #define LKRHASH_GLOBAL_LOCK CCritSec

#ifdef LKRHASH_GLOBAL_LOCK

# define LKRHASH_GLOBAL_LOCK_DECLARATIONS()         \
    typedef LKRHASH_GLOBAL_LOCK GlobalLock;  \
    mutable GlobalLock m_lkGlobal;

# define LKRHASH_GLOBAL_READ_LOCK()     m_lkGlobal.ReadLock()
# define LKRHASH_GLOBAL_WRITE_LOCK()    m_lkGlobal.WriteLock()
# define LKRHASH_GLOBAL_READ_UNLOCK()   m_lkGlobal.ReadUnlock()
# define LKRHASH_GLOBAL_WRITE_UNLOCK()  m_lkGlobal.WriteUnlock()

#else // !LKRHASH_GLOBAL_LOCK

# define LKRHASH_GLOBAL_LOCK_DECLARATIONS()

// These ones will be optimized away by the compiler
# define LKRHASH_GLOBAL_READ_LOCK()     ((void)0)
# define LKRHASH_GLOBAL_WRITE_LOCK()    ((void)0)
# define LKRHASH_GLOBAL_READ_UNLOCK()   ((void)0)
# define LKRHASH_GLOBAL_WRITE_UNLOCK()  ((void)0)

#endif // !LKRHASH_GLOBAL_LOCK



// Class for nodes on a bucket chain. Instead of a node containing
// one (signature, record-pointer, next-tuple-pointer) tuple, it
// contains _N_ such tuples. (N-1 next-tuple-pointers are omitted.)
// This improves locality of reference greatly; i.e., it's L1
// cache-friendly. It also reduces memory fragmentation and memory
// allocator overhead. It does complicate the chain traversal code
// slightly, admittedly.
//
// This theory is beautiful. In practice, however, CNodeClumps
// are *not* perfectly aligned on 32-byte boundaries by the memory
// allocators. Experimental results indicate that we get a 2-3%
// speed improvement by using 32-byte-aligned blocks, but this must
// be considered against the average of 16 bytes wasted per block.

class CNodeClump
{
public:
    // Record slots per chunk - set so a chunk matches (one or two)
    // cache lines. 3 ==> 32 bytes, 7 ==> 64 bytes, on 32-bit system.
    // Note: the default max load factor is 7, which implies that
    // there will seldom be more than one node clump in a chain.
    enum {
#if defined(LOCK_INSTRUMENTATION)
        BUCKET_BYTE_SIZE = 96,
#else
        BUCKET_BYTE_SIZE = 64,
#endif
        BUCKET_OVERHEAD  = sizeof(LKR_BUCKET_LOCK) + sizeof(CNodeClump*),
        NODE_SIZE        = sizeof(const void*) + sizeof(DWORD),
        NODES_PER_CLUMP  = (BUCKET_BYTE_SIZE - BUCKET_OVERHEAD) / NODE_SIZE
    };

    enum {
        // See if countdown loops are faster than countup loops for
        // traversing a CNodeClump. In practice, countup loops are faster.
#ifndef LKR_COUNTDOWN
        NODE_BEGIN = 0,
        NODE_END   = NODES_PER_CLUMP,
        NODE_STEP  = +1,
        // for (int x = 0;  x < NODES_PER_CLUMP;  ++x) ...
#else // LKR_COUNTDOWN
        NODE_BEGIN = NODES_PER_CLUMP-1,
        NODE_END   = -1,
        NODE_STEP  = -1,
        // for (int x = NODES_PER_CLUMP;  --x >= 0;  ) ...
#endif // LKR_COUNTDOWN
    };

    enum {
#ifndef __HASHFN_NO_NAMESPACE__
        HASH_INVALID_SIGNATURE = HashFn::HASH_INVALID_SIGNATURE,
#else // !__HASHFN_NO_NAMESPACE__
        HASH_INVALID_SIGNATURE = ::HASH_INVALID_SIGNATURE,
#endif // !__HASHFN_NO_NAMESPACE__
    };

    DWORD m_dwKeySigs[NODES_PER_CLUMP];       // hash values computed from keys
    CNodeClump*  m_pncNext;                   // next node clump on the chain
    const void*  m_pvNode[NODES_PER_CLUMP];   // pointers to records

    CNodeClump()
    {
        Clear();
    }

    void
    Clear()
    {
        m_pncNext = NULL;  // no dangling pointers
        for (int i = NODES_PER_CLUMP;  --i >= 0; )
        {
            m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
            m_pvNode[i] = NULL;
        }
    }

    bool
    InvalidSignature(
        int i) const
    {
        IRTLASSERT(0 <= i  &&  i < NODES_PER_CLUMP);
        return (m_dwKeySigs[i] == HASH_INVALID_SIGNATURE);
    }

    bool
    IsEmptyNode(
        int i) const
    {
        IRTLASSERT(0 <= i  &&  i < NODES_PER_CLUMP);
        return (m_pvNode[i] == NULL);
    }

    bool
    IsEmptyAndInvalid(
        int i) const
    {
        return IsEmptyNode(i) && InvalidSignature(i);
    }

    bool
    IsEmptySlot(
        int i) const
    {
        return InvalidSignature(i);
    }

    bool
    IsLastClump() const
    {
        return (m_pncNext == NULL);
    }

#ifdef IRTLDEBUG
    // Don't want overhead of calls to dtor in retail build
    ~CNodeClump()
    {
        IRTLASSERT(IsLastClump());  // no dangling pointers
        for (int i = NODES_PER_CLUMP;  --i >= 0;  )
            IRTLASSERT(InvalidSignature(i)  &&  IsEmptyNode(i));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CNodeClump);
}; // class CNodeClump



#ifdef LKR_STL_ITERATORS

class IRTL_DLLEXP CLKRLinearHashTable_Iterator;
class IRTL_DLLEXP CLKRHashTable_Iterator;


class IRTL_DLLEXP CLKRLinearHashTable_Iterator
{
    friend class CLKRLinearHashTable;
    friend class CLKRHashTable;
    friend class CLKRHashTable_Iterator;

protected:
    CLKRLinearHashTable* m_plht;        // which linear hash table?
    CNodeClump*          m_pnc;         // a CNodeClump in bucket
    DWORD                m_dwBucketAddr;// bucket index
    short                m_iNode;       // offset within m_pnc

    enum {
        NODES_PER_CLUMP = CNodeClump::NODES_PER_CLUMP,
        NODE_BEGIN      = CNodeClump::NODE_BEGIN,
        NODE_END        = CNodeClump::NODE_END,
        NODE_STEP       = CNodeClump::NODE_STEP,
    };

    CLKRLinearHashTable_Iterator(
        CLKRLinearHashTable* plht,
        CNodeClump*          pnc,
        DWORD                dwBucketAddr,
        short                iNode)
        : m_plht(plht),
          m_pnc(pnc),
          m_dwBucketAddr(dwBucketAddr),
          m_iNode(iNode)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::prot ctor, this=%p, plht=%p, ")
                       _TEXT("pnc=%p, ba=%d, in=%d\n"),
                       this, plht, pnc, dwBucketAddr, iNode);
    }

    inline void _AddRef(
        LK_ADDREF_REASON lkar) const;

    bool _Increment(
        bool fDecrementOldValue=true);

public:
    CLKRLinearHashTable_Iterator()
        : m_plht(NULL),
          m_pnc(NULL),
          m_dwBucketAddr(0),
          m_iNode(0)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::default ctor, this=%p\n"), this);
    }

    CLKRLinearHashTable_Iterator(
        const CLKRLinearHashTable_Iterator& rhs)
        : m_plht(rhs.m_plht),
          m_pnc(rhs.m_pnc),
          m_dwBucketAddr(rhs.m_dwBucketAddr),
          m_iNode(rhs.m_iNode)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::copy ctor, this=%p, rhs=%p\n"),
                       this, &rhs);
        _AddRef(LKAR_ITER_COPY_CTOR);
    }

    CLKRLinearHashTable_Iterator& operator=(
        const CLKRLinearHashTable_Iterator& rhs)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator=, this=%p, rhs=%p\n"),
                       this, &rhs);
        rhs._AddRef(LKAR_ITER_ASSIGN_ACQUIRE);
        this->_AddRef(LKAR_ITER_ASSIGN_RELEASE);

        m_plht =         rhs.m_plht;
        m_pnc =          rhs.m_pnc;
        m_dwBucketAddr = rhs.m_dwBucketAddr;
        m_iNode =        rhs.m_iNode;

        return *this;
    }

    ~CLKRLinearHashTable_Iterator()
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::dtor, this=%p, plht=%p\n"),
                       this, m_plht);
        _AddRef(LKAR_ITER_DTOR);
    }

    bool Increment()
    {
        return IsValid()  ? _Increment()  :  false;

    }

    bool IsValid() const
    {
        bool fValid = (m_plht != NULL  &&  m_pnc != NULL
                       &&  0 <= m_iNode  &&  m_iNode < NODES_PER_CLUMP);
        if (fValid)
            fValid = (m_pnc->m_pvNode[m_iNode] != NULL);
        IRTLASSERT(fValid);
        return fValid;
    }

    const void* Record() const
    {
        IRTLASSERT(IsValid());
        return m_pnc->m_pvNode[m_iNode];
    }

    inline const DWORD_PTR Key() const;

    bool operator==(
        const CLKRLinearHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator==, this=%p, rhs=%p\n"),
                       this, &rhs);
        // m_pnc and m_iNode uniquely identify an iterator
        bool fEQ = ((m_pnc == rhs.m_pnc)    // most unique field
                    &&  (m_iNode == rhs.m_iNode));
        IRTLASSERT(!fEQ || ((m_plht == rhs.m_plht)
                            &&  (m_dwBucketAddr == rhs.m_dwBucketAddr)));
        return fEQ;
    }

    bool operator!=(
        const CLKRLinearHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator!=, this=%p, rhs=%p\n"),
                       this, &rhs);
        bool fNE = ((m_pnc != rhs.m_pnc)
                    ||  (m_iNode != rhs.m_iNode));
        //// IRTLASSERT(fNE == !this->operator==(rhs));
        return fNE;
    }
}; // class CLKRLinearHashTable_Iterator



class IRTL_DLLEXP CLKRHashTable_Iterator
{
    friend class CLKRHashTable;

protected:
    // order important to minimize size
    CLKRHashTable*                  m_pht;      // which hash table?
    CLKRLinearHashTable_Iterator    m_subiter;  // iterator into subtable
    short                           m_ist;      // index of subtable

    CLKRHashTable_Iterator(
        CLKRHashTable* pht,
        short          ist)
        : m_pht(pht),
          m_subiter(CLKRLinearHashTable_Iterator()), // zero
          m_ist(ist)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::prot ctor, this=%p, pht=%p, ist=%d\n"),
                       this, pht, ist);
    }

    bool _Increment(
        bool fDecrementOldValue=true);

public:
    CLKRHashTable_Iterator()
        : m_pht(NULL),
          m_subiter(CLKRLinearHashTable_Iterator()), // zero
          m_ist(0)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::default ctor, this=%p\n"), this);
    }

#ifdef IRTLDEBUG
    // Compiler does a perfectly adequate job of synthesizing these
    // methods.
    CLKRHashTable_Iterator(
        const CLKRHashTable_Iterator& rhs)
        : m_pht(rhs.m_pht),
          m_subiter(rhs.m_subiter),
          m_ist(rhs.m_ist)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::copy ctor, this=%p, rhs=%p\n"),
                       this, &rhs);
    }

    CLKRHashTable_Iterator& operator=(
        const CLKRHashTable_Iterator& rhs)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator=, this=%p, rhs=%p\n"),
                       this, &rhs);

        m_ist     = rhs.m_ist;
        m_subiter = rhs.m_subiter;
        m_pht     = rhs.m_pht;

        return *this;
    }

    ~CLKRHashTable_Iterator()
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::dtor, this=%p, pht=%p\n"), this, m_pht);
    }
#endif

    bool Increment()
    {
        return IsValid()  ? _Increment()  :  false;

    }

    bool IsValid() const
    {

        bool fValid = (m_pht != NULL  &&  m_ist >= 0);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_plht != NULL);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_pnc != NULL);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (0 <= m_subiter.m_iNode);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_iNode < CNodeClump::NODES_PER_CLUMP);
        IRTLASSERT(fValid);

        if (fValid)
            fValid = (m_subiter.m_pnc->m_pvNode[m_subiter.m_iNode] != NULL);
        IRTLASSERT(fValid);
        return fValid;
    }

    const void* Record() const
    {
        IRTLASSERT(IsValid());
        return m_subiter.Record();
    }

    const DWORD_PTR Key() const
    {
        IRTLASSERT(IsValid());
        return m_subiter.Key();
    }

    bool operator==(
        const CLKRHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator==, this=%p, rhs=%p\n"),
                       this, &rhs);
        // m_pnc and m_iNode uniquely identify an iterator
        bool fEQ = ((m_subiter.m_pnc
                            == rhs.m_subiter.m_pnc)     // most unique field
                    &&  (m_subiter.m_iNode == rhs.m_subiter.m_iNode));
        IRTLASSERT(!fEQ
                   || ((m_ist == rhs.m_ist)
                       &&  (m_pht == rhs.m_pht)
                       &&  (m_subiter.m_plht == rhs.m_subiter.m_plht)
                       &&  (m_subiter.m_dwBucketAddr
                                == rhs.m_subiter.m_dwBucketAddr)));
        return fEQ;
    }

    bool operator!=(
        const CLKRHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator!=, this=%p, rhs=%p\n"),
                       this, &rhs);
        bool fNE = ((m_subiter.m_pnc != rhs.m_subiter.m_pnc)
                    ||  (m_subiter.m_iNode != rhs.m_subiter.m_iNode));
        //// IRTLASSERT(fNE == !this->operator==(rhs));
        return fNE;
    }
}; // class CLKRHashTable_Iterator

#endif // LKR_STL_ITERATORS



//--------------------------------------------------------------------
// CLKRLinearHashTable
//
// A thread-safe linear hash table.
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKRLinearHashTable
{
public:
    typedef LKR_TABLE_LOCK  TableLock;
    typedef LKR_BUCKET_LOCK BucketLock;

#ifdef LKR_DEPRECATED_ITERATORS
    class CIterator;
    friend class CLKRLinearHashTable::CIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_STL_ITERATORS
    friend class CLKRLinearHashTable_Iterator;
    typedef CLKRLinearHashTable_Iterator Iterator;
#endif // LKR_STL_ITERATORS

private:
    friend class CNodeClump;
    friend class CLKRHashTable;

    friend BOOL LKR_Initialize();
    friend void LKR_Terminate();

#ifdef LKRHASH_INSTRUMENTATION
    // TODO
#endif // LKRHASH_INSTRUMENTATION


public:

    // aliases for convenience
    enum {
        NODES_PER_CLUMP        = CNodeClump::NODES_PER_CLUMP,
        MIN_DIRSIZE            = 1<<3,  // CDirEntry::MIN_DIRSIZE
        MAX_DIRSIZE            = 1<<20, // CDirEntry::MAX_DIRSIZE
        NAME_SIZE              = 16,    // includes trailing '\0'
        NODE_BEGIN             = CNodeClump::NODE_BEGIN,
        NODE_END               = CNodeClump::NODE_END,
        NODE_STEP              = CNodeClump::NODE_STEP,
        HASH_INVALID_SIGNATURE = CNodeClump::HASH_INVALID_SIGNATURE,
    };


private:

    //
    // Miscellaneous helper functions
    //

    // Convert a hash signature to a bucket address
    inline DWORD _BucketAddress(DWORD dwSignature) const;

    // See the Linear Hashing paper
    static DWORD _H0(DWORD dwSignature, DWORD dwBktAddrMask);

    DWORD        _H0(DWORD dwSignature) const;

    // See the Linear Hashing paper. Preserves one bit more than _H0.
    static DWORD _H1(DWORD dwSignature, DWORD dwBktAddrMask);

    DWORD        _H1(DWORD dwSignature) const;

    // In which segment within the directory does the bucketaddress lie?
    // (Return type must be lvalue so that it can be assigned to.)
    CSegment*&   _Segment(DWORD dwBucketAddr) const;

    // Offset within the segment of the bucketaddress
    DWORD        _SegIndex(DWORD dwBucketAddr) const;

    // Convert a bucketaddress to a CBucket*
    inline CBucket* _Bucket(DWORD dwBucketAddr) const;

    // Extract the key from a record
    const DWORD_PTR  _ExtractKey(const void* pvRecord) const;

    // Hash the key
    DWORD     _CalcKeyHash(const DWORD_PTR pnKey) const;

    // Compare two keys for equality
    BOOL         _EqualKeys(const DWORD_PTR pnKey1,
                            const DWORD_PTR pnKey2) const;

    // AddRef or Release a record.
    void         _AddRefRecord(const void* pvRecord,
                               LK_ADDREF_REASON lkar) const;

    // Find a bucket, given its signature.
    CBucket*     _FindBucket(DWORD dwSignature,
                             bool fLockForWrite) const;

    // Used by _FindKey so that the thread won't deadlock if the user has
    // already explicitly called table->WriteLock().
    bool _ReadOrWriteLock() const;

    void _ReadOrWriteUnlock(bool fReadLocked) const;

    // Memory allocation wrappers to allow us to simulate allocation
    // failures during testing
    static CDirEntry* const
    _AllocateSegmentDirectory(
        size_t n);

    bool
    _FreeSegmentDirectory();

    static CNodeClump* const
    _AllocateNodeClump();

    static bool
    _FreeNodeClump(
        CNodeClump* pnc);

    CSegment* const
    _AllocateSegment() const;

    bool
    _FreeSegment(
        CSegment* pseg) const;

    LK_RETCODE
    _InitializeSegmentDirectory();

#ifdef LOCK_INSTRUMENTATION
    static LONG sm_cTables;

    static const TCHAR*
    _LockName()
    {
        LONG l = ++sm_cTables;
        // possible race condition but we don't care, as this is never
        // used in production code
        static TCHAR s_tszName[CLockStatistics::L_NAMELEN];
        wsprintf(s_tszName, _TEXT("LH%05x"), 0xFFFFF & l);
        return s_tszName;
    }

    // Statistics for the table lock
    CLockStatistics _LockStats() const
    { return m_Lock.Statistics(); }
#endif // LOCK_INSTRUMENTATION

private:

    // Fields are ordered so as to minimize number of cache lines touched

    DWORD         m_dwSignature;    // debugging: id & corruption check
    CHAR          m_szName[NAME_SIZE];  // an identifier for debugging
    mutable LK_RETCODE m_lkrcState; // Internal state of table
    mutable TableLock  m_Lock;      // Lock on entire linear hash table

    // type-specific function pointers
    LKR_PFnExtractKey   m_pfnExtractKey;    // Extract key from record
    LKR_PFnCalcKeyHash  m_pfnCalcKeyHash;   // Calculate hash signature of key
    LKR_PFnEqualKeys    m_pfnEqualKeys;     // Compare two keys
    LKR_PFnAddRefRecord m_pfnAddRefRecord;  // AddRef a record

    LK_TABLESIZE  m_lkts;           // "size" of table: small, medium, or large
    DWORD         m_dwSegBits;      // C{Small,Medium,Large}Segment::SEGBITS
    DWORD         m_dwSegSize;      // C{Small,Medium,Large}Segment::SEGSIZE
    DWORD         m_dwSegMask;      // C{Small,Medium,Large}Segment::SEGMASK

    DWORD         m_dwBktAddrMask0; // mask used for address calculation
    DWORD         m_dwBktAddrMask1; // used in _H1 calculation
    DWORD         m_iExpansionIdx;  // address of next bucket to be expanded
    CDirEntry*    m_paDirSegs;      // directory of table segments
    DWORD         m_cDirSegs;       // segment directory size: varies between
                                    // MIN_DIRSIZE and MAX_DIRSIZE
    DWORD         m_nLevel;         // number of table doublings performed
    DWORD         m_cRecords;       // number of records in the table
    DWORD         m_cActiveBuckets; // number of buckets in use (table size)

    WORD          m_wBucketLockSpins;// default spin count for bucket locks
    const BYTE    m_nTableLockType; // for debugging: LOCK_SPINLOCK, etc
    const BYTE    m_nBucketLockType;// for debugging: LOCK_SPINLOCK, etc

    const CLKRHashTable* const m_phtParent;// Owning table. NULL => standalone

    BYTE          m_MaxLoad;        // max load factor (average chain length)
    const bool    m_fMultiKeys;     // Allow multiple identical keys?
    const bool    m_fNonPagedAllocs;// Use paged or NP pool in kernel

    DWORD_PTR     m_pvReserved1;    // Reserved for future debugging needs
    DWORD_PTR     m_pvReserved2;    // Reserved for future debugging needs
    DWORD_PTR     m_pvReserved3;    // Reserved for future debugging needs
    DWORD_PTR     m_pvReserved4;    // Reserved for future debugging needs

#ifndef LKR_NO_GLOBAL_LIST
    static CLockedDoubleList sm_llGlobalList;// All active CLKRLinearHashTables
    CListEntry    m_leGlobalList;
#endif // !LKR_NO_GLOBAL_LIST

    void        _InsertThisIntoGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        // Only add standalone CLKRLinearHashTables to global list.
        // CLKRHashTables have their own global list.
        if (m_phtParent == NULL)
            sm_llGlobalList.InsertHead(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    void        _RemoveThisFromGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        if (m_phtParent == NULL)
            sm_llGlobalList.RemoveEntry(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    // Non-trivial implementation functions
    LK_RETCODE   _InsertRecord(const void* pvRecord, DWORD dwSignature,
                               bool fOverwrite
#ifdef LKR_STL_ITERATORS
                             , Iterator* piterResult=NULL
#endif // LKR_STL_ITERATORS
                               );
    LK_RETCODE   _DeleteKey(const DWORD_PTR pnKey, DWORD dwSignature,
                            bool fDeleteAllSame);
    LK_RETCODE   _DeleteRecord(const void* pvRecord, DWORD dwSignature);
    bool         _DeleteNode(CBucket* pbkt, CNodeClump*& rpnc,
                             CNodeClump*& rpncPrev, int& riNode,
                             LK_ADDREF_REASON lkar);
    LK_RETCODE   _FindKey(const DWORD_PTR pnKey, DWORD dwSignature,
                          const void** ppvRecord
#ifdef LKR_STL_ITERATORS
                        , Iterator* piterResult=NULL
#endif // LKR_STL_ITERATORS
                          ) const;
    LK_RETCODE   _FindRecord(const void* pvRecord,
                             DWORD dwSignature) const;

    // returns count of errors in compacted state => 0 is good
    int          _IsNodeCompact(CBucket* const pbkt) const;


#ifdef LKR_APPLY_IF
    // Predicate functions
    static LK_PREDICATE WINAPI
    _PredTrue(const void* /*pvRecord*/, void* /*pvState*/)
    { return LKP_PERFORM; }

    DWORD        _ApplyIf(LKR_PFnRecordPred   pfnPredicate,
                          LKR_PFnRecordAction pfnAction, void* pvState,
                          LK_LOCKTYPE lkl, LK_PREDICATE& rlkp);
    DWORD        _DeleteIf(LKR_PFnRecordPred pfnPredicate, void* pvState,
                           LK_PREDICATE& rlkp);
#endif // LKR_APPLY_IF

    void         _Clear(bool fShrinkDirectory);
    LK_RETCODE   _SetSegVars(LK_TABLESIZE lkts, DWORD cInitialBuckets);
    LK_RETCODE   _Expand();
    LK_RETCODE   _Contract();
    LK_RETCODE   _SplitRecordSet(CNodeClump* pncOldTarget,
                                 CNodeClump* pncNewTarget,
                                 DWORD       iExpansionIdx,
                                 DWORD       dwBktAddrMask,
                                 DWORD       dwNewBkt,
                                 CNodeClump* pncFreeList);
    LK_RETCODE   _MergeRecordSets(CBucket*    pbktNewTarget,
                                  CNodeClump* pncOldList,
                                  CNodeClump* pncFreeList);

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // Must provide a (bad) implementation because we export instantiations.
    // TODO: implement these properly; they could be useful.
    CLKRLinearHashTable(const CLKRLinearHashTable&)
        : m_dwSignature(SIGNATURE_FREE)
#ifdef LOCK_INSTRUMENTATION
        , m_Lock(NULL)
#endif // LOCK_INSTRUMENTATION
        , m_nTableLockType(0),
          m_nBucketLockType(0),
          m_fMultiKeys(false),
          m_fNonPagedAllocs(false),
          m_phtParent(NULL)
    {*(BYTE*)NULL;}

    CLKRLinearHashTable& operator=(const CLKRLinearHashTable&)
    {return *(CLKRLinearHashTable*)NULL;}

private:
    // This ctor is used by CLKRHashTable
    CLKRLinearHashTable(
        LPCSTR              pszName,        // Identifies table for debugging
        LKR_PFnExtractKey   pfnExtractKey,  // Extract key from record
        LKR_PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        LKR_PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        LKR_PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        unsigned            maxload,        // Upperbound on avg chain length
        DWORD               initsize,       // Initial size of hash table.
        CLKRHashTable*      phtParent,      // Owning table.
        bool                fMultiKeys,     // Allow multiple identical keys?
        bool                fNonPagedAllocs // use paged or NP pool in kernel
        );

    LK_RETCODE
    _Initialize(
        LKR_PFnExtractKey   pfnExtractKey,
        LKR_PFnCalcKeyHash  pfnCalcKeyHash,
        LKR_PFnEqualKeys    pfnEqualKeys,
        LKR_PFnAddRefRecord pfnAddRefRecord,
        LPCSTR              pszName,
        unsigned            maxload,
        DWORD               initsize);

public:
    CLKRLinearHashTable(
        LPCSTR              pszName,        // Identifies table for debugging
        LKR_PFnExtractKey   pfnExtractKey,  // Extract key from record
        LKR_PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        LKR_PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        LKR_PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        unsigned maxload=LK_DFLT_MAXLOAD,// Upperbound on average chain length
        DWORD    initsize=LK_DFLT_INITSIZE, // Initial size of hash table.
        DWORD    num_subtbls=LK_DFLT_NUM_SUBTBLS, // for signature compatiblity
                                                  // with CLKRHashTable
        bool                fMultiKeys=false // Allow multiple identical keys?
#ifdef LKRHASH_KERNEL_MODE
      , bool                fNonPagedAllocs=true  // use paged or NP pool
#endif
        );

    ~CLKRLinearHashTable();

    static const TCHAR* ClassName()
    {return _TEXT("CLKRLinearHashTable");}

    int                NumSubTables() const  {return 1;}

    bool               MultiKeys() const
    {
        return false;
        // return m_fMultiKeys;     // TODO: implement
    }

#ifdef LKRHASH_KERNEL_MODE
    bool               NonPagedAllocs() const
    {
        return m_fNonPagedAllocs;
    }
#endif

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);

    // Insert a new record into hash table.
    // Returns LK_SUCCESS if all OK, LK_KEY_EXISTS if same key already
    // exists (unless fOverwrite), LK_ALLOC_FAIL if out of space,
    // or LK_BAD_RECORD for a bad record.
    LK_RETCODE     InsertRecord(const void* pvRecord, bool fOverwrite=false)
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;

        return _InsertRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)),
                             fOverwrite);
    }

    // Delete record with the given key.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteKey(const DWORD_PTR pnKey,
                             bool fDeleteAllSame=false)
    {
        if (!IsUsable())
            return m_lkrcState;

        return _DeleteKey(pnKey, _CalcKeyHash(pnKey), fDeleteAllSame);
    }

    // Delete a record from the table, if present.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteRecord(const void* pvRecord)
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;

        return _DeleteRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)));
    }

    // Find record with given key.
    // Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
    //           LK_BAD_RECORD, if ppvRecord is invalid
    //           LK_NO_SUCH_KEY, if no record with given key value was found
    //           LK_UNUSABLE, if hash table not in usable state
    // Note: the record is AddRef'd. You must decrement the reference
    // count when you are finished with the record (if you're implementing
    // refcounting semantics).
    LK_RETCODE     FindKey(const DWORD_PTR pnKey,
                           const void** ppvRecord) const
    {
        if (!IsUsable())
            return m_lkrcState;

        if (ppvRecord == NULL)
            return LK_BAD_RECORD;

        return _FindKey(pnKey, _CalcKeyHash(pnKey), ppvRecord);
    }

    // Sees if the record is contained in the table
    // Returns:  LK_SUCCESS, if record found
    //           LK_BAD_RECORD, if pvRecord is invalid
    //           LK_NO_SUCH_KEY, if record is not in the table
    //           LK_UNUSABLE, if hash table not in usable state
    // Note: the record is *not* AddRef'd.
    LK_RETCODE     FindRecord(const void* pvRecord) const
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;

        return _FindRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)));
    }


#ifdef LKR_APPLY_IF
    // Walk the hash table, applying pfnAction to all records.
    // Locks the whole table for the duration with either a (possibly
    // shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          Apply(LKR_PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK);

    // Walk the hash table, applying pfnAction to any records that match
    // pfnPredicate. Locks the whole table for the duration with either
    // a (possibly shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          ApplyIf(LKR_PFnRecordPred   pfnPredicate,
                           LKR_PFnRecordAction pfnAction,
                           void*               pvState=NULL,
                           LK_LOCKTYPE         lkl=LKL_READLOCK);

    // Delete any records that match pfnPredicate.
    // Locks the table for the duration with a writelock.
    // Returns the number of deletions.
    //
    // Do *not* walk the hash table by hand with an iterator and call
    // DeleteKey. The iterator will end up pointing to garbage.
    DWORD          DeleteIf(LKR_PFnRecordPred pfnPredicate,
                            void*             pvState=NULL);
#endif // LKR_APPLY_IF


    // Check table for consistency. Returns 0 if okay, or the number of
    // errors otherwise.
    int            CheckTable() const;

    // Remove all data from the table
    void           Clear()
    {
        WriteLock();
        _Clear(true);
        WriteUnlock();
    }

    // Number of elements in the table
    DWORD          Size() const
    { return m_cRecords; }

    // Maximum possible number of elements in the table
    DWORD          MaxSize() const
    { return static_cast<DWORD>(m_MaxLoad * MAX_DIRSIZE * m_dwSegSize); }

    // Get hash table statistics
    CLKRHashTableStats GetStatistics() const;

    // Is the hash table usable?
    bool           IsUsable() const
    { return (m_lkrcState == LK_SUCCESS); }

    // Is the hash table consistent and correct?
    bool           IsValid() const
    {
        STATIC_ASSERT(((MIN_DIRSIZE & (MIN_DIRSIZE-1)) == 0)  // == (1 << N)
                      &&  ((1 << 3) <= MIN_DIRSIZE)
                      &&  (MIN_DIRSIZE < MAX_DIRSIZE)
                      &&  ((MAX_DIRSIZE & (MAX_DIRSIZE-1)) == 0)
                      &&  (MAX_DIRSIZE <= (1 << 30)));

        bool f = (m_lkrcState == LK_SUCCESS     // serious internal failure?
                  &&  m_paDirSegs != NULL
                  &&  MIN_DIRSIZE <= m_cDirSegs  &&  m_cDirSegs <= MAX_DIRSIZE
                  &&  (m_cDirSegs & (m_cDirSegs-1)) == 0
                  &&  m_pfnExtractKey != NULL
                  &&  m_pfnCalcKeyHash != NULL
                  &&  m_pfnEqualKeys != NULL
                  &&  m_pfnAddRefRecord != NULL
                  &&  m_cActiveBuckets > 0
                  &&  ValidSignature()
                  );
        if (!f)
            m_lkrcState = LK_UNUSABLE;
        return f;
    }

    // Set the spin count on the table lock
    void        SetTableLockSpinCount(WORD wSpins);

    // Get the spin count on the table lock
    WORD        GetTableLockSpinCount() const;

    // Set/Get the spin count on the bucket locks
    void        SetBucketLockSpinCount(WORD wSpins);
    WORD        GetBucketLockSpinCount() const;

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('L' << 16) | ('H' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('L' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}


#ifdef LKR_EXPOSED_TABLE_LOCK
public:
#else // !LKR_EXPOSED_TABLE_LOCK
protected:
#endif // !LKR_EXPOSED_TABLE_LOCK

    //
    // Lock manipulators
    //

    // Lock the table (exclusively) for writing
    void        WriteLock()
    { m_Lock.WriteLock(); }

    // Lock the table (possibly shared) for reading
    void        ReadLock() const
    { m_Lock.ReadLock(); }

    // Unlock the table for writing
    void        WriteUnlock()
    { m_Lock.WriteUnlock(); }

    // Unlock the table for reading
    void        ReadUnlock() const
    { m_Lock.ReadUnlock(); }

    // Is the table already locked for writing?
    bool        IsWriteLocked() const
    { return m_Lock.IsWriteLocked(); }

    // Is the table already locked for reading?
    bool        IsReadLocked() const
    { return m_Lock.IsReadLocked(); }

    // Is the table unlocked for writing?
    bool        IsWriteUnlocked() const
    { return m_Lock.IsWriteUnlocked(); }

    // Is the table unlocked for reading?
    bool        IsReadUnlocked() const
    { return m_Lock.IsReadUnlocked(); }

    // Convert the read lock to a write lock
    void  ConvertSharedToExclusive()
    { m_Lock.ConvertSharedToExclusive(); }

    // Convert the write lock to a read lock
    void  ConvertExclusiveToShared() const
    { m_Lock.ConvertExclusiveToShared(); }

#ifdef LKRHASH_KERNEL_MODE
    LKRHASH_ALLOCATOR_DEFINITIONS(CLKRLinearHashTable);
#endif // LKRHASH_KERNEL_MODE


#ifdef LKR_DEPRECATED_ITERATORS

public:

    // Iterators can be used to walk the table. To ensure a consistent
    // view of the data, the iterator locks the whole table. This can
    // have a negative effect upon performance, because no other thread
    // can do anything with the table. Use with care.
    //
    // You should not use an iterator to walk the table, calling DeleteKey,
    // as the iterator will end up pointing to garbage.
    //
    // Use Apply, ApplyIf, or DeleteIf instead of iterators to safely
    // walk the tree. Or use the STL-style iterators.
    //
    // Note that iterators acquire a reference to the record pointed to
    // and release that reference as soon as the iterator is incremented.
    // In other words, this code is safe:
    //     lkrc = ht.IncrementIterator(&iter);
    //     // assume lkrc == LK_SUCCESS for the sake of this example
    //     CMyHashTable::Record* pRec = iter.Record();
    //     Foo(pRec);  // uses pRec but doesn't hang on to it
    //     lkrc = ht.IncrementIterator(&iter);
    //
    // But this code is not safe because pRec is used out of the scope of
    // the iterator that provided it:
    //     lkrc = ht.IncrementIterator(&iter);
    //     CMyHashTable::Record* pRec = iter.Record();
    //     // Broken code: Should have called
    //     //   ht.AddRefRecord(pRec, LKAR_EXPLICIT_ACQUIRE) here
    //     lkrc = ht.IncrementIterator(&iter);
    //     Foo(pRec);   // Unsafe: because no longer have a valid reference
    //
    // If the record has no reference-counting semantics, then you can
    // ignore the above remarks about scope.


    class CIterator
    {
    protected:
        friend class CLKRLinearHashTable;

        CLKRLinearHashTable* m_plht;        // which linear hash table?
        DWORD               m_dwBucketAddr; // bucket index
        CNodeClump*         m_pnc;          // a CNodeClump in bucket
        int                 m_iNode;        // offset within m_pnc
        LK_LOCKTYPE         m_lkl;          // readlock or writelock?

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // Must provide (bad) implementation because we export instantiations.
        CIterator(const CIterator&)             {*(BYTE*)NULL;}
        CIterator& operator=(const CIterator&)  {return *(CIterator*)NULL;}

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : m_plht(NULL),
              m_dwBucketAddr(0),
              m_pnc(NULL),
              m_iNode(-1),
              m_lkl(lkl)
        {}

        // Return the record associated with this iterator
        const void* Record() const
        {
            IRTLASSERT(IsValid());

            return ((m_pnc != NULL
                        &&  m_iNode >= 0
                        &&  m_iNode < CLKRLinearHashTable::NODES_PER_CLUMP)
                    ?  m_pnc->m_pvNode[m_iNode]
                    :  NULL);
        }

        // Return the key associated with this iterator
        const DWORD_PTR Key() const
        {
            IRTLASSERT(m_plht != NULL);
            const void* pRec = Record();
            return ((pRec != NULL  &&  m_plht != NULL)
                    ?  m_plht->_ExtractKey(pRec)
                    :  NULL);
        }

        bool IsValid() const
        {
            return ((m_plht != NULL)
                    &&  (m_pnc != NULL)
                    &&  (0 <= m_iNode
                         &&  m_iNode < CLKRLinearHashTable::NODES_PER_CLUMP)
                    &&  (!m_pnc->IsEmptyNode(m_iNode)));
        }

        // Delete the record that the iterator points to. Does an implicit
        // IncrementIterator after deletion.
        LK_RETCODE     DeleteRecord();

        // Change the record that the iterator points to. The new record
        // must have the same key as the old one.
        LK_RETCODE     ChangeRecord(const void* pNewRec);
    }; // class CIterator


    // Const iterators for readonly access. You must use these with
    // const CLKRLinearHashTables.
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    }; // class CConstIterator


private:
    // The public APIs lock the table. The private ones, which are used
    // directly by CLKRHashTable, don't.
    LK_RETCODE     _InitializeIterator(CIterator* piter);
    LK_RETCODE     _CloseIterator(CIterator* piter);

public:
    // Initialize the iterator to point to the first item in the hash table
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        if (piter == NULL  ||  piter->m_plht != NULL)
            return LK_BAD_ITERATOR;

        if (piter->m_lkl == LKL_WRITELOCK)
            WriteLock();
        else
            ReadLock();

        return _InitializeIterator(piter);
    }

    // The const iterator version
    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        ReadLock();
        return const_cast<CLKRLinearHashTable*>(this)
                    ->_InitializeIterator(static_cast<CIterator*>(piter));
    }

    // Move the iterator on to the next item in the table.
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     IncrementIterator(CIterator* piter);

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRLinearHashTable*>(this)
                    ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    // Close the iterator.
    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        if (piter == NULL  ||  piter->m_plht != this)
            return LK_BAD_ITERATOR;
        _CloseIterator(piter);

        if (piter->m_lkl == LKL_WRITELOCK)
            WriteUnlock();
        else
            ReadUnlock();

        return LK_SUCCESS;
    };

    // Close the CConstIterator
    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        const_cast<CLKRLinearHashTable*>(this)
             ->_CloseIterator(static_cast<CIterator*>(piter));

        ReadUnlock();
        return LK_SUCCESS;
    };

#endif // LKR_DEPRECATED_ITERATORS


#ifdef LKR_STL_ITERATORS

private:
    bool _Erase(Iterator& riter, DWORD dwSignature);
    bool _Find(DWORD_PTR pnKey, DWORD dwSignature,
               Iterator& riterResult);

    bool _IsValidIterator(const Iterator& riter) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH:_IsValidIterator(%p)\n"), &riter);
        bool fValid = ((riter.m_plht == this)
                       &&  (riter.m_dwBucketAddr < m_cActiveBuckets)
                       &&  riter.IsValid());
        IRTLASSERT(fValid);
        return fValid;
    }

public:
    // Return iterator pointing to first item in table
    Iterator
    Begin();

    // Return a one-past-the-end iterator. Always empty.
    Iterator
    End() const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::End\n"));
        return Iterator();
    }

    // Insert a record
    // Returns `true' if successful; iterResult points to that record
    // Returns `false' otherwise; iterResult == End()
    bool
    Insert(
        /* in */  const void* pvRecord,
        /* out */ Iterator&   riterResult,
        /* in */  bool        fOverwrite=false);

    // Erase the record pointed to by the iterator; adjust the iterator
    // to point to the next record. Returns `true' if successful.
    bool
    Erase(
        /* in,out */ Iterator& riter);

    // Erase the records in the range [riterFirst, riterLast).
    // Returns `true' if successful. riterFirst points to riterLast on return.
    bool
    Erase(
        /*in*/ Iterator& riterFirst,
        /*in*/ Iterator& riterLast);

    // Find the (first) record that has its key == pnKey.
    // If successful, returns `true' and iterator points to (first) record.
    // If fails, returns `false' and iterator == End()
    bool
    Find(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterResult);

    // Find the range of records that have their keys == pnKey.
    // If successful, returns `true', iterFirst points to first record,
    //     and iterLast points to one-beyond-the last such record.
    // If fails, returns `false' and both iterators == End().
    // Primarily useful when m_fMultiKey == true
    bool
    EqualRange(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterFirst,     // inclusive
        /* out */ Iterator& riterLast);     // exclusive

#endif // LKR_STL_ITERATORS

}; // class CLKRLinearHashTable



#ifdef LKR_STL_ITERATORS

// These functions have to be defined after CLKRLinearHashTable

inline void
CLKRLinearHashTable_Iterator::_AddRef(
    LK_ADDREF_REASON lkar) const
{
    // TODO: should iterator call _AddRefRecord at all
    if (m_plht != NULL  &&  m_iNode != NODE_BEGIN - NODE_STEP)
    {
        IRTLASSERT((0 <= m_iNode  &&  m_iNode < NODES_PER_CLUMP)
                   &&  (unsigned) m_iNode < NODES_PER_CLUMP
                   &&  m_pnc != NULL
                   &&  (lkar < 0 ||  lkar > 0)
                   );
        const void* pvRecord = m_pnc->m_pvNode[m_iNode];
        IRTLASSERT(pvRecord != NULL);
        LKR_ITER_TRACE(_TEXT("  LKLH::AddRef, this=%p, Rec=%p\n"),
                       this, pvRecord);
        m_plht->_AddRefRecord(pvRecord, lkar);
    }
} // CLKRLinearHashTable_Iterator::_AddRef


inline const DWORD_PTR
CLKRLinearHashTable_Iterator::Key() const
{
    IRTLASSERT(IsValid());
    return m_plht->_ExtractKey(m_pnc->m_pvNode[m_iNode]);
} // CLKRLinearHashTable_Iterator::Key

#endif // LKR_STL_ITERATORS



//--------------------------------------------------------------------
// CLKRHashTable
//
// To improve concurrency, a hash table is divided into a number of
// (independent) subtables. Each subtable is a linear hash table. The
// number of subtables is defined when the table is created and remains
// fixed thereafter. Records are assigned to subtables based on their
// hashed key.
//
// For small or low-contention hashtables, you can bypass this
// thin wrapper and use CLKRLinearHashTable directly. The methods are
// documented in the declarations for CLKRHashTable (above).
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKRHashTable
{
private:
    typedef CLKRLinearHashTable SubTable;

public:
    typedef SubTable::TableLock  TableLock;
    typedef SubTable::BucketLock BucketLock;

#ifdef LKR_DEPRECATED_ITERATORS
    class CIterator;
    friend class CLKRHashTable::CIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_STL_ITERATORS
    friend class CLKRHashTable_Iterator;
    typedef CLKRHashTable_Iterator Iterator;
#endif // LKR_STL_ITERATORS

    friend class CLKRLinearHashTable;

    // aliases for convenience
    enum {
        NAME_SIZE = SubTable::NAME_SIZE,
        HASH_INVALID_SIGNATURE = SubTable::HASH_INVALID_SIGNATURE,
        NODES_PER_CLUMP = SubTable::NODES_PER_CLUMP,
    };

    enum {
        MAX_LKR_SUBTABLES = 64,
    };

private:
    // Hash table parameters
    DWORD          m_dwSignature;   // debugging: id & corruption check
    CHAR           m_szName[NAME_SIZE]; // an identifier for debugging
    DWORD          m_cSubTables;    // number of subtables
    SubTable**     m_palhtDir;      // array of subtables

    // type-specific function pointers
    LKR_PFnExtractKey  m_pfnExtractKey;
    LKR_PFnCalcKeyHash m_pfnCalcKeyHash;
    mutable LK_RETCODE m_lkrcState;     // Internal state of table
    int                m_nSubTableMask;

#ifndef LKR_NO_GLOBAL_LIST
    static CLockedDoubleList sm_llGlobalList; // All active CLKRHashTables
    CListEntry         m_leGlobalList;
#endif // !LKR_NO_GLOBAL_LIST

    void
    _InsertThisIntoGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        sm_llGlobalList.InsertHead(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    void
    _RemoveThisFromGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        sm_llGlobalList.RemoveEntry(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    LKRHASH_GLOBAL_LOCK_DECLARATIONS();

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // Must provide a (bad) implementation because we export instantiations.
    // TODO: implement these properly; they could be useful.
    CLKRHashTable(const CLKRHashTable&)             {*(BYTE*)NULL;}
    CLKRHashTable& operator=(const CLKRHashTable&)  {return *(CLKRHashTable*)NULL;}


    // Extract the key from the record
    const DWORD_PTR  _ExtractKey(const void* pvRecord) const
    {
        IRTLASSERT(pvRecord != NULL);
        IRTLASSERT(m_pfnExtractKey != NULL);
        return (*m_pfnExtractKey)(pvRecord);
    }

    // Hash the key
    DWORD        _CalcKeyHash(const DWORD_PTR pnKey) const
    {
        // Note pnKey==0 is acceptable, as the real key type could be an int
        IRTLASSERT(m_pfnCalcKeyHash != NULL);
        DWORD dwHash = (*m_pfnCalcKeyHash)(pnKey);
        // We forcibly scramble the result to help ensure a better distribution
#ifndef __HASHFN_NO_NAMESPACE__
        dwHash = HashFn::HashRandomizeBits(dwHash);
#else // !__HASHFN_NO_NAMESPACE__
        dwHash = ::HashRandomizeBits(dwHash);
#endif // !__HASHFN_NO_NAMESPACE__
        IRTLASSERT(dwHash != HASH_INVALID_SIGNATURE);
        return dwHash;
    }

    // Use the key's hash signature to multiplex into a subtable
    SubTable*    _SubTable(DWORD dwSignature) const;

    // Find the index of pst within the subtable array
    int          _SubTableIndex(SubTable* pst) const;

    // Memory allocation wrappers to allow us to simulate allocation
    // failures during testing
    static SubTable** const
    _AllocateSubTableArray(
        size_t n);

    static bool
    _FreeSubTableArray(
        SubTable** palht);

    static SubTable* const
    _AllocateSubTable(
        LPCSTR              pszName,        // Identifies table for debugging
        LKR_PFnExtractKey   pfnExtractKey,  // Extract key from record
        LKR_PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        LKR_PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        LKR_PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        unsigned            maxload,        // Upperbound on avg chain length
        DWORD               initsize,       // Initial size of hash table.
        CLKRHashTable*      phtParent,      // Owning table.
        bool                fMultiKeys,     // Allow multiple identical keys?
        bool                fNonPagedAllocs // use paged or NP pool in kernel
    );

    static bool
    _FreeSubTable(
        SubTable* plht);


public:
    CLKRHashTable(
        LPCSTR              pszName,        // Identifies table for debugging
        LKR_PFnExtractKey   pfnExtractKey,  // Extract key from record
        LKR_PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        LKR_PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        LKR_PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        unsigned  maxload=LK_DFLT_MAXLOAD,  // bound on avg chain length
        DWORD     initsize=LK_DFLT_INITSIZE,// Initial size of hash table.
        DWORD     num_subtbls=LK_DFLT_NUM_SUBTBLS, // #subordinate hash tables.
        bool            fMultiKeys=false    // Allow multiple identical keys?
#ifdef LKRHASH_KERNEL_MODE
      , bool                fNonPagedAllocs=true  // use paged or NP pool
#endif
        );

    ~CLKRHashTable();

    static const TCHAR* ClassName()
    {return _TEXT("CLKRHashTable");}

    int                NumSubTables() const  {return m_cSubTables;}

    bool               MultiKeys() const;

#ifdef LKRHASH_KERNEL_MODE
    bool               NonPagedAllocs() const;
#endif

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);


    // Thin wrappers for the corresponding methods in CLKRLinearHashTable
    LK_RETCODE     InsertRecord(const void* pvRecord, bool fOverwrite=false);
    LK_RETCODE     DeleteKey(const DWORD_PTR pnKey, bool fDeleteAllSame=false);
    LK_RETCODE     DeleteRecord(const void* pvRecord);
    LK_RETCODE     FindKey(const DWORD_PTR pnKey,
                           const void** ppvRecord) const;
    LK_RETCODE     FindRecord(const void* pvRecord) const;

#ifdef LKR_APPLY_IF
    DWORD          Apply(LKR_PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          ApplyIf(LKR_PFnRecordPred   pfnPredicate,
                           LKR_PFnRecordAction pfnAction,
                           void*           pvState=NULL,
                           LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          DeleteIf(LKR_PFnRecordPred pfnPredicate,
                            void*         pvState=NULL);
#endif // LKR_APPLY_IF

    void           Clear();
    int            CheckTable() const;
    DWORD          Size() const;
    DWORD          MaxSize() const;
    CLKRHashTableStats GetStatistics() const;
    bool           IsValid() const;

    void           SetTableLockSpinCount(WORD wSpins);
    WORD           GetTableLockSpinCount() const;
    void           SetBucketLockSpinCount(WORD wSpins);
    WORD           GetBucketLockSpinCount() const;

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('H' << 16) | ('T' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('H' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}

    // Is the hash table usable?
    bool           IsUsable() const
    { return (m_lkrcState == LK_SUCCESS); }


#ifdef LKR_EXPOSED_TABLE_LOCK
public:
#else // !LKR_EXPOSED_TABLE_LOCK
protected:
#endif // !LKR_EXPOSED_TABLE_LOCK

    void        WriteLock();
    void        ReadLock() const;
    void        WriteUnlock();
    void        ReadUnlock() const;
    bool        IsWriteLocked() const;
    bool        IsReadLocked() const;
    bool        IsWriteUnlocked() const;
    bool        IsReadUnlocked() const;
    void        ConvertSharedToExclusive();
    void        ConvertExclusiveToShared() const;


#ifdef LKRHASH_KERNEL_MODE
    LKRHASH_ALLOCATOR_DEFINITIONS(CLKRHashTable);
#endif // LKRHASH_KERNEL_MODE


#ifdef LKR_DEPRECATED_ITERATORS

public:

    typedef SubTable::CIterator CLHTIterator;

    class CIterator : public CLHTIterator
    {
    protected:
        friend class CLKRHashTable;

        CLKRHashTable*  m_pht;  // which hash table?
        int             m_ist;  // which subtable

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // Must provide (bad) implementation because we export instantiations.
        CIterator(const CIterator&)             {*(BYTE*)NULL;}
        CIterator& operator=(const CIterator&)  {return *(CIterator*)NULL;}

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : CLHTIterator(lkl),
              m_pht(NULL),
              m_ist(-1)
        {}

        const void* Record() const
        {
            IRTLASSERT(IsValid());

            // This is a hack to work around a compiler bug. Calling
            // CLHTIterator::Record calls this function recursively until
            // the stack overflows.
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Record();
        }

        const DWORD_PTR Key() const
        {
            IRTLASSERT(IsValid());
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Key();
        }

        bool IsValid() const
        {
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return (m_pht != NULL  &&  m_ist >= 0  &&  pBase->IsValid());
        }
    };

    // Const iterators for readonly access
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter);
    LK_RETCODE     IncrementIterator(CIterator* piter);
    LK_RETCODE     CloseIterator(CIterator* piter);

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    };

#endif // LKR_DEPRECATED_ITERATORS



#ifdef LKR_STL_ITERATORS

private:
    bool _IsValidIterator(const Iterator& riter) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT:_IsValidIterator(%p)\n"), &riter);
        bool fValid = (riter.m_pht == this);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (0 <= riter.m_ist
                              &&  riter.m_ist < (int) m_cSubTables);
        IRTLASSERT(fValid);
        IRTLASSERT(_SubTableIndex(riter.m_subiter.m_plht) == riter.m_ist);
        fValid = fValid  &&  riter.IsValid();
        IRTLASSERT(fValid);
        return fValid;
    }


public:
    Iterator
    Begin();

    Iterator
    End() const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::End\n"));
        return Iterator();
    }

    bool
    Insert(
        /* in */  const void* pvRecord,
        /* out */ Iterator&   riterResult,
        /* in */  bool        fOverwrite=false);

    bool
    Erase(
        /* in,out */ Iterator& riter);

    bool
    Erase(
        /*in*/ Iterator& riterFirst,
        /*in*/ Iterator& riterLast);

    bool
    Find(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterResult);

    bool
    EqualRange(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterFirst,     // inclusive
        /* out */ Iterator& riterLast);     // exclusive

#endif // LKR_STL_ITERATORS

}; // class CLKRHashTable



//--------------------------------------------------------------------
// A typesafe wrapper for CLKRHashTable (or CLKRLinearHashTable).
//
// * _Derived must derive from CTypedHashTable and provide certain member
//   functions (ExtractKey, CalcKeyHash, EqualKeys, AddRefRecord). It's
//   needed so that the method wrappers can downcast to the typesafe
//   implementations that you provide.
// * _Record is the type of the record. C{Linear}HashTable will store
//   >pointers< to _Record; i.e., stores _Records by reference, not by value.
// * _Key is the type of the key. _Key is used directly---it is not
//   assumed to be a pointer type. _Key can be an integer or a pointer.
//   C{Linear}HashTable assumes that the key is stored in the associated
//   record. See the comments at the declaration of LKR_PFnExtractKey
//   for more details.
// (optional parameters):
// * _BaseHashTable is the base hash table: CLKRHashTable or
///   CLKRLinearHashTable
// * _BaseIterator is the iterator type, _BaseHashTable::CIterator
//
// Some associative containers allow you to store key-value (aka
// name-value) pairs. LKRhash doesn't allow you to do this directly, but
// it's straightforward to build a simple wrapper class (or to use
// std::pair<key,value>).
//
// CTypedHashTable could derive directly from CLKRLinearHashTable, if you
// don't need the extra overhead of CLKRHashTable (which is quite low).
// If you expect to be using the table a lot on multiprocessor machines,
// you should use the default of CLKRHashTable, as it will scale better.
//
// You may need to add the following line to your code to disable
// warning messages about truncating extremly long identifiers.
//   #pragma warning (disable : 4786)
//
// The _Derived class should look something like this:
//   class CDerived : public CTypedHashTable<CDerived, RecordType, KeyType>
//   {
//   public:
//      CDerived()
//          : CTypedHashTable<CDerived, RecordType, KeyType>("DerivedTable")
//      { /* other ctor actions, if needed */ }
//      static KeyType ExtractKey(const RecordType* pTest);
//      static DWORD   CalcKeyHash(const KeyType Key);
//      static bool    EqualKeys(const KeyType Key1, const KeyType Key2);
//      static void    AddRefRecord(RecordType* pRecord,LK_ADDREF_REASON lkar);
//      // You probably want to declare the copy ctor and operator=
//      // as private, so that the compiler won't synthesize them.
//      // You don't need to provide a dtor, unless you have custom
//      // member data to clean up.
//
//      // Optional: other functions
//   };
//
//--------------------------------------------------------------------

template < class _Derived, class _Record, class _Key,
           class _BaseHashTable=CLKRHashTable
#ifdef LKR_DEPRECATED_ITERATORS
         , class _BaseIterator=_BaseHashTable::CIterator
#endif // LKR_DEPRECATED_ITERATORS
         >
class CTypedHashTable : public _BaseHashTable
{
public:
    // convenient aliases
    typedef _Derived        Derived;
    typedef _Record         Record;
    typedef _Key            Key;
    typedef _BaseHashTable  BaseHashTable;

    typedef CTypedHashTable<_Derived, _Record, _Key, _BaseHashTable
#ifdef LKR_DEPRECATED_ITERATORS
                            , _BaseIterator
#endif // LKR_DEPRECATED_ITERATORS
                            > HashTable;
#ifdef LKR_DEPRECATED_ITERATORS
    typedef _BaseIterator   BaseIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_APPLY_IF
    // ApplyIf() and DeleteIf(): Does the record match the predicate?
    // Note: takes a Record*, not a const Record*. You can modify the
    // record in Pred() or Action(), if you like, but if you do, you
    // should use LKL_WRITELOCK to lock the table.
    typedef LK_PREDICATE (WINAPI *PFnRecordPred) (Record* pRec, void* pvState);

    // Apply() et al: Perform action on record.
    typedef LK_ACTION   (WINAPI *PFnRecordAction)(Record* pRec, void* pvState);
#endif // LKR_APPLY_IF

private:

    // Wrappers for the typesafe methods exposed by the derived class

    static const DWORD_PTR WINAPI
    _ExtractKey(const void* pvRecord)
    {
        const _Record* pRec = static_cast<const _Record*>(pvRecord);
        const _Key   key = static_cast<const _Key>(_Derived::ExtractKey(pRec));
        // I would prefer to use reinterpret_cast here and in _CalcKeyHash
        // and _EqualKeys, but the stupid Win64 compiler thinks it knows
        // better than I do.
        return (const DWORD_PTR) key;
    }

    static DWORD WINAPI
    _CalcKeyHash(const DWORD_PTR pnKey)
    {
        const _Key key = (const _Key) (DWORD_PTR) pnKey;
        return _Derived::CalcKeyHash(key);
    }

    static BOOL WINAPI
    _EqualKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2)
    {
        const _Key key1 = (const _Key) (DWORD_PTR) pnKey1;
        const _Key key2 = (const _Key) (DWORD_PTR) pnKey2;
        return _Derived::EqualKeys(key1, key2);
    }

    static void WINAPI
    _AddRefRecord(const void* pvRecord, LK_ADDREF_REASON lkar)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        _Derived::AddRefRecord(pRec, lkar);
    }


#ifdef LKR_APPLY_IF
    // Typesafe wrappers for Apply, ApplyIf, and DeleteIf.

    class CState
    {
    public:
        PFnRecordPred   m_pfnPred;
        PFnRecordAction m_pfnAction;
        void*           m_pvState;

        CState(
            PFnRecordPred   pfnPred,
            PFnRecordAction pfnAction,
            void*           pvState)
            : m_pfnPred(pfnPred), m_pfnAction(pfnAction), m_pvState(pvState)
        {}
    };

    static LK_PREDICATE WINAPI
    _Pred(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnPred)(pRec, pState->m_pvState);
    }

    static LK_ACTION WINAPI
    _Action(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnAction)(pRec, pState->m_pvState);
    }
#endif // LKR_APPLY_IF

public:
    CTypedHashTable(
        LPCSTR pszName,                       // Identifies table for debugging
        unsigned maxload=LK_DFLT_MAXLOAD,     // Upperbound on avg chain len
        DWORD  initsize=LK_DFLT_INITSIZE,     // Initial size of table: S/M/L
        DWORD  num_subtbls=LK_DFLT_NUM_SUBTBLS,// #subordinate hash tables.
        bool   fMultiKeys=false               // Allow multiple identical keys?
#ifdef LKRHASH_KERNEL_MODE
      , bool   fNonPagedAllocs=true  // use paged or NP pool in kernel
#endif
        )
        : _BaseHashTable(pszName, _ExtractKey, _CalcKeyHash, _EqualKeys,
                            _AddRefRecord, maxload, initsize, num_subtbls,
                            fMultiKeys
#ifdef LKRHASH_KERNEL_MODE
                          , fNonPagedAllocs
#endif
                         )
    {}

    LK_RETCODE   InsertRecord(const _Record* pRec, bool fOverwrite=false)
    { return _BaseHashTable::InsertRecord(pRec, fOverwrite); }

    LK_RETCODE   DeleteKey(const _Key key, bool fDeleteAllSame=false)
    {
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return _BaseHashTable::DeleteKey(pnKey, fDeleteAllSame);
    }

    LK_RETCODE   DeleteRecord(const _Record* pRec)
    { return _BaseHashTable::DeleteRecord(pRec); }

    // Note: returns a _Record**, not a const Record**. Note that you
    // can use a const type for the template parameter to ensure constness.
    LK_RETCODE   FindKey(const _Key key, _Record** ppRec) const
    {
        if (ppRec == NULL)
            return LK_BAD_RECORD;
        *ppRec = NULL;
        const void* pvRec = NULL;
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        LK_RETCODE lkrc = _BaseHashTable::FindKey(pnKey, &pvRec);
        *ppRec = static_cast<_Record*>(const_cast<void*>(pvRec));
        return lkrc;
    }

    LK_RETCODE   FindRecord(const _Record* pRec) const
    { return _BaseHashTable::FindRecord(pRec); }


    // Other C{Linear}HashTable methods can be exposed without change


#ifdef LKR_APPLY_IF

public:

    // Typesafe wrappers for Apply et al

    DWORD        Apply(PFnRecordAction pfnAction,
                       void*           pvState=NULL,
                       LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnAction != NULL);
        if (pfnAction == NULL)
            return 0;

        CState   state(NULL, pfnAction, pvState);
        return   _BaseHashTable::Apply(_Action, &state, lkl);
    }

    DWORD        ApplyIf(PFnRecordPred   pfnPredicate,
                         PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);
        if (pfnPredicate == NULL  ||  pfnAction == NULL)
            return 0;

        CState   state(pfnPredicate, pfnAction, pvState);
        return   _BaseHashTable::ApplyIf(_Pred, _Action, &state, lkl);
    }

    DWORD        DeleteIf(PFnRecordPred pfnPredicate, void* pvState=NULL)
    {
        IRTLASSERT(pfnPredicate != NULL);
        if (pfnPredicate == NULL)
            return 0;

        CState   state(pfnPredicate, NULL, pvState);
        return   _BaseHashTable::DeleteIf(_Pred, &state);
    }
#endif // LKR_APPLY_IF



#ifdef LKR_DEPRECATED_ITERATORS
    // Typesafe wrappers for iterators


    class CIterator : public _BaseIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : _BaseIterator(lkl)
        {}

        _Record*  Record() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Record*>(const_cast<void*>(
                        pBase->Record()));
        }

        _Key      Key() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Key>(reinterpret_cast<void*>(pBase->Key()));
        }
    };

    // readonly iterator
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}

        const _Record*  Record() const
        {
            return CIterator::Record();
        }

        const _Key      Key() const
        {
            return CIterator::Key();
        }
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        return _BaseHashTable::InitializeIterator(piter);
    }

    LK_RETCODE     IncrementIterator(CIterator* piter)
    {
        return _BaseHashTable::IncrementIterator(piter);
    }

    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        return _BaseHashTable::CloseIterator(piter);
    }

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    }

#endif // LKR_DEPRECATED_ITERATORS



#ifdef LKR_STL_ITERATORS

    // TODO: const_iterator

public:

    class iterator
    {
        friend class CTypedHashTable<_Derived, _Record, _Key,
                                     _BaseHashTable
 #ifdef LKR_DEPRECATED_ITERATORS
                                     , _BaseIterator
 #endif // LKR_DEPRECATED_ITERATORS
        >;

    protected:
        _BaseHashTable::Iterator            m_iter;

        iterator(
            _BaseHashTable::Iterator& rhs)
            : m_iter(rhs)
        {
            LKR_ITER_TRACE(_TEXT("Typed::prot ctor, this=%p, rhs=%p\n"),
                           this, &rhs);
        }

    public:
        typedef std::forward_iterator_tag   iterator_category;
        typedef _Record                     value_type;
        typedef ptrdiff_t                   difference_type;
        typedef size_t                      size_type;
        typedef value_type&                 reference;
        typedef value_type*                 pointer;

        iterator()
            : m_iter()
        {
            LKR_ITER_TRACE(_TEXT("Typed::default ctor, this=%p\n"), this);
        }

        iterator(
            const iterator& rhs)
            : m_iter(rhs.m_iter)
        {
            LKR_ITER_TRACE(_TEXT("Typed::copy ctor, this=%p, rhs=%p\n"),
                           this, &rhs);
        }

        iterator& operator=(
            const iterator& rhs)
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator=, this=%p, rhs=%p\n"),
                           this, &rhs);
            m_iter = rhs.m_iter;
            return *this;
        }

        ~iterator()
        {
            LKR_ITER_TRACE(_TEXT("Typed::dtor, this=%p\n"), this);
        }

        reference operator*() const
        {
            void* pvRecord = const_cast<void*>(m_iter.Record());
            return reinterpret_cast<reference>(pvRecord);
        }

        pointer   operator->() const  { return &(operator*()); }

        // pre-increment
        iterator& operator++()
        {
            LKR_ITER_TRACE(_TEXT("Typed::pre-increment, this=%p\n"), this);
            m_iter.Increment();
            return *this;
        }

        // post-increment
        iterator  operator++(int)
        {
            LKR_ITER_TRACE(_TEXT("Typed::post-increment, this=%p\n"), this);
            iterator iterPrev = *this;
            m_iter.Increment();
            return iterPrev;
        }

        bool operator==(
            const iterator& rhs) const
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator==, this=%p, rhs=%p\n"),
                           this, &rhs);
            return m_iter == rhs.m_iter;
        }

        bool operator!=(
            const iterator& rhs) const
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator!=, this=%p, rhs=%p\n"),
                           this, &rhs);
            return m_iter != rhs.m_iter;
        }

        _Record*  Record() const
        {
            LKR_ITER_TRACE(_TEXT("Typed::Record, this=%p\n"), this);
            return reinterpret_cast<_Record*>(
                        const_cast<void*>(m_iter.Record()));
        }

        _Key      Key() const
        {
            LKR_ITER_TRACE(_TEXT("Typed::Key, this=%p\n"), this);
            return reinterpret_cast<_Key>(
                        reinterpret_cast<void*>(m_iter.Key()));
        }
    }; // class iterator

    // Return iterator pointing to first item in table
    iterator begin()
    {
        LKR_ITER_TRACE(_TEXT("Typed::begin()\n"));
        return iterator(_BaseHashTable::Begin());
    }

    // Return a one-past-the-end iterator. Always empty.
    iterator end() const
    {
        LKR_ITER_TRACE(_TEXT("Typed::end()\n"));
        return iterator(_BaseHashTable::End());
    }

    template <class _InputIterator>
    CTypedHashTable(
        LPCSTR pszName,                       // An identifier for debugging
        _InputIterator f,                     // first element in range
        _InputIterator l,                     // one-beyond-last element
        unsigned maxload=LK_DFLT_MAXLOAD,     // Upperbound on avg chain len
        DWORD    initsize=LK_DFLT_INITSIZE,   // Initial size of table: S/M/L
        DWORD    num_subtbls=LK_DFLT_NUM_SUBTBLS,// #subordinate hash tables.
        bool     fMultiKeys=false             // Allow multiple identical keys?
#ifdef LKRHASH_KERNEL_MODE
      , bool     fNonPagedAllocs=true         // use paged or NP pool in kernel
#endif
        )
        : _BaseHashTable(pszName, _ExtractKey, _CalcKeyHash, _EqualKeys,
                         _AddRefRecord, maxload, initsize, num_subtbls,
                         fMultiKeys
#ifdef LKRHASH_KERNEL_MODE
                          , fNonPagedAllocs
#endif
                         )
    {
        insert(f, l);
    }

    template <class _InputIterator>
    void insert(_InputIterator f, _InputIterator l)
    {
        for ( ;  f != l;  ++f)
            InsertRecord(&(*f));
    }

    bool
    Insert(
        const _Record* pRecord,
        iterator& riterResult,
        bool fOverwrite=false)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Insert\n"));
        return _BaseHashTable::Insert(pRecord, riterResult.m_iter, fOverwrite);
    }

    bool
    Erase(
        iterator& riter)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Erase\n"));
        return _BaseHashTable::Erase(riter.m_iter);
    }

    bool
    Erase(
        iterator& riterFirst,
        iterator& riterLast)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Erase2\n"));
        return _BaseHashTable::Erase(riterFirst.m_iter, riterLast.m_iter);
    }

    bool
    Find(
        const _Key key,
        iterator& riterResult)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Find\n"));
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return _BaseHashTable::Find(pnKey, riterResult.m_iter);
    }

    bool
    EqualRange(
        const _Key key,
        iterator& riterFirst,
        iterator& riterLast)
    {
        LKR_ITER_TRACE(_TEXT("Typed::EqualRange\n"));
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return _BaseHashTable::EqualRange(pnKey, riterFirst.m_iter,
                                          riterLast.m_iter);
    }

    // The iterator functions for an STL hash_(|multi)_(set|map)
    //
    // Value type of a Pair-Associative Container is
    //     pair<const key_type, mapped_type>
    //
    // pair<iterator,bool> insert(const value_type& x);
    //
    // void erase(iterator pos);
    // void erase(iterator f, iterator l);
    //
    // iterator find(const key_type& k) [const];
    // const_iterator find(const key_type& k) const;
    //
    // pair<iterator,iterator> equal_range(const key_type& k) [const];
    // pair<const_iterator,const_iterator> equal_range(const key_type& k) const


#endif // LKR_STL_ITERATORS
}; // class CTypedHashTable


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__


#endif // __LKRHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\inc\lstentry.h ===
/*++

   Copyright    (c)    1999-2000    Microsoft Corporation

   Module  Name :
       LstEntry.h

   Abstract:
       Declares CListEntry and other intrusive singly- and doubly-linked lists

   Author:
       George V. Reilly      (GeorgeRe)     02-Mar-1999

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __LSTENTRY_H__
#define __LSTENTRY_H__

#ifndef __LOCKS_H__
# include <Locks.h>
#endif // !__LOCKS_H__

#ifndef LSTENTRY_LOCK
 #ifdef LOCKS_KERNEL_MODE
  #define LSTENTRY_LOCK CKSpinLock
 #else // !LOCKS_KERNEL_MODE
  #define LSTENTRY_LOCK CSpinLock
  #endif // !LOCKS_KERNEL_MODE
#endif // !LSTENTRY_LOCK

// TODO:
// * Add STL-style iterators: begin(), end(), operator++(), etc
// * Templatize the lists, so that you can avoid the CONTAINING_RECORD goo

//--------------------------------------------------------------------
// CSingleListEntry: a node in a singly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CSingleListEntry
{
public:
    CSingleListEntry* Next;  // forward link
};



//--------------------------------------------------------------------
// A non-threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CSingleList
{
protected:
    CSingleListEntry m_sleHead; // external head node

public:
    CSingleList()
    {
        m_sleHead.Next = NULL;
    }

    ~CSingleList()
    {
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_sleHead.Next == NULL;
    }

    CSingleListEntry* const
    Pop()
    {
        CSingleListEntry* psle = m_sleHead.Next;

        if (psle != NULL)
            m_sleHead.Next = psle->Next;

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        psle->Next     = m_sleHead.Next;
        m_sleHead.Next = psle;
    }
};


//--------------------------------------------------------------------
// A threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedSingleList
{
protected:
    LSTENTRY_LOCK m_lock;
    CSingleList   m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedSingleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION

    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    CSingleListEntry* const
    Pop()
    {
        Lock();
        CSingleListEntry* const psle = m_list.Pop();
        Unlock();

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        Lock();
        m_list.Push(psle);
        Unlock();
    }
};



//--------------------------------------------------------------------
// CListEntry: a node in a circular doubly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CListEntry
{
public:
    CListEntry* Flink;  // forward link
    CListEntry* Blink;  // backward link
};


//--------------------------------------------------------------------
// A non-threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CDoubleList
{
protected:
    CListEntry  m_leHead; // external head node

public:
    CDoubleList()
    {
        m_leHead.Flink = m_leHead.Blink = &m_leHead;
    }

    ~CDoubleList()
    {
        IRTLASSERT(m_leHead.Flink != NULL  &&  m_leHead.Blink != NULL);
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_leHead.Flink == &m_leHead;
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        ple->Blink        = &m_leHead;
        ple->Flink        = m_leHead.Flink;
        ple->Flink->Blink = ple;
        m_leHead.Flink    = ple;
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        ple->Flink        = &m_leHead;
        ple->Blink        = m_leHead.Blink;
        ple->Blink->Flink = ple;
        m_leHead.Blink    = ple;
    }

    const CListEntry* const
    HeadNode() const
    {
        return &m_leHead;
    }

    CListEntry* const
    First() const
    {
        return m_leHead.Flink;
    }

    CListEntry* const
    RemoveHead()
    {
        CListEntry* ple = First();
        RemoveEntry(ple);
        return ple;
    }

    CListEntry* const
    Last() const
    {
        return m_leHead.Blink;
    }

    CListEntry* const
    RemoveTail()
    {
        CListEntry* ple = Last();
        RemoveEntry(ple);
        return ple;
    }

    static void
    RemoveEntry(
        CListEntry* const ple)
    {
        CListEntry* const pleOldBlink = ple->Blink;
        IRTLASSERT(pleOldBlink != NULL);
        CListEntry* const pleOldFlink = ple->Flink;
        IRTLASSERT(pleOldFlink != NULL);

        pleOldBlink->Flink = pleOldFlink;
        pleOldFlink->Blink = pleOldBlink;
    }
};


//--------------------------------------------------------------------
// A threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedDoubleList
{
protected:
    LSTENTRY_LOCK m_lock;
    CDoubleList   m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedDoubleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION
    
    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertHead(ple);
        Unlock();
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertTail(ple);
        Unlock();
    }

    // not threadsafe
    const CListEntry* const
    HeadNode() const
    {
        return m_list.HeadNode();
    }

    // not threadsafe
    CListEntry* const
    First()
    {
        return m_list.First();
    }

    CListEntry* const
    RemoveHead()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveHead();
        Unlock();
        return ple;
    }

    // not threadsafe
    CListEntry* const
    Last()
    {
        return m_list.Last();
    }

    CListEntry* const
    RemoveTail()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveTail();
        Unlock();
        return ple;
    }

    void
    RemoveEntry(
        CListEntry* const ple)
    {
        Lock();
        m_list.RemoveEntry(ple);
        Unlock();
    }
};


#ifndef CONTAINING_RECORD
//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) \
            ((type *)((PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)))

#endif // !CONTAINING_RECORD


#endif // __LSTENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\lkrdbg\lkrcust.cpp ===
#include "precomp.hxx"
#include "lkrcust.h"

enum {
    NAME_SIZE           = LKRHASH_NS::CLKRHashTable::NAME_SIZE,
};

LKR_CUST_EXTN*
FindLkrCustExtn(
    LPCSTR    cmdName,
    VOID*     lkrAddress,
    DWORD&    rdwSig)
{
    extern LKR_CUST_EXTN g_alce[];

    struct LKRheader {
        DWORD m_dwSignature;
        CHAR  m_szName[NAME_SIZE];
    };

    LKRheader lkrh;
    rdwSig = 0;
    
    if (!ReadMemory(lkrAddress, &lkrh, sizeof(lkrh), NULL) )
    {
        dprintf(DBGEXT ".%s: cannot read memory @ %p\n",
                cmdName, (PVOID) lkrAddress);

        return NULL;
    }

    rdwSig = lkrh.m_dwSignature;

    lkrh.m_szName[NAME_SIZE-1] = '\0';
    
    for (LKR_CUST_EXTN* plce = g_alce + 1;
         plce->m_pszTableName != NULL;
         ++plce)
    {
        if (strcmp(plce->m_pszTableName, lkrh.m_szName) == 0)
            return plce;
    }

    return &g_alce[0];  // Dummy methods
}



BOOL
WINAPI
Dummy_LKHT_Dump(
    IN LKRHASH_NS::CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    return TRUE;
}



BOOL
WINAPI
Dummy_LKLH_Dump(
    IN LKRHASH_NS::CLKRLinearHashTable* plht,
    IN INT                  nVerbose)
{
    return TRUE;
}



BOOL
WINAPI
Dummy_Record_Dump(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    dprintf("%p (%08x)\n", pvRecord, dwSignature);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\lkrdbg\lkrcust.h ===
#ifndef LKR_CUST_DECLARE_TABLE

#include "lkrhash.h"

#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
 using namespace LKRhash;
 typedef LKRhash::CLKRLinearHashTable CLinearHashTable;
 typedef LKRhash::CLKRHashTable       CHashTable;
#else
 #define LKRHASH_NS
 typedef CLKRLinearHashTable CLinearHashTable;
 typedef CLKRHashTable       CHashTable;
#endif // !__LKRHASH_NO_NAMESPACE__


typedef
BOOL
(CALLBACK * PFN_LKHT_DUMP)(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose);

typedef
BOOL
(CALLBACK * PFN_LKLH_DUMP)(
    IN CLKRLinearHashTable* plht,
    IN INT                  nVerbose);

typedef
BOOL
(CALLBACK * PFN_RECORD_DUMP)(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose);

struct LKR_CUST_EXTN {
    LPCSTR          m_pszTableName;
    PFN_LKHT_DUMP   m_pfn_LKHT_Dump;
    PFN_LKLH_DUMP   m_pfn_LKLH_Dump;
    PFN_RECORD_DUMP m_pfn_Record_Dump;
};

LKR_CUST_EXTN*
FindLkrCustExtn(
    LPCSTR    cmdName,
    VOID*     lkrAddress,
    DWORD&    rdwSig);

BOOL
EnumerateBucketChain(
    LKR_CUST_EXTN*    plce,
    IN LOCK_LOCKTYPE  ltBucketLockType,
    IN INT            iBkt,
    IN CBucket*       pbkt,
    IN INT            nVerbose);

BOOL
EnumerateLKRLinearHashTable(
    LKR_CUST_EXTN*       plce,
    IN CLinearHashTable* plht,
    IN INT               nVerbose);

BOOL
EnumerateLKRhashTable(
    LKR_CUST_EXTN*    plce,
    IN CHashTable*    pht,
    IN INT            nVerbose);



# define BEGIN_LKR_EXTN_TABLE()

# define LKR_EXTN_DECLARE(_TableStr, _Fn_LKHT_Dump, _Fn_LKLH_Dump, _Fn_Record_Dump) \
                                        \
extern                                  \
BOOL                                    \
WINAPI                                  \
_Fn_LKHT_Dump(                          \
    IN CLKRHashTable*   pht,            \
    IN INT              nVerbose);      \
                                        \
extern                                  \
BOOL                                    \
WINAPI                                  \
_Fn_LKLH_Dump(                          \
    IN CLKRLinearHashTable* plht,       \
    IN INT                  nVerbose);  \
                                        \
extern                                  \
BOOL                                    \
WINAPI                                  \
_Fn_Record_Dump(                        \
    IN const void* pvRecord,            \
    IN DWORD       dwSignature,         \
    IN INT         nVerbose);           \

# define END_LKR_EXTN_TABLE()


#else // LKR_CUST_DECLARE_TABLE


#undef BEGIN_LKR_EXTN_TABLE
#undef LKR_EXTN_DECLARE
#undef END_LKR_EXTN_TABLE


 #define BEGIN_LKR_EXTN_TABLE() \
    LKR_CUST_EXTN g_alce[] = {

 #define LKR_EXTN_DECLARE(_TableStr, _Fn_LKHT_Dump, _Fn_LKLH_Dump, _Fn_Record_Dump) \
        { #_TableStr, _Fn_LKHT_Dump, _Fn_LKLH_Dump, _Fn_Record_Dump }, 

 #define END_LKR_EXTN_TABLE()   \
        { 0, 0, 0, 0},          \
        };


#endif // LKR_CUST_DECLARE_TABLE



BEGIN_LKR_EXTN_TABLE()
  LKR_EXTN_DECLARE(?,
                   Dummy_LKHT_Dump,
                   Dummy_LKLH_Dump,
                   Dummy_Record_Dump)
  LKR_EXTN_DECLARE(wordhash,
                   CWordHash_LKHT_Dump,
                   CWordHash_LKLH_Dump,
                   CWordHash_RecordDump)
  LKR_EXTN_DECLARE(string,
                   CStringTest_TableDump,
                   Dummy_LKLH_Dump,
                   CTest_RecordDump)
  LKR_EXTN_DECLARE(NumberSet,
                   CNumberSet_TableDump,
                   Dummy_LKLH_Dump,
                   int_RecordDump)
  LKR_EXTN_DECLARE(number,
                   CNumberTest_TableDump,
                   Dummy_LKLH_Dump,
                   CTest_RecordDump)
  LKR_EXTN_DECLARE(VWtest,
                   CWchar_TableDump,
                   Dummy_LKLH_Dump,
                   Vwrecord_RecordDump)
END_LKR_EXTN_TABLE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\lkrdbg\minfan.cpp ===
#include "precomp.hxx"

#include "lkrcust.h"

#include "..\samples\minfan\minfan.h"

BOOL
WINAPI
CWchar_TableDump(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    return TRUE;
}



BOOL
WINAPI
Vwrecord_RecordDump(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    // Don't want to provide VwrecordBase ctor, so use CPP_VAR macros
    DEFINE_CPP_VAR(VwrecordBase, vwbr);
    VwrecordBase* pvwbr = GET_CPP_VAR_PTR(VwrecordBase, vwbr); 

    // Copy the VwrecordBase from the debuggee's memory
    ReadMemory(pvRecord, &vwbr, sizeof(vwbr), NULL);

    // Read the associated string from the debuggee's memory
    const int MAX_STR=4096;
    char sz[MAX_STR];
    ReadMemory(pvwbr->Key, sz, MAX_STR, NULL);
    sz[MAX_STR-1] = '\0';

    dprintf("%p (%08x): Key=\"%s\", m_num=%d, Refs=%d\n",
            pvRecord, dwSignature, sz, pvwbr->m_num, pvwbr->cRef);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\lkrdbg\dbglocks.cxx ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    dbglocks.cxx

Abstract:

    Locks support

Author:

    George V. Reilly (GeorgeRe)  01-Mar-1999

Revision History:

--*/

#include "precomp.hxx"

#ifdef LOCK_INSTRUMENTATION
# define LOCK_DEFAULT_NAME ("lkrdbg")
LONG CSmallSpinLock::sm_cTotalLocks     = 0;
LONG CSpinLock::sm_cTotalLocks          = 0;
LONG CReaderWriterLock::sm_cTotalLocks  = 0;
LONG CReaderWriterLock2::sm_cTotalLocks = 0;
LONG CReaderWriterLock3::sm_cTotalLocks = 0;
#else // !LOCK_INSTRUMENTATION
# define LOCK_DEFAULT_NAME 
#endif // !LOCK_INSTRUMENTATION

const char*
LockName(
    LOCK_LOCKTYPE lt)
{
    const char* pszName = NULL;

    switch (lt)
    {
    case LOCK_FAKELOCK:
        pszName = "CFakeLock";
        break;
    case LOCK_SMALLSPINLOCK:
        pszName = "CSmallSpinLock";
        break;
    case LOCK_SPINLOCK:
        pszName = "CSpinLock";
        break;
    case LOCK_CRITSEC:
        pszName = "CCritSec";
        break;
    case LOCK_READERWRITERLOCK:
        pszName = "CReaderWriterLock";
        break;
    case LOCK_READERWRITERLOCK2:
        pszName = "CReaderWriterLock2";
        break;
    case LOCK_READERWRITERLOCK3:
        pszName = "CReaderWriterLock3";
        break;
#ifdef LOCKS_KERNEL_MODE
    case LOCK_KSPINLOCK:
        pszName = "CKSpinLock";
        break;
    case LOCK_FASTMUTEX:
        pszName = "CFastMutex";
        break;
    case LOCK_ERESOURCE:
        pszName = "CEResource";
        break;
#endif // LOCKS_KERNEL_MODE
    default:
        pszName = "UnknownLockType";
        break;
    }

    return pszName;
};

int
LockSize(
    LOCK_LOCKTYPE lt)
{
    int cb = 0;

    switch (lt)
    {
    case LOCK_FAKELOCK:
        cb = sizeof(CFakeLock);
        break;
    case LOCK_SMALLSPINLOCK:
        cb = sizeof(CSmallSpinLock);
        break;
    case LOCK_SPINLOCK:
        cb = sizeof(CSpinLock);
        break;
    case LOCK_CRITSEC:
        cb = sizeof(CCritSec);
        break;
    case LOCK_READERWRITERLOCK:
        cb = sizeof(CReaderWriterLock);
        break;
    case LOCK_READERWRITERLOCK2:
        cb = sizeof(CReaderWriterLock2);
        break;
    case LOCK_READERWRITERLOCK3:
        cb = sizeof(CReaderWriterLock3);
        break;
#ifdef LOCKS_KERNEL_MODE
    case LOCK_KSPINLOCK:
        cb = sizeof(CKSpinLock);
        break;
    case LOCK_FASTMUTEX:
        cb = sizeof(CFastMutex);
        break;
    case LOCK_ERESOURCE:
        cb = sizeof(CEResource);
        break;
#endif // LOCKS_KERNEL_MODE
    default:
        cb = 0;
        break;
    }

    return cb;
};



BOOL
Print_FakeLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    return TRUE;
}



BOOL
Print_SmallSpinLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CSmallSpinLock sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CSmallSpinLock (%p): Thread = %x\n",
            pvLock, sl.m_lTid);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_SpinLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CSpinLock sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CSpinLock (%p): Thread = %d, Count = %d\n",
            pvLock,
            (sl.m_lTid & CSpinLock::SL_THREAD_MASK)
                >> CSpinLock::SL_THREAD_SHIFT,
            (sl.m_lTid & CSpinLock::SL_OWNER_MASK)
                >> CSpinLock::SL_OWNER_SHIFT);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_CritSec(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    return TRUE;
}



BOOL
Print_ReaderWriterLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CReaderWriterLock sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CReaderWriterLock (%p): State = %x, Waiters = %d\n",
            pvLock, sl.m_nState, sl.m_cWaiting);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_ReaderWriterLock2(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CReaderWriterLock2 sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CReaderWriterLock2 (%p): State = %x, Waiters = %d\n",
            pvLock,
            (sl.m_lRW & CReaderWriterLock2::SL_STATE_MASK)
                >> CReaderWriterLock2::SL_STATE_SHIFT,
            (sl.m_lRW & CReaderWriterLock2::SL_WAITING_MASK)
                >> CReaderWriterLock2::SL_WAITING_SHIFT
            );
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_ReaderWriterLock3(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CReaderWriterLock3 sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CReaderWriterLock3 (%p): State = %x, Waiters = %d, "
            "Thrd = %x, Cnt = %d\n",
            pvLock,
            (sl.m_lRW & CReaderWriterLock3::SL_STATE_MASK)
                >> CReaderWriterLock3::SL_STATE_SHIFT,
            (sl.m_lRW & CReaderWriterLock3::SL_WAITING_MASK)
                >> CReaderWriterLock3::SL_WAITING_SHIFT,
            (sl.m_lTid & CReaderWriterLock3::SL_THREAD_MASK)
                >> CReaderWriterLock3::SL_THREAD_SHIFT,
            (sl.m_lTid & CReaderWriterLock3::SL_OWNER_MASK)
                >> CReaderWriterLock3::SL_OWNER_SHIFT
            );
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



#ifdef LOCKS_KERNEL_MODE

BOOL
Print_KSpinLock(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CKSpinLock sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CKSpinLock (%p): \n",
            pvLock);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_FastMutex(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CFastMutex sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CFastMutex (%p): \n",
            pvLock);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}



BOOL
Print_EResource(
    IN PVOID pvLock,
    IN INT nVerbose)
{
    CEResource sl LOCK_DEFAULT_NAME;

    ReadMemory(pvLock, &sl, sizeof(sl), NULL);
    dprintf("CEResource (%p): \n",
            pvLock);
    memset(&sl, 0, sizeof(sl));

    return TRUE;
}

#endif // LOCKS_KERNEL_MODE



BOOL
PrintLock(
    LOCK_LOCKTYPE lt,
    IN PVOID      pvLock,
    IN INT        nVerbose)
{
    BOOL f = FALSE;
    switch (lt)
    {
    case LOCK_FAKELOCK:
        f = Print_FakeLock(pvLock, nVerbose);
        break;
    case LOCK_SMALLSPINLOCK:
        f = Print_SmallSpinLock(pvLock, nVerbose);
        break;
    case LOCK_SPINLOCK:
        f = Print_SpinLock(pvLock, nVerbose);
        break;
    case LOCK_CRITSEC:
        f = Print_CritSec(pvLock, nVerbose);
        break;
    case LOCK_READERWRITERLOCK:
        f = Print_ReaderWriterLock(pvLock, nVerbose);
        break;
    case LOCK_READERWRITERLOCK2:
        f = Print_ReaderWriterLock2(pvLock, nVerbose);
        break;
    case LOCK_READERWRITERLOCK3:
        f = Print_ReaderWriterLock3(pvLock, nVerbose);
        break;
#ifdef LOCKS_KERNEL_MODE
    case LOCK_KSPINLOCK:
        f = Print_KSpinLock(pvLock, nVerbose);
        break;
    case LOCK_FASTMUTEX:
        f = Print_FastMutex(pvLock, nVerbose);
        break;
    case LOCK_ERESOURCE:
        f = Print_EResource(pvLock, nVerbose);
        break;
#endif // LOCKS_KERNEL_MODE
    default:
        f = FALSE;
        break;
    }

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\lkrdbg\dbglkrh.cxx ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    dbglkrh.cxx

Abstract:

    LKRhash support

Author:

    George V. Reilly (GeorgeRe)  22-Feb-1999

Revision History:

--*/

#include "precomp.hxx"

#include "lkrcust.h"

#define LKR_CUST_DECLARE_TABLE
#include "lkrcust.h"

#include <i-lkrhash.h>

#ifdef LOCK_INSTRUMENTATION
LONG CLKRLinearHashTable::CBucket::sm_cBuckets = 0;
LONG CLKRLinearHashTable::sm_cTables           = 0;
#endif // LOCK_INSTRUMENTATION

#define CMDNAME "lkrhash"

// There are several different DLLs in the IISRTL family. This is to
// allow us to set the name of the DLL on the fly.
// TODO: add a command to set this name dynamically.

#ifndef LKRHASH_NAME
# define LKRHASH_NAME "LKRhash"
#endif // LKRHASH_NAME

CHAR g_szLKRhashDllName[MAX_PATH] = LKRHASH_NAME;

// sprintf-formatted string, e.g., "&%s!CLKRHashTable__sm_llGlobalList"
// Has to return LPSTR, not LPCSTR, because GetExpression is not const-correct
LPSTR
LKRhashDllVar(
    LPCSTR pszFormat)
{
    // we can get away with a static CHAR[] because debugger extensions
    // are single-threaded
    static CHAR szSymbol[MAX_SYMBOL_LEN];

    sprintf(szSymbol, pszFormat, g_szLKRhashDllName);
    return szSymbol;
}

#ifndef __LKRHASH_NO_NAMESPACE__
 #define STR_LKRHASH_NS "LKRhash__"
#else
 #define STR_LKRHASH_NS ""
#endif // !__LKRHASH_NO_NAMESPACE__



/************************************************************
 * Dump LKRhash tables
 ************************************************************/
const char*
LKRC2String(
    LK_RETCODE lkrc)
{
    const char* psz = NULL;

    switch (lkrc)
    {
    case LK_UNUSABLE:
        psz = "LK_UNUSABLE";
        break;
    case LK_ALLOC_FAIL:
        psz = "LK_ALLOC_FAIL";
        break;
    case LK_BAD_ITERATOR:
        psz = "LK_BAD_ITERATOR";
        break;
    case LK_BAD_RECORD:
        psz = "LK_BAD_RECORD";
        break;
    case LK_BAD_PARAMETERS:
        psz = "LK_BAD_PARAMETERS";
        break;
    case LK_NOT_INITIALIZED:
        psz = "LK_NOT_INITIALIZED";
        break;
    case LK_BAD_TABLE:
        psz = "LK_BAD_TABLE";
        break;
    case LK_SUCCESS:
        psz = "LK_SUCCESS";
        break;
    case LK_KEY_EXISTS:
        psz = "LK_KEY_EXISTS";
        break;
    case LK_NO_SUCH_KEY:
        psz = "LK_NO_SUCH_KEY";
        break;
    case LK_NO_MORE_ELEMENTS:
        psz = "LK_NO_MORE_ELEMENTS";
        break;
    default:
        psz = "Unknown LK_RETCODE";
        break;
    }

    return psz;
}


enum {
    NODES_PER_CLUMP = CNodeClump::NODES_PER_CLUMP,
    BUCKET_BYTE_SIZE = CNodeClump::BUCKET_BYTE_SIZE,
    HASH_INVALID_SIGNATURE =
        LKRHASH_NS::CLKRLinearHashTable::HASH_INVALID_SIGNATURE,
    LKLH_SIGNATURE =      LKRHASH_NS::CLKRLinearHashTable::SIGNATURE,
    LKLH_SIGNATURE_FREE = LKRHASH_NS::CLKRLinearHashTable::SIGNATURE_FREE,
    LKHT_SIGNATURE =      LKRHASH_NS::CLKRHashTable::SIGNATURE,
    LKHT_SIGNATURE_FREE = LKRHASH_NS::CLKRHashTable::SIGNATURE_FREE,
};


BOOL
EnumerateBucketChain(
    LKR_CUST_EXTN*    plce,
    IN LOCK_LOCKTYPE  ltBucketLockType,
    IN INT            iBkt,
    IN CBucket*       pbkt,
    IN INT            nVerbose)
{
    PSTR        cmdName = CMDNAME;
    BYTE        abBkt[BUCKET_BYTE_SIZE];
    DEFINE_CPP_VAR(CNodeClump, nc);
    CNodeClump* pnc = GET_CPP_VAR_PTR(CNodeClump, nc);
    CNodeClump* pncCurr;
    DWORD       cNodes = 0, cnc = 0;
    BOOL        fLockPrinted = FALSE;

    ReadMemory(pbkt, abBkt, sizeof(abBkt), NULL);

    // Just in case lkrdbg.dll and lkrhash.dll were built with different
    // definitions for BucketLock, we make no assumptions about the size
    // of BucketLock
    for (pncCurr = (CNodeClump*) ((PBYTE) pbkt + LockSize(ltBucketLockType));
         pncCurr != NULL;
         pncCurr = pnc->m_pncNext)
    {
        DWORD i, c;

        ReadMemory(pncCurr, &nc, sizeof(nc), NULL);

        for (i = c = 0;  i < NODES_PER_CLUMP;  i++)
        {
            if (pnc->m_dwKeySigs[i] == HASH_INVALID_SIGNATURE)
                c++;
        }

        if (c == NODES_PER_CLUMP)
        {
            if (nVerbose >= 3)
                dprintf("  0-%d: -- empty\n", NODES_PER_CLUMP);
        }
        else
        {
            if (cnc++ == 0)
                PrintLock(ltBucketLockType, &pbkt->m_Lock, nVerbose);
            
            dprintf("Bucket %4d, %d:\n", iBkt, cnc);
            for (i = 0;  i < NODES_PER_CLUMP;  i++)
            {
                if (pnc->m_dwKeySigs[i] == HASH_INVALID_SIGNATURE)
                {
                    if (nVerbose >= 3)
                        dprintf("  %d: --\n", i);
                    else
                        break;
                }
                else if (plce != NULL)
                {
                    if (!(*plce->m_pfn_Record_Dump)(pnc->m_pvNode[i],
                                                    pnc->m_dwKeySigs[i],
                                                    nVerbose))
                        return FALSE;
                }
            }
        }

        if (CheckControlC())
        {
            dprintf("\n^C\n");
            return FALSE;
        }

        const DWORD MAX_NODES = 20;
        if (++cNodes > MAX_NODES)
        {
            dprintf(DBGEXT ".%s: Bucket chain contains more than %d nodes! "
                    "Corrupted?\n", cmdName, MAX_NODES);
            return TRUE;
        }
    }

    return TRUE;
}



BOOL
EnumerateLKRLinearHashTable(
    LKR_CUST_EXTN*       plce,
    IN CLinearHashTable* plht,
    IN INT               nVerbose)
{
    PSTR cmdName = CMDNAME;
    DEFINE_CPP_VAR(CLinearHashTable, lht);
    CLinearHashTable* plht2 = GET_CPP_VAR_PTR(CLinearHashTable, lht);
    INT i;
    BOOL fRet = FALSE;
    LOCK_LOCKTYPE ltTableLockType  = LOCK_SPINLOCK;
    LOCK_LOCKTYPE ltBucketLockType = LOCK_SPINLOCK;
    CDirEntry* paDirSegs = NULL;

    //
    // Read the header, perform some sanity checks.
    //

    if (!ReadMemory(plht, &lht, sizeof(lht), NULL) )
    {
        dprintf(DBGEXT ".%s: cannot read memory @ %p\n",
                cmdName, (PVOID)plht);

        goto cleanup;
    }

    dprintf(
        "\n" DBGEXT ".%s: @ %p:\n"
        "    CLKRLinearHashTable Signature = %08lx '%c%c%c%c' (%s), \"%s\",\n"
        "    State = %d (%s)\n",
        cmdName,
        plht,
        plht2->m_dwSignature,
        DECODE_SIGNATURE(plht2->m_dwSignature),
        plht2->m_dwSignature == LKLH_SIGNATURE
            ? "OK" : (plht2->m_dwSignature == LKLH_SIGNATURE_FREE
                      ? "FREED" : "INVALID"),
        plht2->m_szName,
        plht2->m_lkrcState, LKRC2String(plht2->m_lkrcState));

    if (nVerbose == 0)
        goto done;

    ltTableLockType  = (LOCK_LOCKTYPE) plht2->m_nTableLockType;
    ltBucketLockType = (LOCK_LOCKTYPE) plht2->m_nBucketLockType;
    dprintf(
        "    TableLock = %s, BucketLock = %s, Parent CLKRHashTable = %p\n",
        LockName(ltTableLockType),
        LockName(ltBucketLockType),
        plht2->m_phtParent);

    dprintf(
        "    Size = %d, SegBits = %d, SegSize = %d, SegMask = %x\n",
        plht2->m_lkts, plht2->m_dwSegBits,
        plht2->m_dwSegSize, plht2->m_dwSegMask);
    dprintf(
        "    MaxLoad = %3.1f, paDirSegs = %p, cDirSegs = %d\n",
        plht2->m_MaxLoad, plht2->m_paDirSegs, plht2->m_cDirSegs);
    dprintf(
        "    cRecords = %d, cActiveBuckets = %d, BucketSpins = %hd\n",
        plht2->m_cRecords, plht2->m_cActiveBuckets, plht2->m_wBucketLockSpins);
    dprintf(
        "    nLevel = %d, dwBktAddrMask0 = %x, iExpansionIdx = %d\n",
        plht2->m_nLevel, plht2->m_dwBktAddrMask0, plht2->m_iExpansionIdx);

    PrintLock(ltTableLockType, &plht->m_Lock, nVerbose);

    if (plce != NULL  &&  !(*plce->m_pfn_LKLH_Dump)(plht, nVerbose))
        goto done;
    
    if (nVerbose == 1)
        goto done;
    
    paDirSegs = (CDirEntry*) calloc(plht2->m_cDirSegs, sizeof(CDirEntry));

    if (paDirSegs == NULL)
    {
        dprintf("Couldn't allocate %d bytes for directory segment\n",
                plht2->m_cDirSegs * sizeof(CDirEntry));
        return fRet;
    }
    
    if (!ReadMemory(plht2->m_paDirSegs, paDirSegs,
                    sizeof(CDirEntry) * plht2->m_cDirSegs, NULL))
        goto cleanup;

    for (i = 0;  i < (INT) (plht2->m_cDirSegs * plht2->m_dwSegSize);  i++)
    {
        const DWORD iSeg = i >> plht2->m_dwSegBits;
        CLargeSegment* pseg =
            static_cast<CLargeSegment*>(paDirSegs[iSeg].m_pseg);

        if ((i & plht2->m_dwSegMask) == 0)
            dprintf("Segment %d: %p\n", iSeg, pseg);

        if (pseg == NULL)
            continue;

        if (nVerbose >= 2)
        {
            CBucket* pbkt = pseg->m_bktSlots + (i & plht2->m_dwSegMask);
            
            if (!EnumerateBucketChain(plce, ltBucketLockType,
                                      i, pbkt, nVerbose))
                goto cleanup;
        }

		if (CheckControlC())
        {
			dprintf("\n^C\n");
            goto cleanup;
        }
    }

  done:
    fRet = TRUE;

  cleanup:
    memset(&lht, 0, sizeof(lht));
    free(paDirSegs);
    return fRet;
}



BOOL
EnumerateLKRhashTable(
    LKR_CUST_EXTN*    plce,
    IN CHashTable*    pht,
    IN INT            nVerbose)
{
    DEFINE_CPP_VAR(CHashTable, ht);
    CHashTable* pht2 = GET_CPP_VAR_PTR(CHashTable, ht);
    PSTR cmdName = CMDNAME;
    CLinearHashTable** palhtDir = NULL;
    UINT i;
    BOOL fRet = FALSE;

    //
    // Read the header, perform some sanity checks.
    //

    if (!ReadMemory(pht, &ht, sizeof(ht), NULL) )
    {
        dprintf(DBGEXT ".%s: cannot read memory @ %p\n",
                cmdName, (PVOID)pht);

        goto cleanup;
    }

    dprintf(
        DBGEXT ".%s: @ %p:\n"
        "    CLKRHashTable Signature = %08lx '%c%c%c%c' (%s), \"%s\",\n"
        "    %d subtables, State = %d (%s)\n",
        cmdName,
        pht,
        pht2->m_dwSignature,
        DECODE_SIGNATURE(pht2->m_dwSignature),
        pht2->m_dwSignature == LKHT_SIGNATURE
            ? "OK"
            : pht2->m_dwSignature == LKHT_SIGNATURE_FREE
              ? "FREED"
              : "INVALID",
        pht2->m_szName,
        pht2->m_cSubTables,
        pht2->m_lkrcState, LKRC2String(pht2->m_lkrcState)
        );

    if (plce != NULL  &&  !(*plce->m_pfn_LKHT_Dump)(pht, nVerbose))
        goto done;
    
    if (nVerbose == 0)
        goto done;

    palhtDir = (CLinearHashTable**) calloc(pht2->m_cSubTables,
                                           sizeof(CLinearHashTable*));
    if (!palhtDir)
        goto cleanup;
    
    if (!ReadMemory(pht2->m_palhtDir, palhtDir,
                    pht2->m_cSubTables * sizeof(CLinearHashTable*), NULL))
        goto cleanup;

    for (i = 0;  i < pht2->m_cSubTables;  ++i)
    {
        dprintf("\n%d : ", i);
        if (!EnumerateLKRLinearHashTable(plce, palhtDir[i], nVerbose))
            break;

		if (CheckControlC())
        {
			dprintf("\n^C\n");
            goto cleanup;
        }
    }

  done:
    fRet = TRUE;
    
  cleanup:
    free(palhtDir);

    return fRet;
}



VOID
PrintLKRLinearHashTableThunk(
    PVOID psdDebuggee,
    PVOID psdDebugger,
    CHAR  chVerbosity,
    DWORD iThunk)
{
    DWORD dwSig = ((CLinearHashTable*) psdDebugger)->m_dwSignature;

    if (dwSig != LKLH_SIGNATURE)
    {
        dprintf( "CLKRLinearHashTable(%08p) signature %08lx '%c%c%c%c' doesn't"
                 " match expected: %08lx '%c%c%c%c'\n",
                 psdDebuggee, dwSig, DECODE_SIGNATURE(dwSig),
                 LKLH_SIGNATURE, DECODE_SIGNATURE(LKLH_SIGNATURE)
                 );
        return;
    }

    LKR_CUST_EXTN* plce = FindLkrCustExtn(CMDNAME, psdDebuggee, dwSig);

    if (plce != NULL)
        EnumerateLKRLinearHashTable(plce,
                                    (CLinearHashTable*) psdDebuggee,
                                    chVerbosity);
}



VOID
PrintLKRHashTableThunk(
    PVOID psdDebuggee,
    PVOID psdDebugger,
    CHAR  chVerbosity,
    DWORD iThunk)
{
    DWORD dwSig = ((CHashTable*) psdDebugger)->m_dwSignature;
    if (dwSig != LKHT_SIGNATURE)
    {
        dprintf( "CLKRHashTable(%08p) signature %08lx '%c%c%c%c' doesn't"
                 " match expected: %08lx '%c%c%c%c'\n",
                 psdDebuggee,
                 dwSig, DECODE_SIGNATURE(dwSig),
                 LKHT_SIGNATURE, DECODE_SIGNATURE(LKHT_SIGNATURE)
                 );
        return;
    }

    LKR_CUST_EXTN* plce = FindLkrCustExtn(CMDNAME, psdDebuggee, dwSig);

    if (plce != NULL)
        EnumerateLKRhashTable(plce, (CHashTable*) psdDebuggee,
                              chVerbosity);
}



VOID
DumpLKRsList(
    IN INT              nVerbose)
{
#ifndef LKR_NO_GLOBAL_LIST
    CLockedDoubleList* plstHashTables = (CLockedDoubleList*) GetExpression(
                        LKRhashDllVar("&%s!" STR_LKRHASH_NS
                                      "CLKRHashTable__sm_llGlobalList"));

    if (NULL == plstHashTables)
    {
        dprintf("Unable to get %s\n",
                LKRhashDllVar("%s!" STR_LKRHASH_NS
                              "CLKRHashTable__sm_llGlobalList"));
        return;
    }

    dprintf("\nGlobal List of CLKRHashTables\n");

    EnumLinkedList( (LIST_ENTRY*) &plstHashTables->m_list.m_leHead,
                    PrintLKRHashTableThunk,
                    (CHAR) nVerbose,
                    sizeof(CHashTable),
                    FIELD_OFFSET( CHashTable, m_leGlobalList));


    plstHashTables = (CLockedDoubleList*) GetExpression(
                      LKRhashDllVar("&%s!" STR_LKRHASH_NS
                                    "CLKRLinearHashTable__sm_llGlobalList"));

    if (NULL == plstHashTables)
    {
        dprintf("Unable to get %s\n",
                LKRhashDllVar("!" STR_LKRHASH_NS
                              "CLKRLinearHashTable__sm_llGlobalList"));
        return;
    }

    dprintf("\nGlobal List of CLKRLinearHashTables\n");

    EnumLinkedList( (LIST_ENTRY*) &plstHashTables->m_list.m_leHead,
                    PrintLKRLinearHashTableThunk,
                    (CHAR) nVerbose,
                    sizeof(CLinearHashTable),
                    FIELD_OFFSET( CLinearHashTable, m_leGlobalList));
#endif // !LKR_NO_GLOBAL_LIST
    return;
} // DumpLKRsList()





DECLARE_API( lkrhash )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an LKRhash table.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    INIT_API();

    ULONG_PTR lkrAddress = 0;
    INT nVerbose = 0;
    PSTR cmdName = CMDNAME;

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        PrintUsage( cmdName );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        if ( *lpArgumentString == 'h' )
        {
            PrintUsage( cmdName );
            return;
        }

        if ( *lpArgumentString == 'l' ) {
            lpArgumentString++;
            if ('0' <= *lpArgumentString  &&  *lpArgumentString <= '9' ) {
                nVerbose = *lpArgumentString++ - '0';
            }
        }

        if ( *lpArgumentString == 'v' )
        {
            lpArgumentString++;
            nVerbose = 99;
        }

        if ( *lpArgumentString == 'g' )
        {
            lpArgumentString++;
            if ('0' <= *lpArgumentString  &&  *lpArgumentString <= '9' ) {
                nVerbose = *lpArgumentString++ - '0';
            }
            DumpLKRsList(nVerbose);
            return;
        }

    }

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    lkrAddress = (ULONG_PTR) GetExpression( lpArgumentString );

    if (lkrAddress == 0) {

        dprintf(
            DBGEXT ".%s: cannot evaluate \"%s\"\n",
            cmdName,
            lpArgumentString
            );

        return;

    }

    //
    // Skip to end of expression, then skip any blanks.
    //

    while( *lpArgumentString != ' ' &&
           *lpArgumentString != '\t' &&
           *lpArgumentString != '\0' ) {
        lpArgumentString++;
    }

    DWORD dwSig;
    LKR_CUST_EXTN* plce = FindLkrCustExtn(CMDNAME, (VOID*) lkrAddress, dwSig);

    if (plce == NULL)
        goto cleanup;
    
    if (dwSig == LKHT_SIGNATURE || dwSig == LKHT_SIGNATURE_FREE)
    { 
        EnumerateLKRhashTable(plce,
                              (CHashTable*) lkrAddress,
                              nVerbose);
    }
    else if (dwSig == LKLH_SIGNATURE || dwSig == LKLH_SIGNATURE_FREE)
    { 
        EnumerateLKRLinearHashTable(plce,
                                    (CLinearHashTable*) lkrAddress,
                                    nVerbose);
    }
    else
    {
        dprintf(DBGEXT ".%s: %p does not contain a valid LKRhash table\n",
                cmdName, (PVOID)lkrAddress);
    }
    
cleanup:
    return;
} // DECLARE_API( lkrhash )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\lkrdbg\numset.cpp ===
#include "precomp.hxx"

#include "lkrcust.h"

#include "..\samples\numset\numset.h"

BOOL
WINAPI
CNumberSet_TableDump(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    return TRUE;
}



BOOL
WINAPI
int_RecordDump(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    int test;

    // Copy the CTest from the debuggee's memory
    ReadMemory(pvRecord, &test, sizeof(test), NULL);

    dprintf("%p (%08x): n=%d\n",
            pvRecord, dwSignature, test);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\lkrdbg\help.cxx ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    help.cxx

Abstract:

    This module contains the help text for all commands supported by this
    NTSD debugger extension.

Author:

    Keith Moore (keithmo) 12-Nov-1997

Revision History:

--*/

#include "precomp.hxx"

//
// The following structure defines the text displayed in response
// to the "!help" command. This text may also be displayed if invalid
// arguments are passed to a command.
//

typedef struct _HELP_MAP {

    //
    // This is the name of the command.
    //

    PSTR Command;

    //
    // This is a "one-liner" displayed when the user executes "!help".
    //

    PSTR OneLiner;

    //
    // This is the full help text displayed when the user executes
    // "!help <cmd>".
    //

    PSTR FullHelp;

} HELP_MAP, *PHELP_MAP;

HELP_MAP HelpMaps[] =
    {
        {
            "help",
            "Dump this list or help for specific command",
            "help [<cmd>] - Dump help for command\n"
            "  If no <cmd> is given, a list of all available commands is displayed\n"
        },

        {
            "lkrhash",
            "Dump LKRhash table structures",
            "!lkrhash [options] <addr>    - Dump LKRhash table at <addr>\n"
             "     -l[0-2] == verbosity level\n"
             "     -v      == very verbose\n"
             "     -g[0-2] == dump global list of LKRhashes at verbosity level\n"
        },

    };

#define NUM_HELP_MAPS ( sizeof(HelpMaps) / sizeof(HelpMaps[0]) )


PSTR
FindHelpForCommand(
    IN PSTR CommandName
    )
{

    PHELP_MAP helpMap;
    ULONG i;

    for( i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++ ) {
        if( _stricmp( helpMap->Command, CommandName ) == 0 ) {
            return helpMap->FullHelp;
        }
    }

    return NULL;

}   // FindHelpForCommand

VOID
PrintUsage(
    IN PSTR CommandName
    )
{

    PSTR cmdHelp;
    PHELP_MAP helpMap;
    ULONG i;
    ULONG maxLength;
    ULONG length;

    dprintf( "IIS debugging extension for IIS Version 5.0\n" );

    if( CommandName == NULL ) {

        //
        // We'll display the one-liners for each command. Start by
        // scanning the commands to find the longest length. This makes the
        // output much prettier without having to manually tweak the
        // columns.
        //

        maxLength = 0;

        for( i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++ ) {
            length = (ULONG)strlen( helpMap->Command );
            if( length > maxLength ) {
                maxLength = length;
            }
        }

        //
        // Now actually display the one-liners.
        //

        for( i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++ ) {
            dprintf(
                "!%-*s - %s\n",
                maxLength,
                helpMap->Command,
                helpMap->OneLiner
                );
        }

    } else {

        //
        // Find a specific command and display the full help.
        //

        cmdHelp = FindHelpForCommand( CommandName );

        if( cmdHelp == NULL ) {
            dprintf( "unrecognized command %s\n", CommandName );
        } else {
            dprintf( "%s", cmdHelp );
        }

    }

} // PrintUsage()


DECLARE_API( help )
{

    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( !strcmp( lpArgumentString, "?" ) ) {
        lpArgumentString = "help";
    }

    if( *lpArgumentString == '\0' ) {
        lpArgumentString = NULL;
    }

    PrintUsage( lpArgumentString );

} // DECLARE_API( help )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\lkrdbg\main.cxx ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    Misc utilities

Author:

    Murali R. Krishnan    ( MuraliK )     24-Aug-1997

Revision History:

--*/

#include "precomp.hxx"


NTSD_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;


# define minSize(a, b)  (((a) < (b)) ? (a) : (b))

/************************************************************
 *    Utility Functions
************************************************************/

VOID
dstring( CHAR * pszName, PVOID pvString, DWORD cbLen)
/*++
  Description:
    This function reads the data from the debuggee process at
    address [pvString] for specified length [cbLen] and echoes
    the string back on the debugger window.

  Arguments:
    pszName - pointer to string containing the name of the string read
    pvString - pointer to VOID specifying the location of the string
               in the debugee process
    cbLen   - count of bytes to be read at [pvString]

  Returns:
     None
--*/
{
    CHAR rgchString[10240];
    DWORD cLength = minSize( cbLen, sizeof(rgchString) -1);

    //
    // Read the data block from the debuggee process into local buffer
    //
    moveBlock( rgchString, pvString, cLength);

    rgchString[cLength] = '\0'; // terminate the string buffer
    dprintf( "%s = %s\n", pszName, rgchString);

    return;
} // dstring()



VOID
Print2Dwords( CHAR * pszN1, DWORD d1,
              CHAR * pszN2, DWORD d2
              )
{
    dprintf("    %25s =%8d  %25s =%8d\n",
             pszN1, d1,
             pszN2, d2
             );
    return;
} // Print2Dwords()



BOOL
EnumLinkedList(
    IN LIST_ENTRY  *       pListHead,
    IN PFN_LIST_ENUMERATOR pfnListEnumerator,
    IN CHAR                chVerbosity,
    IN DWORD               cbSizeOfStructure,
    IN DWORD               cbListEntryOffset
    )
/*++
  Description:
    This function iterates over the NT's standard LIST_ENTRY structure
    (doubly linked circular list with header) and makes callbacks for
    objects found on the list.

  Arguments:
    pListHead  - pointer to List head in the debugee process
    pfnListEnumerator - pointer to callback function for the object on the list
    chVerbosity - character indicating the verbosity level desired
    cbSizeOfStructure - count of bytes of object's size
    cbListEntryOffset - count of bytes of offset of the List entry structure
                           inside the containing object

  Returns:
     TRUE on successful enumeration
     FALSE on failure
--*/
{
# define MAX_STRUCTURE_SIZE        (10240)
    CHAR           rgch[MAX_STRUCTURE_SIZE];
    PVOID          pvDebuggee = NULL;
    PVOID          pvDebugger = (PVOID ) rgch;

    LIST_ENTRY     leListHead;
    LIST_ENTRY *   pListEntry;

    DWORD          cItems = 0;

    if ( NULL == pListHead) {
        dprintf( "Invalid List given \n");
        return (FALSE);
    }

    if ( MAX_STRUCTURE_SIZE < cbSizeOfStructure) {
        dprintf( "Given size for structure %d exceeds default max %d bytes\n",
                 cbSizeOfStructure, MAX_STRUCTURE_SIZE);
        return (FALSE);
    }

    // make a local copy of the list head for navigation purposes
    MoveWithRet( leListHead, pListHead, FALSE);

    for ( pListEntry  = leListHead.Flink;
          pListEntry != pListHead;
          )
    {
        if ( CheckControlC() )
        {
            return (FALSE);
        }

        pvDebuggee = (PVOID ) ((PCHAR ) pListEntry - cbListEntryOffset);

        // make a local copy of the debuggee structure
        MoveBlockWithRet( rgch, pvDebuggee, cbSizeOfStructure, FALSE);

        cItems++;

        if( pfnListEnumerator ) {
            (*pfnListEnumerator)( pvDebuggee, pvDebugger, chVerbosity, cItems);
            dprintf( "\n");
        }

        MoveWithRet( pListEntry, &pListEntry->Flink, FALSE );
    } // for all linked list entries

    dprintf( "%d entries traversed\n", cItems );

    return (TRUE);
} // EnumLinkedList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\lkrdbg\str-num.cpp ===
#include "precomp.hxx"

#include "lkrcust.h"

#include "..\samples\str-num\str-num.h"

BOOL
WINAPI
CStringTest_TableDump(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    return TRUE;
}



BOOL
WINAPI
CNumberTest_TableDump(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    return TRUE;
}



BOOL
WINAPI
CTest_RecordDump(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    // Don't want to provide CTest ctor, so use CPP_VAR macros
    DEFINE_CPP_VAR(CTest, test);
    CTest* pTest = GET_CPP_VAR_PTR(CTest, test); 

    // Copy the CTest from the debuggee's memory
    ReadMemory(pvRecord, &test, sizeof(test), NULL);

    dprintf("%p (%08x): m_n=%d, m_sz=\"%s\", m_fWhatever=%d, m_cRefs=%d\n",
            pvRecord, dwSignature, pTest->m_n, pTest->m_sz,
            (int) pTest->m_fWhatever, pTest->m_cRefs);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\lkrdbg\wordhash.cpp ===
#include "precomp.hxx"

#include "lkrcust.h"

#include "..\samples\hashtest\wordhash.h"

BOOL
WINAPI
CWordHash_LKHT_Dump(
    IN CLKRHashTable*   pht,
    IN INT              nVerbose)
{
    dprintf("CWordHash\n");
    return TRUE;
}



BOOL
WINAPI
CWordHash_LKLH_Dump(
    IN CLKRLinearHashTable* plht,
    IN INT                  nVerbose)
{
    dprintf("CWordHash\n");
    return TRUE;
}



BOOL
WINAPI
CWordHash_RecordDump(
    IN const void* pvRecord,
    IN DWORD       dwSignature,
    IN INT         nVerbose)
{
    // Don't want to provide CWord ctor, so use CPP_VAR macros
    DEFINE_CPP_VAR(CWord, word);
    CWord* pWord = GET_CPP_VAR_PTR(CWord, word); 

    // Copy the CWord from the debuggee's memory
    ReadMemory(pvRecord, &word, sizeof(CWord), NULL);

    // Read the associated string from the debuggee's memory
    char sz[4096];
    ReadMemory(pWord->m_str.m_psz, sz, min(4096, pWord->m_str.m_cch+1), NULL);
    sz[4096-1] = '\0';

    dprintf("%p (%08x): str=(\"%s\", %d)"
            ", NF=%d, fIns=%d, fIter=%d, Refs=%d"
            "\n",
            pvRecord, dwSignature, sz, pWord->m_str.m_cch,
            pWord->m_cNotFound, (int) pWord->m_fInserted,
            (int) pWord->m_fIterated, pWord->m_cRefs
            );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\samples\hashtest\inifile.h ===
/*++

   Copyright    (c) 1998-2000    Microsoft Corporation

   Module  Name :
       HashTest.h

   Abstract:
       Test harness for LKRhash

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __INIFILE_H__
#define __INIFILE_H__

#ifndef _MAX_PATH
# define _MAX_PATH 260
#endif

class CIniFileSettings
{
public:
    TCHAR   m_tszIniFile[_MAX_PATH]; // the .ini file
    TCHAR   m_tszDataFile[_MAX_PATH]; // where string data table lives
    int     m_nMaxKeys;         // maximum number of keys
    double  m_dblHighLoad;      // maximum load of table (avg. bucket length)
    DWORD   m_nInitSize;        // initsize (1 => "small", 2 => "medium",
                                //   3 => "large", other => exact)
    int     m_nSubTables;       // num subtables (0 => heuristic)
    int     m_nLookupFreq;      // lookup frequency
    int     m_nMinThreads;      // min threads
    int     m_nMaxThreads;      // max threads
    int     m_nRounds;          // num rounds
    int     m_nSeed;            // random seed
    bool    m_fCaseInsensitive; // case-insensitive
    bool    m_fMemCmp;          // memcmp or strcmp
    int     m_nLastChars;       // num last chars (0 => all chars)
    WORD    m_wTableSpin;       // table lock spin count (0 => no spinning on
                                //   MP machines)
    WORD    m_wBucketSpin;      // bucket lock spin count (0 => no MP spinning)
    double  m_dblSpinAdjFctr;   // spin adjustment factor
    bool    m_fTestIterators;   // run test_iterators?
    int     m_nInsertIfNotFound;// test WriteLock, if(!FindKey) InsertRec, WUL?
                                // if IINF > 0, do this with probability 1/IINF
    int     m_nFindKeyCopy;     // search for a COPY of the key?
                                // if FKC > 0, do this probability 1/FKC
    bool    m_fNonPagedAllocs;
    bool    m_fRefTrace;

    int
    ParseIniFile(
        LPCSTR pszIniFile);
    
    void
    ReadIniFile(
        LPCTSTR ptszIniFile);
    
    void
    Dump(
        LPCTSTR ptszProlog,
        LPCTSTR ptszEpilog) const;
};

extern "C"
const TCHAR*
CommaNumber(
    int n,
    TCHAR* ptszBuff);

int
LKR_TestHashTable(
    CIniFileSettings& ifs);

extern "C"
int
NumProcessors();

#endif // __INIFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\samples\hashtest\inifile.cpp ===
/*++

   Copyright    (c) 1998-2000    Microsoft Corporation

   Module  Name :
       IniFile.cpp

   Abstract:
       Test harness for LKRhash

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#include "precomp.hxx"
#include "WordHash.h"
#include "IniFile.h"


enum INI_TYPE {
    INI_WORD = 1,
    INI_DWORD,
    INI_DOUBLE,
    INI_STRING,
    INI_BOOL,
};

typedef struct _ParseOptions {
    int         m_nFieldOffset;
    const char* m_pszName;
    unsigned    m_cchName;
    INI_TYPE    m_type;
    DWORD_PTR   m_default;
} ParseOptions;

#define INI_ENTRY(_member, _name, _type, _default)  \
    {                                               \
        FIELD_OFFSET(CIniFileSettings, _member),    \
        _name,                                      \
        sizeof(_name)-1,                            \
        _type,                                      \
        (DWORD_PTR) _default,                       \
    }                                               \

static const ParseOptions g_po[] = {
    INI_ENTRY(m_tszDataFile,  "DataFile",       INI_STRING, _TEXT("??")),
    INI_ENTRY(m_nMaxKeys,     "MaxKeys",        INI_DWORD,  MAXKEYS),
    INI_ENTRY(m_dblHighLoad,  "MaxLoadFactor",  INI_DOUBLE, LK_DFLT_MAXLOAD),
    INI_ENTRY(m_nInitSize,    "InitSize",       INI_DWORD,  LK_DFLT_INITSIZE),
    INI_ENTRY(m_nSubTables,   "NumSubTables",   INI_DWORD,LK_DFLT_NUM_SUBTBLS),
    INI_ENTRY(m_nLookupFreq,  "LookupFrequency",INI_DWORD,  5),
    INI_ENTRY(m_nMinThreads,  "MinThreads",     INI_DWORD,  1),
    INI_ENTRY(m_nMaxThreads,  "MaxThreads",     INI_DWORD,  4),
    INI_ENTRY(m_nRounds,      "NumRounds",      INI_DWORD,  1),
    INI_ENTRY(m_nSeed,        "RandomSeed",     INI_DWORD,  1234),
    INI_ENTRY(m_fCaseInsensitive,"CaseInsensitive",INI_BOOL, FALSE),
    INI_ENTRY(m_fMemCmp,      "MemCmp",         INI_BOOL,   FALSE),
    INI_ENTRY(m_nLastChars,   "NumLastChars",   INI_DWORD,  0),
    INI_ENTRY(m_wTableSpin,   "TableLockSpinCount",INI_WORD, LOCK_DEFAULT_SPINS),
    INI_ENTRY(m_wBucketSpin,  "BucketLockSpinCount",INI_WORD,LOCK_DEFAULT_SPINS),
    INI_ENTRY(m_dblSpinAdjFctr,"SpinAdjustmentFactor",INI_DOUBLE, 1),
    INI_ENTRY(m_fTestIterators,"TestIterators", INI_BOOL,   FALSE),
    INI_ENTRY(m_nInsertIfNotFound, "InsertIfNotFound",INI_DWORD, 0),
    INI_ENTRY(m_nFindKeyCopy, "FindKeyCopy",    INI_DWORD,  0),
    INI_ENTRY(m_fNonPagedAllocs,"NonPagedAllocs", INI_BOOL, TRUE),
    INI_ENTRY(m_fRefTrace,     "RefTrace",      INI_BOOL,   FALSE),
    {-1}  // last entry
};


void
CIniFileSettings::Dump(
    LPCTSTR ptszProlog,
    LPCTSTR ptszEpilog) const
{
    TCHAR tsz[50];

    _tprintf(_TEXT("%s\n"), ptszProlog);
    _tprintf(_TEXT("IniFile=\"%s\"\n"),
             m_tszIniFile);
    _tprintf(_TEXT("DataFile=\"%s\". %s keys.\n"),
             m_tszDataFile, CommaNumber(m_nMaxKeys, tsz));
    _tprintf(_TEXT("Max load = %.1f, initsize = %d, %d subtables.\n"),
             m_dblHighLoad, m_nInitSize, m_nSubTables);
    _tprintf(_TEXT("Lookup freq = %d, %d-%d threads, %d round%s.\n"),
             m_nLookupFreq, m_nMinThreads, m_nMaxThreads,
             m_nRounds, (m_nRounds==1 ? "" : "s"));
    _tprintf(_TEXT("Seed=%d, CaseInsensitive=%d, MemCmp=%d, LastChars=%d\n"),
             m_nSeed, m_fCaseInsensitive, m_fMemCmp, m_nLastChars);
    _tprintf(_TEXT("Spin Count: Table = %hd, Bucket = %hd, AdjFactor=%.1f\n"),
             m_wTableSpin, m_wBucketSpin, m_dblSpinAdjFctr);
    _tprintf(_TEXT("TestIterators=%d, InsertIfNotFound=%d, FindKeyCopy=%d\n"),
             m_fTestIterators, m_nInsertIfNotFound, m_nFindKeyCopy);
    _tprintf(_TEXT("NonPagedAllocs=%d, RefTrace=%d\n"),
             m_fNonPagedAllocs, m_fRefTrace);
    _tprintf(_TEXT("%s\n"), ptszEpilog);
}

#if defined(IRTLDEBUG)
# define DUMP_INIFILE(pifs, Pro, Epi)   pifs->Dump(Pro, Epi)
#else
# define DUMP_INIFILE(pifs, Pro, Epi)   ((void) 0)
#endif


DWORD
ReadFileIntoBuffer(
	LPCTSTR ptszFile,
    PBYTE   pbBuffer,
    DWORD   cbBuffer)
{
#ifndef LKRHASH_KERNEL_MODE
    HANDLE hFile =
        CreateFile(
            ptszFile,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        return 0;

    DWORD cbRead = 0, cbFileSizeLow, cbFileSizeHigh;

    cbFileSizeLow = GetFileSize(hFile, &cbFileSizeHigh);

    bool fBadFile =
        (cbFileSizeHigh != 0
         ||  cbFileSizeLow > cbBuffer
         ||  !ReadFile(hFile, pbBuffer, cbFileSizeLow, &cbRead, NULL));

    CloseHandle(hFile);

    return fBadFile  ?  0  :  cbRead;
#else
    return 0;
#endif // !LKRHASH_KERNEL_MODE
}


// Do a case-insensitive match of first `cchStr' chars of ptszBuffer
// against ptszStr. Strings assumed to be alphanumeric
bool
StrMatch(
    LPCSTR   pszBuffer,
    LPCSTR   pszStr,
    unsigned cchStr)
{
    LPCSTR   psz1 = pszBuffer;
    LPCSTR   psz2 = pszStr;
    unsigned i, j;
    bool     fMatch = true;

    for (i = 0;  i < cchStr;  ++i)
    {
        IRTLASSERT(isalnum(*psz1) && isalnum(*psz2));

        if (((*psz1++ ^ *psz2++) & 0xDF) != 0)
        {
            fMatch = false;
            break;
        }
    }

    IRTLTRACE0("\tStrMatch: \"");
    for (j = 0;  j < i + !fMatch;  ++j)
        IRTLTRACE1("%hc", pszBuffer[j]);
    IRTLTRACE0(fMatch ? "\" == \"" : "\" != \"");
    for (j = 0;  j < i + !fMatch;  ++j)
        IRTLTRACE1("%hc", pszStr[j]);
    IRTLTRACE0("\"\n");


    return fMatch;
}


bool
GetNum(
    char*& rpch,
    int&   rn)
{
    int fNegative = ('-' == *rpch);
    rn = 0;

    if (fNegative)
        ++rpch;
    else if (!('0' <= *rpch  &&  *rpch <= '9'))
        return false;

    while ('0' <= *rpch  &&  *rpch <= '9')
        rn = rn * 10 + (*rpch++ - '0');

    if (fNegative)
        rn = -rn;

    return true;
}



bool
GetDouble(
    char*&  rpch,
    double& rdbl)
{
    rdbl = 0;

    int n;
    bool fValidInt = GetNum(rpch, n);

    if (fValidInt)
    {
        rdbl = n;

        // BUGBUG: ignore fractional part, if any
        if ('.' == *rpch)
        {
            ++rpch;
            GetNum(rpch, n);
        }
    }

    return fValidInt;
}



bool
GetString(
    char*&   rpch,
    char*    pszOutput,
    unsigned cchOutput)
{
    // TODO: handle quoted strings and trailing blanks

    bool fGotChars = false;
    
    while ('\0' != *rpch  &&  '\r' != *rpch  &&  '\n' != *rpch )
    {
        fGotChars = true;

        if (cchOutput-- > 0)
            *pszOutput++ = *rpch++;
        else
            ++rpch;
    }

    if (cchOutput > 0)
        *pszOutput = '\0';

    return fGotChars;
}
    


// TODO: break the dependency upon g_po.

int
CIniFileSettings::ParseIniFile(
	LPCSTR             pszIniFile)
{
    strncpy(m_tszIniFile, pszIniFile, _MAX_PATH);

    int i, iMaxIndex = -1;
    int cMembers = 0;

    for (i = 0;  ; ++i)
    {
        if (g_po[i].m_nFieldOffset < 0)
        {
            iMaxIndex = i;
            break;
        }

        PBYTE pbMember = g_po[i].m_nFieldOffset + ((BYTE*) this);

        // Initialize the members of `this' with their default values
        switch (g_po[i].m_type)
        {
        case INI_WORD:
            * (WORD*) pbMember = (WORD) g_po[i].m_default;
            break;
        case INI_DWORD:
            * (DWORD*) pbMember = (DWORD) g_po[i].m_default;
            break;
        case INI_DOUBLE:
            * (double*) pbMember = (float) g_po[i].m_default;
            break;
        case INI_STRING:
            strcpy((char*) pbMember, (const char*) g_po[i].m_default);
            break;
        case INI_BOOL:
            * (bool*) pbMember = (bool) (g_po[i].m_default != 0);
            break;
        default:
            IRTLASSERT(! "invalid INI_TYPE");
        }
    }

    DUMP_INIFILE(this, "Before", "");

    BYTE  abBuffer[2049];
    DWORD cbRead = ReadFileIntoBuffer(m_tszIniFile, abBuffer,
                                      sizeof(abBuffer)-1);

    if (cbRead == 0)
    {
        _tprintf(_TEXT("Can't open IniFile `%s'.\n"), m_tszIniFile) ;
        return 0;
    }

    abBuffer[cbRead] = '\0';

    bool  fInSection = false, fSkipLine = false;
    bool  fDone = false;
	const char szSectionName[] = "HashTest";
	unsigned   cchSectionName = strlen(szSectionName);
    char* pch = (char*) abBuffer;
    char* pszEOB = (char*) (abBuffer + cbRead);

    // parse the in-memory buffer
    while ('\0' != *pch)
    {
        while (' ' == *pch  ||  '\r' == *pch
               ||  '\n' == *pch  ||  '\t' == *pch)
            ++pch;

        if ('\0' == *pch)
            break;

        IRTLTRACE(_TEXT("Line starts with '%hc%hc%hc%hc'\n"),
                  pch[0], pch[1], pch[2], pch[3]);

        // Is this a section name?
        if ('[' == *pch)
        {
            fInSection = false;
            ++pch;
            while (' ' == *pch  ||  '\t' == *pch)
                ++pch;
            if (pch + cchSectionName < pszEOB
                &&  StrMatch(pch, szSectionName, cchSectionName))
            {
                pch += cchSectionName;
                while (' ' == *pch  ||  '\t' == *pch)
                    ++pch;
                if (']' == *pch)
                {
                    ++pch;
                    fInSection = true;
                }
            }
            else
                fSkipLine = true;

            continue;
        }

        // skip comments and entire lines if we're not in the right section
        if (fSkipLine  ||  ';' == *pch  ||  !fInSection)
        {
            // skip to end of line
            while ('\0' != *pch  &&  '\r' != *pch  &&  '\n' != *pch)
            {
                IRTLTRACE1("%hc", *pch);
                ++pch;
            }

            IRTLTRACE0("\n");
            fSkipLine = false;
            continue;
        }

        fSkipLine = true;

        // try to match name=value
        for (i = 0;  i < iMaxIndex;  ++i)
        {
            IRTLASSERT(isalnum(*pch));
            if (pch + g_po[i].m_cchName >= pszEOB
                || !StrMatch(pch, g_po[i].m_pszName, g_po[i].m_cchName))
                continue;

            pch += g_po[i].m_cchName;
            while (' ' == *pch  ||  '\t' == *pch)
                ++pch;
            if ('=' != *pch)
            {
                IRTLTRACE1("'=' not seen after <%hs>\n", g_po[i].m_pszName);
                break;
            }
            ++pch;
            while (' ' == *pch  ||  '\t' == *pch)
                ++pch;

            PBYTE  pbMember = g_po[i].m_nFieldOffset + ((BYTE*) this);
            int    n;
            char   sz[_MAX_PATH];
            double dbl;

            IRTLTRACE1("<%hs>=", g_po[i].m_pszName);

            switch (g_po[i].m_type)
            {
            case INI_WORD:
                if (GetNum(pch, n))
                {
                    IRTLTRACE1("%hu\n", (WORD) n);
                    * (WORD*) pbMember = (WORD) n;
                }
                else
                    IRTLTRACE("bad word\n");
                break;
            case INI_DWORD:
                if (GetNum(pch, n))
                {
                    IRTLTRACE1("%u\n", (DWORD) n);
                    * (DWORD*) pbMember = (DWORD) n;
                }
                else
                    IRTLTRACE("bad dword\n");
                break;
            case INI_DOUBLE:
                if (GetDouble(pch, dbl))
                {
                    IRTLTRACE1("%.1f\n", dbl);
                    * (double*) pbMember = dbl;
                }
                else
                    IRTLTRACE("bad double\n");
                break;
            case INI_STRING:
                if (GetString(pch, sz, sizeof(sz)/sizeof(sz[0])))
                {
                    IRTLTRACE1("%hs\n", sz);
                    strcpy((char*) pbMember, sz);
                }
                else
                    IRTLTRACE("bad string\n");
                break;
            case INI_BOOL:
                if (GetNum(pch, n))
                {
                    IRTLTRACE1("%d\n", n);
                    * (bool*) pbMember = (n != 0);
                }
                else
                    IRTLTRACE("bad bool\n");
                break;
            default:
                IRTLASSERT(! "invalid INI_TYPE");
            }

            ++cMembers;
            fSkipLine = false;
            break;
        }
    }

    DUMP_INIFILE(this, "Parsed", "---");

    return cMembers;
}


void
CIniFileSettings::ReadIniFile(
	LPCTSTR ptszIniFile)
{
    ParseIniFile(ptszIniFile);

    m_nMaxKeys = min(max(1, m_nMaxKeys),  MAXKEYS);
    m_dblHighLoad = max(1, m_dblHighLoad);
    m_nMinThreads = max(1, m_nMinThreads);
    m_nMaxThreads = min(MAX_THREADS,  max(1, m_nMaxThreads));

    // If we're not using a real lock, then we're not threadsafe
    if (CWordHash::TableLock::LockType() == LOCK_FAKELOCK
        ||  CWordHash::BucketLock::LockType() == LOCK_FAKELOCK)
        m_nMinThreads = m_nMaxThreads = 1;

    m_nRounds = max(1, m_nRounds);
    CWordHash::sm_fCaseInsensitive = m_fCaseInsensitive;
    CWordHash::sm_fMemCmp = m_fMemCmp;
    CWordHash::sm_nLastChars = m_nLastChars;
    CWordHash::sm_fNonPagedAllocs = m_fNonPagedAllocs;
    CWordHash::sm_fRefTrace = m_fRefTrace;

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
# ifdef LKRHASH_GLOBAL_LOCK
    CWordHash::GlobalLock::SetDefaultSpinAdjustmentFactor(m_dblSpinAdjFctr);
# endif
    CWordHash::TableLock::SetDefaultSpinAdjustmentFactor(m_dblSpinAdjFctr);
    CWordHash::BucketLock::SetDefaultSpinAdjustmentFactor(m_dblSpinAdjFctr);
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    if (CWordHash::TableLock::Recursion() != LOCK_RECURSIVE
        ||  CWordHash::BucketLock::LockType() != LOCK_RECURSIVE)
        m_nInsertIfNotFound = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\samples\hashtest\hashtest.cpp ===
/*++

   Copyright    (c) 1998-2000    Microsoft Corporation

   Module  Name :
       HashTest.cpp

   Abstract:
       Test harness for LKRhash

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#include "precomp.hxx"



DECLARE_DEBUG_PRINTS_OBJECT();


#define HASHTEST_STATIC_DATA
#include "WordHash.h"
#include "IniFile.h"


void test_iterators(double highload, int initsize, int nsubtbls,
                    int nInsertIfNotFound);

#ifdef LKR_STL_ITERATORS
#pragma message("test STL iterators")
void test_stl_iterators(double highload, int initsize, int nsubtbls);
#endif // LKR_STL_ITERATORS

#ifndef LKRHASH_KERNEL_MODE
void print_table_statistics(const CLKRHashTableStats& stats);

# ifdef LOCK_INSTRUMENTATION
void print_lock_statistics(const CLKRHashTableStats &stats);
# endif
#endif // !LKRHASH_KERNEL_MODE

int  expand_key_set(int maxkeys, int numkeys, bool fVerbose) ;
#ifdef LKRHASH_KERNEL_MODE
void
#else
unsigned __stdcall
#endif
exercise_table(void *pinput);


// how many CPUs on this machine?
int
NumProcessors()
{
    static int s_nCPUs = 0;
    
    if (s_nCPUs == 0)
    {
#ifdef LKRHASH_KERNEL_MODE
        s_nCPUs = KeNumberProcessors;
#else  // !LKRHASH_KERNEL_MODE
        SYSTEM_INFO si;
        
        GetSystemInfo(&si);
        s_nCPUs = si.dwNumberOfProcessors;
#endif // !LKRHASH_KERNEL_MODE
    }
    return s_nCPUs;
}



// globals
int        g_nokeys=0 ;
CWord      g_wordtable[MAXKEYS];


bool
CheckRefCounts(
    LONG nRef,
    int iFirst =  0,
    int iLast  = -1)
{
    if (iLast == -1)
        iLast = g_nokeys;
    
    IRTLTRACE3("\nCheckRefCounts(%d, [%d,%d))\n", nRef, iFirst, iLast);
    bool f = true;

    for (int i = iFirst;  i != iLast;  ++i)
    {
        f = f && (g_wordtable[i].m_cRefs == nRef);
        if (g_wordtable[i].m_cRefs != nRef)
            IRTLTRACE4("\nCRC: %d, %hs, expected %d, got %d\n",
                      i, g_wordtable[i].m_str.m_psz, nRef,
                      g_wordtable[i].m_cRefs);
        IRTLASSERT(g_wordtable[i].m_cRefs == nRef);
    }

    return f;
}


bool CWordHash::sm_fCaseInsensitive = true;
bool CWordHash::sm_fMemCmp    = false;
int  CWordHash::sm_nLastChars = 16;
bool CWordHash::sm_fRefTrace  = false;
bool CWordHash::sm_fNonPagedAllocs = true;


struct thread_data
{
    CWordHash* ptbl ;

    int    threadno ;
    int    first_key ;
    int    last_key ;
    int    rounds ;
    int    lookup_freq ;
    float  highload ;

    int    cinserts ;
    int    cdeletes ;
    int    clookups ;
    int    cfailures ;
    int    m_nInsertIfNotFound;
    int    m_nFindKeyCopy;
    int    m_nSeed;            // random seed

    double duration ;
    HANDLE hevFinished;
    HANDLE hThread;
} ;



const TCHAR*
CommaNumber(
    int n,
    TCHAR* ptszBuff)
{
    TCHAR* ptsz = ptszBuff;
    TCHAR chComma = '\0';

    int aThousands[4];
    int iThousands = 0;
    unsigned int u = n;

    if (n < 0)
    {
        *ptsz++ = '-';
        u = -n;
    }

    do {
        aThousands[iThousands++] = u % 1000;
        u /= 1000;
    } while (u != 0);

    while (--iThousands >= 0)
    {
        u = aThousands[iThousands];

        if (chComma)
            *ptsz++ = chComma;

        unsigned d = u % 10;
        u /= 10;
        unsigned t = u % 10;
        u /= 10;
        unsigned h = u;

        if (h > 0  ||  chComma)
            *ptsz++ = h + '0';
        if (t > 0  ||  h > 0  ||  chComma)
            *ptsz++ = t + '0';
        *ptsz++ = d + '0';

        chComma = ',';
    }

    *ptsz = '\0';
        
    return ptszBuff;
}


#ifndef LKRHASH_KERNEL_MODE

typedef union {
    FILETIME ft;
    __int64  l64;
} FILETIME_UINT64;

# define FILETIME_1_SECOND     10000000
# define FILETIME_1_MILLISECOND   10000

HANDLE
HashTestCreateEvent()
{
    return CreateEvent(NULL,     // no security attributes
                       FALSE,    // auto reset
                       FALSE,    // not signalled
                       NULL);    // no name
}

void
HashTestResumeThread(
    HANDLE hThread)
{
    ResumeThread(hThread);
}

HANDLE
HashTestCreateThread(
    unsigned (__stdcall * pfnThreadProc) (void *),
    void* pvContext,
    bool  fSuspended)
{
    unsigned dummy;
    return (HANDLE) _beginthreadex(NULL, 0, pfnThreadProc, pvContext,
                                   fSuspended ? CREATE_SUSPENDED : 0,
                                   &dummy); 
}

DWORD
HashTestWaitForMultipleObjects(
    DWORD nCount,
    CONST HANDLE *lpHandles)
{
    return WaitForMultipleObjects(nCount, lpHandles, TRUE, INFINITE);
}

#else // LKRHASH_KERNEL_MODE

# define GetTickCount()         NtGetTickCount()
# define GetCurrentThread()     NtCurrentThread()

void
SetThreadIdealProcessor(
    HANDLE hThread,
    DWORD dwIdealProcessor
    )
{
    NtSetInformationThread(
                hThread,
                ThreadIdealProcessor,
                &dwIdealProcessor,
                sizeof(dwIdealProcessor)
                );
}

// non-threadsafe implementation of rand and srand, stolen from CRT
unsigned long _holdrand = 1234567890;

void __cdecl
srand(
    unsigned int seed)
{
    _holdrand = (unsigned long) seed;
}


int __cdecl
rand()
{
    return ((_holdrand = _holdrand * 214013L + 2531011L) >> 16) & 0x7fff;
}

HANDLE
HashTestCreateEvent()
{
    HANDLE hEvent = NULL;

    NTSTATUS status = NtCreateEvent(
        &hEvent,
        EVENT_ALL_ACCESS,
        NULL,
        SynchronizationEvent,
        FALSE);
    
    return hEvent;
}

void
HashTestResumeThread(
    HANDLE hThread)
{
    NtResumeThread(hThread, NULL);
}

HANDLE
HashTestCreateThread(
    void (* pfnThreadProc) (void *),
    void* pvContext,
    bool  fSuspended)
{
    NTSTATUS status;
    HANDLE threadHandle;
    OBJECT_ATTRIBUTES objectAttributes;

    //
    // Create the thread.
    //
    
    InitializeObjectAttributes(
        &objectAttributes,             // ObjectAttributes
        NULL,                          // ObjectName
        OBJ_KERNEL_HANDLE,             // Attributes
        NULL,                          // RootDirectory
        NULL                           // SecurityDescriptor
        );
    
    status = PsCreateSystemThread(
        &threadHandle,                 // ThreadHandle
        THREAD_ALL_ACCESS,             // DesiredAccess
        &objectAttributes,             // ObjectAttributes
        NULL,                          // ProcessHandle
        NULL,                          // ClientId
        pfnThreadProc,                 // StartRoutine
        pvContext                      // StartContext
        );

    if (!fSuspended)
        HashTestResumeThread(threadHandle);

    return threadHandle;
}

BOOL
CloseHandle(
    HANDLE h)
{
    return NT_SUCCESS(NtClose(h));
}

DWORD
HashTestWaitForMultipleObjects(
    DWORD nCount,
    CONST HANDLE *lpHandles)
{
    HANDLE ahHandles[MAX_THREADS+1];

    for (int i = 0;  i < nCount;  ++i)
        ahHandles[i] = lpHandles[i];
    
    return NtWaitForMultipleObjects((CHAR) nCount, ahHandles,
                                    WaitAll, FALSE, NULL);
}

BOOL
SetEvent(
    HANDLE hEvent)
{
    return NT_SUCCESS(NtSetEvent(hEvent, NULL));
}

#endif // LKRHASH_KERNEL_MODE



#ifdef _M_IX86
// Use RDTSC to read timestamp
void
GetCycleCount(
	LARGE_INTEGER *pliTimeStamp)
{
	ULONG Lo;
	LONG Hi;
	
	_asm {
		_emit 0x0f
		_emit 0x31
		mov Lo, eax
		mov Hi, edx
	} /* _asm */
	pliTimeStamp->LowPart = Lo;
	pliTimeStamp->HighPart = Hi;
}
#endif // _M_IX86


int
LKR_TestHashTable(
    CIniFileSettings& ifs)
{
    CWordHash    *pTbl ;
    int          num_threads ;
    thread_data  de_area[MAX_THREADS] ;
    HANDLE       ahEvents[MAX_THREADS];
    TCHAR        tsz[1024] ;
    FILE        *fp ;
    int          nodel=0;
    int          keys_per_thread ;
    int          i ;
    int          sum_ins, sum_dels, sum_lookups ;
    int          failures = 0, total_failures = 0;
    bool         fVerbose = false;
    double       dblSumDuration3 = 0;
    DWORD        dwRunTime = GetTickCount();
    int          nBaseOps = 0;

#ifdef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT("hashtest");
#endif

    SetThreadIdealProcessor(GetCurrentThread(), 0);

    _tprintf(_TEXT("\nTest driver for LKRhash\n")
#ifdef LKRHASH_KERNEL_MODE
           _TEXT(" (Kernel)")
#endif
#ifdef IRTLDEBUG
           _TEXT(" (Debug)")
#endif
#ifdef LKR_PUBLIC_API
           _TEXT(" (Public API)")
#else
           _TEXT(" (Internal API)")
#endif
#ifdef LKR_COUNTDOWN
           _TEXT(" (CountDown)")
#else
           _TEXT(" (CountUp)")
#endif
#ifdef LKR_CONTRACT
           _TEXT(" (Contraction)")
#else
           _TEXT(" (No Contraction)")
#endif
#ifdef LOCKS_SWITCH_TO_THREAD
           _TEXT(" (SwitchToThread)\n")
#endif
#ifdef LKR_DEPRECATED_ITERATORS
           _TEXT(" (Deprecated Iterators)")
#endif
#ifdef LKR_APPLY_IF
           _TEXT(" (ApplyIf)")
#endif
#ifdef LKR_EXPOSED_TABLE_LOCK
           _TEXT(" (Exposed Table Lock)")
#endif
#ifdef LKR_STL_ITERATORS
           _TEXT(" (STL-style Iterators")
# if LKR_STL_ITERATORS >= 2
           _TEXT(", verbose)")
# else
           _TEXT(")")
# endif
#else // !LKR_STL_ITERATORS
           _TEXT(" (No STL-style Iterators)")
#endif // !LKR_STL_ITERATORS
           _TEXT("\n\n")
           ) ;

#if defined(LKRHASH_ACACHE)
    const TCHAR tszAllocator[] = _TEXT("ACache");
#elif defined(LKRHASH_ROCKALL_FAST)
    const TCHAR tszAllocator[] = _TEXT("Rockall FAST_HEAP");
#elif defined(LKRHASH_PAGEDHEAP)
    const TCHAR tszAllocator[] = _TEXT("CPagedHeap");
#elif defined(LKRHASH_NONPAGEDHEAP)
    const TCHAR tszAllocator[] = _TEXT("CNonPagedHeap");
#elif defined(LKRHASH_NONPAGEDLOOKASIDE)
    const TCHAR tszAllocator[] = _TEXT("CNonPagedLookasideList");
#elif defined(LKRHASH_PAGEDLOOKASIDE)
    const TCHAR tszAllocator[] = _TEXT("CPagedLookasideList");
#else
    const TCHAR tszAllocator[] =
        _TEXT("Default allocator (global operator new)");
#endif

    _tprintf(_TEXT("%s version.\n"), tszAllocator);

#ifdef SAMPLE_LKRHASH_TESTCLASS
    Test(fVerbose);
    if (fVerbose)
        _tprintf(_TEXT("Test succeeded\n"));
#endif // SAMPLE_LKRHASH_TESTCLASS

    fp = _tfopen(ifs.m_tszDataFile, _TEXT("r") ) ;
    if (fp == NULL)
    {
        _tprintf(_TEXT("Can't open file `%s'.\n"), ifs.m_tszDataFile) ;
        return 1;
    }

    char sz[1024];

    _tprintf(_TEXT("Reading `%s' "), ifs.m_tszDataFile);
    for (g_nokeys = 0;  g_nokeys < ifs.m_nMaxKeys;  )
    {
        if (fgets(sz, sizeof(sz)/sizeof(sz[0]), fp) == NULL)
            break;
        int cch = strlen(sz);
        // TODO: check for duplicates
        if (cch > 0  &&  sz[cch-1] == '\n')
            sz[--cch] = '\0';
        if (cch >= MAX_STRSIZE)
            sz[MAX_STRSIZE-1] = '\0';
        if (cch > 0)
            g_wordtable[g_nokeys++].m_str.Set(sz, cch);
        if (g_nokeys % 10000 == 0)
            putchar('.');
    }

    fclose(fp) ;

    _tprintf(_TEXT("\nLoaded %s keys from `%s', "),
             CommaNumber(g_nokeys, tsz), ifs.m_tszDataFile);
    g_nokeys = expand_key_set(ifs.m_nMaxKeys, g_nokeys, true) ;
    _tprintf(_TEXT(" expanded to %s keys.\n\n"),
             CommaNumber(g_nokeys, tsz));

    int cchTotal = 0, cchMin = INT_MAX, cchMax = 0;
    for (i = 0;  i < g_nokeys;  ++i)
    {
        cchTotal += g_wordtable[i].m_str.m_cch;
        cchMin    = min(cchMin, g_wordtable[i].m_str.m_cch);
        cchMax    = max(cchMax, g_wordtable[i].m_str.m_cch);
    }

    srand(ifs.m_nSeed) ;

    _stprintf(tsz, _TEXT("%d"), ifs.m_nInitSize);
    if (ifs.m_nInitSize == LK_SMALL_TABLESIZE)
        _tcscpy(tsz, _TEXT("small"));
    else if (ifs.m_nInitSize == LK_MEDIUM_TABLESIZE)
        _tcscpy(tsz, _TEXT("medium"));
    else if (ifs.m_nInitSize == LK_LARGE_TABLESIZE)
        _tcscpy(tsz, _TEXT("large"));

    DWORD initsize2 = ifs.m_nInitSize;
    DWORD nsubtbls2 = ifs.m_nSubTables;
    LK_TABLESIZE lkts = CWordHash::NumSubTables(ifs.m_nInitSize, nsubtbls2);
    
    _tprintf(_TEXT("Max load=%.1f, initsize=%s, ")
             _TEXT("%d subtables (%d tables, size=%d, lkts=%d).\n"),
             ifs.m_dblHighLoad, tsz,
             ifs.m_nSubTables, nsubtbls2, initsize2, lkts);
    _tprintf(_TEXT("Lookup freq = %d, %d-%d threads, ")
             _TEXT("%d round%s.\n"),
             ifs.m_nLookupFreq, ifs.m_nMinThreads, ifs.m_nMaxThreads,
             ifs.m_nRounds, (ifs.m_nRounds==1 ? "" : "s"));
    _tprintf(_TEXT("%s keys from `%s'.\n"),
             CommaNumber(g_nokeys, tsz), ifs.m_tszDataFile);
    _tprintf(_TEXT("Key length: avg = %d, min = %d, max = %d.\n"),
             cchTotal / g_nokeys, cchMin, cchMax);
    _tprintf(_TEXT("Base Table = %s. Hash method = %s.\n"),
             CWordHash::ClassName(), CWordHash::HashMethod());
#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
# ifdef LKRHASH_GLOBAL_LOCK
    _tprintf(_TEXT("GlobalLock = %s, ")
             _TEXT("%d bytes, ")
             _TEXT("Spin Count = %hd, ")
             _TEXT("Adj Factor = %.1f.\n"),
             CWordHash::GlobalLock::ClassName(),
             sizeof(CWordHash::GlobalLock),
             ifs.m_wTableSpin,
             CWordHash::GlobalLock::GetDefaultSpinAdjustmentFactor());
# endif
    _tprintf(_TEXT("TableLock = %s, ")
             _TEXT("%d bytes, ")
             _TEXT("Spin Count = %hd, ")
             _TEXT("Adj Factor = %.1f.\n"),
             CWordHash::TableLock::ClassName(),
             sizeof(CWordHash::TableLock),
             ifs.m_wTableSpin,
             CWordHash::TableLock::GetDefaultSpinAdjustmentFactor());
    
    _tprintf(_TEXT("BucketLock = %s, ")
             _TEXT("%d bytes, ")
             _TEXT("Spin Count = %hd, ")
             _TEXT("Adj Factor = %.1f.\n"),
             CWordHash::BucketLock::ClassName(),
             sizeof(CWordHash::BucketLock),
             ifs.m_wBucketSpin,
             CWordHash::BucketLock::GetDefaultSpinAdjustmentFactor());
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION
    
#ifdef LOCK_PER_LOCK_SPINCOUNTS
    _tprintf(_TEXT("Per"));
#else
    _tprintf(_TEXT("No per"));
#endif
    _tprintf(_TEXT("-lock spincounts.  #CPUs = %d.  Random seed = %d.  ")
             _TEXT("Nodes/Clump = %d.\n"),
             NumProcessors(), ifs.m_nSeed,
             CWordHash::NODES_PER_CLUMP
             );

    _tprintf(_TEXT("InsertIfNotFound = %d, FindKeyCopy = %d\n"),
             ifs.m_nInsertIfNotFound, ifs.m_nFindKeyCopy);
    _tprintf(_TEXT("NonPagedAllocs=%d, RefTrace=%d, Allocator=%s.\n"),
             ifs.m_fNonPagedAllocs, ifs.m_fRefTrace,
             CLKRhashAllocator::ClassName());

#ifndef LKRHASH_KERNEL_MODE
	time_t tmNow;
	time(&tmNow);

    _tprintf(_TEXT("\nRun: %s\n\n"), _tctime(&tmNow));
#endif // !LKRHASH_KERNEL_MODE

    if (ifs.m_fTestIterators)
    {
        test_iterators(ifs.m_dblHighLoad, ifs.m_nInitSize,
                       ifs.m_nSubTables, ifs.m_nInsertIfNotFound);
#ifdef LKR_STL_ITERATORS
        test_stl_iterators(ifs.m_dblHighLoad, ifs.m_nInitSize,
                           ifs.m_nSubTables);
#endif // LKR_STL_ITERATORS
    }

#ifndef LKRHASH_KERNEL_MODE
    // set multimedia timer's period to be 1 millisecond (or the closest
    // approximation that the hardware can manage). This is usually more
    // accurate than GetTickCount. I have had very dubious results from
    // QueryPerformanceCounter on multiprocessor machines, including
    // negative(!) durations (timer skew between processors?)
    timeBeginPeriod(1);
#endif // !LKRHASH_KERNEL_MODE

    _tprintf(_TEXT("Starting threads...\n\n"));

    int nTotalOps = 0;
    int step = (ifs.m_nMinThreads <= ifs.m_nMaxThreads) ? +1 : -1;

    dwRunTime = GetTickCount() - dwRunTime;

    for (num_threads =  ifs.m_nMinThreads;
         num_threads != ifs.m_nMaxThreads + step;
         num_threads += step )
    {
        IRTLTRACE1("\nStarting %8d\n", num_threads);

        pTbl = new CWordHash(ifs.m_dblHighLoad, ifs.m_nInitSize,
                             ifs.m_nSubTables) ;
        pTbl->SetTableLockSpinCount(ifs.m_wTableSpin);
        pTbl->SetBucketLockSpinCount(ifs.m_wBucketSpin);

        keys_per_thread = g_nokeys/num_threads ;
        for (i = 0; i < num_threads; i++)
        {
            de_area[i].ptbl        = pTbl ;
            de_area[i].threadno    = i+1 ;
            de_area[i].first_key   = i*keys_per_thread ;
            de_area[i].last_key    = ((i == num_threads - 1)
                                      ? g_nokeys
                                      : (i+1)*keys_per_thread) ;
            de_area[i].rounds      = ifs.m_nRounds ;
            de_area[i].highload    = (float) ifs.m_dblHighLoad ;
            de_area[i].lookup_freq = ifs.m_nLookupFreq ;
            de_area[i].m_nInsertIfNotFound = ifs.m_nInsertIfNotFound;
            de_area[i].m_nFindKeyCopy = ifs.m_nFindKeyCopy;
            de_area[i].m_nSeed     = ifs.m_nSeed;
            de_area[i].hevFinished = HashTestCreateEvent();
            IRTLASSERT(de_area[i].hevFinished != NULL);
            ahEvents[i] = de_area[i].hevFinished;

            de_area[i].hThread = HashTestCreateThread(exercise_table,
                                                      &de_area[i], true);
        }

#ifndef LKRHASH_KERNEL_MODE
        DWORD dwMMT1 = timeGetTime();
#endif // !LKRHASH_KERNEL_MODE
        
        for (i = 0; i < num_threads; i++)
        {
            HashTestResumeThread(de_area[i].hThread);
            CloseHandle(de_area[i].hThread);
        }

        DWORD dw = HashTestWaitForMultipleObjects(num_threads, ahEvents);

#ifndef LKRHASH_KERNEL_MODE
        DWORD dwMMT2 = timeGetTime();
#endif // !LKRHASH_KERNEL_MODE

        for (i = 0; i < num_threads; i++)
            CloseHandle(ahEvents[i]);

#ifndef LKRHASH_KERNEL_MODE
        double duration3 = double(dwMMT2 - dwMMT1) / 1000.0;
        dblSumDuration3 += duration3;

        dwRunTime += dwMMT2 - dwMMT1;
#endif // !LKRHASH_KERNEL_MODE

        sum_ins = sum_dels = sum_lookups = 0 ;

        for (i = 0; i < num_threads; i++)
        {
            sum_ins     += de_area[i].cinserts ;
            sum_dels    += de_area[i].cdeletes ;
            sum_lookups += de_area[i].clookups ;
            failures    += de_area[i].cfailures ;
        }
        int nOps = sum_ins + sum_dels + sum_lookups;

        total_failures += failures;
        nTotalOps += nOps;  // TODO: weight?

#ifdef LKRHASH_KERNEL_MODE
#else // !LKRHASH_KERNEL_MODE
        int nOpsRate3 = (int)(nOps / duration3);

        if (num_threads == ifs.m_nMinThreads)
            nBaseOps = nOpsRate3;

        TCHAR tszSumIns[16], tszSumDels[16], tszSumLookups[16];
        TCHAR tszNOps3[16];

#ifndef LOCK_INSTRUMENTATION
        if (num_threads == ifs.m_nMinThreads)
#endif // LOCK_INSTRUMENTATION
        {
            _tprintf(_TEXT("%5s %10s %9s %6s")
                     _TEXT("%8s %8s %8s\n"),
                     _TEXT("Thrds"), _TEXT("Ops/sec"),
                     _TEXT("Duration"), _TEXT("Ratio"),
                     _TEXT("Inserts"), _TEXT("Deletes"), _TEXT("Lookups"));
        }

        TCHAR tszSummary[200];

        _stprintf(tszSummary, _TEXT("%5d %10s %9.3f %6.3f")
                  _TEXT("%7sK %7sK %7sK\n"),
                  num_threads,
                  CommaNumber(nOpsRate3, tszNOps3),
                  duration3,
                  double(nOpsRate3) / double(nBaseOps),
                  CommaNumber((sum_ins + 500) / 1000,     tszSumIns),
                  CommaNumber((sum_dels + 500) / 1000,    tszSumDels),
                  CommaNumber((sum_lookups + 500) / 1000, tszSumLookups)
                  );
        _tprintf(tszSummary);
        IRTLTRACE1("%s", tszSummary);

        if (failures != 0)
            _tprintf(_TEXT("%d failed operations!\n"), failures);
#endif // !LKRHASH_KERNEL_MODE

#ifdef LOCK_INSTRUMENTATION
        print_lock_statistics(pTbl->GetStatistics());
 #ifdef LKRHASH_GLOBAL_LOCK
        CWordHash::GlobalLock::ResetGlobalStatistics();
 #endif
        CWordHash::BucketLock::ResetGlobalStatistics();
        CWordHash::TableLock::ResetGlobalStatistics();
        _tprintf(_TEXT("\n"));
#endif

        delete pTbl ;
    }

    TCHAR tszNTotalOps3[16];
    _tprintf(_TEXT("\nAverage Ops = %s. RunTime = %d:%02d.%03d.\n"),
             CommaNumber(int(nTotalOps / dblSumDuration3), tszNTotalOps3),
             dwRunTime / 60000, (dwRunTime / 1000) % 60, dwRunTime % 1000);

    if (total_failures != 0)
        _tprintf(_TEXT("%d total failed operations!\n"), total_failures);

#ifndef LKRHASH_KERNEL_MODE
    timeEndPeriod(1);
#endif // !LKRHASH_KERNEL_MODE

    return 0;
} // LKR_TestHashTable



void test_iterators(
    double highload,
    int    initsize,
    int    nsubtbls,
    int    nInsertIfNotFound)
{
    _tprintf(_TEXT("Testing iterators...\n"));

    int i;
    CWordHash *pTbl = new CWordHash(highload, initsize, nsubtbls) ;
    LK_RETCODE lkrc;

    IRTLASSERT(0 == pTbl->Size());
    IRTLASSERT(pTbl->CheckTable() == 0);

    IRTLTRACE0("Table is empty.  Building...\n");

    int cInsertIfNotFounds = 0;
    
    for (i = 0 ; i < g_nokeys ; i++ )
    {
        lkrc = pTbl->InsertRecord(&g_wordtable[i], false);
        if (lkrc != LK_SUCCESS)
            IRTLTRACE3("i = %d, word = `%hs', lkrc = %d\n",
                       i, g_wordtable[i].m_str.m_psz, lkrc);
        IRTLASSERT(lkrc == LK_SUCCESS);

#ifdef LKR_EXPOSED_TABLE_LOCK
        if (nInsertIfNotFound > 0  &&   rand() % nInsertIfNotFound == 0)
        {
            pTbl->WriteLock();

            int    x        = rand() % g_nokeys;
            CStr*  pstrKey  = &g_wordtable[x].m_str;
            CWord* pRec     = NULL;

            lkrc = pTbl->FindKey(pstrKey, &pRec);

            if (pRec != NULL)
            {
                IRTLASSERT(lkrc == LK_SUCCESS);
                IRTLASSERT(pRec == &g_wordtable[x]);
                IRTLASSERT(x <= i);
                --g_wordtable[x].m_cRefs;
            }
            else
            {
                ++cInsertIfNotFounds;
                IRTLASSERT(x > i);
                IRTLASSERT(lkrc == LK_NO_SUCH_KEY);

                lkrc = pTbl->InsertRecord(&g_wordtable[x], false);
                IRTLASSERT(lkrc == LK_SUCCESS);
                InterlockedIncrement(&g_wordtable[x].m_cInsertIfNotFounds);

                lkrc = pTbl->DeleteKey(&g_wordtable[x].m_str);
                IRTLASSERT(lkrc == LK_SUCCESS);
            }
            
            pTbl->WriteUnlock();
        }
#endif // LKR_EXPOSED_TABLE_LOCK
    }

    IRTLTRACE1("cInsertIfNotFounds = %d\n", cInsertIfNotFounds);
    
#ifdef LKR_EXPOSED_TABLE_LOCK
    pTbl->ReadLock();

    IRTLTRACE2("Checking that table has %d records (size = %d)\n",
              g_nokeys, pTbl->Size());
    IRTLASSERT(g_nokeys == (int) pTbl->Size());
    IRTLASSERT(pTbl->CheckTable() == 0);

    pTbl->ReadUnlock();
#endif // LKR_EXPOSED_TABLE_LOCK

    IRTLTRACE0("Clearing the table\n");
    pTbl->Clear();
    IRTLASSERT(0 == pTbl->Size());
    IRTLASSERT(pTbl->CheckTable() == 0);

    IRTLTRACE0("Seeing what crud is left in the table\n");
    size_t cRec = 0;

    for (i = 0 ; i < g_nokeys ; i++ )
    {
        CStr*  pstrKey  = &g_wordtable[i].m_str;
        CWord* pRec     = NULL;
        LK_RETCODE lkrc = pTbl->FindKey(pstrKey, &pRec);

        if (pRec != NULL)
        {
            IRTLASSERT(pRec == &g_wordtable[i]);
            --pRec->m_cRefs;
            IRTLTRACE1("%hs\n", g_wordtable[i].m_str.m_psz);
            ++cRec;
        }
    }
    IRTLTRACE1("Found %d records that shouldn't have been there\n", cRec);

    pTbl->Clear();
    delete pTbl;

    pTbl = new CWordHash(highload, initsize, nsubtbls) ;

    IRTLTRACE0("Rebuilding the table\n");
    for (i = 0 ; i < g_nokeys ; i++ )
        IRTLVERIFY(pTbl->InsertRecord(&g_wordtable[i]) == LK_SUCCESS);

    IRTLASSERT(g_nokeys == (int) pTbl->Size());
    IRTLASSERT(pTbl->CheckTable() == 0);

#ifdef LKR_DEPRECATED_ITERATORS
    IRTLTRACE0("Checking iterators\n");
    cRec = 0;
    CWordHash::CIterator iter(LKL_READLOCK);
    
    for (lkrc = pTbl->InitializeIterator(&iter);
         lkrc == LK_SUCCESS;
         lkrc = pTbl->IncrementIterator(&iter))
    {
        ++cRec;
        const CStr* pstrKey = iter.Key();
        CWord*      pRec    = iter.Record();
        
        IRTLASSERT(&g_wordtable[0] <= pRec  &&  pRec < &g_wordtable[g_nokeys]);
        IRTLASSERT(!pRec->m_fIterated);
        pRec->m_fIterated = true;

        if (CWordHash::TableLock::Recursion() != LOCK_NON_RECURSIVE
            &&  CWordHash::BucketLock::Recursion() != LOCK_NON_RECURSIVE)
        {
            // Check that the lock can be safely acquired recursively
            // (the table is already locked by the iterator).
            int x = rand() % g_nokeys;
            CStr*  pstrKey2 = &g_wordtable[x].m_str;
            CWord* pRec2    = NULL;
            LK_RETCODE lkrc2= pTbl->FindKey(pstrKey2, &pRec2);
            IRTLASSERT(lkrc2 == LK_SUCCESS  &&  pRec2 == &g_wordtable[x]);
            if (pRec2 != NULL)
                --pRec2->m_cRefs;
        }
    }
    
    IRTLASSERT(lkrc == LK_NO_MORE_ELEMENTS);
    IRTLASSERT((int) cRec == g_nokeys);

    lkrc = pTbl->CloseIterator(&iter);
    IRTLASSERT(lkrc == LK_SUCCESS);

    for (i = 0 ; i < g_nokeys ; i++ )
    {
        IRTLASSERT(g_wordtable[i].m_fIterated);
        g_wordtable[i].m_fIterated = false;
    }


    do {
        cRec = rand() % (g_nokeys - 1);
    } while (cRec == 0);
    IRTLTRACE1("Checking abandoning of const iterators after %d iterations\n",
              cRec);

    const CWordHash *pTblConst = pTbl;
    CWordHash::CConstIterator iterConst;

    for (lkrc = pTblConst->InitializeIterator(&iterConst);
         lkrc == LK_SUCCESS;
         lkrc = pTblConst->IncrementIterator(&iterConst))
    {
        if (--cRec == 0)
            break;
        const CStr*  pszKey = iterConst.Key();
        const CWord* pRec   = iterConst.Record();
        
        IRTLASSERT(&g_wordtable[0] <= pRec  &&  pRec < &g_wordtable[g_nokeys]);
    }
    
    IRTLASSERT(lkrc != LK_NO_MORE_ELEMENTS);

    lkrc = pTblConst->CloseIterator(&iterConst);
    IRTLASSERT(lkrc == LK_SUCCESS);
#endif // LKR_DEPRECATED_ITERATORS

    
#ifndef LKRHASH_KERNEL_MODE
    IRTLTRACE0("Gathering statistics\n");
    CLKRHashTableStats stats = pTbl->GetStatistics();
    print_table_statistics(stats);
#endif // !LKRHASH_KERNEL_MODE

#ifdef LOCK_INSTRUMENTATION
    print_lock_statistics(stats);
    CWordHash::BucketLock::ResetGlobalStatistics();
    CWordHash::TableLock::ResetGlobalStatistics();
#endif
    _tprintf(_TEXT("\n"));

    IRTLTRACE0("Cleaning up by hand\n");
    for (i = 0 ; i < g_nokeys ; i++ )
    {
        IRTLVERIFY(pTbl->DeleteKey(&g_wordtable[i].m_str) == LK_SUCCESS);
    }
    
    IRTLASSERT(0 == pTbl->Size());

    delete pTbl ;
}


#ifdef LKR_STL_ITERATORS

void test_stl_iterators2(
    CWordHash *pTbl);


void test_stl_iterators(
    double highload,
    int    initsize,
    int    nsubtbls)
{
    _tprintf(_TEXT("\nTesting STL iterators...\n"));

    _tprintf(_TEXT("subtable iter = %d, iter = %d\n"),
           sizeof(CLKRLinearHashTable::Iterator),
           sizeof(CLKRHashTable::Iterator));

    int i;
    bool f;
    CWordHash *pTbl;
    CWordHash::iterator iter;
    const int iFirst = 5; //     g_nokeys / 5;
    const int iLast  = 10; // 4 * g_nokeys / 5;

    // pTbl = new CWordHash(highload, initsize, nsubtbls) ;

    IRTLTRACE1("\n\nAbout to create table with %d records\n\n",
               iLast - iFirst);
    pTbl = new CWordHash(&g_wordtable[iFirst], &g_wordtable[iLast],
                        highload, initsize, nsubtbls) ;

    for (iter = pTbl->begin();  iter != pTbl->end();  ++iter)
    {
        const CStr* pstrKey = iter.Key();
        CWord*      pRec    = iter.Record();

        IRTLASSERT(&g_wordtable[iFirst] <= pRec
                   &&  pRec < &g_wordtable[iLast]);
        IRTLTRACE2("\nRecord: %p, %hs\n", pRec, pstrKey->m_psz);
    }

    IRTLTRACE1("\n\nAbout to search %d records\n\n", pTbl->Size());
    for (i = iFirst;  i != iLast;  ++i)
    {
        f = pTbl->Find(&g_wordtable[i].m_str, iter);
        IRTLASSERT(f  &&  iter.Record() == &g_wordtable[i]);
        IRTLTRACE2("\n\tFound: %d, %hs\n", i, iter.Key()->m_psz);
    }
        
    f = pTbl->Find(&g_wordtable[iLast].m_str, iter);
    IRTLASSERT(!f);
    IRTLASSERT(iter == pTbl->end());

    i = pTbl->Size();
    IRTLTRACE1("\n\nAbout to erase %d records\n\n", i);

    for (iter = pTbl->begin();  iter != pTbl->end();  --i)
    {
        IRTLTRACE1("\n\terase %d\n", i);
        IRTLVERIFY(pTbl->Erase(iter));
    }

    IRTLASSERT(i == 0);
    IRTLASSERT(pTbl->Size() == 0);
    CheckRefCounts(0);

    IRTLTRACE1("\n\nAbout to insert %d records\n\n", iLast - iFirst);
    for (i = iFirst;  i != iLast;  ++i)
    {
        f = pTbl->Insert(&g_wordtable[i], iter);
        IRTLASSERT(f  &&  iter.Record() == &g_wordtable[i]);
        IRTLTRACE2("\n\tInserted: %d, %hs\n", i, iter.Key()->m_psz);
    }

    // Reset iter so that it isn't pointing to anything, raising its refcount
    iter = pTbl->end();
    CheckRefCounts(1, iFirst, iLast);

    IRTLTRACE1("\n\nAbout to Erase2 %d records\n\n", iLast - iFirst);
    f = pTbl->Erase(pTbl->begin(), pTbl->end());
    IRTLASSERT(f  &&  pTbl->Size() == 0);

    CheckRefCounts(0);

    IRTLTRACE1("\n\nAbout to insert %d records, again\n\n", iLast - iFirst);
    for (i = iFirst;  i != iLast;  ++i)
    {
        f = pTbl->Insert(&g_wordtable[i], iter);
        IRTLASSERT(f  &&  iter.Record() == &g_wordtable[i]);
        IRTLTRACE2("\n\tInserted: %d, %hs\n", i, iter.Key()->m_psz);
    }

    // Reset iter so that it isn't pointing to anything, raising its refcount
    iter = pTbl->end();
    CheckRefCounts(1, iFirst, iLast);

    IRTLTRACE1("\nAbout to equalrange and erase2 %d records, backwards\n\n",
               iLast - iFirst);
    for (i = iLast;  --i >= iFirst;  )
    {
        CWordHash::iterator iterLast;

        f = pTbl->EqualRange(&g_wordtable[i].m_str, iter, iterLast);
        IRTLASSERT(f  &&  iter.Record() == &g_wordtable[i]);
        IRTLTRACE3("\n\tEqualRange: %d, \"%hs\", %d\n",
                   i, iter.Key()->m_psz, iter.Record()->m_cRefs);

        f = pTbl->Erase(iter, iterLast);
        IRTLASSERT(f);
        IRTLTRACE1("\n\tErase2d: %d\n", i);
    }

    IRTLASSERT(pTbl->Size() == 0);
    CheckRefCounts(0);

    delete pTbl;

#if 1
    pTbl = new CWordHash(highload, initsize, nsubtbls) ;
#else
    pTbl = new CWordHash(1, // LK_DFLT_MAXLOAD * 6,
                         100000, // LK_SMALL_TABLESIZE,
                         17); // # subtables
#endif

    CheckRefCounts(0);
    
    IRTLTRACE0("Building the table\n");
    for (i = 0 ; i < g_nokeys ; i++ )
    {
        g_wordtable[i].m_fIterated = false;
        IRTLVERIFY(pTbl->InsertRecord(&g_wordtable[i]) == LK_SUCCESS);
    }

    IRTLASSERT(g_nokeys == (int) pTbl->Size());
    IRTLASSERT(pTbl->CheckTable() == 0);

    test_stl_iterators2(pTbl);

    IRTLTRACE0("Cleaning up by hand\n");
    for (i = 0 ; i < g_nokeys ; i++ )
    {
        IRTLVERIFY(pTbl->DeleteKey(&g_wordtable[i].m_str) == LK_SUCCESS);
    }
    
    IRTLASSERT(0 == pTbl->Size());

    delete pTbl ;
}



void test_stl_iterators2(
    CWordHash *pTbl)
{
    IRTLTRACE0("Checking STL iterators\n");
    size_t cRec = 0;
    int i;
    
    for (CWordHash::iterator iter = pTbl->begin();
        iter != pTbl->end();
         ++iter)
    {
        ++cRec;
        const CStr* pstrKey = iter.Key();
        CWord*      pRec    = iter.Record();

        IRTLASSERT(&g_wordtable[0] <= pRec  &&  pRec < &g_wordtable[g_nokeys]);
        IRTLASSERT(!pRec->m_fIterated);
        pRec->m_fIterated = true;
        // IRTLTRACE3("%d: %p, %hs\n", cRec, pRec, pstrKey->m_psz);
    }
    
    IRTLASSERT((int) cRec == g_nokeys);

    IRTLTRACE1("Checking that all %d records were touched\n", g_nokeys);
    CheckRefCounts(1);

    for (i = 0 ; i < g_nokeys ; i++ )
    {
        IRTLASSERT(g_wordtable[i].m_fIterated);
        g_wordtable[i].m_fIterated = false;
    }
}

#endif // LKR_STL_ITERATORS



#ifndef LKRHASH_KERNEL_MODE

void print_table_statistics(const CLKRHashTableStats& stats)
{
    _tprintf(_TEXT("#Records=%d, #BucketChains=%d, ")
           _TEXT("DirSize=%d, LongestChain=%3d,\n"),
           stats.RecordCount, stats.TableSize,
           stats.DirectorySize, stats.LongestChain);
           
    _tprintf(_TEXT("#Empty Buckets=%d, Split Factor=%.2f, ")
           _TEXT("AvgSrchLen=%.2f, Expected SL=%.2f,\n"),
           stats.EmptySlots, stats.SplitFactor,
           stats.AvgSearchLength, stats.ExpSearchLength);

    _tprintf(_TEXT("Avg Unsuccessful SrchLen=%.2f, ExpUSL=%.2f.\n"),
           stats.AvgUSearchLength, stats.ExpUSearchLength);

    _tprintf(_TEXT("\nBucket Chain Lengths ")
           _TEXT("(node clump size = %d, bucket size = %d bytes):\n"),
           stats.NodeClumpSize, stats.CBucketSize);
    for (int j = 0;  j < CLKRHashTableStats::MAX_BUCKETS;  ++j)
    {
        if (stats.m_aBucketLenHistogram[j] == 0)
        {
            _tprintf(_TEXT("\n"));
            break;
        }
        _tprintf(_TEXT(" %10d: %6d"),
               stats.BucketSize(j), stats.m_aBucketLenHistogram[j]);
        if (j % 4 == 3)
            _tprintf(_TEXT("\n"));
    }

    _tprintf(_TEXT("\n"));
}


#ifdef LOCK_INSTRUMENTATION

void print_lock_statistics(const CLKRHashTableStats& stats)
{
    _tprintf(_TEXT("Global Locks Statistics:")
           _TEXT("\n   total locks created = %ld, ")
           _TEXT("total contentions = %ld, ")
           _TEXT("#sleeps = %ld,")
           _TEXT("\n   total spins = %I64d, ")
           _TEXT("av spins/contention = %.1f, ")
           _TEXT("\n   #readlocks = %d, ")
           _TEXT("#writelocks=%d\n"),
           stats.m_gls.m_cTotalLocks,
           stats.m_gls.m_cContendedLocks,
           stats.m_gls.m_nSleeps,
           stats.m_gls.m_cTotalSpins,
           stats.m_gls.m_nAverageSpins,
           stats.m_gls.m_nReadLocks,
           stats.m_gls.m_nWriteLocks
           );

    _tprintf(_TEXT("Averaged SubTable Locks Statistics:")
           _TEXT("\n   Total locks = %d, ")
           _TEXT("#contentions = %.1f, ")
           _TEXT("sleeps = %.1f; ")
           _TEXT("\n   total spins = %.1f, ")
           _TEXT("avg spins = %.1f, ")
           _TEXT("\n   #readlocks = %.1f, ")
           _TEXT("#writelocks=%.1f\n"),
           stats.m_alsTable.m_nItems,
           stats.m_alsTable.m_nContentions,
           stats.m_alsTable.m_nSleeps,
           stats.m_alsTable.m_nContentionSpins,
           stats.m_alsTable.m_nAverageSpins,
           stats.m_alsTable.m_nReadLocks,
           stats.m_alsTable.m_nWriteLocks);

    _tprintf(_TEXT("Averaged Bucket Locks Statistics:")
           _TEXT("\n   Total locks = %d, ")
           _TEXT("#contentions = %.1f, ")
           _TEXT("sleeps = %.1f; ")
           _TEXT("\n   total spins = %.1f, ")
           _TEXT("avg spins = %.1f, ")
           _TEXT("\n   #readlocks = %.1f, ")
           _TEXT("#writelocks=%.1f\n"),
           stats.m_alsBucketsAvg.m_nItems,
           stats.m_alsBucketsAvg.m_nContentions,
           stats.m_alsBucketsAvg.m_nSleeps,
           stats.m_alsBucketsAvg.m_nContentionSpins,
           stats.m_alsBucketsAvg.m_nAverageSpins,
           stats.m_alsBucketsAvg.m_nReadLocks,
           stats.m_alsBucketsAvg.m_nWriteLocks);

    _tprintf(_TEXT("\n"));
}

#endif // LOCK_INSTRUMENTATION

#endif // !LKRHASH_KERNEL_MODE
    
int expand_key_set(int maxkeys, int numkeys, bool fVerbose)
{
    int totkeys = numkeys ;
    if (totkeys > maxkeys)
        return maxkeys;

    char* pszTemp = new char [20 + CStr::sm_cchMax];

    for(int k = 0; TRUE; k++)
    {
        for(int i = 0; i < numkeys; i++)
        {
            if (totkeys == maxkeys)
            {
                delete [] pszTemp;
                return(totkeys) ;
            }

            sprintf(pszTemp, "%d%hs", k, g_wordtable[i].m_str.m_psz);
            g_wordtable[totkeys++].m_str.Set(pszTemp, strlen(pszTemp));
        }

        if (fVerbose)
            putchar('.');
    }
}



#ifdef LKRHASH_KERNEL_MODE
void
#else
unsigned __stdcall
#endif
exercise_table(
    void* pinput)
{
    CWordHash*    pTbl;
    thread_data*  pdea = (thread_data*) pinput ;
    int           cfailed_ins=0 ;
    int           cfailed_dels=0 ;
    int           cFoundSuccesses=0, cFoundFails=0 ;
    int           x, i ;
    LK_RETCODE    lkrc;

    SetThreadIdealProcessor(GetCurrentThread(),
                            pdea->threadno % NumProcessors());

#ifndef LKRHASH_KERNEL_MODE
    LARGE_INTEGER liFreq, liT1, liT2;
    IRTLVERIFY(QueryPerformanceFrequency(&liFreq));
    IRTLVERIFY(QueryPerformanceCounter(&liT1));
#endif // !LKRHASH_KERNEL_MODE

    pdea->cinserts = 0 ;
    pdea->cdeletes = 0 ;
    pdea->clookups = 0 ;
    pTbl = pdea->ptbl ;
    srand(pdea->m_nSeed);

    for (int rnd = 0; rnd < pdea->rounds; rnd++)
    {
        IRTLASSERT(pTbl->CheckTable() == 0);

        // Insert all the keys, randomly searching after each insertion
        for (i = pdea->first_key ; i < pdea->last_key ; i++ )
        {
#ifdef IRTLDEBUG
            CStr*  pstrKey = &g_wordtable[i].m_str;
            CWord* pRec     = NULL;
            lkrc = pTbl->FindKey(pstrKey, &pRec);
            IRTLASSERT(lkrc == LK_NO_SUCH_KEY  &&  pRec == NULL);
#endif // IRTLDEBUG

            if (pTbl->InsertRecord(&g_wordtable[i] ) != LK_SUCCESS )
            {
                cfailed_ins++ ;
            }
            else
            {
#ifdef IRTLDEBUG
                pstrKey = &g_wordtable[i].m_str;
                lkrc = pTbl->FindKey(pstrKey, &pRec);
                IRTLASSERT(lkrc == LK_SUCCESS  &&  pRec == &g_wordtable[i]);
                pTbl->AddRefRecord(pRec, LKAR_EXPLICIT_RELEASE);
#endif // IRTLDEBUG

                g_wordtable[i].m_fInserted = true;
            }

            pdea->cinserts++ ;

            for (int lu = 0; lu < pdea->lookup_freq; lu++)
            {
                x = rand() % (pdea->last_key - pdea->first_key)
                    + pdea->first_key;
                bool fPresent = (x <= i); // should it be found?
                CWord* pRec   = NULL;
                LK_RETCODE lkrc;

                if (pdea->m_nFindKeyCopy > 0
                    &&  rand() % pdea->m_nFindKeyCopy == 0)
                {
                    char szTemp[MAX_STRSIZE];
                    strcpy(szTemp, g_wordtable[x].m_str.m_psz);
                    CStr strTemp(szTemp, g_wordtable[x].m_str.m_cch, false);
                    lkrc = pTbl->FindKey(&strTemp, &pRec);
                }
                else
                    lkrc = pTbl->FindKey(&g_wordtable[x].m_str, &pRec);

                if (fPresent)
                {
                    if (lkrc != LK_SUCCESS  ||  pRec != &g_wordtable[x] )
                    {
                        ++g_wordtable[x].m_cNotFound;
                        IRTLTRACE(_TEXT("%d: Not found (%hs): x = %d, i = %d, ")
                              _TEXT("cnf = %d, rnd = %d, lkrc = %d, ")
                              _TEXT("pRec(%hs), %d\n"),
                              pdea->threadno, g_wordtable[x].m_str.m_psz, x, i,
                              g_wordtable[x].m_cNotFound, rnd, lkrc,
                              pRec != NULL ? pRec->m_str.m_psz : "<null>",
                              pRec != NULL ? (pRec - g_wordtable) / sizeof(CWord) : -1);
                        cFoundFails++ ;
                    }
                    else
                    {
                        pTbl->AddRefRecord(pRec, LKAR_EXPLICIT_RELEASE);
                        cFoundSuccesses++ ;
                    }
                }
                else // not fPresent
                {
                    IRTLASSERT(lkrc != LK_SUCCESS  &&  pRec == NULL);
                    if (lkrc == LK_SUCCESS  ||  pRec != NULL)
                    {
                        IRTLTRACE(_TEXT("%d: found when not present (%hs): ")
                              _TEXT("x = %d, i = %d, ")
                              _TEXT("cnf = %d, rnd = %d, lkrc = %d, ")
                              _TEXT("pRec(%hs), %d\n"),
                              pdea->threadno, g_wordtable[x].m_str.m_psz,
                              x, i,
                              g_wordtable[x].m_cNotFound, rnd, lkrc,
                              pRec != NULL ? pRec->m_str.m_psz : "<null>",
                              pRec != NULL ? (pRec - g_wordtable) / sizeof(CWord) : -1);
                        cFoundFails++ ;
                    }
                    else
                    {
                        // wasn't found, but it wasn't present, so this is good
                        cFoundSuccesses++ ;
                    }
                }
            }

            pdea->clookups += pdea->lookup_freq ;
            
#ifdef LKR_EXPOSED_TABLE_LOCK
            if (pdea->m_nInsertIfNotFound > 0
                &&  rand() % pdea->m_nInsertIfNotFound == 0)
            {
                bool fWrite = (rand() & 1) != 0;

                if (fWrite)
                    pTbl->WriteLock();
                else
                    pTbl->ReadLock();
                
                x = rand() % (pdea->last_key - pdea->first_key)
                    + pdea->first_key;
                bool fPresent   = (x <= i); // should it be found?
                CStr*  pstrKey  = &g_wordtable[x].m_str;
                CWord* pRec     = NULL;
                
                lkrc = pTbl->FindKey(pstrKey, &pRec);
                
                if (pRec != NULL)
                {
                    IRTLASSERT(lkrc == LK_SUCCESS);
                    IRTLASSERT(pRec == &g_wordtable[x]);
                    IRTLASSERT(x <= i);
                    pTbl->AddRefRecord(pRec, LKAR_EXPLICIT_RELEASE);
                }
                else if (fWrite)
                {
                    IRTLASSERT(x > i);
                    IRTLASSERT(lkrc == LK_NO_SUCH_KEY);

                    lkrc = pTbl->InsertRecord(&g_wordtable[x], false);
                    IRTLASSERT(lkrc == LK_SUCCESS);
                    InterlockedIncrement(&g_wordtable[x].m_cInsertIfNotFounds);
                    
                    lkrc = pTbl->DeleteKey(&g_wordtable[x].m_str);
                    IRTLASSERT(lkrc == LK_SUCCESS);
                }
            
                if (fWrite)
                    pTbl->WriteUnlock();
                else
                    pTbl->ReadUnlock();
            }
#endif // LKR_EXPOSED_TABLE_LOCK
        }

        IRTLASSERT(cfailed_ins == 0) ;
        IRTLASSERT(cFoundFails == 0) ;
        IRTLASSERT(cFoundSuccesses == ((2 * rnd + 1) * pdea->lookup_freq
                              * (pdea->last_key - pdea->first_key)));

        IRTLTRACE(_TEXT("Thrd %u, rnd %d: %d inserts done, not found %d, ")
                  _TEXT("f=%d, l=%d\n"), 
                  pdea->threadno, rnd, pdea->cinserts, cFoundFails,
                  pdea->first_key, pdea->last_key) ;
        IRTLASSERT(pTbl->CheckTable() == 0);

        // Delete all the keys, randomly searching before each deletion
        for (i = pdea->first_key ; i < pdea->last_key ; i++ )
        {
            for (int lu = 0; lu < pdea->lookup_freq; lu++)
            {
                x = rand() % (pdea->last_key - pdea->first_key)
                    + pdea->first_key;
                bool fPresent = (x >= i); // should it be found?
                CWord* pRec   = NULL;
                LK_RETCODE lkrc;

                if (pdea->m_nFindKeyCopy > 0
                    &&  rand() % pdea->m_nFindKeyCopy == 0)
                {
                    char szTemp[MAX_STRSIZE];
                    strcpy(szTemp, g_wordtable[x].m_str.m_psz);
                    CStr strTemp(szTemp, g_wordtable[x].m_str.m_cch, false);
                    lkrc = pTbl->FindKey(&strTemp, &pRec);
                }
                else
                    lkrc = pTbl->FindKey(&g_wordtable[x].m_str, &pRec);

                if (fPresent)
                {
                    if (lkrc != LK_SUCCESS  ||  pRec != &g_wordtable[x] )
                    {
                        ++g_wordtable[x].m_cNotFound;
                        IRTLTRACE(_TEXT("%d: Not found (%hs): x = %d, i = %d, ")
                              _TEXT("cnf = %d, rnd = %d, lkrc = %d, ")
                              _TEXT("pRec(%hs), %d\n"),
                              pdea->threadno, g_wordtable[x].m_str.m_psz, x, i,
                              g_wordtable[x].m_cNotFound, rnd, lkrc,
                              pRec != NULL ? pRec->m_str.m_psz : "<null>",
                              pRec != NULL ? (pRec - g_wordtable) / sizeof(CWord) : -1);
                        cFoundFails++ ;
                    }
                    else
                    {
                        pTbl->AddRefRecord(pRec, LKAR_EXPLICIT_RELEASE);
                        cFoundSuccesses++ ;
                    }
                }
                else // !fPresent
                {
                    IRTLASSERT(lkrc != LK_SUCCESS  &&  pRec == NULL);
                    if (lkrc == LK_SUCCESS  ||  pRec != NULL)
                    {
                        IRTLTRACE(_TEXT("%d: found when not present (%hs): ")
                              _TEXT("x = %d, i = %d, ")
                              _TEXT("cnf = %d, rnd = %d, lkrc = %d, ")
                              _TEXT("pRec(%hs), %d\n"),
                              pdea->threadno, g_wordtable[x].m_str.m_psz,
                              x, i,
                              g_wordtable[x].m_cNotFound, rnd, lkrc,
                              pRec != NULL ? pRec->m_str.m_psz : "<null>",
                              pRec != NULL ? (pRec - g_wordtable) / sizeof(CWord) : -1);
                        cFoundFails++ ;
                    }
                    else
                    {
                        // wasn't found, but it wasn't present, so this is good
                        cFoundSuccesses++ ;
                    }
                }
            }
            pdea->clookups += pdea->lookup_freq ;

#ifdef IRTLDEBUG
            CStr*  pstrKey  = &g_wordtable[i].m_str;
            CWord* pRec     = NULL;
            LK_RETCODE lkrc = pTbl->FindKey(pstrKey, &pRec);
            IRTLASSERT(lkrc == LK_SUCCESS  &&  pRec == &g_wordtable[i]);
            pTbl->AddRefRecord(pRec, LKAR_EXPLICIT_RELEASE);
#endif // IRTLDEBUG

            if (pTbl->DeleteKey(&g_wordtable[i].m_str) != LK_SUCCESS )
            {
                cfailed_dels++ ;
            }
            else
            {
#ifdef IRTLDEBUG
                pstrKey = &g_wordtable[i].m_str;
                lkrc = pTbl->FindKey(pstrKey, &pRec);
                IRTLASSERT(lkrc == LK_NO_SUCH_KEY  &&  pRec == NULL);
#endif // IRTLDEBUG

                g_wordtable[i].m_fInserted = false;
            }
            pdea->cdeletes++ ;
        }

#ifdef IRTLDEBUG
        int cBadKeys = 0;
        for (i = pdea->first_key ; i < pdea->last_key ; i++ )
        {
            if (g_wordtable[i].m_cNotFound > 0)
            {
                ++cBadKeys;
                IRTLTRACE(_TEXT("%-20hs: #not found = %d, hash = %d, %08x\n"),
                          g_wordtable[i].m_str.m_psz,
                          g_wordtable[i].m_cNotFound,
                          CWordHash::CalcKeyHash(CWordHash::ExtractKey(
                                                 &g_wordtable[i])),
                          CWordHash::CalcKeyHash(CWordHash::ExtractKey(
                                                 &g_wordtable[i])));
            }
        }
        if (cBadKeys > 0)
            IRTLTRACE1("%d bad keys\n", cBadKeys);
        IRTLASSERT(cBadKeys == 0);
#endif // IRTLDEBUG

        IRTLASSERT(cfailed_dels == 0 ) ;
        IRTLASSERT(cFoundFails == 0 ) ;
        IRTLASSERT(cFoundSuccesses == ((2 * rnd + 2) * pdea->lookup_freq
                              * (pdea->last_key - pdea->first_key)));
        IRTLTRACE(_TEXT("Thrd %u, rnd %d: %d deletes done, not found %d, ")
                  _TEXT("f=%d, l=%d\n"), 
                  pdea->threadno, rnd, pdea->cdeletes, cFoundFails,
                  pdea->first_key, pdea->last_key) ;
    } // (for rnd)

#ifndef LKRHASH_KERNEL_MODE
    IRTLVERIFY(QueryPerformanceCounter(&liT2));
    pdea->duration = (liT2.QuadPart-liT1.QuadPart) / (double) liFreq.QuadPart;
#endif // !LKRHASH_KERNEL_MODE

    IRTLASSERT(pTbl->CheckTable() == 0);

    IRTLTRACE3("Thread %u terminating: %d found, %d not found\n",
              pdea->threadno, cFoundSuccesses, cFoundFails) ;

    if (cFoundSuccesses != (2 * pdea->rounds * pdea->lookup_freq
                   * (pdea->last_key - pdea->first_key))
        ||  cFoundFails != 0  ||  cfailed_ins != 0  ||  cfailed_dels != 0)
    {
        _tprintf(_TEXT("Thread %u: found = %d, not found = %d, ")
               _TEXT("\nfailed inserts = %d, failed deletes = %d\n"),
               pdea->threadno, cFoundSuccesses, cFoundFails,
               cfailed_ins, cfailed_dels);
    }

    pdea->cfailures = cfailed_ins + cfailed_dels + cFoundFails;

    if (pdea->hevFinished != NULL)
        SetEvent(pdea->hevFinished);

#ifndef LKRHASH_KERNEL_MODE
    return 0;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\samples\hashtest\main.cpp ===
/*++

   Copyright    (c) 1998-2000    Microsoft Corporation

   Module  Name :
       HashTest.cpp

   Abstract:
       Test harness for LKRhash

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#include "precomp.hxx"
#include "WordHash.h"
#include "IniFile.h"

int __cdecl
_tmain(
    int argc,
    TCHAR **argv)
{
    TCHAR            tszIniFile[MAX_PATH];
    CIniFileSettings ifs;

    if (argc == 2)
    {
        GetFullPathName(argv[1], MAX_PATH, tszIniFile, NULL);
        ifs.ReadIniFile(tszIniFile);

        FILE* fp = _tfopen(ifs.m_tszDataFile, _TEXT("r"));

        if (fp == NULL)
        {
            TCHAR tszDrive[_MAX_DRIVE], tszDir[_MAX_DIR];
            
            _tsplitpath(tszIniFile, tszDrive, tszDir, NULL, NULL);
            
            _stprintf(tszIniFile, "%s%s%s", tszDrive, tszDir,
                      ifs.m_tszDataFile);
            _tcscpy(ifs.m_tszDataFile, tszIniFile);

            fp = _tfopen(ifs.m_tszDataFile, _TEXT("r"));
        }

        if (fp != NULL)
            fclose(fp);
        else
            _ftprintf(stderr, _TEXT("%s: Can't open datafile `%s'.\n"),
                      argv[0], ifs.m_tszDataFile) ;
    }
    else
    {
        _ftprintf(stderr, _TEXT("Usage: %s ini-file\n"), argv[0]);
        exit(1);
    }

    LKR_TestHashTable(ifs);

    return(0) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\samples\hashtest\wordhash.h ===
#ifndef __WORDHASH_H__
#define __WORDHASH_H__

#define MAXKEYS      1000000
#define MAX_THREADS  MAXIMUM_WAIT_OBJECTS
#define MAX_STRSIZE  300

#ifndef __LKRHASH_H__

 typedef PLkrHashTable WordBaseTable;
 #define LKR_PUBLIC_API
 #include <lkrhash.h>

#endif //  !__LKRHASH_H__


#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
 using namespace LKRhash;
#else
 #define LKRHASH_NS
#endif // !__LKRHASH_NO_NAMESPACE__

#ifndef __HASHFN_NO_NAMESPACE__
 using namespace HashFn;
#endif // !__HASHFN_NO_NAMESPACE__


#ifndef LKR_PUBLIC_API
 typedef LKRHASH_NS::CLKRHashTable WordBaseTable;
 // typedef LKRHASH_NS::CLKRLinearHashTable WordBaseTable;
#endif



// A string wrapper class that keeps track of the length of the string data.
// A more useful string class would refcount the data and have copy-on-write
// semantics (or use MFC's CString or STL's string classes).

class CStr
{
public:
    const char* m_psz;
    short       m_cch;
    bool        m_fDynamic;
    
    static int  sm_cchMax;

    CStr()
        :  m_psz(NULL),
           m_cch(0),
           m_fDynamic(false)
    { 
    }
    
    CStr(
        const char* psz,
        int cch,
        bool fDynamic)
        :  m_psz(NULL),
           m_cch(static_cast<short>(cch)),
           m_fDynamic(fDynamic)
    { 
        if (fDynamic)
            Set(psz, cch);
        else
            m_psz = psz;
            
    }
    
    void Set(
        const char* psz,
        int cch)
    { 
        delete [] const_cast<char*>(m_psz);
        m_psz = new char[cch+1];
        strcpy(const_cast<char*>(m_psz), psz);
        m_cch = static_cast<short>(cch);
        m_fDynamic = true;
        sm_cchMax = max(m_cch, sm_cchMax);
    }

    ~CStr()
    {
        if (m_fDynamic)
            delete [] const_cast<char*>(m_psz);
    }
};

#ifdef HASHTEST_STATIC_DATA
// length of longest string seen
int CStr::sm_cchMax = 0;
#endif


// a word from the data file, which contains one 'word' per line (may
// include spaces).

class CWord
{
public:
    int    m_cNotFound;
    CStr   m_str;
    bool   m_fInserted;
    bool   m_fIterated;
    LONG   m_cRefs;
    LONG   m_cInsertIfNotFounds;
    
    CWord()
        : m_cNotFound(0),
          m_fInserted(false),
          m_fIterated(false),
          m_cRefs(0),
          m_cInsertIfNotFounds(0)
    { 
    }
    
    ~CWord()
    {
        IRTLASSERT(m_cRefs == 0);
#ifdef IRTLDEBUG
        if (m_cRefs != 0)
            IRTLTRACE(_TEXT("\"%hs\": %d, %d\n"), m_str.m_psz, m_cRefs,
                      m_cInsertIfNotFounds);
#endif
    }
};


// globals
extern int        g_nokeys ;
extern CWord      g_wordtable[MAXKEYS];

const char*
LK_AddRefReasonCode2String(
    LK_ADDREF_REASON lkar);


// A hash table of CWords, indexed by CStr*s.
class CWordHash
#ifndef LKR_PUBLIC_API
    : public CTypedHashTable<CWordHash, CWord, const CStr*, WordBaseTable>
#else
    : public TypedLkrHashTable<CWordHash, CWord, const CStr*>
#endif
{
public:
    static bool sm_fCaseInsensitive;
    static bool sm_fMemCmp;
    static int  sm_nLastChars;
    static bool sm_fNonPagedAllocs;
    static bool sm_fRefTrace;
    
    static const CStr*
    ExtractKey(const CWord* pKey)
    {
        return &pKey->m_str;
    }

    static DWORD
    CalcKeyHash(const CStr* pstrKey)
    {
        const char* psz = pstrKey->m_psz;

        // use only the last few chars instead of whole string?
        if (sm_nLastChars > 0  &&  pstrKey->m_cch >= sm_nLastChars)
            psz = pstrKey->m_psz + pstrKey->m_cch - sm_nLastChars;

        IRTLASSERT(pstrKey->m_psz <= psz
                   &&  psz < pstrKey->m_psz + pstrKey->m_cch);

        if (sm_fCaseInsensitive)
            return HashStringNoCase(psz, pstrKey->m_cch);
        else
            return HashString(psz, pstrKey->m_cch);
    }

    static bool
    EqualKeys(const CStr* pstrKey1, const CStr* pstrKey2)
    {
        if (pstrKey1->m_cch != pstrKey2->m_cch)
            return false;
        else if (sm_fCaseInsensitive)
        {
            if ((pstrKey1->m_psz[0] & 0xDF) == (pstrKey2->m_psz[0] & 0xDF))
                return (sm_fMemCmp
                        ? _memicmp(pstrKey1->m_psz, pstrKey2->m_psz,
                                   pstrKey1->m_cch)
                        : _stricmp(pstrKey1->m_psz, pstrKey2->m_psz)) == 0;
            else
                return false;
        }
        else
        {
            if (pstrKey1->m_psz[0] == pstrKey2->m_psz[0])
                return (sm_fMemCmp
                        ? memcmp(pstrKey1->m_psz, pstrKey2->m_psz,
                                 pstrKey1->m_cch)
                        : strcmp(pstrKey1->m_psz, pstrKey2->m_psz)) == 0;
            else
                return false;
        }
    }

    static void
    AddRefRecord(CWord* pRec, LK_ADDREF_REASON lkar)
    {
        int  nIncr = (lkar > 0) ? +1 : -1;
        LONG cRefs = nIncr + InterlockedExchangeAdd(&pRec->m_cRefs, nIncr);
        if (sm_fRefTrace)
            IRTLTRACE(_TEXT("\tAddRef key(%d, %p: \"%hs\"), %hs (%s), = %d\n"),
                      pRec - g_wordtable, pRec, pRec->m_str.m_psz,
                      (nIncr > 0) ? "+1" : "-1",
                      LKR_AddRefReasonAsString(lkar), cRefs);
        IRTLASSERT(cRefs >= 0);
    }

    CWordHash(
        double          maxload,    // Bound on avg chain length
        size_t          initsize,   // Initial size of hash table.
        size_t          num_subtbls // #subordinate hash tables.
        )
#ifndef LKR_PUBLIC_API
        : CTypedHashTable<CWordHash, CWord, const CStr*, WordBaseTable>
                ("wordhash", maxload, initsize, num_subtbls
# ifdef LKRHASH_KERNEL_MODE
                 , sm_fNonPagedAllocs // use paged or NP pool
# endif
                 )
#else // LKR_PUBLIC_API
        : TypedLkrHashTable<CWordHash, CWord, const CStr*>
                ("wordhash", (LK_TABLESIZE) initsize)
#endif // LKR_PUBLIC_API
    {}

    template <class _InputIterator>
    CWordHash(
        _InputIterator  f,
        _InputIterator  l,
        double          maxload,    // Bound on avg chain length
        size_t          initsize,   // Initial size of hash table.
        size_t          num_subtbls // #subordinate hash tables.
        )
#ifndef LKR_PUBLIC_API
        : CTypedHashTable<CWordHash, CWord, const CStr*, WordBaseTable>
                ("wordhash", f, l, maxload, initsize, num_subtbls)
#else
        : TypedLkrHashTable<CWordHash, CWord, const CStr*>
                ("wordhash", f, l, (LK_TABLESIZE) initsize)
#endif
    {}

    static const TCHAR*
    HashMethod()
    {
        TCHAR tszLast[20];
        static TCHAR s_tsz[80];

        if (sm_nLastChars > 0)
            _stprintf(tszLast, _TEXT("last %d"), sm_nLastChars);
        else
            _tcscpy(tszLast, _TEXT("all"));

        _stprintf(s_tsz, _TEXT("case-%ssensitive, %scmp, %s chars"),
                  sm_fCaseInsensitive ? _TEXT("in") : _TEXT(""),
                  sm_fMemCmp ? _TEXT("mem") : _TEXT("str"),
                  tszLast);

        return s_tsz;
    }

#ifdef LKR_PUBLIC_API
    typedef CLKRHashTable             BaseHashTable;
    typedef BaseHashTable::TableLock  TableLock;
    typedef BaseHashTable::BucketLock BucketLock;

    enum {
        NODES_PER_CLUMP = BaseHashTable::NODES_PER_CLUMP,
    };

    static const TCHAR* ClassName()
    {return _TEXT("PLkrHashTable");}

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls)
    { return BaseHashTable::NumSubTables(rinitsize, rnum_subtbls); }

    int                NumSubTables() const
    { return reinterpret_cast<BaseHashTable*>(m_plkr)->NumSubTables(); }

    void        SetTableLockSpinCount(WORD wSpins)
    { reinterpret_cast<BaseHashTable*>(m_plkr)->SetTableLockSpinCount(wSpins);}

    void        SetBucketLockSpinCount(WORD wSpins)
    { reinterpret_cast<BaseHashTable*>(m_plkr)->SetBucketLockSpinCount(wSpins);}

    CLKRHashTableStats GetStatistics() const
    { return reinterpret_cast<BaseHashTable*>(m_plkr)->GetStatistics();}

#endif // LKR_PUBLIC_API
};

#endif // __WORDHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\samples\numset\numset.cpp ===
/* Test driver for class HashTable             */
/* Author: Paul Larson, palarson@microsoft.com */
/* Much hacked upon by George V. Reilly, georgere@microsoft.com */

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>


#include "numset.h"


LK_RETCODE
InsertRecord(
    CNumberTestHashTable* pntht,
    int n)
{
    return pntht->InsertRecord((const int*) (DWORD_PTR) n);
}


LK_RETCODE
FindKey(
    CNumberTestHashTable* pntht,
    int nKey,
    int** pptOut)
{
    return pntht->FindKey(nKey, pptOut);
}


LK_RETCODE
DeleteKey(
    CNumberTestHashTable* pntht,
    int nKey)
{
    return pntht->DeleteKey(nKey);
}


void Test(
    CNumberTestHashTable* pntht,
    int n)
{
    int* pt2 = NULL;

    IRTLVERIFY(LK_SUCCESS == InsertRecord(pntht, n));
    IRTLVERIFY(LK_SUCCESS == FindKey(pntht, n, &pt2));
    printf("FK = %d\n", (int) (DWORD_PTR) pt2);
    IRTLVERIFY(LK_SUCCESS == DeleteKey(pntht, n));
}


int __cdecl
main(
    int argc,
    char **argv)
{
    CNumberTestHashTable ntht;
    int n = 1965;

    Test(&ntht, n);

    return(0) ;

} /* main */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\samples\hashtest\kernel\kmain.cpp ===
/*++

   Copyright    (c) 1998-2000    Microsoft Corporation

   Module  Name :
       HashTest.cpp

   Abstract:
       Kernel-mode test harness for LKRhash

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - Kernel Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


#include "precomp.hxx"


extern "C"
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\samples\minfan\minfan.cpp ===
// Repro case for LKRhash Clear bug

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>


#include "MinFan.h"

void
test(
    int N)
{
	printf("\nTest driver for LKRhash for wchar, %d\n", N);

    // A case-senstive string-to-int map
    CWcharHashTable map;
    int index;
    LK_RETCODE lkrc;
#ifdef LKR_DEPRECATED_ITERATORS
	CWcharHashTable::CIterator iter;
#endif // LKR_DEPRECATED_ITERATORS

#if 1
    // Some objects for the hash tables
    printf("\tFirst Insertion Loop\n");
	for ( index = 0; index < N; index++)
	{
		char buf[30];
		sprintf(buf, "page%04d.htm", index);
		VwrecordBase* psoRecord = new VwrecordBase(buf, index);
		// printf("Insert1: pso is %s\n", psoRecord->getKey());
		map.InsertRecord(psoRecord);
	}   
#endif
    
#ifdef LKR_DEPRECATED_ITERATORS
    printf("\tFirst Iteration Loop\n");
    for (lkrc = map.InitializeIterator(&iter);
         lkrc == LK_SUCCESS;
         lkrc = map.IncrementIterator(&iter))
    {
		const VwrecordBase* psoRecord = iter.Record();
		// printf("Iterate1: pso is %s\n", psoRecord->getKey());
	}
    lkrc = map.CloseIterator(&iter);
#endif // LKR_DEPRECATED_ITERATORS
    
	printf("\tAfter insertions, size of map is %d\n", map.Size());	
	
	map.Clear();
    printf("\tAfter Clear(), size of map is %d\n", map.Size());

    printf("\tSecond Insertion Loop\n");
	for ( index = 0; index < N; index++)
	{
		char buf[30];
		sprintf(buf, "page%4d", index);
		VwrecordBase* psoRecord = new VwrecordBase(buf, index);
		// printf("Insert2: pso is %s\n", psoRecord->getKey());
		map.InsertRecord(psoRecord);
	}   
    
#ifdef LKR_DEPRECATED_ITERATORS
    printf("\tSecond Iteration Loop\n");
    for (index = 0, lkrc = map.InitializeIterator(&iter);
         lkrc == LK_SUCCESS;
         ++index, lkrc = map.IncrementIterator(&iter))
    {
		const VwrecordBase* psoRecord = iter.Record();
		// printf("Iterate2: %d, pso is %s\n", index, psoRecord->getKey());
	}
    lkrc = map.CloseIterator(&iter);
#endif // LKR_DEPRECATED_ITERATORS

    printf("\tClearing again\n");
	map.Clear();

    printf("\tFinishing %d\n", N);
}



int __cdecl
main(
    int argc,
    char **argv)
{
#if 0
    for (int i = 0; i < 200000; ++i)
        test(i);
#endif

    int N = 5092;
    if (argc > 1)
        N = atoi(argv[1]);
    test(N);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\samples\numset\numset.h ===
//--------------------------------------------------------------------
// An example of how to create a wrapper for CLKRHashTable
//--------------------------------------------------------------------

#include <lkrhash.h>


#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
// using namespace LKRhash;
#else  // __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS
#endif // __LKRHASH_NO_NAMESPACE__

#ifndef __HASHFN_NO_NAMESPACE__
 #define HASHFN_NS HashFn
// using namespace HashFn;
#else  // __HASHFN_NO_NAMESPACE__
 #define HASHFN_NS
#endif // __HASHFN_NO_NAMESPACE__


class CNumberTestHashTable
    : public LKRHASH_NS::CTypedHashTable<CNumberTestHashTable, int, int>
{
public:
    CNumberTestHashTable()
        : LKRHASH_NS::CTypedHashTable<CNumberTestHashTable, int, int>(
            "NumberSet") {}
    static int   ExtractKey(const int* pn)       {return (int) (DWORD_PTR) pn;}
    static DWORD CalcKeyHash(int nKey)           {return nKey;}
    static bool  EqualKeys(int nKey1, int nKey2) {return nKey1 == nKey2;}
    static void  AddRefRecord(const int* pn, LK_ADDREF_REASON lkar)  {}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\samples\str-num\str-num.cpp ===
/* Test driver for class HashTable             */
/* Author: Paul Larson, palarson@microsoft.com */
/* Much hacked upon by George V. Reilly, georgere@microsoft.com */

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>


#include "str-num.h"


#ifdef LKR_APPLY_IF

// A class to exercise ApplyIf()

class CApplyIfTest
{
public:
    static LK_PREDICATE WINAPI
    Predicate(const CTest* pTest, void* pvState)
    {
        CApplyIfTest* pThis = static_cast<CApplyIfTest*>(pvState);
        ++pThis->m_cPreds;
        IRTLTRACE("CApplyIfTest::Predicate(%p (%s, %d), %p)\n",
                  pTest, pTest->m_sz, pTest->m_n, pThis);
        return ((pTest->m_n % 10 == 7)
                ?  LKP_PERFORM
                :  LKP_NO_ACTION);
    }

    static LK_ACTION WINAPI
    Action(const CTest* pTest, void* pvState)
    {
        CApplyIfTest* pThis = static_cast<CApplyIfTest*>(pvState);
        ++pThis->m_cActions;
        LK_ACTION lka = ((pTest->m_n > 30)
                                     ?  LKA_SUCCEEDED
                                     :  LKA_FAILED);

        IRTLTRACE("CApplyIfTest::Action(%p (%s, %d), %p) %s\n",
                  pTest, pTest->m_sz, pTest->m_n, pThis,
              lka == LKA_SUCCEEDED ? "succeeded" : "failed");

        if (lka == LKA_SUCCEEDED)
            ++pThis->m_cSuccesses;
        else if (lka == LKA_FAILED)
            ++pThis->m_cFailures;

        return lka;
    }

    int m_cPreds;
    int m_cActions;
    int m_cSuccesses;
    int m_cFailures;

    CApplyIfTest()
        : m_cPreds(0), m_cActions(0), m_cSuccesses(0), m_cFailures(0)
    {}
};


// The Predicate and Action functions can be static member functions,
// but don't have to be

LK_PREDICATE WINAPI
DeleteIfGt10(
    const CTest* pTest,
    void* pvState)
{
    IRTLTRACE("DeleteIfGt10(%p, %s, %p) = %d\n",
              pTest, pTest->m_sz, pvState, pTest->m_n);
    return ((pTest->m_n > 10)
            ?  LKP_PERFORM
            :   LKP_NO_ACTION);
}

#endif // LKR_APPLY_IF


void Test(
    bool fVerbose)
{
    // Some objects for the hash tables
    CTest tl(5,  "Larson",   true);
    CTest tk(17, "Krishnan", false);
    CTest tr(37, "Reilly",   true);

    // A string-keyed hash table
    CStringTestHashTable stht;

    IRTLVERIFY(LK_SUCCESS == stht.InsertRecord(&tl));
    IRTLVERIFY(LK_SUCCESS == stht.InsertRecord(&tk));
    IRTLVERIFY(LK_SUCCESS == stht.InsertRecord(&tr));

    IRTLTRACE("Check the overwrite feature of InsertRecord\n");
    IRTLVERIFY(LK_KEY_EXISTS == stht.InsertRecord(&tr, false));
    IRTLASSERT(tr.m_cRefs == 1);

    IRTLVERIFY(LK_SUCCESS == stht.InsertRecord(&tr, true));
    IRTLASSERT(tr.m_cRefs == 1);    // 1+1-1 == 1

    IRTLTRACE("Check that the keys are really present in the table and that "
              "the refcounting works\n");
    const CTest* pTest = NULL;

    IRTLVERIFY(LK_SUCCESS == stht.FindKey(tl.m_sz, &pTest)  &&  pTest == &tl);
    IRTLASSERT(tl.m_cRefs == 2);

    IRTLVERIFY(LK_SUCCESS == stht.FindKey(tk.m_sz, &pTest)  &&  pTest == &tk);
    IRTLASSERT(tk.m_cRefs == 2);

    IRTLVERIFY(LK_SUCCESS == stht.FindKey(tr.m_sz, &pTest)  &&  pTest == &tr);
    IRTLASSERT(tr.m_cRefs == 2);

    IRTLVERIFY(LK_SUCCESS == stht.FindRecord(&tr));
    IRTLASSERT(tr.m_cRefs == 2);    // FindRecord does not addref

    IRTLTRACE("Look for a key under an alternate spelling "
              "(case-insensitive)\n");
    IRTLVERIFY(LK_SUCCESS == stht.FindKey("rEiLlY", &pTest)  &&  pTest == &tr);
    IRTLASSERT(tr.m_cRefs == 3);

    IRTLTRACE("Release the references added by FindKey\n");
    stht.AddRefRecord(&tl, LKAR_EXPLICIT_RELEASE);
    tk.m_cRefs--;
    tr.m_cRefs = 1;

    IRTLTRACE("Now build the numeric hash table\n");
    CNumberTestHashTable ntht;

    IRTLVERIFY(LK_SUCCESS == ntht.InsertRecord(&tl));
    IRTLVERIFY(LK_SUCCESS == ntht.InsertRecord(&tk));
    IRTLVERIFY(LK_SUCCESS == ntht.InsertRecord(&tr));

#ifdef LKR_APPLY_IF
    IRTLTRACE("Test ApplyIf()\n");
    CApplyIfTest ait;

    IRTLVERIFY(1 == ntht.ApplyIf(ait.Predicate, ait.Action, &ait));
    IRTLASSERT(3 == ait.m_cPreds  &&  2 == ait.m_cActions
               &&  1 == ait.m_cSuccesses  &&  1 == ait.m_cFailures);

    IRTLTRACE("Test DeleteIf()\n");
    IRTLASSERT(3 == ntht.Size());
    ntht.DeleteIf(DeleteIfGt10, NULL);
    IRTLASSERT(1 == ntht.Size());

    IRTLTRACE("Check that the keys that were supposed to be deleted "
              "really are gone\n");
    IRTLASSERT(tl.m_n <= 10);
    IRTLVERIFY(LK_SUCCESS == ntht.FindKey(tl.m_n, &pTest)  &&  pTest == &tl);
    ntht.AddRefRecord(pTest, LKAR_EXPLICIT_RELEASE); // release ref

    IRTLASSERT(tk.m_n >  10);
    IRTLVERIFY(LK_NO_SUCH_KEY == ntht.FindKey(tk.m_n, &pTest)
               &&  pTest == NULL);

    IRTLASSERT(tr.m_n >  10);
    IRTLVERIFY(LK_NO_SUCH_KEY == ntht.FindKey(tr.m_n, &pTest)
               &&  pTest == NULL);

    IRTLVERIFY(LK_SUCCESS == ntht.DeleteKey(tl.m_n));
    IRTLASSERT(0 == ntht.Size());
#endif // LKR_APPLY_IF

#ifdef LKR_DEPRECATED_ITERATORS
    IRTLTRACE("Check Iterators\n");
    DWORD  cRec = 0;
    CStringTestHashTable::CIterator iter;
    LK_RETCODE lkrc = stht.InitializeIterator(&iter);

    while (lkrc == LK_SUCCESS)
    {
        ++cRec;
        CStringTestHashTable::Key     pszKey = iter.Key();
        CStringTestHashTable::Record* pRec   = iter.Record();

        IRTLASSERT(pRec == &tl  ||  pRec == &tk  ||  pRec == &tr);
        if (fVerbose)
            printf("Record(%p) contains \"%s\"\n", pRec, pszKey);
        lkrc = stht.IncrementIterator(&iter);
    }

    IRTLASSERT(lkrc == LK_NO_MORE_ELEMENTS);

    lkrc = stht.CloseIterator(&iter);
    IRTLASSERT(lkrc == LK_SUCCESS);
    IRTLASSERT(cRec == stht.Size());

    IRTLTRACE("Check const iterators\n");
    const CStringTestHashTable& sthtConst = stht;
    CStringTestHashTable::CConstIterator iterConst;
    cRec = 0;

    lkrc = sthtConst.InitializeIterator(&iterConst);

    while (lkrc == LK_SUCCESS)
    {
        ++cRec;
        const CStringTestHashTable::Key     pszKey = iterConst.Key();
        const CStringTestHashTable::Record* pRec   = iterConst.Record();

        IRTLASSERT(pRec == &tl  ||  pRec == &tk  ||  pRec == &tr);
        if (fVerbose)
            printf("Const Record(%p) contains \"%s\"\n", pRec, pszKey);
        lkrc = sthtConst.IncrementIterator(&iterConst);
    }

    IRTLASSERT(lkrc == LK_NO_MORE_ELEMENTS);

    lkrc = sthtConst.CloseIterator(&iterConst);
    IRTLASSERT(lkrc == LK_SUCCESS);
    IRTLASSERT(cRec == sthtConst.Size());
#endif // LKR_DEPRECATED_ITERATORS

#if 0
    IRTLTRACE("Check Clear\n");
    stht.Clear();
    IRTLASSERT(0 == stht.Size());
#else
    IRTLTRACE("Check DeleteKey\n");
    IRTLVERIFY(LK_SUCCESS == stht.DeleteKey(tl.m_sz));
    IRTLVERIFY(LK_SUCCESS == stht.DeleteKey(tk.m_sz));
    IRTLVERIFY(LK_SUCCESS == stht.DeleteKey(tr.m_sz));
#endif

    IRTLTRACE("Test done\n");
    // ~CTest will check for m_cRefs==0
}


int __cdecl
main(
    int argc,
    char **argv)
{
    Test(true);

    return(0) ;

} /* main */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\samples\minfan\minfan.h ===
#include <lkrhash.h>

#ifndef __LKRHASH_NO_NAMESPACE__
using namespace LKRhash;
#endif // __LKRHASH_NO_NAMESPACE__

#ifndef __HASHFN_NO_NAMESPACE__
using namespace HashFn;
#endif // __HASHFN_NO_NAMESPACE__

class VwrecordBase
{
public:
    VwrecordBase(const char* pszKey, int i)
    {
		Key = new char[strlen(pszKey) + 1];
        strcpy(Key, pszKey);
		m_num  = i;
		cRef = 0;
    }

    virtual ~VwrecordBase()
    {
        // printf("~VwrecordBase: %s\n", Key);
        delete [] Key;
    }

    char* getKey() const { return Key; }

	void  AddRefRecord(LK_ADDREF_REASON lkar) const
	{
		if (lkar > 0)
			InterlockedIncrement(&cRef);
		else if (InterlockedDecrement(&cRef) == 0)
            delete this;
	}

private:
    char* Key;
	int m_num;
	mutable long cRef;
};


class CWcharHashTable
    : public CTypedHashTable<CWcharHashTable, const VwrecordBase, char*>
{
public:
    CWcharHashTable()
        : CTypedHashTable<CWcharHashTable, const VwrecordBase, char*>("VWtest")
    {}

    static char*
    ExtractKey(const VwrecordBase* pRecord)        
	{
		return pRecord->getKey();
	}
    
	static DWORD
    CalcKeyHash(const char* pszKey)
    {
		return HashString(pszKey);
	}

    static bool
    EqualKeys(const char* pszKey1, const char* pszKey2)
    {
        return (strcmp(pszKey1, pszKey2) == 0);
    }

    static void
    AddRefRecord(const VwrecordBase* pRecord, LK_ADDREF_REASON lkar)
	{
		pRecord->AddRefRecord(lkar);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\samples\str-num\str-num.h ===
//--------------------------------------------------------------------
// An example of how to create a wrapper for CLKRHashTable
//--------------------------------------------------------------------

#include <lkrhash.h>


#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
// using namespace LKRhash;
#else  // __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS
#endif // __LKRHASH_NO_NAMESPACE__

#ifndef __HASHFN_NO_NAMESPACE__
 #define HASHFN_NS HashFn
// using namespace HashFn;
#else  // __HASHFN_NO_NAMESPACE__
 #define HASHFN_NS
#endif // __HASHFN_NO_NAMESPACE__


// some random class

class CTest
{
public:
    enum {BUFFSIZE=20};

    int   m_n;                  // This will also be a key
    char  m_sz[BUFFSIZE];       // This will be the primary key
    bool  m_fWhatever;
    mutable LONG  m_cRefs;      // Reference count for lifetime management.
                                // Must be mutable to use 'const CTest*' in
                                // hashtables

    CTest(int n, const char* psz, bool f)
        : m_n(n), m_fWhatever(f), m_cRefs(0)
    {
        strncpy(m_sz, psz, BUFFSIZE-1);
        m_sz[BUFFSIZE-1] = '\0';
    }

    ~CTest()
    {
        IRTLASSERT(m_cRefs == 0);
    }
};



// A typed hash table of CTests, keyed on the string field.  Case-insensitive.

class CStringTestHashTable
    : public LKRHASH_NS::CTypedHashTable<CStringTestHashTable,
                                         const CTest, const char*>
{
public:
    CStringTestHashTable()
        : LKRHASH_NS::CTypedHashTable<CStringTestHashTable, const CTest,
                          const char*>("string",
                                       LK_DFLT_MAXLOAD,
                                       LK_SMALL_TABLESIZE,
                                       LK_DFLT_NUM_SUBTBLS)
    {}
    
    static const char*
    ExtractKey(const CTest* pTest)
    {
        return pTest->m_sz;
    }

    static DWORD
    CalcKeyHash(const char* pszKey)
    {
        return HASHFN_NS::HashStringNoCase(pszKey);
    }

    static bool
    EqualKeys(const char* pszKey1, const char* pszKey2)
    {
        return _stricmp(pszKey1, pszKey2) == 0;
    }

    static void
    AddRefRecord(const CTest* pTest, LK_ADDREF_REASON lkar)
    {
        if (lkar > 0)
        {
            // or, perhaps, pIFoo->AddRef() (watch out for marshalling)
            // or ++pTest->m_cRefs (single-threaded only)
            InterlockedIncrement(&pTest->m_cRefs);
        }
        else if (lkar < 0)
        {
            // or, perhaps, pIFoo->Release() or --pTest->m_cRefs;
            LONG l = InterlockedDecrement(&pTest->m_cRefs);

            // For some hashtables, it may also make sense to add the following
            //      if (l == 0) delete pTest;
            // but that would typically only apply when InsertRecord was
            // used thus
            //      lkrc = ht.InsertRecord(new CTest(foo, bar));
        }
        else
            IRTLASSERT(0);

        IRTLTRACE("AddRef(%p, %s) %d, cRefs == %d\n",
                  pTest, pTest->m_sz, lkar, pTest->m_cRefs);
    }
};


// Another typed hash table of CTests.  This one is keyed on the numeric field.

class CNumberTestHashTable
    : public LKRHASH_NS::CTypedHashTable<CNumberTestHashTable,
                                         const CTest, int>
{
public:
    CNumberTestHashTable()
        : LKRHASH_NS::CTypedHashTable<CNumberTestHashTable, const CTest, int>(
            "number") {}
    static int   ExtractKey(const CTest* pTest)        {return pTest->m_n;}
    static DWORD CalcKeyHash(int nKey)          {return HASHFN_NS::Hash(nKey);}
    static bool  EqualKeys(int nKey1, int nKey2)       {return nKey1 == nKey2;}
    static void  AddRefRecord(const CTest* pTest, LK_ADDREF_REASON lkar)
    {
        int nIncr = (lkar > 0) ? +1 : -1;
        InterlockedExchangeAdd(&pTest->m_cRefs, nIncr);
        IRTLTRACE("AddRef(%p, %d) %d (%d), cRefs == %d\n",
                  pTest, pTest->m_n, nIncr, (int) lkar, pTest->m_cRefs);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\src\lkr-apply.cpp ===
/*++

   Copyright    (c) 1998-2000    Microsoft Corporation

   Module  Name :
       LKRhash.cpp

   Abstract:
       Implements the old, deprecated iterators for LKRhash.
       Use the STL-style iterators instead.

   Author:
       George V. Reilly      (GeorgeRe)     1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#include "precomp.hxx"


#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <lkrhash.h>

#include "i-lkrhash.h"


#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
#else  // __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS
#endif // __LKRHASH_NO_NAMESPACE__


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__

#include "LKR-inline.h"

#ifdef LKR_APPLY_IF

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::Apply(
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    LK_PREDICATE lkp = LKP_PERFORM;
    DWORD dw = _ApplyIf(_PredTrue, pfnAction, pvState, lkl, lkp);

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    return dw;
} // CLKRLinearHashTable::Apply



//------------------------------------------------------------------------
// Function: CLKRHashTable::Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::Apply(
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        if (lkl == LKL_WRITELOCK)
            m_palhtDir[i]->WriteLock();
        else
            m_palhtDir[i]->ReadLock();

        // Must call IsValid inside a lock to ensure that none of the state
        // variables change while it's being evaluated
        IRTLASSERT(m_palhtDir[i]->IsValid());

        if (m_palhtDir[i]->IsValid())
        {
            dw += m_palhtDir[i]->_ApplyIf(CLKRLinearHashTable::_PredTrue,
                                          pfnAction, pvState, lkl, lkp);
        }

        if (lkl == LKL_WRITELOCK)
            m_palhtDir[i]->WriteUnlock();
        else
            m_palhtDir[i]->ReadUnlock();

        if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
            ||  lkp == LKP_DELETE_STOP)
            break;
    }

    return dw;
} // CLKRHashTable::Apply



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::ApplyIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::ApplyIf(
    LKR_PFnRecordPred   pfnPredicate,
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        dw = _ApplyIf(pfnPredicate, pfnAction, pvState, lkl, lkp);
    }

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();
    return dw;
} // CLKRLinearHashTable::ApplyIf



//------------------------------------------------------------------------
// Function: CLKRHashTable::ApplyIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::ApplyIf(
    LKR_PFnRecordPred   pfnPredicate,
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        if (lkl == LKL_WRITELOCK)
            m_palhtDir[i]->WriteLock();
        else
            m_palhtDir[i]->ReadLock();
        
        // Must call IsValid inside a lock to ensure that none of the state
        // variables change while it's being evaluated
        IRTLASSERT(m_palhtDir[i]->IsValid());
        
        if (m_palhtDir[i]->IsValid())
        {
            dw += m_palhtDir[i]->_ApplyIf(pfnPredicate, pfnAction,
                                          pvState, lkl, lkp);
        }
        
        if (lkl == LKL_WRITELOCK)
            m_palhtDir[i]->WriteUnlock();
        else
            m_palhtDir[i]->ReadUnlock();
        
        if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
            ||  lkp == LKP_DELETE_STOP)
            break;
    }

    return dw;
} // CLKRHashTable::ApplyIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::DeleteIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::DeleteIf(
    LKR_PFnRecordPred   pfnPredicate,
    void*               pvState)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    WriteLock();
    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());
    if (IsValid())
        dw = _DeleteIf(pfnPredicate, pvState, lkp);
    WriteUnlock();

    return dw;
} // CLKRLinearHashTable::DeleteIf



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::DeleteIf(
    LKR_PFnRecordPred   pfnPredicate,
    void*               pvState)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->WriteLock();
        
        // Must call IsValid inside a lock to ensure that none of the state
        // variables change while it's being evaluated
        IRTLASSERT(m_palhtDir[i]->IsValid());
        
        if (m_palhtDir[i]->IsValid())
            dw += m_palhtDir[i]->_DeleteIf(pfnPredicate, pvState, lkp);
        
        m_palhtDir[i]->WriteUnlock();
        
        if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
            ||  lkp == LKP_DELETE_STOP)
            break;
    }

    return dw;
} // CLKRHashTable::DeleteIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_ApplyIf
// Synopsis:
// Returns:  Number of successful actions
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_ApplyIf(
    LKR_PFnRecordPred   pfnPredicate,
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl,
    LK_PREDICATE&       rlkp)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(lkl == LKL_WRITELOCK  ?  IsWriteLocked()  :  IsReadLocked());
    IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);

    if ((lkl == LKL_WRITELOCK  ?  !IsWriteLocked()  :  !IsReadLocked())
            ||  pfnPredicate == NULL  ||  pfnAction == NULL)
        return 0;

    DWORD cActions = 0;

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);

        if (lkl == LKL_WRITELOCK)
            pbkt->WriteLock();
        else
            pbkt->ReadLock();

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            int i;

            FOR_EACH_NODE(i)
            {
                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                    IRTLASSERT(0 == _IsNodeCompact(pbkt));
                    IRTLASSERT(pncCurr->IsLastClump());
                    goto unlock;
                }
                else
                {
                    rlkp = (*pfnPredicate)(pncCurr->m_pvNode[i], pvState);

                    switch (rlkp)
                    {
                    case LKP_ABORT:
                        if (lkl == LKL_WRITELOCK)
                            pbkt->WriteUnlock();
                        else
                            pbkt->ReadUnlock();
                        return cActions;
                        break;

                    case LKP_NO_ACTION:
                        // nothing to do
                        break;

                    case LKP_DELETE:
                    case LKP_DELETE_STOP:
                        if (lkl != LKL_WRITELOCK)
                        {
                            pbkt->ReadUnlock();
                            return cActions;
                        }

                        // fall through

                    case LKP_PERFORM:
                    case LKP_PERFORM_STOP:
                    {
                        LK_ACTION lka;

                        if (rlkp == LKP_DELETE  ||  rlkp == LKP_DELETE_STOP)
                        {
                            IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i,
                                                   LKAR_APPLY_DELETE));

                            ++cActions;
                            lka = LKA_SUCCEEDED;
                        }
                        else
                        {
                            lka = (*pfnAction)(pncCurr->m_pvNode[i], pvState);

                            switch (lka)
                            {
                            case LKA_ABORT:
                                if (lkl == LKL_WRITELOCK)
                                    pbkt->WriteUnlock();
                                else
                                    pbkt->ReadUnlock();
                                return cActions;
                                
                            case LKA_FAILED:
                                // nothing to do
                                break;
                                
                            case LKA_SUCCEEDED:
                                ++cActions;
                                break;
                                
                            default:
                                IRTLASSERT(! "Unknown LK_ACTION in ApplyIf");
                                break;
                            }
                        }

                        if (rlkp == LKP_PERFORM_STOP
                            ||  rlkp == LKP_DELETE_STOP)
                        {
                            if (lkl == LKL_WRITELOCK)
                                pbkt->WriteUnlock();
                            else
                                pbkt->ReadUnlock();
                            return cActions;
                        }

                        break;
                    }

                    default:
                        IRTLASSERT(! "Unknown LK_PREDICATE in ApplyIf");
                        break;
                    }
                }
            }
        }

      unlock:
        if (lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();
    }

    return cActions;
} // CLKRLinearHashTable::_ApplyIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteIf
// Synopsis: Deletes all records that match the predicate
// Returns:  Count of successful deletions
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_DeleteIf(
    LKR_PFnRecordPred   pfnPredicate,
    void*               pvState,
    LK_PREDICATE&       rlkp)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(IsWriteLocked());
    IRTLASSERT(pfnPredicate != NULL);

    if (!IsWriteLocked()  ||  pfnPredicate == NULL)
        return 0;

    DWORD cActions = 0;

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);
        pbkt->WriteLock();

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            int i;

            FOR_EACH_NODE(i)
            {
                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                    IRTLASSERT(0 == _IsNodeCompact(pbkt));
                    IRTLASSERT(pncCurr->IsLastClump());
                    goto unlock;
                }
                else
                {
                    rlkp = (*pfnPredicate)(pncCurr->m_pvNode[i], pvState);

                    switch (rlkp)
                    {
                    case LKP_ABORT:
                        pbkt->WriteUnlock();
                        return cActions;
                        break;

                    case LKP_NO_ACTION:
                        // nothing to do
                        break;

                    case LKP_PERFORM:
                    case LKP_PERFORM_STOP:
                    case LKP_DELETE:
                    case LKP_DELETE_STOP:
                    {
                        IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i,
                                               LKAR_DELETE_IF_DELETE));

                        ++cActions;

                        if (rlkp == LKP_PERFORM_STOP
                            ||  rlkp == LKP_DELETE_STOP)
                        {
                            pbkt->WriteUnlock();
                            return cActions;
                        }

                        break;
                    }

                    default:
                        IRTLASSERT(! "Unknown LK_PREDICATE in DeleteIf");
                        break;
                    }
                }
            }
        }

      unlock:
        pbkt->WriteUnlock();
    }

    return cActions;
} // CLKRLinearHashTable::_DeleteIf

#endif // LKR_APPLY_IF


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\src\dllmain.cpp ===
/*++

   Copyright    (c) 1998-2000    Microsoft Corporation

   Module  Name :
       dllmain.cpp

   Abstract:
       DLL entrypoints for LKRhash: a fast, scalable,
       cache- and MP-friendly hash table

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#include <precomp.hxx>

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <irtldbg.h>
#include <lkrhash.h>


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /*lpReserved*/)
{
    BOOL  fReturn = TRUE;  // ok
    
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);
        IRTL_DEBUG_INIT();
        IRTLTRACE0("LKRhash::DllMain::DLL_PROCESS_ATTACH\n");
        fReturn = LKR_Initialize(LK_INIT_DEFAULT);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        IRTLTRACE0("LKRhash::DllMain::DLL_PROCESS_DETACH\n");
        LKR_Terminate();
        IRTL_DEBUG_TERM();
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\src\i-debug.h ===
/*++

   Copyright    (c) 2000    Microsoft Corporation

   Module  Name :
       i-debug.h

   Abstract:
       Internal debugging declarations for LKRhash: a fast, scalable,
       cache- and MP-friendly hash table

   Author:
       George V. Reilly      (GeorgeRe)     Sep-2000

   Environment:
       Win32 - User Mode
       NT - Kernel Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __I_DEBUG_H__
#define __I_DEBUG_H__

extern "C" {

extern bool g_fDebugOutputEnabled;

}; // extern "C"

#endif // __I_DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\src\i-locks.h ===
/*++

   Copyright    (c) 2000    Microsoft Corporation

   Module  Name :
       i-Locks.h

   Abstract:
       Internal declarations for Locks

   Author:
       George V. Reilly      (GeorgeRe)     Sep-2000

   Environment:
       Win32 - User Mode
       NT - Kernel Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __I_LOCKS_H__
#define __I_LOCKS_H__

#define LOCKS_SWITCH_TO_THREAD

extern "C" {

BOOL
Locks_Initialize();

BOOL
Locks_Cleanup();

};

#endif // __I_LOCKS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\src\lkr-c-api.cpp ===
/*++

   Copyright    (c) 1998-2000    Microsoft Corporation

   Module  Name :
       LKR-c-api.cpp

   Abstract:
       Implements the C API for LKRhash

   Author:
       George V. Reilly      (GeorgeRe)     Sep-2000

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#include "precomp.hxx"


#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <lkrhash.h>

#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
using namespace LKRhash;
#else  // __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS
#endif // __LKRHASH_NO_NAMESPACE__

#ifndef __HASHFN_NO_NAMESPACE__
 #define HASHFN_NS HashFn
using namespace HashFn;
#else  // __HASHFN_NO_NAMESPACE__
 #define HASHFN_NS
#endif // __HASHFN_NO_NAMESPACE__


typedef CLKRHashTable          BaseHashTable;


// don't want to expose the inner workings of LKRhash through the
// public iterators, so we use this as the actual implementation

class BaseIter
{
public:
    BaseHashTable::Iterator m_iter;
    LONG                    m_cRefs;

    BaseIter()
        : m_iter(),
          m_cRefs(1)
    {}

    BaseIter(
        BaseHashTable::Iterator& iter)
        : m_iter(iter),
          m_cRefs(1)
    {}

    LONG
    AddRef()
    {
        LONG l = InterlockedIncrement(&m_cRefs);
        LKR_ITER_TRACE(_TEXT(" BI::AddRef: this=%p, iter=%p, cRefs=%d\n"),
                       this, &m_iter, m_cRefs);
        return l;
    }

    LONG
    Release()
    {
        LONG l = InterlockedDecrement(&m_cRefs);
        LKR_ITER_TRACE(_TEXT(" BI::Release: this=%p, iter=%p, cRefs=%d\n"),
                       this, &m_iter, m_cRefs);
        if (l == 0)
            delete this;
        return l;
    }

    ~BaseIter()
    {
        IRTLASSERT(m_cRefs == 0);
    }

private:
    BaseIter(const BaseIter& rhs);
    BaseIter& operator=(const BaseIter& rhs);
};



/* Create a new LkrHashTable
 * Returns pointer to new table if successful. NULL, otherwise.
 * The table must be destroyed with LKR_DeleteTable.
 */
PLkrHashTable
LKR_CreateTable(
    LPCSTR              pszName,        /* An identifier for debugging */
    LKR_PFnExtractKey   pfnExtractKey,  /* Extract key from record */
    LKR_PFnCalcKeyHash  pfnCalcKeyHash, /* Calculate hash signature of key */
    LKR_PFnEqualKeys    pfnEqualKeys,   /* Compare two keys */
    LKR_PFnAddRefRecord pfnAddRefRecord,/* AddRef in LKR_FindKey, etc */
    LK_TABLESIZE        nTableSize,     /* Small/Med/Large number of elements*/
    DWORD               fCreateFlags    /* Mixture of LK_CREATE_* flags. */
    )
{
    bool fMultiKeys = (fCreateFlags & LK_CREATE_MULTIKEYS) != 0;

    BaseHashTable* pht = new BaseHashTable(pszName,
                                           pfnExtractKey,
                                           pfnCalcKeyHash,
                                           pfnEqualKeys,
                                           pfnAddRefRecord,
                                           LK_DFLT_MAXLOAD,
                                           nTableSize,
                                           LK_DFLT_NUM_SUBTBLS,
                                           fMultiKeys);
    if (pht != NULL  &&  !pht->IsValid())
    {
        delete pht;
        pht = NULL;
    }

    return (PLkrHashTable) pht;
}



/* Destroy an LkrHashTable created by LKR_CreateTable.
 */
void
LKR_DeleteTable(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;

    delete pht;
}



/* Insert a new record into hash table.
 * Returns LKR_SUCCESS if all OK, LKR_KEY_EXISTS if same key already
 * exists (unless fOverwrite), LKR_ALLOC_FAIL if out of space,
 * or LK_BAD_RECORD for a bad record.
 */
LK_RETCODE
LKR_InsertRecord(
    PLkrHashTable   plkr,
    const void*     pvRecord,
    BOOL            fOverwrite)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->InsertRecord(pvRecord, !!fOverwrite);
}



/* Delete record with the given key from the table. Does not actually delete
 * record from memory, just calls AddRefRecord(LKAR_DELETE_KEY);
 * Returns LKR_SUCCESS if all OK, or LKR_NO_SUCH_KEY if not found
 * If fDeleteAllSame is set, all records that match pnKey will be deleted
 * from the table; otherwise, only the first matching record is deleted.
 */
LK_RETCODE
LKR_DeleteKey(
    PLkrHashTable   plkr,
    const DWORD_PTR pnKey,
    BOOL            fDeleteAllSame)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->DeleteKey(pnKey, !!fDeleteAllSame);
}



/* Delete a record from the table, if present.
 * Returns LKR_SUCCESS if all OK, or LKR_NO_SUCH_KEY if not found
 */
LK_RETCODE
LKR_DeleteRecord(
    PLkrHashTable   plkr,
    const void*     pvRecord)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->DeleteRecord(pvRecord);
}



/* Find record with given key.
 * Returns:  LKR_SUCCESS, if record found (record is returned in *ppvRecord)
 *           LK_BAD_RECORD, if ppvRecord is invalid
 *           LKR_NO_SUCH_KEY, if no record with given key value was found
 *           LKR_UNUSABLE, if hash table not in usable state
 * Note: the record is AddRef'd. You must decrement the reference
 * count when you are finished with the record (if you're implementing
 * refcounting semantics).
 */
LK_RETCODE
LKR_FindKey(
    PLkrHashTable   plkr,
    const DWORD_PTR pnKey,
    const void**    ppvRecord)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->FindKey(pnKey, ppvRecord);
}



/* Sees if the record is contained in the table
 * Returns:  LKR_SUCCESS, if record found
 *           LK_BAD_RECORD, if pvRecord is invalid
 *           LKR_NO_SUCH_KEY, if record is not in the table
 *           LKR_UNUSABLE, if hash table not in usable state
 * Note: the record is *not* AddRef'd.
 */
LK_RETCODE
LKR_FindRecord(
    PLkrHashTable   plkr,
    const void*     pvRecord)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->FindRecord(pvRecord);
}



/* Walk the hash table, applying pfnAction to all records.
 * Locks the whole table for the duration with either a (possibly
 * shared) readlock or a writelock, according to lkl.
 * Loop is aborted if pfnAction returns LKA_ABORT.
 * Returns the number of successful applications.
 */
DWORD
LKR_Apply(
    PLkrHashTable       plkr,
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->Apply(pfnAction, pvState, lkl);
}



/* Walk the hash table, applying pfnAction to any records that match
 * pfnPredicate. Locks the whole table for the duration with either
 * a (possibly shared) readlock or a writelock, according to lkl.
 * Loop is aborted if pfnAction returns LKA_ABORT.
 * Returns the number of successful applications.
 */
DWORD
LKR_ApplyIf(
    PLkrHashTable       plkr,
    LKR_PFnRecordPred   pfnPredicate,
    LKR_PFnRecordAction pfnAction,
    void*               pvState,
    LK_LOCKTYPE         lkl)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->ApplyIf(pfnPredicate, pfnAction, pvState, lkl);
}



/* Delete any records that match pfnPredicate.
 * Locks the table for the duration with a writelock.
 * Returns the number of deletions.
 *
 * Do *not* walk the hash table by hand with an iterator and call
 * LKR_DeleteKey. The iterator will end up pointing to garbage.
 */
DWORD
LKR_DeleteIf(
    PLkrHashTable       plkr,
    LKR_PFnRecordPred   pfnPredicate,
    void*               pvState)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->DeleteIf(pfnPredicate, pvState);
}



/* Check table for consistency. Returns 0 if okay, or the number of
 * errors otherwise.
 */
int
LKR_CheckTable(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return LK_BAD_TABLE;
    
    return pht->CheckTable();
}



/* Remove all data from the table
 */
void
LKR_Clear(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return;
    
    pht->Clear();
}



/* Number of elements in the table
 */
DWORD
LKR_Size(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return 0;
    
    return pht->Size();
}



/* Maximum possible number of elements in the table
 */
DWORD
LKR_MaxSize(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return 0;
    
    return pht->MaxSize();
}



/* Is the hash table usable?
 */
BOOL
LKR_IsUsable(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL)
        return FALSE;
    
    return pht->IsUsable();
}


    
/* Is the hash table consistent and correct?
 */
BOOL
LKR_IsValid(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL)
        return FALSE;
    
    return pht->IsValid();
}



#ifdef LKR_EXPOSED_TABLE_LOCK

/* Lock the table (exclusively) for writing
 */
void
LKR_WriteLock(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return;
    
    pht->WriteLock();
}



/* Lock the table (possibly shared) for reading
 */
void
LKR_ReadLock(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return;
    
    pht->ReadLock();
}



/* Unlock the table for writing
 */
void
LKR_WriteUnlock(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return;
    
    pht->WriteUnlock();
}



/* Unlock the table for reading
 */
void
LKR_ReadUnlock(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return;
    
    pht->ReadUnlock();
}



/* Is the table already locked for writing?
 */
BOOL
LKR_IsWriteLocked(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return FALSE;
    
    return pht->IsWriteLocked();
}



/* Is the table already locked for reading?
 */
BOOL
LKR_IsReadLocked(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return FALSE;
    
    return pht->IsReadLocked();
}



/* Is the table unlocked for writing?
 */
BOOL
LKR_IsWriteUnlocked(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return FALSE;
    
    return pht->IsWriteUnlocked();
}



/* Is the table unlocked for reading?
 */
BOOL
LKR_IsReadUnlocked(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        return FALSE;
    
    return pht->IsReadUnlocked();
}



/* Convert the read lock to a write lock. Note: another thread may acquire
 * exclusive access to the table before this routine returns.
 */
void
LKR_ConvertSharedToExclusive(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        pht->ConvertSharedToExclusive();
}



/* Convert the write lock to a read lock
 */
void
LKR_ConvertExclusiveToShared(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    if (pht == NULL  ||  !pht->IsValid())
        pht->ConvertExclusiveToShared();
}

#endif // LKR_EXPOSED_TABLE_LOCK



#ifdef LKR_STL_ITERATORS


/* LKR_Iterator default ctor
 */
LKR_Iterator::LKR_Iterator()
    : pImpl(NULL)
{
    BaseIter* piter = new BaseIter;
    LKR_ITER_TRACE(_TEXT(" L_I::default ctor: this=%p, pImpl=%p, %d\n"),
                   this, piter, piter->m_cRefs);
    pImpl = piter;
}



/* LKR_Iterator private ctor
 */
LKR_Iterator::LKR_Iterator(
    bool)
    : pImpl(NULL)
{
    LKR_ITER_TRACE(_TEXT(" L_I::private ctor: this=%p\n"), this);
}



/* LKR_Iterator copy ctor
 */
LKR_Iterator::LKR_Iterator(
    const LKR_Iterator& rhs)
    : pImpl(NULL)
{
    BaseIter* piter    = reinterpret_cast<BaseIter*>(pImpl);
    BaseIter* piterRhs = reinterpret_cast<BaseIter*>(rhs.pImpl);

    IRTLASSERT(piterRhs != NULL  &&  piterRhs->m_cRefs > 0);

    LKR_ITER_TRACE(_TEXT(" L_I::copy ctor: this=%p, ")
                   _TEXT(" rhs=%p, rhs.pImpl=%p,%d\n"),
                   this, &rhs, piterRhs, piterRhs->m_cRefs);

    pImpl = rhs.pImpl;
    piterRhs->AddRef();
}



/* LKR_Iterator assignment operator
 */
LKR_Iterator&
LKR_Iterator::operator=(
    const LKR_Iterator& rhs)
{
    BaseIter* piter    = reinterpret_cast<BaseIter*>(pImpl);
    BaseIter* piterRhs = reinterpret_cast<BaseIter*>(rhs.pImpl);

    IRTLASSERT(piter != NULL     &&  piter->m_cRefs > 0);
    IRTLASSERT(piterRhs != NULL  &&  piterRhs->m_cRefs > 0);

    LKR_ITER_TRACE(_TEXT(" L_I::op=: this=%p, pImpl=%p,%d,")
                   _TEXT(" rhs=%p, rhs.pImpl=%p,%d\n"),
                   this, piter, (piter ? piter->m_cRefs : -99),
                   &rhs, piterRhs, piterRhs->m_cRefs);

    piterRhs->AddRef();
    piter->Release();

    pImpl = rhs.pImpl;

    return *this;
}



/* LKR_Iterator dtor
 */
LKR_Iterator::~LKR_Iterator()
{
    BaseIter* piter = reinterpret_cast<BaseIter*>(pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::dtor: this=%p, pImpl=%p,%d\n"),
                   this, piter, (piter ? piter->m_cRefs : -99));

    IRTLASSERT(piter != NULL     &&  piter->m_cRefs > 0);
    piter->Release();
}



/* Increment the LKR_Iterator, so that it points to the next record in
 * the LkrHashTable, or to LKR_End();
 */
bool
LKR_Iterator::Increment()
{
    BaseIter* piter = reinterpret_cast<BaseIter*>(pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::Increment: this=%p, pImpl=%p\n"),
                   this, pImpl);

    return piter->m_iter.Increment();
}



/* Is the LKR_Iterator valid?
 */
bool
LKR_Iterator::IsValid() const
{
    BaseIter* piter = reinterpret_cast<BaseIter*>(pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::IsValid: this=%p, pImpl=%p\n"),
                   this, pImpl);

    return piter->m_iter.IsValid();
}



/* Return the record that an LKR_Iterator points to.
 * Must point to a valid record.
 */
const void*
LKR_Iterator::Record() const
{
    BaseIter* piter = reinterpret_cast<BaseIter*>(pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::Record: this=%p, pImpl=%p\n"),
                   this, pImpl);

    return piter->m_iter.Record();
}



/* Return the key of the record that an LKR_Iterator points to.
 * Must point to a valid record.
 */
const DWORD_PTR
LKR_Iterator::Key() const
{
    BaseIter* piter = reinterpret_cast<BaseIter*>(pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::Key: this=%p, pImpl=%p\n"),
                   this, pImpl);

    return piter->m_iter.Key();
}



/* Compare two LKR_Iterators for equality
 */
bool
LKR_Iterator::operator==(
    const LKR_Iterator& rhs) const
{
    BaseIter* piter = reinterpret_cast<BaseIter*>(pImpl);
    BaseIter* piterRhs = reinterpret_cast<BaseIter*>(rhs.pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::op==, this=%p, pImpl=%p, rhs=%p, r.p=%p\n"),
                   this, pImpl, &rhs, rhs.pImpl);

    return piter->m_iter == piterRhs->m_iter;
}



/* Compare two LKR_Iterators for inequality
 */
bool
LKR_Iterator::operator!=(
    const LKR_Iterator& rhs) const
{
    BaseIter* piter = reinterpret_cast<BaseIter*>(pImpl);
    BaseIter* piterRhs = reinterpret_cast<BaseIter*>(rhs.pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::op!=, this=%p, pImpl=%p, rhs=%p, r.p=%p\n"),
                   this, pImpl, &rhs, rhs.pImpl);

    return piter->m_iter != piterRhs->m_iter;
}



/* Return iterator pointing to first item in table
 */
LKR_Iterator
LKR_Begin(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    LKR_Iterator   iter(true);

    iter.pImpl = new BaseIter(pht->Begin());
    
    LKR_ITER_TRACE(_TEXT(" L_I::Begin: plkr=%p, iter=%p, pImpl=%p\n"),
                   plkr, &iter, iter.pImpl);

    return iter;
}



/* Return a one-past-the-end iterator. Always empty.
 */
LKR_Iterator
LKR_End(
    PLkrHashTable plkr)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    LKR_Iterator   iter(true);

    iter.pImpl = new BaseIter(pht->End());

    LKR_ITER_TRACE(_TEXT(" L_I::End: plkr=%p, iter=%p, pImpl=%p\n"),
                   plkr, &iter, iter.pImpl);

    return iter;
}



/* Insert a record
 * Returns `true' if successful; iterResult points to that record
 * Returns `false' otherwise; iterResult == End()
 */
bool
LKR_Insert(
              PLkrHashTable plkr,
    /* in */  const void*   pvRecord,
    /* out */ LKR_Iterator& riterResult,
    /* in */  bool          fOverwrite)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    BaseIter* piter = reinterpret_cast<BaseIter*>(riterResult.pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::Insert: plkr=%p, iter=%p, pImpl=%p, Rec=%p\n"),
                   plkr, &riterResult, piter, pvRecord);

    return pht->Insert(pvRecord, piter->m_iter, fOverwrite);
}



/* Erase the record pointed to by the iterator; adjust the iterator
 * to point to the next record. Returns `true' if successful.
 */
bool
LKR_Erase(
                 PLkrHashTable plkr,
    /* in,out */ LKR_Iterator& riter)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    BaseIter* piter = reinterpret_cast<BaseIter*>(riter.pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::Erase: plkr=%p, iter=%p, pImpl=%p\n"),
                   plkr, &riter, piter);

    return pht->Erase(piter->m_iter);
}



/* Erase the records in the range [riterFirst, riterLast).
 * Returns `true' if successful. riterFirst points to riterLast on return.
 */
bool
LKR_Erase(
           PLkrHashTable plkr,
    /*in*/ LKR_Iterator& riterFirst,
    /*in*/ LKR_Iterator& riterLast)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    BaseIter* piterFirst= reinterpret_cast<BaseIter*>(riterFirst.pImpl);
    BaseIter* piterLast = reinterpret_cast<BaseIter*>(riterLast.pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::Erase2: plkr=%p,")
                   _TEXT(" iterFirst=%p, pImplFirst=%p,")
                   _TEXT(" iterLast=%p, pImplLast=%p\n"),
                   plkr, &riterFirst, piterFirst, &riterLast, piterLast);

    return pht->Erase(piterFirst->m_iter, piterLast->m_iter);
}


    
/* Find the (first) record that has its key == pnKey.
 * If successful, returns `true' and iterator points to (first) record.
 * If fails, returns `false' and iterator == End()
 */
bool
LKR_Find(
              PLkrHashTable plkr,
    /* in */  DWORD_PTR     pnKey,
    /* out */ LKR_Iterator& riterResult)
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    BaseIter* piter = reinterpret_cast<BaseIter*>(riterResult.pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::Find: plkr=%p, iter=%p, pImpl=%p, Key=%p\n"),
                   plkr, &riterResult, piter, (void*) pnKey);

    return pht->Find(pnKey, piter->m_iter);
}



/* Find the range of records that have their keys == pnKey.
 * If successful, returns `true', iterFirst points to first record,
 *     and iterLast points to one-beyond-the last such record.
 * If fails, returns `false' and both iterators == End().
 * Primarily useful when fMultiKeys == TRUE
 */
bool
LKR_EqualRange(
              PLkrHashTable plkr,
    /* in */  DWORD_PTR     pnKey,
    /* out */ LKR_Iterator& riterFirst,     // inclusive
    /* out */ LKR_Iterator& riterLast)      // exclusive
{
    BaseHashTable* pht = (BaseHashTable*) plkr;
    BaseIter* piterFirst= reinterpret_cast<BaseIter*>(riterFirst.pImpl);
    BaseIter* piterLast = reinterpret_cast<BaseIter*>(riterLast.pImpl);

    LKR_ITER_TRACE(_TEXT(" L_I::EqualRange: plkr=%p, Key=%p,")
                   _TEXT(" iterFirst=%p, pImplFirst=%p,")
                   _TEXT(" iterLast=%p, pImplLast=%p\n"),
                   plkr, (void*) pnKey, &riterFirst, piterFirst,
                   &riterLast, piterLast);

    return pht->EqualRange(pnKey, piterFirst->m_iter, piterLast->m_iter);
}

#endif // LKR_STL_ITERATORS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\src\i-lkrhash.h ===
/*++

   Copyright    (c) 2000    Microsoft Corporation

   Module  Name :
       i-LKRhash.h

   Abstract:
       Internal declarations for LKRhash: a fast, scalable,
       cache- and MP-friendly hash table

   Author:
       George V. Reilly      (GeorgeRe)     Sep-2000

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __I_LKRHASH_H__
#define __I_LKRHASH_H__

// Should the table be allowed to contract after deletions?
#define LKR_CONTRACT

#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__


// Class for bucket chains of the hash table. Note that the first
// nodeclump is actually included in the bucket and not dynamically
// allocated, which increases space requirements slightly but does
// improve performance.
class CBucket
{
private:
    typedef LKR_BUCKET_LOCK BucketLock;

    mutable BucketLock m_Lock;       // lock protecting this bucket

#ifdef LOCK_INSTRUMENTATION
    static LONG sm_cBuckets;

    static const TCHAR*
    _LockName()
    {
        LONG l = ++sm_cBuckets;
        // possible race condition but we don't care, as this is never
        // used in production code
        static TCHAR s_tszName[CLockStatistics::L_NAMELEN];
        wsprintf(s_tszName, _TEXT("B%06x"), 0xFFFFFF & l);
        return s_tszName;
    }
#endif // LOCK_INSTRUMENTATION

public:
    CNodeClump    m_ncFirst;    // first CNodeClump of this bucket

#if defined(LOCK_INSTRUMENTATION) || defined(IRTLDEBUG)
    CBucket()
#ifdef LOCK_INSTRUMENTATION
        : m_Lock(_LockName())
#endif // LOCK_INSTRUMENTATION
    {
#ifdef IRTLDEBUG
        LOCK_LOCKTYPE lt = BucketLock::LockType();
        if (lt == LOCK_SPINLOCK  ||  lt == LOCK_FAKELOCK)
            IRTLASSERT(sizeof(*this) <= CNodeClump::BUCKET_BYTE_SIZE);
#endif IRTLDEBUG
    }
#endif // LOCK_INSTRUMENTATION || IRTLDEBUG

    void  WriteLock()               { m_Lock.WriteLock(); }
    void  ReadLock() const          { m_Lock.ReadLock(); }
    void  WriteUnlock()             { m_Lock.WriteUnlock(); }
    void  ReadUnlock() const        { m_Lock.ReadUnlock(); }
    bool  IsWriteLocked() const     { return m_Lock.IsWriteLocked(); }
    bool  IsReadLocked() const      { return m_Lock.IsReadLocked(); }
    bool  IsWriteUnlocked() const   { return m_Lock.IsWriteUnlocked(); }
    bool  IsReadUnlocked() const    { return m_Lock.IsReadUnlocked(); }
#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    void  SetSpinCount(WORD wSpins) { m_Lock.SetSpinCount(wSpins); }
    WORD  GetSpinCount() const  { return m_Lock.GetSpinCount(); }
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION
#ifdef LOCK_INSTRUMENTATION
    CLockStatistics LockStats() const {return m_Lock.Statistics();}
#endif // LOCK_INSTRUMENTATION
}; // class CBucket



// The hash table space is divided into fixed-size segments (arrays of
// CBuckets) and physically grows/shrinks one segment at a time. This is
// a low-cost way of having a growable array of buckets.
//
// We provide small, medium, and large segments to better tune the
// overall memory requirements of the hash table according to the
// expected usage of an instance.
//
// We do not use virtual functions: partially because it's faster not to,
// and partially so that the custom allocators can do a better job, as the
// segment size is exactly 2^(6+_NBits) bytes long.

class CSegment
{
public:
    CBucket m_bktSlots[1];

    // See note at m_bktSlots2 in CSizedSegment below
    CBucket& Slot(DWORD i)
    { return m_bktSlots[i]; }
}; // class CSegment



// A segment directory keeps track of the segments comprising the hash table.
// The directory is just a variable-sized array of pointers to
// segments (CDirEntrys).
class CDirEntry
{
public:
    // MIN_DIRSIZE and MAX_DIRSIZE can be changed independently
    // of anything else. Should be powers of two.
    enum {
        MIN_DIRSIZE =  (1<<3),   // minimum directory size
        MAX_DIRSIZE = (1<<20),   // maximum directory size
    };

    CSegment* m_pseg;

    CDirEntry()
        : m_pseg(NULL)
    {}

    ~CDirEntry()
    { delete m_pseg; }
}; // class CDirEntry



template <int _NBits, int _InitSizeMultiplier, LK_TABLESIZE _lkts>
class CSizedSegment : public CSegment
{
public:
    // Maximum table size equals MAX_DIRSIZE * SEGSIZE buckets.
    enum {
        SEGBITS  =       _NBits,// number of bits extracted from a hash
                                // address for offset within a segment
        SEGSIZE  = (1<<SEGBITS),// segment size
        SEGMASK  = (SEGSIZE-1), // mask used for extracting offset bit
        INITSIZE = _InitSizeMultiplier * SEGSIZE, // #segments to allocate
                                // initially
    };

    // Hack: assumes laid out immediately after CSegment::m_bktSlots,
    // with no padding. The STATIC_ASSERTs in _AllocateSegment and in
    // CompileTimeAssertions should cause a compile-time error if
    // this assumption ever proves false.
    CBucket m_bktSlots2[SEGSIZE-1];

public:
    DWORD           Bits() const        { return SEGBITS; }
    DWORD           Size() const        { return SEGSIZE; }
    DWORD           Mask() const        { return SEGMASK; }
    DWORD           InitSize() const    { return INITSIZE;}
    LK_TABLESIZE    SegmentType() const { return _lkts; }

    static void CompileTimeAssertions()
    {
        STATIC_ASSERT(offsetof(CSizedSegment, m_bktSlots) + sizeof(CBucket)
                      == offsetof(CSizedSegment, m_bktSlots2));
    };

#ifdef IRTLDEBUG
    CSizedSegment()
    {
        IRTLASSERT(&Slot(1) == m_bktSlots2);
        IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CSizedSegment);
}; // class CSizedSegment


typedef CSizedSegment<3, 1, LK_SMALL_TABLESIZE>   CSmallSegment;
typedef CSizedSegment<6, 1, LK_MEDIUM_TABLESIZE>  CMediumSegment;
typedef CSizedSegment<9, 2, LK_LARGE_TABLESIZE>   CLargeSegment;


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__

#endif //__I_LKRHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\src\irtldbg.cpp ===
// Implementation of debug support functions

#include "precomp.hxx"

#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <malloc.h>

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <IrtlDbg.h>

#include "i-Debug.h"

bool g_fDebugOutputEnabled = true;

IRTL_DLLEXP
void __cdecl
IrtlTrace(
    LPCTSTR ptszFormat,
    ...)
{
    if (g_fDebugOutputEnabled)
    {
        TCHAR tszBuff[2048];
        va_list args;
        
        va_start(args, ptszFormat);
        _vstprintf(tszBuff, ptszFormat, args);
        va_end(args);
        
#ifdef IRTLDBG_KERNEL_MODE
        DbgPrint(tszBuff);
#else // !IRTLDBG_KERNEL_MODE
        OutputDebugString(tszBuff);
#endif // !IRTLDBG_KERNEL_MODE
    }
}



#ifdef IRTLDBG_KERNEL_MODE
# undef IRTLDEBUG
// Can't compile the rest of this code in kernel mode
#endif


#ifdef IRTLDEBUG

# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)


#  ifdef IRTLDBG_RUNNING_AS_SERVICE

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int __cdecl
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate LKRhash,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        // If using MFC's TRACE macro (AfxTrace), the report hook
        // (AspAssertHandler) will get called with _CRT_WARN.  Ignore.
        pszMessageTitle = "Warning";
        *pnReturn = 0;
        return FALSE;

    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;

    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(_alloca(strlen(pszErrorText) + strlen(szInfo) + 1));

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        return TRUE;     // tell _CrtDbgReport to run
    }
    
    *pnReturn = 0;       // nothing for _CrtDbgReport to do

    return FALSE;
}

#  endif // IRTLDBG_RUNNING_AS_SERVICE
# endif // _MSC_VER >= 1000



void
IrtlDebugInit()
{
# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef IRTLDBG_RUNNING_AS_SERVICE
    // If we end up in _CrtDbgReport, don't put up a message box
    // _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // IRTLDBG_RUNNING_AS_SERVICE

    
    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // _MSC_VER >= 1000
}



void
IrtlDebugTerm()
{
# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef IRTLDBG_RUNNING_AS_SERVICE
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // IRTLDBG_RUNNING_AS_SERVICE
# endif // _MSC_VER >= 1000
}



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}

#endif //IRTLDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\src\lkr-inline.h ===
/*++

   Copyright    (c) 2000    Microsoft Corporation

   Module  Name :
       LKR-inline.h

   Abstract:
       Inlined implementation of important small functions

   Author:
       George V. Reilly      (GeorgeRe)     November 2000

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       March 2000

--*/

#ifndef __LKR_INLINE_H__
#define __LKR_INLINE_H__


// See if countdown loops are faster than countup loops for traversing
// a CNodeClump
#ifdef LKR_COUNTDOWN
 #define  FOR_EACH_NODE(x)    for (x = NODES_PER_CLUMP;  --x >= 0;  )
#else // !LKR_COUNTDOWN
 #define  FOR_EACH_NODE(x)    for (x = 0;  x < NODES_PER_CLUMP;  ++x)
#endif // !LKR_COUNTDOWN


// Convert a hash signature to a bucket address
inline
DWORD
CLKRLinearHashTable::_BucketAddress(
    DWORD dwSignature) const
{
    DWORD dwBktAddr = _H0(dwSignature);
    // Has this bucket been split already?
    if (dwBktAddr < m_iExpansionIdx)
        dwBktAddr = _H1(dwSignature);
    IRTLASSERT(dwBktAddr < m_cActiveBuckets);
    IRTLASSERT(dwBktAddr < (m_cDirSegs << m_dwSegBits));
    return dwBktAddr;
}


// See the Linear Hashing paper
inline
DWORD
CLKRLinearHashTable::_H0(
    DWORD dwSignature,
    DWORD dwBktAddrMask)
{
    return dwSignature & dwBktAddrMask;
}


inline
DWORD
CLKRLinearHashTable::_H0(
    DWORD dwSignature) const
{
    return _H0(dwSignature, m_dwBktAddrMask0);
}


// See the Linear Hashing paper. Preserves one bit more than _H0.
inline
DWORD
CLKRLinearHashTable::_H1(
    DWORD dwSignature,
    DWORD dwBktAddrMask)
{
    return dwSignature & ((dwBktAddrMask << 1) | 1);
}


inline
DWORD
CLKRLinearHashTable::_H1(
    DWORD dwSignature) const
{
    return _H0(dwSignature, m_dwBktAddrMask1);
}


// In which segment within the directory does the bucketaddress lie?
// (Return type must be lvalue so that it can be assigned to.)
inline
CSegment*&
CLKRLinearHashTable::_Segment(
    DWORD dwBucketAddr) const
{
    const DWORD iSeg = dwBucketAddr >> m_dwSegBits;
    IRTLASSERT(m_paDirSegs != NULL  &&  iSeg < m_cDirSegs);
    return m_paDirSegs[iSeg].m_pseg;
}


// Offset within the segment of the bucketaddress
inline
DWORD
CLKRLinearHashTable::_SegIndex(
    DWORD dwBucketAddr) const
{
    return dwBucketAddr & m_dwSegMask;
}


// Convert a bucketaddress to a CBucket*
inline
CBucket*
CLKRLinearHashTable::_Bucket(
    DWORD dwBucketAddr) const
{
    IRTLASSERT(dwBucketAddr < m_cActiveBuckets);
    CSegment* const pseg = _Segment(dwBucketAddr);
    IRTLASSERT(pseg != NULL);
    const DWORD dwSegIndex = _SegIndex(dwBucketAddr);
    return &(pseg->Slot(dwSegIndex));
}


// Extract the key from a record
inline
const DWORD_PTR
CLKRLinearHashTable::_ExtractKey(
    const void* pvRecord) const
{
    IRTLASSERT(pvRecord != NULL);
    IRTLASSERT(m_pfnExtractKey != NULL);
    return (*m_pfnExtractKey)(pvRecord);
}


// Hash the key
inline
DWORD
CLKRLinearHashTable::_CalcKeyHash(
    const DWORD_PTR pnKey) const
{
    // Note pnKey==0 is acceptable, as the real key type could be an int
    IRTLASSERT(m_pfnCalcKeyHash != NULL);
    DWORD dwHash = (*m_pfnCalcKeyHash)(pnKey);
    // We forcibly scramble the result to help ensure a better distribution
#ifndef __HASHFN_NO_NAMESPACE__
    dwHash = HashFn::HashRandomizeBits(dwHash);
#else // !__HASHFN_NO_NAMESPACE__
    dwHash = ::HashRandomizeBits(dwHash);
#endif // !__HASHFN_NO_NAMESPACE__
    IRTLASSERT(dwHash != HASH_INVALID_SIGNATURE);
    return dwHash;
}


// Compare two keys for equality
inline
BOOL
CLKRLinearHashTable::_EqualKeys(
    const DWORD_PTR pnKey1,
    const DWORD_PTR pnKey2) const
{
    IRTLASSERT(m_pfnEqualKeys != NULL);
    return (*m_pfnEqualKeys)(pnKey1, pnKey2);
}


// AddRef or Release a record.
inline
void
CLKRLinearHashTable::_AddRefRecord(
    const void*      pvRecord,
    LK_ADDREF_REASON lkar) const
{
    IRTLASSERT(pvRecord != NULL
               &&  (LKAR_EXPLICIT_RELEASE <= lkar
                    && lkar <= LKAR_EXPLICIT_ACQUIRE));
    IRTLASSERT(m_pfnAddRefRecord != NULL);
    (*m_pfnAddRefRecord)(pvRecord, lkar);
}


// Used by _FindKey so that the thread won't deadlock if the user has
// already explicitly called table->WriteLock().
inline
bool
CLKRLinearHashTable::_ReadOrWriteLock() const
{
#ifdef LKR_EXPOSED_TABLE_LOCK
    return m_Lock.ReadOrWriteLock();
#else // !LKR_EXPOSED_TABLE_LOCK
    m_Lock.ReadLock();
    return true;
#endif // !LKR_EXPOSED_TABLE_LOCK
}


inline
void
CLKRLinearHashTable::_ReadOrWriteUnlock(
    bool fReadLocked) const
{
#ifdef LKR_EXPOSED_TABLE_LOCK
    m_Lock.ReadOrWriteUnlock(fReadLocked);
#else // !LKR_EXPOSED_TABLE_LOCK
    m_Lock.ReadUnlock();
#endif // !LKR_EXPOSED_TABLE_LOCK
}

#endif  // __LKR_INLINE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\src\lkrhash.cpp ===
/*++

   Copyright    (c) 1998-2001    Microsoft Corporation

   Module  Name :
       LKRhash.cpp

   Abstract:
       Implements LKRhash: a fast, scalable, cache- and MP-friendly hash table

   Author:
       Paul (Per-Ake) Larson, palarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       Jan 1998   - Massive cleanup and rewrite.  Templatized.
       10/01/1998 - Change name from LKhash to LKRhash
       10/2000    - Refactor, port to kernel mode

--*/

#include "precomp.hxx"


#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <lkrhash.h>

#include "i-LKRhash.h"
#include "i-Locks.h"
#include "i-Debug.h"


#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
#else  // __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS
#endif // __LKRHASH_NO_NAMESPACE__


#ifdef LKRHASH_ALLOCATOR_NEW

# define DECLARE_ALLOCATOR(CLASS)                        \
  CLKRhashAllocator* LKRHASH_NS::CLASS::sm_palloc = NULL

# define DECLARE_ALLOCATOR_LHTSUBCLASS(CLASS)            \
  CLKRhashAllocator* LKRHASH_NS::CLKRLinearHashTable::CLASS::sm_palloc = NULL


#ifdef LKRHASH_KERNEL_MODE
DECLARE_ALLOCATOR(CLKRLinearHashTable);
DECLARE_ALLOCATOR(CLKRHashTable);
#endif

DECLARE_ALLOCATOR(CNodeClump);
DECLARE_ALLOCATOR(CSmallSegment);
DECLARE_ALLOCATOR(CMediumSegment);
DECLARE_ALLOCATOR(CLargeSegment);


#endif // LKRHASH_ALLOCATOR_NEW


static BOOL s_fInitialized = FALSE;


// -------------------------------------------------------------------------
// Initialize per-class allocators and other global initialization
// -------------------------------------------------------------------------

BOOL
LKR_Initialize(
    DWORD dwInitFlags)
{
    IRTLTRACE(_TEXT("LKR_Initialize")
#ifdef LKRHASH_KERNEL_MODE
              _TEXT(" (kernel)")
#endif
              _TEXT(": Flags=0x%08x, Allocator=%s,\n")
              _TEXT("\tTableLock=%s, BucketLock=%s.\n"),
              dwInitFlags, CLKRhashAllocator::ClassName(),
              LKRHASH_NS::CLKRHashTable::TableLock::ClassName(),
              LKRHASH_NS::CLKRHashTable::BucketLock::ClassName());

    g_fDebugOutputEnabled = (dwInitFlags & LK_INIT_DEBUG_SPEW) != 0;

#define INIT_ALLOCATOR(CLASS, N, Tag)                                \
    LKRHASH_ALLOCATOR_INIT(LKRHASH_NS::CLASS, N, Tag, f)

#define INIT_ALLOCATOR_LHTSUBCLASS(CLASS, N, Tag)                    \
    LKRHASH_ALLOCATOR_INIT(LKRHASH_NS::CLKRLinearHashTable::CLASS, N, Tag, f)

    BOOL f = Locks_Initialize();

    INIT_ALLOCATOR(CNodeClump,         200, 'cnKL');
    INIT_ALLOCATOR(CSmallSegment,        5, 'ssKL');
    INIT_ALLOCATOR(CMediumSegment,       5, 'msKL');
    INIT_ALLOCATOR(CLargeSegment,        5, 'lsKL');

#ifdef LKRHASH_KERNEL_MODE
    INIT_ALLOCATOR(CLKRLinearHashTable, 20, 'hlKL');
    INIT_ALLOCATOR(CLKRHashTable,        4, 'thKL');
#endif

    LKRHASH_NS::CSmallSegment::CompileTimeAssertions();
    LKRHASH_NS::CMediumSegment::CompileTimeAssertions();
    LKRHASH_NS::CLargeSegment::CompileTimeAssertions();

    s_fInitialized = f;

    return f;
} // LKR_Initialize



// -------------------------------------------------------------------------
// Destroy per-class allocators and other global cleanup
// -------------------------------------------------------------------------

void
LKR_Terminate()
{
#define UNINIT_ALLOCATOR(CLASS)                        \
    LKRHASH_ALLOCATOR_UNINIT(LKRHASH_NS::CLASS)

#define UNINIT_ALLOCATOR_LHTSUBCLASS(CLASS)            \
    LKRHASH_ALLOCATOR_UNINIT(LKRHASH_NS::CLKRLinearHashTable::CLASS)

#ifdef LKRHASH_KERNEL_MODE
    UNINIT_ALLOCATOR(CLKRHashTable);
    UNINIT_ALLOCATOR(CLKRLinearHashTable);
#endif

    UNINIT_ALLOCATOR(CLargeSegment);
    UNINIT_ALLOCATOR(CMediumSegment);
    UNINIT_ALLOCATOR(CSmallSegment);
    UNINIT_ALLOCATOR(CNodeClump);

    Locks_Cleanup();

    s_fInitialized = false;

    IRTLTRACE0("LKR_Terminate done\n");
} // LKR_Terminate



const char*
LKR_AddRefReasonAsString(
    LK_ADDREF_REASON lkar)
{
    switch (lkar)
    {
// negative reasons => decrement refcount => release ownership
    case LKAR_EXPLICIT_RELEASE:
        return "Explicit_Release";
    case LKAR_DELETE_KEY:
        return "Delete_Key";
    case LKAR_DELETE_RECORD:
        return "Delete_Record";
    case LKAR_INSERT_RELEASE:
        return "Insert_Release";
    case LKAR_CLEAR:
        return "Clear";
    case LKAR_DTOR:
        return "Table_Dtor";
    case LKAR_APPLY_DELETE:
        return "Apply_Delete";
    case LKAR_DELETE_IF_DELETE:
        return "DeleteIf_Delete";
    case LKAR_ITER_RELEASE:
        return "++Iter_Release";
    case LKAR_ITER_ASSIGN_RELEASE:
        return "Iter_Operator=_Release";
    case LKAR_ITER_DTOR:
        return "~Iter_Dtor";
    case LKAR_ITER_ERASE:
        return "Iter_Erase";
    case LKAR_ITER_ERASE_TABLE:
        return "Iter_Erase_Table";
    case LKAR_ITER_CLOSE:
        return "Iter_Close";

// positive reasons => increment refcount => add an owner
    case LKAR_INSERT_RECORD:
        return "Insert_Record";
    case LKAR_FIND_KEY:
        return "Find_Key";
    case LKAR_ITER_ACQUIRE:
        return "Iter_Acquire";
    case LKAR_ITER_COPY_CTOR:
        return "Iter_Copy_Ctor";
    case LKAR_ITER_ASSIGN_ACQUIRE:
        return "Iter_Operator=_Assign";
    case LKAR_ITER_INSERT:
        return "Insert(Iter)";
    case LKAR_ITER_FIND:
        return "Find(Iter)";
    case LKAR_EXPLICIT_ACQUIRE:
        return "Explicit_Acquire";

    default:
        IRTLASSERT(! "Invalid LK_ADDREF_REASON");
        return "Invalid LK_ADDREF_REASON";
    }
}



const unsigned MINLOAD = 2;


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__

#include "LKR-inline.h"

// -------------------------------------------------------------------------
// class static member variables
// -------------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION
LONG CBucket::sm_cBuckets            = 0;

LONG CLKRLinearHashTable::sm_cTables = 0;
#endif // LOCK_INSTRUMENTATION


#ifndef LKR_NO_GLOBAL_LIST
CLockedDoubleList CLKRLinearHashTable::sm_llGlobalList;
CLockedDoubleList CLKRHashTable::sm_llGlobalList;
#endif // LKR_NO_GLOBAL_LIST



// CLKRLinearHashTable --------------------------------------------------------
// Public Constructor for class CLKRLinearHashTable.
// -------------------------------------------------------------------------

CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR              pszName,        // An identifier for debugging
    LKR_PFnExtractKey   pfnExtractKey,  // Extract key from record
    LKR_PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    LKR_PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    LKR_PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    unsigned            maxload,        // Upperbound on average chain length
    DWORD               initsize,       // Initial size of hash table.
    DWORD             /*num_subtbls*/,  // for compatiblity with CLKRHashTable
    bool                fMultiKeys      // Allow multiple identical keys?
#ifdef LKRHASH_KERNEL_MODE
  , bool                fNonPagedAllocs // use paged or NP pool
#endif
    )
    :
#ifdef LOCK_INSTRUMENTATION
      m_Lock(_LockName()),
#endif // LOCK_INSTRUMENTATION
      m_nTableLockType(TableLock::LockType()),
      m_nBucketLockType(BucketLock::LockType()),
      m_phtParent(NULL),    // directly created, no owning table
      m_fMultiKeys(fMultiKeys),
#ifdef LKRHASH_KERNEL_MODE
      m_fNonPagedAllocs(fNonPagedAllocs)
#else
      m_fNonPagedAllocs(false)
#endif
{
#ifndef LOCK_INSTRUMENTATION
    STATIC_ASSERT(1 <= LK_DFLT_MAXLOAD  && LK_DFLT_MAXLOAD <= NODES_PER_CLUMP);
#endif // !LOCK_INSTRUMENTATION
    STATIC_ASSERT(0 <= NODE_BEGIN  &&  NODE_BEGIN < NODES_PER_CLUMP);
    STATIC_ASSERT(!(0 <= NODE_END  &&  NODE_END < NODES_PER_CLUMP));

    IRTLVERIFY(LK_SUCCESS
               == _Initialize(pfnExtractKey, pfnCalcKeyHash, pfnEqualKeys,
                              pfnAddRefRecord, pszName, maxload, initsize));

    _InsertThisIntoGlobalList();
} // CLKRLinearHashTable::CLKRLinearHashTable



// CLKRLinearHashTable --------------------------------------------------------
// Private Constructor for class CLKRLinearHashTable, used by CLKRHashTable.
// -------------------------------------------------------------------------

CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR              pszName,        // An identifier for debugging
    LKR_PFnExtractKey   pfnExtractKey,  // Extract key from record
    LKR_PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    LKR_PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    LKR_PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    unsigned            maxload,        // Upperbound on average chain length
    DWORD               initsize,       // Initial size of hash table.
    CLKRHashTable*      phtParent,      // Owning table.
    bool                fMultiKeys,     // Allow multiple identical keys?
    bool                fNonPagedAllocs // use paged or NP pool
    )
    :
#ifdef LOCK_INSTRUMENTATION
      m_Lock(_LockName()),
#endif // LOCK_INSTRUMENTATION
      m_nTableLockType(TableLock::LockType()),
      m_nBucketLockType(BucketLock::LockType()),
      m_phtParent(phtParent),
      m_fMultiKeys(fMultiKeys),
      m_fNonPagedAllocs(fNonPagedAllocs)
{
    IRTLASSERT(m_phtParent != NULL);
    IRTLVERIFY(LK_SUCCESS
               == _Initialize(pfnExtractKey, pfnCalcKeyHash, pfnEqualKeys,
                              pfnAddRefRecord, pszName, maxload, initsize));

    _InsertThisIntoGlobalList();
} // CLKRLinearHashTable::CLKRLinearHashTable



// _Initialize -------------------------------------------------------------
// Do all the real work of constructing a CLKRLinearHashTable
// -------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Initialize(
    LKR_PFnExtractKey   pfnExtractKey,
    LKR_PFnCalcKeyHash  pfnCalcKeyHash,
    LKR_PFnEqualKeys    pfnEqualKeys,
    LKR_PFnAddRefRecord pfnAddRefRecord,
    LPCSTR              pszName,
    unsigned            maxload,
    DWORD               initsize)
{
    m_dwSignature =     SIGNATURE;
    m_dwBktAddrMask0 =  0;
    m_dwBktAddrMask1 =  0;
    m_iExpansionIdx =   0;
    m_paDirSegs =       NULL;
    m_lkts =            LK_MEDIUM_TABLESIZE;
    m_dwSegBits =       0;
    m_dwSegSize =       0;
    m_dwSegMask =       0;
    m_lkrcState =       LK_UNUSABLE;
    m_MaxLoad =         LK_DFLT_MAXLOAD;
    m_nLevel =          0;
    m_cDirSegs =        0;
    m_cRecords =        0;
    m_cActiveBuckets =  0;
    m_wBucketLockSpins= LOCK_USE_DEFAULT_SPINS;
    m_pfnExtractKey =   pfnExtractKey;
    m_pfnCalcKeyHash =  pfnCalcKeyHash;
    m_pfnEqualKeys =    pfnEqualKeys;
    m_pfnAddRefRecord = pfnAddRefRecord;
    m_pvReserved1     = 0;
    m_pvReserved2     = 0;
    m_pvReserved3     = 0;
    m_pvReserved4     = 0;

    strncpy(m_szName, pszName, NAME_SIZE-1);
    m_szName[NAME_SIZE-1] = '\0';

    IRTLASSERT(m_pfnExtractKey != NULL
               && m_pfnCalcKeyHash != NULL
               && m_pfnEqualKeys != NULL
               && m_pfnAddRefRecord != NULL);

    IRTLASSERT(s_fInitialized);

    if (!s_fInitialized)
        return (m_lkrcState = LK_NOT_INITIALIZED);

    if (m_pfnExtractKey == NULL
            || m_pfnCalcKeyHash == NULL
            || m_pfnEqualKeys == NULL
            || m_pfnAddRefRecord == NULL)
        return (m_lkrcState = LK_BAD_PARAMETERS);

    // TODO: better sanity check for ridiculous values?
    m_MaxLoad = (maxload < MINLOAD)  ?  LK_DFLT_MAXLOAD  :  maxload;
    m_MaxLoad = min(m_MaxLoad, 10 * NODES_PER_CLUMP);

    // Choose the size of the segments according to the desired "size" of
    // the table, small, medium, or large.
    LK_TABLESIZE lkts;

    if (initsize == LK_SMALL_TABLESIZE)
    {
        lkts = LK_SMALL_TABLESIZE;
        initsize = CSmallSegment::INITSIZE;
    }
    else if (initsize == LK_MEDIUM_TABLESIZE)
    {
        lkts = LK_MEDIUM_TABLESIZE;
        initsize = CMediumSegment::INITSIZE;
    }
    else if (initsize == LK_LARGE_TABLESIZE)
    {
        lkts = LK_LARGE_TABLESIZE;
        initsize = CLargeSegment::INITSIZE;
    }

    // specified an explicit initial size
    else
    {
        // force Small::INITSIZE  <= initsize <=  MAX_DIRSIZE * Large::INITSIZE
        initsize = min(max(initsize, CSmallSegment::INITSIZE),
                       (MAX_DIRSIZE >> CLargeSegment::SEGBITS)
                            * CLargeSegment::INITSIZE);

        // Guess a table size
        if (initsize <= 8 * CSmallSegment::INITSIZE)
            lkts = LK_SMALL_TABLESIZE;
        else if (initsize >= CLargeSegment::INITSIZE)
            lkts = LK_LARGE_TABLESIZE;
        else
            lkts = LK_MEDIUM_TABLESIZE;
    }

    return _SetSegVars(lkts, initsize);
} // CLKRLinearHashTable::_Initialize



// CLKRHashTable ----------------------------------------------------------
// Constructor for class CLKRHashTable.
// ---------------------------------------------------------------------

CLKRHashTable::CLKRHashTable(
    LPCSTR              pszName,        // An identifier for debugging
    LKR_PFnExtractKey   pfnExtractKey,  // Extract key from record
    LKR_PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    LKR_PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    LKR_PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    unsigned            maxload,        // Bound on the average chain length
    DWORD               initsize,       // Initial size of hash table.
    DWORD               num_subtbls,    // Number of subordinate hash tables.
    bool                fMultiKeys      // Allow multiple identical keys?
#ifdef LKRHASH_KERNEL_MODE
  , bool                fNonPagedAllocs // use paged or NP pool
#endif
    )
    : m_dwSignature(SIGNATURE),
      m_cSubTables(0),
      m_palhtDir(NULL),
      m_pfnExtractKey(pfnExtractKey),
      m_pfnCalcKeyHash(pfnCalcKeyHash),
      m_lkrcState(LK_BAD_PARAMETERS)
{
    strncpy(m_szName, pszName, NAME_SIZE-1);
    m_szName[NAME_SIZE-1] = '\0';

    _InsertThisIntoGlobalList();

    IRTLASSERT(pfnExtractKey != NULL
               && pfnCalcKeyHash != NULL
               && pfnEqualKeys != NULL
               && pfnAddRefRecord != NULL);

    if (pfnExtractKey == NULL
            || pfnCalcKeyHash == NULL
            || pfnEqualKeys == NULL
            || pfnAddRefRecord == NULL)
        return;

    if (!s_fInitialized)
    {
        m_lkrcState = LK_NOT_INITIALIZED;
        return;
    }

#ifndef LKRHASH_KERNEL_MODE
    bool         fNonPagedAllocs = false;
#endif
    LK_TABLESIZE lkts            = NumSubTables(initsize, num_subtbls);

#ifdef IRTLDEBUG
    int cBuckets = initsize;
    if (initsize == LK_SMALL_TABLESIZE)
        cBuckets = CSmallSegment::INITSIZE;
    else if (initsize == LK_MEDIUM_TABLESIZE)
        cBuckets = CMediumSegment::INITSIZE;
    else if (initsize == LK_LARGE_TABLESIZE)
        cBuckets = CLargeSegment::INITSIZE;

    IRTLTRACE(TEXT("CLKRHashTable, %p, %s: ")
              TEXT("%s, %d subtables, initsize = %d, ")
              TEXT("total #buckets = %d\n"),
              this, m_szName,
              ((lkts == LK_SMALL_TABLESIZE) ? "small" : 
               (lkts == LK_MEDIUM_TABLESIZE) ? "medium" : "large"),
              num_subtbls, initsize, cBuckets * num_subtbls);
#endif // IRTLDEBUG

    m_lkrcState = LK_ALLOC_FAIL;
    m_palhtDir  = _AllocateSubTableArray(num_subtbls);

    if (m_palhtDir == NULL)
        return;
    else
    {
        m_cSubTables = num_subtbls;
        for (DWORD i = 0;  i < m_cSubTables;  i++)
            m_palhtDir[i] = NULL;
    }

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i] = _AllocateSubTable(pszName, pfnExtractKey,
                                          pfnCalcKeyHash, pfnEqualKeys,
                                          pfnAddRefRecord, maxload,
                                          initsize, this, fMultiKeys,
                                          fNonPagedAllocs);

        // Failed to allocate a subtable.  Destroy everything allocated so far.
        if (m_palhtDir[i] == NULL  ||  !m_palhtDir[i]->IsValid())
        {
            for (DWORD j = i;  j-- > 0;  )
                _FreeSubTable(m_palhtDir[j]);
            _FreeSubTableArray(m_palhtDir);
            m_cSubTables = 0;
            m_palhtDir   = NULL;

            return;
        }
    }

    m_nSubTableMask = m_cSubTables - 1;

    // is m_cSubTables a power of 2? This calculation works even for
    // m_cSubTables == 1 ( == 2^0).
    if ((m_nSubTableMask & m_cSubTables) != 0)
        m_nSubTableMask = -1; // No, see CLKRHashTable::_SubTable()

    m_lkrcState = LK_SUCCESS; // so IsValid/IsUsable won't fail
} // CLKRHashTable::CLKRHashTable



// ~CLKRLinearHashTable ------------------------------------------------------
// Destructor for class CLKRLinearHashTable
//-------------------------------------------------------------------------

CLKRLinearHashTable::~CLKRLinearHashTable()
{
    // must acquire all locks before deleting to make sure
    // that no other threads are using the table
    WriteLock();
    _Clear(false);
    WriteUnlock();

    _RemoveThisFromGlobalList();

    m_dwSignature = SIGNATURE_FREE;
    m_lkrcState   = LK_UNUSABLE; // so IsUsable will fail
} // CLKRLinearHashTable::~CLKRLinearHashTable



// ~CLKRHashTable ------------------------------------------------------------
// Destructor for class CLKRHashTable
//-------------------------------------------------------------------------
CLKRHashTable::~CLKRHashTable()
{
    // Must delete the subtables in forward order (unlike
    // delete[], which starts at the end and moves backwards) to
    // prevent possibility of deadlock by acquiring the subtable
    // locks in a different order from the rest of the code.
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        _FreeSubTable(m_palhtDir[i]);

    _FreeSubTableArray(m_palhtDir);

    _RemoveThisFromGlobalList();

    m_dwSignature = SIGNATURE_FREE;
    m_lkrcState   = LK_UNUSABLE; // so IsUsable will fail
} // CLKRHashTable::~CLKRHashTable



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::NumSubTables
// Synopsis: 
//------------------------------------------------------------------------

LK_TABLESIZE
CLKRLinearHashTable::NumSubTables(
    DWORD& rinitsize,
    DWORD& rnum_subtbls)
{
    LK_TABLESIZE lkts = LK_MEDIUM_TABLESIZE;

    return lkts;
} // CLKRLinearHashTable::NumSubTables



//------------------------------------------------------------------------
// Function: CLKRHashTable::NumSubTables
// Synopsis: 
//------------------------------------------------------------------------

LK_TABLESIZE
CLKRHashTable::NumSubTables(
    DWORD& rinitsize,
    DWORD& rnum_subtbls)
{
    LK_TABLESIZE lkts;
    
    // Establish the table size
    if (rinitsize == LK_SMALL_TABLESIZE
        ||  rinitsize == LK_MEDIUM_TABLESIZE
        ||  rinitsize == LK_LARGE_TABLESIZE)
    {
        lkts = static_cast<LK_TABLESIZE>(rinitsize);
    }
    else
    {
        if (rnum_subtbls != LK_DFLT_NUM_SUBTBLS)
        {
            rinitsize = (rinitsize - 1) / rnum_subtbls + 1;

            if (rinitsize <= CSmallSegment::SEGSIZE)
                lkts = LK_SMALL_TABLESIZE;
            else if (rinitsize >= CLargeSegment::SEGSIZE)
                lkts = LK_LARGE_TABLESIZE;
            else
                lkts = LK_MEDIUM_TABLESIZE;
        }
        else
        {
            lkts = LK_MEDIUM_TABLESIZE;
        }
    }

    // Choose a suitable number of subtables
    if (rnum_subtbls == LK_DFLT_NUM_SUBTBLS)
    {
        static int s_nCPUs = -1;
    
        if (s_nCPUs == -1)
        {
#ifdef LKRHASH_KERNEL_MODE
            s_nCPUs = KeNumberProcessors;
#else  // !LKRHASH_KERNEL_MODE
            SYSTEM_INFO si;

            GetSystemInfo(&si);
            s_nCPUs = si.dwNumberOfProcessors;
#endif // !LKRHASH_KERNEL_MODE
        }

        switch (lkts)
        {
        case LK_SMALL_TABLESIZE:
            rnum_subtbls = max(1,  min(s_nCPUs, 4));
            break;
        
        case LK_MEDIUM_TABLESIZE:
            rnum_subtbls = 2 * s_nCPUs;
            break;
        
        case LK_LARGE_TABLESIZE:
            rnum_subtbls = 4 * s_nCPUs;
            break;
        }
    }

    rnum_subtbls = min(MAX_LKR_SUBTABLES, rnum_subtbls);

    return lkts;
} // CLKRHashTable::NumSubTables



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_IsNodeCompact
// Synopsis: validates that a node is correctly compacted
//------------------------------------------------------------------------

int
CLKRLinearHashTable::_IsNodeCompact(
    CBucket* const pbkt) const
{
    CNodeClump* pncCurr;
    CNodeClump* pncPrev;
    bool fEmpty  = pbkt->m_ncFirst.InvalidSignature(NODE_BEGIN);
    int  cErrors = fEmpty ? !pbkt->m_ncFirst.IsLastClump() : 0;

    for (pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (fEmpty)
            {
                cErrors += (!pncCurr->InvalidSignature(i));
                cErrors += (!pncCurr->IsEmptyNode(i));
            }
            else if (pncCurr->InvalidSignature(i))
            {
                fEmpty = true;
                cErrors += (!pncCurr->IsEmptyNode(i));
                cErrors += (!pncCurr->IsLastClump());
            }
            else // still in non-empty portion
            {
                cErrors += (pncCurr->InvalidSignature(i));
                cErrors += (pncCurr->IsEmptyNode(i));
            }
        }
    }

    return cErrors;
} // CLKRLinearHashTable::_IsNodeCompact



//------------------------------------------------------------------------
// Function: CLKRHashTable::_SubTable
// Synopsis: Map a hash signature to a subtable
//------------------------------------------------------------------------

LOCK_FORCEINLINE
CLKRHashTable::SubTable*
CLKRHashTable::_SubTable(
    DWORD dwSignature) const
{
    IRTLASSERT(m_lkrcState == LK_SUCCESS
               &&  m_palhtDir != NULL  &&  m_cSubTables > 0);
    
    const DWORD PRIME = 1048583UL;  // used to scramble the hash sig
    DWORD       index = dwSignature;
    
    // scramble the index, using a different set of constants than
    // HashRandomizeBits. This helps ensure that elements are sprayed
    // equally across subtables
    index = (((index * PRIME + 12345) >> 16)
             | ((index * 69069 + 1) & 0xffff0000));
    
    // If mask is non-negative, we can use faster bitwise-and
    if (m_nSubTableMask >= 0)
        index &= m_nSubTableMask;
    else
        index %= m_cSubTables;

    return m_palhtDir[index];
} // CLKRHashTable::_SubTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::_SubTableIndex
// Synopsis: Given a subtable, find its index within the parent table
//------------------------------------------------------------------------

int
CLKRHashTable::_SubTableIndex(
    CLKRHashTable::SubTable* pst) const
{
    int index = -1;
    
    for (int i = 0;  i < m_cSubTables;  ++i)
    {
        if (pst == m_palhtDir[i])
        {
            index = i;
            break;
        }
    }

    IRTLASSERT(index >= 0);

    return index;
} // CLKRHashTable::_SubTableIndex



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindBucket
// Synopsis: Find a bucket, given its signature. The bucket is locked
//           before returning. Assumes table is already locked, to avoid
//           race conditions.
//------------------------------------------------------------------------

const bool FB_READLOCK = false;
const bool FB_WRITELOCK = true;

CBucket*
CLKRLinearHashTable::_FindBucket(
    DWORD dwSignature,
    bool  fLockForWrite) const
{
    IRTLASSERT(IsValid());
    IRTLASSERT(m_dwBktAddrMask0 > 0);
    IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0); // 00011..111
    IRTLASSERT(m_dwBktAddrMask0 == (1U << m_nLevel) - 1);
    IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));
    IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
    IRTLASSERT(m_iExpansionIdx <= m_dwBktAddrMask0);
    IRTLASSERT(2 < m_dwSegBits  &&  m_dwSegBits < 20
               &&  m_dwSegSize == (1U << m_dwSegBits)
               &&  m_dwSegMask == (m_dwSegSize - 1));
    IRTLASSERT(IsReadLocked()  ||  IsWriteLocked());
    
    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    IRTLASSERT(dwBktAddr < m_cActiveBuckets);
    
    CBucket* const pbkt = _Bucket(dwBktAddr);
    IRTLASSERT(pbkt != NULL);
    
    if (fLockForWrite)
        pbkt->WriteLock();
    else
        pbkt->ReadLock();
    
    return pbkt;
} // CLKRLinearHashTable::_FindBucket



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_InsertRecord
// Synopsis: Inserts a new record into the hash table. If this causes the
//           average chain length to exceed the upper bound, the table is
//           expanded by one bucket.
// Output:   LK_SUCCESS,    if the record was inserted.
//           LK_KEY_EXISTS, if the record was not inserted (because a record
//               with the same key value already exists in the table, unless
//               fOverwrite==true).
//           LK_ALLOC_FAIL, if failed to allocate the required space
//           LK_UNUSABLE,   if hash table not in usable state
//           LK_BAD_RECORD, if record is bad.
//
// TODO: honor m_fMultiKeys and allow multiple identical keys.
// This will require keeping all identical signatures contiguously
// within a bucket chain, and keeping all identical keys contigously
// within that set of contigous signatures. With a good hash function,
// there should not be identical signatures without also having
// identical keys. Also, need to modify _DeleteNode. This modification
// is needed for EqualRange and for hash_multiset and hash_multimap
// to work.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_InsertRecord(
    const void* pvRecord,   // Pointer to the record to add to table
    DWORD       dwSignature,// hash signature
    bool        fOverwrite  // overwrite record if key already present
#ifdef LKR_STL_ITERATORS
  , Iterator*   piterResult // = NULL. Points to record upon return
#endif // LKR_STL_ITERATORS
    )
{
    IRTLASSERT(IsUsable()
               &&  pvRecord != NULL
               &&  dwSignature != HASH_INVALID_SIGNATURE);

    // find the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

#ifdef LKR_STL_ITERATORS
    DWORD dwBktAddr;

    if (piterResult != NULL)
    {
        dwBktAddr = _BucketAddress(dwSignature);
        IRTLASSERT(dwBktAddr < m_cActiveBuckets);
    }
#endif // LKR_STL_ITERATORS

    CBucket* const pbkt = _FindBucket(dwSignature, FB_WRITELOCK);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    // check that no record with the same key value exists
    // and save a pointer to the last element on the chain
    LK_RETCODE  lkrc = LK_SUCCESS;
    CNodeClump* pncFree = NULL;
    int         iFreePos = NODE_BEGIN - NODE_STEP;
    CNodeClump* pncPrev;
    CNodeClump* pncCurr;
    bool        fUpdate = false;
    const DWORD_PTR pnKey = _ExtractKey(pvRecord);

    // walk down the entire bucket chain, looking for matching hash
    // signatures and keys
    for (pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());

                pncFree  = pncCurr;
                iFreePos = i;
                goto insert;
            }

            if (dwSignature == pncCurr->m_dwKeySigs[i]
                &&  (pvRecord == pncCurr->m_pvNode[i]  ||
                    _EqualKeys(pnKey,  _ExtractKey(pncCurr->m_pvNode[i]))))
            {
                if (fOverwrite)
                {
                    // If we allow overwrites, this is the slot to do it to
                    fUpdate  = true;
                    pncFree  = pncCurr;
                    iFreePos = i;
                    goto insert;
                }
                else
                {
                    // overwrites forbidden: return an error
                    lkrc = LK_KEY_EXISTS;
                    goto exit;
                }
            }
        }
    }

  insert:
    if (pncFree != NULL)
    {
        pncCurr = pncFree;
        IRTLASSERT(0 <= iFreePos  &&  iFreePos < NODES_PER_CLUMP);
    }
    else
    {
        // No free slots.  Attach the new node to the end of the chain
        IRTLASSERT(iFreePos == NODE_BEGIN - NODE_STEP);
        pncCurr = _AllocateNodeClump();

        if (pncCurr == NULL)
        {
            lkrc = LK_ALLOC_FAIL;
            goto exit;
        }

        IRTLASSERT(pncPrev != NULL  &&  pncPrev->IsLastClump());
        pncPrev->m_pncNext = pncCurr;
        iFreePos = NODE_BEGIN;
    }

    // Bump the new record's reference count upwards
    _AddRefRecord(pvRecord, LKAR_INSERT_RECORD);

    if (fUpdate)
    {
        // We're overwriting an existing record.  Adjust the old record's
        // refcount downwards.  (Doing ++new, --old in this order ensures
        // that the refcount won't briefly go to zero if new and old are
        // the same record.)
        IRTLASSERT(!pncCurr->IsEmptyAndInvalid(iFreePos));
        _AddRefRecord(pncCurr->m_pvNode[iFreePos], LKAR_INSERT_RELEASE);
    }
    else
    {
        IRTLASSERT(pncCurr->IsEmptyAndInvalid(iFreePos));
        InterlockedIncrement(reinterpret_cast<LONG*>(&m_cRecords));
    }

    pncCurr->m_dwKeySigs[iFreePos] = dwSignature;
    pncCurr->m_pvNode[iFreePos]    = pvRecord;

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
#ifdef LKR_STL_ITERATORS
        // Don't call _Expand() if we're putting the result into an
        // iterator, as _Expand() tends to invalidate any other
        // iterators that might be in use.
        if (piterResult != NULL)
        {
            piterResult->m_plht =         this;
            piterResult->m_pnc =          pncCurr;
            piterResult->m_dwBucketAddr = dwBktAddr;
            piterResult->m_iNode =        (short) iFreePos;

            // Add an extra reference on the record, as the one added by
            // _InsertRecord will be lost when the iterator's destructor
            // fires or its assignment operator is used
            piterResult->_AddRef(LKAR_ITER_INSERT);
        }
        else
#endif // LKR_STL_ITERATORS
        {
            // If the average load factor has grown too high, we grow the
            // table one bucket at a time.
            unsigned nExpandedBuckets = m_cRecords / m_MaxLoad;

            while (m_cActiveBuckets < nExpandedBuckets)
            {
                // If _Expand returns an error code (viz. LK_ALLOC_FAIL), it
                // just means that there isn't enough spare memory to expand
                // the table by one bucket. This is likely to cause problems
                // elsewhere soon, but this hashtable has not been corrupted.
                // If the call to _AllocateNodeClump above failed, then we do
                // have a real error that must be propagated back to the caller
                // because we were unable to insert the element at all.
                if (_Expand() != LK_SUCCESS)
                    break;  // expansion failed
            }
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_InsertRecord



//------------------------------------------------------------------------
// Function: CLKRHashTable::InsertRecord
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::InsertRecord(
    const void* pvRecord,
    bool fOverwrite /*=false*/)
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op

    DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lk = pst->_InsertRecord(pvRecord, hash_val, fOverwrite);

    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
    return lk;
} // CLKRHashTable::InsertRecord



//-------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteKey
// Synopsis: Deletes the record with the given key value from the hash
//           table (if it exists).
// Returns:  LK_SUCCESS, if record found and deleted.
//           LK_NO_SUCH_KEY, if no record with the given key value was found.
//           LK_UNUSABLE, if hash table not in usable state
//-------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_DeleteKey(
    const DWORD_PTR pnKey,      // Key value of the record, depends on key type
    DWORD           dwSignature,
    bool            fDeleteAllSame)
{
    IRTLASSERT(IsUsable());

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, FB_WRITELOCK);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    // scan down the bucket chain, looking for the victim
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (dwSignature != pncCurr->m_dwKeySigs[i])
                continue;

            const DWORD_PTR pnKey2 = _ExtractKey(pncCurr->m_pvNode[i]);

            if (pnKey == pnKey2  ||  _EqualKeys(pnKey,  pnKey2))
            {
                IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i,
                                       LKAR_DELETE_KEY));

                lkrc = LK_SUCCESS;

                if (!fDeleteAllSame)
                    goto exit;
            }
        }
    }

  exit:
    pbkt->WriteUnlock();

#ifdef LKR_CONTRACT
    if (lkrc == LK_SUCCESS)
    {
        // contract the table if necessary
        unsigned nContractedBuckets = m_cRecords / m_MaxLoad;

        // Hysteresis: add a fudge factor to allow a slightly lower density
        // in the table. This reduces the frequency of contractions and
        // expansions in a table that gets a lot of deletions and insertions
        nContractedBuckets += nContractedBuckets >> 4;
        nContractedBuckets =  max(nContractedBuckets, m_dwSegSize);

        while (m_cActiveBuckets > nContractedBuckets)
        {
            // If _Contract returns an error code (viz. LK_ALLOC_FAIL), it
            // just means that there isn't enough spare memory to contract
            // the table by one bucket. This is likely to cause problems
            // elsewhere soon, but this hashtable has not been corrupted.
            if (_Contract() != LK_SUCCESS)
                break;
        }
    }
#endif // LKR_CONTRACT

    return lkrc;
} // CLKRLinearHashTable::_DeleteKey



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteKey
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::DeleteKey(
    const DWORD_PTR pnKey,
    bool            fDeleteAllSame /* =false */)
{
    if (!IsUsable())
        return m_lkrcState;
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op

    DWORD     hash_val  = _CalcKeyHash(pnKey);
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lk       = pst->_DeleteKey(pnKey, hash_val, fDeleteAllSame);

    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
    return lk;
} // CLKRHashTable::DeleteKey



//-------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteRecord
// Synopsis: Deletes the specified record from the hash table (if it
//           exists).  This is not the same thing as calling
//           DeleteKey(_ExtractKey(pvRecord)).  If _DeleteKey were called for
//           a record that doesn't exist in the table, it could delete some
//           completely unrelated record that happened to have the same key.
// Returns:  LK_SUCCESS, if record found and deleted.
//           LK_NO_SUCH_KEY, if the record is not found in the table.
//           LK_UNUSABLE, if hash table not in usable state.
//-------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_DeleteRecord(
    const void* pvRecord,   // Pointer to the record to delete from the table
    DWORD       dwSignature
    )
{
    IRTLASSERT(IsUsable()  &&  pvRecord != NULL);

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, FB_WRITELOCK);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    const DWORD_PTR pnKey = _ExtractKey(pvRecord);
    IRTLASSERT(dwSignature == _CalcKeyHash(pnKey));

    // scan down the bucket chain, looking for the victim
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (pncCurr->m_pvNode[i] == pvRecord)
            {
                IRTLASSERT(_EqualKeys(pnKey,
                                      _ExtractKey(pncCurr->m_pvNode[i])));
                IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[i]);

                IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i,
                                       LKAR_DELETE_RECORD));

                lkrc = LK_SUCCESS;
                goto exit;
            }
        }
    }

  exit:
    pbkt->WriteUnlock();

#ifdef LKR_CONTRACT
    if (lkrc == LK_SUCCESS)
    {
        // contract the table if necessary
        unsigned nContractedBuckets = m_cRecords / m_MaxLoad;

        // Hysteresis: add a fudge factor to allow a slightly lower density
        // in the table. This reduces the frequency of contractions and
        // expansions in a table that gets a lot of deletions and insertions
        nContractedBuckets += nContractedBuckets >> 4;
        nContractedBuckets =  max(nContractedBuckets, m_dwSegSize);

        while (m_cActiveBuckets > nContractedBuckets)
        {
            // If _Contract returns an error code (viz. LK_ALLOC_FAIL), it
            // just means that there isn't enough spare memory to contract
            // the table by one bucket. This is likely to cause problems
            // elsewhere soon, but this hashtable has not been corrupted.
            if (_Contract() != LK_SUCCESS)
                break;
        }
    }
#endif // LKR_CONTRACT

    return lkrc;
} // CLKRLinearHashTable::_DeleteRecord



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteRecord
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::DeleteRecord(
    const void* pvRecord)
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op

    DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lk       = pst->_DeleteRecord(pvRecord, hash_val);

    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
    return lk;
} // CLKRHashTable::DeleteRecord



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteNode
// Synopsis: Deletes a node; removes the node clump if empty
// Returns:  true if successful
//
// TODO: Is the rpncPrev parameter really necessary?
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_DeleteNode(
    CBucket*         pbkt,      // bucket chain containing node
    CNodeClump*&     rpnc,      // actual node
    CNodeClump*&     rpncPrev,  // predecessor of actual node, or NULL
    int&             riNode,    // index within node
    LK_ADDREF_REASON lkar)      // Where called from
{
    IRTLASSERT(pbkt != NULL  &&  pbkt->IsWriteLocked());
    IRTLASSERT(rpnc != NULL);
    IRTLASSERT(rpncPrev == NULL  ||  rpncPrev->m_pncNext == rpnc);
    IRTLASSERT(0 <= riNode  &&  riNode < NODES_PER_CLUMP);
    IRTLASSERT(!rpnc->IsEmptyAndInvalid(riNode));
    IRTLASSERT(lkar < 0);

#ifdef IRTLDEBUG
    // Check that the node clump really does belong to the bucket
    CNodeClump* pnc1 = &pbkt->m_ncFirst;

    while (pnc1 != NULL  &&  pnc1 != rpnc)
         pnc1 = pnc1->m_pncNext;

    IRTLASSERT(pnc1 == rpnc);
#endif // IRTLDEBUG

    // Release the reference to the record
    _AddRefRecord(rpnc->m_pvNode[riNode], lkar);

    IRTLASSERT(0 == _IsNodeCompact(pbkt));

    // TODO: honor m_fMultiKeys

    // Compact the nodeclump by moving the very last node back to the
    // newly freed slot
    CNodeClump* pnc2   = rpnc;
    int         iNode2 = riNode;

    // Find the last nodeclump in the chain
    while (!pnc2->IsLastClump())
    {
         pnc2 = pnc2->m_pncNext;
         iNode2 = NODE_BEGIN;
    }

    IRTLASSERT(0 <= iNode2  &&  iNode2 < NODES_PER_CLUMP);
    IRTLASSERT(!pnc2->IsEmptyAndInvalid(iNode2));

    // Find the first empty slot in the nodeclump
    while (iNode2 != NODE_END  &&  !pnc2->IsEmptySlot(iNode2))
    {
        iNode2 += NODE_STEP;
    }

    // Back up to last non-empty slot
    iNode2 -= NODE_STEP;
    IRTLASSERT(0 <= iNode2  &&  iNode2 < NODES_PER_CLUMP
               &&  !pnc2->IsEmptyAndInvalid(iNode2));
    IRTLASSERT(iNode2+NODE_STEP == NODE_END
               ||  pnc2->IsEmptyAndInvalid(iNode2+NODE_STEP));

#ifdef IRTLDEBUG
    // Check that all the remaining nodes are empty
    IRTLASSERT(pnc2->IsLastClump());
    for (int iNode3 = iNode2 + NODE_STEP;
         iNode3 != NODE_END;
         iNode3 += NODE_STEP)
    {
        IRTLASSERT(pnc2->IsEmptyAndInvalid(iNode3));
    }
#endif // IRTLDEBUG

    // Move the last node's data back to the current node
    rpnc->m_pvNode[riNode]    = pnc2->m_pvNode[iNode2];
    rpnc->m_dwKeySigs[riNode] = pnc2->m_dwKeySigs[iNode2];

    // Blank the old last node.
    // Correct even if (rpnc, riNode) == (pnc2, iNode2).
    pnc2->m_pvNode[iNode2]    = NULL;
    pnc2->m_dwKeySigs[iNode2] = HASH_INVALID_SIGNATURE;

    IRTLASSERT(0 == _IsNodeCompact(pbkt));

    // Back up riNode by one, so that the next iteration of the loop
    // calling _DeleteNode will end up pointing to the same spot.
    if (riNode != NODE_BEGIN)
    {
        riNode -= NODE_STEP;
    }
    else
    {
        // rewind rpnc and rpncPrev to previous node
        if (rpnc == &pbkt->m_ncFirst)
        {
            riNode = NODE_BEGIN - NODE_STEP;
        }
        else
        {
            riNode = NODE_END;
            rpnc = rpncPrev;
            if (rpnc == &pbkt->m_ncFirst)
            {
                rpncPrev = NULL;
            }
            else
            {
                for (rpncPrev = &pbkt->m_ncFirst;
                     rpncPrev->m_pncNext != rpnc;
                     rpncPrev = rpncPrev->m_pncNext)
                {}
            }
        }
    }

    // Is the last node clump now completely empty?  Delete, if possible
    if (iNode2 == NODE_BEGIN  &&  pnc2 != &pbkt->m_ncFirst)
    {
        // Find preceding nodeclump
        CNodeClump* pnc3 = &pbkt->m_ncFirst;
        while (pnc3->m_pncNext != pnc2)
        {
            pnc3 = pnc3->m_pncNext;
            IRTLASSERT(pnc3 != NULL);
        }

        pnc3->m_pncNext = NULL;
#ifdef IRTLDEBUG
        pnc2->m_pncNext = NULL; // or dtor will ASSERT
#endif // IRTLDEBUG
        _FreeNodeClump(pnc2);
    }

    IRTLASSERT(rpncPrev == NULL  ||  rpncPrev->m_pncNext == rpnc);

    InterlockedDecrement(reinterpret_cast<LONG*>(&m_cRecords));

    return true;
} // CLKRLinearHashTable::_DeleteNode



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindKey
// Synopsis: Locate the record associated with the given key value.
// Returns:  Pointer to the record, if it is found.
//           NULL, if the record is not found.
// Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
//           LK_BAD_RECORD, if ppvRecord is invalid
//           LK_NO_SUCH_KEY, if no record with the given key value was found.
//           LK_UNUSABLE, if hash table not in usable state
// Note:     the record is AddRef'd.  You must decrement the reference count
//           when you are finished with the record (if you're implementing
//           refcounting semantics).
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_FindKey(
    const DWORD_PTR  pnKey,  // Key value of the record, depends on key type
    DWORD        dwSignature,// hash signature
    const void** ppvRecord   // resultant record
#ifdef LKR_STL_ITERATORS
  , Iterator*   piterResult // = NULL. Points to record upon return
#endif // LKR_STL_ITERATORS
    ) const
{
    IRTLASSERT(IsUsable()  &&  ppvRecord != NULL);

    *ppvRecord = NULL;
    LK_RETCODE lkrc = LK_NO_SUCH_KEY;
    int iNode;

    // locate the beginning of the correct bucket chain
    bool fReadLocked = _ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

#ifdef LKR_STL_ITERATORS
    DWORD dwBktAddr;

    if (piterResult != NULL)
    {
        dwBktAddr = _BucketAddress(dwSignature);
        IRTLASSERT(dwBktAddr < m_cActiveBuckets);
    }
#endif // LKR_STL_ITERATORS

    CBucket* const pbkt = _FindBucket(dwSignature, FB_READLOCK);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsReadLocked());
    _ReadOrWriteUnlock(fReadLocked);

    // walk down the bucket chain
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst;
         pncCurr != NULL;
         pncCurr = pncCurr->m_pncNext)
    {
        FOR_EACH_NODE(iNode)
        {
            if (pncCurr->IsEmptySlot(iNode))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(iNode));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (dwSignature != pncCurr->m_dwKeySigs[iNode])
                continue;

            const DWORD_PTR pnKey2 = _ExtractKey(pncCurr->m_pvNode[iNode]);

            if (pnKey == pnKey2  ||  _EqualKeys(pnKey,  pnKey2))
            {
                    *ppvRecord = pncCurr->m_pvNode[iNode];
                    lkrc = LK_SUCCESS;

                    // bump the reference count before handing the record
                    // back to the user.  The user should decrement the
                    // reference count when finished with this record.

                    LK_ADDREF_REASON lkar;

#ifdef LKR_STL_ITERATORS
                    if (piterResult != NULL)
                        lkar = LKAR_ITER_FIND;
                    else
#endif
                        lkar = LKAR_FIND_KEY;

                    _AddRefRecord(*ppvRecord, lkar);
                    goto exit;
            }
        }
    }

  exit:
    pbkt->ReadUnlock();

#ifdef LKR_STL_ITERATORS
    if (piterResult != NULL)
    {
        if (lkrc == LK_SUCCESS)
        {
            piterResult->m_plht =       const_cast<CLKRLinearHashTable*>(this);
            piterResult->m_pnc =          pncCurr;
            piterResult->m_dwBucketAddr = dwBktAddr;
            piterResult->m_iNode =        (short) iNode;
        }
        else
        {
            IRTLASSERT((*piterResult) == End());
        }
    }
#endif // LKR_STL_ITERATORS

    return lkrc;
} // CLKRLinearHashTable::_FindKey



//------------------------------------------------------------------------
// Function: CLKRHashTable::FindKey
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::FindKey(
    const DWORD_PTR pnKey,
    const void**    ppvRecord) const
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (ppvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_READ_LOCK();    // usu. no-op
    DWORD     hash_val   = _CalcKeyHash(pnKey);
    SubTable* const pst  = _SubTable(hash_val);
    LK_RETCODE lkrc      = pst->_FindKey(pnKey, hash_val, ppvRecord);
    LKRHASH_GLOBAL_READ_UNLOCK();    // usu. no-op

    return lkrc;
} // CLKRHashTable::FindKey



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindRecord
// Synopsis: Sees if the record is contained in the table
// Returns:  Pointer to the record, if it is found.
//           NULL, if the record is not found.
// Returns:  LK_SUCCESS, if record found
//           LK_BAD_RECORD, if pvRecord is invalid
//           LK_NO_SUCH_KEY, if the record was not found in the table
//           LK_UNUSABLE, if hash table not in usable state
// Note:     The record is *not* AddRef'd. By definition, the caller
//           already has a reference to it.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_FindRecord(
    const void* pvRecord,    // Pointer to the record to find in the table
    DWORD       dwSignature  // hash signature
    ) const
{
    IRTLASSERT(IsUsable()  &&  pvRecord != NULL);

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    bool fReadLocked = _ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, FB_READLOCK);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsReadLocked());
    _ReadOrWriteUnlock(fReadLocked);

    const DWORD_PTR pnKey = _ExtractKey(pvRecord);
    IRTLASSERT(dwSignature == _CalcKeyHash(pnKey));

    // walk down the bucket chain
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst;
         pncCurr != NULL;
         pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (pncCurr->m_pvNode[i] == pvRecord)
            {
                IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[i]);
                IRTLASSERT(_EqualKeys(pnKey,
                                      _ExtractKey(pncCurr->m_pvNode[i])));
                lkrc = LK_SUCCESS;

                // Do NOT AddRef the record.

                goto exit;
            }
        }
    }

  exit:
    pbkt->ReadUnlock();
    return lkrc;
} // CLKRLinearHashTable::_FindRecord



//------------------------------------------------------------------------
// Function: CLKRHashTable::FindRecord
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::FindRecord(
    const void* pvRecord) const
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_READ_LOCK();    // usu. no-op
    DWORD     hash_val   = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst  = _SubTable(hash_val);
    LK_RETCODE lkrc      = pst->_FindRecord(pvRecord, hash_val);
    LKRHASH_GLOBAL_READ_UNLOCK();    // usu. no-op

    return lkrc;
} // CLKRHashTable::FindRecord



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::CheckTable
// Synopsis: Verify that all records are in the right place and can be located.
// Returns:   0 => hash table is consistent
//           >0 => that many misplaced records
//           <0 => otherwise invalid
//------------------------------------------------------------------------

int
CLKRLinearHashTable::CheckTable() const
{
    if (!IsUsable())
        return LK_UNUSABLE;

    bool fReadLocked = _ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (!IsValid())
    {
        _ReadOrWriteUnlock(fReadLocked);
        return LK_UNUSABLE;
    }

    int       cMisplaced = 0;
    DWORD     cRecords = 0;
    int       retcode = 0;

    // Check every bucket
    for (DWORD i = 0;  i < m_cActiveBuckets;  i++)
    {
        CBucket* const pbkt = _Bucket(i);

        IRTLASSERT(pbkt != NULL);
        retcode += !(pbkt != NULL);

        pbkt->ReadLock();

        IRTLASSERT(0 == _IsNodeCompact(pbkt));

        // Walk the bucket chain
        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            int j;

            FOR_EACH_NODE(j)
            {
                if (pncCurr->IsEmptySlot(j))
                {
                    IRTLASSERT(pncCurr->IsLastClump());
                    retcode += !(pncCurr->IsLastClump());

                    for (int k = j;  k != NODE_END;  k += NODE_STEP)
                    {
                        IRTLASSERT(pncCurr->IsEmptyNode(k));
                        retcode += !pncCurr->IsEmptyNode(k);
                        IRTLASSERT(pncCurr->InvalidSignature(k));
                        retcode += !pncCurr->InvalidSignature(k);
                    }
                    break;
                }

                if (!pncCurr->IsEmptySlot(j))
                {
                    ++cRecords;

                    const DWORD_PTR pnKey = _ExtractKey(pncCurr->m_pvNode[j]);

                    DWORD dwSignature = _CalcKeyHash(pnKey);
                    IRTLASSERT(dwSignature != HASH_INVALID_SIGNATURE);
                    retcode += !(dwSignature != HASH_INVALID_SIGNATURE);
                    IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[j]);
                    retcode += !(dwSignature == pncCurr->m_dwKeySigs[j]);

                    DWORD address = _BucketAddress(dwSignature);
                    IRTLASSERT(address == i);
                    retcode += !(address == i);

                    if (address != i || dwSignature != pncCurr->m_dwKeySigs[j])
                        cMisplaced++;
                }
                else // pncCurr->IsEmptySlot(j)
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(j));
                    retcode += !pncCurr->IsEmptyAndInvalid(j);
                }
            }
            if (pncPrev != NULL)
            {
                IRTLASSERT(pncPrev->m_pncNext == pncCurr);
                retcode += !(pncPrev->m_pncNext == pncCurr);
            }
        }
        pbkt->ReadUnlock();
    }

    if (cRecords != m_cRecords)
        ++retcode;

    IRTLASSERT(cRecords == m_cRecords);
    retcode += !(cRecords == m_cRecords);

    if (cMisplaced > 0)
        retcode = cMisplaced;

    IRTLASSERT(cMisplaced == 0);
    retcode += !(cMisplaced == 0);

    _ReadOrWriteUnlock(fReadLocked);

    return retcode;
} // CLKRLinearHashTable::CheckTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::CheckTable
// Synopsis: Verify that all records are in the right place and can be located.
// Returns:   0 => hash table is consistent
//           >0 => that many misplaced records
//           <0 => otherwise invalid
//------------------------------------------------------------------------
int
CLKRHashTable::CheckTable() const
{
    if (!IsUsable())
        return LK_UNUSABLE;

    int retcode = 0;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
        retcode += m_palhtDir[i]->CheckTable();

    return retcode;
} // CLKRHashTable::CheckTable



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Clear
// Synopsis: Remove all data from the table
//------------------------------------------------------------------------

void
CLKRLinearHashTable::_Clear(
    bool fShrinkDirectory)  // Shrink to min size but don't destroy entirely?
{
    if (!IsUsable())
        return;

    IRTLASSERT(IsWriteLocked());

#ifdef IRTLDEBUG
    DWORD cDeleted = 0;
    DWORD cOldRecords = m_cRecords;
#endif // IRTLDEBUG

    const LK_ADDREF_REASON lkar = (fShrinkDirectory ? LKAR_CLEAR : LKAR_DTOR);

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);
        pbkt->WriteLock();

        IRTLASSERT(0 == _IsNodeCompact(pbkt));

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             )
        {
            int i;

            FOR_EACH_NODE(i)
            {

                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                    IRTLASSERT(pncCurr->IsLastClump());
                    break;
                }
                else
                {
                    _AddRefRecord(pncCurr->m_pvNode[i], lkar);
                    pncCurr->m_pvNode[i]    = NULL;
                    pncCurr->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
                    m_cRecords--;

#ifdef IRTLDEBUG
                    ++cDeleted;
#endif // IRTLDEBUG
                }
            } // for (i ...

            pncPrev = pncCurr;
            pncCurr = pncCurr->m_pncNext;
            pncPrev->m_pncNext = NULL;

            if (pncPrev != &pbkt->m_ncFirst)
                _FreeNodeClump(pncPrev);
        } // for (pncCurr ...

        pbkt->WriteUnlock();
    } // for (iBkt ...

    IRTLASSERT(m_cRecords == 0  &&  cDeleted == cOldRecords);

    // delete all segments
    for (DWORD iSeg = 0;  iSeg < m_cActiveBuckets;  iSeg += m_dwSegSize)
    {
        _FreeSegment(_Segment(iSeg));
        _Segment(iSeg) = NULL;
    }

    _FreeSegmentDirectory();
    m_nLevel = m_cActiveBuckets = m_iExpansionIdx = 0;
    m_dwBktAddrMask0 = 1;
    m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;

    // set directory of segments to minimum size
    if (fShrinkDirectory)
    {
        DWORD cInitialBuckets = 0;

        if (LK_SMALL_TABLESIZE == m_lkts)
            cInitialBuckets = CSmallSegment::INITSIZE;
        else if (LK_MEDIUM_TABLESIZE == m_lkts)
            cInitialBuckets = CMediumSegment::INITSIZE;
        else if (LK_LARGE_TABLESIZE == m_lkts)
            cInitialBuckets = CLargeSegment::INITSIZE;
        else
            IRTLASSERT(! "Unknown LK_TABLESIZE");

        _SetSegVars(m_lkts, cInitialBuckets);
    }
} // CLKRLinearHashTable::_Clear



//------------------------------------------------------------------------
// Function: CLKRHashTable::Clear
// Synopsis: Remove all data from the table
//------------------------------------------------------------------------

void
CLKRHashTable::Clear()
{
    WriteLock();
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->_Clear(true);
    WriteUnlock();
} // CLKRHashTable::Clear



//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_SetSegVars
// Synopsis: sets the size-specific segment variables
//-----------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_SetSegVars(
    LK_TABLESIZE lkts,
    DWORD        cInitialBuckets)
{
    switch (lkts)
    {
    case LK_SMALL_TABLESIZE:
      {
        m_lkts      = LK_SMALL_TABLESIZE;
        m_dwSegBits = CSmallSegment::SEGBITS;
        m_dwSegSize = CSmallSegment::SEGSIZE;
        m_dwSegMask = CSmallSegment::SEGMASK;
        STATIC_ASSERT(CSmallSegment::SEGSIZE == (1U<<CSmallSegment::SEGBITS));
        STATIC_ASSERT(CSmallSegment::SEGMASK == (CSmallSegment::SEGSIZE-1));
        break;
      }
        
    default:
        IRTLASSERT(! "Unknown LK_TABLESIZE");
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
      {
        m_lkts      = LK_MEDIUM_TABLESIZE;
        m_dwSegBits = CMediumSegment::SEGBITS;
        m_dwSegSize = CMediumSegment::SEGSIZE;
        m_dwSegMask = CMediumSegment::SEGMASK;
        STATIC_ASSERT(CMediumSegment::SEGSIZE ==(1U<<CMediumSegment::SEGBITS));
        STATIC_ASSERT(CMediumSegment::SEGMASK == (CMediumSegment::SEGSIZE-1));
        break;
      }
        
    case LK_LARGE_TABLESIZE:
      {
        m_lkts      = LK_LARGE_TABLESIZE;
        m_dwSegBits = CLargeSegment::SEGBITS;
        m_dwSegSize = CLargeSegment::SEGSIZE;
        m_dwSegMask = CLargeSegment::SEGMASK;
        STATIC_ASSERT(CLargeSegment::SEGSIZE == (1U<<CLargeSegment::SEGBITS));
        STATIC_ASSERT(CLargeSegment::SEGMASK == (CLargeSegment::SEGSIZE-1));
        break;
      }
    }

    m_dwBktAddrMask0 = m_dwSegMask;
    m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
    m_nLevel         = m_dwSegBits;
    m_cActiveBuckets = cInitialBuckets;

    IRTLASSERT(m_cActiveBuckets > 0);

    IRTLASSERT(m_nLevel == m_dwSegBits);
    IRTLASSERT(m_dwBktAddrMask0 == (1U << m_nLevel) - 1);
    IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));

    IRTLASSERT(m_dwSegBits > 0);
    IRTLASSERT(m_dwSegSize == (1U << m_dwSegBits));
    IRTLASSERT(m_dwSegMask == (m_dwSegSize - 1));
    IRTLASSERT(m_dwBktAddrMask0 == m_dwSegMask);

    // adjust m_dwBktAddrMask0 (== m_dwSegMask) to make it large
    // enough to distribute the buckets across the address space
    for (DWORD tmp = m_cActiveBuckets >> m_dwSegBits;  tmp > 1;  tmp >>= 1)
    {
        ++m_nLevel;
        m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
    }

    m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;

    IRTLASSERT(_H1(m_cActiveBuckets) == m_cActiveBuckets);
    m_iExpansionIdx = m_cActiveBuckets & m_dwBktAddrMask0;

    // create and clear directory of segments
    DWORD cDirSegs = MIN_DIRSIZE;
    while (cDirSegs < (m_cActiveBuckets >> m_dwSegBits))
        cDirSegs <<= 1;

    cDirSegs = min(cDirSegs, MAX_DIRSIZE);
    IRTLASSERT((cDirSegs << m_dwSegBits) >= m_cActiveBuckets);

    m_lkrcState = LK_ALLOC_FAIL;
    m_paDirSegs = _AllocateSegmentDirectory(cDirSegs);

    if (m_paDirSegs != NULL)
    {
        m_cDirSegs = cDirSegs;
        IRTLASSERT(m_cDirSegs >= MIN_DIRSIZE
                   &&  (m_cDirSegs & (m_cDirSegs-1)) == 0);  // == (1 << N)

        // create and initialize only the required segments
        DWORD dwMaxSegs = (m_cActiveBuckets + m_dwSegSize - 1) >> m_dwSegBits;
        IRTLASSERT(dwMaxSegs <= m_cDirSegs);

#if 0
        IRTLTRACE(TEXT("LKR_SetSegVars: m_lkts = %d, m_cActiveBuckets = %lu, ")
                  TEXT("m_dwSegSize = %lu, bits = %lu\n")
                  TEXT("m_cDirSegs = %lu, dwMaxSegs = %lu, ")
                  TEXT("segment total size = %lu bytes\n"),
                  m_lkts, m_cActiveBuckets,
                  m_dwSegSize, m_dwSegBits,
                  m_cDirSegs, dwMaxSegs,
                  m_dwSegSize * sizeof(CBucket));
#endif

        m_lkrcState = LK_SUCCESS; // so IsValid/IsUsable won't fail

        for (DWORD i = 0;  i < dwMaxSegs;  i++)
        {
            CSegment* pSeg = _AllocateSegment();
            if (pSeg != NULL)
                m_paDirSegs[i].m_pseg = pSeg;
            else
            {
                // problem: deallocate everything
                m_lkrcState = LK_ALLOC_FAIL;
                for (DWORD j = i;  j-- > 0;  )
                {
                    _FreeSegment(m_paDirSegs[j].m_pseg);
                    m_paDirSegs[j].m_pseg = NULL;
                }
                _FreeSegmentDirectory();
                break;
            }
        }
    }

    if (m_lkrcState != LK_SUCCESS)
    {
        m_paDirSegs = NULL;
        m_cDirSegs  = m_cActiveBuckets = m_iExpansionIdx = 0;

        // Propagate error back up to parent (if it exists). This ensures
        // that all of the parent's public methods will start failing.
        if (NULL != m_phtParent)
            m_phtParent->m_lkrcState = m_lkrcState;
    }

    return m_lkrcState;
} // CLKRLinearHashTable::_SetSegVars




#include <stdlib.h>

LONG g_cAllocDirEntry = 0;
LONG g_cAllocNodeClump = 0;
LONG g_cAllocSmallSegment = 0;
LONG g_cAllocMediumSegment = 0;
LONG g_cAllocLargeSegment = 0;

extern "C"
__declspec(dllexport)
bool
GetAllocCounters()
{
return true;
}

// #define LKR_RANDOM_MEMORY_FAILURES 1000  // 1..RAND_MAX (32767)

// Memory allocation wrappers to allow us to simulate allocation
// failures during testing

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateSegmentDirectory
// Synopsis: 
//------------------------------------------------------------------------

CDirEntry* const
CLKRLinearHashTable::_AllocateSegmentDirectory(
    size_t n)
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES
    // InterlockedIncrement(&g_cAllocDirEntry);

    CDirEntry* const paDirSegs = new CDirEntry [n];

#ifdef IRTLDEBUG
    for (size_t i = 0;  i < n;  ++i)
        IRTLASSERT(paDirSegs[i].m_pseg == NULL);
#endif // IRTLDEBUG

    return paDirSegs;
} // CLKRLinearHashTable::_AllocateSegmentDirectory



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeSegmentDirectory
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeSegmentDirectory()
{
#ifdef IRTLDEBUG
    for (size_t i = 0;  i < m_cDirSegs;  ++i)
        IRTLASSERT(m_paDirSegs[i].m_pseg == NULL);
#endif // IRTLDEBUG

    delete [] m_paDirSegs;
    m_paDirSegs = NULL;
    m_cDirSegs = 0;
    return true;
} // CLKRLinearHashTable::_FreeSegmentDirectory



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateNodeClump
// Synopsis: 
//------------------------------------------------------------------------

CNodeClump* const
CLKRLinearHashTable::_AllocateNodeClump()
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES
    // InterlockedIncrement(&g_cAllocNodeClump);

    return new CNodeClump;
} // CLKRLinearHashTable::_AllocateNodeClump



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeNodeClump
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeNodeClump(
    CNodeClump* pnc)
{
    delete pnc;
    return true;
} // CLKRLinearHashTable::_FreeNodeClump



//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateSegment
// Synopsis: creates a new segment of the approriate size
// Output:   pointer to the new segment; NULL => failure
//-----------------------------------------------------------------------

CSegment* const
CLKRLinearHashTable::_AllocateSegment(
    ) const
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES

    STATIC_ASSERT(offsetof(CSmallSegment, m_bktSlots) + sizeof(CBucket)
                  == offsetof(CSmallSegment, m_bktSlots2));

    STATIC_ASSERT(offsetof(CMediumSegment, m_bktSlots) + sizeof(CBucket)
                  == offsetof(CMediumSegment, m_bktSlots2));

    STATIC_ASSERT(offsetof(CLargeSegment, m_bktSlots) + sizeof(CBucket)
                  == offsetof(CLargeSegment, m_bktSlots2));

    CSegment* pseg = NULL;

    switch (m_lkts)
    {
    case LK_SMALL_TABLESIZE:
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CSmallSegment::sm_palloc != NULL);
#endif // LKRHASH_ALLOCATOR_NEW
        // InterlockedIncrement(&g_cAllocSmallSegment);
        pseg = new CSmallSegment;
        break;
        
    default:
        IRTLASSERT(! "Unknown LK_TABLESIZE");
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CMediumSegment::sm_palloc != NULL);
#endif // LKRHASH_ALLOCATOR_NEW
        // InterlockedIncrement(&g_cAllocMediumSegment);
        pseg = new CMediumSegment;
        break;
        
    case LK_LARGE_TABLESIZE:
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CLargeSegment::sm_palloc != NULL);
#endif // LKRHASH_ALLOCATOR_NEW
        // InterlockedIncrement(&g_cAllocLargeSegment);
        pseg = new CLargeSegment;
        break;
    }

    IRTLASSERT(pseg != NULL);

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    if (pseg != NULL  &&  BucketLock::PerLockSpin() == LOCK_INDIVIDUAL_SPIN)
    {
        for (DWORD i = 0;  i < m_dwSegSize;  ++i)
            pseg->Slot(i).SetSpinCount(m_wBucketLockSpins);
    }
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION

    return pseg;
} // CLKRLinearHashTable::_AllocateSegment



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeSegment
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeSegment(
    CSegment* pseg) const
{
    switch (m_lkts)
    {
    case LK_SMALL_TABLESIZE:
        delete static_cast<CSmallSegment*>(pseg);
        break;
        
    default:
        IRTLASSERT(! "Unknown LK_TABLESIZE");
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
        delete static_cast<CMediumSegment*>(pseg);
        break;
        
    case LK_LARGE_TABLESIZE:
        delete static_cast<CLargeSegment*>(pseg);
        break;
    }

    return true;
} // CLKRLinearHashTable::_FreeSegment



//------------------------------------------------------------------------
// Function: CLKRHashTable::_AllocateSubTableArray
// Synopsis: 
//------------------------------------------------------------------------

CLKRHashTable::SubTable** const
CLKRHashTable::_AllocateSubTableArray(
    size_t n)
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES

    return new SubTable* [n];
} // CLKRHashTable::_AllocateSubTableArray



//------------------------------------------------------------------------
// Function: CLKRHashTable::_FreeSubTableArray
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::_FreeSubTableArray(
    CLKRHashTable::SubTable** palht)
{
    delete [] palht;
    return true;
} // CLKRHashTable::_FreeSubTableArray



//------------------------------------------------------------------------
// Function: CLKRHashTable::_AllocateSubTable
// Synopsis: 
//------------------------------------------------------------------------

CLKRHashTable::SubTable* const
CLKRHashTable::_AllocateSubTable(
    LPCSTR              pszName,        // An identifier for debugging
    LKR_PFnExtractKey   pfnExtractKey,  // Extract key from record
    LKR_PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    LKR_PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    LKR_PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    unsigned            maxload,        // Upperbound on average chain length
    DWORD               initsize,       // Initial size of hash table.
    CLKRHashTable*      phtParent,      // Owning table.
    bool                fMultiKeys,     // Allow multiple identical keys?
    bool                fNonPagedAllocs // use paged or NP pool in kernel
    )
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES

    return new SubTable(pszName, pfnExtractKey, pfnCalcKeyHash,
                        pfnEqualKeys,  pfnAddRefRecord,
                        maxload, initsize, phtParent,
                        fMultiKeys, fNonPagedAllocs);
} // CLKRHashTable::_AllocateSubTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::_FreeSubTable
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::_FreeSubTable(
    CLKRHashTable::SubTable* plht)
{
    delete plht;
    return true;
} // CLKRHashTable::_FreeSubTable




//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Expand
// Synopsis: Expands the table by one bucket. Done by splitting the
//           bucket pointed to by m_iExpansionIdx.
// Output:   LK_SUCCESS, if expansion was successful.
//           LK_ALLOC_FAIL, if expansion failed due to lack of memory.
//-----------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Expand()
{
    if (m_cActiveBuckets >= (MAX_DIRSIZE << m_dwSegBits) - 1)
        return LK_ALLOC_FAIL;  // table is not allowed to grow any more

    WriteLock();

    // double segment directory size if necessary
    if (m_cActiveBuckets >= (m_cDirSegs << m_dwSegBits))
    {
        IRTLASSERT(m_cDirSegs < MAX_DIRSIZE);
        DWORD cDirSegsNew = (m_cDirSegs == 0) ? MIN_DIRSIZE : m_cDirSegs << 1;
        CDirEntry* paDirSegsNew = _AllocateSegmentDirectory(cDirSegsNew);

        if (paDirSegsNew != NULL)
        {
            for (DWORD j = 0;  j < m_cDirSegs;  j++)
            {
                paDirSegsNew[j] = m_paDirSegs[j];
                m_paDirSegs[j].m_pseg = NULL;
            }

            _FreeSegmentDirectory();
            m_paDirSegs = paDirSegsNew;
            m_cDirSegs  = cDirSegsNew;
        }
        else
        {
            WriteUnlock();
            return LK_ALLOC_FAIL;  // expansion failed
        }
    }

    // locate the new bucket, creating a new segment if necessary
    ++m_cActiveBuckets;

    DWORD     dwOldBkt = m_iExpansionIdx;
    DWORD     dwNewBkt = (1 << m_nLevel) | dwOldBkt;

    IRTLASSERT(dwOldBkt < m_cActiveBuckets);
    IRTLASSERT(dwNewBkt < m_cActiveBuckets);

    IRTLASSERT(_Segment(dwOldBkt) != NULL);
    CSegment* psegNew  = _Segment(dwNewBkt);

    if (psegNew == NULL)
    {
        psegNew = _AllocateSegment();
        if (psegNew == NULL)
        {
            --m_cActiveBuckets;
            WriteUnlock();
            return LK_ALLOC_FAIL;  // expansion failed
        }
        _Segment(dwNewBkt) = psegNew;
    }

    // prepare to relocate records to the new bucket
    CBucket* pbktOld = _Bucket(dwOldBkt);
    CBucket* pbktNew = _Bucket(dwNewBkt);

    // get locks on the two buckets involved
    pbktOld->WriteLock();
    pbktNew->WriteLock();

    // Now work out if we need to allocate any extra CNodeClumps.  We do
    // this up front, before calling _SplitRecordSet, as it's hard to
    // gracefully recover from the depths of that routine should we run
    // out of memory.

    CNodeClump* pncFreeList = NULL;
    LK_RETCODE  lkrc        = LK_SUCCESS;

    // If the old bucket has more than one CNodeClump, there's a chance that
    // we'll need extra CNodeClumps in the new bucket too.  If it doesn't,
    // we definitely won't. One CNodeClump is enough to prime the freelist.
    if (!pbktOld->m_ncFirst.IsLastClump())
    {
        pncFreeList = _AllocateNodeClump();
        if (pncFreeList == NULL)
        {
            lkrc = LK_ALLOC_FAIL;
            --m_cActiveBuckets;
        }
    }

    // adjust expansion pointer, level, and mask
    if (lkrc == LK_SUCCESS)
    {
        if (++m_iExpansionIdx == (1U << m_nLevel))
        {
            ++m_nLevel;
            m_iExpansionIdx = 0;

            m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
            // m_dwBktAddrMask0 = 00011..111
            IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0);

            m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
            IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));
            IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
        }
    }

    DWORD iExpansionIdx = m_iExpansionIdx;  // save to avoid race conditions
    DWORD dwBktAddrMask = m_dwBktAddrMask0; // ditto

    // Release the table lock before doing the actual relocation
    WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        lkrc = _SplitRecordSet(&pbktOld->m_ncFirst, &pbktNew->m_ncFirst,
                               iExpansionIdx, dwBktAddrMask,
                               dwNewBkt, pncFreeList);
    }

    pbktNew->WriteUnlock();
    pbktOld->WriteUnlock();

    return lkrc;
} // CLKRLinearHashTable::_Expand



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_SplitRecordSet
// Synopsis: Split records between the old and new buckets.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_SplitRecordSet(
    CNodeClump* pncOldTarget,
    CNodeClump* pncNewTarget,
    DWORD       iExpansionIdx,
    DWORD       dwBktAddrMask,
    DWORD       dwNewBkt,
    CNodeClump* pncFreeList     // list of free nodes available for reuse
    )
{
    CNodeClump  ncFirst = *pncOldTarget;    // save head of old target chain
    CNodeClump* pncOldList = &ncFirst;
    CNodeClump* pncTmp;
    int         iOldSlot = NODE_BEGIN;
    int         iNewSlot = NODE_BEGIN;

    // clear target buckets
    pncOldTarget->Clear();
    pncNewTarget->Clear();

    // scan through the old bucket chain and decide where to move each record
    while (pncOldList != NULL)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            // node already empty?
            if (pncOldList->IsEmptySlot(i))
            {
                IRTLASSERT(pncOldList->IsEmptyAndInvalid(i));
                continue;
            }

            // calculate bucket address of this node
            DWORD dwBkt = _H0(pncOldList->m_dwKeySigs[i], dwBktAddrMask);
            if (dwBkt < iExpansionIdx)
                dwBkt = _H1(pncOldList->m_dwKeySigs[i], dwBktAddrMask);

            // record to be moved to the new address?
            if (dwBkt == dwNewBkt)
            {
                // node in new bucket chain full?
                if (iNewSlot == NODE_END)
                {
                    // the calling routine has passed in a FreeList adequate
                    // for all needs
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncNewTarget->m_pncNext = pncTmp;
                    pncNewTarget = pncTmp;
                    iNewSlot = NODE_BEGIN;
                }

                pncNewTarget->m_dwKeySigs[iNewSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncNewTarget->m_pvNode[iNewSlot]
                    = pncOldList->m_pvNode[i];
                iNewSlot += NODE_STEP;
            }

            // no, record stays in its current bucket chain
            else
            {
                // node in old bucket chain full?
                if (iOldSlot == NODE_END)
                {
                    // the calling routine has passed in a FreeList adequate
                    // for all needs
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncOldTarget->m_pncNext = pncTmp;
                    pncOldTarget = pncTmp;
                    iOldSlot = NODE_BEGIN;
                }

                pncOldTarget->m_dwKeySigs[iOldSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncOldTarget->m_pvNode[iOldSlot]
                    = pncOldList->m_pvNode[i];
                iOldSlot += NODE_STEP;
            }

            // clear old slot
            pncOldList->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
            pncOldList->m_pvNode[i]    = NULL;
        }

        // keep walking down the original bucket chain
        pncTmp     = pncOldList;
        pncOldList = pncOldList->m_pncNext;

        // ncFirst is a stack variable, not allocated on the heap
        if (pncTmp != &ncFirst)
        {
            pncTmp->m_pncNext = pncFreeList;
            pncFreeList = pncTmp;
        }
    }

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->m_pncNext;
#ifdef IRTLDEBUG
        pncTmp->m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG
        _FreeNodeClump(pncTmp);
    }

#ifdef IRTLDEBUG
    ncFirst.m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG

    return LK_SUCCESS;
} // CLKRLinearHashTable::_SplitRecordSet



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Contract
// Synopsis: Contract the table by deleting the last bucket in the active
//           address space. Return the records to the "buddy" of the
//           deleted bucket.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Contract()
{
    WriteLock();

    // update the state variables (expansion ptr, level and mask)
    if (m_iExpansionIdx > 0)
        --m_iExpansionIdx;
    else
    {
        --m_nLevel;
        m_iExpansionIdx = (1 << m_nLevel) - 1;
        IRTLASSERT(m_nLevel > 0  &&  m_iExpansionIdx > 0);

        m_dwBktAddrMask0 >>= 1;
        IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0); // 0011..11

        m_dwBktAddrMask1 >>= 1;
        IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));
        IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
    }

    // The last bucket is the one that will be emptied
    CBucket* pbktLast = _Bucket(m_cActiveBuckets - 1);
    pbktLast->WriteLock();

    // Decrement after calculating pbktLast, or _Bucket() will assert.
    --m_cActiveBuckets;

    // Where the nodes from pbktLast will end up
    CBucket* pbktNew = _Bucket(m_iExpansionIdx);
    pbktNew->WriteLock();

    // Now we work out if we need to allocate any extra CNodeClumps.  We do
    // this up front, before calling _MergeRecordSets, as it's hard to
    // gracefully recover from the depths of that routine should we run
    // out of memory.
    
    CNodeClump* pnc;
    int         c = 0;

    // First, count the number of items in the old bucket
    for (pnc = &pbktLast->m_ncFirst;  pnc != NULL;  pnc = pnc->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (!pnc->IsEmptySlot(i))
            {
                IRTLASSERT(!pnc->IsEmptyAndInvalid(i));
                c++;
            }
        }
    }

    // Then, subtract off the number of empty slots in the new bucket
    for (pnc = &pbktNew->m_ncFirst;  pnc != NULL;  pnc = pnc->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pnc->IsEmptySlot(i))
            {
                IRTLASSERT(pnc->IsEmptyAndInvalid(i));
                c--;
            }
        }
    }

    CNodeClump* pncFreeList = NULL;  // list of nodes available for reuse
    LK_RETCODE  lkrc        = LK_SUCCESS;

    // Do we need to allocate CNodeClumps to accommodate the surplus items?
    if (c > 0)
    {
        pncFreeList = _AllocateNodeClump();
        if (pncFreeList == NULL)
            lkrc = LK_ALLOC_FAIL;
        else if (c > NODES_PER_CLUMP)
        {
            // In the worst case, we need a 2-element freelist for
            // _MergeRecordSets. Two CNodeClumps always suffice since the
            // freelist will be augmented by the CNodeClumps from the old
            // bucket as they are processed.
            pnc = _AllocateNodeClump();
            if (pnc == NULL)
            {
                _FreeNodeClump(pncFreeList);
                lkrc = LK_ALLOC_FAIL;
            }
            else
                pncFreeList->m_pncNext = pnc;
        }
    }

    // Abort if we couldn't allocate enough CNodeClumps
    if (lkrc != LK_SUCCESS)
    {
        // undo the changes to the state variables
        if (++m_iExpansionIdx == (1U << m_nLevel))
        {
            ++m_nLevel;
            m_iExpansionIdx  = 0;

            m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
            IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0);

            m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
            IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));
            IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
        }
        ++m_cActiveBuckets;

        // Unlock the buckets and the table
        pbktLast->WriteUnlock();
        pbktNew->WriteUnlock();
        WriteUnlock();

        return lkrc;
    }

    // Copy the chain of records from pbktLast
    CNodeClump ncOldFirst = pbktLast->m_ncFirst;

    // destroy pbktLast
    pbktLast->m_ncFirst.Clear();
    pbktLast->WriteUnlock();

    // remove segment, if empty
    if (_SegIndex(m_cActiveBuckets) == 0)
    {
#ifdef IRTLDEBUG
        // double-check that the supposedly empty segment is really empty
        IRTLASSERT(_Segment(m_cActiveBuckets) != NULL);
        for (DWORD i = 0;  i < m_dwSegSize;  ++i)
        {
            CBucket* pbkt = &_Segment(m_cActiveBuckets)->Slot(i);
            IRTLASSERT(pbkt->IsWriteUnlocked()  &&  pbkt->IsReadUnlocked());
            IRTLASSERT(pbkt->m_ncFirst.IsLastClump());

            int j;

            FOR_EACH_NODE(j)
            {
                IRTLASSERT(pbkt->m_ncFirst.IsEmptyAndInvalid(j));
            }
        }
#endif // IRTLDEBUG
        _FreeSegment(_Segment(m_cActiveBuckets));
        _Segment(m_cActiveBuckets) = NULL;
    }

    // reduce directory of segments if possible
    if (m_cActiveBuckets <= (m_cDirSegs << (m_dwSegBits - 1))
        &&  m_cDirSegs > MIN_DIRSIZE)
    {
        DWORD cDirSegsNew = m_cDirSegs >> 1;
        CDirEntry* paDirSegsNew = _AllocateSegmentDirectory(cDirSegsNew);

        // Memory allocation failure here does not require us to abort; it
        // just means that the directory of segments is larger than we'd like.
        if (paDirSegsNew != NULL)
        {
            for (DWORD j = 0;  j < cDirSegsNew;  j++)
                paDirSegsNew[j] = m_paDirSegs[j];
            for (j = 0;  j < m_cDirSegs;  j++)
                m_paDirSegs[j].m_pseg = NULL;

            _FreeSegmentDirectory();
            m_paDirSegs = paDirSegsNew;
            m_cDirSegs  = cDirSegsNew;
        }
    }

    // release the table lock before doing the reorg
    WriteUnlock();

    lkrc = _MergeRecordSets(pbktNew, &ncOldFirst, pncFreeList);

    pbktNew->WriteUnlock();

#ifdef IRTLDEBUG
    ncOldFirst.m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG

    return lkrc;
} // CLKRLinearHashTable::_Contract



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_MergeRecordSets
// Synopsis: Merge two record sets.  Copy the contents of pncOldList
//           into pbktNewTarget.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_MergeRecordSets(
    CBucket*    pbktNewTarget,
    CNodeClump* pncOldList,
    CNodeClump* pncFreeList
    )
{
    IRTLASSERT(pbktNewTarget != NULL  &&  pncOldList != NULL);

    CNodeClump*   pncTmp = NULL;
    CNodeClump* const pncOldFirst = pncOldList;
    CNodeClump*   pncNewTarget = &pbktNewTarget->m_ncFirst;
    int           iNewSlot;

    // find the first nodeclump in the new target bucket with an empty slot
    while (!pncNewTarget->IsLastClump())
    {
        FOR_EACH_NODE(iNewSlot)
        {
            if (pncNewTarget->IsEmptySlot(iNewSlot))
                break;
        }

        if (iNewSlot == NODE_END)
            pncNewTarget = pncNewTarget->m_pncNext;
        else
            break;
    }

    IRTLASSERT(pncNewTarget != NULL);

    // find the first empty slot in pncNewTarget;
    // if none, iNewSlot == NODE_END
    FOR_EACH_NODE(iNewSlot)
    {
        if (pncNewTarget->IsEmptySlot(iNewSlot))
        {
            break;
        }
    }
    
    while (pncOldList != NULL)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (!pncOldList->IsEmptySlot(i))
            {
                // any empty slots left in pncNewTarget?
                if (iNewSlot == NODE_END)
                {
                    // no, so walk down pncNewTarget until we find another
                    // empty slot
                    while (!pncNewTarget->IsLastClump())
                    {
                        pncNewTarget = pncNewTarget->m_pncNext;

                        FOR_EACH_NODE(iNewSlot)
                        {
                            if (pncNewTarget->IsEmptySlot(iNewSlot))
                                goto found_slot;
                        }
                    }

                    // Oops, reached the last nodeclump in pncNewTarget
                    // and it's full.  Get a new nodeclump off the free
                    // list, which is big enough to handle all needs.
                    IRTLASSERT(pncNewTarget != NULL);
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncNewTarget->m_pncNext = pncTmp;
                    pncNewTarget = pncTmp;
                    iNewSlot = NODE_BEGIN;
                }

              found_slot:
                // We have an empty slot in pncNewTarget
                IRTLASSERT(0 <= iNewSlot  &&  iNewSlot < NODES_PER_CLUMP
                       &&  pncNewTarget != NULL
                       &&  pncNewTarget->IsEmptyAndInvalid(iNewSlot));

                // Let's copy the node from pncOldList
                pncNewTarget->m_dwKeySigs[iNewSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncNewTarget->m_pvNode[iNewSlot]
                    = pncOldList->m_pvNode[i];

                // Clear old slot
                pncOldList->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
                pncOldList->m_pvNode[i]    = NULL;

                // find the next free slot in pncNewTarget
                while ((iNewSlot += NODE_STEP) != NODE_END)
                {
                    if (pncNewTarget->IsEmptySlot(iNewSlot))
                    {
                        break;
                    }
                }
            }
            else // iNewSlot != NODE_END
            {
                IRTLASSERT(pncOldList->IsEmptyAndInvalid(i));
            }
        }

        // Move into the next nodeclump in pncOldList
        pncTmp = pncOldList;
        pncOldList = pncOldList->m_pncNext;

        // Append to the free list.  Don't put the first node of
        // pncOldList on the free list, as it's a stack variable.
        if (pncTmp != pncOldFirst)
        {
            pncTmp->m_pncNext = pncFreeList;
            pncFreeList = pncTmp;
        }
    }

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->m_pncNext;
#ifdef IRTLDEBUG
        pncTmp->m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG
        _FreeNodeClump(pncTmp);
    }

    return LK_SUCCESS;
} // CLKRLinearHashTable::_MergeRecordSets




//------------------------------------------------------------------------
// Function: CLKRHashTable::WriteLock
// Synopsis: Lock all subtables for writing
//------------------------------------------------------------------------

void
CLKRHashTable::WriteLock()
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->WriteLock();
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
    }
} // CLKRHashTable::WriteLock



//------------------------------------------------------------------------
// Function: CLKRHashTable::ReadLock
// Synopsis: Lock all subtables for reading
//------------------------------------------------------------------------

void
CLKRHashTable::ReadLock() const
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->ReadLock();
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
    }
} // CLKRHashTable::ReadLock



//------------------------------------------------------------------------
// Function: CLKRHashTable::WriteUnlock
// Synopsis: Unlock all subtables
//------------------------------------------------------------------------

void
CLKRHashTable::WriteUnlock()
{
    // unlock in reverse order: LIFO
    for (DWORD i = m_cSubTables;  i-- > 0;  )
    {
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
        m_palhtDir[i]->WriteUnlock();
        IRTLASSERT(m_palhtDir[i]->IsWriteUnlocked());
    }
} // CLKRHashTable::WriteUnlock



//------------------------------------------------------------------------
// Function: CLKRHashTable::ReadUnlock
// Synopsis: Unlock all subtables
//------------------------------------------------------------------------

void
CLKRHashTable::ReadUnlock() const
{
    // unlock in reverse order: LIFO
    for (DWORD i = m_cSubTables;  i-- > 0;  )
    {
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
        m_palhtDir[i]->ReadUnlock();
        IRTLASSERT(m_palhtDir[i]->IsReadUnlocked());
    }
} // CLKRHashTable::ReadUnlock



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsWriteLocked
// Synopsis: Are all subtables write-locked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsWriteLocked() const
{
    bool fLocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fLocked = fLocked && m_palhtDir[i]->IsWriteLocked();
    }
    return fLocked;
} // CLKRHashTable::IsWriteLocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsReadLocked
// Synopsis: Are all subtables read-locked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsReadLocked() const
{
    bool fLocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fLocked = fLocked && m_palhtDir[i]->IsReadLocked();
    }
    return fLocked;
} // CLKRHashTable::IsReadLocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsWriteUnlocked
// Synopsis: Are all subtables write-unlocked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsWriteUnlocked() const
{
    bool fUnlocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fUnlocked = fUnlocked && m_palhtDir[i]->IsWriteUnlocked();
    }
    return fUnlocked;
} // CLKRHashTable::IsWriteUnlocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsReadUnlocked
// Synopsis: Are all subtables read-unlocked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsReadUnlocked() const
{
    bool fUnlocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fUnlocked = fUnlocked && m_palhtDir[i]->IsReadUnlocked();
    }
    return fUnlocked;
} // CLKRHashTable::IsReadUnlocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::ConvertSharedToExclusive
// Synopsis: Convert the read lock to a write lock
//------------------------------------------------------------------------

void
CLKRHashTable::ConvertSharedToExclusive()
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->ConvertSharedToExclusive();
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
    }
} // CLKRHashTable::ConvertSharedToExclusive



//------------------------------------------------------------------------
// Function: CLKRHashTable::ConvertExclusiveToShared
// Synopsis: Convert the write lock to a read lock
//------------------------------------------------------------------------

void
CLKRHashTable::ConvertExclusiveToShared() const
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->ConvertExclusiveToShared();
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
    }
} // CLKRHashTable::ConvertExclusiveToShared



//------------------------------------------------------------------------
// Function: CLKRHashTable::Size
// Synopsis: Number of elements in the table
//------------------------------------------------------------------------

DWORD
CLKRHashTable::Size() const
{
    DWORD cSize = 0;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
        cSize += m_palhtDir[i]->Size();

    return cSize;
} // CLKRHashTable::Size



//------------------------------------------------------------------------
// Function: CLKRHashTable::MaxSize
// Synopsis: Maximum possible number of elements in the table
//------------------------------------------------------------------------

DWORD
CLKRHashTable::MaxSize() const
{
    return (m_cSubTables == 0)  ? 0  : m_cSubTables * m_palhtDir[0]->MaxSize();
} // CLKRHashTable::MaxSize



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsValid
// Synopsis: is the table valid?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsValid() const
{
    bool f = (m_lkrcState == LK_SUCCESS     // serious internal failure?
              &&  (m_palhtDir != NULL  &&  m_cSubTables > 0)
              &&  ValidSignature());

    for (DWORD i = 0;  f  &&  i < m_cSubTables;  i++)
        f = f && m_palhtDir[i]->IsValid();

    if (!f)
        m_lkrcState = LK_UNUSABLE;

    return f;
} // CLKRHashTable::IsValid



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRLinearHashTable::SetTableLockSpinCount(
    WORD wSpins)
{
#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    m_Lock.SetSpinCount(wSpins);
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRLinearHashTable::GetTableLockSpinCount() const
{
#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    return m_Lock.GetSpinCount();
#else
    return 0;
#endif
}



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRLinearHashTable::SetBucketLockSpinCount(
    WORD wSpins)
{
    m_wBucketLockSpins = wSpins;

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION
    if (BucketLock::PerLockSpin() != LOCK_INDIVIDUAL_SPIN)
        return;
    
    for (DWORD i = 0;  i < m_cDirSegs;  i++)
    {
        CSegment* pseg = m_paDirSegs[i].m_pseg;

        if (pseg != NULL)
        {
            for (DWORD j = 0;  j < m_dwSegSize;  ++j)
            {
                pseg->Slot(j).SetSpinCount(wSpins);
            }
        }
    }
#endif // LOCK_DEFAULT_SPIN_IMPLEMENTATION
} // CLKRLinearHashTable::SetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRLinearHashTable::GetBucketLockSpinCount() const
{
    return m_wBucketLockSpins;
} // CLKRLinearHashTable::GetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRHashTable::SetTableLockSpinCount(
    WORD wSpins)
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->SetTableLockSpinCount(wSpins);
} // CLKRHashTable::SetTableLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRHashTable::GetTableLockSpinCount() const
{
    return ((m_cSubTables == 0)
            ?  LOCK_DEFAULT_SPINS
            :  m_palhtDir[0]->GetTableLockSpinCount());
} // CLKRHashTable::GetTableLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRHashTable::SetBucketLockSpinCount(
    WORD wSpins)
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->SetBucketLockSpinCount(wSpins);
} // CLKRHashTable::SetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRHashTable::GetBucketLockSpinCount() const
{
    return ((m_cSubTables == 0)
            ?  LOCK_DEFAULT_SPINS
            :  m_palhtDir[0]->GetBucketLockSpinCount());
} // CLKRHashTable::GetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::MultiKeys
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::MultiKeys() const
{
    return ((m_cSubTables == 0)
            ?  false
            :  m_palhtDir[0]->MultiKeys());
} // CLKRHashTable::MultiKeys


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\src\lkr-stl-iter.cpp ===
/*++

   Copyright    (c) 2000    Microsoft Corporation

   Module  Name :
       LKR-stl-iter.cpp

   Abstract:
       Implements STL-style iterators for LKRhash

   Author:
       George V. Reilly      (GeorgeRe)     March 2000

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       March 2000

--*/

#include "precomp.hxx"


#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <lkrhash.h>

#include "i-lkrhash.h"


#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
#else  // __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS
#endif // __LKRHASH_NO_NAMESPACE__


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__

#ifdef LKR_STL_ITERATORS

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Begin
// Synopsis: Make the iterator point to the first record in the hash table.
//------------------------------------------------------------------------

CLKRLinearHashTable::Iterator
CLKRLinearHashTable::Begin()
{
    Iterator iter(this, &_Bucket(0)->m_ncFirst, 0, NODE_BEGIN - NODE_STEP);

    LKR_ITER_TRACE(_TEXT("  LKLH:Begin(it=%p, plht=%p)\n"), &iter, this);
    
    // Let Increment do the hard work of finding the first slot in use.
    iter._Increment(false);

    IRTLASSERT(iter.m_iNode != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(iter == End()  ||  _IsValidIterator(iter));

    return iter;
} // CLKRLinearHashTable::Begin



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable_Iterator::Increment()
// Synopsis: move iterator to next valid record in table
//------------------------------------------------------------------------

bool
CLKRLinearHashTable_Iterator::_Increment(
    bool fDecrementOldValue)
{
    IRTLASSERT(m_plht != NULL);
    IRTLASSERT(m_dwBucketAddr < m_plht->m_cActiveBuckets);
    IRTLASSERT(m_pnc != NULL);
    IRTLASSERT((0 <= m_iNode  &&  m_iNode < NODES_PER_CLUMP)
               || (NODE_BEGIN - NODE_STEP == m_iNode));

    // Release the reference acquired in the previous call to _Increment
    if (fDecrementOldValue)
        _AddRef(LKAR_ITER_RELEASE);

    do
    {
        do
        {
            // find the next slot in the nodeclump that's in use
            while ((m_iNode += NODE_STEP) != NODE_END)
            {
                const void* pvRecord = m_pnc->m_pvNode[m_iNode];

                if (pvRecord != NULL)
                {
                    IRTLASSERT(!m_pnc->InvalidSignature(m_iNode));

                    // Add a new reference
                    _AddRef(LKAR_ITER_ACQUIRE);

                    LKR_ITER_TRACE(_TEXT("  LKLH:++(this=%p, plht=%p, NC=%p, ")
                                   _TEXT("BA=%u, IN=%d, Rec=%p)\n"),
                                   this, m_plht, m_pnc,
                                   m_dwBucketAddr, m_iNode, pvRecord);

                    return true;
                }
                else // pvRecord == NULL
                {
#if 0 //// #ifdef IRTLDEBUG
                    // Check that all the remaining nodes are empty
                    IRTLASSERT(m_pnc->IsLastClump());

                    for (int i = m_iNode;  i != NODE_END;  i += NODE_STEP)
                    {
                        IRTLASSERT(m_pnc->IsEmptyAndInvalid(i));
                    }
#endif // IRTLDEBUG
                    break; // rest of nodeclump is empty
                }
            }

            // try the next nodeclump in the bucket chain
            m_iNode = NODE_BEGIN - NODE_STEP;
            m_pnc = m_pnc->m_pncNext;

        } while (m_pnc != NULL);

        // Try the next bucket, if there is one
        if (++m_dwBucketAddr < m_plht->m_cActiveBuckets)
        {
            CBucket* pbkt = m_plht->_Bucket(m_dwBucketAddr);
            IRTLASSERT(pbkt != NULL);
            m_pnc = &pbkt->m_ncFirst;
        }

    } while (m_dwBucketAddr < m_plht->m_cActiveBuckets);

    // We have fallen off the end of the hashtable. Set iterator equal
    // to end(), the empty iterator.
    LKR_ITER_TRACE(_TEXT("  LKLH:End(this=%p, plht=%p)\n"), this, m_plht);

    m_plht = NULL;
    m_pnc = NULL;
    m_dwBucketAddr = 0;
    m_iNode = 0;

    //// IRTLASSERT(this->operator==(Iterator())); // == end()

    return false;
} // CLKRLinearHashTable_Iterator::_Increment()



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Insert
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Insert(
    const void* pvRecord,
    Iterator&   riterResult,
    bool        fOverwrite /* = false */)
{
    riterResult = End();

    if (!IsUsable()  ||  pvRecord == NULL)
        return false;
    
    bool fSuccess = (_InsertRecord(pvRecord,
                                  _CalcKeyHash(_ExtractKey(pvRecord)),
                                  fOverwrite,
                                  &riterResult)
                     == LK_SUCCESS);

    IRTLASSERT(riterResult.m_iNode != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(fSuccess
               ?  _IsValidIterator(riterResult)
               :  riterResult == End());

    return fSuccess;
} // CLKRLinearHashTable::Insert()



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Erase
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_Erase(
    Iterator& riter,
    DWORD     dwSignature)
{
    CNodeClump* pncCurr, *pncPrev;
    CBucket* const pbkt = riter.m_plht->_Bucket(riter.m_dwBucketAddr);

    LKR_ITER_TRACE(_TEXT("  LKLH:_Erase:pre(iter=%p, plht=%p, NC=%p, ")
                   _TEXT("BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_plht, riter.m_pnc,
                   riter.m_dwBucketAddr, riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL);

    pbkt->WriteLock();

    for (pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        if (pncCurr == riter.m_pnc)
            break;
    }
    IRTLASSERT(pncCurr != NULL);

    // Release the iterator's reference on the record
    const void* pvRecord = riter.m_pnc->m_pvNode[riter.m_iNode];
    IRTLASSERT(pvRecord != NULL);
    _AddRefRecord(pvRecord, LKAR_ITER_ERASE);

    // _DeleteNode will leave iterator members pointing to the
    // preceding record
    int iNode = riter.m_iNode;
    IRTLVERIFY(_DeleteNode(pbkt, riter.m_pnc, pncPrev, iNode,
                           LKAR_ITER_ERASE_TABLE));

    if (iNode == NODE_END)
        LKR_ITER_TRACE(_TEXT("\t_Erase(Bkt=%p, pnc=%p, Prev=%p, iNode=%d)\n"),
                       pbkt, riter.m_pnc, pncPrev, iNode);
                  
    riter.m_iNode = (iNode == NODE_END)  ? NODE_END-NODE_STEP  : (short) iNode;

    pbkt->WriteUnlock();

    // Don't contract the table. Likely to invalidate the iterator,
    // if iterator is being used in a loop

    return true;
} // CLKRLinearHashTable::_Erase()



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Erase
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Erase(
    Iterator& riter)
{
    if (!IsUsable()  ||  !_IsValidIterator(riter))
        return false;
    
    DWORD dwSignature = _CalcKeyHash(_ExtractKey(riter.Record()));
    
    LKR_ITER_TRACE(_TEXT("  LKLH:Erase:pre(iter=%p, plht=%p, NC=%p, BA=%u, ")
                   _TEXT("IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_plht, riter.m_pnc, riter.m_dwBucketAddr,
                   riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL);
    
    bool fSuccess = _Erase(riter, dwSignature);
    bool fIncrement = false;
    
    LKR_ITER_TRACE(_TEXT("  LKLH:Erase:post(iter=%p, plht=%p, NC=%p, BA=%u, ")
                   _TEXT("IN=%d, Sig=%x, Rec=%p, Success=%s)\n"),
                   &riter, riter.m_plht, riter.m_pnc, riter.m_dwBucketAddr,
                   riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL,
                   (fSuccess ? "true" : "false"));
    
    // _Erase left riter pointing to the preceding record.
    // Move to next record.
    if (fSuccess)
        fIncrement = riter._Increment(false);

    IRTLASSERT(riter.m_iNode != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(fIncrement  ?  _IsValidIterator(riter)  :  riter == End());
    
    LKR_ITER_TRACE(_TEXT("  LKLH:Erase:post++(iter=%p, plht=%p, NC=%p, ")
                   _TEXT("BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_plht, riter.m_pnc,
                   riter.m_dwBucketAddr, riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL);
    
    return fSuccess;
} // CLKRLinearHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Erase
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Erase(
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT(" LKHT:Erase2(%p, %p)\n"), &riterFirst, &riterLast);

    bool fSuccess;
    int cRecords = 0;

    do
    {
        LKR_ITER_TRACE(_TEXT("\n  LKLH:Erase2(%d, %p)\n"),
                       ++cRecords, &riterFirst);
        fSuccess = Erase(riterFirst);
    } while (fSuccess  &&  riterFirst != End()  &&  riterFirst != riterLast);

    LKR_ITER_TRACE(_TEXT("  LKLH:Erase2: fSuccess = %s\n"),
                   (fSuccess ? "true" : "false"));

    return fSuccess;
} // CLKRLinearHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Find
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Find(
    DWORD_PTR pnKey,
    Iterator& riterResult)
{
    riterResult = End();

    if (!IsUsable())
        return false;
    
    const void* pvRecord = NULL;
    DWORD       hash_val = _CalcKeyHash(pnKey);
    bool        fFound   = (_FindKey(pnKey, hash_val, &pvRecord, &riterResult)
                            == LK_SUCCESS);

    IRTLASSERT(fFound
               ?  _IsValidIterator(riterResult)  &&  riterResult.Key() == pnKey
               :  riterResult == End());
    IRTLASSERT(riterResult.m_iNode != NODE_BEGIN - NODE_STEP);

    return fFound;
} // CLKRLinearHashTable::Find



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::EqualRange
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::EqualRange(
    DWORD_PTR pnKey,
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT("  LKLH:EqualRange: Key=%p)\n"), (void*) pnKey);

    riterLast = End();

    bool fFound = Find(pnKey, riterFirst);

    if (fFound)
    {
        riterLast = riterFirst;
        IRTLASSERT(riterLast != End());

        do
        {
            riterLast._Increment();
        } while (riterLast != End()  &&  riterLast.Key() == pnKey);
    }

    IRTLASSERT(riterFirst.m_iNode != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(fFound ?  _IsValidIterator(riterFirst) :  riterFirst == End());

    IRTLASSERT(riterLast.m_iNode  != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(fFound  ||  riterLast == End());

    return fFound;
} // CLKRLinearHashTable::EqualRange



//------------------------------------------------------------------------
// Function: CLKRHashTable::Begin
// Synopsis: Make the iterator point to the first record in the hash table.
//------------------------------------------------------------------------

CLKRHashTable::Iterator
CLKRHashTable::Begin()
{
    Iterator iter(this, -1);

    LKR_ITER_TRACE(_TEXT(" LKHT:Begin(it=%p, pht=%p)\n"), &iter, this);

    // Let Increment do the hard work of finding the first slot in use.
    iter._Increment(false);

    IRTLASSERT(iter.m_ist != -1);
    IRTLASSERT(iter == End()  ||  _IsValidIterator(iter));

    return iter;
} // CLKRHashTable::Begin



//------------------------------------------------------------------------
// Function: CLKRHashTable_Iterator::_Increment()
// Synopsis: move iterator to next valid record in table
//------------------------------------------------------------------------

bool
CLKRHashTable_Iterator::_Increment(
    bool fDecrementOldValue)
{
    IRTLASSERT(m_pht != NULL);
    IRTLASSERT(-1 <= m_ist
               &&  m_ist < static_cast<int>(m_pht->m_cSubTables));

    for (;;)
    {
        // Do we have a valid iterator into a subtable?  If not, get one.
        while (m_subiter.m_plht == NULL)
        {
            while (++m_ist < static_cast<int>(m_pht->m_cSubTables))
            {
                LKR_ITER_TRACE(_TEXT(" LKHT:++IST=%d\n"), m_ist);
                m_subiter = m_pht->m_palhtDir[m_ist]->Begin();

                if (m_subiter.m_plht != NULL)
                {
                    LKR_ITER_TRACE(_TEXT(" LKHT:++(this=%p, pht=%p, IST=%d, ")
                                   _TEXT("LHT=%p, NC=%p, ")
                                   _TEXT("BA=%u, IN=%d, Rec=%p)\n"),
                                   this, m_pht, m_ist,
                                   m_subiter.m_plht, m_subiter.m_pnc,
                                   m_subiter.m_dwBucketAddr, m_subiter.m_iNode,
                                   m_subiter.m_pnc->m_pvNode[m_subiter.m_iNode]
                                  );
                    return true;
                }
            }
            
            // There are no more subtables left.
            LKR_ITER_TRACE(_TEXT(" LKHT:End(this=%p, pht=%p)\n"), this, m_pht);

            m_pht = NULL;
            m_ist = 0;

            //// IRTLASSERT(this->operator==(Iterator())); // == end()
            
            return false;
        }

        // We already have a valid iterator into a subtable.  Increment it.
        m_subiter._Increment(fDecrementOldValue);

        if (m_subiter.m_plht != NULL)
        {
            LKR_ITER_TRACE(_TEXT(" LKHT:++(this=%p, pht=%p, IST=%d, ")
                           _TEXT("LHT=%p, NC=%p, BA=%u, IN=%d, Rec=%p)\n"),
                           this, m_pht, m_ist,
                           m_subiter.m_plht, m_subiter.m_pnc,
                           m_subiter.m_dwBucketAddr, m_subiter.m_iNode, 
                           m_subiter.m_pnc->m_pvNode[m_subiter.m_iNode]);
            return true;
        }
    }
} // CLKRHashTable_Iterator::_Increment()



//------------------------------------------------------------------------
// Function: CLKRHashTable::Insert
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRHashTable::Insert(
    const void* pvRecord,
    Iterator&   riterResult,
    bool        fOverwrite)
{
    riterResult = End();

    if (!IsUsable()  ||  pvRecord == NULL)
        return false;
    
    DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst = _SubTable(hash_val);

    bool f = (pst->_InsertRecord(pvRecord, hash_val, fOverwrite,
                                 &riterResult.m_subiter)
              == LK_SUCCESS);

    if (f)
    {
        riterResult.m_pht = this;
        riterResult.m_ist = (short) _SubTableIndex(pst);
    }

    IRTLASSERT(riterResult.m_ist != -1);
    IRTLASSERT(f  ?  _IsValidIterator(riterResult)  :  riterResult == End());

    return f;
} // CLKRHashTable::Insert



//------------------------------------------------------------------------
// Function: CLKRHashTable::Erase
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRHashTable::Erase(
    Iterator& riter)
{
    if (!IsUsable()  ||  !_IsValidIterator(riter))
        return false;
    
    DWORD     dwSignature = _CalcKeyHash(_ExtractKey(riter.Record()));
    SubTable* const pst   = _SubTable(dwSignature);

    IRTLASSERT(pst == riter.m_subiter.m_plht);

    if (pst != riter.m_subiter.m_plht)
        return false;

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase:pre(iter=%p, pht=%p, ist=%d, plht=%p, ")
                   _TEXT("NC=%p, BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_pht, riter.m_ist,
                   riter.m_subiter.m_plht, riter.m_subiter.m_pnc,
                   riter.m_subiter.m_dwBucketAddr, riter.m_subiter.m_iNode,
                   dwSignature,
                   (riter.m_subiter.m_pnc ? riter.Record() : NULL));

    // _Erase left riter pointing to the preceding record. Move to
    // next record.
    bool fSuccess = pst->_Erase(riter.m_subiter, dwSignature);
    bool fIncrement = false;

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase:post(iter=%p, pht=%p, ist=%d, plht=%p, ")
                   _TEXT("NC=%p, BA=%u, IN=%d, Sig=%x, Rec=%p, Success=%s)\n"),
                   &riter, riter.m_pht, riter.m_ist,
                   riter.m_subiter.m_plht, riter.m_subiter.m_pnc,
                   riter.m_subiter.m_dwBucketAddr, riter.m_subiter.m_iNode,
                   dwSignature,
                   ((riter.m_subiter.m_pnc && riter.m_subiter.m_iNode >= 0)
                        ? riter.Record() : NULL),
                   (fSuccess ? "true" : "false"));

    if (fSuccess)
        fIncrement = riter._Increment(false);

    IRTLASSERT(riter.m_ist != -1);
    IRTLASSERT(fIncrement  ?  _IsValidIterator(riter)  :  riter  == End());

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase:post++(iter=%p, pht=%p, ist=%d, ")
                   _TEXT("plht=%p, NC=%p, ")
                   _TEXT("BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_pht, riter.m_ist,
                   riter.m_subiter.m_plht, riter.m_subiter.m_pnc,
                   riter.m_subiter.m_dwBucketAddr, riter.m_subiter.m_iNode,
                   dwSignature,
                   (riter.m_subiter.m_pnc ? riter.Record() : NULL));

    return fSuccess;
} // CLKRHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRHashTable::Erase
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::Erase(
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT(" LKHT:Erase2(%p, %p)\n"), &riterFirst, &riterLast);

    bool fSuccess;
    int cRecords = 0;

    do
    {
        LKR_ITER_TRACE(_TEXT("\n LKHT:Erase2(%d, %p)\n"),
                       ++cRecords, &riterFirst);
        fSuccess = Erase(riterFirst);
    } while (fSuccess  &&  riterFirst != End()  &&  riterFirst != riterLast);

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase2: fSuccess = %s\n"),
                   (fSuccess ? "true" : "false"));

    return fSuccess;
} // CLKRHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRHashTable::Find
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::Find(
    DWORD_PTR pnKey,
    Iterator& riterResult)
{
    riterResult = End();

    if (!IsUsable())
        return false;
    
    const void* pvRecord = NULL;
    DWORD       hash_val = _CalcKeyHash(pnKey);
    SubTable* const pst  = _SubTable(hash_val);
    bool        fFound   = (pst->_FindKey(pnKey, hash_val, &pvRecord,
                                          &riterResult.m_subiter)
                            == LK_SUCCESS);
    if (fFound)
    {
        riterResult.m_pht = this;
        riterResult.m_ist = (short) _SubTableIndex(pst);
    }

    IRTLASSERT(riterResult.m_ist != -1);
    IRTLASSERT(fFound
               ?  _IsValidIterator(riterResult)  &&  riterResult.Key() == pnKey
               :  riterResult == End());

    return fFound;
} // CLKRHashTable::Find



//------------------------------------------------------------------------
// Function: CLKRHashTable::EqualRange
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::EqualRange(
    DWORD_PTR pnKey,
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT(" LKHT:EqualRange: Key=%p)\n"), (void*) pnKey);

    riterLast = End();

    bool fFound = Find(pnKey, riterFirst);

    if (fFound)
    {
        riterLast = riterFirst;
        IRTLASSERT(riterLast != End());

        do
        {
            riterLast._Increment();
        } while (riterLast != End()  &&  riterLast.Key() == pnKey);
    }

    IRTLASSERT(riterFirst.m_ist != -1);
    IRTLASSERT(fFound ? _IsValidIterator(riterFirst) : riterFirst == End());

    IRTLASSERT(riterLast.m_ist != -1);
    IRTLASSERT(fFound  ||  riterLast == End());

    return fFound;
} // CLKRHashTable::EqualRange


#endif // LKR_STL_ITERATORS


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\src\lkr-old-iter.cpp ===
/*++

   Copyright    (c) 1998-2000    Microsoft Corporation

   Module  Name :
       LKRhash.cpp

   Abstract:
       Implements the old, deprecated iterators for LKRhash.
       Use the STL-style iterators instead.

   Author:
       George V. Reilly      (GeorgeRe)     1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#include "precomp.hxx"


#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <lkrhash.h>

#include "i-lkrhash.h"


#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
#else  // __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS
#endif // __LKRHASH_NO_NAMESPACE__


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__

#ifdef LKR_DEPRECATED_ITERATORS

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_InitializeIterator
// Synopsis: Make the iterator point to the first record in the hash table.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_InitializeIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    if (piter == NULL  ||  piter->m_plht != NULL)
        return LK_BAD_ITERATOR;

    piter->m_plht = this;
    piter->m_dwBucketAddr = 0;

    CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
    IRTLASSERT(pbkt != NULL);
    if (piter->m_lkl == LKL_WRITELOCK)
        pbkt->WriteLock();
    else
        pbkt->ReadLock();

    piter->m_pnc = &pbkt->m_ncFirst;
    piter->m_iNode = NODE_BEGIN - NODE_STEP;

    // Let IncrementIterator do the hard work of finding the first
    // slot in use.
    return IncrementIterator(piter);
} // CLKRLinearHashTable::_InitializeIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::InitializeIterator
// Synopsis: make the iterator point to the first record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::InitializeIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
    if (piter == NULL  ||  piter->m_pht != NULL)
        return LK_BAD_ITERATOR;

    // First, lock all the subtables
    if (piter->m_lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());
    if (!IsValid())
        return LK_UNUSABLE;

    piter->m_pht  = this;
    piter->m_ist  = -1;
    piter->m_plht = NULL;

    // Let IncrementIterator do the hard work of finding the first
    // valid node in the subtables.
    return IncrementIterator(piter);
} // CLKRHashTable::InitializeIterator



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::IncrementIterator
// Synopsis: move the iterator on to the next record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::IncrementIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_plht == this);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    IRTLASSERT(piter->m_dwBucketAddr < m_cActiveBuckets);
    IRTLASSERT(piter->m_pnc != NULL);
    IRTLASSERT((0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
               || (NODE_BEGIN - NODE_STEP == piter->m_iNode));

    if (piter == NULL  ||  piter->m_plht != this)
        return LK_BAD_ITERATOR;

    const void* pvRecord = NULL;

    if (piter->m_iNode != NODE_BEGIN - NODE_STEP)
    {
        // Release the reference acquired in the previous call to
        // IncrementIterator
        pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
        _AddRefRecord(pvRecord, LKAR_ITER_RELEASE);
    }

    do
    {
        do
        {
            // find the next slot in the nodeclump that's in use
            while ((piter->m_iNode += NODE_STEP) != NODE_END)
            {
                pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
                if (pvRecord != NULL)
                {
                    // Add a new reference
                    _AddRefRecord(pvRecord, LKAR_ITER_ACQUIRE);
                    return LK_SUCCESS;
                }
                else // pvRecord == NULL
                {
#ifdef IRTLDEBUG
                    // Check that all the remaining nodes are empty
                    IRTLASSERT(piter->m_pnc->IsLastClump());
                    for (int i = piter->m_iNode;
                         i != NODE_END;
                         i += NODE_STEP)
                    {
                        IRTLASSERT(piter->m_pnc->IsEmptyAndInvalid(i));
                    }
#endif // IRTLDEBUG
                    break; // rest of nodeclump is empty
                }
            }

            // try the next nodeclump in the bucket chain
            piter->m_iNode = NODE_BEGIN - NODE_STEP;
            piter->m_pnc = piter->m_pnc->m_pncNext;
        } while (piter->m_pnc != NULL);

        // Exhausted this bucket chain.  Unlock it.
        CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
        IRTLASSERT(pbkt != NULL);
        IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
                   ?  pbkt->IsWriteLocked()
                   :  pbkt->IsReadLocked());
        if (piter->m_lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();

        // Try the next bucket, if there is one
        if (++piter->m_dwBucketAddr < m_cActiveBuckets)
        {
            pbkt = _Bucket(piter->m_dwBucketAddr);
            IRTLASSERT(pbkt != NULL);
            if (piter->m_lkl == LKL_WRITELOCK)
                pbkt->WriteLock();
            else
                pbkt->ReadLock();
            piter->m_pnc = &pbkt->m_ncFirst;
        }
    } while (piter->m_dwBucketAddr < m_cActiveBuckets);

    // We have fallen off the end of the hashtable
    piter->m_iNode = NODE_BEGIN - NODE_STEP;
    piter->m_pnc = NULL;

    return LK_NO_MORE_ELEMENTS;
} // CLKRLinearHashTable::IncrementIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::IncrementIterator
// Synopsis: move the iterator on to the next record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::IncrementIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_pht == this);
    IRTLASSERT(-1 <= piter->m_ist
               &&  piter->m_ist < static_cast<int>(m_cSubTables));

    if (piter == NULL  ||  piter->m_pht != this)
        return LK_BAD_ITERATOR;

    // Table is already locked
    if (!IsValid())
        return LK_UNUSABLE;

    LK_RETCODE lkrc;
    CLHTIterator* pBaseIter = static_cast<CLHTIterator*>(piter);

    for (;;)
    {
        // Do we have a valid iterator into a subtable?  If not, get one.
        while (piter->m_plht == NULL)
        {
            while (++piter->m_ist < static_cast<int>(m_cSubTables))
            {
                lkrc = m_palhtDir[piter->m_ist]->_InitializeIterator(piter);
                if (lkrc == LK_SUCCESS)
                {
                    IRTLASSERT(m_palhtDir[piter->m_ist] == piter->m_plht);
                    return lkrc;
                }
                else if (lkrc == LK_NO_MORE_ELEMENTS)
                    lkrc = piter->m_plht->_CloseIterator(pBaseIter);

                if (lkrc != LK_SUCCESS)
                    return lkrc;
            }

            // There are no more subtables left.
            return LK_NO_MORE_ELEMENTS;
        }

        // We already have a valid iterator into a subtable.  Increment it.
        lkrc = piter->m_plht->IncrementIterator(pBaseIter);
        if (lkrc == LK_SUCCESS)
            return lkrc;

        // We've exhausted that subtable.  Move on.
        if (lkrc == LK_NO_MORE_ELEMENTS)
            lkrc = piter->m_plht->_CloseIterator(pBaseIter);

        if (lkrc != LK_SUCCESS)
            return lkrc;
    }
} // CLKRHashTable::IncrementIterator



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_CloseIterator
// Synopsis: release the resources held by the iterator
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_CloseIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_plht == this);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    IRTLASSERT(piter->m_dwBucketAddr <= m_cActiveBuckets);
    IRTLASSERT((0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
               || (NODE_BEGIN - NODE_STEP == piter->m_iNode));

    if (piter == NULL  ||  piter->m_plht != this)
        return LK_BAD_ITERATOR;

    // Are we abandoning the iterator before the end of the table?
    // If so, need to unlock the bucket.
    if (piter->m_dwBucketAddr < m_cActiveBuckets)
    {
        CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
        IRTLASSERT(pbkt != NULL);
        IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
                   ?  pbkt->IsWriteLocked()
                   :  pbkt->IsReadLocked());
        if (0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
        {
            IRTLASSERT(piter->m_pnc != NULL);
            const void* pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
            _AddRefRecord(pvRecord, LKAR_ITER_CLOSE);
        }
        if (piter->m_lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();
    }

    piter->m_plht = NULL;
    piter->m_pnc  = NULL;

    return LK_SUCCESS;
} // CLKRLinearHashTable::_CloseIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::CloseIterator
// Synopsis: release the resources held by the iterator
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::CloseIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_pht == this);
    IRTLASSERT(-1 <= piter->m_ist
               &&  piter->m_ist <= static_cast<int>(m_cSubTables));

    if (piter == NULL  ||  piter->m_pht != this)
        return LK_BAD_ITERATOR;

    LK_RETCODE lkrc = LK_SUCCESS;

    if (!IsValid())
        lkrc = LK_UNUSABLE;
    else
    {
        // Are we abandoning the iterator before we've reached the end?
        // If so, close the subtable iterator.
        if (piter->m_plht != NULL)
        {
            IRTLASSERT(piter->m_ist < static_cast<int>(m_cSubTables));
            CLHTIterator* pBaseIter = static_cast<CLHTIterator*>(piter);
            piter->m_plht->_CloseIterator(pBaseIter);
        }
    }

    // Unlock all the subtables
    if (piter->m_lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    piter->m_plht = NULL;
    piter->m_pht  = NULL;
    piter->m_ist  = -1;

    return lkrc;
} // CLKRHashTable::CloseIterator

#endif // LKR_DEPRECATED_ITERATORS


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\src\locks.cpp ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       Locks.cpp

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT

#define LOCK_ATOMIC_INLINES
#include <Locks.h>
#include "i-Locks.h"


#ifdef _M_IX86
// # define LOCK_NAKED  __declspec(naked)
# define LOCK_NAKED
# define LOCK_FASTCALL __fastcall
// # define LOCK_FASTCALL
// The compiler will warn that the assembly language versions of the
// Lock_Atomic* functions don't return a value. Actually, they do: in EAX.
# pragma warning(disable: 4035)
#else // !_M_IX86
# define LOCK_NAKED
# define LOCK_FASTCALL
#endif // _M_IX86


// Workarounds for certain useful interlocked operations that are not
// available on Windows 95. Note: the CMPXCHG and XADD instructions were
// introduced in the 80486. If you still need to run on a i386 (unlikely
// in 2000), you'll need to use something else.


// Lock_AtomicIncrement is equivalent to
//      LONG lNew = +1 + *plAddend;
//      *plAddend = lNew;
// except it's one atomic operation
LOCK_NAKED
LOCK_FORCEINLINE
void
LOCK_FASTCALL
Lock_AtomicIncrement(
    IN OUT PLONG plAddend)
#ifdef LOCK_ATOMIC_INLINES
{
#ifdef _M_IX86
// ecx = plAddend
    __asm
    {
;            mov        ecx,    plAddend
             mov        eax,    1
        lock xadd       [ecx],  eax
;            inc        eax                 // correct result
    }
#else
    ::InterlockedIncrement(plAddend);
#endif
}
#else // !LOCK_ATOMIC_INLINES
;
#endif // !LOCK_ATOMIC_INLINES


// Lock_AtomicDecrement is equivalent to
//      LONG lNew = -1 + *plAddend;
//      *plAddend = lNew;
// except it's one atomic operation
LOCK_NAKED
LOCK_FORCEINLINE
void
LOCK_FASTCALL
Lock_AtomicDecrement(
    IN OUT PLONG plAddend)
#ifdef LOCK_ATOMIC_INLINES
{
#ifdef _M_IX86
// ecx = plAddend
    __asm
    {
;            mov        ecx,    plAddend
             mov        eax,    -1
        lock xadd       [ecx],  eax
;            dec        eax                 // correct result
    }
#else
    ::InterlockedDecrement(plAddend);
#endif
}
#else // !LOCK_ATOMIC_INLINES
;
#endif // !LOCK_ATOMIC_INLINES


// Lock_AtomicExchange is equivalent to
//      LONG lOld = *plAddr;
//      *plAddr = lNew;
//      return lOld;
// except it's one atomic operation
LOCK_NAKED
LOCK_FORCEINLINE
LONG
LOCK_FASTCALL
Lock_AtomicExchange(
    IN OUT PLONG plAddr,
    IN LONG      lNew)
#ifdef LOCK_ATOMIC_INLINES
{
#ifdef _M_IX86
// ecx = plAddr, edx = lNew
    __asm
    {
;            mov        ecx,    plAddr
;            mov        edx,    lNew
;            mov        eax,    [ecx]
;   LAEloop:
;       lock cmpxchg    [ecx],  edx
;            jnz        LAEloop

        lock xchg       [ecx],  edx
             mov        eax,    edx
    }
#else
    return ::InterlockedExchange(plAddr, lNew);
#endif
}
#else // !LOCK_ATOMIC_INLINES
;
#endif // !LOCK_ATOMIC_INLINES


// Lock_AtomicCompareAndSwap is equivalent to
//      if (*plAddr == lCurrent)
//          *plAddr = lNew;
//          return true;
//      else
//          return false;
// except it's one atomic operation
LOCK_NAKED
LOCK_FORCEINLINE
bool
LOCK_FASTCALL
Lock_AtomicCompareAndSwap(
    IN OUT PLONG plAddr,
    IN LONG      lNew,
    IN LONG      lCurrent)
#ifdef LOCK_ATOMIC_INLINES
{
#ifdef _M_IX86
// ecx = plAddr, edx = lNew
    __asm
    {
;            mov        ecx,    plAddr
;            mov        edx,    lNew
;            mov        eax,    lCurrent

             mov        eax,    lCurrent
        lock cmpxchg    [ecx],  edx
             sete       al          // eax==1 => successfully swapped; else =0
    }
#elif defined(UNDER_CE)
    return ::InterlockedTestExchange(plAddr, lCurrent, lNew) == lCurrent;
#else
    return ::InterlockedCompareExchange(plAddr, lNew, lCurrent) == lCurrent;
#endif
}
#else // !LOCK_ATOMIC_INLINES
;
#endif // !LOCK_ATOMIC_INLINES


LOCK_FORCEINLINE
LONG
LOCK_FASTCALL
Lock_GetCurrentThreadId()
#ifdef LOCK_ATOMIC_INLINES
{
#if defined(_M_IX86) && !defined(LOCKS_KERNEL_MODE)
    const unsigned int PcTeb = 0x18;
    const unsigned int IDTeb = 0x24;
    
    __asm
    {
        mov		eax,fs:[PcTeb]				// Load TEB base address.
        mov		eax,dword ptr[eax+IDTeb]	// Load thread ID.
    }
#else // !_M_IX86 || LOCKS_KERNEL_MODE
 #ifdef LOCKS_KERNEL_MODE
    return (DWORD) HandleToULong(::PsGetCurrentThreadId());
 #else // !LOCKS_KERNEL_MODE
    return ::GetCurrentThreadId();
 #endif // !LOCKS_KERNEL_MODE
#endif
}
#else // !LOCK_ATOMIC_INLINES
;
#endif // !LOCK_ATOMIC_INLINES


#ifdef _M_IX86
# pragma warning(default: 4035)
// Makes tight loops a little more cache friendly and reduces power
// consumption. Needed on Willamette (Pentium 4) processors.
# define Lock_Yield()    __asm { rep nop }
#else
# define Lock_Yield()    ((void) 0)
#endif


//------------------------------------------------------------------------
// Not all Win32 platforms support all the functions we want. Set up dummy
// thunks and use GetProcAddress to find their addresses at runtime.

#ifndef LOCKS_KERNEL_MODE

typedef
BOOL
(WINAPI * PFN_SWITCH_TO_THREAD)(
    VOID
    );

static BOOL WINAPI
FakeSwitchToThread(
    VOID)
{
    return FALSE;
}

PFN_SWITCH_TO_THREAD  g_pfnSwitchToThread = NULL;


typedef
BOOL
(WINAPI * PFN_TRY_ENTER_CRITICAL_SECTION)(
    IN OUT LPCRITICAL_SECTION lpCriticalSection
    );

static BOOL WINAPI
FakeTryEnterCriticalSection(
    LPCRITICAL_SECTION /*lpCriticalSection*/)
{
    return FALSE;
}

PFN_TRY_ENTER_CRITICAL_SECTION g_pfnTryEnterCritSec = NULL;


typedef
DWORD
(WINAPI * PFN_SET_CRITICAL_SECTION_SPIN_COUNT)(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   );

static DWORD WINAPI
FakeSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION /*lpCriticalSection*/,
    DWORD              /*dwSpinCount*/)
{
    // For faked critical sections, the previous spin count is just ZERO!
    return 0;
}

PFN_SET_CRITICAL_SECTION_SPIN_COUNT  g_pfnSetCSSpinCount = NULL;

#else  // LOCKS_KERNEL_MODE

// ZwYieldExecution is the actual kernel-mode implementation of SwitchToThread.
extern "C"
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwYieldExecution (
    VOID
    );

#endif // LOCKS_KERNEL_MODE



DWORD g_cProcessors = 0;
BOOL  g_fLocksInitialized = FALSE;



BOOL
Locks_Initialize()
{
    if (!g_fLocksInitialized)
    {
        static LONG s_nLock = 0;

        while (Lock_AtomicExchange(&s_nLock, 1) != 0)
        {
#ifdef LOCKS_KERNEL_MODE
            ZwYieldExecution();
#else // !LOCKS_KERNEL_MODE
            Sleep(0);
#endif // !LOCKS_KERNEL_MODE
        }
    
        if (!g_fLocksInitialized)
        {
#if defined(LOCKS_KERNEL_MODE)

            g_cProcessors = KeNumberProcessors;

#else  // !LOCKS_KERNEL_MODE

# if !defined(UNDER_CE)
            // load kernel32 and get NT-specific entry points
            HMODULE hKernel32 = GetModuleHandle(TEXT("kernel32.dll"));

            if (hKernel32 != NULL)
            {
                g_pfnSwitchToThread = (PFN_SWITCH_TO_THREAD)
                    GetProcAddress(hKernel32, "SwitchToThread");
                
                g_pfnTryEnterCritSec = (PFN_TRY_ENTER_CRITICAL_SECTION)
                    GetProcAddress(hKernel32, "TryEnterCriticalSection");
                
                g_pfnSetCSSpinCount = (PFN_SET_CRITICAL_SECTION_SPIN_COUNT)
                    GetProcAddress(hKernel32, "SetCriticalSectionSpinCount");
            }
# endif // !UNDER_CE
            
            if (g_pfnSwitchToThread == NULL)
                g_pfnSwitchToThread = FakeSwitchToThread;
            
            if (g_pfnTryEnterCritSec == NULL)
                g_pfnTryEnterCritSec = FakeTryEnterCriticalSection;
            
            if (g_pfnSetCSSpinCount == NULL)
                g_pfnSetCSSpinCount = FakeSetCriticalSectionSpinCount;

            SYSTEM_INFO si;

            GetSystemInfo(&si);
            g_cProcessors = si.dwNumberOfProcessors;
            
#endif // !LOCKS_KERNEL_MODE

            IRTLASSERT(g_cProcessors > 0);

            Lock_AtomicExchange((LONG*) &g_fLocksInitialized, TRUE);
        }
        
        Lock_AtomicExchange(&s_nLock, 0);
    }

    return TRUE;
}


BOOL
Locks_Cleanup()
{
    return TRUE;
}



#ifdef __LOCKS_NAMESPACE__
namespace Locks {
#endif // __LOCKS_NAMESPACE__

#ifdef LOCK_DEFAULT_SPIN_IMPLEMENTATION

 #define LOCK_DEFAULT_SPIN_DATA(CLASS)                      \
  WORD   CLASS::sm_wDefaultSpinCount  = LOCK_DEFAULT_SPINS; \
  double CLASS::sm_dblDfltSpinAdjFctr = 0.5

 #define DefaultSpinCount()     sm_wDefaultSpinCount
 #define AdjustBySpinFactor(x)  (int) ((x) * sm_dblDfltSpinAdjFctr)

#else  // !LOCK_DEFAULT_SPIN_IMPLEMENTATION

 #define LOCK_DEFAULT_SPIN_DATA(CLASS)
 #define DefaultSpinCount()     LOCK_DEFAULT_SPINS
 #define AdjustBySpinFactor(x)  ((x) >> 1)

#endif  // !LOCK_DEFAULT_SPIN_IMPLEMENTATION


#ifdef LOCK_INSTRUMENTATION

# define LOCK_STATISTICS_DATA(CLASS)            \
LONG        CLASS::sm_cTotalLocks       = 0;    \
LONG        CLASS::sm_cContendedLocks   = 0;    \
LONG        CLASS::sm_nSleeps           = 0;    \
LONGLONG    CLASS::sm_cTotalSpins       = 0;    \
LONG        CLASS::sm_nReadLocks        = 0;    \
LONG        CLASS::sm_nWriteLocks       = 0


# define LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CLASS)            \
CLockStatistics                 CLASS::Statistics() const       \
{return CLockStatistics();}                                     \
CGlobalLockStatistics           CLASS::GlobalStatistics()       \
{return CGlobalLockStatistics();}                               \
void                            CLASS::ResetGlobalStatistics()  \
{}


# define LOCK_STATISTICS_REAL_IMPLEMENTATION(CLASS)             \
                                                                \
/* Per-lock statistics */                                       \
CLockStatistics                                                 \
CLASS::Statistics() const                                       \
{                                                               \
    CLockStatistics ls;                                         \
                                                                \
    ls.m_nContentions     = m_nContentions;                     \
    ls.m_nSleeps          = m_nSleeps;                          \
    ls.m_nContentionSpins = m_nContentionSpins;                 \
    if (m_nContentions > 0)                                     \
        ls.m_nAverageSpins = m_nContentionSpins / m_nContentions;\
    else                                                        \
        ls.m_nAverageSpins = 0;                                 \
    ls.m_nReadLocks       = m_nReadLocks;                       \
    ls.m_nWriteLocks      = m_nWriteLocks;                      \
    _tcscpy(ls.m_tszName, m_tszName);                           \
                                                                \
    return ls;                                                  \
}                                                               \
                                                                \
                                                                \
/* Global statistics for CLASS */                               \
CGlobalLockStatistics                                           \
CLASS::GlobalStatistics()                                       \
{                                                               \
    CGlobalLockStatistics gls;                                  \
                                                                \
    gls.m_cTotalLocks      = sm_cTotalLocks;                    \
    gls.m_cContendedLocks  = sm_cContendedLocks;                \
    gls.m_nSleeps          = sm_nSleeps;                        \
    gls.m_cTotalSpins      = sm_cTotalSpins;                    \
    if (sm_cContendedLocks > 0)                                 \
        gls.m_nAverageSpins = static_cast<LONG>(sm_cTotalSpins / \
                                                sm_cContendedLocks);\
    else                                                        \
        gls.m_nAverageSpins = 0;                                \
    gls.m_nReadLocks       = sm_nReadLocks;                     \
    gls.m_nWriteLocks      = sm_nWriteLocks;                    \
                                                                \
    return gls;                                                 \
}                                                               \
                                                                \
                                                                \
/* Reset global statistics for CLASS */                         \
void                                                            \
CLASS::ResetGlobalStatistics()                                  \
{                                                               \
    sm_cTotalLocks       = 0;                                   \
    sm_cContendedLocks   = 0;                                   \
    sm_nSleeps           = 0;                                   \
    sm_cTotalSpins       = 0;                                   \
    sm_nReadLocks        = 0;                                   \
    sm_nWriteLocks       = 0;                                   \
}


// Note: we are not using Interlocked operations for the shared
// statistical counters. We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.
# define LOCK_INSTRUMENTATION_PROLOG()  \
    ++sm_cContendedLocks;               \
    LONG cTotalSpins = 0;               \
    WORD cSleeps = 0

// Don't need InterlockedIncrement or InterlockedExchangeAdd for 
// member variables, as the lock is now locked by this thread.
# define LOCK_INSTRUMENTATION_EPILOG()  \
    ++m_nContentions;                   \
    m_nSleeps += cSleeps;               \
    m_nContentionSpins += cTotalSpins;  \
    sm_nSleeps += cSleeps;              \
    sm_cTotalSpins += cTotalSpins

#else // !LOCK_INSTRUMENTATION

# define LOCK_STATISTICS_DATA(CLASS)
# define LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CLASS)
# define LOCK_STATISTICS_REAL_IMPLEMENTATION(CLASS)
# define LOCK_INSTRUMENTATION_PROLOG()
# define LOCK_INSTRUMENTATION_EPILOG()

#endif // !LOCK_INSTRUMENTATION



//------------------------------------------------------------------------
// Function: RandomBackoffFactor
// Synopsis: A fudge factor to help avoid synchronization problems
//------------------------------------------------------------------------

LONG
RandomBackoffFactor(
    LONG cBaseSpins)
{
    static const int s_aFactors[] = {
        // 64ths of cBaseSpin
        +2, -3, -5, +6, +3, +1, -4, -1, -2, +8, -7,
    };
    const int nFactors = sizeof(s_aFactors) / sizeof(s_aFactors[0]);

    // Alternatives for nRand include a static counter
    // or the low DWORD of QueryPerformanceCounter().
#ifdef LOCKS_KERNEL_MODE
    DWORD nRand = (DWORD) HandleToULong(::PsGetCurrentThreadId());
#else // !LOCKS_KERNEL_MODE
    DWORD nRand = ::GetCurrentThreadId();
#endif // !LOCKS_KERNEL_MODE

    return cBaseSpins  +  (s_aFactors[nRand % nFactors] * (cBaseSpins >> 6));
}


//------------------------------------------------------------------------
// Function: SwitchOrSleep
// Synopsis: If possible, yields the thread with SwitchToThread.
//           If that doesn't work, calls Sleep.
//------------------------------------------------------------------------

void
SwitchOrSleep(
    DWORD dwSleepMSec)
{
#ifdef LOCKS_KERNEL_MODE
    ZwYieldExecution();
#else // !LOCKS_KERNEL_MODE
 #ifdef LOCKS_SWITCH_TO_THREAD
    if (!g_pfnSwitchToThread())
 #endif
        Sleep(dwSleepMSec);
#endif // !LOCKS_KERNEL_MODE
}
    



//------------------------------------------------------------------------
// CFakeLock static member variables

LOCK_DEFAULT_SPIN_DATA(CFakeLock);
LOCK_STATISTICS_DATA(CFakeLock);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CFakeLock);



//------------------------------------------------------------------------
// CSmallSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CSmallSpinLock);
LOCK_STATISTICS_DATA(CSmallSpinLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CSmallSpinLock);


//------------------------------------------------------------------------
// Function: CSmallSpinLock::_TryLock
// Synopsis: Attempt to acquire the lock
//------------------------------------------------------------------------

bool
CSmallSpinLock::_TryLock()
{
    if (m_lTid == SL_UNOWNED)
    {
        const LONG l = _CurrentThreadId();
        
        return (Lock_AtomicCompareAndSwap(const_cast<LONG*>(&m_lTid),
                                          l, SL_UNOWNED));
    }
    else
        return false;
}



//------------------------------------------------------------------------
// Function: CSmallSpinLock::_Unlock
// Synopsis: Release the lock
//------------------------------------------------------------------------

void
CSmallSpinLock::_Unlock()
{
    Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), SL_UNOWNED);
}



//------------------------------------------------------------------------
// Function: CSmallSpinLock::_LockSpin
// Synopsis: Acquire an exclusive lock. Blocks until acquired.
//------------------------------------------------------------------------

void
CSmallSpinLock::_LockSpin()
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime = 0;
    LONG  cBaseSpins  = DefaultSpinCount();
    LONG  cBaseSpins2 = RandomBackoffFactor(cBaseSpins);

    // This lock cannot be acquired recursively. Attempting to do so will
    // deadlock this thread forever. Use CSpinLock instead if you need that
    // kind of lock.
    if (m_lTid == _CurrentThreadId())
    {
        IRTLASSERT(
           !"CSmallSpinLock: Illegally attempted to acquire lock recursively");
#ifdef LOCKS_KERNEL_MODE
            DbgBreakPoint();
#else  // !LOCKS_KERNEL_MODE
            DebugBreak();
#endif // !LOCKS_KERNEL_MODE
    }

    while (!_TryLock())
    {
        // Only spin on a multiprocessor machine and then only if
        // spinning is enabled
        if (g_cProcessors > 1  &&  cBaseSpins != LOCK_DONT_SPIN)
        {
            LONG cSpins = cBaseSpins2;
        
            // Check no more than cBaseSpins2 times then yield.
            // It is important not to use the InterlockedExchange in the
            // inner loop in order to minimize system memory bus traffic.
            while (m_lTid != 0)
            { 
                if (--cSpins < 0)
                { 
#ifdef LOCK_INSTRUMENTATION
                    cTotalSpins += cBaseSpins2;
                    ++cSleeps;
#endif
                    SwitchOrSleep(dwSleepTime) ;

                    // Backoff algorithm: reduce (or increase) busy wait time
                    cBaseSpins2 = AdjustBySpinFactor(cBaseSpins2);
                    // LOCK_MINIMUM_SPINS <= cBaseSpins2 <= LOCK_MAXIMUM_SPINS
                    cBaseSpins2 = min(LOCK_MAXIMUM_SPINS, cBaseSpins2);
                    cBaseSpins2 = max(cBaseSpins2, LOCK_MINIMUM_SPINS);
                    cSpins = cBaseSpins2;

                    // Using Sleep(0) leads to the possibility of priority
                    // inversion. Sleep(0) only yields the processor if
                    // there's another thread of the same priority that's
                    // ready to run. If a high-priority thread is trying to
                    // acquire the lock, which is held by a low-priority
                    // thread, then the low-priority thread may never get
                    // scheduled and hence never free the lock. NT attempts
                    // to avoid priority inversions by temporarily boosting
                    // the priority of low-priority runnable threads, but the
                    // problem can still occur if there's a medium-priority
                    // thread that's always runnable. If Sleep(1) is used,
                    // then the thread unconditionally yields the CPU. We
                    // only do this for the second and subsequent even
                    // iterations, since a millisecond is a long time to wait
                    // if the thread can be scheduled in again sooner
                    // (~100,000 instructions).
                    // Avoid priority inversion: 0, 1, 0, 1,...
                    dwSleepTime = !dwSleepTime;
                }
                else
                {
                    Lock_Yield();
                }
            }

            // Lock is now available, but we still need to do the
            // InterlockedExchange to atomically grab it for ourselves.
#ifdef LOCK_INSTRUMENTATION
            cTotalSpins += cBaseSpins2 - cSpins;
#endif
        }

        // On a 1P machine, busy waiting is a waste of time
        else
        {
#ifdef LOCK_INSTRUMENTATION
            ++cSleeps;
#endif
            SwitchOrSleep(dwSleepTime);

            // Avoid priority inversion: 0, 1, 0, 1,...
            dwSleepTime = !dwSleepTime;
        }

    }

    LOCK_INSTRUMENTATION_EPILOG();
} // CSmallSpinLock::_LockSpin()



//------------------------------------------------------------------------
// CSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CSpinLock);
LOCK_STATISTICS_DATA(CSpinLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CSpinLock);


//------------------------------------------------------------------------
// Function: CSpinLock::_TryLock
// Synopsis: Attempt to acquire the lock without blocking
//------------------------------------------------------------------------

bool
CSpinLock::_TryLock()
{
    if (m_lTid == SL_UNOWNED)
    {
        LONG l = _CurrentThreadId() | SL_OWNER_INCR;
        
        return (Lock_AtomicCompareAndSwap(const_cast<LONG*>(&m_lTid),
                                          l, SL_UNOWNED));
    }
    else
        return false;
}


//------------------------------------------------------------------------
// Function: CSpinLock::_Lock
// Synopsis: Acquire the lock, recursively if need be
//------------------------------------------------------------------------

void
CSpinLock::_Lock()
{
    // Do we own the lock already?  Just bump the count.
    if (_IsLocked())
    {
        // owner count isn't maxed out?
        IRTLASSERT((m_lTid & SL_OWNER_MASK) != SL_OWNER_MASK);
        
        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid),
                            m_lTid + SL_OWNER_INCR);
    }
    
    // Some other thread owns the lock. We'll have to spin :-(.
    else
        _LockSpin();
    
    IRTLASSERT((m_lTid & SL_OWNER_MASK) > 0
               &&  (m_lTid & SL_THREAD_MASK) == _CurrentThreadId());
}


//------------------------------------------------------------------------
// Function: CSpinLock::_Unlock
// Synopsis: Release the lock.
//------------------------------------------------------------------------

void
CSpinLock::_Unlock()
{
    IRTLASSERT((m_lTid & SL_OWNER_MASK) > 0
               &&  (m_lTid & SL_THREAD_MASK) == _CurrentThreadId());
    
    LONG l = m_lTid - SL_OWNER_INCR; 
    
    // Last owner?  Release completely, if so
    if ((l & SL_OWNER_MASK) == 0)
        l = SL_UNOWNED;
    
    Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), l);
}


//------------------------------------------------------------------------
// Function: CSpinLock::_LockSpin
// Synopsis: Acquire an exclusive lock. Blocks until acquired.
//------------------------------------------------------------------------

void
CSpinLock::_LockSpin()
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime   = 0;
    bool  fAcquiredLock = false;
    LONG  cBaseSpins    = RandomBackoffFactor(DefaultSpinCount());

    while (!fAcquiredLock)
    {
        // Only spin on a multiprocessor machine and then only if
        // spinning is enabled
        if (g_cProcessors > 1  &&  DefaultSpinCount() != LOCK_DONT_SPIN)
        {
            LONG cSpins = cBaseSpins;
        
            // Check no more than cBaseSpins times then yield
            while (m_lTid != 0)
            { 
                if (--cSpins < 0)
                { 
#ifdef LOCK_INSTRUMENTATION
                    cTotalSpins += cBaseSpins;
                    ++cSleeps;
#endif // LOCK_INSTRUMENTATION

                    SwitchOrSleep(dwSleepTime) ;

                    // Backoff algorithm: reduce (or increase) busy wait time
                    cBaseSpins = AdjustBySpinFactor(cBaseSpins);
                    // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
                    cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
                    cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
                    cSpins = cBaseSpins;
            
                    // Avoid priority inversion: 0, 1, 0, 1,...
                    dwSleepTime = !dwSleepTime;
                }
                else
                {
                    Lock_Yield();
                }
            }

            // Lock is now available, but we still need to atomically
            // update m_cOwners and m_nThreadId to grab it for ourselves.
#ifdef LOCK_INSTRUMENTATION
            cTotalSpins += cBaseSpins - cSpins;
#endif // LOCK_INSTRUMENTATION
        }

        // on a 1P machine, busy waiting is a waste of time
        else
        {
#ifdef LOCK_INSTRUMENTATION
            ++cSleeps;
#endif // LOCK_INSTRUMENTATION
            SwitchOrSleep(dwSleepTime);
            
            // Avoid priority inversion: 0, 1, 0, 1,...
            dwSleepTime = !dwSleepTime;
        }

        // Is the lock unowned?
        if (_TryLock())
            fAcquiredLock = true; // got the lock
    }

    IRTLASSERT(_IsLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



#ifndef LOCKS_KERNEL_MODE

//------------------------------------------------------------------------
// CCritSec static member variables

LOCK_DEFAULT_SPIN_DATA(CCritSec);
LOCK_STATISTICS_DATA(CCritSec);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CCritSec);


bool
CCritSec::TryWriteLock()
{
    IRTLASSERT(g_pfnTryEnterCritSec != NULL);
    return g_pfnTryEnterCritSec(&m_cs) ? true : false;
}


//------------------------------------------------------------------------
// Function: CCritSec::SetSpinCount
// Synopsis: This function is used to call the appropriate underlying
//           functions to set the spin count for the supplied critical
//           section. The original function is supposed to be exported out
//           of kernel32.dll from NT 4.0 SP3. If the func is not available
//           from the dll, we will use a fake function.
//
// Arguments:
//   lpCriticalSection
//      Points to the critical section object.
//
//   dwSpinCount
//      Supplies the spin count for the critical section object. For UP
//      systems, the spin count is ignored and the critical section spin
//      count is set to 0. For MP systems, if contention occurs, instead of
//      waiting on a semaphore associated with the critical section, the
//      calling thread will spin for spin count iterations before doing the
//      hard wait. If the critical section becomes free during the spin, a
//      wait is avoided.
//
// Returns:
//      The previous spin count for the critical section is returned.
//------------------------------------------------------------------------

DWORD
CCritSec::SetSpinCount(
    LPCRITICAL_SECTION pcs,
    DWORD dwSpinCount)
{
    IRTLASSERT(g_pfnSetCSSpinCount != NULL);
    return g_pfnSetCSSpinCount(pcs, dwSpinCount);
}

#endif // !LOCKS_KERNEL_MODE



//------------------------------------------------------------------------
// CReaderWriterLock static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock);
LOCK_STATISTICS_DATA(CReaderWriterLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock);


//------------------------------------------------------------------------
// Function: CReaderWriterLock::_CmpExch
// Synopsis: _CmpExch is equivalent to
//      LONG lTemp = m_lRW;
//      if (lTemp == lCurrent)  m_lRW = lNew;
//      return lCurrent == lTemp;
// except it's one atomic instruction.  Using this gives us the basis of
// a protocol because the update only succeeds when we knew exactly what
// used to be in m_lRW.  If some other thread slips in and modifies m_lRW
// before we do, the update will fail.  In other words, it's transactional.
//------------------------------------------------------------------------

bool
CReaderWriterLock::_CmpExch(LONG lNew, LONG lCurrent)
{
    return Lock_AtomicCompareAndSwap(const_cast<LONG*>(&m_nState),
                                     lNew, lCurrent);
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock::_TryWriteLock
// Synopsis: Try to acquire the lock exclusively.
//------------------------------------------------------------------------

bool
CReaderWriterLock::_TryWriteLock()
{
    return (m_nState == SL_FREE  &&  _CmpExch(SL_EXCLUSIVE, SL_FREE));
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock::_TryReadLock
// Synopsis: Try to acquire the lock shared.
//------------------------------------------------------------------------

bool
CReaderWriterLock::_TryReadLock()
{
    LONG nCurrState = m_nState;
    
    // Give writers priority
    return (nCurrState != SL_EXCLUSIVE  &&  m_cWaiting == 0
            &&  _CmpExch(nCurrState + 1, nCurrState));
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock::WriteLock
// Synopsis: acquire the lock exclusively
//------------------------------------------------------------------------

void
CReaderWriterLock::WriteLock()
{
    LOCKS_ENTER_CRIT_REGION();
    LOCK_WRITELOCK_INSTRUMENTATION();
    
    // Add ourselves to the queue of waiting writers
    Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));
    
    if (_TryWriteLock())
            return;
    
    _WriteLockSpin();
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock::ReadLock
// Synopsis: acquire the lock shared
//------------------------------------------------------------------------

void
CReaderWriterLock::ReadLock()
{
    LOCKS_ENTER_CRIT_REGION();
    LOCK_READLOCK_INSTRUMENTATION();
    
    if (_TryReadLock())
        return;
    
    _ReadLockSpin();
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock::TryWriteLock
// Synopsis: Try to acquire the lock exclusively.
//------------------------------------------------------------------------

bool
CReaderWriterLock::TryWriteLock()
{
    LOCKS_ENTER_CRIT_REGION();

    // Add ourselves to the queue of waiting writers
    Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));
    
    if (_TryWriteLock())
    {
        LOCK_WRITELOCK_INSTRUMENTATION();
        return true;
    }
    
    Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
    LOCKS_LEAVE_CRIT_REGION();

    return false;    
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock::_TryReadLock
// Synopsis: Try to acquire the lock shared.
//------------------------------------------------------------------------

bool
CReaderWriterLock::TryReadLock()
{
    LOCKS_ENTER_CRIT_REGION();

    if (_TryReadLock())
    {
        LOCK_READLOCK_INSTRUMENTATION();
        return true;
    }
    
    LOCKS_LEAVE_CRIT_REGION();

    return false;
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock::WriteUnlock
// Synopsis: release the exclusive lock
//------------------------------------------------------------------------

void
CReaderWriterLock::WriteUnlock()
{
    Lock_AtomicExchange(const_cast<LONG*>(&m_nState), SL_FREE);
    Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
    LOCKS_LEAVE_CRIT_REGION();
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock::ReadUnlock
// Synopsis: release the shared lock
//------------------------------------------------------------------------

void
CReaderWriterLock::ReadUnlock()
{
    Lock_AtomicDecrement(const_cast<LONG*>(&m_nState));
    LOCKS_LEAVE_CRIT_REGION();
}




//------------------------------------------------------------------------
// Function: CReaderWriterLock::ConvertSharedToExclusive()
// Synopsis: Convert a reader lock to a writer lock
//------------------------------------------------------------------------

void
CReaderWriterLock::ConvertSharedToExclusive()
{
    IRTLASSERT(IsReadLocked());
    Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));
    
    // single reader?
    if (m_nState == SL_FREE + 1  &&  _CmpExch(SL_EXCLUSIVE, SL_FREE + 1))
        return;
    
    // No, so release the reader lock and spin
    ReadUnlock();

    LOCKS_ENTER_CRIT_REGION();
    _WriteLockSpin();
    
    IRTLASSERT(IsWriteLocked());
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock::ConvertExclusiveToShared()
// Synopsis: Convert a writer lock to a reader lock
//------------------------------------------------------------------------

void
CReaderWriterLock::ConvertExclusiveToShared()
{
    IRTLASSERT(IsWriteLocked());
    Lock_AtomicExchange(const_cast<LONG*>(&m_nState), SL_FREE + 1);
    Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
    IRTLASSERT(IsReadLocked());
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock::_LockSpin
// Synopsis: Acquire an exclusive or shared lock. Blocks until acquired.
//------------------------------------------------------------------------

void
CReaderWriterLock::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = RandomBackoffFactor(DefaultSpinCount());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (g_cProcessors == 1  ||  DefaultSpinCount() == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock()  :  _TryReadLock();

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = AdjustBySpinFactor(cBaseSpins);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



//------------------------------------------------------------------------
// CReaderWriterLock2 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock2);
LOCK_STATISTICS_DATA(CReaderWriterLock2);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock2);



//------------------------------------------------------------------------
// Function: CReaderWriterLock2::_CmpExch
// Synopsis: _CmpExch is equivalent to
//      LONG lTemp = m_lRW;
//      if (lTemp == lCurrent)  m_lRW = lNew;
//      return lCurrent == lTemp;
// except it's one atomic instruction.  Using this gives us the basis of
// a protocol because the update only succeeds when we knew exactly what
// used to be in m_lRW.  If some other thread slips in and modifies m_lRW
// before we do, the update will fail.  In other words, it's transactional.
//------------------------------------------------------------------------

LOCK_FORCEINLINE bool
CReaderWriterLock2::_CmpExch(LONG lNew, LONG lCurrent)
{
    return Lock_AtomicCompareAndSwap(const_cast<LONG*>(&m_lRW),
                                     lNew, lCurrent);
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock2::_WriteLockSpin
// Synopsis: Try to acquire an exclusive lock
//------------------------------------------------------------------------

inline bool
CReaderWriterLock2::_TryWriteLock(
    LONG nIncr)
{
    LONG l = m_lRW;
    // Grab exclusive access to the lock if it's free.  Works even
    // if there are other writers queued up.
    return ((l & SL_STATE_MASK) == SL_FREE
            &&  _CmpExch((l + nIncr) | SL_EXCLUSIVE, l));
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock2::_TryReadLock
// Synopsis: Try to acquire a shared lock
//------------------------------------------------------------------------

inline bool
CReaderWriterLock2::_TryReadLock()
{
    LONG l = m_lRW;
    
    // Give writers priority
    return ((l & SL_WRITERS_MASK) == 0
            &&  _CmpExch(l + SL_READER_INCR, l));
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock2::_WriteLockSpin
// Synopsis: release an exclusive lock
//------------------------------------------------------------------------

void
CReaderWriterLock2::WriteUnlock()
{
    IRTLASSERT(IsWriteLocked());

    for (LONG l = m_lRW;
         // decrement waiter count, clear loword to SL_FREE
         !_CmpExch((l - SL_WRITER_INCR) & ~SL_STATE_MASK, l);
         l = m_lRW)
    {
        IRTLASSERT(IsWriteLocked());
        Lock_Yield();
    }

    LOCKS_LEAVE_CRIT_REGION();
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock2::ReadUnlock
// Synopsis: release a shared lock
//------------------------------------------------------------------------

void
CReaderWriterLock2::ReadUnlock()
{
    IRTLASSERT(IsReadLocked());

    for (LONG l = m_lRW;  !_CmpExch(l - SL_READER_INCR, l);  l = m_lRW)
    {
        IRTLASSERT(IsReadLocked());
        Lock_Yield();
    }

    LOCKS_LEAVE_CRIT_REGION();
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock2::ConvertSharedToExclusive
// Synopsis: Convert a reader lock to a writer lock
//------------------------------------------------------------------------

void
CReaderWriterLock2::ConvertSharedToExclusive()
{
    IRTLASSERT(IsReadLocked());

    // single reader?
    if (m_lRW != SL_ONE_READER  ||  !_CmpExch(SL_ONE_WRITER,SL_ONE_READER))
    {
        // no, multiple readers
        ReadUnlock();

        LOCKS_ENTER_CRIT_REGION();
        _WriteLockSpin();
    }

    IRTLASSERT(IsWriteLocked());
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock2::ConvertExclusiveToShared
// Synopsis: Convert a writer lock to a reader lock
//------------------------------------------------------------------------

void
CReaderWriterLock2::ConvertExclusiveToShared()
{
    IRTLASSERT(IsWriteLocked());

    for (LONG l = m_lRW;
         !_CmpExch(((l-SL_WRITER_INCR) & SL_WAITING_MASK) | SL_READER_INCR, l);
         l = m_lRW)
    {
        IRTLASSERT(IsWriteLocked());
        Lock_Yield();
    }

    IRTLASSERT(IsReadLocked());
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock2::_WriteLockSpin
// Synopsis: Acquire an exclusive lock. Blocks until acquired.
//------------------------------------------------------------------------

void
CReaderWriterLock2::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (LONG l = m_lRW;  !_CmpExch(l + SL_WRITER_INCR, l);  l = m_lRW)
    {
        Lock_Yield();
    }
    
    _LockSpin(true);
}


//------------------------------------------------------------------------
// Function: CReaderWriterLock2::_LockSpin
// Synopsis: Acquire an exclusive or shared lock. Blocks until acquired.
//------------------------------------------------------------------------

void
CReaderWriterLock2::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = RandomBackoffFactor(DefaultSpinCount());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (g_cProcessors == 1  ||  DefaultSpinCount() == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock(0)  :  _TryReadLock();

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = AdjustBySpinFactor(cBaseSpins);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



//------------------------------------------------------------------------
// CReaderWriterLock3 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock3);
LOCK_STATISTICS_DATA(CReaderWriterLock3);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock3);



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::_CmpExch
// Synopsis: _CmpExch is equivalent to
//      LONG lTemp = m_lRW;
//      if (lTemp == lCurrent)  m_lRW = lNew;
//      return lCurrent == lTemp;
// except it's one atomic instruction.  Using this gives us the basis of
// a protocol because the update only succeeds when we knew exactly what
// used to be in m_lRW.  If some other thread slips in and modifies m_lRW
// before we do, the update will fail.  In other words, it's transactional.
//------------------------------------------------------------------------

LOCK_FORCEINLINE bool
CReaderWriterLock3::_CmpExch(LONG lNew, LONG lCurrent)
{
    return Lock_AtomicCompareAndSwap(const_cast<LONG*>(&m_lRW),
                                     lNew, lCurrent);
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::_SetTid
// Synopsis: Atomically update m_lTid, the thread ID/count of owners.
// Returns:  Former value of m_lTid
//------------------------------------------------------------------------

LOCK_FORCEINLINE LONG
CReaderWriterLock3::_SetTid(LONG lNewTid)
{
    return Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), lNewTid);
}
                                        


//------------------------------------------------------------------------
// Function: CReaderWriterLock3::_TryWriteLock
// Synopsis: Try to acquire an exclusive lock
//------------------------------------------------------------------------

bool
CReaderWriterLock3::_TryWriteLock(
    LONG nIncr)
{
    // The common case: the writelock has no owner
    if (m_lTid == SL_UNOWNED)
    {
        // IRTLASSERT((m_lRW & SL_STATE_MASK) != SL_EXCLUSIVE);
        LONG l = m_lRW;
        // Grab exclusive access to the lock if it's free.  Works even
        // if there are other writers queued up.
        if ((l & SL_STATE_MASK) == SL_FREE
            &&  _CmpExch((l + nIncr) | SL_EXCLUSIVE, l))
        {
            l = _SetTid(_CurrentThreadId() | SL_OWNER_INCR);
            IRTLASSERT(l == SL_UNOWNED);
            return true;
        }
    }

    // Does the current thread own the lock?
    if (IsWriteLocked())
    {
        IRTLASSERT((m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE);
        // If all bits are set in owner field, it's about to overflow
        IRTLASSERT((m_lTid & SL_OWNER_MASK) != SL_OWNER_MASK);

        _SetTid(m_lTid + SL_OWNER_INCR);
        return true;
    }

    return false;
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::_TryReadLock
// Synopsis: Try to acquire a shared lock
//------------------------------------------------------------------------

bool
CReaderWriterLock3::_TryReadLock()
{
    // Give writers priority
    LONG l = m_lRW;
    bool fLocked = (((l & SL_WRITERS_MASK) == 0)
                    &&  _CmpExch(l + SL_READER_INCR, l));
    IRTLASSERT(!fLocked  ||  m_lTid == SL_UNOWNED);
    return fLocked;
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::_TryReadLockRecursive
// Synopsis: Try to acquire a shared lock that might already be owned
// by this thread for reading. Unlike _TryReadLock, does not give
// priority to waiting writers.
//------------------------------------------------------------------------

bool
CReaderWriterLock3::_TryReadLockRecursive()
{
    // Do *not* give writers priority. If the inner call attempts
    // to reacquire the read lock while another thread is waiting on
    // the write lock, we would deadlock if we waited for the queue
    // of writers to empty: the writer(s) can't acquire the lock
    // exclusively, as this thread holds a readlock. The inner call
    // typically releases the lock very quickly, so there is no
    // danger of writer starvation.
    LONG l = m_lRW;
    bool fLocked = (((l & SL_STATE_MASK) != SL_EXCLUSIVE)
                    &&  _CmpExch(l + SL_READER_INCR, l));
    IRTLASSERT(!fLocked  ||  m_lTid == SL_UNOWNED);
    return fLocked;
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::ReadOrWriteLock
// Synopsis: If already locked, recursively acquires another lock of the
// same kind (read or write). Otherwise, just acquires a read lock.
//------------------------------------------------------------------------

bool
CReaderWriterLock3::ReadOrWriteLock()
{
    if (IsWriteLocked())
    {
        WriteLock();
        return false;   // => not read locked
    }
    else
    {
        LOCKS_ENTER_CRIT_REGION();
        LOCK_READLOCK_INSTRUMENTATION();
        
        if (!_TryReadLockRecursive())
            _ReadLockSpin(SPIN_READ_RECURSIVE);
            
        return true;   // => is read locked
    }
} 



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::WriteUnlock
// Synopsis: release an exclusive lock
//------------------------------------------------------------------------

void
CReaderWriterLock3::WriteUnlock()
{
    IRTLASSERT(IsWriteLocked());
    LONG lNew = m_lTid - SL_OWNER_INCR; 

    // Last owner?  Release completely, if so
    if ((lNew & SL_OWNER_MASK) == 0)
        lNew = SL_UNOWNED;

    _SetTid(lNew);

    if (lNew == SL_UNOWNED)
    {
        LONG l;
        do 
        {
            Lock_Yield();
            l = m_lRW;
        } // decrement waiter count, clear loword to SL_FREE
        while (!_CmpExch((l - SL_WRITER_INCR) & ~SL_STATE_MASK, l));
    }

    LOCKS_LEAVE_CRIT_REGION();
} 



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::ReadUnlock
// Synopsis: release a shared lock
//------------------------------------------------------------------------

void
CReaderWriterLock3::ReadUnlock()
{
    IRTLASSERT(IsReadLocked());
    for (LONG l = m_lRW;  !_CmpExch(l - SL_READER_INCR, l);  l = m_lRW)
    {
        IRTLASSERT(IsReadLocked());
        Lock_Yield();
    }

    LOCKS_LEAVE_CRIT_REGION();
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::ReadOrWriteUnlock
// Synopsis: release a lock acquired with ReadOrWriteLock
//------------------------------------------------------------------------

void
CReaderWriterLock3::ReadOrWriteUnlock(
    bool fIsReadLocked)
{
    if (fIsReadLocked)
        ReadUnlock();
    else
        WriteUnlock();
} 



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::ConvertSharedToExclusive
// Synopsis: Convert a reader lock to a writer lock
// Note: if there's more than one reader, then there's a window where
// another thread can acquire and release a writelock before this routine
// returns.
//------------------------------------------------------------------------

void
CReaderWriterLock3::ConvertSharedToExclusive()
{
    IRTLASSERT(IsReadLocked());

    // single reader?
    if (m_lRW == SL_ONE_READER
        &&  _CmpExch(SL_ONE_WRITER, SL_ONE_READER))
    {
        _SetTid(_CurrentThreadId() | SL_OWNER_INCR);
    }
    else
    {
        // no, multiple readers
        ReadUnlock();

        LOCKS_ENTER_CRIT_REGION();
        _WriteLockSpin();
    }

    IRTLASSERT(IsWriteLocked());
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::ConvertExclusiveToShared
// Synopsis: Convert a writer lock to a reader lock
// Note: There is no such window when converting from a writelock to a readlock
//------------------------------------------------------------------------

void
CReaderWriterLock3::ConvertExclusiveToShared()
{
    IRTLASSERT(IsWriteLocked());

    // assume writelock is not held recursively
    IRTLASSERT((m_lTid & SL_OWNER_MASK) == SL_OWNER_INCR);
    _SetTid(SL_UNOWNED);

    for (LONG l = m_lRW;
         !_CmpExch(((l-SL_WRITER_INCR) & SL_WAITING_MASK) | SL_READER_INCR,
                   l);
         l = m_lRW)
    {
        Lock_Yield();
    }

    IRTLASSERT(IsReadLocked());
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::_WriteLockSpin
// Synopsis: Acquire an exclusive lock. Blocks until acquired.
//------------------------------------------------------------------------

void
CReaderWriterLock3::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (LONG l = m_lRW;  !_CmpExch(l + SL_WRITER_INCR, l);  l = m_lRW)
    {
        Lock_Yield();
    }
    
    _LockSpin(SPIN_WRITE);
}



//------------------------------------------------------------------------
// Function: CReaderWriterLock3::_LockSpin
// Synopsis: Acquire an exclusive or shared lock. Blocks until acquired.
//------------------------------------------------------------------------

void
CReaderWriterLock3::_LockSpin(
    SPIN_TYPE st)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = RandomBackoffFactor(DefaultSpinCount());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (g_cProcessors == 1  ||  DefaultSpinCount() == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock;

            if (st == SPIN_WRITE)
                fLock = _TryWriteLock(0);
            else if (st == SPIN_READ)
                fLock = _TryReadLock();
            else
            {
                IRTLASSERT(st == SPIN_READ_RECURSIVE);
                fLock = _TryReadLockRecursive();
            }


            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = AdjustBySpinFactor(cBaseSpins);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT((st == SPIN_WRITE)  ?  IsWriteLocked()  :  IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



#ifdef __LOCKS_NAMESPACE__
}
#endif // __LOCKS_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\lkrhash\src\lkr-stats.cpp ===
/*++

   Copyright    (c) 1998-2000    Microsoft Corporation

   Module  Name :
       LKR-stats.cpp

   Abstract:
       Implements statistics gathering for LKRhash

   Author:
       Paul (Per-Ake) Larson, palarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       Jan 1998   - Massive cleanup and rewrite.  Templatized.
       10/01/1998 - Change name from LKhash to LKRhash

--*/

#include "precomp.hxx"


#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <LKRhash.h>

#include "i-LKRhash.h"


#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
#else  // __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS
#endif // __LKRHASH_NO_NAMESPACE__


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__

#include "LKR-inline.h"

#ifndef LKRHASH_KERNEL_MODE

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::GetStatistics
// Synopsis: Gather statistics about the table
//------------------------------------------------------------------------

CLKRHashTableStats
CLKRLinearHashTable::GetStatistics() const
{
    CLKRHashTableStats stats;

    if (!IsUsable())
        return stats;

    if (m_paDirSegs != NULL)
    {
        stats.RecordCount   = m_cRecords;
        stats.TableSize     = m_cActiveBuckets;
        stats.SplitFactor   = static_cast<double>(m_iExpansionIdx)
                                / (1 << m_nLevel);
        stats.DirectorySize = m_cDirSegs;
        stats.NodeClumpSize = NODES_PER_CLUMP;
        stats.CBucketSize   = sizeof(CBucket);

#ifdef LOCK_INSTRUMENTATION
        stats.m_alsBucketsAvg.m_nContentions     = 0;
        stats.m_alsBucketsAvg.m_nSleeps          = 0;
        stats.m_alsBucketsAvg.m_nContentionSpins = 0;
        stats.m_alsBucketsAvg.m_nAverageSpins    = 0;
        stats.m_alsBucketsAvg.m_nReadLocks       = 0;
        stats.m_alsBucketsAvg.m_nWriteLocks      = 0;
        stats.m_alsBucketsAvg.m_nItems           = 0;
#endif // LOCK_INSTRUMENTATION

        int empty = 0;
        int totacc = 0;
        int low_count = 0;
        int high_count = 0;
        int max_length = 0;

        for (DWORD i = 0;  i < m_cActiveBuckets;  i++)
        {
            int acc = 0;

            for (CNodeClump* pncCurr = &_Bucket(i)->m_ncFirst;
                 pncCurr != NULL;
                 pncCurr = pncCurr->m_pncNext)
            {
                int j;

                FOR_EACH_NODE(j)
                {
                    if (!pncCurr->IsEmptySlot(j))
                    {
                        acc++;
                        totacc += acc;
                        int iBucketIndex = stats.BucketIndex(acc);
                        ++stats.m_aBucketLenHistogram[iBucketIndex];
                    }
                }
            }

#ifdef LOCK_INSTRUMENTATION
            CLockStatistics ls = _Bucket(i)->LockStats();

            stats.m_alsBucketsAvg.m_nContentions     += ls.m_nContentions;
            stats.m_alsBucketsAvg.m_nSleeps          += ls.m_nSleeps;
            stats.m_alsBucketsAvg.m_nContentionSpins += ls.m_nContentionSpins;
            stats.m_alsBucketsAvg.m_nAverageSpins    += ls.m_nAverageSpins;
            stats.m_alsBucketsAvg.m_nReadLocks       += ls.m_nReadLocks;
            stats.m_alsBucketsAvg.m_nWriteLocks      += ls.m_nWriteLocks;
            stats.m_alsBucketsAvg.m_nItems           ++;
#endif // LOCK_INSTRUMENTATION

            max_length = max(max_length, acc);
            if (acc == 0)
                empty++;

            if (_H0(i) < m_iExpansionIdx)
            {
                low_count += acc;
            }
            else
            {
                high_count += acc;
            }
        }

        stats.LongestChain = max_length;
        stats.EmptySlots   = empty;

        if (m_cActiveBuckets > 0)
        {
            if (m_cRecords > 0)
            {
                double x=static_cast<double>(m_iExpansionIdx) /(1 << m_nLevel);
                double alpha= static_cast<double>(m_cRecords)/m_cActiveBuckets;
                double low_sl = 0.0;
                double high_sl = 0.0;
                
                stats.AvgSearchLength= static_cast<double>(totacc) /m_cRecords;
                stats.ExpSearchLength  = 1 + alpha * 0.25 * (2 + x - x*x);
                
                if (m_iExpansionIdx > 0)
                    low_sl  = static_cast<double>(low_count)
                        / (2.0 * m_iExpansionIdx);
                if (m_cActiveBuckets - 2 * m_iExpansionIdx > 0)
                    high_sl = static_cast<double>(high_count)
                        / (m_cActiveBuckets - 2.0 * m_iExpansionIdx);
                stats.AvgUSearchLength = low_sl * x + high_sl * (1.0 - x);
                stats.ExpUSearchLength = alpha * 0.5 * (2 + x - x*x);
            }

#ifdef LOCK_INSTRUMENTATION
            stats.m_alsBucketsAvg.m_nContentions     /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nSleeps          /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nContentionSpins /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nAverageSpins    /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nReadLocks       /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nWriteLocks      /= m_cActiveBuckets;
#endif // LOCK_INSTRUMENTATION

        }
        else
        {
            stats.AvgSearchLength  = 0.0;
            stats.ExpSearchLength  = 0.0;
            stats.AvgUSearchLength = 0.0;
            stats.ExpUSearchLength = 0.0;
        }
    }

#ifdef LOCK_INSTRUMENTATION
    stats.m_gls     = TableLock::GlobalStatistics();
    CLockStatistics ls = _LockStats();

    stats.m_alsTable.m_nContentions     = ls.m_nContentions;
    stats.m_alsTable.m_nSleeps          = ls.m_nSleeps;
    stats.m_alsTable.m_nContentionSpins = ls.m_nContentionSpins;
    stats.m_alsTable.m_nAverageSpins    = ls.m_nAverageSpins;
    stats.m_alsTable.m_nReadLocks       = ls.m_nReadLocks;
    stats.m_alsTable.m_nWriteLocks      = ls.m_nWriteLocks;
    stats.m_alsTable.m_nItems           = 1;
#endif // LOCK_INSTRUMENTATION

    return stats;
} // CLKRLinearHashTable::GetStatistics



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetStatistics
// Synopsis: Gather statistics about the table
//------------------------------------------------------------------------

CLKRHashTableStats
CLKRHashTable::GetStatistics() const
{
    CLKRHashTableStats hts;

    if (!IsUsable())
        return hts;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        CLKRHashTableStats stats = m_palhtDir[i]->GetStatistics();

        hts.RecordCount +=      stats.RecordCount;
        hts.TableSize +=        stats.TableSize;
        hts.DirectorySize +=    stats.DirectorySize;
        hts.LongestChain =      max(hts.LongestChain, stats.LongestChain);
        hts.EmptySlots +=       stats.EmptySlots;
        hts.SplitFactor +=      stats.SplitFactor;
        hts.AvgSearchLength +=  stats.AvgSearchLength;
        hts.ExpSearchLength +=  stats.ExpSearchLength;
        hts.AvgUSearchLength += stats.AvgUSearchLength;
        hts.ExpUSearchLength += stats.ExpUSearchLength;
        hts.NodeClumpSize =     stats.NodeClumpSize;
        hts.CBucketSize =       stats.CBucketSize;

        for (int j = 0;  j < CLKRHashTableStats::MAX_BUCKETS;  ++j)
            hts.m_aBucketLenHistogram[j] += stats.m_aBucketLenHistogram[j];

#ifdef LOCK_INSTRUMENTATION
        hts.m_alsTable.m_nContentions     += stats.m_alsTable.m_nContentions;
        hts.m_alsTable.m_nSleeps          += stats.m_alsTable.m_nSleeps;
        hts.m_alsTable.m_nContentionSpins
            += stats.m_alsTable.m_nContentionSpins;
        hts.m_alsTable.m_nAverageSpins    += stats.m_alsTable.m_nAverageSpins;
        hts.m_alsTable.m_nReadLocks       += stats.m_alsTable.m_nReadLocks;
        hts.m_alsTable.m_nWriteLocks      += stats.m_alsTable.m_nWriteLocks;
        
        hts.m_alsBucketsAvg.m_nContentions
            += stats.m_alsBucketsAvg.m_nContentions;
        hts.m_alsBucketsAvg.m_nSleeps
            += stats.m_alsBucketsAvg.m_nSleeps;
        hts.m_alsBucketsAvg.m_nContentionSpins
            += stats.m_alsBucketsAvg.m_nContentionSpins;
        hts.m_alsBucketsAvg.m_nAverageSpins
            += stats.m_alsBucketsAvg.m_nAverageSpins;
        hts.m_alsBucketsAvg.m_nReadLocks
            += stats.m_alsBucketsAvg.m_nReadLocks;
        hts.m_alsBucketsAvg.m_nWriteLocks
            += stats.m_alsBucketsAvg.m_nWriteLocks;
        hts.m_alsBucketsAvg.m_nItems
            += stats.m_alsBucketsAvg.m_nItems;
        
        hts.m_gls = stats.m_gls;
#endif // LOCK_INSTRUMENTATION
    }

    // Average out the subtables statistics.  (Does this make sense
    // for all of these fields?)
    hts.DirectorySize /=    m_cSubTables;
    hts.SplitFactor /=      m_cSubTables;
    hts.AvgSearchLength /=  m_cSubTables;
    hts.ExpSearchLength /=  m_cSubTables;
    hts.AvgUSearchLength /= m_cSubTables;
    hts.ExpUSearchLength /= m_cSubTables;

#ifdef LOCK_INSTRUMENTATION
    hts.m_alsTable.m_nContentions     /= m_cSubTables;
    hts.m_alsTable.m_nSleeps          /= m_cSubTables;
    hts.m_alsTable.m_nContentionSpins /= m_cSubTables;
    hts.m_alsTable.m_nAverageSpins    /= m_cSubTables;
    hts.m_alsTable.m_nReadLocks       /= m_cSubTables;
    hts.m_alsTable.m_nWriteLocks      /= m_cSubTables;
    hts.m_alsTable.m_nItems            = m_cSubTables;

    hts.m_alsBucketsAvg.m_nContentions     /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nSleeps          /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nContentionSpins /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nAverageSpins    /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nReadLocks       /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nWriteLocks      /= m_cSubTables;
#endif // LOCK_INSTRUMENTATION

    return hts;
} // CLKRHashTable::GetStatistics

#endif // !LKRHASH_KERNEL_MODE



#ifdef LOCK_INSTRUMENTATION

CAveragedLockStats::CAveragedLockStats()
    : m_nItems(1)
{}

#endif // LOCK_INSTRUMENTATION


#ifndef LKRHASH_KERNEL_MODE

CLKRHashTableStats::CLKRHashTableStats()
    : RecordCount(0),
      TableSize(0),
      DirectorySize(0),
      LongestChain(0),
      EmptySlots(0),
      SplitFactor(0.0),
      AvgSearchLength(0.0),
      ExpSearchLength(0.0),
      AvgUSearchLength(0.0),
      ExpUSearchLength(0.0),
      NodeClumpSize(1),
      CBucketSize(0)
{
    for (int i = MAX_BUCKETS;  --i >= 0;  )
        m_aBucketLenHistogram[i] = 0;
}

const LONG*
CLKRHashTableStats::BucketSizes()
{
    static const LONG  s_aBucketSizes[MAX_BUCKETS] = {
        1,    2,    3,    4,    5,    6,    7,      8,        9,
        10,   11,   12,   13,   14,   15,   16,   17,     18,       19,
        20,   21,   22,   23,   24,   25,   30,   40,     50,       60,
        70,   80,   90,  100,  200,  500, 1000,10000, 100000, LONG_MAX,
    };
    
    return s_aBucketSizes;
}

LONG
CLKRHashTableStats::BucketSize(
    LONG nBucketIndex)
{
    IRTLASSERT(0 <= nBucketIndex  &&  nBucketIndex < MAX_BUCKETS);
    return BucketSizes()[nBucketIndex];
}

LONG
CLKRHashTableStats::BucketIndex(
    LONG nBucketLength)
{
    const LONG* palBucketSizes = BucketSizes();
    LONG i = 0;
    while (palBucketSizes[i] < nBucketLength)
        ++i;
    if (i == MAX_BUCKETS  ||  palBucketSizes[i] > nBucketLength)
        --i;
    IRTLASSERT(0 <= i  &&  i < MAX_BUCKETS);
    return i;
}

#endif // !LKRHASH_KERNEL_MODE


#ifndef __LKRHASH_NO_NAMESPACE__
};
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\imh6\makefile.inc ===
munge_inf:
    perl iisinfsp.pl

#-------------------------------------------------------
# the following are old stuff, not used for service pack


iCPU=$(PROCESSOR_ARCHITECTURE)
!IF "$(iCPU)"=="x86"
iCPU=I386
!ENDIF

!IF "$(PROCESSOR_ARCHITECTURE)"!="MIPS"
!IF "$(PROCESSOR_ARCHITECTURE)"!="PPC"

CDROOT=$(_NTTREE)\inetsrv
CDDUMP=$(_NTTREE)\inetsrv\Dump

MY_BINPLACE = -binplace -P $(BINPLACE_PLACEFILE)

copyfile:
	if not exist "$(CDROOT)" mkdir $(CDROOT)
	if not exist "$(CDDUMP)" mkdir $(CDDUMP)

#       keep around so can run standalone setup
	$(MY_BINPLACE) setup.exe

#       stuff we really do need
	$(MY_BINPLACE) infutil.csv
	$(MY_BINPLACE) header.ddf
	$(MY_BINPLACE) makecab.lst
	$(MY_BINPLACE) makecab.cmd
	$(MY_BINPLACE) makecab1.cmd
	$(MY_BINPLACE) chkcab.cmd
	$(MY_BINPLACE) hardcode.lst

	$(MY_BINPLACE) iistop.inx
	$(MY_BINPLACE) iisend.inx
	$(MY_BINPLACE) dirmake.txt

#       --------------------------------------
#       old bad way of copying files to the binaries dir
#       bad bad bad, you should not use xcopy!
#       use binplace and modify the placefil.txt file
#       --------------------------------------
#	xcopy /d /i header*.inf $(CDDUMP)

!ENDIF
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\browsedi.h ===
//
// BrowseDir.h
//

#ifndef __BROWSEDIR_H__
#define __BROWSEDIR_H__

BOOL BrowseForDirectory(
		HWND hwndParent,
		LPCTSTR pszInitialDir,
		LPTSTR pszBuf,
		int cchBuf,
		LPCTSTR pszDialogTitle,
		BOOL bRemoveTrailingBackslash );

BOOL BrowseForFile(
                HWND hwndParent,
                LPCTSTR pszInitialDir,
                LPTSTR pszBuf,
                int cchBuf);

#endif // !__BROWSEDIR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\browsedi.cpp ===
//
// BrowseDir.cpp
//
//              Functionality for the "Browse Directory" dialog.
//              Requires dialog resource IDD_BROWSEDIRECTORY.
//
// History:
//
//              10/04/95        KenSh           Created
//              10/09/95        KenSh           Fixed bugs, removed globals and statics
//

#include "stdafx.h"
#include <dlgs.h>
#include <direct.h>

//*** Custom window messages
//
#define CM_UPDATEEDIT   (WM_USER + 42)  // Update text in the edit (sent to the dialog)

//*** Dialog control IDs
//
#define IDC_FILENAME    edt1                    // Edit box w/ current directory
#define IDC_FILELIST    lst2                    // Listbox with current directory hierarchy
#define IDC_DRIVECOMBO  cmb2                    // Combo-box with current drive
#define IDC_NETWORK             psh14                   // Network button (added at runtime)

//*** Window property names
//
const TCHAR c_szOFNProp[] = _T("OFNStruct");
const TCHAR c_szRedrawProp[] = _T("Redraw");

//*** Globals
//
//              Note: Use of thse globals assumes that any multiple threads using
//              our subclass at the same time always have the same original edit/
//              combo window procs.  I think this is true.
//
WNDPROC                         g_pfnPrevEditProc;      // original edit proc (before subclass)
WNDPROC                         g_pfnPrevComboProc;     // original combo proc (before subclass)

//*** Local function declarations
//
BOOL CALLBACK BrowseDirDlgHook( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam );
BOOL BrowseDir_OnOK( HWND hwnd );

// This struct is used internally and kept as a window property,
// in lieu of using static variables or MFC.
typedef struct _OFNINFO
{
        OPENFILENAME    ofn;                                            // OFN struct passed to GetOpenFileName
        TCHAR                   szLastDirName[_MAX_PATH];       // last known good directory
        BOOL                    fAllowSetText;                          // should we allow WM_SETTEXT for the Edit
//        BOOL                    fNetworking;                            // is Connect Network Drive dialog open
} OFNINFO, *LPOFNINFO;


//----------------------------------------------------------------------------
// Procedure    BrowseForDirectory
//
// Purpose              Displays a dialog that lets the user choose a directory
//                              name, either local or UNC.
//
// Parameters   hwndParent                      Parent window for the dialog
//                              pszInitialDir           Directory to use as the default
//                              pszBuf                          Where to store the answer
//                              cchBuf                          Number of characters in this buffer
//                              pszDialogTitle          Title for the dialog
//
// Returns              nonzero if successful, zero if not.  If successful, pszBuf
//                              will be filled with the full pathname of the chosen directory.
//
// History              10/06/95        KenSh           Created
//                              10/09/95        KenSh           Use lCustData member instead of global
//

CString strSelectDir;

BOOL BrowseForDirectory(
                HWND hwndParent,
                LPCTSTR pszInitialDir,
                LPTSTR pszBuf,
                int cchBuf,
                LPCTSTR pszDialogTitle,
                BOOL bRemoveTrailingBackslash )
{
        TCHAR szInitialDir[MAX_PATH];
        OFNINFO ofnInfo;

        pszBuf[0] = _T('\0');

        // Prepare the initial directory... add a backslash if it's
        // a 2-character path
        _tcscpy( szInitialDir, pszInitialDir );
        if( !szInitialDir[2] )
        {
                szInitialDir[2] = _T('\\');
                szInitialDir[3] = _T('\0');
        }

        if( pszDialogTitle )
        {
                ofnInfo.ofn.lpstrTitle          = pszDialogTitle;
        }
        else
        {
                MyLoadString( IDS_SELECT_DIR, strSelectDir );

                ofnInfo.ofn.lpstrTitle          = (LPCTSTR)strSelectDir;
        }

        ofnInfo.ofn.lStructSize                 = sizeof(OPENFILENAME);
        ofnInfo.ofn.hwndOwner                   = hwndParent;
        ofnInfo.ofn.hInstance                   = (HINSTANCE) g_MyModuleHandle;
        ofnInfo.ofn.lpstrFilter                 = NULL;
        ofnInfo.ofn.lpstrCustomFilter   = NULL;
        ofnInfo.ofn.nMaxCustFilter              = 0;
        ofnInfo.ofn.nFilterIndex                = 0;
        ofnInfo.ofn.lpstrFile                   = pszBuf;
        ofnInfo.ofn.nMaxFile                    = cchBuf;
        ofnInfo.ofn.lpstrFileTitle              = NULL;
        ofnInfo.ofn.nMaxFileTitle               = 0;
        ofnInfo.ofn.lpstrInitialDir     = szInitialDir;
        ofnInfo.ofn.nFileOffset                 = 0;
        ofnInfo.ofn.nFileExtension              = 0;
        ofnInfo.ofn.lpstrDefExt                 = NULL;
        ofnInfo.ofn.lCustData                   = (LPARAM)&ofnInfo;
        ofnInfo.ofn.lpfnHook                    = (LPOFNHOOKPROC)BrowseDirDlgHook;
        ofnInfo.ofn.lpTemplateName              = MAKEINTRESOURCE( IDD_BROWSEDIRECTORY );
        ofnInfo.ofn.Flags                       = OFN_ENABLEHOOK | OFN_PATHMUSTEXIST |
                                                  OFN_NONETWORKBUTTON | OFN_ENABLETEMPLATE |
                                                  OFN_HIDEREADONLY;

        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("comdlg32:GetOpenFileName().Start.")));
        int nResult = ::GetOpenFileName( &ofnInfo.ofn );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("comdlg32:GetOpenFileName().End.")));

            DWORD dw = 0;
        if (nResult == 0) 
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("comdlg32:CommDlgExtendedError().Start.")));
            dw = CommDlgExtendedError();
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("comdlg32:CommDlgExtendedError().End.")));
        }

        return (BOOL)( IDOK == nResult );
}


//----------------------------------------------------------------------------
// Procedure    pszSkipDriveSpec
//
// Purpose              Returns a pointer to whatever comes after the drive part
//                              of a filename.  For example:
//                  c:\foo\bar.bat         \\server\share\file.txt
//                    ^                                  ^
//
// Returns              Pointer to the appropriate part of the string, or a pointer
//                              to the end of the string if it's not in the right format
//
// History              10/06/95        KenSh           Created
//
LPTSTR pszSkipDriveSpec( LPTSTR pszPathName )
{
        LPTSTR pch = NULL;

        if( pszPathName[0] == _T('\\') && pszPathName[1] == _T('\\') )
        {
                pch = _tcschr(pszPathName+2, _T('\\'));
                if( NULL != pch)
                {
                        LPTSTR pchResult;
                        pchResult = _tcschr( pch, _T('\\') );

                        if( pchResult )
                        {
                                pchResult = _tcschr( pchResult+1, _T('\\') );
                        }

                        if( pchResult )
                        {
                                return pchResult;
                        }
                        else
                        {
                                return _tcschr( pch, _T('\0') );
                        }
                }
                else
                {
                        return _tcschr( pszPathName, _T('\0') );
                }
        }
        else
        {
                pch = _tcschr( pszPathName, _T(':') );

                if( pch )
                {
                        return _tcsinc(pch);
                }
                else
                {
                        return _tcschr( pszPathName, _T('\0') );
                }
        }
}


//----------------------------------------------------------------------------
// Procedure    BrowseDirEditProc
//
// Purpose              Subclassed window proc for the edit control in the Browse
//                              for Directory dialog.  We override the WM_SETTEXT message
//                              to control when the window text can be programatically
//                              changed.
//
// Parameters   standard
//
// Returns              standard
//
// History              10/06/95        KenSh           Created
//                              10/09/95        KenSh           Moved most code into UpdateEditText()
//
LRESULT CALLBACK BrowseDirEditProc( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam )
{
        switch( message )
        {
                // In order to prevent default functionality from setting the Edit's text
                // to strings like "*.*", we capture WM_SETTEXT and only allow it to occur
                // if the fAllowSetText flag is specified in the OFNINFO struct.
                case WM_SETTEXT:
                {
                        LPOFNINFO lpOFNInfo = (LPOFNINFO)GetProp( GetParent(hwnd), c_szOFNProp );

                        if( lpOFNInfo->fAllowSetText )
                        {
                                break;  // default processing
                        }
                        else
                        {
                                return 0L;      // suppress the urge to change the text
                        }
                }

                default:
                        break;
        }

        return CallWindowProc( g_pfnPrevEditProc, hwnd, message, wParam, lParam );
}


//----------------------------------------------------------------------------
// Procedure    BrowseDirComboProc
//
// Purpose              Subclassed window proc for the combo box in the Browse
//                              Directory dialog.  We need to subclass so we can catch the
//                              change to selection after the Network button is used to
//                              switch drives.
//
// Parameters   standard
//
// Returns              standard
//
// History              10/09/95        KenSh           Created
//
LRESULT CALLBACK BrowseDirComboProc( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam )
{
        switch( message )
        {
                // We catch the WM_SETREDRAW message so that we ignore CB_SETCURSEL
                // messages when the combo is not supposed to be updated.  This is
                // pretty much of a hack due to the ordering of messages after the
                // Network button is clicked.
                case WM_SETREDRAW:
                {
                        if( wParam )
                        {
                                SetProp( hwnd, c_szRedrawProp, (HANDLE)1 );
                        }
                        else
                        {
                                if( GetProp( hwnd, c_szRedrawProp ) )
                                {
                                        RemoveProp( hwnd, c_szRedrawProp );
                                }
                        }
                        break;  // continue with default processing
                }

                // We catch CB_SETCURSEL and use it to update our edit box after the
                // Network button has been pressed.
                case CB_SETCURSEL:
                {
                        LPOFNINFO lpOFNInfo = (LPOFNINFO)GetProp( GetParent(hwnd), c_szOFNProp );

#ifdef NEVER
                        // If "Network" was pressed and redraw has been re-enabled...
                        if( lpOFNInfo->fNetworking && GetProp( hwnd, c_szRedrawProp ) )
                        {
                                TCHAR szBuf[_MAX_PATH];
                                LRESULT lResult = CallWindowProc( g_pfnPrevComboProc, hwnd, message, wParam, lParam );

                                // Turn off the networking flag
                                lpOFNInfo->fNetworking = FALSE;

                                // Force the selected drive to be the current drive and
                                // get the current directory on that drive
                                GetWindowText( hwnd, szBuf, _MAX_PATH );
                                _chdrive( _totupper(szBuf[0]) - 'A' + 1 );
                                GetCurrentDirectory( _MAX_PATH, szBuf );

                                // Update the edit box with the new text.
                                lpOFNInfo->fAllowSetText = TRUE;
                                SetDlgItemText( GetParent(hwnd), IDC_FILENAME, szBuf );
                                lpOFNInfo->fAllowSetText = FALSE;
                                SendDlgItemMessage( GetParent(hwnd), IDC_FILENAME, EM_SETSEL, 0, (LPARAM)-1 );

                                return lResult;
                        }
#endif
                        break;
                }

                case WM_DESTROY:
                {
                        if( GetProp( hwnd, c_szRedrawProp ) )
                        {
                                RemoveProp( hwnd, c_szRedrawProp );
                        }
                        break;          // continue with default processing
                }

                default:
                        break;
        }

        return CallWindowProc( g_pfnPrevComboProc, hwnd, message, wParam, lParam );
}


//----------------------------------------------------------------------------
// Procedure    UpdateEditText
//
// Purpose              Based on which control has focus and the current state of
//                              the edit control, calculates the new "current directory" and
//                              sets the Edit control's text to match.
//
// Parameters   hwndDlg         handle to the dialog window.  This function will
//                                                      access the lpOFNInfo window property.
//
// Returns              nothing
//
// History              10/09/95        KenSh           Created
//
VOID UpdateEditText( HWND hwndDlg )
{
        HWND hwndLB = GetDlgItem(hwndDlg, IDC_FILELIST);
        int nCurSel = (int)SendMessage(hwndLB, LB_GETCURSEL, 0, 0);
        TCHAR szDirName[_MAX_PATH];
        LPTSTR pchStart = NULL;
        LPOFNINFO lpOFNInfo = (LPOFNINFO)GetProp( hwndDlg, c_szOFNProp );
        int i;

        HWND hwndFocus = GetFocus();
        int idFocus = GetDlgCtrlID( hwndFocus );

        if( idFocus == IDC_FILELIST )
                // Listbox: build name up through current LB selection
        {
                // First get the top entry in the listbox, this will tell us
                // if it's a connected drive or a UNC drive
                SendMessage( hwndLB, LB_GETTEXT, 0, (LPARAM)szDirName );

                // Run down the entries in the listbox appending them
                // and stop when we get to the current selection.
                if( szDirName[0] == _T('\\') && szDirName[1] == _T('\\') )
                        pchStart = _tcschr(szDirName+2, _T('\0'));
                else
                        pchStart = _tcsinc(szDirName) + 1;      // skip 2 chars, first may be MBCS

                if (NULL != pchStart)
                {
                    for( i = 1; i <= nCurSel; i++ )
                    {
                            if( *pchStart != _T('\\') )
                                    *pchStart = _T('\\');
                            pchStart = _tcsinc(pchStart);
                            SendMessage( hwndLB, LB_GETTEXT, i, (LPARAM)pchStart );
                            pchStart = _tcschr(pchStart, _T('\0'));
                    }
                }
        }
        else if( idFocus == IDC_DRIVECOMBO )
                // Combo box: use current working directory
        {
                GetCurrentDirectory( _MAX_PATH, szDirName );
        }
        else if( idFocus == IDC_FILENAME )
                // Edit control: build the new path using the edit contents
        {
                TCHAR szBuf[_MAX_PATH];

                GetDlgItemText( hwndDlg, IDC_FILENAME, szBuf, _MAX_PATH );

                if( szBuf[0] == _T('\\') )
                {
                        if( szBuf[1] == _T('\\') )
                                // full UNC path was specified
                        {
                                _tcscpy( szDirName, szBuf );
                        }
                        else
                                // new directory on the current drive
                        {
                                _tcscpy( szDirName, lpOFNInfo->szLastDirName );
                                LPTSTR pch = pszSkipDriveSpec(szDirName);
                                _tcscpy( pch, szBuf );
                        }
                }
                else if( *_tcsinc(szBuf) == _T(':') )
                {
                        // Change to the requested drive and use the current directory
                        // on that drive.
                        if( 0 == _chdrive( _totupper(szBuf[0]) - 'A' + 1 ) &&
                                szBuf[2] != _T('\\') )
                        {
                                // It's a legal drive and no directory was specified,
                                // so use the current default.
                                GetCurrentDirectory( _MAX_PATH, szDirName );
                        }
                        else
                        {
                                // A directory was specified or the drive does not exist.
                                // Copy the text verbatim to test it and possibly display
                                // an error message.
                                _tcscpy( szDirName, szBuf );
                        }
                }
                else
                        // Subdirectory of the current directory
                {
                        // Start with the current directory
                        _tcscpy( szDirName, lpOFNInfo->szLastDirName );

                        // Append a backslash if there isn't already one there
                        LPTSTR pch = _tcsrchr( szDirName, _T('\\') );
                        if (pch)
                        {
                            if( *_tcsinc(pch) )
                            {
                                    pch = _tcschr( pch, _T('\0') );
                                    if (pch)
                                    {
                                        *pch = _T('\\');
                                    }
                            }
                            pch = _tcsinc(pch);

                            // Append the new directory name
                            _tcscpy( pch, szBuf );
                        }

                        // Attempt to change into the new directory
                        if( SetCurrentDirectory(szDirName) )
                        {
                                // The directory exists, get the official name and use that
                                // instead of whatever we're using now
                                GetCurrentDirectory( _MAX_PATH, szDirName );
                        }
                }
        }
        else
        {
                // Some other control, likely an error message is going on
                _tcscpy( szDirName, lpOFNInfo->szLastDirName );
        }

        lpOFNInfo->fAllowSetText = TRUE;
        SetDlgItemText( hwndDlg, IDC_FILENAME, szDirName );
        lpOFNInfo->fAllowSetText = FALSE;
}


//----------------------------------------------------------------------------
// Procedure    BrowseDirDlgHook
//
// Purpose              Dialog proc for the Browse for Directory subclassed common
//                              dialog.  We spend most of our effort trying to get the right
//                              string into the edit control (IDC_FILENAME).
//
// Parameters   standard
//
// Returns              TRUE to halt further processing, FALSE to do the default.
//
// History              10/06/95        KenSh           Created
//
BOOL CALLBACK BrowseDirDlgHook( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam )
{
        switch(message)
        {
                case WM_INITDIALOG:
                {
                        LPOFNINFO lpOFNInfo = (LPOFNINFO)((LPOPENFILENAME)lParam)->lCustData;

                        // Store the OFN struct pointer as a window property
                        SetProp( hwnd, c_szOFNProp, (HANDLE)lpOFNInfo );

                        // Initialize the OFNInfo struct
                        _tcscpy( lpOFNInfo->szLastDirName, lpOFNInfo->ofn.lpstrInitialDir );
                        lpOFNInfo->fAllowSetText = FALSE;
                        //lpOFNInfo->fNetworking = FALSE;

                        // Start our edit off with the initial directory
                        SetDlgItemText( hwnd, IDC_FILENAME, lpOFNInfo->ofn.lpstrInitialDir );

                        // Subclass the edit to let us display only what we want to display
                        g_pfnPrevEditProc = (WNDPROC)SetWindowLongPtr(
                                        GetDlgItem(hwnd, IDC_FILENAME),
                                        GWLP_WNDPROC,
                                        (LONG_PTR)BrowseDirEditProc );

                        // Subclass the combo so we know when the Network button has been used.
                        g_pfnPrevComboProc = (WNDPROC)SetWindowLongPtr(
                                        GetDlgItem(hwnd, IDC_DRIVECOMBO),
                                        GWLP_WNDPROC,
                                        (LONG_PTR)BrowseDirComboProc );

                        return TRUE;    // set default focus
                }

                case WM_DESTROY:
                {
                        // Clean up.
                        RemoveProp( hwnd, c_szOFNProp );
                        return FALSE;   // continue with default processing
                }

                case WM_COMMAND:
                {
                        switch( LOWORD(wParam) )
                        {
                                case IDOK:
                                {
                                        return BrowseDir_OnOK( hwnd );
                                }

                                case IDC_FILELIST:      //directory listbox.
                                {
                                        if( HIWORD(wParam) == LBN_DBLCLK )
                                        {
                                                // Post this message telling us to change the edit box.
                                                PostMessage( hwnd, CM_UPDATEEDIT, 0, 0L );
                                        }
                                        return FALSE;   // continue with default processing.
                                }

                                case IDC_DRIVECOMBO:    // drive combo box:
                                {
                                        if( HIWORD(wParam) == CBN_SELCHANGE )
                                        {
                                                // Post this message telling us to change the edit box.
                                                PostMessage( hwnd, CM_UPDATEEDIT, 0, 0L );
                                        }
                                        return FALSE;   // continue with default processing.
                                }

#ifdef NEVER
                                case IDC_NETWORK:       // "Network..." button
                                {
                                        // Set the fNetworking flag which the combo box looks for when
                                        // processing CB_SETCURSEL.
                                        LPOFNINFO lpOFNInfo = (LPOFNINFO)GetProp( hwnd, c_szOFNProp );
                                        lpOFNInfo->fNetworking = TRUE;
                                        return FALSE;   // default processing.
                                }
#endif

                                default:
                                        return FALSE;   // default processing.
                        }
                }

                case CM_UPDATEEDIT:     //update edit box with directory
                {
                        LPOFNINFO lpOFNInfo = (LPOFNINFO)GetProp( hwnd, c_szOFNProp );

                        // Change the text of the edit control.
                        UpdateEditText( hwnd );
                        SendDlgItemMessage( hwnd, IDC_FILENAME, EM_SETSEL, 0, (LPARAM)(INT)-1 );

                        // Store this text as the "last known good" directory
                        GetDlgItemText( hwnd, IDC_FILENAME, lpOFNInfo->szLastDirName, _MAX_PATH );

                        return TRUE;
                }

                default:
                        return FALSE;   //default processing
        }
}


//----------------------------------------------------------------------------
// Procedure    BrowseDir_OnOK
//
// Purpose              Handles a click of the OK button in the Browse Directory
//                              dialog.  We have to do some sneaky stuff here with checking
//                              which control has focus, because we want the dialog to go
//                              away enter when the OK button is clicked directly (i.e. just
//                              hitting Enter doesn't count).
//
// Parameters   hwnd                    The dialog window
//
// Returns              TRUE if processing should halt, FALSE if default processing
//                              should still happen.
//
// History              10/09/95        KenSh           Created
//
BOOL BrowseDir_OnOK( HWND hwnd )
{
        LPOFNINFO lpOFNInfo = (LPOFNINFO)GetProp( hwnd, c_szOFNProp );
        HWND hwndFocus = GetFocus();

        int idFocus = GetDlgCtrlID(hwndFocus);

        if( idFocus != IDC_FILENAME && idFocus != IDC_FILELIST && idFocus != IDC_DRIVECOMBO )
        {
                ASSERT( lpOFNInfo->ofn.lpstrFile != NULL );
                //UpdateEditText( hwnd );
                GetDlgItemText( hwnd, IDC_FILENAME, lpOFNInfo->ofn.lpstrFile, lpOFNInfo->ofn.nMaxFile );

                EndDialog( hwnd, IDOK );

                return TRUE;            // halt processing here.
        }
        else
        {
                // We don't want the dialog to go away at this point.
                // Because the default functionality is expecting
                // a file to be found, not a directory, we must make
                // sure what's been typed in is actually a directory
                // before we hand this message to the default handler.

                TCHAR szBuf[_MAX_PATH];

                // Calculate the new current directory and put it into the Edit
                UpdateEditText( hwnd );

                // Read the newly generated directory name
                GetDlgItemText( hwnd, IDC_FILENAME, szBuf, _MAX_PATH );

                // Update our "last good" directory
                _tcscpy( lpOFNInfo->szLastDirName, szBuf );

                // Post this message to update the edit after the default handler
                // updates the list box
                PostMessage( hwnd, CM_UPDATEEDIT, 0, 0 );

                return FALSE;           // let the original common dialog handle it.
        }
}

BOOL BrowseForFile(
                HWND hwndParent,
                LPCTSTR pszInitialDir,
                LPTSTR pszBuf,
                int cchBuf)
{
        TCHAR szInitialDir[MAX_PATH];
        TCHAR szFileExtension[_MAX_PATH] = _T("");
        LPTSTR p = NULL;
        TCHAR szFileFilter[_MAX_PATH];
        CString csTitle;

        OFNINFO ofnInfo;

        // Prepare the initial directory... add a backslash if it's
        // a 2-character path
        _tcscpy( szInitialDir, pszInitialDir );
        if( !szInitialDir[2] )
        {
                szInitialDir[2] = _T('\\');
                szInitialDir[3] = _T('\0');
        }

        // calculate file extension
        p = _tcsrchr(pszBuf, _T('.'));
        if (p) {
            p = _tcsinc(p);
            if (*p) {
                _tcscpy(szFileExtension, _T("*."));
                _tcscat(szFileExtension, p);
            }
        }

        memset( (PVOID)szFileFilter, 0, sizeof(szFileFilter));
        p = szFileFilter;
        if (*szFileExtension) {
            _tcscpy(p, szFileExtension);
            p = _tcsninc(p, _tcslen(szFileExtension) + 1);
            _tcscpy(p, szFileExtension);
            p = _tcsninc(p, _tcslen(szFileExtension) + 1);
        }
        _tcscpy(p, _T("*.*"));
        p = _tcsninc(p, _tcslen(_T("*.*")) + 1);
        _tcscpy(p, _T("*.*"));

        // dialog title "Locate File"
        MyLoadString(IDS_LOCATE_FILE, csTitle);

        // fill in the OFNINFO struct
        ofnInfo.ofn.lStructSize                 = sizeof(OPENFILENAME);
        ofnInfo.ofn.hwndOwner                   = hwndParent;
        ofnInfo.ofn.hInstance                   = (HINSTANCE) g_MyModuleHandle;
        ofnInfo.ofn.lpstrFilter                 = szFileFilter; // extention of the file we're looking for
        ofnInfo.ofn.lpstrCustomFilter           = NULL;
        ofnInfo.ofn.nMaxCustFilter              = 0;
        ofnInfo.ofn.nFilterIndex                = 1;
        ofnInfo.ofn.lpstrFile                   = pszBuf; // Buffer for file name
        ofnInfo.ofn.nMaxFile                    = cchBuf;
        ofnInfo.ofn.lpstrFileTitle              = NULL;
        ofnInfo.ofn.nMaxFileTitle               = 0;
        ofnInfo.ofn.lpstrInitialDir             = szInitialDir;
        ofnInfo.ofn.lpstrTitle                  = (LPCTSTR)csTitle;
        ofnInfo.ofn.Flags                       = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_EXPLORER |
                                                  OFN_NOCHANGEDIR | OFN_LONGNAMES | OFN_NONETWORKBUTTON;
        ofnInfo.ofn.nFileOffset                 = 0;
        ofnInfo.ofn.nFileExtension              = 0;
        ofnInfo.ofn.lpstrDefExt                 = NULL;
        ofnInfo.ofn.lCustData                   = (LPARAM)&ofnInfo;
        ofnInfo.ofn.lpfnHook                    = NULL;
        ofnInfo.ofn.lpTemplateName              = NULL;

        int nResult = ::GetOpenFileName( &ofnInfo.ofn );

        DWORD dw = 0;
        if (nResult == 0) {
            dw = CommDlgExtendedError();
        }

        if (nResult == IDOK) {
            iisDebugOut((LOG_TYPE_TRACE, _T("pszBuf=%s\n"), pszBuf));
            *(pszBuf + ofnInfo.ofn.nFileOffset - 1) = _T('\0');
        }

        return (BOOL)( IDOK == nResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\inetmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by START.RC
//
#define IDS_NOTSUPPORT                  1
#define IDS_CANTRUN                     2
#define IDS_LOAD1                       3
#define IDS_RUN_NTS                     4
#define IDS_RUN_NTW                     5
#define IDS_RUN_W95                     6
#define IDS_UNABLE_TO_RUN               7
#define IDS_UNABLE_TO_FIND              8
#define IDS_SETUP                       9
#define IDS_TITLE                       9
#define IDS_SETUP_LOAD                  10
#define IDS_UNKNOWN_SERVER_TYPE         11
#define IDS_UNABLE_TO_SETUP             12
#define IDS_CANNOT_RUN_UNC              13
#define IDS_INETSRV_INSTALLED_DIR       14
#define IDI_ICON1                       101
#define IDI_ICON2                       102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\inetmgr\start.c ===
//----------------------------------------------
//
// 16 bit stub to run mmc.exe with parameters
//
//----------------------------------------------
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
#include <string.h>
#include <direct.h>
#include <windows.h>

#include <shellapi.h> // 16-bit Windows header
#include "wownt16.h"  // available from Win32 SDK
#include "resource.h"

#define FILE_TO_RUN            "mmc.exe"
#define FILE_TO_RUN_FILE_PARAM "iis.msc"
#define REG_PRODUCT_KEY    "SYSTEM\\CurrentControlSet\\Control\\ProductOptions"

/* ************************ prototypes ***************************** */
int     RunTheApp(void);
int             HasTheAppStarted(void);
int             CheckIfFileExists(char *input_filespec);
void    PopUpUnableToSomething(char[], int);
void    AddPath(LPSTR szPath, LPCSTR szName );

LRESULT CALLBACK WindowFunc(HWND, UINT, WPARAM, LPARAM);
/* ************************* globals ******************************* */
HANDLE  g_hInstance;
HANDLE  g_hPrevInstance;
LPSTR   g_lpCmdLine;
int     g_nCmdShow;
char    g_szTime[100] = "";
UINT    g_WinExecReturn;
char    g_szWinExecModuleName[260];
char    g_szMsg[_MAX_PATH];
char    g_szSystemDir[_MAX_PATH];
char    g_szSystemDir32[_MAX_PATH];
/* **************************************************************** */
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    HWND hwnd;
    MSG  msg;
    WNDCLASS wcl;
    char szWinName[_MAX_PATH];
    char szBuf[_MAX_PATH];

    g_hInstance = hInstance;
    g_hPrevInstance = hPrevInstance;
    g_lpCmdLine = lpCmdLine;
    g_nCmdShow = nCmdShow;

    LoadString( g_hInstance, IDS_TITLE, szWinName, _MAX_PATH );

    lstrcpy(szBuf, "");

        // note that this will come back as "system" <-- must be because this is a 16bit app
        if (!GetSystemDirectory((LPSTR) szBuf, sizeof(szBuf)))
{return 0;}

        lstrcpy(g_szSystemDir, szBuf);
        lstrcat(g_szSystemDir, "32");
        // set to system if can't find system32 directory
        if (CheckIfFileExists(g_szSystemDir) == FALSE) {lstrcpy(g_szSystemDir, szBuf);}

    // define windows class
    wcl.hInstance = hInstance;
    wcl.lpszClassName = szWinName;
    wcl.lpfnWndProc = WindowFunc;
    wcl.style = 0;
    wcl.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wcl.hCursor = LoadCursor(NULL, IDC_ARROW);
    wcl.lpszMenuName = NULL;
    wcl.cbClsExtra = 0;
    wcl.cbWndExtra = 0;
    wcl.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);

    // register the window class.
    if (!RegisterClass (&wcl)) return 0;

    //hwnd = CreateWindow(szWinName, NULL, WS_DLGFRAME, CW_USEDEFAULT, CW_USEDEFAULT, window_h, window_v, HWND_DESKTOP, NULL, hInstance , NULL);
    hwnd = CreateWindow(szWinName, NULL, WS_DISABLED | WS_CHILD, CW_USEDEFAULT, CW_USEDEFAULT, 10, 10, HWND_DESKTOP, NULL, hInstance , NULL);

    // display the window
    ShowWindow(hwnd, nCmdShow);

    // Start a timer -- interrupt once for 1 seconds
    SetTimer(hwnd, 1, 500, NULL);
    UpdateWindow(hwnd);

        // Return true only if we are able to start the setup program and run it.
    if (!RunTheApp()) {return FALSE;}

        // Check if the process has started by checking for
        // the window that should be run...
        if (HasTheAppStarted()) {PostQuitMessage(0);}

    while(GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    KillTimer(hwnd, 1);
    return (int)(msg.wParam);
}


//***************************************************************************
//*
//* purpose: you know what
//*
//***************************************************************************
LRESULT CALLBACK WindowFunc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        switch(message)
                {
                case WM_TIMER:
                        // Check if the process has started by checking for
                        // the window that should be run...
                        if (HasTheAppStarted()) {PostQuitMessage(0);}
                        break;

            case WM_CREATE:
                        break;

                case WM_PAINT:
                        break;

                case WM_DESTROY:
                        PostQuitMessage(0);
                        break;

                default:
                    return DefWindowProc(hwnd,message,wParam, lParam);
                }

        return 0;
}


//***************************************************************************
//*
//* purpose: return TRUE if the window has started
//*
//***************************************************************************
int RunTheApp(void)
{
    char szIISInstalledPath[_MAX_PATH];
    char szCommandToRun[_MAX_PATH + _MAX_PATH + 50];
    char szTempFilePath[_MAX_PATH];

        // check if our files exist...
    lstrcpy(szTempFilePath, g_szSystemDir);
        AddPath(szTempFilePath, FILE_TO_RUN);
        if (CheckIfFileExists(szTempFilePath) == FALSE) {PopUpUnableToSomething(szTempFilePath, IDS_UNABLE_TO_FIND); return FALSE;}

        // get iis installed directory
    LoadString( g_hInstance, IDS_INETSRV_INSTALLED_DIR, szIISInstalledPath, _MAX_PATH);
    lstrcpy(szTempFilePath, g_szSystemDir);
    AddPath(szTempFilePath, szIISInstalledPath);
    AddPath(szTempFilePath, FILE_TO_RUN_FILE_PARAM);
        if (CheckIfFileExists(szTempFilePath) == FALSE) {PopUpUnableToSomething(szTempFilePath, IDS_UNABLE_TO_FIND); return FALSE;}

    // Create a command line
    //%SystemRoot%\System32\mmc.exe D:\WINNT0\System32\inetsrv\iis.msc
    lstrcpy(szCommandToRun, g_szSystemDir);
        AddPath(szCommandToRun, FILE_TO_RUN);
        lstrcat(szCommandToRun, " ");
    lstrcat(szCommandToRun, g_szSystemDir);
    AddPath(szCommandToRun, szIISInstalledPath);
    AddPath(szCommandToRun, FILE_TO_RUN_FILE_PARAM);

        // Run the executable if the file exists
    g_WinExecReturn = WinExec(szCommandToRun, SW_SHOW);

    if (g_WinExecReturn < 32)
    {
        // we failed on running it.
        PopUpUnableToSomething(szCommandToRun, IDS_UNABLE_TO_RUN);
        return FALSE;
    }
        GetModuleFileName(NULL, g_szWinExecModuleName, sizeof(g_szWinExecModuleName));

        return TRUE;
}


//***************************************************************************
//*
//* purpose: return TRUE if the window has started
//*
//***************************************************************************
int HasTheAppStarted(void)
{
        // do a findwindow for our setup window to
        // see if our setup has started...
        // if it has then return TRUE,  if not return FALSE.
        if (g_WinExecReturn >= 32)
                {
                if (GetModuleHandle(g_szWinExecModuleName))
                //if (GetModuleHandle(g_WinExecReturn))
                        {return TRUE;}
                }

        return FALSE;
}

//***************************************************************************
//*
//* purpose: TRUE if the file is opened, FALSE if the file does not exists.
//*
//***************************************************************************
int CheckIfFileExists (char * szFileName)
{
    char svTemp1[_MAX_PATH];
    char *pdest = NULL;
    char *pTemp = NULL;
    strcpy(svTemp1, szFileName);
    // cut off the trailing \ if need to
    pdest = svTemp1;
    if (*(pdest + (strlen(pdest) - 1)) == '\\')
        {
        pTemp = strrchr(svTemp1, '\\');
        if (pTemp)
	  {*pTemp = '\0';}
        }

  if ((_access(svTemp1,0)) != -1)
        {return TRUE;}
  else
        {return FALSE;}
}


//***************************************************************************
//*
//* purpose: display message that we were unable to runthe exe
//*
//***************************************************************************
void PopUpUnableToSomething(char g_szFilepath[], int WhichString_ID)
{
        char szTempString[_MAX_PATH];
    LoadString( g_hInstance, WhichString_ID, g_szMsg, _MAX_PATH );
        sprintf(szTempString, g_szMsg, g_szFilepath);
        MessageBox(NULL, szTempString, NULL, MB_ICONSTOP);
        return;
}

//***************************************************************************
//*
//* purpose: add's filename onto path
//*
//***************************************************************************
void AddPath(LPSTR szPath, LPCSTR szName )
{
    LPSTR szTmp;
    // Find end of the string
    szTmp = szPath + lstrlen(szPath);
    // If no trailing backslash then add one
    if ( szTmp > szPath && *(AnsiPrev( szPath, szTmp )) != '\\' )
        *(szTmp++) = '\\';
    // Add new name to existing path string
    while ( *szName == ' ' ) szName++;
    lstrcpy( szTmp, szName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\dcomperm.h ===
DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    );

DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    );

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    );

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD,
    BOOL bCreateNewIfNotExist
    );

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    );

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL * pbUserExistsToBeDeleted
    );

DWORD
GetCurrentUserSID (
    PSID *Sid
    );

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    );

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    );

DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    );

DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    );

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal,
    BOOL *pbUserExistsToBeDeleted
    );

DWORD   GetPrincipalSID (LPTSTR Principal,PSID *Sid,BOOL *pbWellKnownSID);
DWORD   ChangeAppIDAccessACL (LPTSTR AppID,LPTSTR Principal,BOOL SetPrincipal,BOOL Permit,BOOL bDumbCall);
DWORD   ChangeAppIDLaunchACL (LPTSTR AppID,LPTSTR Principal,BOOL SetPrincipal,BOOL Permit,BOOL bDumbCall);
DWORD   ChangeDCOMAccessACL (LPTSTR Principal,BOOL SetPrincipal,BOOL Permit,BOOL bDumbCall);
DWORD   ChangeDCOMLaunchACL (LPTSTR Principal,BOOL SetPrincipal,BOOL Permit,BOOL bDumbCall);
BOOL    MakeAbsoluteCopyFromRelative(PSECURITY_DESCRIPTOR  psdOriginal,PSECURITY_DESCRIPTOR* ppsdNew);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\dcomperm.cpp ===
#include "stdafx.h"

#include <conio.h>
#include "dcomperm.h"

#define _WIN32_DCOM
#include <objbase.h>

#define MY_DCOM_PERSIST_FLAG _T("PREEXIST")


int IsValidDaclInSD(PSECURITY_DESCRIPTOR pSD)
{
    int iReturn = TRUE;
    BOOL present = 0;
    BOOL defaultDACL = 0;
    PACL dacl = NULL;

    // Check if the SD is valid

    if (!IsValidSecurityDescriptor(pSD)) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("IsValidDaclInSD:IsValidSecurityDescriptor FAILED")));
        iReturn = FALSE;
    }
    else
    {
        // Check if the dacl we got is valid...
        if (!GetSecurityDescriptorDacl (pSD, &present, &dacl, &defaultDACL)) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("IsValidDaclInSD:GetSecurityDescriptorDacl FAILED")));
            iReturn = FALSE;
        }
        else
        {
            if (present)
            {
                // check if our sd is valid after call
                if (!IsValidSecurityDescriptor(pSD)) 
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("IsValidDaclInSD:IsValidSecurityDescriptor FAILED")));
                    iReturn = FALSE;
                }
                else
                {
                    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("IsValidDaclInSD:SD has valid dacl")));
                }
            }
        }
    }

    return iReturn;
}


DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    LPVOID                ace;
    ACE_HEADER            *aceHeader;
    ULONG                 i;
    DWORD                 returnValue = ERROR_SUCCESS;

    if (0 == IsValidAcl(OldACL))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CopyACL:IsValidAcl.FAILED.ACL is bad.")));
        returnValue = ERROR_INVALID_ACL;
        return returnValue;
    }

    if (0 == GetAclInformation (OldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (aclSizeInfo), AclSizeInformation))
    {
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("CopyACL:GetAclInformation.FAILED.Return=0x%x."), returnValue));
        return returnValue;
    }

    //
    // Copy all of the ACEs to the new ACL
    //

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        //
        // Get the ACE and header info
        //

        if (!GetAce (OldACL, i, &ace))
        {
            returnValue = GetLastError();
            iisDebugOut((LOG_TYPE_ERROR, _T("CopyACL:GetAce.FAILED.Return=0x%x."), returnValue));
            return returnValue;
        }

        aceHeader = (ACE_HEADER *) ace;

        //
        // Add the ACE to the new list
        //

        if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
        {
            returnValue = GetLastError();
            iisDebugOut((LOG_TYPE_ERROR, _T("CopyACL:AddAce.FAILED.Return=0x%x."), returnValue));
            return returnValue;
        }
    }

    return returnValue;
}

DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  newACL = NULL;
    PACL                  oldACL = NULL;
    BOOL                  bWellKnownSID = FALSE;
    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (0 == IsValidAcl(oldACL))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessDeniedACEToACL:IsValidAcl.FAILED.ACL is bad.")));
        returnValue = ERROR_INVALID_ACL;
        return returnValue;
    }

    if (0 == GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_DENIED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    if (!AddAccessDeniedAce (newACL, ACL_REVISION, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    // cleanup old memory whose pointer we're replacing
    // okay to leak in setup... (need to comment out or else av's)
    //if (*Acl) {delete(*Acl);}
    *Acl = newACL;
    newACL = NULL;

cleanup:
    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    if (newACL)
    {
		delete [] newACL;
		newACL = NULL;
    }

    return returnValue;
}

DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  oldACL = NULL;
    PACL                  newACL = NULL;
    BOOL                  bWellKnownSID = FALSE;

    oldACL = *Acl;

    // check if the acl we got passed in is valid!
    if (0 == IsValidAcl(oldACL))
    {
        returnValue = ERROR_INVALID_ACL;
        iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessAllowedACEToACL:IsValidAcl.FAILED.ACL we got passed in is bad1.")));
        goto cleanup;
    }

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetPrincipalSID.FAILED.Return=0x%x."), returnValue));
        return returnValue;
    }

    if (0 == GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation))
    {
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("GetAclInformation.FAILED.Return=0x%x."), returnValue));
        goto cleanup;
    }

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("InitializeAcl.FAILED.Return=0x%x."), returnValue));
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CopyACL.FAILED.Return=0x%x."), returnValue));
        goto cleanup;
    }

    //if (!AddAccessAllowedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    if (!AddAccessAllowedAce (newACL, ACL_REVISION, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessAllowedAce.FAILED.Return=0x%x."), returnValue));
        goto cleanup;
    }

    // check if the acl is valid!
    /*
    if (0 == IsValidAcl(newACL))
    {
        returnValue = ERROR_INVALID_ACL;
        iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessAllowedACEToACL:IsValidAcl.FAILED.ACL we are pasing out is bad.")));
        goto cleanup;
    }
    */

    // cleanup old memory whose pointer we're replacing
    // okay to leak in setup... (need to comment out or else av's)
    //if (*Acl) {delete(*Acl);}
    *Acl = newACL;
    newACL = NULL;

cleanup:
    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }
    if (newACL)
    {
		delete [] newACL;
		newACL = NULL;
    }

    return returnValue;
}

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal,
    BOOL *pbUserExistsToBeDeleted
    )
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    ULONG                   i;
    LPVOID                  ace;
    ACCESS_ALLOWED_ACE      *accessAllowedAce;
    ACCESS_DENIED_ACE       *accessDeniedAce;
    SYSTEM_AUDIT_ACE        *systemAuditAce;
    PSID                    principalSID = NULL;
    DWORD                   returnValue = ERROR_SUCCESS;
    ACE_HEADER              *aceHeader;
    BOOL                    bWellKnownSID = FALSE;

    *pbUserExistsToBeDeleted = FALSE;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    // check if the acl we got passed in is valid!
    if (0 == IsValidAcl(Acl))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("RemovePrincipalFromACL:IsValidAcl.FAILED.ACL is bad.")));
        returnValue = ERROR_INVALID_ACL;
        return returnValue;
    }

    if (0 == GetAclInformation (Acl, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation))
    {
        returnValue = GetLastError();
        return returnValue;
    }

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce (Acl, i, &ace))
        {
            returnValue = GetLastError();
            break;
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce (Acl, i);
                *pbUserExistsToBeDeleted = TRUE;
                break;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce (Acl, i);
                *pbUserExistsToBeDeleted = TRUE;
                break;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce (Acl, i);
                *pbUserExistsToBeDeleted = TRUE;
                break;
            }
        }
    }

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
GetCurrentUserSID (
    PSID *Sid
    )
{
    DWORD dwReturn = ERROR_SUCCESS;
    TOKEN_USER  *tokenUser = NULL;
    HANDLE      tokenHandle = NULL;
    DWORD       tokenSize;
    DWORD       sidLength;

    if (OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
    {
        GetTokenInformation (tokenHandle, TokenUser, tokenUser, 0, &tokenSize);

        tokenUser = (TOKEN_USER *) malloc (tokenSize);
        if (!tokenUser)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return GetLastError();
        }

        if (GetTokenInformation (tokenHandle, TokenUser, tokenUser, tokenSize, &tokenSize))
        {
            sidLength = GetLengthSid (tokenUser->User.Sid);
            *Sid = (PSID) malloc (sidLength);
            if (*Sid)
            {
                memcpy (*Sid, tokenUser->User.Sid, sidLength);
            }
            CloseHandle (tokenHandle);
        } else
            dwReturn = GetLastError();

        if (tokenUser)
            free(tokenUser);

    } else
        dwReturn = GetLastError();

    return dwReturn;
}

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetPrincipalSID():Principal=%s\n"), Principal));

    DWORD returnValue=ERROR_SUCCESS;
    CString csPrincipal = Principal;
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));
    csPrincipal.MakeLower();
    if ( csPrincipal.Find(_T("administrators")) != -1 ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;

    } else if (csPrincipal.Find(_T("system")) != -1) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;

    } else if (csPrincipal.Find(_T("networkservice")) != -1) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_NETWORK_SERVICE_RID;

    } else if (csPrincipal.Find(_T("service")) != -1) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SERVICE_RID;

    } else if (csPrincipal.Find(_T("interactive")) != -1) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;

    } else if (csPrincipal.Find(_T("everyone")) != -1) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;

    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority, 
                                    (BYTE)Count, 
		                            dwRID[0], 
		                            dwRID[1], 
		                            dwRID[2], 
		                            dwRID[3], 
		                            dwRID[4], 
		                            dwRID[5], 
		                            dwRID[6], 
		                            dwRID[7], 
                                    Sid) ) {
            returnValue = GetLastError();
        }
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           Principal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();

        if (returnValue == ERROR_INSUFFICIENT_BUFFER) {
            *Sid = (PSID) malloc (sidSize);
            if (!*Sid)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return GetLastError();
            }
            refDomainSize = 255;

            if (!LookupAccountName (NULL,
                                    Principal,
                                    *Sid,
                                    &sidSize,
                                    refDomain,
                                    &refDomainSize,
                                    &snu))
            {
                returnValue = GetLastError();
            } else {
                returnValue = ERROR_SUCCESS;
            }
        }
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetPrincipalSID():Ret=0x%x."), returnValue));
    return returnValue;
}

DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    )
{
    PACL    dacl = NULL;
    DWORD   sidLength;
    PSID    sid;
    PSID    groupSID;
    PSID    ownerSID;
    DWORD   returnValue;

    *SD = NULL;

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CreateNewSD()")));

    returnValue = GetCurrentUserSID (&sid);
    if (returnValue != ERROR_SUCCESS) {
        if (sid)
            free(sid);

        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.FAILED1.Return=0x%x."), returnValue));
        return returnValue;
    }

    sidLength = GetLengthSid (sid);

    *SD = (SECURITY_DESCRIPTOR *) malloc (
        (sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength) +
        (2 * sidLength) +
        sizeof (SECURITY_DESCRIPTOR));

    if (!*SD)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.FAILED2.Return=0x%x."), returnValue));
        return returnValue;
    }

    groupSID = (SID *) (*SD + 1);
    ownerSID = (SID *) (((BYTE *) groupSID) + sidLength);
    dacl = (ACL *) (((BYTE *) ownerSID) + sidLength);

    if (!InitializeSecurityDescriptor (*SD, SECURITY_DESCRIPTOR_REVISION))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.FAILED3.Return=0x%x."), returnValue));
        return returnValue;
    }

    if (!InitializeAcl (dacl,
                        sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength,
                        ACL_REVISION2))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.FAILED4.Return=0x%x."), returnValue));
        return returnValue;
    }

    if (!AddAccessAllowedAce (dacl,
                              ACL_REVISION2,
                              COM_RIGHTS_EXECUTE,
                              sid))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.FAILED5.Return=0x%x."), returnValue));
        return returnValue;
    }

    if (!SetSecurityDescriptorDacl (*SD, TRUE, dacl, FALSE))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.FAILED6.Return=0x%x."), returnValue));
        return returnValue;
    }

    memcpy (groupSID, sid, sidLength);
    if (!SetSecurityDescriptorGroup (*SD, groupSID, FALSE))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.FAILED7.Return=0x%x."), returnValue));
        return returnValue;
    }

    memcpy (ownerSID, sid, sidLength);
    if (!SetSecurityDescriptorOwner (*SD, ownerSID, FALSE))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.FAILED8.Return=0x%x."), returnValue));
        return returnValue;
    }

    // check if everything went ok 
    if (!IsValidSecurityDescriptor(*SD)) 
    {
        free (*SD);
        free (sid);
        returnValue = ERROR_INVALID_SECURITY_DESCR;
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateNewSD.IsValidDaclInSD.FAILED.Return=0x%x."), returnValue));
        return returnValue;
    }
    
    
    if (sid)
        free(sid);
    return ERROR_SUCCESS;
}


DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    )
{
    PSECURITY_DESCRIPTOR  sd = NULL;
    DWORD                 descriptorSize;
    DWORD                 daclSize;
    DWORD                 saclSize;
    DWORD                 ownerSIDSize;
    DWORD                 groupSIDSize;
    PACL                  dacl = NULL;
    PACL                  sacl = NULL;
    PSID                  ownerSID = NULL;
    PSID                  groupSID = NULL;
    BOOL                  present;
    BOOL                  systemDefault;

    //
    // Get SACL
    //

    if (!GetSecurityDescriptorSacl (OldSD, &present, &sacl, &systemDefault))
        return GetLastError();

    if (sacl && present)
    {
        saclSize = sacl->AclSize;
    } else saclSize = 0;

    //
    // Get DACL
    //

    if (!GetSecurityDescriptorDacl (OldSD, &present, &dacl, &systemDefault))
        return GetLastError();


    if (dacl && present)
    {
        daclSize = dacl->AclSize;
    } else daclSize = 0;

    //
    // Get Owner
    //

    if (!GetSecurityDescriptorOwner (OldSD, &ownerSID, &systemDefault))
        return GetLastError();

    ownerSIDSize = GetLengthSid (ownerSID);

    //
    // Get Group
    //

    if (!GetSecurityDescriptorGroup (OldSD, &groupSID, &systemDefault))
        return GetLastError();

    groupSIDSize = GetLengthSid (groupSID);

    //
    // Do the conversion
    //

    descriptorSize = 0;

    MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                    &saclSize, ownerSID, &ownerSIDSize, groupSID,
                    &groupSIDSize);

    sd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (!sd)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return GetLastError();
    }
    if (!InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION))
        return GetLastError();

    if (!MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                         &saclSize, ownerSID, &ownerSIDSize, groupSID,
                         &groupSIDSize))
        return GetLastError();

    *NewSD = sd;
    return ERROR_SUCCESS;
}

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    )
{
    DWORD   returnValue;
    DWORD   disposition;
    HKEY    registryKey;

    //
    // Create new key or open existing key
    //

    returnValue = RegCreateKeyEx (RootKey, KeyName, 0, _T(""), 0, KEY_ALL_ACCESS, NULL, &registryKey, &disposition);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    //
    // Write the security descriptor
    //

    returnValue = RegSetValueEx (registryKey, ValueName, 0, REG_BINARY, (LPBYTE) SD, GetSecurityDescriptorLength (SD));
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD,
    BOOL bCreateNewIfNotExist
    )
{
    DWORD               returnValue = E_FAIL;
    HKEY                registryKey;
    DWORD               valueType = 0;
    DWORD               valueSize = 0;

    *NewSD = FALSE;

    //
    // Get the security descriptor from the named value. If it doesn't
    // exist, create a fresh one.
    //
    returnValue = RegOpenKeyEx (RootKey, KeyName, 0, KEY_ALL_ACCESS, &registryKey);
    if (returnValue != ERROR_SUCCESS)
    {
        if (returnValue == ERROR_FILE_NOT_FOUND)
        {
            // okay it doesn't exist
            // shall we create a new one???
            if (TRUE == bCreateNewIfNotExist)
            {
                *SD = NULL;
                returnValue = CreateNewSD (SD);
                if (returnValue != ERROR_SUCCESS) 
                {
                    if (*SD){free(*SD);*SD=NULL;}
                    goto GetNamedValueSD_Exit;
                }

                *NewSD = TRUE;
                returnValue = ERROR_SUCCESS;

                //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetNamedValueSD:key not exist.New SD created")));
                goto GetNamedValueSD_Exit;
            }
            else
            {
                return ERROR_FILE_NOT_FOUND;
            }
        }
        else
        {
            goto GetNamedValueSD_Exit;
        }
    }

    returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, NULL, &valueSize);
    if (returnValue && returnValue != ERROR_INSUFFICIENT_BUFFER)
    {
        if (returnValue == ERROR_FILE_NOT_FOUND)
        {
            // okay it doesn't exist
            // shall we create a new one???
            if (TRUE == bCreateNewIfNotExist)
            {
                *SD = NULL;
                returnValue = CreateNewSD (SD);
                if (returnValue != ERROR_SUCCESS) 
                {
                    if (*SD){free(*SD);*SD=NULL;}
                    goto GetNamedValueSD_Exit;
                }
                //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetNamedValueSD:key exist, but value not found.New SD created")));
                *NewSD = TRUE;
            }
            else
            {
                return ERROR_FILE_NOT_FOUND;
            }
        }
        else
        {
            goto GetNamedValueSD_Exit;
        }

    }
    else
    {
        *SD = (SECURITY_DESCRIPTOR *) malloc (valueSize);
        if (!*SD)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            returnValue = ERROR_NOT_ENOUGH_MEMORY;
            goto GetNamedValueSD_Exit;
        }

        // get the SD from the registry
        returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, (LPBYTE) *SD, &valueSize);
        if (returnValue != ERROR_SUCCESS)
        {
            if (*SD){free(*SD);*SD=NULL;}

            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) 
            {
                if (*SD){free(*SD);*SD=NULL;}
                goto GetNamedValueSD_Exit;
            }

            //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetNamedValueSD:key exist,no mem.New SD created")));
            *NewSD = TRUE;
        }
        else
        {
            // otherwise, we successfully got the SD from an existing key!
            // let's test if the one we got is valid.
            // if it's not then log the error and create a new one.

            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetNamedValueSD:key exist using SD from reg")));

            // check if our sd we got or created is valid
            if (!IsValidDaclInSD(*SD)) 
            {
                returnValue = ERROR_INVALID_SECURITY_DESCR;
                iisDebugOut((LOG_TYPE_ERROR, _T("Security Descriptor at [%s\\%s] is not valid.creating a new one temporarily to work around problem"),KeyName,ValueName));

                // try to just create a new one!
                if (*SD){free(*SD);*SD=NULL;}

                *SD = NULL;
                returnValue = CreateNewSD (SD);
                if (returnValue != ERROR_SUCCESS) 
                {
                    if (*SD){free(*SD);*SD=NULL;}
                    goto GetNamedValueSD_Exit;
                }
                *NewSD = TRUE;
            }
        }
    }

    RegCloseKey (registryKey);
    returnValue = ERROR_SUCCESS;

GetNamedValueSD_Exit:
    return returnValue;
}

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl = NULL;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;
    BOOL                fCreateNewSDIfOneInRegNotThere = TRUE;

    //
    // Get security descriptor from registry or create a new one
    //
    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD, fCreateNewSDIfOneInRegNotThere);
    if (returnValue != ERROR_SUCCESS)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetNamedValueSD.FAILED.Return=0x%x."), returnValue));
        return returnValue;
    }

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("GetSecurityDescriptorDacl.FAILED.Return=0x%x."), returnValue));
        goto Cleanup;
    }

    if (newSD)
    {
        returnValue = AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("SYSTEM"));
        if (returnValue != ERROR_SUCCESS)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessAllowedACEToACL(SYSTEM).FAILED.Return=0x%x."), returnValue));
        }

        returnValue = AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("INTERACTIVE"));
        if (returnValue != ERROR_SUCCESS)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessAllowedACEToACL(INTERACTIVE).FAILED.Return=0x%x."), returnValue));
        }
    }

    //
    // Add the Principal that the caller wants added
    //

    if (Permit)
    {
        returnValue = AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, Principal);
        if (returnValue != ERROR_SUCCESS)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessAllowedACEToACL(%s).FAILED.Return=0x%x."), Principal,returnValue));
        }
    }
    else
    {
        returnValue = AddAccessDeniedACEToACL (&dacl, GENERIC_ALL, Principal);
    }
    if (returnValue != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute); 
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("SetSecurityDescriptorDacl.FAILED.Return=0x%x."), returnValue));
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!sdSelfRelative)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("MakeSelfRelativeSD.FAILED.Return=0x%x."), returnValue));
        goto Cleanup;
    }


    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("MakeSelfRelativeSD.FAILED.Return=0x%x."), returnValue));
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    returnValue = SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);
    if (ERROR_SUCCESS != returnValue)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetNamedValueSD.FAILED.Return=0x%x."), returnValue));
    }

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute) 
        free (sdAbsolute);

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddPrincipalToNamedValueSD:%s.end\n"), Principal));
    return returnValue;
}

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL * pbUserExistsToBeDeleted
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl = NULL;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;
    BOOL                fCreateNewSDIfOneInRegNotThere = FALSE;

    *pbUserExistsToBeDeleted = FALSE;

    //
    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD, fCreateNewSDIfOneInRegNotThere);
    if (returnValue == ERROR_FILE_NOT_FOUND)
    {
        // this means that there is no SD in registry, so
        // there is nothing to remove from it, just exit with successs!
        returnValue = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
    {
        return returnValue;
    }

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    // check if the acl we got passed in is valid!
    if (present && dacl)
    {
        if (0 == IsValidAcl(dacl))
        {
            returnValue = ERROR_INVALID_ACL;
            goto Cleanup;
        }
    }

    //
    // If the security descriptor is new, add the required Principals to it
    //
    if (newSD)
    {
        // but if this is a removal, then don't add system and interactive!
        // AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("SYSTEM"));
        // AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("INTERACTIVE"));
    }

    //
    // Remove the Principal that the caller wants removed
    //

    returnValue = RemovePrincipalFromACL (dacl, Principal,pbUserExistsToBeDeleted);
    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute); 
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!sdSelfRelative)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute)
        free (sdAbsolute);

    return returnValue;
}

DWORD
ChangeAppIDAccessACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit,
    BOOL bDumbCall
    )
{
    BOOL bUserExistsToBeDeleted = FALSE;
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeAppIDAccessACL():APPID=%s,Principal=%s.  \n"), AppID, Principal));

    TCHAR   keyName [256];
    DWORD   err;

    CString csKey;
    CString csData;

    if (AppID [0] == _T('{'))
        _stprintf (keyName, _T("APPID\\%s"), AppID); 
    else
        _stprintf (keyName, _T("APPID\\{%s}"), AppID);

    csKey = keyName;
    csKey += _T(":A:");
    csKey += Principal;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal,&bUserExistsToBeDeleted);
        if (TRUE == bUserExistsToBeDeleted)
        {
            // this means that in fact the user was already in there!
            // so we now have to add it back in!
            // we just want to make sure we know that it was already in there
            // so when we do an uninstall -- we don't delete the value if it was already in there!
            if (FALSE == bDumbCall)
            {
                // Do not set this on an upgrade!
                if (g_pTheApp->m_eInstallMode != IM_UPGRADE)
                {
                    g_pTheApp->UnInstallList_Add(csKey,MY_DCOM_PERSIST_FLAG);
                }
            }
        }
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal, Permit);
		if (FAILED(err))
		{
			iisDebugOut((LOG_TYPE_ERROR, _T("AddPrincipalToNamedValueSD():Principal=%s.End.FAILED.Return=0x%x."), Principal, err));
		}
    }
    else
    {
        if (TRUE == bDumbCall)
        {
            csData = g_pTheApp->UnInstallList_QueryKey(csKey);
            if (_tcsicmp(csData, MY_DCOM_PERSIST_FLAG) == 0)
            {
                // don't remove it!! it was already there before we even added it!
                err = ERROR_SUCCESS;
            }
            else
            {
                err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal,&bUserExistsToBeDeleted);
            }
            g_pTheApp->UnInstallList_DelKey(csKey);
        }
        else
        {
            err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal,&bUserExistsToBeDeleted);
        }
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeAppIDAccessACL():APPID=%s,Principal=%s.  End.  Return=0x%x\n"), AppID, Principal, err));
    return err;
}

DWORD
ChangeAppIDLaunchACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit,
    BOOL bDumbCall
    )
{
    BOOL bUserExistsToBeDeleted = FALSE;
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeAppIDLaunchACL():APPID=%s,Principal=%s. Start."), AppID, Principal));

    TCHAR   keyName [256];
    DWORD   err;
    CString csKey;
    CString csData;

    if (AppID [0] == _T('{'))
        _stprintf (keyName, _T("APPID\\%s"), AppID); 
    else
        _stprintf (keyName, _T("APPID\\{%s}"), AppID);

    csKey = keyName;
    csKey += _T(":L:");
    csKey += Principal;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal,&bUserExistsToBeDeleted);
        if (TRUE == bUserExistsToBeDeleted)
        {
            // this means that in fact the user was already in there!
            // so we now have to add it back in!
            // we just want to make sure we know that it was already in there
            // so when we do an uninstall -- we don't delete the value if it was already in there!
            if (FALSE == bDumbCall)
            {
                // Do not set this on an upgrade!
                if (g_pTheApp->m_eInstallMode != IM_UPGRADE)
                {
                    g_pTheApp->UnInstallList_Add(csKey,MY_DCOM_PERSIST_FLAG);
                }
            }
        }
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal, Permit);
		if (FAILED(err))
		{
			iisDebugOut((LOG_TYPE_ERROR, _T("AddPrincipalToNamedValueSD():Principal=%s.End.FAILED.Return=0x%x."), Principal, err));
		}
    }
    else
    {
        if (TRUE == bDumbCall)
        {
            err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal,&bUserExistsToBeDeleted);
        }
        else
        {
            csData = g_pTheApp->UnInstallList_QueryKey(csKey);
            if (_tcsicmp(csData, MY_DCOM_PERSIST_FLAG) == 0)
            {
                // don't remove it!! it was already there before we even added it!
                err = ERROR_SUCCESS;
            }
            else
            {
                err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal,&bUserExistsToBeDeleted);
            }
            g_pTheApp->UnInstallList_DelKey(csKey);
        }
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeAppIDLaunchACL():APPID=%s,Principal=%s.End.  Return=0x%x"), AppID, Principal, err));
    return err;
}

DWORD
ChangeDCOMAccessACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit,
    BOOL bDumbCall
    )
{
    BOOL bUserExistsToBeDeleted = FALSE;
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeDCOMAccessACL():Principal=%s. Start.\n"), Principal));

    TCHAR   keyName [256] = _T("Software\\Microsoft\\OLE");
    DWORD   err;
    CString csKey;
    CString csData;
    csKey = _T("DCOM_DA:");
    csKey += Principal;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal,&bUserExistsToBeDeleted);
        if (TRUE == bUserExistsToBeDeleted)
        {
            // this means that in fact the user was already in there!
            // so we now have to add it back in!
            // we just want to make sure we know that it was already in there
            // so when we do an uninstall -- we don't delete the value if it was already in there!
            if (FALSE == bDumbCall)
            {
                // Do not set this on an upgrade!
                if (g_pTheApp->m_eInstallMode != IM_UPGRADE)
                {
                    g_pTheApp->UnInstallList_Add(csKey,MY_DCOM_PERSIST_FLAG);
                }
            }
        }
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal, Permit);
		if (FAILED(err))
		{
			iisDebugOut((LOG_TYPE_ERROR, _T("ChangeDCOMAccessACL():Principal=%s.End.FAILED.Return=0x%x."), Principal, err));
		}
    }
    else
    {
        // Should we remove this principle from there?
        // we should only do it if we actually had added them.
        // the problem is that before iis5.1 we didn't have this information
        // so when we go look in the registry to find "DCOM_DA:iusr_computername", we won't find it
        // because iis5.1 setup hasn't been run yet.

        // if "DCOM_DA:IUSR_COMPUTERNAME" exists and it is = MY_DCOM_PERSIST_FLAG
        // then do not allow the entry to be deleted!
        // that's because iis5.1 when trying to add the entry -- found that it was already there!
        if (TRUE == bDumbCall)
        {
            err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal,&bUserExistsToBeDeleted);
        }
        else
        {
            csData = g_pTheApp->UnInstallList_QueryKey(csKey);
            if (_tcsicmp(csData, MY_DCOM_PERSIST_FLAG) == 0)
            {
                // don't remove it!! it was already there before we even added it!
                err = ERROR_SUCCESS;
            }
            else
            {
                err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal,&bUserExistsToBeDeleted);
            }
            g_pTheApp->UnInstallList_DelKey(csKey);
        }
    }
    iisDebugOut((LOG_TYPE_TRACE, _T("ChangeDCOMAccessACL():End.Return=0x%x"), err));
    return err;
}

DWORD
ChangeDCOMLaunchACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit,
    BOOL bDumbCall
    )
{
    BOOL bUserExistsToBeDeleted = FALSE;

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeDCOMLaunchACL():Principal=%s. Start.\n"), Principal));

    TCHAR   keyName [256] = _T("Software\\Microsoft\\OLE");
    DWORD   err;

    CString csKey;
    CString csData;
    csKey = _T("DCOM_DL:");
    csKey += Principal;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal,&bUserExistsToBeDeleted);
        if (TRUE == bUserExistsToBeDeleted)
        {
            // this means that in fact the user was already in there!
            // so we now have to add it back in!
            // we just want to make sure we know that it was already in there
            // so when we do an uninstall -- we don't delete the value if it was already in there!
            if (FALSE == bDumbCall)
            {
              // Do not set this on an upgrade!
              if (g_pTheApp->m_eInstallMode != IM_UPGRADE)
              {
                  g_pTheApp->UnInstallList_Add(csKey,MY_DCOM_PERSIST_FLAG);
              }
            }
        }

        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal, Permit);
		if (FAILED(err))
		{
			iisDebugOut((LOG_TYPE_ERROR, _T("ChangeDCOMLaunchACL():Principal=%s.End.FAILED.Return=0x%x"), Principal, err));
		}
    }
    else
    {

        // Should we remove this principle from there?
        // we should only do it if we actually had added them.
        // the problem is that before iis5.1 we didn't have this information
        // so when we go look in the registry to find "DCOM_DL:iusr_computername", we won't find it
        // because iis5.1 setup hasn't been run yet.

        // if "DCOM_DL:IUSR_COMPUTERNAME" exists and it is = MY_DCOM_PERSIST_FLAG
        // then do not allow the entry to be deleted!
        // that's because iis5.1 when trying to add the entry -- found that it was already there!
        if (TRUE == bDumbCall)
        {
            err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal,&bUserExistsToBeDeleted);
        }
        else
        {
            csData = g_pTheApp->UnInstallList_QueryKey(csKey);
            if (_tcsicmp(csData, MY_DCOM_PERSIST_FLAG) == 0)
            {
                // don't remove it!! it was already there before we even added it!
                err = ERROR_SUCCESS;
            }
            else
            {
                err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal,&bUserExistsToBeDeleted);
            }
            g_pTheApp->UnInstallList_DelKey(csKey);
        }
    }
    iisDebugOut((LOG_TYPE_TRACE, _T("ChangeDCOMLaunchACL():End.\n"), err));
    return err;
}



BOOL
MakeAbsoluteCopyFromRelative(
    PSECURITY_DESCRIPTOR  psdOriginal,
    PSECURITY_DESCRIPTOR* ppsdNew
    )
{
    // we have to find out whether the original is already self-relative
    SECURITY_DESCRIPTOR_CONTROL         sdc = 0;
    PSECURITY_DESCRIPTOR                psdAbsoluteCopy = NULL;
    DWORD                               dwRevision = 0;
    DWORD                               cb = 0;
    PACL Dacl = NULL, Sacl = NULL;

    BOOL                                bDefaulted;
    PSID Owner = NULL, Group = NULL;

    DWORD                               dwDaclSize = 0;
    BOOL                                bDaclPresent = FALSE;
    DWORD                               dwSaclSize = 0;
    BOOL                                bSaclPresent = FALSE;

    DWORD                               dwOwnerSize = 0;
    DWORD                               dwPrimaryGroupSize = 0;

    if( !IsValidSecurityDescriptor( psdOriginal ) ) {
        return FALSE;
    }

    if( !GetSecurityDescriptorControl( psdOriginal, &sdc, &dwRevision ) ) {
        DWORD err = GetLastError();
        goto cleanup;
    }

    if( sdc & SE_SELF_RELATIVE ) {
        // the original is in self-relative format, build an absolute copy

        // get the dacl
        if( !GetSecurityDescriptorDacl(
                                      psdOriginal,      // address of security descriptor
                                      &bDaclPresent,    // address of flag for presence of disc. ACL
                                      &Dacl,           // address of pointer to ACL
                                      &bDefaulted       // address of flag for default disc. ACL
                                      )
          ) {
            goto cleanup;
        }

        // get the sacl
        if( !GetSecurityDescriptorSacl(
                                      psdOriginal,      // address of security descriptor
                                      &bSaclPresent,    // address of flag for presence of disc. ACL
                                      &Sacl,           // address of pointer to ACL
                                      &bDefaulted       // address of flag for default disc. ACL
                                      )
          ) {
            goto cleanup;
        }

        // get the owner
        if( !GetSecurityDescriptorOwner(
                                       psdOriginal,    // address of security descriptor
                                       &Owner,        // address of pointer to owner security
                                       // identifier (SID)
                                       &bDefaulted     // address of flag for default
                                       )
          ) {
            goto cleanup;
        }

        // get the group
        if( !GetSecurityDescriptorGroup(
                                       psdOriginal,    // address of security descriptor
                                       &Group, // address of pointer to owner security
                                       // identifier (SID)
                                       &bDefaulted     // address of flag for default
                                       )
          ) {
            goto cleanup;
        }

        // get required buffer size
        cb = 0;
        MakeAbsoluteSD(
                      psdOriginal,              // address of self-relative SD
                      psdAbsoluteCopy,          // address of absolute SD
                      &cb,                      // address of size of absolute SD
                      NULL,                     // address of discretionary ACL
                      &dwDaclSize,              // address of size of discretionary ACL
                      NULL,                     // address of system ACL
                      &dwSaclSize,              // address of size of system ACL
                      NULL,                     // address of owner SID
                      &dwOwnerSize,             // address of size of owner SID
                      NULL,                     // address of primary-group SID
                      &dwPrimaryGroupSize       // address of size of group SID
                      );

        // alloc the memory
        psdAbsoluteCopy = (PSECURITY_DESCRIPTOR) malloc( cb );
        Dacl = (PACL) malloc( dwDaclSize );
        Sacl = (PACL) malloc( dwSaclSize );
        Owner = (PSID) malloc( dwOwnerSize );
        Group = (PSID) malloc( dwPrimaryGroupSize );

        if(NULL == psdAbsoluteCopy ||
           NULL == Dacl ||
           NULL == Sacl ||
           NULL == Owner ||
           NULL == Group
          ) {
            goto cleanup;
        }

        // make the copy
        if( !MakeAbsoluteSD(
                           psdOriginal,            // address of self-relative SD
                           psdAbsoluteCopy,        // address of absolute SD
                           &cb,                    // address of size of absolute SD
                           Dacl,                  // address of discretionary ACL
                           &dwDaclSize,            // address of size of discretionary ACL
                           Sacl,                  // address of system ACL
                           &dwSaclSize,            // address of size of system ACL
                           Owner,                 // address of owner SID
                           &dwOwnerSize,           // address of size of owner SID
                           Group,          // address of primary-group SID
                           &dwPrimaryGroupSize     // address of size of group SID
                           )
          ) {
            goto cleanup;
        }
    } else {
        // the original is in absolute format, fail
        goto cleanup;
    }

    *ppsdNew = psdAbsoluteCopy;

    // paranoia check
    if( !IsValidSecurityDescriptor( *ppsdNew ) ) {
        goto cleanup;
    }
    if( !IsValidSecurityDescriptor( psdOriginal ) ) {
        goto cleanup;
    }

    return(TRUE);

cleanup:
    if( Dacl != NULL && bDaclPresent == TRUE ) {
        free((PVOID) Dacl );
        Dacl = NULL;
    }
    if( Sacl != NULL && bSaclPresent == TRUE ) {
        free((PVOID) Sacl );
        Sacl = NULL;
    }
    if( Owner != NULL ) {
        free((PVOID) Owner );
        Owner = NULL;
    }
    if( Group != NULL ) {
        free((PVOID) Group );
        Group = NULL;
    }
    if( psdAbsoluteCopy != NULL ) {
        free((PVOID) psdAbsoluteCopy );
        psdAbsoluteCopy = NULL;
    }

    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\depends.cpp ===
#include "stdafx.h"
#include <objbase.h>
#include <delayimp.h>
#include "depends.h"
#include "other.h"


//******************************************************************************
// CDepends :: Constructor/Destructor
//******************************************************************************
CDepends::CDepends() :
   m_hFile(NULL),
   m_lpvFile(NULL),
   m_pIFH(NULL),
   m_pIOH(NULL),
   m_pISH(NULL),
   m_fOutOfMemory(FALSE),
   m_fCircularError(FALSE),
   m_fMixedMachineError(FALSE),
   m_dwMachineType((DWORD)-1),
   m_pModuleRoot(NULL),
   m_cxOrdinal(0),
   m_cxHint(0),
   m_cImports(0),
   m_cExports(0)
{
   m_cstrlstListOfBrokenLinks.RemoveAll();
   m_iNumberOfBrokenLinks = 0;
}
//******************************************************************************
CDepends::~CDepends() {
}



//******************************************************************************
BOOL CDepends::SetInitialFilename(LPCSTR szPath) {

   // Set our current directory to the directory that the file is in. We need to
   // do this so our file search can find dependents that happen to be in the
   // same directory that our target file is in.
   CString strDir(szPath);
   strDir = strDir.Left(strDir.ReverseFind('\\') + 1);
   SetCurrentDirectory(strDir);

   // Create our root module node.
   if (m_pModuleRoot = CreateModule(szPath, 0))
   {
      // Start the recursion on the head module to process all modules.
      ProcessModule(m_pModuleRoot);
   }
   else
   {
      m_fOutOfMemory = TRUE;
   }

   // If we ran out of memory while processing the module, then free our
   // document data, display an error, and fail the document from loading.
   // Out of memory is a fairly major error.  If this should occur, MFC will
   // most likely notice and report the problem before we do.
   if (m_fOutOfMemory)
   {
      DeleteContents();
      //CString strError("Not enough memory to process \"");
      //strError += m_pModuleRoot->m_pData->m_szPath;
      //strError += "\"!";
      //MessageBox(strError, "Dependency Walker Error", MB_ICONERROR | MB_OK);
      return FALSE;
   }

   // Display a message if the module contains a circular dependency error.
   if (m_fCircularError)
   {
      //CString strError("\"");
      //strError += m_pModuleRoot->m_pData->m_szPath;
      //strError += "\" will fail to load due to circular dependencies.";
      //g_pMainFrame->MessageBox(strError, "Dependency Walker Module Error",MB_ICONERROR | MB_OK);
   }

   // Display a message if the module contains a mixed machine error.
   if (m_fMixedMachineError) {
      //CString strError("\"");
      //strError += m_pModuleRoot->m_pData->m_szPath;
      //strError += "\" will fail to load due to a mismatched machine type with "
      //            "one or more of the dependent modules.";
      //g_pMainFrame->MessageBox(strError, "Dependency Walker Module Error", MB_ICONERROR | MB_OK);
   }

   return TRUE;
}

CModule* CDepends::LoopThruAndPrintLosers(CModule *pModuleCur)
{
    TCHAR szBigString[_MAX_PATH + _MAX_PATH];
    LPWSTR  pwszModuleName = NULL;

    //
    // loop thru the linked list and look for
    // items marked with m_fExportError
    //
   if (!pModuleCur) {
      return NULL;
   }

   // check to see if our current module is marked with m_fExportError
   // Check to see if our current module matches our search module.
   if (pModuleCur->m_fExportError == TRUE)
   {
        // Convert the filename to unicode.
        pwszModuleName = MakeWideStrFromAnsi( (LPSTR)(pModuleCur->m_pData->m_szPath) );

        _stprintf(szBigString, _T("Import\\Export Dependency MisMatch with:%s"), pwszModuleName);
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, szBigString));
        m_cstrlstListOfBrokenLinks.AddTail(szBigString);
        m_iNumberOfBrokenLinks++;

        if (pwszModuleName){CoTaskMemFree(pwszModuleName);}
   }

   if (pModuleCur->m_pData->m_fFileNotFound == TRUE)
   {
        // Convert the filename to unicode.
        pwszModuleName = MakeWideStrFromAnsi( (LPSTR)(pModuleCur->m_pData->m_szPath) );
        _stprintf(szBigString, _T("Link Dependency MissingFile:%s"), pwszModuleName);
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, szBigString));
        m_cstrlstListOfBrokenLinks.AddTail(szBigString);
        m_iNumberOfBrokenLinks++;

        if (pwszModuleName){CoTaskMemFree(pwszModuleName);}

   }

   // Recurse into LoopThruAndPrintLosers() for each dependent module.
   pModuleCur = pModuleCur->m_pDependents;
   while (pModuleCur)
   {
      CModule *pModuleFound = LoopThruAndPrintLosers(pModuleCur);
      if (pModuleFound) {
         return pModuleFound;
      }
      pModuleCur = pModuleCur->m_pNext;
   }

   return NULL;
}


void CDepends::DeleteContents() {

   // Delete all modules by recursing into DeleteModule() with our root module.
   if (m_pModuleRoot) {
      DeleteModule(m_pModuleRoot);
      m_pModuleRoot = NULL;
   }

   // Clear our memory error flag.
   m_fOutOfMemory = FALSE;

   // Clear our circular dependency error flag.
   m_fCircularError = FALSE;

   // Clear our mixed machine error flag.
   m_fMixedMachineError = FALSE;
   m_dwMachineType = (DWORD)-1;
}


//******************************************************************************
// CDepends :: Internal functions
//******************************************************************************

CModule* CDepends::CreateModule(LPCSTR szFile, int depth) {

   CHAR szPath[16384] = "", *pszFile = NULL;

   // Attempt to find the file in our search path.  This will mimic what the OS
   // loader does when looking for a module.  Our OnOpenDocument() function sets
   // the current directory to the module directory, so SearchPath() will first
   // look in the module directory.
   //SearchPath(NULL, szFile, NULL, sizeof(szPath), szPath, &pszFile);
   SearchPathA(NULL, szFile, NULL, sizeof(szPath), szPath, &pszFile);

   // If we don't have a path, then just copy the file name into our path string
   // and set the file pointer to the character following the last wack "\".
   if (!*szPath) {
      strcpy(szPath, szFile);
      LPSTR pszWack = strrchr(szPath, '\\');
      pszFile = (pszWack && *(pszWack + 1)) ? (pszWack + 1) : szPath;
   }

   // If our file name pointer is invalid, then just point it to our path.
   if (pszFile < szPath) {
      pszFile = szPath;
   }

   // Create a new CModule object
   CModule *pModule = new CModule();
   if (!pModule) {
      return NULL;
   }
   ZeroMemory(pModule, sizeof(CModule));

   // Store our module's depth for later recursion overflow checks.
   pModule->m_depth = depth;

   // Recurse our module tree to see if this module is a duplicate of another.
   pModule->m_pModuleOriginal = FindModule(m_pModuleRoot, szPath);

   // Check to see if a duplicate was found.
   if (pModule->m_pModuleOriginal) {

      // If the module is a duplicate, then just point our data field to the
      // original module's data field.
      pModule->m_pData = pModule->m_pModuleOriginal->m_pData;

   } else {

      // If this module is not a duplicate, then create a new CModuleData object.
      pModule->m_pData = (CModuleData*)new BYTE[sizeof(CModuleData) + strlen(szPath)];
      if (!pModule->m_pData) {
         delete pModule;
         return NULL;
      }

      // Clear the object, copy the path string to it, and set the file pointer.
      ZeroMemory(pModule->m_pData, sizeof(CModuleData));
      strcpy(pModule->m_pData->m_szPath, szPath);
      pModule->m_pData->m_szFile = pModule->m_pData->m_szPath + (pszFile - szPath);

      // For readability, make path lowercase and file uppercase.
      _strlwr(pModule->m_pData->m_szPath);
      _strupr(pModule->m_pData->m_szFile);
   }

   // Return our new module object.
   return pModule;
}

//******************************************************************************
CFunction* CDepends::CreateFunction(int ordinal, int hint, LPCSTR szName,
                                       DWORD_PTR dwAddress, LPCSTR szForward)
{
   // Create a CFunction object.
   CFunction *pFunction = (CFunction*)new BYTE[sizeof(CFunction) + strlen(szName)];
   if (!pFunction) {
      return NULL;
   }

   // Clear the function object and fill in its members.
   ZeroMemory(pFunction, sizeof(CFunction));
   strcpy(pFunction->m_szName, szName);
   pFunction->m_ordinal = ordinal;
   pFunction->m_hint = hint;
   pFunction->m_dwAddress = dwAddress;

   // If a forward string exists, then allocate a buffer and store a pointer to
   // it in our CFunction's m_dwExtra member.  See the CFunction class for more
   // info on m_dwExtra.
   if (szForward) {
      if (pFunction->m_dwExtra = (DWORD_PTR)new CHAR[strlen(szForward) + 1]) {
         strcpy((LPSTR)pFunction->m_dwExtra, szForward);
      } else {
         delete[] (BYTE*)pFunction;
         return NULL;
      }
   }

   // Return our new function object.
   return pFunction;
}

//******************************************************************************
void CDepends::DeleteModule(CModule *pModule) {

   // Recurse into DeleteModule() to delete all our dependent modules first.
   CModule *pModuleCur = pModule->m_pDependents;
   while (pModuleCur) {
      CModule *pModuleNext = pModuleCur->m_pNext;
      DeleteModule(pModuleCur);
      pModuleCur = pModuleNext;
   }

   // Delete all of our current module's parent import functions.
   CFunction *pFunctionCur = pModule->m_pParentImports;
   while (pFunctionCur) {
      CFunction *pFunctionNext = pFunctionCur->m_pNext;
      delete[] (BYTE*)pFunctionCur;
      pFunctionCur = pFunctionNext;
   }

   // If we are not marked as a duplicate, then free our CModuleData.
   if (!pModule->m_pModuleOriginal) {

      // Delete all of our current module's export functions.
      CFunction *pFunctionCur = pModule->m_pData->m_pExports;
      while (pFunctionCur) {

         // Delete our forward string if we allocated one.
         if (pFunctionCur->GetForwardString()) {
            delete[] (CHAR*)pFunctionCur->GetForwardString();
         }

         // Delete the export node itself.
         CFunction *pFunctionNext = pFunctionCur->m_pNext;
         delete[] (BYTE*)pFunctionCur;
         pFunctionCur = pFunctionNext;
      }

      // Delete any error string that may have been allocated.
      if (pModule->m_pData->m_pszError) {
         delete[] (CHAR*)pModule->m_pData->m_pszError;
      }

      // Delete our current module's CModuleData object.
      delete[] (BYTE*)pModule->m_pData;
   }

   // Delete our current module object itself.
   delete pModule;
}

//******************************************************************************
CModule* CDepends::FindModule(CModule *pModuleCur, LPCSTR szPath) {

   if (!pModuleCur) {
      return NULL;
   }

   // Check to see if our current module matches our search module.
   if (!_stricmp(pModuleCur->m_pData->m_szPath, szPath)) {
      return (pModuleCur->m_pModuleOriginal ? pModuleCur->m_pModuleOriginal : pModuleCur);
   }

   // Recurse into FindModule() for each dependent module.
   pModuleCur = pModuleCur->m_pDependents;
   while (pModuleCur) {
      CModule *pModuleFound = FindModule(pModuleCur, szPath);
      if (pModuleFound) {
         return pModuleFound;
      }
      pModuleCur = pModuleCur->m_pNext;
   }

   return NULL;
}

//******************************************************************************
BOOL CDepends::VerifyModule(CModule *pModule) {

   // Map an IMAGE_DOS_HEADER structure onto our module file mapping.
   PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER)m_lpvFile;

   // Check for the DOS signature ("MZ").
   if (pIDH->e_magic != IMAGE_DOS_SIGNATURE) {
      //SetModuleError(pModule, "No DOS signature found. This file is not a valid Win32 module.");
      return FALSE;
   }

   // Map an IMAGE_NT_HEADERS structure onto our module file mapping.
   PIMAGE_NT_HEADERS pINTH = (PIMAGE_NT_HEADERS)((DWORD_PTR)m_lpvFile + pIDH->e_lfanew);

   // Check for NT/PE signature ("PE\0\0").
   if (pINTH->Signature != IMAGE_NT_SIGNATURE) {
      //SetModuleError(pModule, "No PE signature found. This file is not a valid Win32 module.");
      return FALSE;
   }

   // Map our IMAGE_FILE_HEADER structure onto our module file mapping.
   m_pIFH = &pINTH->FileHeader;

   // Map our IMAGE_OPTIONAL_HEADER structure onto our module file mapping.
   m_pIOH = &pINTH->OptionalHeader;

   // Map our IMAGE_SECTION_HEADER structure array onto our module file mapping
   m_pISH = IMAGE_FIRST_SECTION(pINTH);

   return TRUE;
}

//******************************************************************************
BOOL CDepends::GetModuleInfo(CModule *pModule) {

   // Store the machine type.
   pModule->m_pData->m_dwMachine = m_pIFH->Machine;

   // Check for a mismatched machine error.
   if (m_dwMachineType == (DWORD)-1) {
      m_dwMachineType = pModule->m_pData->m_dwMachine;
   } else if (m_dwMachineType != pModule->m_pData->m_dwMachine)
   {
    m_fMixedMachineError = TRUE;

    // Convert the filename to unicode.
    LPWSTR  pwszModuleName = NULL;
    TCHAR szBigString[_MAX_PATH + _MAX_PATH];
    pwszModuleName = MakeWideStrFromAnsi( (LPSTR)(pModule->m_pData->m_szPath) );
    _stprintf(szBigString, _T("Wrong Machine Type:(%s) %s"), MachineToString(pModule->m_pData->m_dwMachine), pwszModuleName);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, szBigString));
    m_cstrlstListOfBrokenLinks.AddTail(szBigString);
    m_iNumberOfBrokenLinks++;
    if (pwszModuleName){CoTaskMemFree(pwszModuleName);}

   }

   // Store the subsystem type
   pModule->m_pData->m_dwSubsystem = m_pIOH->Subsystem;

   // Store the preferred base address
   pModule->m_pData->m_dwBaseAddress = m_pIOH->ImageBase;

   // Store the image version
   pModule->m_pData->m_dwImageVersion =
      MAKELONG(m_pIOH->MinorImageVersion, m_pIOH->MajorImageVersion);

   // Store the linker version
   pModule->m_pData->m_dwLinkerVersion =
      MAKELONG(m_pIOH->MinorLinkerVersion, m_pIOH->MajorLinkerVersion);

   // Store the OS version
   pModule->m_pData->m_dwOSVersion =
      MAKELONG(m_pIOH->MinorOperatingSystemVersion, m_pIOH->MajorOperatingSystemVersion);

   // Store the subsystem version
   pModule->m_pData->m_dwSubsystemVersion = MAKELONG(m_pIOH->MinorSubsystemVersion, m_pIOH->MajorSubsystemVersion);

   return TRUE;
}


BOOL
CDepends::WalkIAT(
    PIMAGE_THUNK_DATA pITDF,
    PIMAGE_THUNK_DATA pITDA,
    CModule *pModule,
    DWORD_PTR dwBase
    )
{
    CFunction *pFunctionLast = NULL, *pFunctionNew;

    // Loop through all the Image Thunk Data structures in the function array.
    while (pITDF->u1.Ordinal) {

         LPCSTR szFunction = "";
         int    ordinal = -1, hint = -1;

         // Check to see if this function is by ordinal or by name. If the
         // function is by ordinal, the ordinal's high bit will be set. If the
         // the high bit is not set, then the ordinal value is really a virtual
         // address of an IMAGE_IMPORT_BY_NAME structure.

         if (IMAGE_SNAP_BY_ORDINAL(pITDF->u1.Ordinal)) {
             ordinal = (int)IMAGE_ORDINAL(pITDF->u1.Ordinal);
         } else {
            PIMAGE_IMPORT_BY_NAME pIIBN =
               (PIMAGE_IMPORT_BY_NAME)(dwBase + (DWORD_PTR)pITDF->u1.AddressOfData);
            szFunction = (LPCSTR)pIIBN->Name;
            hint = (int)pIIBN->Hint;
         }

         // If this import module has been pre-bound, then get this function's
         // entrypoint memory address.
         DWORD_PTR dwAddress = (DWORD_PTR)(pITDA ? pITDA->u1.Function : (DWORD_PTR)INVALID_HANDLE_VALUE);

         // Create a new CFunction object for this function.
         if (!(pFunctionNew = CreateFunction(ordinal, hint, szFunction, dwAddress))) {
             m_fOutOfMemory = TRUE;
             return FALSE;
         }

         // Add the function to the end of our module's function linked list
         if (pFunctionLast) {
             pFunctionLast->m_pNext = pFunctionNew;
         } else {
             pModule->m_pParentImports = pFunctionNew;
         }
         pFunctionLast = pFunctionNew;

         // Increment to the next function and address.
         pITDF++;
         if (pITDA) {
             pITDA++;
         }
    }
    return TRUE;
}


//******************************************************************************
BOOL CDepends::BuildImports(CModule *pModule) {

   // If this module has no imports (like NTDLL.DLL), then just return success.
   if (m_pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size == 0) {
      return TRUE;
   }

   // Locate our Import Image Directory's relative virtual address
   DWORD VAImageDir = m_pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

   PIMAGE_SECTION_HEADER pISH = NULL;

   // Locate the section that contains this Image Directory. We do this by
   // walking through all of our sections until we find the one that specifies
   // an address range that our Image Directory fits in.
   for (int i = 0; i < m_pIFH->NumberOfSections; i++) {
      if ((VAImageDir >= m_pISH[i].VirtualAddress) &&
          (VAImageDir < (m_pISH[i].VirtualAddress + m_pISH[i].SizeOfRawData)))
      {
         pISH = &m_pISH[i];
         break;
      }
   }

   // Bail out if we could not find a section that owns our Image Directory.
   if (!pISH) {
      //SetModuleError(pModule, "Could not find the section that owns the Import Directory.");
      return FALSE;
   }

   // Compute our base that everything else is an offset from. We do this by
   // taking our base file pointer and adding our section's PointerToRawData,
   // which is an absolute offset value into our file.  We then subtract off our
   // Virtual Address since the offsets we are going to be adding later will be
   // relative to the this Virtual Address
   DWORD_PTR dwBase = (DWORD_PTR)m_lpvFile + pISH->PointerToRawData - pISH->VirtualAddress;

   // To locate the beginning of our Image Import Descriptor array, we add our
   // Image Directory offset to our base.
   PIMAGE_IMPORT_DESCRIPTOR pIID = (PIMAGE_IMPORT_DESCRIPTOR)(dwBase + VAImageDir);

   CModule   *pModuleLast   = NULL, *pModuleNew;
   CFunction *pFunctionLast = NULL, *pFunctionNew;

   // Loop through all the Image Import Descriptors in the array.
   while (pIID->OriginalFirstThunk || pIID->FirstThunk) {

      // Locate our module name string and create the module object.
      if (!(pModuleNew = CreateModule((LPCSTR)(dwBase + pIID->Name),
                                      pModule->m_depth + 1)))
      {
         m_fOutOfMemory = TRUE;
         return FALSE;
      }

      // Add the module to the end of our module linked list.
      if (pModuleLast) {
         pModuleLast->m_pNext = pModuleNew;
      } else {
         pModule->m_pDependents = pModuleNew;
      }
      pModuleLast = pModuleNew;

      // Locate the beginning of our function array and address array. The
      // function array (pITDF) is an array of IMAGE_THUNK_DATA structures that
      // contains all the exported functions, both by name and by ordinal. The
      // address array (pITDA) is an parallel array of IMAGE_THUNK_DATA
      // structures that is used to store the all the function's entrypoint
      // addresses. Usually the address array contains the exact same values
      // the function array contains until the OS loader actually loads all the
      // modules. At that time, the loader will set (bind) these addresses to
      // the actual addresses that the given functions reside at in memory. Some
      // modules have their exports pre-bound which can provide a speed increase
      // when loading the module. If a module is pre-bound (often seen with
      // system modules), the TimeDateStamp field of our IMAGE_IMPORT_DESCRIPTOR
      // structure will be set and the address array will contain the actual
      // memory addresses that the functions will reside at, assuming that the
      // imported module loads at its preferred base address.

      PIMAGE_THUNK_DATA pITDF = NULL, pITDA = NULL;

      // Check to see if module is Microsoft format or Borland format.
      if (pIID->OriginalFirstThunk) {

         // Microsoft uses the OriginalFirstThunk field for the function array.
         pITDF = (PIMAGE_THUNK_DATA)(dwBase + (DWORD)pIID->OriginalFirstThunk);

         // Microsoft optionally uses the FirstThunk as a bound address array.
         // If the TimeDateStamp field is set, then the module has been bound.
         if (pIID->TimeDateStamp) {
            pITDA = (PIMAGE_THUNK_DATA)(dwBase + (DWORD)pIID->FirstThunk);
         }

      } else {

         // Borland uses the FirstThunk field for the function array.
         pITDF = (PIMAGE_THUNK_DATA)(dwBase + (DWORD)pIID->FirstThunk);;
      }

      // Find imports
      if (!WalkIAT(pITDF, pITDA, pModuleLast, dwBase)) {
          return FALSE;
      }

      // Increment to the next import module
      pIID++;
   }

   return TRUE;
}

BOOL CDepends::BuildDelayImports(CModule *pModule) {

   // If this module has no delay imports just return success.
   if (m_pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].Size == 0) {
      return TRUE;
   }

   // Locate our Import Image Directory's relative virtual address
   DWORD VAImageDir = m_pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].VirtualAddress;

   PIMAGE_SECTION_HEADER pISH = NULL;

   // Locate the section that contains this Image Directory. We do this by
   // walking through all of our sections until we find the one that specifies
   // an address range that our Image Directory fits in.
   for (int i = 0; i < m_pIFH->NumberOfSections; i++) {
      if ((VAImageDir >= m_pISH[i].VirtualAddress) &&
          (VAImageDir < (m_pISH[i].VirtualAddress + m_pISH[i].SizeOfRawData)))
      {
         pISH = &m_pISH[i];
         break;
      }
   }

   // Bail out if we could not find a section that owns our Image Directory.
   if (!pISH) {
      //SetModuleError(pModule, "Could not find the section that owns the Import Directory.");
      return FALSE;
   }

   // Compute our base that everything else is an offset from. We do this by
   // taking our base file pointer and adding our section's PointerToRawData,
   // which is an absolute offset value into our file.  We then subtract off our
   // Virtual Address since the offsets we are going to be adding later will be
   // relative to the this Virtual Address
   DWORD_PTR dwBase = (DWORD_PTR)m_lpvFile + pISH->PointerToRawData - pISH->VirtualAddress;

   // To locate the beginning of our Image Import Descriptor array, we add our
   // Image Directory offset to our base.
   PImgDelayDescr pIDD = (PImgDelayDescr)(dwBase + VAImageDir);

   CModule   *pModuleLast   = NULL, *pModuleNew;
   CFunction *pFunctionLast = NULL, *pFunctionNew;

   if (pIDD->grAttrs & dlattrRva) {
       PImgDelayDescrV2 pIDDv2 = (PImgDelayDescrV2)pIDD;
       // Loop through all the Image Import Descriptors in the array.
       while (pIDDv2->rvaINT && pIDDv2->rvaIAT && pIDDv2->rvaHmod) {

          DWORD_PTR dwNameBase = 0, dwINTBase = 0;

          // Locate the section that contains this Image Directory. We do this by
          // walking through all of our sections until we find the one that specifies
          // an address range that our Image Directory fits in.
          for (int i = 0; i < m_pIFH->NumberOfSections; i++) {
             if (((DWORD_PTR)pIDDv2->rvaDLLName >= m_pISH[i].VirtualAddress) &&
                 ((DWORD_PTR)pIDDv2->rvaDLLName < (m_pISH[i].VirtualAddress + m_pISH[i].SizeOfRawData)))
             {
                dwNameBase = ((DWORD_PTR)m_lpvFile + m_pISH[i].PointerToRawData - m_pISH[i].VirtualAddress);
             }

             if (((DWORD_PTR)pIDDv2->rvaINT >= (m_pISH[i].VirtualAddress)) &&
                 ((DWORD_PTR)pIDDv2->rvaINT < (m_pISH[i].VirtualAddress + m_pISH[i].SizeOfRawData)))
             {
                dwINTBase = ((DWORD_PTR)m_lpvFile + m_pISH[i].PointerToRawData - m_pISH[i].VirtualAddress);
             }
          }

          if (!dwINTBase) {
             //SetModuleError(pModule, "Could not find the section that owns the Delay Import INT.");
             return FALSE;
          }

          if (!dwNameBase) {
             //SetModuleError(pModule, "Could not find the section that owns the Delay Import DllName.");
             return FALSE;
          }

          // Locate our module name string and create the module object.
          if (!(pModuleNew = CreateModule((LPCSTR)(dwNameBase + pIDDv2->rvaDLLName),
                                          pModule->m_depth + 1)))
          {
             m_fOutOfMemory = TRUE;
             return FALSE;
          }

          // Add the module to the end of our module linked list.
          if (pModuleLast) {
             pModuleLast->m_pNext = pModuleNew;
          } else {
             if (pModule->m_pDependents) {
                 pModuleLast = pModule->m_pDependents;
                 while (pModuleLast->m_pNext) {
                     pModuleLast = pModuleLast->m_pNext;
                 }
                 pModuleLast->m_pNext = pModuleNew;
             } else {
                 pModule->m_pDependents = pModuleNew;
             }
          }
          pModuleLast = pModuleNew;

          pModuleLast->m_fDelayLoad = TRUE;

          // For now, don't worry about bound imports.

          PIMAGE_THUNK_DATA pITDF = NULL;

          pITDF = (PIMAGE_THUNK_DATA)(dwINTBase + (DWORD_PTR)pIDDv2->rvaINT);

          // Find imports
          if (!WalkIAT(pITDF, NULL, pModuleLast, dwNameBase)) {
              return FALSE;
          }

          // Increment to the next import module
          pIDDv2++;
       }
   } else {
       PImgDelayDescrV1 pIDDv1 = (PImgDelayDescrV1)pIDD;

       // Loop through all the Image Import Descriptors in the array.
       while (pIDDv1->pINT && pIDDv1->pIAT && pIDDv1->phmod) {

          DWORD_PTR dwNameBase = 0, dwINTBase = 0;

          // Locate the section that contains this Image Directory. We do this by
          // walking through all of our sections until we find the one that specifies
          // an address range that our Image Directory fits in.
          for (int i = 0; i < m_pIFH->NumberOfSections; i++) {
             if (((DWORD_PTR)pIDDv1->szName >= (m_pIOH->ImageBase + m_pISH[i].VirtualAddress)) &&
                 ((DWORD_PTR)pIDDv1->szName < (m_pIOH->ImageBase + m_pISH[i].VirtualAddress + m_pISH[i].SizeOfRawData)))
             {
                dwNameBase = ((DWORD_PTR)m_lpvFile + m_pISH[i].PointerToRawData - m_pISH[i].VirtualAddress - m_pIOH->ImageBase);
             }

             if (((DWORD_PTR)pIDDv1->pINT >= (m_pIOH->ImageBase + m_pISH[i].VirtualAddress)) &&
                 ((DWORD_PTR)pIDDv1->pINT < (m_pIOH->ImageBase + m_pISH[i].VirtualAddress + m_pISH[i].SizeOfRawData)))
             {
                dwINTBase = ((DWORD_PTR)m_lpvFile + m_pISH[i].PointerToRawData - m_pISH[i].VirtualAddress - m_pIOH->ImageBase);
             }
          }

          if (!dwINTBase) {
             //SetModuleError(pModule, "Could not find the section that owns the Delay Import INT.");
             return FALSE;
          }

          if (!dwNameBase) {
             //SetModuleError(pModule, "Could not find the section that owns the Delay Import DllName.");
             return FALSE;
          }

          // Locate our module name string and create the module object.
          if (!(pModuleNew = CreateModule((LPCSTR)(dwNameBase + pIDDv1->szName),
                                          pModule->m_depth + 1)))
          {
             m_fOutOfMemory = TRUE;
             return FALSE;
          }

          // Add the module to the end of our module linked list.
          if (pModuleLast) {
             pModuleLast->m_pNext = pModuleNew;
          } else {
             if (pModule->m_pDependents) {
                 pModuleLast = pModule->m_pDependents;
                 while (pModuleLast->m_pNext) {
                     pModuleLast = pModuleLast->m_pNext;
                 }
                 pModuleLast->m_pNext = pModuleNew;
             } else {
                 pModule->m_pDependents = pModuleNew;
             }
          }
          pModuleLast = pModuleNew;

          pModuleLast->m_fDelayLoad = TRUE;

          // For now, don't worry about bound imports.

          PIMAGE_THUNK_DATA pITDF = NULL;

          pITDF = (PIMAGE_THUNK_DATA)(dwINTBase + (DWORD_PTR)pIDDv1->pINT);

          // Find imports
          if (!WalkIAT(pITDF, NULL, pModuleLast, dwNameBase)) {
              return FALSE;
          }

          // Increment to the next import module
          pIDDv1++;
       }
   }

   return TRUE;
}



//******************************************************************************
BOOL CDepends::BuildExports(CModule *pModule) {

   // If this module has no exports, then just return success.
   if (m_pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size == 0) {
      return TRUE;
   }

   // Locate our Export Image Directory's relative virtual address
   DWORD VAImageDir = m_pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

   PIMAGE_SECTION_HEADER pISH = NULL;

   // Locate the section that contains this Image Directory. We do this by
   // walking through all of our sections until we find the one that specifies
   // an address range that our Image Directory fits in.
   for (int i = 0; i < m_pIFH->NumberOfSections; i++) {
      if ((VAImageDir >= m_pISH[i].VirtualAddress) &&
          (VAImageDir < (m_pISH[i].VirtualAddress + m_pISH[i].SizeOfRawData)))
      {
         pISH = &m_pISH[i];
         break;
      }
   }

   // Bail out if we could not find a section that owns our Image Directory.
   if (!pISH) {
      //SetModuleError(pModule, "Could not find the section that owns the Export Directory.");
      return FALSE;
   }

   // Compute our base that everything else is an offset from. We do this by
   // taking our base file pointer and adding our section's PointerToRawData,
   // which is an absolute offset value into our file.  We then subtract off our
   // Virtual Address since the offsets we are going to be adding later will be
   // relative to the this Virtual Address
   DWORD_PTR dwBase = (DWORD_PTR)m_lpvFile + pISH->PointerToRawData - pISH->VirtualAddress;

   // To locate the beginning of our Image Export Directory, we add our
   // Image Directory offset to our base.
   PIMAGE_EXPORT_DIRECTORY pIED = (PIMAGE_EXPORT_DIRECTORY)(dwBase + VAImageDir);

   // pdwNames is a DWORD array of size pIED->NumberOfNames, which contains VA
   // pointers to all the function name strings. pwOrdinals is a WORD array of
   // size pIED->NumberOfNames, which contains all the ordinal values for each
   // function exported by name. pdwNames and pwOrdinals are parallel arrays,
   // meaning that the ordinal in pwOrdinals[x] goes with the function name
   // pointed to by pdwNames[x]. The value used to index these arrays is
   // referred to as the "hint".

   // pdwAddresses is a DWORD array of size pIED->NumberOfFunctions, which
   // contains the entrypoint addresses for all functions exported by the
   // module. Contrary to several PE format documents, this array is *not*
   // parallel with pdwNames and pwOrdinals. The index used for this array is
   // the ordinal value of the function you are interested in, minus the base
   // ordinal specified in pIED->Base. Another common mistake is to assume that
   // pIED->NumberOfFunctions is always equal to pIED->AddressOfNames. If the
   // module exports function by ordinal only, then pIED->NumberOfFunctions
   // will be greater than pIED->NumberOfNames.

   DWORD *pdwNames     = (DWORD*)(dwBase + (DWORD)pIED->AddressOfNames);
   WORD  *pwOrdinals   = (WORD* )(dwBase + (DWORD)pIED->AddressOfNameOrdinals);
   DWORD *pdwAddresses = (DWORD*)(dwBase + (DWORD)pIED->AddressOfFunctions);

   CFunction *pFunctionLast = NULL, *pFunctionNew;

   // Loop through all the "exported by name" functions.
   for (int hint = 0; hint < (int)pIED->NumberOfNames; hint++) {

      // Get our ordinal value, function name, and entrypoint address
      int    ordinal    = pIED->Base + (DWORD)pwOrdinals[hint];
      LPCSTR szFunction = (LPCSTR)(dwBase + pdwNames[hint]);
      DWORD  dwAddress  = pdwAddresses[ordinal - pIED->Base];
      LPCSTR szForward  = NULL;

      // Certain modules, such as NTDLL.DLL and MSVCRT40.DLL, have what are
      // known as forwarded functions.  Forwarded functions are functions that
      // are exported from one module, but the code actually lives in another
      // module.  We can check to see if a function is forwarded by looking at
      // its address pointer.  If the address pointer points to the character
      // immediately following the NULL character in its function name string,
      // then this address pointer is really a pointer to a forward string in
      // the string table.  Some documents state that if the address points to
      // a RVA in our current section, then the address must point to a forward
      // string.  This is not true since the function code can (and sometimes
      // does) live in the same section that we are currently in.

      if (((DWORD_PTR)szFunction + strlen(szFunction) + 1) == (dwBase + dwAddress)) {
         szForward = (LPCSTR)(dwBase + dwAddress);
      }

      // Create a new CFunction object for this function.
      if (!(pFunctionNew = CreateFunction(ordinal, hint, szFunction, dwAddress, szForward))) {
         m_fOutOfMemory = TRUE;
         return FALSE;
      }

      // Add the function to the end of our module's export function linked list
      if (pFunctionLast) {
         pFunctionLast->m_pNext = pFunctionNew;
      } else {
         pModule->m_pData->m_pExports = pFunctionNew;
      }
      pFunctionLast = pFunctionNew;
   }

   // Loop through all the "exported by ordinal" functions. This module has
   // pIED->NumberOfFunctions functions with consecutive ordinals starting
   // with the ordinal specified by pIED->Base. We need to loop through all
   // these ordinal values and add any to our list that have not already been
   // added by name.

   for (int ordinal = pIED->Base;
        ordinal < (int)(pIED->NumberOfFunctions + pIED->Base); ordinal++) {

      // Loop through our current list to make sure we haven't already added
      // this function during our "exported by name" search above.
      CFunction *pFunctionCur = pModule->m_pData->m_pExports;
      while (pFunctionCur) {
         if (pFunctionCur->m_ordinal == ordinal) {
            break;
         }
         pFunctionCur = pFunctionCur->m_pNext;
      }

      // If this ordinal is not currently in our list, then add it to our list.
      if (!pFunctionCur) {

         // Get this function's entrypoint address.
         DWORD dwAddress = pdwAddresses[ordinal - pIED->Base];

         // Create a new CFunction object for this function.
         if (!(pFunctionNew = CreateFunction(ordinal, -1, "", dwAddress))) {
            m_fOutOfMemory = TRUE;
            return FALSE;
         }

         // Add the function to the end of our module's export function linked list
         if (pFunctionLast) {
            pFunctionLast->m_pNext = pFunctionNew;
         } else {
            pModule->m_pData->m_pExports = pFunctionNew;
         }
         pFunctionLast = pFunctionNew;
      }
   }

   return TRUE;
}

//******************************************************************************
BOOL CDepends::VerifyParentImports(CModule *pModule) {

   CModule *pModuleHead = NULL, *pModuleLast, *pModuleCur;

   // Loop through each of our parent import functions.
   CFunction *pImport = pModule->m_pParentImports;
   while (pImport) {

      // Mark this parent import function as not resolved before starting search.
      pImport->m_dwExtra = 0;

      // Loop through all our exports, looking for a match with our current import.
      CFunction *pExport = pModule->m_pData->m_pExports;
      while (pExport) {

         // If we have a name, then check for the match by name.
         if (*pImport->m_szName) {
            if (!strcmp(pImport->m_szName, pExport->m_szName)) {

               // We found a match. Link this parent import to its associated
               // export, break out of loop, and move on to handling our next
               // parent import.
               pImport->m_dwExtra = (DWORD_PTR)pExport;
               break;
            }

         // If we don't have a name, then check for the match by name.
         } else if (pImport->m_ordinal == pExport->m_ordinal) {

            // We found a match. Link this parent import to its associated
            // export, break out of loop, and move on to handling our next
            // parent import.
            pImport->m_dwExtra = (DWORD_PTR)pExport;
            break;
         }

         // Move to the next export
         pExport = pExport->m_pNext;
      }

      // Check to see if an export match was found.
      if (pImport->GetAssociatedExport()) {

         CHAR   szFile[1024];
         LPCSTR szFunction;

         // If an export was found, check to see if it is a forwarded function.
         // If it is forwarded, then we need to make sure we consider the
         // forwarded module as a new dependent of the current module.
         LPCSTR szForward = pImport->GetAssociatedExport()->GetForwardString();
         if (szForward) {

            // Extract and build the DLL name from the forward string.
            LPCSTR pszDot = strchr(szForward, '.');
            if (pszDot) {
               strncpy(szFile, szForward, (size_t)(pszDot - szForward));
               strcpy(szFile + (pszDot - szForward), ".DLL");
               szFunction = pszDot + 1;
            } else {
               strcpy(szFile, "Invalid");
               szFunction = szForward;
            }

            // Search our local forward module list to see if we have already
            // created a forward CModoule for this DLL file.
            for (pModuleLast = NULL, pModuleCur = pModuleHead; pModuleCur;
                 pModuleLast = pModuleCur, pModuleCur = pModuleCur->m_pNext)
            {
               if (!_stricmp(pModuleCur->m_pData->m_szFile, szFile)) {
                  break;
               }
            }

            // If we have not created a forward module for this file yet, then
            // create it now and add it to the end of our list.
            if (!pModuleCur) {

               if (!(pModuleCur = CreateModule(szFile, pModule->m_depth + 1))) {
                  m_fOutOfMemory = TRUE;
                  return FALSE;
               }
               pModuleCur->m_fForward = TRUE;

               // Add the new module to our local forward module list.
               if (pModuleLast) {
                  pModuleLast->m_pNext = pModuleCur;
               } else {
                  pModuleHead = pModuleCur;
               }
            }

            // Create a new CFunction object for this function.
            CFunction *pFunction = CreateFunction(-1, -1, szFunction, (DWORD)-1);
            if (!pFunction) {
               m_fOutOfMemory = TRUE;
               return FALSE;
            }

            // Insert this function object into our forward module's import list.
            pFunction->m_pNext = pModuleCur->m_pParentImports;
            pModuleCur->m_pParentImports = pFunction;
         }

      } else {

         // If we could not find an import/export match, then flag the module
         // as having an export error.
         pModule->m_fExportError = TRUE;
      }

      // Move to the next parent import function.
      pImport = pImport->m_pNext;
   }

   // If we created any forward modules during our entire import verify, then
   // add them to the end of our module's dependent module list.
   if (pModuleHead) {

      // Walk to end of our module's dependent module list.
      for (pModuleLast = pModule->m_pDependents;
           pModuleLast && pModuleLast->m_pNext;
           pModuleLast = pModuleLast->m_pNext)
      {}

      // Add our local list to the end of our module's dependent module list.
      if (pModuleLast) {
         pModuleLast->m_pNext = pModuleHead;
      } else {
         pModule->m_pDependents = pModuleHead;
      }
   }
   return TRUE;
}


//******************************************************************************
BOOL CDepends::ProcessModule(CModule *pModule) {

   BOOL fResult = FALSE;

   // First check to see if this module is a duplicate. If it is, make sure the
   // original instance of this module has been processed and then just perform
   // the Parent Import Verify. If the module being passed in is an original,
   // then just ensure that we haven't already processed this module.

   if (pModule->m_pModuleOriginal) {

      // Process the original module and its subtree.
      fResult = ProcessModule(pModule->m_pModuleOriginal);
      if (!fResult && m_fOutOfMemory) {
         return FALSE;
      }

   // Exit now if we have already processed this original module in the past.
   } else if (pModule->m_pData->m_fProcessed) {
      return TRUE;

   } else {

      // Mark this module as processed.
      pModule->m_pData->m_fProcessed = TRUE;

      // Open the file for read.
      //m_hFile = CreateFile(pModule->m_pData->m_szPath, GENERIC_READ,
      m_hFile = CreateFileA(pModule->m_pData->m_szPath, GENERIC_READ,
                           FILE_SHARE_READ, NULL, OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL, NULL);

      // Exit now if the file failed to open.
      if (m_hFile == INVALID_HANDLE_VALUE) {
         DWORD dwGLE = GetLastError();
         if (dwGLE == ERROR_FILE_NOT_FOUND) {
            //SetModuleError(pModule, "File not found in local directory or search path.");
            pModule->m_pData->m_fFileNotFound = TRUE;
         } else if (dwGLE == ERROR_PATH_NOT_FOUND) {
            //SetModuleError(pModule, "Invalid path or file name.");
            pModule->m_pData->m_fFileNotFound = TRUE;
         } else {
            //SetModuleError(pModule, "CreateFile() failed (%u).", dwGLE);
         }
         return FALSE;
      }

      // Create a file mapping object for the open module.
      HANDLE hMap = CreateFileMapping(m_hFile, NULL, PAGE_READONLY, 0, 0, NULL);

      // Exit now if the file failed to map.
      if (hMap == NULL) {
         //SetModuleError(pModule, "CreateFileMapping() failed (%u).", GetLastError());
         CloseHandle(m_hFile);
         m_hFile = NULL;
         return FALSE;
      }

      // Create a file mapping view for the open module.
      m_lpvFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);

      // Exit now if the mapped view failed to create.
      if (m_lpvFile == NULL) {
         //SetModuleError(pModule, "MapViewOfFile() failed (%u).", GetLastError());
         CloseHandle(hMap);
         CloseHandle(m_hFile);
         m_hFile = NULL;
         return FALSE;
      }

      __try {

         // Everything from here on is pretty much relying on the file being a
         // valid binary with valid pointers and offsets. It is fairly safe to
         // just wrap everything in exception handling and then blindly access
         // the file. Anything that causes us to move outside our file mapping
         // will generate an exception and bring us back here to fail the file.
         fResult = (VerifyModule(pModule)   &&
                    GetModuleInfo(pModule)  &&
                    BuildImports(pModule)   &&
                    BuildDelayImports(pModule) &&
                    BuildExports(pModule));


      } __except(EXCEPTION_EXECUTE_HANDLER) {
         //SetModuleError(pModule, "Module does not appear to be a valid Win32 module.");
      }

      // Close our map view pointer, our map handle, and our file handle.
      UnmapViewOfFile(m_lpvFile);
      CloseHandle(hMap);
      CloseHandle(m_hFile);

      // Clear our file handles and pointers.
      m_hFile   = NULL;
      m_lpvFile = NULL;
      m_pIFH    = NULL;
      m_pIOH    = NULL;
      m_pISH    = NULL;
   }

   // Compare our parent imports with our exports to make sure they all match up.
   if (!VerifyParentImports(pModule)) {
      return FALSE;
   }

   // Safeguard to ensure that we don't get stuck in some recursize loop.  This
   // can occur if there is a circular dependency with forwarded functions. This
   // is extremely rare and would require someone to design it, but we need
   // to handle this case to prevent us from crashing on it.  When NT encounters
   // a module like this, it fails the load with exception 0xC00000FD which is
   // defined as STATUS_STACK_OVERFLOW in WINNT.H.  We use 255 as our max depth
   // because the several versions of the tree control crash if more than 256
   // depths are displayed.

   if (pModule->m_depth >= 255) {

      // If this module has dependents, then delete them.
      if (pModule->m_pDependents) {
         DeleteModule(pModule->m_pDependents);
         pModule->m_pDependents = NULL;
      }

      // Flag this document as having a circular dependency error.
      m_fCircularError = TRUE;
      return FALSE;
   }

   // Recurse into ProcessModule() to handle all our dependent modules.
   pModule = pModule->m_pDependents;
   while (pModule) {
      if (!ProcessModule(pModule) && m_fOutOfMemory) {
         return FALSE;
      }
      pModule = pModule->m_pNext;
   }

   return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\const.h ===
// this is the max resource string length
#define MAX_STR_LEN 1024

const TCHAR REG_INETSTP[]   = _T("Software\\Microsoft\\INetStp");
const TCHAR REG_IISADMIN[]     = _T("System\\CurrentControlSet\\Services\\IISADMIN");
const TCHAR REG_W3SVC[]     = _T("System\\CurrentControlSet\\Services\\W3SVC");
const TCHAR REG_MSFTPSVC[] = _T("System\\CurrentControlSet\\Services\\MSFTPSVC");
const TCHAR REG_GOPHERSVC[] = _T("System\\CurrentControlSet\\Services\\GOPHERSVC");
const TCHAR REG_MIMEMAP[] = _T("System\\CurrentControlSet\\Services\\InetInfo\\Parameters\\MimeMap");

const TCHAR REG_ASP_UNINSTALL[] = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\ActiveServerPages");

const TCHAR REG_INETINFOPARAMETERS[] = _T("System\\CurrentControlSet\\Services\\InetInfo\\Parameters");
const TCHAR REG_WWWPARAMETERS[] = _T("System\\CurrentControlSet\\Services\\W3Svc\\Parameters");
const TCHAR REG_WWWVROOTS[] = _T("System\\CurrentControlSet\\Services\\W3Svc\\Parameters\\Virtual Roots");
const TCHAR REG_WWWPERFORMANCE[] = _T("System\\CurrentControlSet\\Services\\W3svc\\Performance");
const TCHAR REG_EVENTLOG_SYSTEM[] = _T("System\\CurrentControlSet\\Services\\EventLog\\System");
const TCHAR REG_EVENTLOG_APPLICATION[] = _T("System\\CurrentControlSet\\Services\\EventLog\\Application");
const TCHAR REG_FTPPARAMETERS[] = _T("System\\CurrentControlSet\\Services\\MSFtpsvc\\Parameters");
const TCHAR REG_FTPVROOTS[] = _T("System\\CurrentControlSet\\Services\\MSFtpsvc\\Parameters\\Virtual Roots");

const TCHAR REG_SNMPPARAMETERS[] = _T("System\\CurrentControlSet\\Services\\SNMP\\Parameters");
const TCHAR REG_SNMPEXTAGENT[] = _T("System\\CurrentControlSet\\Services\\SNMP\\Parameters\\ExtensionAgents");

enum OS	{OS_NT, OS_W95, OS_OTHERS};

enum NT_OS_TYPE {OT_NT_UNKNOWN, OT_NTS, OT_PDC_OR_BDC, OT_NTW};

enum UPGRADE_TYPE {UT_NONE, UT_351, UT_10_W95, UT_10, UT_20, UT_30, UT_40, UT_50, UT_51, UT_60};

enum INSTALL_MODE {IM_FRESH,IM_UPGRADE,IM_MAINTENANCE, IM_DEGRADE};

enum ACTION_TYPE {AT_DO_NOTHING, AT_REMOVE, AT_INSTALL_FRESH, AT_INSTALL_UPGRADE, AT_INSTALL_REINSTALL};

enum STATUS_TYPE {ST_UNKNOWN, ST_INSTALLED, ST_UNINSTALLED};

// 0 = log errors only
// 1 = log errors and warnings
// 2 = log errors, warnings and program flow type statemtns
// 3 = log errors, warnings, program flow and basic trace activity
// 4 = log errors, warnings, program flow, basic trace activity and trace to win32 api calls.
const int LOG_TYPE_ERROR = 0;
const int LOG_TYPE_WARN  = 1;
const int LOG_TYPE_PROGRAM_FLOW = 2;
const int LOG_TYPE_TRACE = 3;
const int LOG_TYPE_TRACE_WIN32_API = 4;

/*
old pws10 registry entries...

[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Setup\SetupX\INF\OEM Name]
    "C:\\WINDOWS\\INF\\MSWEBSVR.INF"="MSWEBSVR.INF"
[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Uninstall\Personal Web Server]
    "DisplayName"="Personal Web Server"
    "UninstallString"="C:\\Program Files\\WebSvr\\System\\mswebndi.exe /REMOVE"
[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\App Paths\inetsw95.exe]
    @="C:\\Program Files\\WebSvr\\System\\inetsw95.exe"
[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run]
    "Microsoft WebServer"="C:\\Program Files\\WebSvr\\System\\svctrl /init"
[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServices]
    "Microsoft WebServer"="C:\\Program Files\\WebSvr\\System\\inetsw95 -w3svc"
[HKEY_LOCAL_MACHINE\Software\Microsoft\FrontPage]
[HKEY_LOCAL_MACHINE\Software\Microsoft\FrontPage\3.0]
    "PWSInstalled"="1"
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetService\0000]
    "DriverDesc"="Personal Web Server"
    "InfSection"="MSWEBSVR.ndi"
    "InfPath"="MSWEBSVR.INF"
    "ProviderName"="Microsoft"
    "DriverDate"=" 8-21-1996"
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetService\0000\Ndi]
    "DeviceID"="MSWEBSVR"
    "MaxInstance"="8"
    "NdiInstaller"="mswebndi.dll,WebNdiProc"
    "HelpText"="Personal Web Server enables you to share your files over the Internet."
    "InstallInf"=""
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetService\0000\Ndi\Compatibility]
    "RequireAll"="MSTCP"
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetService\0000\Ndi\Interfaces]
    "DefLower"="winsock"
    "LowerRange"="winsock"
    "Lower"="winsock"
    "Upper"=""
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetService\0000\Ndi\Install]
    @="MSWEBSVR.Install.Inf"
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetService\0000\Ndi\Remove]
    @="MSWEBSVR.Remove.Inf"
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetService\0000\Ndi\params]
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetService\0000\Ndi\params\LocalSecurity]
    "ParamDesc"="Use Local Security"
    "flag"=hex:10,00,00,00
    "default"="TRUE"
    "type"="enum"
    @="TRUE"
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetService\0000\Ndi\params\LocalSecurity\enum]
    "TRUE"="TRUE"
    "FALSE"="FALSE"
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\VxD\mswebSP]
    "StaticVxD"="mswebsp.vxd"
    "Start"=hex:00
    "NetClean"=hex:01
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\VxD\FILESEC]
    "StaticVxD"="filesec.vxd"
    "Start"=hex:00
    "NetClean"=hex:01
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\EventLog]
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\EventLog\System]
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\EventLog\System\W3SVC]
    "EventMessageFile"="w3svc.dll"
    "TypesSupported"=hex:07
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\EventLog\System\MSFTPSVC]
    "EventMessageFile"="ftpsvc2.dll"
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\InetInfo]
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\InetInfo\Parameters]
    "MaxPoolThreads"=hex:05
    "MaxConcurrency"=hex:01
    "ThreadTimeout"=hex:00,20
    "RPCEnabled"=hex:01
    "StartupServices"=hex:01
    "BandwidthLevel"=hex:00
    "EventLogDirectory"="C:\\WINDOWS"
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\InetInfo\Parameters\MimeMap]
    "text/plain,*,/images/default.gif,1"=""
    "application/wav,wav,/images/sound.gif,1"=""
    "application/zip,zip,/images/binary.gif,1"=""
    "application/rtf,rtf,/images/doc.gif,1"=""
    "application/postscript,ps,/images/image.gif,1"=""
    "application/msword,doc,/images/doc.gif,1"=""
    "text/html,html,/images/doc.gif,1"=""
    "text/html,htm,/images/doc.gif,1"=""
    "text/html,stm,/images/doc.gif,1"=""
    "text/plain,txt,/images/doc.gif,1"=""
    "image/gif,gif,/images/image.gif,1"=""
    "image/jpeg,jpeg,/images/image.gif,1"=""
    "image/jpeg,jpg,/images/image.gif,1"=""
    "image/tiff,tiff,/images/image.gif,1"=""
    "image/tiff,tif,/images/image.gif,1"=""
    "video/mpeg,mpeg,/images/video.gif,1"=""
    "video/mpeg,mpg,/images/video.gif,1"=""
    "video/avi,avi,/images/video.gif,1"=""
    "audio/basic,au,/images/sound.gif,1"=""
    "application/octet-stream,*,,5"=""
    "text/html,htm,,h"=""
    "image/gif,gif,,g"=""
    "image/jpeg,jpg,,:"=""
    "text/plain,txt,,0"=""
    "text/html,html,,h"=""
    "image/jpeg,jpe,,:"=""
    "image/bmp,bmp,,:"=""
    "image/jpeg,jpeg,,:"=""
    "application/pdf,pdf,,5"=""
    "application/oda,oda,,5"=""
    "application/zip,zip,,9"=""
    "application/rtf,rtf,,5"=""
    "application/postscript,ps,,5"=""
    "application/postscript,ai,,5"=""
    "application/postscript,eps,,5"=""
    "application/mac-binhex40,hqx,,4"=""
    "application/msword,doc,,5"=""
    "application/msword,dot,,5"=""
    "application/winhlp,hlp,,5"=""
    "video/mpeg,mpeg,,Long file names"=""
    "video/mpeg,mpg,,Long file names"=""
    "video/mpeg,mpe,,Long file names"=""
    "video/avi,avi,,<"=""
    "video/x-msvideo,avi,,<"=""
    "video/quicktime,qt,,Long file names"=""
    "video/quicktime,mov,,Long file names"=""
    "video/x-sgi-movie,movie,,<"=""
    "x-world/x-vrml,wrl,,5"=""
    "x-world/x-vrml,xaf,,5"=""
    "x-world/x-vrml,xof,,5"=""
    "x-world/x-vrml,flr,,5"=""
    "x-world/x-vrml,wrz,,5"=""
    "application/x-director,dcr,,5"=""
    "application/x-director,dir,,5"=""
    "application/x-director,dxr,,5"=""
    "image/cis-cod,cod,,5"=""
    "image/x-cmx,cmx,,5"=""
    "application/envoy,evy,,5"=""
    "application/x-msaccess,mdb,,5"=""
    "application/x-mscardfile,crd,,5"=""
    "application/x-msclip,clp,,5"=""
    "application/octet-stream,exe,,5"=""
    "application/x-msexcel,xla,,5"=""
    "application/x-msexcel,xlc,,5"=""
    "application/x-msexcel,xlm,,5"=""
    "application/x-msexcel,xls,,5"=""
    "application/x-msexcel,xlt,,5"=""
    "application/x-msexcel,xlw,,5"=""
    "application/x-msmediaview,m13,,5"=""
    "application/x-msmediaview,m14,,5"=""
    "application/x-msmoney,mny,,5"=""
    "application/x-mspowerpoint,ppt,,5"=""
    "application/x-msproject,mpp,,5"=""
    "application/x-mspublisher,pub,,5"=""
    "application/x-msterminal,trm,,5"=""
    "application/x-msworks,wks,,5"=""
    "application/x-mswrite,wri,,5"=""
    "application/x-msmetafile,wmf,,5"=""
    "application/x-csh,csh,,5"=""
    "application/x-dvi,dvi,,5"=""
    "application/x-hdf,hdf,,5"=""
    "application/x-latex,latex,,5"=""
    "application/x-netcdf,nc,,5"=""
    "application/x-netcdf,cdf,,5"=""
    "application/x-sh,sh,,5"=""
    "application/x-tcl,tcl,,5"=""
    "application/x-tex,tex,,5"=""
    "application/x-texinfo,texinfo,,5"=""
    "application/x-texinfo,texi,,5"=""
    "application/x-troff,t,,5"=""
    "application/x-troff,tr,,5"=""
    "application/x-troff,roff,,5"=""
    "application/x-troff-man,man,,5"=""
    "application/x-troff-me,me,,5"=""
    "application/x-troff-ms,ms,,5"=""
    "application/x-wais-source,src,,7"=""
    "application/x-bcpio,bcpio,,5"=""
    "application/x-cpio,cpio,,5"=""
    "application/x-gtar,gtar,,9"=""
    "application/x-shar,shar,,5"=""
    "application/x-sv4cpio,sv4cpio,,5"=""
    "application/x-sv4crc,sv4crc,,5"=""
    "application/x-tar,tar,,5"=""
    "application/x-ustar,ustar,,5"=""
    "audio/basic,au,,<"=""
    "audio/basic,snd,,<"=""
    "audio/aiff,aif,,<"=""
    "audio/aiff,aiff,,<"=""
    "audio/aiff,aifc,,<"=""
    "audio/x-wav,wav,,<"=""
    "audio/x-pn-realaudio,ra,,<"=""
    "audio/x-pn-realaudio,ram,,<"=""
    "image/ief,ief,,:"=""
    "image/tiff,tiff,,:"=""
    "image/tiff,tif,,:"=""
    "image/x-cmu-raster,ras,,:"=""
    "image/x-portable-anymap,pnm,,:"=""
    "image/x-portable-bitmap,pbm,,:"=""
    "image/x-portable-graymap,pgm,,:"=""
    "image/x-portable-pixmap,ppm,,:"=""
    "image/x-xbitmap,xbm,,:"=""
    "image/x-xxpixmap,xpm,,:"=""
    "image/x-xwindowdump,xwd,,:"=""
    "text/html,stm,,h"=""
    "text/plain,bas,,0"=""
    "text/plain,c,,0"=""
    "text/plain,h,,0"=""
    "text/richtext,rtx,,0"=""
    "text/tab-separated-values,tsv,,0"=""
    "text/x-setext,etx,,0"=""
    "application/x-perfmon,pmc,,5"=""
    "application/x-perfmon,pma,,5"=""
    "application/x-perfmon,pmr,,5"=""
    "application/x-perfmon,pml,,5"=""
    "application/x-perfmon,pmw,,5"=""
    "application/octet-stream,bin,,5"=""
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\MsFtpSvc]
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\MsFtpSvc\Parameters]
    "MajorVersion"=hex:01
    "MinorVersion"=hex:01
    "AllowAnonymous"=hex:01
    "AllowGuestAccess"=hex:01
    "AnonymousUserName"="anonymous"
    "DebugFlags"=hex:ff,ff
    "ConnectionTimeOut"=hex:50,03
    "EnablePortAttack"=hex:00
    "ExitMessage"="Bye."
    "GreetingMessage"="Windows 95 FTP Service."
    "LogAnonymous"=hex:01
    "LogFileDirectory"="C:\\WINDOWS"
    "LogType"=hex:01
    "LogFilePeriod"=hex:01
    "MaxConnections"=hex:10
    "MaxClientsMessage"="The connection limit for this server has been reached. No more connections can be accepted at this time."
    "SecurityOn"=hex:00
    "MsdosDirOutput"=hex:00
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\MsFtpSvc\Parameters\Virtual Roots]
    "/"="C:\\WebShare\\ftproot,,1"
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\W3Svc]
    @=""
    "DisplayName"="Microsoft HTTP World Wide Web Server"
    "ErrorControl"=hex:01
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\W3Svc\Parameters]
    "LogAnonymous"=hex:01
    "SecurePort"=hex:bb,01
    "ConnectionTimeout"=hex:58,02
    "Filter DLLs"="sspifilt.dll"
    "AccessDeniedMessage"="Access to this resource has been denied."
    "MajorVersion"=hex:00
    "MinorVersion"=hex:01
    "AdminName"="Administrator Name"
    "AdminEmail"="Admin@Corp.com"
    "AnonymousUserName"=""
    "Default Load File"="Default.htm"
    "Dir Browse Control"=hex:1e,00,00,c0
    "CacheExtensions"=hex:01
    "CheckForWAISDB"="1"
    "DebugFlags"=hex:ff,ff
    "Directory Image"="/images/dir.gif"
    "GlobalExpire"=hex:ff,ff,ff,ff
    "MaxConnections"=hex:2c,01
    "LogFileDirectory"="C:\\WINDOWS"
    "LogType"=hex:01
    "LogFilePeriod"=hex:03
    "LogFileTruncateSize"=hex:00,00,10
    "ServerAsProxy"=hex:00
    "ServerComment"="Server Comment"
    "ScriptTimeout"=hex:84,03
    "ServerSideIncludesEnabled"=hex:00
    "ServerSideIncludesExtension"=".stm"
    "CreateProcessAsUser"=hex:00
    "ReturnUrlUsingHostName"=hex:01
    "NTAuthenticationProviders"="NTLM"
    "Authorization"=dword:00000003
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\W3Svc\Parameters\Virtual Roots]
    "/"="C:\\WebShare\\wwwroot,,1"
    "/Scripts"="C:\\WebShare\\scripts,,4"
    "/Htmla"="C:\\Program Files\\WebSvr\\Htmla,,1"
    "/Docs"="C:\\Program Files\\WebSvr\\Docs,,1"
    "/HtmlaScripts"="C:\\Program Files\\WebSvr\\Htmlascr,,4"
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\W3Svc\Parameters\Script Map]
    ".idc"="C:\\WebShare\\Scripts\\httpodbc.dll"
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\W3Svc\Parameters\Deny IP List]
    @=""
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\W3Svc\Parameters\Grant IP List]
    @=""
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\ASD\Prob\{CF2524C0-29AE-11CF-97EA-00AA0034319D}]
    "NETWORK\\MSWEBSVR\\0000"=hex:00
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\ServiceProvider\ServiceTypes]
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\ServiceProvider\ServiceTypes\MSFTPSVC]
    "TcpPort"=hex:15
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\ServiceProvider\ServiceTypes\W3Svc]
    "TcpPort"=hex:50
[HKEY_LOCAL_MACHINE\Enum\Network\MSTCP\0000\Bindings]
    "MSWEBSVR\\0000"=""
[HKEY_LOCAL_MACHINE\Enum\Network\MSWEBSVR]
[HKEY_LOCAL_MACHINE\Enum\Network\MSWEBSVR\0000]
    "Class"="NetService"
    "Driver"="NetService\\0000"
    "MasterCopy"="Enum\\Network\\MSWEBSVR\\0000"
    "DeviceDesc"="Personal Web Server"
    "CompatibleIDs"="MSWEBSVR"
    "Mfg"="Microsoft"
    "ClassGUID"="{4d36e974-e325-11ce-bfc1-08002be10318}"
    "ConfigFlags"=hex:10,00,00,00
    "Capabilities"=hex:14,00,00,00
[HKEY_LOCAL_MACHINE\Enum\Network\MSWEBSVR\0000\Bindings]
[HKEY_LOCAL_MACHINE\Security\Provider]
    "Platform_Type"=hex:02,00,00,00
    "Address_Book"="mswebab.dll"
    "NoCache"=hex:01
[HKEY_LOCAL_MACHINE\Security\Provider\Platform_Type]
    @="."
[HKEY_LOCAL_MACHINE\Security\ACCESS]
[HKEY_LOCAL_MACHINE\Security\ACCESS\C:]
[HKEY_LOCAL_MACHINE\Security\ACCESS\C:\WEBSHARE]
[HKEY_LOCAL_MACHINE\Security\ACCESS\C:\WEBSHARE\WWWROOT]
    "*"=hex:81,80
[HKEY_LOCAL_MACHINE\Security\ACCESS\C:\WEBSHARE\SCRIPTS]
    "*"=hex:81,80
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\depends.h ===
#include <objbase.h>
#include <delayimp.h>
#include "stdafx.h"

#define MI_MODULE                  0
#define MI_DUPLICATE               1
#define MI_EXPORT_ERROR            2    
#define MI_DUPLICATE_EXPORT_ERROR  3
#define MI_NOT_FOUND               4
#define MI_ERROR                   5


//******************************************************************************
//***** CFunction
//******************************************************************************
class CFunction {
public:
   CFunction *m_pNext;
   int        m_ordinal;
   int        m_hint;
   DWORD_PTR  m_dwAddress;
   DWORD_PTR  m_dwExtra;
   CHAR       m_szName[1];

   // The m_dwExtra field's purpose is dependent on whether the CFunction
   // object is an export or an import.  For imports, it is a pointer to the
   // associated export in the child module.  If the import was not resolved,
   // then this value will be NULL.  For exports, the m_dwExtra field is a
   // pointer to a forward string.  If the export has no forward string, then
   // this member will be NULL.

   inline CFunction* GetAssociatedExport() { return (CFunction*)m_dwExtra; }
   inline LPCSTR     GetForwardString()    { return (LPCSTR)m_dwExtra; }
};


//******************************************************************************
//***** CModuleData
//******************************************************************************

// Every CModule object points to a CModuleData object. There is a single
// CModuleData for every unique module we process. If a module is duplicated in
// in our tree, there will be a CModule object for each instance, but they will
// all point to the same CModuleData object. For each unique module, a CModule
// object and a CModuleData object are created and the module is opened and
// processed. For every duplicate module, just a CModule object is created and
// pointed to the existing CModuleData. Duplicate modules are never opened since
// all the data that would be achieved by processing the file are already stored
// in the CModuleData.

class CModuleData {
public:
   // Flag to determine if this module has been processed yet.
   BOOL m_fProcessed;

   // Filled in by GetFileInfo()
   DWORD m_dwTimeStamp;
   DWORD m_dwSize;
   DWORD m_dwAttributes;

   // Filled in by GetModuleInfo()
   DWORD m_dwMachine;
   DWORD m_dwSubsystem;
   DWORD_PTR m_dwBaseAddress;
   DWORD m_dwImageVersion;
   DWORD m_dwLinkerVersion;
   DWORD m_dwOSVersion;
   DWORD m_dwSubsystemVersion;

   // Filled in by GetVersionInfo()
   DWORD m_dwFileVersionMS;
   DWORD m_dwFileVersionLS;
   DWORD m_dwProductVersionMS;
   DWORD m_dwProductVersionLS;

   // Build by BuildExports()
   CFunction *m_pExports;

   // Filled in by CheckForDebugInfo()
   BOOL m_fDebug;

   // Allocated and filled in by SetModuleError() if an error occurs.
   LPSTR m_pszError;
   BOOL  m_fFileNotFound;

   // Allocated and filled in by CreateModule()
   LPSTR m_szFile;
   CHAR  m_szPath[1];
};


//******************************************************************************
//***** CModule
//******************************************************************************
class CModule {
public:
   // Our next sibling module.
   CModule *m_pNext;

   // Head pointer to a list of dependent modules.
   CModule *m_pDependents;

   // Head pointer to a list of functions that our parent module imports from us.
   CFunction *m_pParentImports;

   // If we are a duplicate, then this will point to the original CModule.
   CModule *m_pModuleOriginal;

   // Depth of this module in our tree. Used to catch circular dependencies.
   int m_depth;

   // Set if any of our parent's imports can't be matched to one of our exports.
   BOOL m_fExportError;

   // Set if this module was included in the tree because of a forward call.
   BOOL m_fForward;

   // Set if this module was included via Delay Load import.
   BOOL m_fDelayLoad;

   // Pointer to the bulk of our module's processed information.
   CModuleData *m_pData;

   inline int GetImage() {
      return ((m_pData->m_fFileNotFound)            ? MI_NOT_FOUND :
              (m_pData->m_pszError)                 ? MI_ERROR :
              (m_pModuleOriginal && m_fExportError) ? MI_DUPLICATE_EXPORT_ERROR :
              (m_fExportError)                      ? MI_EXPORT_ERROR :
              (m_pModuleOriginal)                   ? MI_DUPLICATE : MI_MODULE);
   }
};

class CDepends {

// Internal variables
protected:
   // The following 5 members contain information about the currently opened
   // module file. We can store them here in our document since there is never
   // a time when two files are open at once.
   HANDLE                 m_hFile;
   LPVOID                 m_lpvFile;
   PIMAGE_FILE_HEADER     m_pIFH;
   PIMAGE_OPTIONAL_HEADER m_pIOH;
   PIMAGE_SECTION_HEADER  m_pISH;

   BOOL  m_fOutOfMemory;
   BOOL  m_fCircularError;
   BOOL  m_fMixedMachineError;
   DWORD m_dwMachineType;

// Public variables
public:
   CModule           *m_pModuleRoot;
   CStringList       m_cstrlstListOfBrokenLinks;
   int               m_iNumberOfBrokenLinks;

   int      m_cxOrdinal;
   int      m_cxHint;
   int      m_cImports;
   int      m_cExports;

// Public Functions
public:
   CDepends();
   virtual  ~CDepends();
   BOOL     SetInitialFilename(LPCSTR lpszPathName);
   CModule* LoopThruAndPrintLosers(CModule *pModuleCur);
   void     DeleteContents();

// Internal functions
protected:
   CFunction* CreateFunction(int ordinal, int hint, LPCSTR szName, DWORD_PTR dwAddress, LPCSTR szForward = NULL);

   CModule*   CreateModule(LPCSTR szPath, int depth);
   void       DeleteModule(CModule *pModule);
   CModule*   FindModule(CModule *pModuleCur, LPCSTR szPath);

   void       SetModuleError(CModule *pModule, LPCTSTR szFormat, ...);
   BOOL       VerifyModule(CModule *pModule);
   BOOL       GetModuleInfo(CModule *pModule);

   BOOL       BuildImports(CModule *pModule);
   BOOL       BuildDelayImports(CModule *pModule);
   BOOL       WalkIAT(PIMAGE_THUNK_DATA pITDF, PIMAGE_THUNK_DATA pITDA, CModule *pModule, DWORD_PTR dwBase);
   BOOL       BuildExports(CModule *pModule);
   BOOL       VerifyParentImports(CModule *pModule);
   BOOL       ProcessModule(CModule *pModule);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\dllmain.h ===
#include "stdafx.h"

// Function Prototypes
DWORD_PTR OC_WIZARD_CREATED_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_FILE_BUSY_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_PREINITIALIZE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_INIT_COMPONENT_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_SET_LANGUAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_QUERY_IMAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
#ifdef _WIN64
   DWORD_PTR OC_QUERY_IMAGE_EX_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
#endif
DWORD_PTR OC_QUERY_STATE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_QUERY_CHANGE_SEL_STATE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_QUERY_SKIP_PAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_CALC_DISK_SPACE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_QUEUE_FILE_OPS_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_NEED_MEDIA_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_NOTIFICATION_FROM_QUEUE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_QUERY_STEP_COUNT_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_ABOUT_TO_COMMIT_QUEUE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_COMPLETE_INSTALLATION_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);
DWORD_PTR OC_CLEANUP_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);

void  GetShortDesc(LPCTSTR SubcomponentId, LPTSTR szShortDesc);
void  StartInstalledServices(void);
void  SetIISSetupMode(DWORD dwSetupMode);
void  ParseCmdLine(void);
void  HandleMetabaseBeforeSetupStarts();
DWORD HandleFileBusyOurSelf(PFILEPATHS pFilePath);
DWORD RemoveComponent(IN LPCTSTR SubcomponentId, int iThePartToDo);
int   AtLeastOneComponentIsTurnedOn(IN HINF hInfFileHandle);

void TestClusterRead(LPWSTR pszClusterName);
void TestAfterInitApp(void);
void SumUpProgressBarTickGauge(IN LPCTSTR SubcomponentId);

void WINAPI IIS5Log(int iLogType, TCHAR *pszfmt);
void WINAPI IIS5LogParmString(int iLogType, TCHAR *pszfmt, TCHAR *pszString);
void WINAPI IIS5LogParmDword(int iLogType, TCHAR *pszfmt, DWORD dwErrorCode);

int MigrateAllWin95Files(void);
int HandleWin95MigrateDll(void);
int GimmieOriginalWin95MetabaseBin(TCHAR * szReturnedFilePath);
int GetTheRightWin95MetabaseFile(void);

ACTION_TYPE GetIISCoreAction(int iLogResult);
ACTION_TYPE GetSubcompAction(LPCTSTR SubcomponentId, int iLogResult);
STATUS_TYPE GetSubcompInitStatus(LPCTSTR SubcomponentId);
void StopAllServicesThatAreRelevant(int iShowErrorsFlag);
void DisplayActionsForAllOurComponents(IN HINF hInfFileHandle);
int CheckIfWeNeedToMoveMetabaseBin(void);
BOOL ToBeInstalled(LPCTSTR ComponentId, LPCTSTR SubcomponentId);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\elem.cpp ===
#include "stdafx.h"

#include "elem.h"

CElem::CElem()
{
    m_hKey = NULL;
    m_index = 0;
    m_ip = _T("");
    m_name = _T("");
    m_value = _T("");
}

CElem::~CElem()
{
    if (m_hKey) 
        RegCloseKey(m_hKey);
}

BOOL CElem::OpenReg(LPCTSTR szSubKey)
{
    BOOL fReturn = FALSE;
    LONG err = ERROR_SUCCESS;
    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubKey, 0, KEY_READ, &m_hKey);
    if (ERROR_SUCCESS  == err)
    {
        fReturn = TRUE;
    }
    else
    {
        m_hKey = NULL;
        if ( err != ERROR_FILE_NOT_FOUND ) 
            {iisDebugOut((LOG_TYPE_ERROR, _T("CElem::OpenReg(): %s.  FAILED.  code=0x%x\n"), szSubKey, err));}
    }

    return (fReturn);
}

void CElem::CloseReg()
{
    if (m_hKey) 
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }
}

BOOL CElem::GetNext()
{
    BOOL fReturn = FALSE;
    LONG err = ERROR_SUCCESS;
    TCHAR szBufferL[_MAX_PATH], szBufferR[_MAX_PATH];
    DWORD dwBufferL = _MAX_PATH, dwBufferR = _MAX_PATH;

    err = RegEnumValue(m_hKey, m_index, szBufferL, &dwBufferL, NULL, NULL, (LPBYTE)szBufferR, &dwBufferR);
    if (err == ERROR_SUCCESS) 
    {
        LPTSTR token;
        m_index++;
        m_value = szBufferR;

        token = _tcstok(szBufferL, _T(","));
        if (token) {
            m_name = token;
            token = _tcstok(NULL, _T(","));
            if (token) {
                m_ip = token;
            } else {
                m_ip = _T("null");
            }
            fReturn = TRUE;
        }

        m_name.MakeLower();
        m_value.MakeLower();

        //
        // m_name  looks like = /scripts
        // m_value looks like = c:\inetpub\scripts,,4
        //
        // m_value could look like anything
        // c:
        // c:\stuff
        // c:\whatevers\
        // who knows what they put in there.
        // we need to make sure it look like a fully qualified path though.
        //

        // Get the first Value before the comma
        int iWhere = 0;
        iWhere = m_value.Find(_T(','));
        if (-1 != iWhere)
        {
            CString BeforeComma;
            CString AfterComma;

            // there is a ',' in the string
            BeforeComma = m_value.Left(iWhere);

            // Get the after comma vlues
            AfterComma = m_value.Right( m_value.GetLength() - iWhere);

            TCHAR thefilename[_MAX_PATH];
            TCHAR thepath[_MAX_PATH];
            TCHAR * pmypath;
            _stprintf(thefilename, _T("%s"), BeforeComma);

            // make sure the left side is a valid directory name!
            if (0 != GetFullPathName(thefilename, _MAX_PATH, thepath, &pmypath))
                {BeforeComma = thepath;}

            // reconcatenate them
            m_value = BeforeComma;
            m_value += AfterComma;
        }
    }
    else
    {
        if ( err != ERROR_FILE_NOT_FOUND && err != ERROR_NO_MORE_ITEMS) 
            {iisDebugOut((LOG_TYPE_WARN, _T("CElem::GetNext(): FAILED.  code=0x%x\n"), err));}
    }

    return (fReturn);
}

void CElem::ReadRegVRoots(LPCTSTR szSubKey, CMapStringToOb *pMap)
{
    if ( OpenReg(szSubKey) ) 
    {
        while (GetNext()) 
        {
            Add(pMap);
        }
        CloseReg();
    }
}

void CElem::Add(CMapStringToOb *pMap)
{
    CObject *pObj;
    CMapStringToString *pNew;

    if (pMap->Lookup(m_ip, pObj) == TRUE) {
        pNew = (CMapStringToString*)pObj;
        pNew->SetAt(m_name, m_value);
    } else {
        pNew = new CMapStringToString;
        pNew->SetAt(m_name, m_value);
        pMap->SetAt(m_ip, (CObject*)pNew);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\dllmain.cpp ===
#include "stdafx.h"
#include <afxinet.h>
#include <ole2.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"
#include "massupdt.h"
#include "setupapi.h"
#include "ocmanage.h"
#include "browsedi.h"
#include "log.h"
#include "other.h"
#include "mtxadmii.c"
#include "mtxadmin.h"
#include "mdentry.h"
#include "depends.h"
#include "kill.h"
#include "svc.h"
#include "wolfpack.h"
#include "dllmain.h"
#include "ocpages.h"
#pragma hdrstop

int g_GlobalTickValue = 1;
int g_GlobalGuiOverRide = 0;
int g_GlobalTotalTickGaugeCount = 0;
int g_GlobalTickTotal_iis_common = 0;
int g_GlobalTickTotal_iis_inetmgr = 0;
int g_GlobalTickTotal_iis_www = 0;
int g_GlobalTickTotal_iis_pwmgr = 0;
int g_GlobalTickTotal_iis_doc = 0;
int g_GlobalTickTotal_iis_htmla = 0;
int g_GlobalTickTotal_iis_ftp = 0;

TCHAR g_szCurrentSubComponent[20];

// OcManage globals
OCMANAGER_ROUTINES gHelperRoutines;
HANDLE g_MyModuleHandle = NULL;

const TCHAR OC_MANAGER_SETUP_KEY[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents");

const TCHAR OCM_OptionalComponents_Section[] = _T("Optional Components");
const TCHAR STRING_iis_ftp[]   = _T("iis_ftp");
const TCHAR STRING_iis_htmla[] = _T("iis_htmla");
const TCHAR STRING_iis_doc[]   = _T("iis_doc");
const TCHAR STRING_iis_pwmgr[] = _T("iis_pwmgr");
const TCHAR STRING_iis_www[]   = _T("iis_www");
const TCHAR STRING_iis_inetmgr[] = _T("iis_inetmgr");
const TCHAR STRING_iis_core[]    = _T("iis_core");
const TCHAR STRING_iis_common[]  = _T("iis_common");
const TCHAR STRING_iis_www_parent[]   = _T("iis_www_parent");
const TCHAR STRING_iis_www_vdir_scripts[]   = _T("iis_www_vdir_scripts");
const TCHAR STRING_iis_www_vdir_printers[]   = _T("iis_www_vdir_printers");

int g_iOC_WIZARD_CREATED_Called = FALSE;
int g_iOC_FILE_BUSY_Called = FALSE;
int g_iOC_PREINITIALIZE_Called = FALSE;
int g_iOC_INIT_COMPONENT_Called = FALSE;
int g_iOC_SET_LANGUAGE_Called = FALSE;
int g_iOC_QUERY_IMAGE_Called = FALSE;
int g_iOC_REQUEST_PAGES_Called = FALSE;
int g_iOC_QUERY_STATE_Called = FALSE;
int g_iOC_QUERY_CHANGE_SEL_STATE_Called = FALSE;
int g_iOC_QUERY_SKIP_PAGE_Called = FALSE;
int g_iOC_CALC_DISK_SPACE_Called = FALSE;
int g_iOC_QUEUE_FILE_OPS_Called = FALSE;
int g_iOC_NEED_MEDIA_Called = FALSE;
int g_iOC_NOTIFICATION_FROM_QUEUE_Called = FALSE;
int g_iOC_QUERY_STEP_COUNT_Called = FALSE;
int g_iOC_ABOUT_TO_COMMIT_QUEUE_Called = FALSE;
int g_iOC_COMPLETE_INSTALLATION_Called = FALSE;
int g_iOC_CLEANUP_Called = FALSE;
int g_iOC_DEFAULT_Called = FALSE;

int g_Please_Call_Register_iis_inetmgr = FALSE;

HSPFILEQ g_GlobalFileQueueHandle = NULL;
int g_GlobalFileQueueHandle_ReturnError = 0;

CInitApp *g_pTheApp;

BOOL g_bGlobalWriteUnSecuredIfFailed_All  = FALSE;

// 0 = log errors only
// 1 = log warnings
// 2 = trace
// 3 = trace win32 stuff
int g_GlobalDebugLevelFlag = 3;
int g_GlobalDebugLevelFlag_WasSetByUnattendFile = FALSE;
int g_GlobalDebugCallValidateHeap = 1;
int g_GlobalDebugCrypto = 0;
int g_GlobalFastLoad = 0;

TCHAR g_szLastSectionToGetCalled[50];

// Logging class
MyLogFile g_MyLogFile;


int CheckInfInstead(int iPrevious)
{
    INFCONTEXT Context;
    int iTempFlag = 0;
    TCHAR szPersonalFlag[20] = _T("");

    iTempFlag = iPrevious;
    if (SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, _T("SetupInfo"), _T("Personal"), &Context) )
    {
        SetupGetStringField(&Context, 1, szPersonalFlag, 50, NULL);
        if (IsValidNumber((LPCTSTR)szPersonalFlag)) 
        {
            iTempFlag = _ttoi(szPersonalFlag);
            iTempFlag++;
        }
    }
 
    return (iTempFlag);
}


BOOL IsWhistlerPersonal(void)
{
    static int PersonalSKU = 0;

    if (0 == PersonalSKU)
    {
        OSVERSIONINFOEX osvi;

        //
        // Determine if we are installing Personal SKU
        //
        ZeroMemory( &osvi, sizeof( OSVERSIONINFOEX ) );
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        GetVersionEx((OSVERSIONINFO *) &osvi);

        if (osvi.wProductType == VER_NT_WORKSTATION && (osvi.wSuiteMask & VER_SUITE_PERSONAL))
        {
            PersonalSKU = 2;
        }
        else
        {
            PersonalSKU = 1;
        }

        PersonalSKU = CheckInfInstead(PersonalSKU);
    }

    return (PersonalSKU - 1);
}


void WINAPI ProcessInfSection(CHAR *pszSectionName)
{
    BOOL bPleaseCloseInfHandle = FALSE;
    TCHAR szWindowsDir[_MAX_PATH];
    TCHAR szFullPath[_MAX_PATH];
    TCHAR wszWideString[MAX_PATH];
    int MySavedDebugLevel = 0;

    _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("ProcessInfSection:"));
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("ProcessInfSection: Start.\n")));

    if (!pszSectionName)
        {goto ProcessInfSection_Exit;}

    if (!g_pTheApp->m_hInfHandle || g_pTheApp->m_hInfHandle == INVALID_HANDLE_VALUE)
    {
        g_pTheApp->m_hInfHandle = INVALID_HANDLE_VALUE;

        // get the c:\winnt dir
        if (0 == GetWindowsDirectory(szWindowsDir, _MAX_PATH))
            {goto ProcessInfSection_Exit;}

        // Tack on the inf\iis.inf subdir and filename
        _stprintf(szFullPath, _T("%s\\inf\\iis.inf"),szWindowsDir);
  
	    // Check if the file exists
        if (TRUE != IsFileExist(szFullPath))
            {
            iisDebugOut((LOG_TYPE_WARN, _T("ProcessInfSection: %s does not exist!\n"),szFullPath));
            goto ProcessInfSection_Exit;
            }

        // Get a handle to it.
        g_pTheApp->m_hInfHandle = SetupOpenInfFile(szFullPath, NULL, INF_STYLE_WIN4, NULL);
        if (!g_pTheApp->m_hInfHandle || g_pTheApp->m_hInfHandle == INVALID_HANDLE_VALUE)
            {
            iisDebugOut((LOG_TYPE_WARN, _T("ProcessInfSection: SetupOpenInfFile failed on file: %s.\n"),szFullPath));
            goto ProcessInfSection_Exit;
            }
        bPleaseCloseInfHandle = TRUE;
    }

    // get the debug level from the iis.inf
    GetDebugLevelFromInf(g_pTheApp->m_hInfHandle);

    MySavedDebugLevel = g_GlobalDebugLevelFlag;
    // reset global debug level only most of the time
    if (LOG_TYPE_TRACE_WIN32_API < g_GlobalDebugLevelFlag)
        {g_GlobalDebugLevelFlag = LOG_TYPE_ERROR;}

    // Read .inf file and set some globals from the information in there.
    ReadGlobalsFromInf(g_pTheApp->m_hInfHandle);
    g_pTheApp->InitApplication();
    SetDIRIDforThisInf(g_pTheApp->m_hInfHandle);

    //g_pTheApp->DumpAppVars();
    g_GlobalDebugLevelFlag = MySavedDebugLevel;

    // See if user configured anything
    ReadUserConfigurable(g_pTheApp->m_hInfHandle);
    
    // Convert the input to a wide char if ProcessSection() takes wide type.
#if defined(UNICODE) || defined(_UNICODE)
    MultiByteToWideChar( CP_ACP, 0, pszSectionName, -1, wszWideString, MAX_PATH);
#else
    _tcscpy(wszWideString, pszSectionName);
#endif
    ProcessSection(g_pTheApp->m_hInfHandle, wszWideString);

ProcessInfSection_Exit:
    if (TRUE == bPleaseCloseInfHandle)
        {if(g_pTheApp->m_hInfHandle != INVALID_HANDLE_VALUE) {SetupCloseInfFile(g_pTheApp->m_hInfHandle);g_pTheApp->m_hInfHandle = INVALID_HANDLE_VALUE;}}

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("ProcessInfSection: End.\n")));
    return;
}

void WINAPI IIS5Log(int iLogType, TCHAR *pszfmt)
{
    iisDebugOut((iLogType, pszfmt));
}

void WINAPI IIS5LogParmString(int iLogType, TCHAR *pszfmt, TCHAR *pszString)
{
    if ( _tcsstr(pszfmt, _T("%s")) || _tcsstr(pszfmt, _T("%S")))
    {
        iisDebugOut((iLogType, pszfmt, pszString));
    }
    else
    {
        iisDebugOut((iLogType, pszfmt));
        iisDebugOut((iLogType, pszString));
    }
}

void WINAPI IIS5LogParmDword(int iLogType, TCHAR *pszfmt, DWORD dwErrorCode)
{
    if ( _tcsstr(pszfmt, _T("%x")) || _tcsstr(pszfmt, _T("%X")) || _tcsstr(pszfmt, _T("%d")) || _tcsstr(pszfmt, _T("%D")))
    {
        iisDebugOut((iLogType, pszfmt, dwErrorCode));
    }
    else
    {
        iisDebugOut((iLogType, pszfmt));
        iisDebugOut((iLogType, _T("%d"), dwErrorCode));
    }
}

void TestAfterInitApp(void)
{
    //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("...... Start\n")));
    //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("...... End\n")));
    return;
}

extern "C" void InitializeIISRTL2();
extern "C" void TerminateIISRTL2();

//
// Standard Win32 DLL Entry point
//
BOOL WINAPI DllMain(IN HANDLE DllHandle,IN DWORD  Reason,IN LPVOID Reserved)
{
    BOOL bReturn = TRUE;
    UNREFERENCED_PARAMETER(Reserved);
    bReturn = TRUE;
    CString csTempPath;

    switch(Reason)
    {
        case DLL_PROCESS_ATTACH:
            InitializeIISRTL2();

            // Because Heap problems with IISRTL, we must make sure that anything that
            // uses stuff from iisrtl, must NOT live beyond the scope of 
            // InitializeIISRTL2 and TerminateIISRTL2!!!
            g_pTheApp = new (CInitApp);

            if ( !g_pTheApp )
            {
                bReturn = FALSE;
            }

            if (!g_MyModuleHandle)
            {
                srand(GetTickCount());
                g_MyModuleHandle = DllHandle;

                // open the log file.
#ifdef IIS60
                g_MyLogFile.LogFileCreate(_T("iis6.log"));
#else
                g_MyLogFile.LogFileCreate(_T("iis5.log"));
#endif
                gHelperRoutines.OcManagerContext = NULL;
            }

            break;

        case DLL_THREAD_ATTACH:
            bReturn = TRUE;
            break;

        case DLL_PROCESS_DETACH:
            _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("Final Check:"));
            // only do the final check if we are actually run from sysocmgr.exe!
            // and the first thing that sysocmgr.exe does is call preinitialize, so let's check for that!
            if (g_iOC_PREINITIALIZE_Called)
            {
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("=======================\n")));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_PREINITIALIZE Called=%d\n"), g_iOC_PREINITIALIZE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_INIT_COMPONENT Called=%d\n"), g_iOC_INIT_COMPONENT_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_SET_LANGUAGE Called=%d\n"), g_iOC_SET_LANGUAGE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_QUERY_IMAGE Called=%d\n"), g_iOC_QUERY_IMAGE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_REQUEST_PAGES Called=%d\n"), g_iOC_REQUEST_PAGES_Called));
			    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_WIZARD_CREATED Called=%d\n"), g_iOC_WIZARD_CREATED_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_QUERY_STATE Called=%d\n"), g_iOC_QUERY_STATE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_QUERY_CHANGE_SEL_STATE Called=%d\n"), g_iOC_QUERY_CHANGE_SEL_STATE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_QUERY_SKIP_PAGE Called=%d\n"), g_iOC_QUERY_SKIP_PAGE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_CALC_DISK_SPACE Called=%d\n"), g_iOC_CALC_DISK_SPACE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_QUEUE_FILE_OPS Called=%d\n"), g_iOC_QUEUE_FILE_OPS_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_NEED_MEDIA Called=%d\n"), g_iOC_NEED_MEDIA_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_NOTIFICATION_FROM_QUEUE Called=%d\n"), g_iOC_NOTIFICATION_FROM_QUEUE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_QUERY_STEP_COUNT Called=%d\n"), g_iOC_QUERY_STEP_COUNT_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_ABOUT_TO_COMMIT_QUEUE Called=%d\n"), g_iOC_ABOUT_TO_COMMIT_QUEUE_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_FILE_BUSY Called=%d\n"), g_iOC_FILE_BUSY_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_COMPLETE_INSTALLATION Called=%d\n"), g_iOC_COMPLETE_INSTALLATION_Called));
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("OC_CLEANUP Called=%d\n"), g_iOC_CLEANUP_Called));
                iisDebugOut((LOG_TYPE_TRACE, _T("OC_DEFAULT Called=%d\n"), g_iOC_DEFAULT_Called));
                _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("Final Check:"));

			    // Check if g_iOC_COMPLETE_INSTALLATION_Called was called!!!!!
			    if (!g_iOC_COMPLETE_INSTALLATION_Called)
			    {
                    if (g_pTheApp->m_fNTGuiMode)
                    {
				        iisDebugOut((LOG_TYPE_ERROR, _T("WARNING.FAILURE: OC_COMPLETE_INSTALLATION was not called (by ocmanage.dll) for this component.  IIS was not installed or configured!!  This will be a problem for other ocm installed components as well.\n")));
                    }
			    }
            }
            // log the heap state
            LogHeapState(TRUE, __FILE__, __LINE__);

            // free some memory
            FreeTaskListMem();
            UnInit_Lib_PSAPI();

            // Close the log file
            g_MyLogFile.LogFileClose();

            ASSERT(g_pTheApp);
            delete (g_pTheApp);
            g_pTheApp = NULL;

            TerminateIISRTL2();

            break;

        case DLL_THREAD_DETACH:
            break;
    }

    return(bReturn);
}


BOOL g_fFranceHackAttempted = FALSE;
LCID g_TrueThreadLocale;

DWORD WINAPI FranceFixThread(LPVOID lpParameter)
{
    g_TrueThreadLocale = GetThreadLocale ();
    return 0;
}


// -----------------------------------------------
// OcEntry is the main entry point (After DllMain)
// -----------------------------------------------
DWORD_PTR OcEntry(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;
    _tcscpy(g_szCurrentSubComponent, _T(""));
    if (SubcomponentId) {_tcscpy(g_szCurrentSubComponent, SubcomponentId);}


    if (!g_fFranceHackAttempted)
    {
        g_fFranceHackAttempted = TRUE;
        LCID            InitialThreadLocale;
        DWORD           thid;

       InitialThreadLocale = GetThreadLocale ();
       iisDebugOut((LOG_TYPE_TRACE, _T("Initial thread locale=%0x\n"),InitialThreadLocale));

        HANDLE hHackThread = CreateThread (NULL,0,FranceFixThread,NULL,0,&thid);
        if (hHackThread)
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("Starting to wait On France fix thread\n")));

            // wait for 10 secs only
            DWORD res = WaitForSingleObject (hHackThread,10*1000);
            if (res==WAIT_TIMEOUT)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("ERROR France fix thread never finished...\n")));
            }
            else
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("returned from France fix with locale %0x \n"),g_TrueThreadLocale));
                CloseHandle (hHackThread);

                // do that only if locales are different and another one is France
                if (g_TrueThreadLocale !=InitialThreadLocale && g_TrueThreadLocale==0x40c)
                {
                BOOL ret = SetThreadLocale (g_TrueThreadLocale);
                iisDebugOut((LOG_TYPE_TRACE, _T("SetThreadLocale returned %d\n"),ret));

                g_TrueThreadLocale = GetThreadLocale ();
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("France fix succeed=%0x\n"),g_TrueThreadLocale));
                }

            }
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("Failed to start France fix thread. error =%0x\n"),GetLastError()));
        }
    }


    
    switch(Function)
    {
    case OC_WIZARD_CREATED:
        g_iOC_WIZARD_CREATED_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_WIZARD_CREATED:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End. Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
        DisplayActionsForAllOurComponents(g_pTheApp->m_hInfHandle);
        break;

    case OC_FILE_BUSY:
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_FILE_BUSY:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        // if the first time this function was
        // called then show all running services
        LogHeapState(FALSE, __FILE__, __LINE__);
        if (g_iOC_FILE_BUSY_Called != TRUE)
        {
            // display locked dlls by setup
            // This seems to thru exceptions on build nt5 build 1980.
            // comment this out since it's not crucial.
            //LogThisProcessesDLLs();
            // display running services
            LogEnumServicesStatus();
        }
        g_iOC_FILE_BUSY_Called = TRUE;
        dwOcEntryReturn = OC_FILE_BUSY_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        LogHeapState(FALSE, __FILE__, __LINE__);
        break;

    case OC_PREINITIALIZE:
        g_iOC_PREINITIALIZE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_PREINITIALIZE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_PREINITIALIZE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_INIT_COMPONENT:
        g_iOC_INIT_COMPONENT_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_INIT_COMPONENT:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_INIT_COMPONENT_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_SET_LANGUAGE:
        g_iOC_SET_LANGUAGE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_SET_LANGUAGE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_SET_LANGUAGE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

#ifdef _WIN64
    case OC_QUERY_IMAGE_EX:
        g_iOC_QUERY_IMAGE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_QUERY_IMAGE_EX:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_QUERY_IMAGE_EX_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;
#endif

    case OC_QUERY_IMAGE:
        g_iOC_QUERY_IMAGE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_QUERY_IMAGE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_QUERY_IMAGE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_REQUEST_PAGES:
        g_iOC_REQUEST_PAGES_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_REQUEST_PAGES:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_REQUEST_PAGES_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUERY_STATE:
        g_iOC_QUERY_STATE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_QUERY_STATE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_QUERY_STATE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        g_iOC_QUERY_CHANGE_SEL_STATE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_QUERY_CHANGE_SEL_STATE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_QUERY_CHANGE_SEL_STATE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUERY_SKIP_PAGE:
        g_iOC_QUERY_SKIP_PAGE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_QUERY_SKIP_PAGE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_QUERY_SKIP_PAGE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_CALC_DISK_SPACE:
        g_iOC_CALC_DISK_SPACE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_CALC_DISK_SPACE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_CALC_DISK_SPACE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUEUE_FILE_OPS:
        ProgressBarTextStack_Set(IDS_IIS_ALL_FILEOPS);
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_QUEUE_FILE_OPS:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        if (g_iOC_QUEUE_FILE_OPS_Called != TRUE)
        {
            // turn logging back on if we need to
            // get the debug level from the iis.inf
            if (g_GlobalFastLoad)
            {
                GetDebugLevelFromInf(g_pTheApp->m_hInfHandle);
                // output stuff that we missed during init
                g_pTheApp->DumpAppVars();
            }
        }
        g_iOC_QUEUE_FILE_OPS_Called = TRUE;
        dwOcEntryReturn = OC_QUEUE_FILE_OPS_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        ProgressBarTextStack_Pop();
        break;

    case OC_NEED_MEDIA:
        g_iOC_NEED_MEDIA_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_NEED_MEDIA:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_NEED_MEDIA_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_NOTIFICATION_FROM_QUEUE:
        g_iOC_NOTIFICATION_FROM_QUEUE_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_NOTIFICATION_FROM_QUEUE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_NOTIFICATION_FROM_QUEUE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_QUERY_STEP_COUNT:
        g_iOC_QUERY_STEP_COUNT_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_QUERY_STEP_COUNT:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = OC_QUERY_STEP_COUNT_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_ABOUT_TO_COMMIT_QUEUE:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        LogHeapState(FALSE, __FILE__, __LINE__);
        if (g_iOC_ABOUT_TO_COMMIT_QUEUE_Called != TRUE)
        {
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE)
            {
                // display running processes
                LogCurrentProcessIDs();
                // display running services
                LogEnumServicesStatus();
                // log file versions
                LogImportantFiles();
                // display locked dlls by setup
                //LogThisProcessesDLLs();
                // check if temp dir is writeable
                LogCheckIfTempDirWriteable();
            }
        }
        g_iOC_ABOUT_TO_COMMIT_QUEUE_Called = TRUE;
        dwOcEntryReturn = OC_ABOUT_TO_COMMIT_QUEUE_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        LogHeapState(FALSE, __FILE__, __LINE__);
        break;

    case OC_COMPLETE_INSTALLATION:
        g_iOC_COMPLETE_INSTALLATION_Called = TRUE;
        //ProgressBarTextStack_Set(IDS_IIS_ALL_COMPLETE);
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_COMPLETE_INSTALLATION:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        LogHeapState(FALSE, __FILE__, __LINE__);
        // no need to do this, just slows things down
        //g_MyLogFile.m_bFlushLogToDisk = TRUE;
        if (g_iOC_COMPLETE_INSTALLATION_Called != TRUE)
        {
            // Get the debug level, incase we changed it during setup...
            GetDebugLevelFromInf(g_pTheApp->m_hInfHandle);
        }

        dwOcEntryReturn = OC_COMPLETE_INSTALLATION_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        LogHeapState(FALSE, __FILE__, __LINE__);
        g_MyLogFile.m_bFlushLogToDisk = FALSE;
        //ProgressBarTextStack_Pop();
        break;

    case OC_CLEANUP:
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_CLEANUP:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        LogHeapState(FALSE, __FILE__, __LINE__);
        if (g_iOC_CLEANUP_Called != TRUE)
        {
            // turn logging back on if we need to
            // get the debug level from the iis.inf
            if (g_GlobalFastLoad)
            {
                GetDebugLevelFromInf(g_pTheApp->m_hInfHandle);
            }
        }
        g_iOC_CLEANUP_Called = TRUE;
        dwOcEntryReturn = OC_CLEANUP_Func(ComponentId,SubcomponentId,Function,Param1,Param2);
        LogHeapState(FALSE, __FILE__, __LINE__);
        break;

    default:
        g_iOC_DEFAULT_Called = TRUE;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_(DEFAULT):"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        dwOcEntryReturn = 0;
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End.  Type=0x%x.  Return=%d\n"), ComponentId, SubcomponentId, Function, dwOcEntryReturn));
        break;
    }

    return(dwOcEntryReturn);
}


// -----------------------------------------------------
// Retrive the original state of the subcomponent
// -----------------------------------------------------
STATUS_TYPE GetSubcompInitStatus(LPCTSTR SubcomponentId)
{
    STATUS_TYPE nStatus = ST_UNINSTALLED;
    BOOL OriginalState;

#ifdef _CHICAGO_
    if (_tcsicmp(SubcomponentId, STRING_iis_ftp) == 0)
        {return nStatus;}
#endif //_CHICAGO_

    // Get the original state from the Helper Routines (which get it from the registry)
    OriginalState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL);
    if (OriginalState == 1) {nStatus = ST_INSTALLED;}
    if (OriginalState == 0) {nStatus = ST_UNINSTALLED;}

    return nStatus;
}


void DebugOutAction(LPCTSTR SubcomponentId, ACTION_TYPE nAction)
{
    switch (nAction)
    {
    case AT_DO_NOTHING:
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Action of [%s]\t= AT_DO_NOTHING.\n"), SubcomponentId));
        break;
    case AT_REMOVE:
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Action of [%s]\t= AT_REMOVE.\n"), SubcomponentId));
        break;
    case AT_INSTALL_FRESH:
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Action of [%s]\t= AT_INSTALL_FRESH.\n"), SubcomponentId));
        break;
    case AT_INSTALL_UPGRADE:
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Action of [%s]\t= AT_INSTALL_UPGRADE.\n"), SubcomponentId));
        break;
    case AT_INSTALL_REINSTALL:
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Action of [%s]\t= AT_INSTALL_REINSTALL.\n"), SubcomponentId));
        break;
    default:
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Action of [%s]\t= UN_DEFINED.\n"), SubcomponentId));
        break;
    }

    return;
}

// ---------------------------------------------------------
// OriginalState = 1 (means that it was previously installed and exists on the computer)
// OriginalState = 0 (means that it does not exist on the computer)
//
// CurrentState  = 1 (means please install the subcomponent)
// CurrentState  = 0 (means please remove  the subcomponent)
// ---------------------------------------------------------
ACTION_TYPE GetSubcompAction(LPCTSTR SubcomponentId, int iLogResult)
{
    ACTION_TYPE nReturn = AT_DO_NOTHING;
    BOOL CurrentState,OriginalState;

    OriginalState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL);
    CurrentState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_CURRENT);

    // if already installed and we want to remove it, then remove it
    if (OriginalState == 1 && CurrentState == 0) {nReturn = AT_REMOVE;}

    // if not installed and we want to install it, then install it.
    if (OriginalState == 0 && CurrentState == 1) {nReturn = AT_INSTALL_FRESH;}

    // if already installed and we want to install it, then Gee i dunno.
    // it could be a bunch of things
    if (OriginalState == 1 && CurrentState == 1)
    {
        if (g_pTheApp->m_eInstallMode == IM_UPGRADE) {nReturn = AT_INSTALL_UPGRADE;}
        if (g_pTheApp->m_dwSetupMode == SETUPMODE_REINSTALL) {nReturn = AT_INSTALL_REINSTALL;}
        if (g_pTheApp->m_dwSetupMode == SETUPMODE_ADDREMOVE) {nReturn = AT_DO_NOTHING;}
    }

    if (iLogResult)
    {
		TCHAR szTempString[50];
		_tcscpy(szTempString, _T("UN_DEFINED"));
		switch (nReturn)
		{
		case AT_DO_NOTHING:
			_tcscpy(szTempString, _T("AT_DO_NOTHING"));
			break;
		case AT_REMOVE:
			_tcscpy(szTempString, _T("AT_REMOVE"));
			break;
		case AT_INSTALL_FRESH:
			_tcscpy(szTempString, _T("AT_INSTALL_FRESH"));
			break;
		case AT_INSTALL_UPGRADE:
			_tcscpy(szTempString, _T("AT_INSTALL_UPGRADE"));
			break;
		case AT_INSTALL_REINSTALL:
			_tcscpy(szTempString, _T("AT_INSTALL_REINSTALL"));
			break;
		default:
			_tcscpy(szTempString, _T("UN_DEFINED"));
			break;
		}

        if (_tcsicmp(SubcomponentId, _T("iis")) == 0)
        {
            // use two tabs
            iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Action of [%s]\t\t= %s. Original=%d, Current=%d.\n"), SubcomponentId, szTempString, OriginalState, CurrentState));
        }
        else
        {
		    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Action of [%s]\t= %s. Original=%d, Current=%d.\n"), SubcomponentId, szTempString, OriginalState, CurrentState));
        }
    }

    return nReturn;
}



BOOL GetDataFromMetabase(LPCTSTR szPath, int nID, LPBYTE Buffer, int BufSize)
{
    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;

    CMDKey cmdKey;
    cmdKey.OpenNode(szPath);
    if ( (METADATA_HANDLE)cmdKey )
    {
        bFound = cmdKey.GetData(nID, &attr, &uType, &dType, &cbLen, (PBYTE)Buffer, BufSize);
        cmdKey.Close();
    }
    else
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetDataFromMetabase():%s:ID=%d.Could not open node.\n"),szPath,nID));
    }
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetDataFromMetabase():%s:ID=%d.ret=%d.\n"),szPath,nID,bFound));
    return (bFound);
}

void SetIISSetupMode(DWORD dwSetupMode)
{
    if (g_pTheApp->m_fInvokedByNT)
    {
        g_pTheApp->DefineSetupModeOnNT();
    }
    else
    {
        g_pTheApp->m_dwSetupMode = dwSetupMode;
    }

    if (g_pTheApp->m_dwSetupMode & SETUPMODE_UPGRADE){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_UPGRADE\n")));}
    if (g_pTheApp->m_dwSetupMode == SETUPMODE_UPGRADEONLY){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_UPGRADE | SETUPMODE_UPGRADEONLY\n")));}
    if (g_pTheApp->m_dwSetupMode == SETUPMODE_ADDEXTRACOMPS){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_UPGRADE | SETUPMODE_ADDEXTRACOMPS\n")));}

    if (g_pTheApp->m_dwSetupMode & SETUPMODE_MAINTENANCE){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_MAINTENANCE\n")));}
    if (g_pTheApp->m_dwSetupMode == SETUPMODE_ADDREMOVE){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_MAINTENANCE | SETUPMODE_ADDREMOVE\n")));}
    if (g_pTheApp->m_dwSetupMode == SETUPMODE_REINSTALL){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_MAINTENANCE | SETUPMODE_REINSTALL\n")));}
    if (g_pTheApp->m_dwSetupMode == SETUPMODE_REMOVEALL){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_MAINTENANCE | SETUPMODE_REMOVEALL\n")));}

    if (g_pTheApp->m_dwSetupMode & SETUPMODE_FRESH){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_FRESH\n")));}
    if (g_pTheApp->m_dwSetupMode == SETUPMODE_MINIMAL){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_FRESH | SETUPMODE_MINIMAL\n")));}
    if (g_pTheApp->m_dwSetupMode == SETUPMODE_TYPICAL){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_FRESH | SETUPMODE_TYPICAL\n")));}
    if (g_pTheApp->m_dwSetupMode == SETUPMODE_CUSTOM){iisDebugOut((LOG_TYPE_TRACE, _T("SetIISSetupMode() m_dwSetupMode=SETUPMODE_FRESH | SETUPMODE_CUSTOM\n")));}

    gHelperRoutines.SetSetupMode(gHelperRoutines.OcManagerContext, g_pTheApp->m_dwSetupMode);
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("IISSetupMode"),(PVOID)&(g_pTheApp->m_dwSetupMode),sizeof(DWORD),REG_DWORD);
    return;
}


BOOL ToBeInstalled(LPCTSTR ComponentId, LPCTSTR SubcomponentId)
{
    BOOL fReturn = FALSE;

    if ( SubcomponentId )
    {
        BOOL CurrentState,OriginalState;
        OriginalState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL);
        CurrentState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_CURRENT);
        if (OriginalState == 0 && CurrentState == 1)
            {fReturn = TRUE;}
    }

    return fReturn;
}

void CustomFTPRoot(LPCTSTR szFTPRoot)
{
    g_pTheApp->m_csPathFTPRoot = szFTPRoot;
    SetupSetDirectoryId_Wrapper(g_pTheApp->m_hInfHandle, 32769, g_pTheApp->m_csPathFTPRoot);
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathFTPRoot"),(PVOID)(LPCTSTR)g_pTheApp->m_csPathFTPRoot,(g_pTheApp->m_csPathFTPRoot.GetLength() + 1) * sizeof(TCHAR),REG_SZ);
    return;
}

void CustomWWWRoot(LPCTSTR szWWWRoot)
{
    TCHAR szParentDir[_MAX_PATH], szDir[_MAX_PATH];

    g_pTheApp->m_csPathWWWRoot = szWWWRoot;
    InetGetFilePath(szWWWRoot, szParentDir);

    g_pTheApp->m_csPathInetpub = szParentDir;
    SetupSetDirectoryId_Wrapper(g_pTheApp->m_hInfHandle, 32773, szParentDir);

    AppendDir(szParentDir, _T("iissamples"), szDir);
    g_pTheApp->m_csPathIISSamples = szDir;

    AppendDir(szParentDir, _T("webpub"), szDir);
    g_pTheApp->m_csPathWebPub = szDir;

    AppendDir(szParentDir, _T("scripts"), szDir);
    g_pTheApp->m_csPathScripts = szDir;

    AppendDir(szParentDir, _T("ASPSamp"), szDir);
    g_pTheApp->m_csPathASPSamp = szDir;

    g_pTheApp->m_csPathAdvWorks = g_pTheApp->m_csPathASPSamp + _T("\\AdvWorks");

    CString csPathScripts = g_pTheApp->m_csPathIISSamples + _T("\\Scripts");
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathScripts"),(PVOID)(LPCTSTR)csPathScripts,(csPathScripts.GetLength() + 1) * sizeof(TCHAR),REG_SZ);

    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathWWWRoot"),(PVOID)(LPCTSTR)g_pTheApp->m_csPathWWWRoot,(g_pTheApp->m_csPathWWWRoot.GetLength() + 1) * sizeof(TCHAR),REG_SZ);
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathIISSamples"),(PVOID)(LPCTSTR)g_pTheApp->m_csPathIISSamples,(g_pTheApp->m_csPathIISSamples.GetLength() + 1) * sizeof(TCHAR),REG_SZ);

    // Set inf file dir id's
    SetupSetDirectoryId_Wrapper(g_pTheApp->m_hInfHandle, 32770, g_pTheApp->m_csPathWWWRoot);
    SetupSetDirectoryId_Wrapper(g_pTheApp->m_hInfHandle, 32771, g_pTheApp->m_csPathIISSamples);
    SetupSetDirectoryId_Wrapper(g_pTheApp->m_hInfHandle, 32772, g_pTheApp->m_csPathScripts);
    SetupSetDirectoryId_Wrapper(g_pTheApp->m_hInfHandle, 32779, g_pTheApp->m_csPathWebPub);
    return;
}


void StartInstalledServices(void)
{
    ACTION_TYPE atWWW = GetSubcompAction(STRING_iis_www, FALSE);
    ACTION_TYPE atFTP = GetSubcompAction(STRING_iis_ftp, FALSE);
    STATUS_TYPE stFTP = GetSubcompInitStatus(STRING_iis_ftp);
    STATUS_TYPE stWWW = GetSubcompInitStatus(STRING_iis_www);

    iisDebugOut_Start(_T("StartInstalledServices()"), LOG_TYPE_TRACE);

    if (atWWW == AT_INSTALL_FRESH || atWWW == AT_INSTALL_UPGRADE || atWWW == AT_INSTALL_REINSTALL || (stWWW == ST_INSTALLED && atWWW != AT_REMOVE))
    {
#ifndef _CHICAGO_
        InetStartService(_T("W3SVC"));
#else
        W95StartW3SVC();
#endif // _CHICAGO_
    }

#ifndef _CHICAGO_
    if (atFTP == AT_INSTALL_FRESH || atFTP == AT_INSTALL_UPGRADE || atFTP == AT_INSTALL_REINSTALL || (stFTP == ST_INSTALLED && atFTP != AT_REMOVE))
    {
        InetStartService(_T("MSFTPSVC"));
    }
#endif // _CHICAGO_

    if (g_pTheApp->m_eOS == OS_W95 || g_pTheApp->m_eNTOSType == OT_NTW)
    {
        ACTION_TYPE atPWMGR = GetSubcompAction(STRING_iis_pwmgr, FALSE);
        if (atPWMGR == AT_INSTALL_FRESH ||
            atPWMGR == AT_INSTALL_UPGRADE ||
            atPWMGR == AT_INSTALL_REINSTALL)
        {
            CString csProgram;
            csProgram = g_pTheApp->m_csSysDir + _T("\\pwstray.exe");
            if (IsFileExist(csProgram))
            {
                STARTUPINFO si;
                PROCESS_INFORMATION pi;
                ZeroMemory(&si, sizeof(STARTUPINFO));
                si.cb = sizeof( STARTUPINFO );
                CreateProcess( csProgram, NULL, NULL, NULL,FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi );
            }
        }
    }
    return;
}


void GetShortDesc(LPCTSTR SubcomponentId, LPTSTR szShortDesc)
{
    INFCONTEXT Context;
    TCHAR szSection[_MAX_PATH] = _T("Strings");
    TCHAR szKey[_MAX_PATH] = _T("SDESC_");
    TCHAR szString[_MAX_PATH] = _T("");
    int nLen=0;

    _tcscat(szKey, SubcomponentId);
    *szShortDesc = _T('\0');

    if (SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, szSection, szKey, &Context))
    {
        SetupGetStringField(&Context, 1, szString, _MAX_PATH, NULL);
        nLen = _tcslen(szString);
        if (*szString == _T('"') && *_tcsninc(szString, nLen-1) == _T('"'))
            {_tcsncpy(szShortDesc, _tcsinc(szString), nLen-2);}
        else
            {_tcscpy(szShortDesc, szString);}
    }

    return;
}

void ParseCmdLine(void)
{
    TCHAR szCmdLine[_MAX_PATH];

    _tcscpy(szCmdLine, GetCommandLine());
    _tcslwr(szCmdLine);
    if (_tcsstr(szCmdLine, _T("sysoc.inf"))) 
        {g_pTheApp->m_fInvokedByNT = TRUE;}
    return;
}


// -----------------------------
// handles the OC_INIT_COMPONENT call from ocmanager
//
// The OC Manager passes us some information that we want to save,
// such as an open handle to our per-component INF. As long as we have
// a per-component INF, append-open any layout file that is
// associated with it, in preparation for later inf-based file
// queuing operations.
//
// We save away certain other stuff that gets passed to us now,
// since OC Manager doesn't guarantee that the SETUP_INIT_COMPONENT
// will persist beyond processing of this one interface routine.
//
//
// Param1 = unused
// Param2 = points to SETUP_INIT_COMPONENT structure
// Return code = is Win32 error indicating outcome.
//
// -----------------------------
DWORD_PTR OC_INIT_COMPONENT_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
	iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] Start.\n"), ComponentId, SubcomponentId));
    DWORD_PTR dwOcEntryReturn = 0;
    INFCONTEXT Context;
    PSETUP_INIT_COMPONENT InitComponent = (PSETUP_INIT_COMPONENT)Param2;

    TCHAR szCmdLine1[_MAX_PATH];

    // set flag if running as admin
    BOOL g_fAdministrator = RunningAsAdministrator();

    // Parse The Command line and set global Variables.
    ParseCmdLine();
   
    // first of all display iis.dll to avoid any confusion!
    DisplayVerOnCurrentModule();

    g_pTheApp->m_hInfHandle = InitComponent->ComponentInfHandle;
    if (InitComponent->ComponentInfHandle == INVALID_HANDLE_VALUE)
    {
        MessageBox(NULL, _T("Invalid inf handle."), _T("IIS Setup"), MB_OK | MB_SETFOREGROUND);
        iisDebugOut((LOG_TYPE_ERROR, _T("InitComponent->ComponentInfHandle FAILED")));
        dwOcEntryReturn = ERROR_CANCELLED;
        goto OC_INIT_COMPONENT_Func_Exit;
    }
    g_pTheApp->m_fNTOperationFlags = InitComponent->SetupData.OperationFlags;
    g_pTheApp->m_fNtWorkstation = InitComponent->SetupData.ProductType == PRODUCT_WORKSTATION;
    if (InitComponent->SetupData.OperationFlags & SETUPOP_STANDALONE)
    {
       g_pTheApp->m_fNTGuiMode = FALSE;
    }
    else
    {
       g_pTheApp->m_fNTGuiMode = TRUE;
    }
    g_pTheApp->m_csPathSource = InitComponent->SetupData.SourcePath;
    gHelperRoutines = InitComponent->HelperRoutines;
    g_pTheApp->m_fInvokedByNT = g_pTheApp->m_fNTGuiMode;

    // get the handle to the unattended file (the answer file)
    // if this is a migration from win95, then there will be
    // a section in here called [InternetServer] which will
    // point to the win95 migration.dat file.
    g_pTheApp->m_hUnattendFile = gHelperRoutines.GetInfHandle(INFINDEX_UNATTENDED, gHelperRoutines.OcManagerContext);
    if (_tcsicmp(InitComponent->SetupData.UnattendFile,_T("")) != 0 && InitComponent->SetupData.UnattendFile != NULL)
    {
        g_pTheApp->m_csUnattendFile = InitComponent->SetupData.UnattendFile;
    }
    g_pTheApp->m_fUnattended = (((DWORD)InitComponent->SetupData.OperationFlags) & SETUPOP_BATCH);
    if (g_pTheApp->m_fUnattended)
        {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Set UnAttendFlag:ON (File='%s')\n"), g_pTheApp->m_csUnattendFile));
        if (g_pTheApp->m_hUnattendFile == INVALID_HANDLE_VALUE || g_pTheApp->m_hUnattendFile == NULL)
            {iisDebugOut((LOG_TYPE_WARN, _T("WARNING: There should have been an unattended file but there is none.\n")));}
        }
    else
        {iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Set UnAttendFlag:OFF (File='%s')\n"), g_pTheApp->m_csUnattendFile));}
    
    // if ran from sysoc.inf then set m_fInvokedByNT (for control panel add/remove)
    _tcscpy(szCmdLine1, GetCommandLine());

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("CmdLine=%s"), szCmdLine1));
    _tcslwr(szCmdLine1);
    if (_tcsstr(szCmdLine1, _T("sysoc.inf"))) 
        {g_pTheApp->m_fInvokedByNT = TRUE;}

    // make sure that this is always set -- so that
    // you never get the iis welcome, min\typ\custom, dir selection, End pages.
    g_pTheApp->m_fInvokedByNT = TRUE;
    if (g_pTheApp->m_fInvokedByNT) {g_pTheApp->m_bAllowMessageBoxPopups = FALSE;}
    //if (g_SpecialFlagForDebug) {g_pTheApp->m_bAllowMessageBoxPopups = TRUE;}

    // get the debug level from the iis.inf
    GetDebugLevelFromInf(g_pTheApp->m_hInfHandle);

    if (!g_pTheApp->m_fNTGuiMode)
    {
        if (g_GlobalFastLoad)
        {
            // change it so that there is no logging during the load process.
            // so that the iis.dll loads up faster.
            // g_pTheApp->m_fNTGuiMode
            g_GlobalDebugLevelFlag = LOG_TYPE_WARN;
        }
    }

    // Read .inf file
    // and set some globals from the informatin in there.
    ReadGlobalsFromInf(g_pTheApp->m_hInfHandle);
    if (g_GlobalGuiOverRide)
    {
        g_pTheApp->m_fNTGuiMode = TRUE;
        SetIISSetupMode(SETUPMODE_UPGRADEONLY);
    }
    
    // ----------------------------------
    //     handle win95 migration
    //
    // win95 migration is handled this way.
    // 1. on the win95 side a file is generated.  it is a actually a
    //    setupapi type .inf fie.
    // 2. win95 migration dll creates the file and sticks the path to where
    //    it is in the answerfile.txt file.  should look like this
    //    [InternetServer]
    //    Win95MigrateDll=d:\winnt\system32\setup\????\something.dat
    //
    // 3. so we should, open the answer file,
    //    find the [InternetServer] section
    //    have setupapi install it 
    //    
    // 4. that will put appropriate registry values into the registry.
    //
    // ----------------------------------
    HandleWin95MigrateDll();

    if (!g_fAdministrator) 
    {
        g_pTheApp->MsgBox(NULL, IDS_NOT_ADMINISTRATOR, MB_OK, TRUE);
        dwOcEntryReturn = ERROR_CANCELLED;
        goto OC_INIT_COMPONENT_Func_Exit;
    }
    
    // Call this stuff after setting m_fNTGuiMode and m_fNtWorkstation and m_fInvokedByNT
    // since it maybe used in InitApplication().
    if ( FALSE == g_pTheApp->InitApplication() ) 
    {
        g_pTheApp->DumpAppVars();
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED")));
        // setup should be terminated.
        dwOcEntryReturn = ERROR_CANCELLED;
        goto OC_INIT_COMPONENT_Func_Exit;
    }
    if ( g_pTheApp->m_eInstallMode == IM_MAINTENANCE )
        {g_pTheApp->m_fEULA = TRUE;}

    // check if the .inf we are looking at is the right inf for what the machine is running as
    //if (FALSE == CheckIfPlatformMatchesInf(g_pTheApp->m_hInfHandle))
    //{
    //    dwOcEntryReturn = ERROR_CANCELLED;
    //    goto OC_INIT_COMPONENT_Func_Exit;
    //}

    //  something like "this build requires nt build 1899 or something"
    CheckSpecificBuildinInf(g_pTheApp->m_hInfHandle);

    // Check for old gopher!
    if (FALSE == CheckForOldGopher(g_pTheApp->m_hInfHandle))
    {
        dwOcEntryReturn = ERROR_CANCELLED;
        goto OC_INIT_COMPONENT_Func_Exit;
    }

    // See if user configured anything
    // must happen after g_pTheApp->InitApplication
    // but before SetDIRIDforThisInf!
    ReadUserConfigurable(g_pTheApp->m_hInfHandle);

    //
    // Set up the DIRIDs for our .inf file
    // these are very very important and can get changed throughout the program
    // 
    SetDIRIDforThisInf(g_pTheApp->m_hInfHandle);

    //
    // Set global ocm private data for other components to find out
    // (during installation) where our inetpub or inetsrv dir is located..
    SetOCGlobalPrivateData();

    dwOcEntryReturn = NO_ERROR;

    // Check if There are pending reboot operations...
    if (LogPendingReBootOperations() != ERROR_SUCCESS)
        {dwOcEntryReturn = ERROR_CANCELLED;}

    // if we already did some win95 stuff then don't need to do this
    // do this only in gui mode
    if (g_pTheApp->m_fNTGuiMode)
    {
        if (!g_pTheApp->m_bWin95Migration){CheckIfWeNeedToMoveMetabaseBin();}
    }

    // Get the last section to be called.
    _tcscpy(g_szLastSectionToGetCalled, _T(""));
    GetLastSectionToBeCalled();

    ProcessSection(g_pTheApp->m_hInfHandle, _T("OC_INIT_COMPONENT"));

    Check_For_DebugServiceFlag();

    TestAfterInitApp();

OC_INIT_COMPONENT_Func_Exit:
    g_pTheApp->DumpAppVars();
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=%d \n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    return dwOcEntryReturn;
}

DWORD_PTR OC_QUERY_CHANGE_SEL_STATE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    // Make these static, so we can query the value on the next call
    static BOOL bFtp_IgnoreNextSet = FALSE;
    static BOOL bVdirScripts_IgnoreNextSet = FALSE;

    DWORD dwOcEntryReturn = 0;
    DWORD dwCurrentState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_CURRENT);

    dwOcEntryReturn = 1;
    if (SubcomponentId)
    {
        BOOL OriginalState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL);

        //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   Param1=%d, Param2=%d, Original=%d, Current=%d\n"), ComponentId, SubcomponentId, Param1, Param2,OriginalState,CurrentState));
        if (OriginalState == 1)
        {
            if ((BOOL)Param1)
            {
                dwOcEntryReturn = 1;
                if (_tcsicmp(SubcomponentId, STRING_iis_inetmgr) == 0 || _tcsicmp(SubcomponentId, STRING_iis_www) == 0  ||  _tcsicmp(SubcomponentId, STRING_iis_pwmgr) == 0 )
                {
                    // check if tcpip is installed
                    g_pTheApp->IsTCPIPInstalled();
                    if (g_pTheApp->m_fTCPIP == FALSE)
                    {
                        g_pTheApp->MsgBox(NULL, IDS_TCPIP_NEEDED_ON_OPTION, MB_OK, TRUE);
                        dwOcEntryReturn = 0;
                    }
                }
            }
            else
            {
                // In upgrade case, we don't allow user to uncheck previously installed components
                if (g_pTheApp->m_eInstallMode == IM_UPGRADE)
                    {dwOcEntryReturn = 0;}
            }
        }
        else
        {
            if (_tcsicmp(SubcomponentId, STRING_iis_inetmgr) == 0 || _tcsicmp(SubcomponentId, STRING_iis_www) == 0  || _tcsicmp(SubcomponentId, STRING_iis_pwmgr) == 0 )
            {
                if ((BOOL)Param1)
                {
                    //
                    // if we are turning ON then we NEED TCPIP
                    //
                    // check if tcpip is installed
                    g_pTheApp->IsTCPIPInstalled();
                    if (g_pTheApp->m_fTCPIP == FALSE)
                    {
                        g_pTheApp->MsgBox(NULL, IDS_TCPIP_NEEDED_ON_OPTION, MB_OK, TRUE);
                        dwOcEntryReturn = 0;
                    }
                }
            }
        }
    }

    // If we are turning the component on
    if ( Param1 != 0 )
    {
      if ( _tcscmp(SubcomponentId, _T("iis") ) == 0 )
      {
        // This is going to cause a chain reaction of selections, so make sure
        // that when the ftp one comes around, we ignore it
        bFtp_IgnoreNextSet = TRUE;
      } 
      else if ( _tcscmp(SubcomponentId, _T("iis_www_parent") ) == 0 )
        {
          // This is going to cause a chain reaction of selections, so make sure
          // that when the vdirs_scripts one comes around, we ignore it
          bVdirScripts_IgnoreNextSet = TRUE;
        }
        else if ( ( _tcscmp(SubcomponentId, _T("iis_ftp") ) == 0 ) && (bFtp_IgnoreNextSet) )
          {
            bFtp_IgnoreNextSet = FALSE;
            return 0;
          }
        else if ( ( _tcscmp(SubcomponentId, _T("iis_www_vdir_scripts") ) == 0 ) && (bVdirScripts_IgnoreNextSet) )
            {
              bVdirScripts_IgnoreNextSet = FALSE;
              return 0;
            }
    }

    //
    // if we are running on Whistler personal, then return denied.
    // so that no other component can turn us on! or think that they're going to turn us on.
    //
    if (IsWhistlerPersonal())
    {
       dwOcEntryReturn = 0;
    }

    if (dwOcEntryReturn == 0)
    {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=%d (denied) \n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    }
    else
    {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=%d (approved)\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    }

    return dwOcEntryReturn;
}



//
// gets called right before we show your page!
//
DWORD_PTR OC_QUERY_SKIP_PAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] Start.\n"), ComponentId, SubcomponentId));

    DWORD_PTR dwOcEntryReturn = 0;
    TCHAR szTempString[50];
    _tcscpy(szTempString, _T(""));

    switch (g_pTheApp->m_dwSetupMode)
    {
        case SETUPMODE_UPGRADEONLY:
            _tcscpy(szTempString, _T("SETUPMODE_UPGRADEONLY"));
            dwOcEntryReturn = 1;
            break;
        case SETUPMODE_REINSTALL:
            _tcscpy(szTempString, _T("SETUPMODE_REINSTALL"));
            dwOcEntryReturn = 1;
            break;
        case SETUPMODE_REMOVEALL:
            _tcscpy(szTempString, _T("SETUPMODE_REMOVEALL"));
            dwOcEntryReturn = 1;
            break;
        case SETUPMODE_MINIMAL:
            _tcscpy(szTempString, _T("SETUPMODE_MINIMAL"));
            dwOcEntryReturn = 1;
            break;
        case SETUPMODE_TYPICAL:
            _tcscpy(szTempString, _T("SETUPMODE_TYPICAL"));
            dwOcEntryReturn = 1;
            break;
        case SETUPMODE_ADDEXTRACOMPS:
            _tcscpy(szTempString, _T("SETUPMODE_ADDEXTRACOMPS"));
            dwOcEntryReturn = 0;
            break;
        case SETUPMODE_ADDREMOVE:
            _tcscpy(szTempString, _T("SETUPMODE_ADDREMOVE"));
            dwOcEntryReturn = 0;
            break;
        case SETUPMODE_CUSTOM:
            _tcscpy(szTempString, _T("SETUPMODE_CUSTOM"));
            dwOcEntryReturn = 0;
            break;
    }

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  g_pTheApp->m_dwSetupMode=%x (%s), dwOcEntryReturn=%d\n"), ComponentId, SubcomponentId, g_pTheApp->m_dwSetupMode, szTempString, dwOcEntryReturn));
    return dwOcEntryReturn;
}


// ----------------------------------------
// Param1 = 0 if for removing component or non-0 if for adding component
// Param2 = HDSKSPC to operate on
//
// Return value is Win32 error code indicating outcome.
//
// In our case the private section for this component/subcomponent pair
// is a simple standard inf install section, so we can use the high-level
// disk space list api to do what we want.

// Logic is not correct here !!!
// ----------------------------------------
DWORD_PTR OC_CALC_DISK_SPACE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;
    BOOL bTempFlag = FALSE;
    TCHAR SectionName[128];

    dwOcEntryReturn = NO_ERROR;
    if (SubcomponentId)
    {
        bTempFlag = TRUE;
        if ( Param1 )
        {
            // add component
            _stprintf(SectionName,TEXT("%s_%s"),SubcomponentId, _T("install"));
            bTempFlag = SetupAddInstallSectionToDiskSpaceList(Param2,g_pTheApp->m_hInfHandle,NULL,SectionName,0,0);

        }
        else
        {
            // removing component

            // Comment this out per PatSt, 3/5/97, and change it to the install list
            //_stprintf(SectionName,TEXT("%s_%s"),SubcomponentId, _T("uninstall"));
            _stprintf(SectionName,TEXT("%s_%s"),SubcomponentId, _T("install"));
            bTempFlag = SetupRemoveInstallSectionFromDiskSpaceList(Param2,g_pTheApp->m_hInfHandle,NULL,SectionName,0,0);

            //
            // check if it's something we need to warn user about
            //

            // in add remove case, if the user is removing w3svc or msftpsvc
            // then check if clustering is installed.  if clustering is installed
            // then check if there are any cluster resources which have w3svc or msftpsvc as a
            // resouce, if there are any, then warn the user that they must remove these cluster resources!
#ifndef _CHICAGO_
            if (g_pTheApp->m_eInstallMode == IM_MAINTENANCE)
            {
                BOOL CurrentState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_CURRENT);
                BOOL OriginalState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL);
                if (OriginalState == 1 && CurrentState == 0)
                {
                    if (TRUE == DoesClusterServiceExist())
                    {
                        TCHAR * szClusterName = NULL;
                        WCHAR szServiceLookingFor[20];
                        CString MyReturnString;
                        CLUSTER_SVC_INFO_FILL_STRUCT MyStructOfInfo;

                        // check if they are trying to 
                        // remove the W3SVC service!
                        if (_tcsicmp(SubcomponentId, STRING_iis_www) == 0 || _tcsicmp(SubcomponentId, STRING_iis_ftp) == 0)
                        {
                            if (_tcsicmp(SubcomponentId, STRING_iis_ftp) == 0)
                            {
                                wcscpy(szServiceLookingFor,L"MSFTPSVC");
                                // check for msftpsvc resource
                                MyStructOfInfo.szTheClusterName = szClusterName;
                                MyStructOfInfo.pszTheServiceType = szServiceLookingFor;
                                MyStructOfInfo.csTheReturnServiceResName = &MyReturnString;
                                MyStructOfInfo.dwReturnStatus = 0;
                                if (TRUE == DoClusterServiceCheck(&MyStructOfInfo))
                                {
                                    g_pTheApp->MsgBox2(NULL, IDS_REMOVE_CLUS_MSFTPSVC_FIRST, *MyStructOfInfo.csTheReturnServiceResName, MB_OK | MB_SETFOREGROUND);
                                }
                            }
                            else
                            {
                                wcscpy(szServiceLookingFor,L"W3SVC");
                                // check for w3svc resource
                                MyStructOfInfo.szTheClusterName = szClusterName;
                                MyStructOfInfo.pszTheServiceType = szServiceLookingFor;
                                MyStructOfInfo.csTheReturnServiceResName = &MyReturnString;
                                MyStructOfInfo.dwReturnStatus = 0;
                                if (TRUE == DoClusterServiceCheck(&MyStructOfInfo))
                                {
                                    g_pTheApp->MsgBox2(NULL, IDS_REMOVE_CLUS_W3SVC_FIRST, *MyStructOfInfo.csTheReturnServiceResName, MB_OK | MB_SETFOREGROUND);
                                }
                                else
                                {
                                    // check for smtp resources
                                    wcscpy(szServiceLookingFor,L"SMTPSVC");
                                    if (TRUE == DoClusterServiceCheck(&MyStructOfInfo))
                                    {
                                        g_pTheApp->MsgBox2(NULL, IDS_REMOVE_CLUS_W3SVC_FIRST, *MyStructOfInfo.csTheReturnServiceResName, MB_OK | MB_SETFOREGROUND);
                                    }
                                    else
                                    {
                                        // check for nntp resources
                                        wcscpy(szServiceLookingFor,L"NNTPSVC");
                                        if (TRUE == DoClusterServiceCheck(&MyStructOfInfo))
                                        {
                                            g_pTheApp->MsgBox2(NULL, IDS_REMOVE_CLUS_W3SVC_FIRST, *MyStructOfInfo.csTheReturnServiceResName, MB_OK | MB_SETFOREGROUND);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
#endif
        }

        dwOcEntryReturn = bTempFlag ? NO_ERROR : GetLastError();
    }

    // Display the new state of this component
    if (SubcomponentId)
    {
        if (_tcsicmp(SubcomponentId, STRING_iis_ftp) == 0 || _tcsicmp(SubcomponentId, STRING_iis_www) == 0)
        {
            GetIISCoreAction(TRUE);
        }
        else
        {
            GetSubcompAction(SubcomponentId, TRUE);
        }
    }

    if (dwOcEntryReturn == NO_ERROR)
    {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=NO_ERROR\n"), ComponentId, SubcomponentId));
    }
    else
    {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return='0x%x'\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    }

    return dwOcEntryReturn;
}

DWORD_PTR OC_NEED_MEDIA_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;
    iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("[%1!s!,%2!s!] Start. Param1=0x%3!x!,Param2=0x%4!x!\n"), ComponentId, SubcomponentId, Param1, Param2));
    dwOcEntryReturn = NO_ERROR;
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    return dwOcEntryReturn;
}


// -------------------------------
// Param1 = unused
// Param2 = HSPFILEQ to operate on
//
// Return value is Win32 error code indicating outcome.
//
// OC Manager calls this routine when it is ready for files to be copied
// to effect the changes the user requested. The component DLL must figure out
// whether it is being installed or uninstalled and take appropriate action.
// For this sample, we look in the private data section for this component/
// subcomponent pair, and get the name of an uninstall section for the
// uninstall case.
//
// Note that OC Manager calls us once for the *entire* component
// and then once per subcomponent. We ignore the first call.
// -------------------------------
DWORD_PTR OC_QUEUE_FILE_OPS_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] Start.\n"), ComponentId, SubcomponentId));
    DWORD_PTR dwOcEntryReturn = NO_ERROR;
    g_GlobalFileQueueHandle = Param2;
    g_GlobalFileQueueHandle_ReturnError = NO_ERROR;

    g_GlobalTotalTickGaugeCount = 0;

    if (!SubcomponentId)
    {
        if (g_pTheApp->m_fNTGuiMode)
        {
            // no need to do anyof this anymore since nt will be installing %windir%\Help\iis.chm
            /*
            BOOL iHelpFileExists = FALSE;
            // on install NT copies file iisnts.chm or iisntw.chm to the %windir%\help dir.
            // during guimode install we need to make sure it get's renamed to %windir%\help\iis.chm
            CString csIISHelpCopiedAlways;
            csIISHelpCopiedAlways = g_pTheApp->m_csWinDir + _T("\\Help\\iisnts.chm");
            if (IsFileExist(csIISHelpCopiedAlways)) 
                {iHelpFileExists = TRUE;}
            if (!iHelpFileExists)
            {
                csIISHelpCopiedAlways = g_pTheApp->m_csWinDir + _T("\\Help\\iisntw.chm");
                if (IsFileExist(csIISHelpCopiedAlways))
                    {iHelpFileExists = TRUE;}
            }

            if (iHelpFileExists)
            {
                CString csTempDelFile;
                // Delete any existing iis.chm that's already there
                csTempDelFile = g_pTheApp->m_csWinDir + _T("\\Help\\iis.chm");
                DeleteFile(csTempDelFile);
                // Rename iisnts.chm to iis.chm
                MoveFileEx( csIISHelpCopiedAlways, csTempDelFile, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH|MOVEFILE_REPLACE_EXISTING);
                //rename((csIISHelpCopiedAlways, csTempDelFile);
            }
            */
        }
    }

    // -----------------------
    // handle all removes here = the file operations only
    // -----------------------
    //
    // Check to see if the user has chosen to "remove-all"
    //
    // handle all removes here.
    // we need to handle it in or special order
    // because we want to make sure that removeal happens in the right order.
    // right order means =(considering the 'needs' relationship - since ocmanage does not handle it).
    //
    if (!SubcomponentId)
    {
        DisplayActionsForAllOurComponents(g_pTheApp->m_hInfHandle);
        if (g_pTheApp->m_eInstallMode != IM_UPGRADE)
        {
            // make sure they can't mistakenly
            // do these remove's during guimode!
            if (!g_pTheApp->m_fNTGuiMode)
            {
                // if the user has chosen to remove any iis component...
                // then we must make sure that they get removed in the correct order since
                // ocmanage will not remove based on the .inf 'Needs' relationships.
                //iis
                //iis_common  (Needs = iis)
                //iis_core    (Needs = iis_core)
                //iis_inetmgr (Needs = iis_common)
                //iis_www     (Needs = iis_inetmgr, com
                //iis_pwmgr   (Needs = iis_www)
                //iis_doc     (Needs = iis_www)
                //iis_htmla   (Needs = iis_www)
                //iis_www_vdir_scripts     (Needs = iis_www)
                //iis_ftp     (Needs = iis_inetmgr)

                _tcscpy(g_szCurrentSubComponent, STRING_iis_ftp);
                RemoveComponent(STRING_iis_ftp,1);
                _tcscpy(g_szCurrentSubComponent, STRING_iis_www_vdir_scripts);
                RemoveComponent(STRING_iis_www_vdir_scripts,1);
                _tcscpy(g_szCurrentSubComponent, STRING_iis_www_vdir_printers);
                RemoveComponent(STRING_iis_www_vdir_printers,1);
                _tcscpy(g_szCurrentSubComponent, STRING_iis_htmla);
                RemoveComponent(STRING_iis_htmla,1);
                _tcscpy(g_szCurrentSubComponent, STRING_iis_doc);
                RemoveComponent(STRING_iis_doc,1);
                _tcscpy(g_szCurrentSubComponent, STRING_iis_pwmgr);
                RemoveComponent(STRING_iis_pwmgr,1);
                _tcscpy(g_szCurrentSubComponent, STRING_iis_www);
                RemoveComponent(STRING_iis_www,1);
                _tcscpy(g_szCurrentSubComponent, STRING_iis_inetmgr);
                RemoveComponent(STRING_iis_inetmgr,1);
                _tcscpy(g_szCurrentSubComponent, STRING_iis_common);
                RemoveComponent(STRING_iis_core,1);
                RemoveComponent(STRING_iis_common,1);
                _tcscpy(g_szCurrentSubComponent, _T(""));
                RemoveComponent(_T("iis"),1);
                if (SubcomponentId)
                    {_tcscpy(g_szCurrentSubComponent, SubcomponentId);}

                // check to make sure that we haven't overlooked something.
                // if iis_core is to be not there, then make sure it is not there.
            }
        }
    }

    // ------------------------
    // handle fresh and upgrade
    // ------------------------
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
    if (!SubcomponentId)
    {
        ProcessSection(g_pTheApp->m_hInfHandle, _T("OC_QUEUE_FILE_OPS"));
        ACTION_TYPE atCORE = GetIISCoreAction(FALSE);
        if (atCORE == AT_INSTALL_FRESH || atCORE == AT_INSTALL_UPGRADE || atCORE == AT_INSTALL_REINSTALL)
        {
            ProcessSection(g_pTheApp->m_hInfHandle, _T("OC_QUEUE_FILE_OPS_install.iis_core"));
            dwOcEntryReturn = g_GlobalFileQueueHandle_ReturnError ? NO_ERROR : GetLastError();
        }
    }
    else
    {
        ACTION_TYPE atComp = GetSubcompAction(SubcomponentId, FALSE);
        if (atComp == AT_INSTALL_FRESH ||atComp == AT_INSTALL_UPGRADE || atComp == AT_INSTALL_REINSTALL)
        {
            TCHAR szTheSectionToDo[100];
            _stprintf(szTheSectionToDo,_T("OC_QUEUE_FILE_OPS_install.%s"),SubcomponentId);
            if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, (CString) szTheSectionToDo))
            {
              ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);
              dwOcEntryReturn = g_GlobalFileQueueHandle_ReturnError ? NO_ERROR : GetLastError();
            }
            else
            {
              dwOcEntryReturn = NO_ERROR;
            }
        }
    }

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    return dwOcEntryReturn;
}


DWORD_PTR OC_ABOUT_TO_COMMIT_QUEUE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] Start. 0x%x,0x%x\n"), ComponentId, SubcomponentId, Param1, Param2));
    DWORD_PTR dwOcEntryReturn = 0;
    BOOL bTempFlag = FALSE;

    g_GlobalTotalTickGaugeCount = 0;

    // OCM will send this notification to each components by using the order
    // of bottom==>top of the dependency tree.
    // You should handle un-installation in this notification.
    dwOcEntryReturn = NO_ERROR;
    SetCurrentDirectory(g_pTheApp->m_csPathInetsrv);
    if (!SubcomponentId)
    {
        DisplayActionsForAllOurComponents(g_pTheApp->m_hInfHandle);

        // set the machinename 
        g_pTheApp->ReGetMachineAndAccountNames();
		CString csMachineName = g_pTheApp->m_csMachineName.Right(g_pTheApp->m_csMachineName.GetLength() - 2);
        SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle, 32800, csMachineName);

        ProcessSection(g_pTheApp->m_hInfHandle, _T("OC_ABOUT_TO_COMMIT_QUEUE"));
    }
    else
    {
        TCHAR szTheSectionToDo[100];
        _stprintf(szTheSectionToDo,_T("OC_ABOUT_TO_COMMIT_QUEUE.%s"),SubcomponentId);
        ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);

        ACTION_TYPE atCORE = GetIISCoreAction(FALSE);
        ACTION_TYPE atComp = GetSubcompAction(SubcomponentId, FALSE);
        ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);
    }

    // ------------------------------------
    // Stop any services that we need to...
    // ------------------------------------
    if (!SubcomponentId)
    {
        if (g_pTheApp->m_fNTGuiMode)
        {
            // In any type of case, either fresh,upgrade, reinstall, whatevers,
            // the services must be stopped at this point!!!!
            StopAllServicesRegardless(FALSE);
            // handle the metabase file appropriately,
            // in order to work correctly with NT5 GUI mode setup re-startable
            HandleMetabaseBeforeSetupStarts();
            //AfterRemoveAll_SaveMetabase();
        }
        else
        {
            // add\remove, so only stop services that will be affected
            StopAllServicesThatAreRelevant(FALSE);
        }
    }

    // -----------------------
    // handle all removes here
    // -----------------------
    //
    // Check to see if the user has chosen to "remove-all"
    //
    // handle all removes here.
    // we need to handle it in or special order
    // because we want to make sure that removeal happens in the right order.
    // right order means =(considering the 'needs' relationship - since ocmanage does not handle it).
    //
    if (!SubcomponentId)
    {
        DisplayActionsForAllOurComponents(g_pTheApp->m_hInfHandle);
        if (g_pTheApp->m_eInstallMode != IM_UPGRADE)
        {
            // if the user has chosen to remove any iis component...
            // then we must make sure that they get removed in the correct order since
            // ocmanage will not remove based on the .inf 'Needs' relationships.
            //iis
            //iis_common  (Needs = iis)
            //iis_core    (Needs = iis_core)
            //iis_inetmgr (Needs = iis_common)
            //iis_www     (Needs = iis_inetmgr, com
            //iis_pwmgr   (Needs = iis_www)
            //iis_doc     (Needs = iis_www)
            //iis_htmla   (Needs = iis_www)
            //iis_www_vdir_scripts     (Needs = iis_www)
            //iis_ftp     (Needs = iis_inetmgr)
            _tcscpy(g_szCurrentSubComponent, STRING_iis_ftp);
            RemoveComponent(STRING_iis_ftp,2);
            _tcscpy(g_szCurrentSubComponent, STRING_iis_www_vdir_scripts);
            RemoveComponent(STRING_iis_www_vdir_scripts,2);
            _tcscpy(g_szCurrentSubComponent, STRING_iis_www_vdir_printers);
            RemoveComponent(STRING_iis_www_vdir_printers,2);
            _tcscpy(g_szCurrentSubComponent, STRING_iis_htmla);
            RemoveComponent(STRING_iis_htmla,2);
            _tcscpy(g_szCurrentSubComponent, STRING_iis_doc);
            RemoveComponent(STRING_iis_doc,2);
            _tcscpy(g_szCurrentSubComponent, STRING_iis_pwmgr);
            RemoveComponent(STRING_iis_pwmgr,2);
            _tcscpy(g_szCurrentSubComponent, STRING_iis_www);
            RemoveComponent(STRING_iis_www,2);
            _tcscpy(g_szCurrentSubComponent, STRING_iis_inetmgr);
            RemoveComponent(STRING_iis_inetmgr,2);
            _tcscpy(g_szCurrentSubComponent, STRING_iis_core);
            RemoveComponent(STRING_iis_core,2);
            _tcscpy(g_szCurrentSubComponent, STRING_iis_common);
            RemoveComponent(STRING_iis_common,2);
            _tcscpy(g_szCurrentSubComponent, _T(""));
            RemoveComponent(_T("iis"),2);
        }
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoFreeUnusedLibraries().Start.")));
    CoFreeUnusedLibraries();
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoFreeUnusedLibraries().End.")));


    // ------------------------------------
    // Make sure that all possible services are stopped before anytype of copyfiles!
    // ------------------------------------
    if (g_pTheApp->m_fNTGuiMode)
    {
        // In any type of case, either fresh,upgrade, reinstall, whatevers,
        // the services must be stopped at this point!!!!
        StopAllServicesRegardless(TRUE);
    }
    else
    {
        // add\remove, so only stop services that will be affected
        StopAllServicesThatAreRelevant(TRUE);
    }

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End.  Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    return dwOcEntryReturn;
}



DWORD_PTR OC_COMPLETE_INSTALLATION_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] Start. 0x%x,0x%x\n"), ComponentId, SubcomponentId, Param1, Param2));
    // OCM will send this notification to each components by using the order
    // of top==>bottom of the dependency tree.
    // You should handle installation in this notification.
    DWORD_PTR dwOcEntryReturn = 0;
    BOOL bTempFlag = FALSE;
    TCHAR SectionName[128];
    TCHAR szShortDesc[_MAX_PATH];
    TCHAR szTheSectionToDo[100];

    g_GlobalTotalTickGaugeCount = 0;

  
    if (!SubcomponentId)
    {

        if (g_pTheApp->m_fNTGuiMode)
        {
            g_pTheApp->ReGetMachineAndAccountNames();
		    CString csMachineName = g_pTheApp->m_csMachineName.Right(g_pTheApp->m_csMachineName.GetLength() - 2);
            SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle, 32800, csMachineName);
        }

        _stprintf(szTheSectionToDo,_T("OC_COMPLETE_INSTALLATION_install.%s"),ComponentId);
        ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);
    }

    dwOcEntryReturn = NO_ERROR;
    SetCurrentDirectory(g_pTheApp->m_csPathInetsrv);
    if (SubcomponentId)
    {
        ACTION_TYPE atComp = GetSubcompAction(SubcomponentId, FALSE);

        // Should get called in this order
        // ===============================
        // [Optional Components]
        // iis
        // iis_common
        // iis_inetmgr
        // iis_www
        // iis_doc
        // iis_htmla
        // iis_www_vdir_scripts
        // iis_ftp

        // ===============================
        //
        // iis_common should be the first call....
        //
        // ===============================
        if (_tcsicmp(SubcomponentId, STRING_iis_common) == 0)
        {
            //
            // install the iis_common section
            //
            if (atComp == AT_INSTALL_FRESH || atComp == AT_INSTALL_UPGRADE || (atComp == AT_INSTALL_REINSTALL))
            {
                _stprintf(g_MyLogFile.m_szLogPreLineInfo2,_T("%s:"),SubcomponentId);

                if (atComp == AT_INSTALL_UPGRADE){ProgressBarTextStack_Set(IDS_IIS_ALL_UPGRADE);}
                else{ProgressBarTextStack_Set(IDS_IIS_ALL_INSTALL);}

                _stprintf(szTheSectionToDo,_T("OC_COMPLETE_INSTALLATION_install.%s"),SubcomponentId);
                ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);
                _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

                ProgressBarTextStack_Pop();
            }

            //
            //  If we just processed iis_common,
            //  but now we should install iis_core
            //
            if (atComp == AT_INSTALL_FRESH || atComp == AT_INSTALL_UPGRADE || (atComp == AT_INSTALL_REINSTALL) || atComp == AT_DO_NOTHING)
            {
                ACTION_TYPE atCORE = GetIISCoreAction(FALSE);
                if (atCORE == AT_INSTALL_FRESH || atCORE == AT_INSTALL_UPGRADE ||  (atCORE == AT_INSTALL_REINSTALL))
                {
                    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("iis_core:"));

                    if (atComp != AT_DO_NOTHING)
                    {
                        if (atCORE == AT_INSTALL_UPGRADE){ProgressBarTextStack_Set(IDS_IIS_ALL_UPGRADE);}
                        else{ProgressBarTextStack_Set(IDS_IIS_ALL_INSTALL);}
                    }

                    _stprintf(szTheSectionToDo,_T("OC_COMPLETE_INSTALLATION_install.%s"),STRING_iis_core);
                    ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);
                    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

                    if (atComp != AT_DO_NOTHING)
                    {
                        ProgressBarTextStack_Pop();
                    }
                }
            }
        }
        else
        {
            // ===============================
            //
            // Handle the Registration of all other components...
            //
            // ===============================
            if (atComp == AT_INSTALL_FRESH || atComp == AT_INSTALL_UPGRADE || (atComp == AT_INSTALL_REINSTALL))
            {
                _stprintf(g_MyLogFile.m_szLogPreLineInfo2,_T("%s:"),SubcomponentId);

                if (atComp == AT_INSTALL_UPGRADE){ProgressBarTextStack_Set(IDS_IIS_ALL_UPGRADE);}
                else{ProgressBarTextStack_Set(IDS_IIS_ALL_INSTALL);}

                // Call the sections registration stuff.
                if (_tcsicmp(SubcomponentId, STRING_iis_inetmgr) == 0) 
                {
                    // Do this at the end of setup since things that it needs may not happen yet (mmc)
                    g_Please_Call_Register_iis_inetmgr = TRUE;
                   // Register_iis_inetmgr();
                }

                _stprintf(szTheSectionToDo,_T("OC_COMPLETE_INSTALLATION_install.%s"),SubcomponentId);
                ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);

                _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

                ProgressBarTextStack_Pop();
            }
        }

        //
        // If we are removing something, then remove the directories
        //
        if (atComp == AT_REMOVE)
        {
            ProgressBarTextStack_Set(IDS_IIS_ALL_REMOVE);

            _stprintf(szTheSectionToDo,_T("OC_COMPLETE_INSTALLATION_remove.%s"),SubcomponentId);
            ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);

            ProgressBarTextStack_Pop();
        }
    }


    AdvanceProgressBarTickGauge();

    SumUpProgressBarTickGauge(SubcomponentId);

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End.  Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    
    // check if this is the last section to get called!!!
    if (SubcomponentId)
        {
        // Yes this is the last section to get called! So, let's say sooooo....
        if (_tcsicmp(SubcomponentId, g_szLastSectionToGetCalled) == 0)
            {

            // Enforce max connections
            if (CheckifServiceExist(_T("IISADMIN")) == 0 ) 
            {
                //EnforceMaxConnections();
            }

            // free some memory
            FreeTaskListMem();
            UnInit_Lib_PSAPI();

            iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("....All OC_COMPLETE_INSTALLATION for all 'IIS' sections have been completed.....\n")));

            // if there were errors then popup message box.
            MesssageBoxErrors_IIS();
            }
        }

    return dwOcEntryReturn;
}

DWORD_PTR OC_CLEANUP_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] Start. 0x%x,0x%x\n"), ComponentId, SubcomponentId, Param1, Param2));
    // OCM send out this notification after the "Finish" button on
    // the End Page has been clicked.
    //
    // remove the files we downloaded from the web in this session
    DWORD_PTR dwOcEntryReturn = 0;

    // display running services in case our services
    // need other services to be running!
    ShowStateOfTheseServices(g_pTheApp->m_hInfHandle);

    // Install inetmgr after gui mode setup is done because
    // it may require other things that were setup in guimode.
    if (TRUE == g_Please_Call_Register_iis_inetmgr) {Register_iis_inetmgr();}

    ProcessSection(g_pTheApp->m_hInfHandle, _T("OC_CLEANUP"));

    // restart services that we stopped
    ServicesRestartList_RestartServices();
#ifndef _CHICAGO_
    // restart cluster resources that we had stopped
    if (!g_pTheApp->m_fNTGuiMode)
    {
        BringALLIISClusterResourcesOnline();
    }
#endif

    //--------------------------------------------------------------------
    // For Migrations we need to scan the entire metabase and look for the old
    // system directory (e.g. "C:\\Windows\\System\\") and replace
    // with the new system directory (e.g. "C:\\WINNT.1\\System32\\")
    //
    // Does the iisadmin service exist?
    // Does the metabase exist???
    if (g_pTheApp->m_eInstallMode == IM_UPGRADE)
    {
        if (g_pTheApp->m_fMoveInetsrv)
        {
            // Check if the iisadmin service exists...
            if (CheckifServiceExist(_T("IISADMIN")) == 0 ) 
            {
                CMDKey cmdKey;
                cmdKey.OpenNode(_T("LM"));
                if ( (METADATA_HANDLE)cmdKey ) 
                {
                    HRESULT hr;
                    cmdKey.Close();
                    CString cOldWinSysPath;
                    CString cNewWinSysPath;

                    // Change all "c:\windows\system\inetsrv" to "c:\windows\system32\inetsrv"
                    cOldWinSysPath = g_pTheApp->m_csPathOldInetsrv;
                    cOldWinSysPath += _T("\\"); // add a trailing backslash
                    cNewWinSysPath = g_pTheApp->m_csPathInetsrv;
                    cNewWinSysPath += _T("\\"); // add a trailing backslash

                    iisDebugOut((LOG_TYPE_TRACE, _T("CPhysicalPathFixer: please change %s to %s.\n"),cOldWinSysPath, cNewWinSysPath));
                    CPhysicalPathFixer cmdKeySpecial(cOldWinSysPath, cNewWinSysPath);
                    hr = cmdKeySpecial.Update(_T("LM"), TRUE);
                    if (FAILED(hr)) {iisDebugOut((LOG_TYPE_ERROR, _T("CPhysicalPathFixer failed return HR:%#lx\n"), hr));}

                    // Change all "%WinDir%\System" to "%windir%\System32"
                    cOldWinSysPath = _T("%WinDir%\\System");
                    cNewWinSysPath = _T("%WinDir%\\System32");
                    CPhysicalPathFixer cmdKeySpecial2(cOldWinSysPath, cNewWinSysPath);
                    hr = cmdKeySpecial2.Update(_T("LM"), TRUE);
                    if (FAILED(hr)) {iisDebugOut((LOG_TYPE_ERROR, _T("CPhysicalPathFixer failed return HR:%#lx\n"), hr));}
                }
            }
        }
    }

    // if iis is installed, then check if Tcp/ip is installed.
    // if it is not installed... then output some error message to the log saying 
    // a big warning that they must install tcp/ip inorder for iis to work.
    //IDS_TCPIP_ERROR
    if (CheckifServiceExist(_T("TCPIP")) == ERROR_SERVICE_DOES_NOT_EXIST)
    {
        int IISInstalled = FALSE;
        if (CheckifServiceExist(_T("W3SVC")) == 0 )
            {IISInstalled=TRUE;}
        if (CheckifServiceExist(_T("MSFTPSVC")) == 0 )
            {IISInstalled=TRUE;}
        if (IISInstalled)
        {
            _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T(""));
            _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("FAIL:"));

            CString csTemp;
            MyLoadString(IDS_TCPIP_ERROR, csTemp);
            iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("================================\n")));
            iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("%s\n"), csTemp));
            iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("================================\n")));
            _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("OC_CLEANUP:"));
            _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

            //LogSevInformation           0x00000000
            //LogSevWarning               0x00000001
            //LogSevError                 0x00000002
            //LogSevFatalError            0x00000003
            //LogSevMaximum               0x00000004
            // Write it to the setupapi log file!
            SetupLogError(csTemp, LogSevWarning);
        }
    }
    else
    {
        // The tcpip service exists, but is it running???
    }

    // Write the uninstall info for this session out to the registry
    g_pTheApp->UnInstallList_RegWrite();

    CRegKey regINetStp( HKEY_LOCAL_MACHINE, REG_INETSTP);
    if ((HKEY) regINetStp){regINetStp.DeleteValue(_T("MetabaseUnSecuredRead"));}
    
    dwOcEntryReturn = 0;
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End.  Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    return dwOcEntryReturn;
}

//
// Param1 = char width flags
// Param2 = unused
//
// Return value is a flag indicating to OC Manager
// which char width we want to run in. Run in "native"
// char width.
//
DWORD_PTR OC_PREINITIALIZE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;
#ifdef UNICODE
    dwOcEntryReturn = OCFLAG_UNICODE;
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s]   End.  Return=%d (OCFLAG_UNICODE)\n"), ComponentId, dwOcEntryReturn));
#else
    dwOcEntryReturn = OCFLAG_ANSI;
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s]   End.  Return=%d (OCFLAG_ANSI)\n"), ComponentId, dwOcEntryReturn));
#endif
    return dwOcEntryReturn;
}

//
// Param1 = low 16 bits specify Win32 LANGID
// Param2 = unused
//
// Return code is a boolean indicating whether we think we
// support the requested language. We remember the language id
// and say we support the language. A more exact check might involve
// looking through our resources via EnumResourcesLnguages() for
// example, or checking our inf to see whether there is a matching
// or closely matching [strings] section. We don't bother with
// any of that here.
//
// Locate the component and remember the language id for later use.
//
DWORD_PTR OC_SET_LANGUAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;
    dwOcEntryReturn = TRUE;

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End. Win32LANGID=0x%x,  Return=%d\n"), ComponentId, SubcomponentId, Param1, dwOcEntryReturn));

    return dwOcEntryReturn;
}

#ifdef _WIN64
DWORD_PTR OC_QUERY_IMAGE_EX_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    BOOL bReturn = FALSE;
    HBITMAP hBitMap = NULL;
    HBITMAP * phBitMapInput = NULL;
    OC_QUERY_IMAGE_INFO * MyQueryInfo = NULL;
    MyQueryInfo = (OC_QUERY_IMAGE_INFO *) Param1;

    phBitMapInput = (HBITMAP *) Param2;

    if(MyQueryInfo->ComponentInfo == SubCompInfoSmallIcon)
    {
        if (_tcsicmp(SubcomponentId, STRING_iis_ftp) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle,MAKEINTRESOURCE(IDB_FTP));}
        if (_tcsicmp(SubcomponentId, STRING_iis_www) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW));}
        if (_tcsicmp(SubcomponentId, STRING_iis_www_parent) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW));}
        if (_tcsicmp(SubcomponentId, STRING_iis_www_vdir_scripts) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW_VDIR));}
        if (_tcsicmp(SubcomponentId, STRING_iis_www_vdir_printers) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW_VDIR));}
        if (_tcsicmp(SubcomponentId, STRING_iis_htmla) == 0 || _tcsicmp(SubcomponentId, STRING_iis_doc) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_HTMLA));}
        if (_tcsicmp(SubcomponentId, STRING_iis_inetmgr) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_INETMGR));}
        if (_tcsicmp(SubcomponentId, STRING_iis_pwmgr) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_PWS));}
        if (_tcsicmp(SubcomponentId, _T("iis")) == 0) {hBitMap = LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_TOPLEVEL_IIS));}
        if (hBitMap)
        {
            *phBitMapInput = (HBITMAP) hBitMap;
            bReturn = TRUE;
        }
    }

    if (phBitMapInput != NULL)
    {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]  End.Return=0x%x.\n"), ComponentId, SubcomponentId,phBitMapInput));
    }
    else
    {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]  End.Return=0x%x.\n"), ComponentId, SubcomponentId,phBitMapInput));
    }
    MyQueryInfo = NULL;
    return bReturn;
}
#endif


DWORD_PTR OC_QUERY_IMAGE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;

    dwOcEntryReturn = (DWORD)NULL;

    if(LOWORD(Param1) == SubCompInfoSmallIcon)
    {
        if (_tcsicmp(SubcomponentId, STRING_iis_ftp) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle,MAKEINTRESOURCE(IDB_FTP));}
        if (_tcsicmp(SubcomponentId, STRING_iis_www) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW));}
        if (_tcsicmp(SubcomponentId, STRING_iis_www_parent) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW));}
        if (_tcsicmp(SubcomponentId, STRING_iis_www_vdir_scripts) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW_VDIR));}
        if (_tcsicmp(SubcomponentId, STRING_iis_www_vdir_printers) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_WWW_VDIR));}
        if (_tcsicmp(SubcomponentId, STRING_iis_htmla) == 0 || _tcsicmp(SubcomponentId, STRING_iis_doc) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_HTMLA));}
        if (_tcsicmp(SubcomponentId, STRING_iis_inetmgr) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_INETMGR));}
        if (_tcsicmp(SubcomponentId, STRING_iis_pwmgr) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_PWS));}
        if (_tcsicmp(SubcomponentId, _T("iis")) == 0) {dwOcEntryReturn = (DWORD_PTR) LoadBitmap((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDB_TOPLEVEL_IIS));}
    }

    if (dwOcEntryReturn != NULL)
    {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]  End.Return=0x%x.\n"), ComponentId, SubcomponentId,dwOcEntryReturn));
    }
    else
    {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]  End.Return=NULL.\n"), ComponentId, SubcomponentId));
    }
    return dwOcEntryReturn;
}


int GetTotalTickGaugeFromINF(IN LPCTSTR SubcomponentId, IN int GimmieForInstall)
{
    int nReturn = 0;
    INFCONTEXT Context;
    TCHAR szTempString[20];
    TCHAR szTempString2[20];
    
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("TotalTicks"), &Context) )
    {
        SetupGetStringField(&Context, 1, szTempString, 20, NULL);

        if (!SetupGetStringField(&Context, 2, szTempString2, 20, NULL))
            {_tcscpy(szTempString2,szTempString);}

        //iisDebugOut((LOG_TYPE_TRACE, _T("GetTotalTickGaugeFromINF:%s,%s\n"),szTempString,szTempString2));

        if (GimmieForInstall)
        {
            nReturn = _ttoi(szTempString);
        }
        else
        {
            nReturn = _ttoi(szTempString2);
        }
    }

    return nReturn;
}


//
// Param1 = unused
// Param2 = unused
//
// Return value is an arbitrary 'step' count or -1 if error.
//
// OC Manager calls this routine when it wants to find out how much
// work the component wants to perform for nonfile operations to
// install/uninstall a component/subcomponent.
// It is called once for the *entire* component and then once for
// each subcomponent in the component.
//
// One could get arbitrarily fancy here but we simply return 2 step
// per subcomponent. We ignore the "entire component" case.
//
DWORD_PTR OC_QUERY_STEP_COUNT_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;

    // iis
    // iis_common
    // iis_inetmgr
    // iis_www
    // iis_doc
    // iis_htmla
    // iis_ftp

    //AT_DO_NOTHING AT_REMOVE AT_INSTALL_FRESH AT_INSTALL_UPGRADE AT_INSTALL_REINSTALL

    if (SubcomponentId)
    {
        ACTION_TYPE atComp = GetSubcompAction(SubcomponentId, FALSE);

        // Set the Tick Total value for iis_common (which includes iis_core)
        if (_tcsicmp(SubcomponentId, STRING_iis_common) == 0)
        {
            // Get the operations for Core instead since this is bigger.
            ACTION_TYPE atCORE = GetIISCoreAction(FALSE);
            if (atCORE == AT_REMOVE) 
                {dwOcEntryReturn = GetTotalTickGaugeFromINF(SubcomponentId, FALSE);}
            else
                {dwOcEntryReturn = GetTotalTickGaugeFromINF(SubcomponentId, TRUE);}
            if (atCORE == AT_DO_NOTHING) 
                {dwOcEntryReturn = 0;}
        }
        else
        {
            if (atComp == AT_REMOVE)
                {dwOcEntryReturn = GetTotalTickGaugeFromINF(SubcomponentId, FALSE);}
            else
                {dwOcEntryReturn = GetTotalTickGaugeFromINF(SubcomponentId, TRUE);}
            if (atComp == AT_DO_NOTHING) 
                {dwOcEntryReturn = 0;}
        }
    }
    else
    {
        //
        // "Entire component" case, which we ignore.
        //
        dwOcEntryReturn = 0;
    }

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    return dwOcEntryReturn;
}


//
// This is a fake notification. You'll never receive this notification from OCM.
//
DWORD_PTR OC_NOTIFICATION_FROM_QUEUE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;

    dwOcEntryReturn = 0;
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));

    return dwOcEntryReturn;
}


void StopAllServicesThatAreRelevant(int iShowErrorsFlag)
{
    int iPleaseStopTheService = FALSE;
#ifndef _CHICAGO_
    ACTION_TYPE atTheComponent_core = GetIISCoreAction(FALSE);
    ACTION_TYPE atTheComponent_ftp = GetSubcompAction(STRING_iis_ftp, FALSE);
    ACTION_TYPE atTheComponent_www = GetSubcompAction(STRING_iis_www, FALSE);

    int BringALLIISClusterResourcesOffline_WasCalled = FALSE;

    //ACTION_TYPE atTheComponent_common = GetSubcompAction(STRING_iis_common, FALSE);
    //ACTION_TYPE atTheComponent_inetmgr = GetSubcompAction(STRING_iis_inetmgr, FALSE);
    //ACTION_TYPE atTheComponent_pwmgr = GetSubcompAction(STRING_iis_pwmgr, FALSE);
    //ACTION_TYPE atTheComponent_doc = GetSubcompAction(STRING_iis_doc, FALSE);
    //ACTION_TYPE atTheComponent_htmla = GetSubcompAction(STRING_iis_htmla, FALSE);
    
    // ----------------------
    // Handle the MSFTPSVC service...
    // ----------------------
    // Check if we are going to remove something...
    iPleaseStopTheService = FALSE;
    if (atTheComponent_ftp != AT_DO_NOTHING){iPleaseStopTheService = TRUE;}
    if (iPleaseStopTheService)
    {
        // important: you must take iis clusters off line before doing anykind of upgrade\installs...
        // but incase the user didn't do this... try to take them off line for the user
        if (FALSE == BringALLIISClusterResourcesOffline_WasCalled)
        {
	        DWORD dwResult = ERROR_SUCCESS;
	        dwResult = BringALLIISClusterResourcesOffline();
            BringALLIISClusterResourcesOffline_WasCalled = TRUE;
        }
        if (StopServiceAndDependencies(_T("MSFTPSVC"), FALSE) == FALSE)
        {
            if (iShowErrorsFlag)
            {
                MyMessageBox(NULL, IDS_UNABLE_TO_STOP_SERVICE,_T("MSFTPSVC"), MB_OK | MB_SETFOREGROUND);
            }
        }
    }

    // ----------------------
    // Handle the W3SVC service...
    // ----------------------
    iPleaseStopTheService = FALSE;
    if (atTheComponent_www != AT_DO_NOTHING){iPleaseStopTheService = TRUE;}

    if (iPleaseStopTheService)
    {
        // important: you must take iis clusters off line before doing anykind of upgrade\installs...
        // but incase the user didn't do this... try to take them off line for the user
        if (FALSE == BringALLIISClusterResourcesOffline_WasCalled)
        {
	        DWORD dwResult = ERROR_SUCCESS;
	        dwResult = BringALLIISClusterResourcesOffline();
            BringALLIISClusterResourcesOffline_WasCalled = TRUE;
        }
        if (StopServiceAndDependencies(_T("W3SVC"), FALSE) == FALSE)
        {
            if (iShowErrorsFlag)
            {
                MyMessageBox(NULL, IDS_UNABLE_TO_STOP_SERVICE,_T("W3SVC"), MB_OK | MB_SETFOREGROUND);
            }
        }
    }

    // ----------------------
    // Handle the IISADMIN service...
    // ----------------------
    iPleaseStopTheService = FALSE;
    if (atTheComponent_core != AT_DO_NOTHING){iPleaseStopTheService = TRUE;}

    // if they are adding msftpsvc or w3svc, then we'll have to stop this iisadmin service as well!
    // why?  because the iisadmin serivce (inetinfo.exe) can be locking some files that we want to copy in.
    // and if we can't copy them in, things could get hosed -- especially w3svc.
    // actually if you think about it all the services (msftp,w3svc,smtp, etc..) area all running in the same process (inetinfo.exe)
    // so it kinda makes sense that we have to stop this service when add\removing.

    // let's say i removed msftpsvc -- and the services are still running,
    // then i go and re-add msftpsvc -- well because we didn't reboot some of those ftp files are still
    // locked -- so well have to do the old "slip it in on reboot" trick or something
    // which still may have problems.  Bottom line here is -- we have to stop iisadmin service when adding\readding
    // msftpsvc or w3svc

    // when i tested this -- it looks like the wam*.dll's get locked by the inetinfo.exe process
    // so i have to stop the iisadmin service to unload those.
    
    // if we they are trying to remove ftp then we don't have to stop the iisadmin service.
    // but if we are trying to add, then stop the iisadmin service
    if (atTheComponent_ftp != AT_DO_NOTHING && atTheComponent_ftp != AT_REMOVE)
        {iPleaseStopTheService = TRUE;}

    // if we they are trying to remove w3svc then we don't have to stop the iisadmin service.
    // but if we are trying to add, then stop the iisadmin service
    if (atTheComponent_www != AT_DO_NOTHING && atTheComponent_www != AT_REMOVE)
        {iPleaseStopTheService = TRUE;}

    if (iPleaseStopTheService)
    {
        // important: you must take iis clusters off line before doing anykind of upgrade\installs...
        // but incase the user didn't do this... try to take them off line for the user
        if (FALSE == BringALLIISClusterResourcesOffline_WasCalled)
        {
	        DWORD dwResult = ERROR_SUCCESS;
	        dwResult = BringALLIISClusterResourcesOffline();
            BringALLIISClusterResourcesOffline_WasCalled = TRUE;
        }
        if (StopServiceAndDependencies(_T("IISADMIN"), TRUE) == FALSE)
        {
            if (iShowErrorsFlag)
            {
                MyMessageBox(NULL, IDS_UNABLE_TO_STOP_SERVICE,_T("IISADMIN"), MB_OK | MB_SETFOREGROUND);
            }
        }
    }

#endif
    return;
}


DWORD_PTR OC_FILE_BUSY_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
{
    DWORD_PTR dwOcEntryReturn = 0;
    //dwOcEntryReturn = TRUE;
    PFILEPATHS pTheBusyFile;
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   Start.\n"), ComponentId, SubcomponentId));

    pTheBusyFile = (PFILEPATHS) Param1;
    iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("Target=%1!s!, Source=%2!s!\n"), pTheBusyFile->Target, pTheBusyFile->Source));

    ProcessSection(g_pTheApp->m_hInfHandle, _T("OC_FILE_BUSY"));

    // display the file version information
    LogFileVersion(pTheBusyFile->Target, TRUE);

    // handle the file busy stuff ourselves.
    // either - 1. findout who is locking this file -- which process or services and stop it.
    //          2. or try to rename the locked file and copy in the new one.
    //             will set the reboot flag if we did #2
    HandleFileBusyOurSelf(pTheBusyFile);

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s]   End.  Return=%d\n"), ComponentId, SubcomponentId, dwOcEntryReturn));
    return dwOcEntryReturn;
}


#define HandleMetabaseBeforeSetupStarts_log _T("HandleMetabaseBeforeSetupStarts")
void HandleMetabaseBeforeSetupStarts()
/*++

Routine Description:

    This function handles the metabase file in various installation scenario before iis setup really starts.
    It is developed in order to handle NT5 GUI mode setup re-startable.

    This function should be called exactly after we have stopped all running iis services,
    such that nobody is locking the metabase file.

Arguments:

    None

Return Value:

    void

--*/
{
    CString csMetabaseFile;

    csMetabaseFile = g_pTheApp->m_csPathInetsrv + _T("\\metabase.bin");

    switch (g_pTheApp->m_eInstallMode) {
    case IM_UPGRADE:
        {
            if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
            {
                CString csBackupFile;

                csBackupFile = g_pTheApp->m_csPathInetsrv + _T("\\upg45b2.bin");

                if (IsFileExist(csBackupFile)) {
                    //
                    // restore it back to be the current metabase.bin
                    //

                    iisDebugOut((LOG_TYPE_TRACE, _T("%s:IM_UPGRADE:restore upg45b2.bin to metabase.bin\n"),HandleMetabaseBeforeSetupStarts_log));
                    InetCopyFile(csBackupFile, csMetabaseFile);

                } else {
                    //
                    // backup the current metabase.bin to upg45b2.bin
                    //
                    if (IsFileExist(csMetabaseFile)) 
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("%s:IM_UPGRADE:backup metabase.bin to upg45b2.bin\n"),HandleMetabaseBeforeSetupStarts_log));
                        InetCopyFile(csMetabaseFile, csBackupFile);
                    }
                    else
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("%s:IM_UPGRADE:backup metabase.bin to upg45b2.bin.  metabase.bin not found WARNING.\n"),HandleMetabaseBeforeSetupStarts_log));
                    }
                }

                //
                // delete the backup file on reboot
                //

                iisDebugOut((LOG_TYPE_TRACE, _T("%s:IM_UPGRADE:mark upg45b2.bin as delete-on-reboot\n"),HandleMetabaseBeforeSetupStarts_log));
                MoveFileEx( (LPCTSTR)csBackupFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT );

                break;
            }

            // for all the other upgrades, fall through
            // to blow away the existing metabase.bin
        }
    case IM_FRESH:
        {
            //
            // blow away the existing metabase.bin
            //
            iisDebugOut((LOG_TYPE_TRACE, _T("%s:IM_FRESH.Delete metabase.bin for NTsetup restartable mode case.\n"),HandleMetabaseBeforeSetupStarts_log));
            InetDeleteFile(csMetabaseFile);
            break;
        }
    default:
        {
            break;
        }
    }

    return;
}

void SetRebootFlag(void)
{
	gHelperRoutines.SetReboot(gHelperRoutines.OcManagerContext, TRUE);
}


#define GetStateFromUnattendFile_log _T("GetStateFromUnattendFile")
int GetStateFromUnattendFile(LPCTSTR SubcomponentId)
/*++

Routine Description:

    This function determines the current state of SubcomponentId
    according to values specified in the unattend text file.

Arguments:

    SubcomponentId: the name of the component, e.g., iis_www

Return Value:

    SubcompOn/SubcompOff/SubcompUseOcManagerDefault
    This function returns SubcompUseOcManagerDefault in case the value of SubcomponentId
    is neither specified as ON nor OFF.

--*/
{
    int nReturn = SubcompUseOcManagerDefault;
    INFCONTEXT Context;
    TCHAR szSectionName[_MAX_PATH];
    TCHAR szValue[_MAX_PATH] = _T("");

    _tcscpy(szSectionName, _T("InternetServer"));

    if (g_pTheApp->m_hUnattendFile == INVALID_HANDLE_VALUE || g_pTheApp->m_hUnattendFile == NULL)
        {return SubcompUseOcManagerDefault;}

    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, szSectionName, SubcomponentId, &Context) ) 
        {SetupGetStringField(&Context, 1, szValue, _MAX_PATH, NULL);}

    if (_tcsicmp(szValue, _T("ON")) == 0)
        {nReturn = SubcompOn;}
    else if (_tcsicmp(szValue, _T("OFF")) == 0)
        {nReturn = SubcompOff;}
    else
        {nReturn = SubcompUseOcManagerDefault;}

    if (SubcompOn)
        {iisDebugOut((LOG_TYPE_TRACE, _T("%s() on %s returns SubcompOn\n"), GetStateFromUnattendFile_log, SubcomponentId));}
    if (SubcompOff)
        {iisDebugOut((LOG_TYPE_TRACE, _T("%s() on %s returns SubcompOff\n"), GetStateFromUnattendFile_log, SubcomponentId));}
    if (SubcompUseOcManagerDefault)
        {iisDebugOut((LOG_TYPE_TRACE, _T("%s() on %s returns SubcompUseOcManagerDefault\n"), GetStateFromUnattendFile_log, SubcomponentId));}

    return nReturn;
}

int GetStateFromModesLine(LPCTSTR SubcomponentId, int nModes)
/*++

Routine Description:

    This function determines the current state of SubcomponentId
    according to the Modes= line specified in the inf file.

Arguments:

    SubcomponentId: the name of the component, e.g., iis_www

Return Value:

    SubcompOn/SubcompOff only

--*/
{
    int nReturn = SubcompOff;
    BOOL bFound = FALSE;
    INFCONTEXT Context;

    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("Modes"), &Context) )
    {
        int n, i, nValue;

        n = SetupGetFieldCount(&Context);
        for(i=0; i<n; i++) {
            if(SetupGetIntField(&Context,i+1,&nValue) && ((DWORD)nValue < 32)) {
                if (nValue == nModes) {
                    bFound = TRUE;
                    break;
                }
            }
        }
    }

    if (bFound)
        nReturn = SubcompOn;
    else
        nReturn = SubcompOff;

    iisDebugOut((LOG_TYPE_TRACE, _T("%s() on %s for mode %d returns %d\n"), GetStateFromUnattendFile_log, SubcomponentId, nModes, nReturn));
    
    return nReturn;
}

int GetStateFromRegistry(LPCTSTR SubcomponentId)
/*++

Routine Description:

    This function determines the original state of SubcomponentId
    according to the registry value.

Arguments:

    SubcomponentId: the name of the component, e.g., iis_www

Return Value:

    SubcompOn/SubcompOff only

--*/
{
    int nReturn = SubcompOff;

    CRegKey regKey(HKEY_LOCAL_MACHINE,OC_MANAGER_SETUP_KEY,KEY_READ);
    if ((HKEY)regKey) 
    {
        DWORD dwValue = 0xffffffff;
        regKey.m_iDisplayWarnings = TRUE;
        if (regKey.QueryValue(SubcomponentId, dwValue) == ERROR_SUCCESS)
        {
            if (dwValue == 0x0)
                nReturn = SubcompOff;
            else
                nReturn = SubcompOn;
        }
    }
    
    iisDebugOut((LOG_TYPE_TRACE, _T("GetStateFromRegistry() on %s returns %d\n"), SubcomponentId, nReturn));
    
    return nReturn;
}


int IsThisSubCompNeededByOthers(LPCTSTR SubcomponentId)
{
    int iReturn = FALSE;

    // search thru our inf to see if another component needs it

    return iReturn;
}

int DoesOCManagerKeyExist(LPCTSTR SubcomponentId)
{
    int iReturn = FALSE;

    CRegKey regKey(HKEY_LOCAL_MACHINE,OC_MANAGER_SETUP_KEY,KEY_READ);
    if ((HKEY)regKey) 
    {
        DWORD dwValue = 0xffffffff;
        regKey.m_iDisplayWarnings = FALSE;
        if (regKey.QueryValue(SubcomponentId, dwValue) == ERROR_SUCCESS)
            {iReturn = TRUE;}
    }
    return iReturn;
}


int GetStateFromUpgRegLines(LPCTSTR SubcomponentId)
/*++

Routine Description:

    This function determines the original state of SubcomponentId
    according to the UpgReg= line specified in the inf file.

Arguments:

    SubcomponentId: the name of the component, e.g., iis_www

Return Value:

    SubcompOn/SubcompOff only

--*/
{
    int nReturn = SubcompOff;
    INFCONTEXT Context;
    TCHAR szPath[_MAX_PATH];
    TCHAR szUpgradeInfKeyToUse[30];

    _tcscpy(szUpgradeInfKeyToUse, _T("None"));

    // Check for special NT4 upgrade
    if (g_pTheApp->m_eUpgradeType == UT_40)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg4"), &Context) )
        {
            _tcscpy(szUpgradeInfKeyToUse, _T("UpgReg4"));
            //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("GetStateFromUpgRegLines() use: UpgReg4.\n")));
            SetupGetStringField(&Context, 1, szPath, _MAX_PATH, NULL);
            CRegKey regKey(HKEY_LOCAL_MACHINE, szPath, KEY_READ);
            if ((HKEY)regKey) 
            {
                TCHAR szCompId[_MAX_PATH];
                int iValue = 0;
                DWORD dwValue = 0xffffffff;
                SetupGetStringField(&Context, 2, szCompId, _MAX_PATH, NULL);
                SetupGetIntField(&Context, 3, &iValue);
                regKey.m_iDisplayWarnings = TRUE;
                if (regKey.QueryValue(szCompId, dwValue) == ERROR_SUCCESS) 
                {
                    if (dwValue == (DWORD)iValue)
                        nReturn = SubcompOn;
                }
            }
        }
        goto GetStateFromUpgRegLines_Exit;
    }
    // Check for special NT60 upgrade
    if (g_pTheApp->m_eUpgradeType == UT_60)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg60"), &Context) )
        {
            _tcscpy(szUpgradeInfKeyToUse, _T("UpgReg60"));
            //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("GetStateFromUpgRegLines() use: UpgReg60.\n")));
            SetupGetStringField(&Context, 1, szPath, _MAX_PATH, NULL);
            CRegKey regKey(HKEY_LOCAL_MACHINE, szPath, KEY_READ);
            if ((HKEY)regKey) 
            {
                TCHAR szCompId[_MAX_PATH];
                int iValue = 0;
                DWORD dwValue = 0xffffffff;
                SetupGetStringField(&Context, 2, szCompId, _MAX_PATH, NULL);
                SetupGetIntField(&Context, 3, &iValue);
                regKey.m_iDisplayWarnings = TRUE;
                if (regKey.QueryValue(szCompId, dwValue) == ERROR_SUCCESS) 
                {
                    if (dwValue == (DWORD)iValue)
                        nReturn = SubcompOn;
                }
            }
        }
        goto GetStateFromUpgRegLines_Exit;
    }

    // Check for special NT5 upgrade
    if (g_pTheApp->m_eUpgradeType == UT_51)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg51"), &Context) )
        {
            _tcscpy(szUpgradeInfKeyToUse, _T("UpgReg51"));
            //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("GetStateFromUpgRegLines() use: UpgReg51.\n")));
            SetupGetStringField(&Context, 1, szPath, _MAX_PATH, NULL);
            CRegKey regKey(HKEY_LOCAL_MACHINE, szPath, KEY_READ);
            if ((HKEY)regKey) 
            {
                TCHAR szCompId[_MAX_PATH];
                int iValue = 0;
                DWORD dwValue = 0xffffffff;
                SetupGetStringField(&Context, 2, szCompId, _MAX_PATH, NULL);
                SetupGetIntField(&Context, 3, &iValue);
                regKey.m_iDisplayWarnings = TRUE;
                if (regKey.QueryValue(szCompId, dwValue) == ERROR_SUCCESS) 
                {
                    if (dwValue == (DWORD)iValue)
                        nReturn = SubcompOn;
                }
            }
        }
        goto GetStateFromUpgRegLines_Exit;
    }

    // Check for special NT5 upgrade
    if (g_pTheApp->m_eUpgradeType == UT_50)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg5"), &Context) )
        {
            _tcscpy(szUpgradeInfKeyToUse, _T("UpgReg5"));
            //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("GetStateFromUpgRegLines() use: UpgReg5.\n")));
            SetupGetStringField(&Context, 1, szPath, _MAX_PATH, NULL);
            CRegKey regKey(HKEY_LOCAL_MACHINE, szPath, KEY_READ);
            if ((HKEY)regKey) 
            {
                TCHAR szCompId[_MAX_PATH];
                int iValue = 0;
                DWORD dwValue = 0xffffffff;
                SetupGetStringField(&Context, 2, szCompId, _MAX_PATH, NULL);
                SetupGetIntField(&Context, 3, &iValue);
                regKey.m_iDisplayWarnings = TRUE;
                if (regKey.QueryValue(szCompId, dwValue) == ERROR_SUCCESS) 
                {
                    if (dwValue == (DWORD)iValue)
                        nReturn = SubcompOn;
                }
            }
        }
        goto GetStateFromUpgRegLines_Exit;
    }

    // Check if there is a specific one for our special upgrade type.
    _tcscpy(szUpgradeInfKeyToUse, _T("UpgReg"));

    if (g_pTheApp->m_eUpgradeType == UT_351)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg351"), &Context) )
            {_tcscpy(szUpgradeInfKeyToUse, _T("UpgReg351"));}
    }

    if (g_pTheApp->m_eUpgradeType == UT_10)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg1"), &Context) )
            {_tcscpy(szUpgradeInfKeyToUse, _T("UpgReg1"));}
    }

    if (g_pTheApp->m_eUpgradeType == UT_20)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg2"), &Context) )
            {_tcscpy(szUpgradeInfKeyToUse, _T("UpgReg2"));}
    }
    if (g_pTheApp->m_eUpgradeType == UT_30)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg3"), &Context) )
            {_tcscpy(szUpgradeInfKeyToUse, _T("UpgReg3"));}
    }
    if (g_pTheApp->m_eUpgradeType == UT_10_W95)
    {
        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, _T("UpgReg1_w95"), &Context) )
            {_tcscpy(szUpgradeInfKeyToUse, _T("UpgReg1_w95"));}
    }

    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, SubcomponentId, szUpgradeInfKeyToUse, &Context) ) 
    {
        SetupGetStringField(&Context, 1, szPath, _MAX_PATH, NULL);
        CRegKey regKey(HKEY_LOCAL_MACHINE, szPath, KEY_READ);
        if ((HKEY)regKey)
        {
            TCHAR szCompId[_MAX_PATH];
            int iValue = 0;
            DWORD dwValue = 0xffffffff;

            // check if there is a parameter specified
            if (SetupGetStringField(&Context, 2, szCompId, _MAX_PATH, NULL))
            {
                if (SetupGetIntField(&Context, 3, &iValue))
                {
                    // check if the dword matches what we specified.
                    regKey.m_iDisplayWarnings = FALSE;
                    if (regKey.QueryValue(szCompId, dwValue) == ERROR_SUCCESS) 
                    {
                        if (dwValue == (DWORD)iValue)
                            {nReturn = SubcompOn;}
                    }
                }
                else
                {
                    // just check for existence.
                    regKey.m_iDisplayWarnings = FALSE;
                    if (regKey.QueryValue(szCompId, dwValue) == ERROR_SUCCESS) 
                    {
                        nReturn = SubcompOn;
                    }
                }
            }
            else
            {
                nReturn = SubcompOn;
            }
        }
    }
    
GetStateFromUpgRegLines_Exit:
    iisDebugOut((LOG_TYPE_TRACE, _T("GetStateFromUpgRegLines() %s:%s returns %d\n"), szUpgradeInfKeyToUse, SubcomponentId, nReturn));
    return nReturn;
}

void InCaseNoTCPIP(LPCTSTR SubcomponentId, int nNewStateValue, int *pnState)
/*++

Routine Description:

    This function overwrites current state with nNewStateValue 
    in case that TCPIP is not present.

Arguments:

    LPCTSTR SubcomponentId: e.g., iis_www, etc.
    int nNewStateValue: SubcompOn/SubcompOff/SubcompUseOcManagerDefault
    int *pnState: pointer to the state which will be overwritten if condition is met.

Return Value:

    void

--*/
{
    // check if tcpip is installed
    g_pTheApp->IsTCPIPInstalled();

    if (g_pTheApp->m_fTCPIP == FALSE) 
    {
        if (_tcsicmp(SubcomponentId, STRING_iis_inetmgr) == 0 || 
            _tcsicmp(SubcomponentId, STRING_iis_www) == 0     || 
            _tcsicmp(SubcomponentId, STRING_iis_pwmgr) == 0 )
        {
            *pnState = nNewStateValue;
        }
    }

    return;
}

DWORD_PTR OC_QUERY_STATE_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
/*++

Routine Description:

    This function handles OC_QUERY_STATE notification.
    
    IIS 4.0 SETUP NOTE (LinanT): 
    ============================
    This function returns SubcompOn/SubcompOff explicitly. 
    It does NOT return SubcompUseOcManagerDefault, because 
    OCM sometimes behaves strangely when SubcompUseOcManagerDefault is returned.
    The above comments were valid for iis4 but in iis5 ocmanage has been fixed so
    that SubcompUseOcManagerDefault is valid

    IIS 5.0 SETUP NOTE (AaronL):
    ============================
    Well okay.  iis5.0 shipped with Win2000, Patst and then AndrewR took over the ocmanager.
    They made a bunch of changes to ocmanager to appropriately handle the "needs" relationship stuff in the .inf files.
    Anyway, that stuffs all kool, however things had to be changed in order for this oc_query_state stuff to work.

    Here is basic description of how this works:

    OCSELSTATETYPE_ORIGINAL
    -----------------------
    During setup ocmanage will ask each of the components for they're original state (OCSELSTATETYPE_ORIGINAL).
    In this call each component can return back the state of that certain component -- such as "yes, a previous inetmgr 1.0,2.0,3.0,4.0 or 5.0 is already installed".

    If this is a fresh\maintenance installation, the component should return back SubcompUseOcManagerDefault.  Meaning, ocmanage will look in the registry for this component
    probably at HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OC Manager\Subcomponents;SubcomponentId=1 or 0.
    if the component value is 0, then ocmanage will figure your component is off.  if it's 1 then it's on.  however if it's not there, then ocmanage will use whatever
    the component has specified for for it's Modes= line in the .inf file.

    During an upgrade installation, well, since older installations of inetmgr maybe located at a different registry key than at:
    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OC Manager\Subcomponents;iis_inetmgr=1 or 0.
    we have to let ocmanage know, what the original state is by manually returning on/off/default.

    Okay so what's the deal here?  Why do we even need to use default?  That's because something in ocmanage isn't working quite right and AndrewR doesn't want to destabilize
    setup by making such a drastic this late in win2000 ship cycle.  Here is the story.  If iis_inetmgr returns on during this call -- kool, everything is fine and no problems.
    however if i find that iis_inetmgr was not previously installed, then naturally i would want to return "off", but in fact this is wrong and will hose other things.  how you say?
    well because if i return "off" here, that means other components which need iis_inetmgr will not be able to turn it "on" thru needs (since the ocmanage has a screwy bug with this).
    But if i return here "SubcompUseOcManagerDefault", then the other components will be able to turn it on iff they need it.  the catch here is that -- ocmanage will use SubcompUseOcManagerDefault
    which means that it will lookup in the registry:
    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OC Manager\Subcomponents;iis_inetmgr=1 or 0.
    and determine for itself if it should be on or off, however on the upgrade iis_inetmgr won't be there so it will want to default to the "Modes=" line.  however if iis is installed by default -- as 
    specified in the modes= lines -- then iis_inetmgr would be turned on wrongly!

    How to work around this problem?  Well, if the HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OC Manager\Subcomponents;iis_inetmgr=1 or 0
    key was there then ocmanage wouldn't have to consult the Modes= line.  so the workaround was for AndrewR, on an upgrade case to crate the
    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OC Manager\Subcomponents;iis_inetmgr key if it wasn't already there.

    OCSELSTATETYPE_CURRENT
    -----------------------
    on a fresh just returns SubcompUseOcManagerDefault.  in this case ocmanage should open the .inf file and read my Modes= line to determine if this component should be on or off.
    on a maintenance mode add\remove (there is no removeall or reinstall in win2000 add\remove ocmanage) just returns SubcompUseOcManagerDefault.  in which ocmanage will just read the registry again.
    on upgrade the code will return either on or usedefault.  we don't ever want to return off here because that would prevent other components which need us from turing us on.

--*/
{
    int nReturn = SubcompUseOcManagerDefault;
    TCHAR szTempStringInstallMode[40];
    _tcscpy(szTempStringInstallMode, _T("NONE"));

    if (!SubcomponentId)
        {goto OC_QUERY_STATE_Func_Exit;}

    switch (g_pTheApp->m_eInstallMode)
    {
        case IM_FRESH:
            _tcscpy(szTempStringInstallMode, _T("IM_FRESH"));
            break;
        case IM_MAINTENANCE:
            _tcscpy(szTempStringInstallMode, _T("IM_MAINTENANCE"));
            break;
        case IM_UPGRADE:
            _tcscpy(szTempStringInstallMode, _T("IM_UPGRADE"));
            break;
    }
    
    if (Param1 == OCSELSTATETYPE_ORIGINAL)
    {
        switch (g_pTheApp->m_eInstallMode)
        {
            case IM_FRESH:
                nReturn = SubcompUseOcManagerDefault;
                break;
            case IM_MAINTENANCE:
                nReturn = SubcompUseOcManagerDefault;
                break;
            case IM_UPGRADE:
                nReturn = GetStateFromUpgRegLines(SubcomponentId);
                if (SubcompOff == nReturn)
                {
                    if (g_pTheApp->m_eUpgradeType != UT_NONE)
                    {
                        // Dont' return back SubCompOff because ocmanage won't be able to turn it on from they're screwy needs logic.
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End. OCSELSTATETYPE_ORIGINAL. %s. Return=SubcompUseOcManagerDefault (But really it was SubCompOff)\n"), ComponentId, SubcomponentId, szTempStringInstallMode));
                        nReturn = SubcompUseOcManagerDefault;
                    }
                }
                break;
            default:
                break;
        }
        goto OC_QUERY_STATE_Func_Exit;
    } // OCSELSTATETYPE_ORIGINAL


    if (Param1 == OCSELSTATETYPE_CURRENT)
    {
        // This should overide everything...
        if (g_pTheApp->m_bPleaseDoNotInstallByDefault == TRUE)
        {
            _tcscpy(szTempStringInstallMode, _T("IM_NO_IIS_TO_UPGRADE"));
            // change for AndrewR to make sure that during an upgrade, our component is set to default (which will be "off" by default since the modes= line will be set [if not there] at the beginning  of guimode setup)
            nReturn = SubcompUseOcManagerDefault;
            iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] Start. OCSELSTATETYPE_CURRENT.m_bPleaseDoNotInstallByDefault=TRUE,so setting to SubcompUseOcManagerDefault by default.\n"), ComponentId, SubcomponentId));
            goto OC_QUERY_STATE_Func_Exit;
        }

        if (g_pTheApp->m_eInstallMode == IM_FRESH) 
        {
            nReturn = SubcompUseOcManagerDefault;
            goto OC_QUERY_STATE_Func_Exit;
        }

        if (g_pTheApp->m_eInstallMode == IM_MAINTENANCE) 
        {
            int nOriginal = (gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL)) ? SubcompOn : SubcompOff;
            switch (g_pTheApp->m_dwSetupMode)
            {
                case SETUPMODE_ADDREMOVE:
                    nReturn = SubcompUseOcManagerDefault;
                    break;
                case SETUPMODE_REINSTALL:
                    nReturn = nOriginal;
                    break;
                case SETUPMODE_REMOVEALL:
                    nReturn = SubcompOff;
                    break;
            }

            goto OC_QUERY_STATE_Func_Exit;
        }

        if (g_pTheApp->m_eInstallMode == IM_UPGRADE) 
        {
            int nOriginal = (gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL)) ? SubcompOn : SubcompOff;
            switch (g_pTheApp->m_dwSetupMode)
            {
                case SETUPMODE_UPGRADEONLY:
                    nReturn = nOriginal;
                    break;
                case SETUPMODE_ADDEXTRACOMPS:
                    nReturn = nOriginal;
                    break;
            }

            // ocmanager work around.
            // check the ocmanage setup key to see if this entry
            // exists -- in an upgrade ocmanage is assuming that it does exist
            // when in fact -- it may not (since they ocmanage key could have been introduced in this new OS version
            // if the key is in the registry then set this to subcompuseocmanagedefault, otherwise, set it to off
            //if (TRUE == DoesOCManagerKeyExist(SubcomponentId))
            {
                if (SubcompOff == nReturn)
                {
                    nReturn = SubcompUseOcManagerDefault;
                    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End. OCSELSTATETYPE_CURRENT. %s. Return=SubcompUseOcManagerDefault (But really it was SubCompOff)\n"), ComponentId, SubcomponentId, szTempStringInstallMode));
                }
            }
            /*
            else
            {
                // however if the key does not exist
                // we want to set this to off (since ocmanage will take the default from the modes line -- which is probably on)
                // however if this component is needed by another component, then this component won't be able to be turned on
                // since it was set to off.

                // so before we go and set this component to be off, check to see if it has any needs dependencies (like it's needed by someone else)
                // if it's needed by someone else then we set it to be SubcompUseOcManagerDefault
                if (TRUE == IsThisSubCompNeededByOthers(SubcomponentId))
                {
                    if (SubcompOff == nReturn)
                    {
                        nReturn = SubcompUseOcManagerDefault;
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End. OCSELSTATETYPE_CURRENT. %s. Return=SubcompUseOcManagerDefault (But really it was SubCompOff)\n"), ComponentId, SubcomponentId, szTempStringInstallMode));
                    }

                }
            }
            */

            //
            // if we are running on Whistler personal, then
            // return back OFF! -- so that we will remove ourselves!
            //
            if (TRUE == IsWhistlerPersonal())
            {
                nReturn = SubcompOff;
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End. OCSELSTATETYPE_CURRENT. %s. Return=SubCompOff (always on personal)\n"), ComponentId, SubcomponentId, szTempStringInstallMode));
            }
        }
        goto OC_QUERY_STATE_Func_Exit;
    } // OCSELSTATETYPE_CURRENT

    if (Param1 == OCSELSTATETYPE_FINAL)
    {
        nReturn = SubcompUseOcManagerDefault;
	    if (!g_iOC_COMPLETE_INSTALLATION_Called)
	    {
            // user could have cancelled setup
            // so only do this in guimode fresh or upgrade scenario.
            if (g_pTheApp->m_fNTGuiMode)
            {
                nReturn = SubcompOff;
            }
	    }
        goto OC_QUERY_STATE_Func_Exit;
    } // OCSELSTATETYPE_FINAL

    
OC_QUERY_STATE_Func_Exit:
	TCHAR szTempStringMode[40];
    if (nReturn == SubcompOn) 
		{_tcscpy(szTempStringMode, _T("SubcompOn"));}
    if (nReturn == SubcompOff) 
		{_tcscpy(szTempStringMode, _T("SubcompOff"));}
    if (nReturn == SubcompUseOcManagerDefault)
		{_tcscpy(szTempStringMode, _T("SubcompUseOcManagerDefault"));}

    if (Param1 == OCSELSTATETYPE_ORIGINAL)
		{iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End. OCSELSTATETYPE_ORIGINAL. %s. Return=%s\n"), ComponentId, SubcomponentId, szTempStringInstallMode, szTempStringMode));}
    if (Param1 == OCSELSTATETYPE_CURRENT)
		{iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End. OCSELSTATETYPE_CURRENT. %s. Return=%s\n"), ComponentId, SubcomponentId, szTempStringInstallMode, szTempStringMode));}
    if (Param1 == OCSELSTATETYPE_FINAL)
		{iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End. OCSELSTATETYPE_FINAL. %s. Return=%s\n"), ComponentId, SubcomponentId, szTempStringInstallMode, szTempStringMode));}

    return nReturn;
}


DWORD TryToSlipInFile(PFILEPATHS pFilePath)
{
    DWORD dwReturn = FALSE;
    iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("TryToSlipInFile:Replacing critical setup file %1!s!.\n"), pFilePath->Target));

    BOOL        bOK                       = FALSE;
    DWORD       dwSourceAttrib            = 0;
    DWORD       dwTargetAttrib            = 0;


    TCHAR tszTempFileName[MAX_PATH+1];
    TCHAR tszTempDir[MAX_PATH+1];

    _tcscpy(tszTempDir, pFilePath->Target);

    LPTSTR ptszTemp = _tcsrchr(tszTempDir, _T('\\'));
    if (ptszTemp)
    {
        *ptszTemp = _T('\0');
    }

    GetTempFileName(tszTempDir, _T("IIS"), 0, tszTempFileName);
    DeleteFile(tszTempFileName);

    //Save file attributes so they can be restored after we are done.
    dwSourceAttrib = GetFileAttributes(pFilePath->Source);
    dwTargetAttrib = GetFileAttributes(pFilePath->Target);

    //Now set the file attributes to normal to ensure file ops succeed.
    SetFileAttributes(pFilePath->Source, FILE_ATTRIBUTE_NORMAL);
    SetFileAttributes(pFilePath->Target, FILE_ATTRIBUTE_NORMAL);

    // Try to rename the filename.dll file!
    bOK = MoveFile(pFilePath->Target, tszTempFileName);
    if (bOK) {iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Rename %1!s! to %2!s!.  Successfull.\n"), pFilePath->Target, tszTempFileName));}
    else{iisDebugOutSafeParams((LOG_TYPE_WARN, _T("Rename %1!s! to %2!s!.  Failed.\n"), pFilePath->Target, tszTempFileName));}

    bOK = CopyFile(pFilePath->Source, pFilePath->Target, FALSE);
    if (bOK) {iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Copy %1!s! to %2!s!.  Successfull.\n"), pFilePath->Source, pFilePath->Target));}
    else{iisDebugOutSafeParams((LOG_TYPE_WARN, _T("Copy %1!s! to %2!s!.  Failed, Replace on reboot.\n"), pFilePath->Source, pFilePath->Target));}
    #ifdef _CHICAGO_
        if(!DeleteFile(tszTempFileName))
        {
            TCHAR tszWinInitFile[MAX_PATH+1];
            GetWindowsDirectory(tszWinInitFile, MAX_PATH);
            AddPath(tszWinInitFile, _T("WININIT.INI"));
            WritePrivateProfileString(_T("Rename"), _T("NUL"), tszTempFileName, tszWinInitFile);
        }
    #else
        MoveFileEx(tszTempFileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
    #endif

    SetFileAttributes(pFilePath->Source, dwSourceAttrib);
    SetFileAttributes(pFilePath->Target, dwTargetAttrib);
    SetRebootFlag();
    dwReturn = TRUE;

    return dwReturn;
}


DWORD HandleFileBusyOurSelf(PFILEPATHS pFilePath)
{
    // ----------------------------
    // Why would we want to handle the file busy ourself?
    //
    // When setupapi/ocmanage handles it:
    // it will keep the old filename.dll and create a new randomename.tmp for the new file.
    // 
    // The result is that our files will link with the old filename.dll when it does
    // all of it's regsvr32 stuff -- this is bad and can produce very confusing results.
    //
    //
    // What We will want to do is:
    // 1. try to rename filename.dll to something else.  and copy over filename.dll
    // 2. if we can't do it then at least log it.
    // ----------------------------
    DWORD  dwRetVal = 0;
    TCHAR szDrive_only[_MAX_DRIVE];
    TCHAR szPath_only[_MAX_PATH];
    TCHAR szDrive_and_Path[_MAX_DRIVE + _MAX_PATH];
    TCHAR szFilename_only[_MAX_FNAME];
    TCHAR szFilename_ext_only[_MAX_EXT];
    TCHAR szFilename_and_ext[_MAX_FNAME + _MAX_EXT];

    BOOL        bOK                       = FALSE;
    BOOL        bFileFound                = FALSE;

    //Critical Setup files
    TCHAR * szFileList[] = {
_T("admexs.dll"),
_T("admwprox.dll"),
_T("admxprox.dll"),
_T("ADROT.dll"),
_T("adsiis.dll"),
_T("adsiis51.dll"),
_T("AppConf.dll"),
_T("asp.dll"),
_T("asp51.dll"),
_T("aspperf.dll"),
_T("asptxn.dll"),
_T("authfilt.dll"),
_T("axctrnm.h2"),
_T("axperf.ini"),
_T("browscap.dll"),
_T("browscap.ini"),
_T("catmeta.xms"),
_T("CertMap.ocx"),
_T("certobj.dll"),
_T("CertWiz.ocx"),
_T("Cnfgprts.ocx"),
_T("coadmin.dll"),
_T("compfilt.dll"),
_T("ContRot.dll"),
_T("convlog.exe"),
_T("counters.dll"),
_T("davcdata.exe"),
_T("exstrace.dll"),
_T("fortutil.exe"),
_T("ftpctrs.h2"),
_T("ftpctrs.ini"),
_T("ftpctrs2.dll"),
_T("ftpmib.dll"),
_T("ftpsapi2.dll"),
_T("ftpsvc2.dll"),
_T("gzip.dll"),
_T("http.sys"),
_T("httpapi.dll"),
_T("httpext.dll"),
_T("httpmb51.dll"),
_T("httpmib.dll"),
_T("httpod51.dll"),
_T("httpodbc.dll"),
_T("iis.dll"),
_T("iis.msc"),
_T("iisadmin.dll"),
_T("IIsApp.vbs"),
_T("iisback.vbs"),
_T("iiscfg.dll"),
_T("iische51.dll"),
_T("iisclex4.dll"),
_T("IIsCnfg.vbs"),
_T("iiscrmap.dll"),
_T("iisext.dll"),
_T("iisext51.dll"),
_T("iisfecnv.dll"),
_T("IIsFtp.vbs"),
_T("IIsFtpdr.vbs"),
_T("iislog.dll"),
_T("iislog51.dll"),
_T("iismap.dll"),
_T("iismui.dll"),
_T("iisperf.pmc"),
_T("iisreset.exe"),
_T("iisrstap.dll"),
_T("iisrstas.exe"),
_T("iisRtl.dll"),
_T("IIsScHlp.wsc"),
_T("iissync.exe"),
_T("iisui.dll"),
_T("iisutil.dll"),
_T("iisvdir.vbs"),
_T("iisw3adm.dll"),
_T("iisweb.vbs"),
_T("iiswmi.dll"),
_T("iiswmi.mfl"),
_T("iiswmi.mof"),
_T("inetin51.exe"),
_T("inetinfo.exe"),
_T("inetmgr.dll"),
_T("inetmgr.exe"),
_T("inetsloc.dll"),
_T("infoadmn.dll"),
_T("infocomm.dll"),
_T("infoctrs.dll"),
_T("infoctrs.h2"),
_T("infoctrs.ini"),
_T("ipm.dll"),
_T("isapips.dll"),
_T("isatq.dll"),
_T("iscomlog.dll"),
_T("iwrps.dll"),
_T("logscrpt.dll"),
_T("logtemp.sql"),
_T("logui.ocx"),
_T("lonsint.dll"),
_T("md5filt.dll"),
_T("mdsync.dll"),
_T("metada51.dll"),
_T("metadata.dll"),
_T("NEXTLINK.dll"),
_T("nsepm.dll"),
_T("PageCnt.dll"),
_T("PermChk.dll"),
_T("pwsdata.dll"),
_T("rpcref.dll"),
_T("spud.sys"),
_T("ssinc.dll"),
_T("ssinc51.dll"),
_T("sspifilt.dll"),
_T("status.dll"),
_T("staxmem.dll"),
_T("strmfilt.dll"),
_T("svcext.dll"),
_T("tools.dll"),
_T("uihelper.dll"),
_T("w3cache.dll"),
_T("w3comlog.dll"),
_T("w3core.dll"),
_T("w3ctrlps.dll"),
_T("w3ctrs.dll"),
_T("w3ctrs.h2"),
_T("w3ctrs.ini"),
_T("w3ctrs51.dll"),
_T("w3ctrs51.h2"),
_T("w3ctrs51.ini"),
_T("w3dt.dll"),
_T("w3ext.dll"),
_T("w3isapi.dll"),
_T("w3svapi.dll"),
_T("w3svc.dll"),
_T("w3tp.dll"),
_T("w3wp.exe"),
_T("wam.dll"),
_T("wam51.dll"),
_T("wamps.dll"),
_T("wamps51.dll"),
_T("wamreg.dll"),
_T("wamreg51.dll"),
_T("wamregps.dll"),
_T("clusiis4.dll"),
_T("iis.msc"),
_T("iissuba.dll"),
_T("regtrace.exe"),
NULL
    };

    // make sure we didn't get some bogus pointers
    if(pFilePath->Target == NULL || pFilePath->Source == NULL) return dwRetVal;

    // Check to make sure the file exists!
    if(!IsFileExist(pFilePath->Source)) return dwRetVal;

    _tsplitpath( pFilePath->Target, szDrive_only, szPath_only, szFilename_only, szFilename_ext_only);
    _tcscpy(szFilename_and_ext, szFilename_only);
    _tcscat(szFilename_and_ext, szFilename_ext_only);
    _tcscpy(szDrive_and_Path, szDrive_only);
    _tcscat(szDrive_and_Path, szPath_only);

    //
    // if this is a removal, then forget it, if it's locked!
    //
    if((g_pTheApp->m_eInstallMode == IM_MAINTENANCE) && (g_pTheApp->m_dwSetupMode == SETUPMODE_REMOVEALL))
    {
        return dwRetVal;
    }

    CString csInetsrvPath = g_pTheApp->m_csPathInetsrv;
    // add extra '\' chracter
    csInetsrvPath += _T('\\');

    BOOL bAbleToCopyFileAfterStopingService = FALSE;

    // Check if it's anything in the inetsrv directory.
    if (_tcsicmp(csInetsrvPath, szFilename_and_ext) == 0) {bFileFound = TRUE;}

    if (_tcsicmp(csInetsrvPath, szDrive_and_Path) == 0) 
    {
        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("Check %1!s! against filename=%2!s!.Match!\n"),csInetsrvPath,szDrive_and_Path));
        bFileFound = TRUE;
    }
    else
    {
        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("Check %1!s! against filename=%2!s!.no match.\n"),csInetsrvPath,szDrive_and_Path));
    }
    
    // loop thru our list of file which
    // we care about (since this function will get called for every single
    // ocmanage component <-- not just iiS.
    if (bFileFound != TRUE)
    {
        for(int i = 0; !bFileFound && szFileList[i]; i++)
            {if(szFilename_and_ext && _tcsicmp(szFileList[i], szFilename_and_ext) == 0) bFileFound = TRUE;}
    }

    // files on nt5 in the cab are stoed as iis_filename.
    // check to see if this file starts with iis_
    // if it does then it's a file that we care about..
    if (bFileFound != TRUE)
    {
    }

    // ah, do it for everyone.
    // bFileFound = TRUE;

    // Do we really need to replace this file???
    // If the filesize is the same, then lets just save it for reboot!
    if (_tcsicmp(_T("iissuba.dll"), szFilename_and_ext) == 0)
    {
        if (bFileFound)
        {
            DWORD dwSize1 = ReturnFileSize(pFilePath->Target);
            DWORD dwSize2 = ReturnFileSize(pFilePath->Source);
            if (dwSize1 == 0xFFFFFFFF || dwSize1 == 0xFFFFFFFF)
            {
                // unable to retrieve the size of one of those files!
            }
            else
            {
                // check if dwSize1 and dwSize2 are the same.
                if (dwSize1 == dwSize2)
                {
                    // They are the same, so we don't have to replace it till reboot! yah!
                    iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("Files %1!s! and %2!s! are the same size, not replacing..\n"),pFilePath->Target, pFilePath->Source));
                    goto HandleFileBusyOurSelf_Exit;
                }
            }
        }
    }
  
    // if this is one of the files that we care about, then
    // let's try to see who is locking it and try to stop that service or kill the process
    // and then try to move the file over!
    bAbleToCopyFileAfterStopingService = FALSE;
    if(bFileFound)
    {
        TCHAR szReturnedServiceName[MAX_PATH];

        // display which process has it locked, so we can fix it in the future.
        CStringList strList;
        LogProcessesUsingThisModule(pFilePath->Target, strList);
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos;
            CString csExeName;
            LPTSTR p;
            int nLen = 0;

            pos = strList.GetHeadPosition();
            while (pos) 
            {
                csExeName = strList.GetAt(pos);
                nLen += csExeName.GetLength() + 1;

                if (TRUE == InetIsThisExeAService(csExeName, szReturnedServiceName))
                {
                    iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("%1!s! is the %2!s! service and is locking %3!s!.  Let's stop that service.\n"),csExeName,szReturnedServiceName, pFilePath->Target));

                    /*
                    // Check if it is the netlogon service, We no don't want to stop this service for sure!!!
                    if (_tcsicmp(szReturnedServiceName, _T("NetLogon")) == 0)
                    {
                        // no we do not want to stop this service!!!
                        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("%1!s! is the %2!s! service and is locking %3!s!.  This service should not be stopped.\n"),csExeName,szReturnedServiceName, pFilePath->Target));
                        bAbleToCopyFileAfterStopingService = FALSE;
                        break;
                    }

                    if (_tcsicmp(szReturnedServiceName, _T("WinLogon")) == 0)
                    {
                        // no we do not want to stop this service!!!
                        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("%1!s! is the %2!s! service and is locking %3!s!.  This service should not be stopped.\n"),csExeName,szReturnedServiceName, pFilePath->Target));
                        bAbleToCopyFileAfterStopingService = FALSE;
                        break;
                    }
                    */

                    // check list of services that we definetly do not want to stop!
                    if (TRUE == IsThisOnNotStopList(g_pTheApp->m_hInfHandle, szReturnedServiceName, TRUE))
                    {
                        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("%1!s! is the %2!s! service and is locking %3!s!.  This service should not be stopped.\n"),csExeName,szReturnedServiceName, pFilePath->Target));
                    }
                    else
                    {
                        // add this service to the list of 
                        // services we need to restart after setup is done!!
                        ServicesRestartList_Add(szReturnedServiceName);

                        // net stop it
                        InetStopService(szReturnedServiceName);

                        // if the service is stopped, then it should be okay if we kill it!
                        KillProcess_Wrap(csExeName);

                        // now try to copy over the file!
                        if (CopyFile(pFilePath->Source, pFilePath->Target, FALSE))
                        {
                            bAbleToCopyFileAfterStopingService = TRUE;
                            break;
                        }
                    }

                    // otherwise go on to the next .exe file
                }
                else
                {
                    // This .exe file is not a Service....
                    // Should we kill it???????

                    // check list of services/processes that we definetly do not want to stop!
                    if (TRUE == IsThisOnNotStopList(g_pTheApp->m_hInfHandle, csExeName, FALSE))
                    {
                        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("%1!s! is locking it. This process should not be killed\n"),csExeName));
                    }
                    else
                    {
                        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("%1!s! is locking it.  Let's kill that process.\n"),csExeName));
                        if (KillProcess_Wrap(csExeName) == 0)
                        {
                            // if we were able to kill the process.
                            // then let's try to copy over the file.
                            // now try to copy over the file!
                            if (CopyFile(pFilePath->Source, pFilePath->Target, FALSE))
                            {
                                bAbleToCopyFileAfterStopingService = TRUE;
                                break;
                            }
                        }
                    }
                }
                strList.GetNext(pos);
            }
        }

    }

    // if this is one of the files that we care about then, let's do the move
    if (bAbleToCopyFileAfterStopingService == TRUE)
    {
        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("HandleFileBusyOurSelf:critical setup file %1!s!, was successfully copied over after stopping services or stopping processes which were locking it.\n"), pFilePath->Target));
    }
    else
    {
        if(bFileFound)
        {
            // make sure the services we know about are stopped.
            StopAllServicesRegardless(FALSE); 

            TryToSlipInFile(pFilePath);
        }
        else
        {
            iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("HandleFileBusyOurSelf:%1!s! busy, but not one of our files, so ignore.\n"), pFilePath->Target));
        }
    }

HandleFileBusyOurSelf_Exit:
    return dwRetVal;
}


DWORD GetLastSectionToBeCalled(void)
{
    DWORD dwReturn = ERROR_SUCCESS;

    // Open up the .inf file and return the last section which will get called...
    // [Optional Components]
    // iis
    // iis_common
    // iis_inetmgr
    // iis_www
    // iis_doc
    // iis_htmla
    // iis_ftp  <-------
    //
    LPTSTR  szLine = NULL;
    DWORD   dwRequiredSize;
    BOOL    b = FALSE;
    INFCONTEXT Context;

    // go to the beginning of the section in the INF file
    b = SetupFindFirstLine_Wrapped(g_pTheApp->m_hInfHandle, OCM_OptionalComponents_Section, NULL, &Context);
    if (!b)
        {
        dwReturn = E_FAIL;
        goto GetLastSectionToBeCalled_Exit;
        }

    // loop through the items in the section.
    while (b) 
    {
        // get the size of the memory we need for this
        b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);

        // prepare the buffer to receive the line
        szLine = (LPTSTR)GlobalAlloc( GPTR, dwRequiredSize * sizeof(TCHAR) );
        if ( !szLine )
            {
            goto GetLastSectionToBeCalled_Exit;
            }
        
        // get the line from the inf file1
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL) == FALSE)
            {
            goto GetLastSectionToBeCalled_Exit;
            }

        // overwrite our string
        _tcscpy(g_szLastSectionToGetCalled, szLine);

        // find the next line in the section. If there is no next line it should return false
        b = SetupFindNextLine(&Context, &Context);

        // free the temporary buffer
        GlobalFree( szLine );
        szLine = NULL;
    }
    if (szLine) {GlobalFree(szLine);szLine=NULL;}
    
GetLastSectionToBeCalled_Exit:
    return dwReturn;
}


// should create a backup of the metabase on remove all....
#define AfterRemoveAll_SaveMetabase_log _T("AfterRemoveAll_SaveMetabase")
int AfterRemoveAll_SaveMetabase(void)
{
    iisDebugOut_Start(AfterRemoveAll_SaveMetabase_log);
    int iReturn = TRUE;
    int iFileExist = FALSE;
    CString csMetabaseFile;

    csMetabaseFile = g_pTheApp->m_csPathInetsrv + _T("\\metabase.xml");

    switch (g_pTheApp->m_eInstallMode) 
    {
        case IM_MAINTENANCE:
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("%s.End.Maintenance.\n"),AfterRemoveAll_SaveMetabase_log));
                if ( g_pTheApp->m_dwSetupMode == SETUPMODE_ADDREMOVE || g_pTheApp->m_dwSetupMode == SETUPMODE_REMOVEALL)
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("%s.End.Maintenance.addremoveorremoveall\n"),AfterRemoveAll_SaveMetabase_log));
                    // Check if we removed iis_core!!!
                    ACTION_TYPE atCORE = GetIISCoreAction(FALSE);
                    if (atCORE == AT_REMOVE)
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("%s.End.removing Core.\n"),AfterRemoveAll_SaveMetabase_log));
                        // Back up the file!
                        if (IsFileExist(csMetabaseFile))
                        {
                            CString csBackupFile;

				            SYSTEMTIME  SystemTime;
				            GetLocalTime(&SystemTime);
				            TCHAR szDatedFileName[50];

                            csBackupFile = g_pTheApp->m_csPathInetsrv + _T("\\MetaBack");
                            CreateDirectory(csBackupFile, NULL);

				            _stprintf(szDatedFileName,_T("\\MetaBack\\Metabase.%d%d%d"),SystemTime.wYear,SystemTime.wMonth, SystemTime.wDay);

                            csBackupFile = g_pTheApp->m_csPathInetsrv + szDatedFileName;

                            // Get a new filename
                            csBackupFile = ReturnUniqueFileName(csBackupFile);
                            if (!IsFileExist(csBackupFile))
                            {
                                // backup the current metabase.bin to Metabase.bin.bak#
                                iisDebugOut((LOG_TYPE_TRACE, _T("backup metabase.bin to %s\n"), csBackupFile));
                                InetCopyFile(csMetabaseFile, csBackupFile);
                            }
                        }
                    }
                }
                break;
            }

        default:
            {break;}
    }

    iisDebugOut_End(AfterRemoveAll_SaveMetabase_log);
    return iReturn;
}


int CheckIfWeNeedToMoveMetabaseBin(void)
{
    int iReturn = TRUE;
    TCHAR szTempDir1[_MAX_PATH];
    TCHAR szTempDir2[_MAX_PATH];
    BOOL bOK = FALSE;
    DWORD dwSourceAttrib = 0;

    // check if the old inetsrv dir is different from the new inetsrv directory.
    // if it's different then we need to move all the old inetsrv files to the new directory

    // no. we just need to move the metabase.bin file.
    // all those other files should get deleted in the iis.inf file.

    if (!g_pTheApp->m_fMoveInetsrv)
        {goto CheckIfWeNeedToMoveMetabaseBin_Exit;}

    _tcscpy(szTempDir1, g_pTheApp->m_csPathOldInetsrv);
    _tcscpy(szTempDir2, g_pTheApp->m_csPathInetsrv);
    AddPath(szTempDir1, _T("Metabase.bin"));
    AddPath(szTempDir2, _T("Metabase.bin"));

    // Check if the old metabase.bin even exists first...
    if (!IsFileExist(szTempDir1))
        {goto CheckIfWeNeedToMoveMetabaseBin_Exit;}

    // Check if there is a metabase.bin already in the new place
    if (IsFileExist(szTempDir2))
    {
        iisDebugOut((LOG_TYPE_WARN, _T("CheckIfWeNeedToMoveMetabaseBin:Cannot copy %s to %s because already exists. WARNING.\n"), szTempDir1, szTempDir2));
        goto CheckIfWeNeedToMoveMetabaseBin_Exit;
    }

    //
    // Try to move over the entire dirs...
    //
    // Try to rename the system\inetsrv to system32\inetsrv
    if (TRUE == MoveFileEx( g_pTheApp->m_csPathOldInetsrv, g_pTheApp->m_csPathInetsrv, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH ))
    {
        goto CheckIfWeNeedToMoveMetabaseBin_Exit;
    }

    // otherwise, we were not able to move the system\inetsrv dir to system32\inetsrv....
    // let's see if we can do another type of dirmove.

    //Save file attributes so they can be restored after we are done.
    dwSourceAttrib = GetFileAttributes(szTempDir1);

    //Now set the file attributes to normal to ensure file ops succeed.
    SetFileAttributes(szTempDir1, FILE_ATTRIBUTE_NORMAL);

    bOK = CopyFile(szTempDir1, szTempDir2, FALSE);
    if (bOK) {iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("CheckIfWeNeedToMoveMetabaseBin: Copy %1!s! to %2!s!.  Successfull.\n"), szTempDir1, szTempDir2));}
    else{iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("CheckIfWeNeedToMoveMetabaseBin: Copy %1!s! to %2!s!.  FAILED.  Metabase.bin will not be upgraded.\n"), szTempDir1, szTempDir2));}

    if (bOK) 
    {
        // remove the old one
        DeleteFile(szTempDir1);
        // set the file attributes back to what it was.
        SetFileAttributes(szTempDir2, dwSourceAttrib);
    }
    else
    {
        // set the file attributes back to what it was.
        SetFileAttributes(szTempDir1, dwSourceAttrib);

        // set return flag to say we failed to move over old files.
        // upgrade will not do an upgrade.
        iReturn = FALSE;
    }

CheckIfWeNeedToMoveMetabaseBin_Exit:
    return iReturn;
}   


//
// function will copy all the old c:\windows\system\inetsrv files
//
// over to c:\windows\system32\inetsrv
//
// keep a list of the files which we're copied and
// then after the files are copied, delete the files in the old location.
int MigrateAllWin95Files(void)
{
    int iReturn = TRUE;
    TCHAR szTempSysDir1[_MAX_PATH];
    TCHAR szTempSysDir2[_MAX_PATH];
    TCHAR szTempSysDir3[_MAX_PATH];

    //
    // Check if the old metabase.bin even exists first...
    //
    GimmieOriginalWin95MetabaseBin(szTempSysDir1);

    GetSystemDirectory( szTempSysDir2, _MAX_PATH);
    AddPath(szTempSysDir2, _T("inetsrv\\Metabase.bin"));
    if (!IsFileExist(szTempSysDir1))
    {
        // Check if there is one in the new location...
        if (!IsFileExist(szTempSysDir2))
        {
            // set return flag to say we failed to move over old files.
            // upgrade will not do an upgrade.
            iReturn = FALSE;
            goto MigrateAllWin95Files_Exit;
        }
        else
        {
            iReturn = TRUE;
            goto MigrateAllWin95Files_Exit;
        }
    }

    //
    // Try to move over the entire dirs...
    //
    // cut of the filename and just get the path
    ReturnFilePathOnly(szTempSysDir1,szTempSysDir3);

    GetSystemDirectory( szTempSysDir2, _MAX_PATH);
    AddPath(szTempSysDir2, _T("inetsrv"));
    // Try to rename the system\inetsrv to system32\inetsrv
    RemoveDirectory( szTempSysDir2 );   // Delete the destination directory first, so the move will work.
    if (TRUE == MoveFileEx( szTempSysDir3, szTempSysDir2, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH ))
        {goto MigrateAllWin95Files_Exit;}
    
    // otherwise, we were not able to move the system\inetsrv dir to system32\inetsrv....
    // let's see if we can do another type of dirmove.

    // looks like all the other types of copies failed...
    // let's just try to move the metabase.bin file.
    GetWindowsDirectory( szTempSysDir1, _MAX_PATH);
    AddPath(szTempSysDir1, _T("System\\inetsrv\\Metabase.bin"));

    GetSystemDirectory( szTempSysDir2, _MAX_PATH);
    AddPath(szTempSysDir2, _T("inetsrv\\Metabase.bin"));

    // then let's copy it over, if we don't already have one in system32\inetsrv
    if (IsFileExist(szTempSysDir2))
    {
        iisDebugOut((LOG_TYPE_WARN, _T("Cannot copy %s to %s because already exists. WARNING.\n"), szTempSysDir1, szTempSysDir2));
    }
    else
    {
        BOOL        bOK                       = FALSE;
        DWORD       dwSourceAttrib            = 0;

        //Save file attributes so they can be restored after we are done.
        dwSourceAttrib = GetFileAttributes(szTempSysDir1);

        //Now set the file attributes to normal to ensure file ops succeed.
        SetFileAttributes(szTempSysDir1, FILE_ATTRIBUTE_NORMAL);

        bOK = CopyFile(szTempSysDir1, szTempSysDir2, FALSE);
        if (bOK) {iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("Copy %1!s! to %2!s!.  Successfull.\n"), szTempSysDir1, szTempSysDir2));}
        else{iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("Copy %1!s! to %2!s!.  FAILED.  Metabase.bin will not be upgraded.\n"), szTempSysDir1, szTempSysDir2));}

        if (bOK) 
        {
            // remove the old one
            DeleteFile(szTempSysDir1);
            // set the file attributes back to what it was.
            SetFileAttributes(szTempSysDir2, dwSourceAttrib);
        }
        else
        {
            // set the file attributes back to what it was.
            SetFileAttributes(szTempSysDir1, dwSourceAttrib);

            // set return flag to say we failed to move over old files.
            // upgrade will not do an upgrade.
            iReturn = FALSE;
        }

    }

MigrateAllWin95Files_Exit:
    return iReturn;
}


int GimmieOriginalWin95MetabaseBin(TCHAR * szReturnedFilePath)
{
    int iReturn = FALSE;
    INFCONTEXT Context;
    int iFindSection = FALSE;
    TCHAR szWin95MetabaseFile[_MAX_PATH] = _T("");

    iFindSection = SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, _T("InternetServer"), _T("Win95MigrateDllMetabaseOrg"), &Context);
    if (iFindSection) 
    {
        SetupGetStringField(&Context, 1, szWin95MetabaseFile, _MAX_PATH, NULL);
        iisDebugOut((LOG_TYPE_TRACE, _T("[InternetServer].Win95MigrateDllMetabaseOrg=%s.\n"), szWin95MetabaseFile));
        // if there is an entry, check if the file exists...
        if (IsFileExist(szWin95MetabaseFile))
        {
            _tcscpy(szReturnedFilePath, szWin95MetabaseFile);
            iReturn = TRUE;
        }
    }

    if (FALSE == iReturn)
    {
        // we were not able to get the metabase.dll from the answer file.
        // assume that it's in %windir%\system\inetsrv\metabase.bin
        TCHAR szTempSysDir1[_MAX_PATH];
        // Check if the old metabase.bin even exists first...
        GetWindowsDirectory(szTempSysDir1, _MAX_PATH);
        AddPath(szTempSysDir1, _T("System\\inetsrv\\Metabase.bin"));
        _tcscpy(szReturnedFilePath, szTempSysDir1);
        if (IsFileExist(szTempSysDir1))
        {
            iReturn = TRUE;
        }
        else
        {
            iReturn = FALSE;
        }
    }
    return iReturn;
}


int HandleWin95MigrateDll(void)
{
    int iReturn = TRUE;
    int iTempFlag = 0;
    int iFindSection = FALSE;
    TCHAR szMigrateFileName[_MAX_PATH] = _T("");
    INFCONTEXT Context;

    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("Win95Upgrate:"));

    if (g_pTheApp->m_hUnattendFile == INVALID_HANDLE_VALUE || g_pTheApp->m_hUnattendFile == NULL)
    {
        goto HandleWin95MigrateDll_Exit;
    }

    if (g_pTheApp->m_csUnattendFile)
    {
        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("AnswerFile=%1!s!.\n"), g_pTheApp->m_csUnattendFile));
    }
    else
    {
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("AnswerFile=(not found).exiting.\n")));
        goto HandleWin95MigrateDll_Exit;
    }

    // Look for our entry
    //iisDebugOut((LOG_TYPE_TRACE, _T("HandleWin95MigrateDll:looking for entry [InternetServer]:Win95MigrateDll.\n")));
    iFindSection = SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, _T("InternetServer"), _T("Win95MigrateDll"), &Context);
    if (iFindSection) 
    {
        SetupGetStringField(&Context, 1, szMigrateFileName, _MAX_PATH, NULL);
        iisDebugOut((LOG_TYPE_TRACE, _T("[InternetServer].Win95MigrateDll=%s.\n"), szMigrateFileName));
        // if there is an entry
        // check if the file exists...
        if (!IsFileExist(szMigrateFileName))
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("[InternetServer].Win95MigrateDll=%s. Does not exist!!!!! FAILURE.\n"), szMigrateFileName));
            iReturn = FALSE;
            goto HandleWin95MigrateDll_Exit;
        }

        // okay, the file exists.
        // lets pass it off to setupapi.
        //iisDebugOut((LOG_TYPE_TRACE, _T("%s\n"), szMigrateFileName));
        iTempFlag = InstallInfSection(INVALID_HANDLE_VALUE,szMigrateFileName,_T("DefaultInstall"));
        if (iTempFlag != TRUE)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("FAILED to install DefaultInstall Section.\n"), szMigrateFileName));
            goto HandleWin95MigrateDll_Exit;
        }

        // During the win95 side of migrate.dll
        // the metabase.bin file gets a bunch of stuff removed from it.
        // then that metabase.bin file gets renamed to another file.
        // then the original metabase.bin is put back -- just in case the user cancelled upgrading to win95 (to ensure that they're win95/98 pws still works the metabase.bin has to be kool)
        // so what we need to do here is:
        // 1.save the old metabase.bin to something in case we mess things up.
        // 2.find out what the newlyhacked metabase.bin file is called by looking for the entry in the answerfile
        // 3.rename whatever that filename is to metabase.bin
        GetTheRightWin95MetabaseFile();
        
        // set the flag to say that we did call win95 migration dll
        if (TRUE == MigrateAllWin95Files())
        {
            // only set this flag if
            // we can copy over the existing metabase.bin file!
            g_pTheApp->m_bWin95Migration = TRUE;
        }

    iReturn = iTempFlag;
    }

HandleWin95MigrateDll_Exit:
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
    return iReturn;
}


int GetTheRightWin95MetabaseFile(void)
{
    int iReturn = TRUE;
    int iFindSection = FALSE;
    INFCONTEXT Context;
    TCHAR szOriginalMetabaseBin[_MAX_PATH];

    // Get the full path to the original metabase.bin file
    GimmieOriginalWin95MetabaseBin(szOriginalMetabaseBin);

    iFindSection = FALSE;
    iFindSection = SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, _T("InternetServer"), _T("Win95MigrateDllMetabaseNew"), &Context);
    if (iFindSection) 
    {
        TCHAR szWin95FixedMetabaseFile[_MAX_PATH] = _T("");
        SetupGetStringField(&Context, 1, szWin95FixedMetabaseFile, _MAX_PATH, NULL);
        iisDebugOut((LOG_TYPE_TRACE, _T("[InternetServer].Win95MigrateDllMetabaseNew=%s.\n"), szWin95FixedMetabaseFile));
        // if there is an entry, check if the file exists...
        if (IsFileExist(szWin95FixedMetabaseFile))
        {
            // File is there.
            // 1. save the old metabase.bin just in case.
            TCHAR szTempDir[MAX_PATH+1];
            TCHAR szTempFileName[MAX_PATH+1];

            // delete the original metabase.bin file
            if (DeleteFile(szOriginalMetabaseBin))
            {
                // copy in the fixed one.
                if (0 == CopyFile(szWin95FixedMetabaseFile, szOriginalMetabaseBin, FALSE))
                {
                    // unable to copy it, try to move it
                    // Try to rename the system\inetsrv to system32\inetsrv
                    if (FALSE == MoveFileEx( szWin95FixedMetabaseFile, szOriginalMetabaseBin, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH ))
                        {
                        // do nothing i guess were hosed.
                        // setup won't upgrade and will only do a clean install
                        iReturn = FALSE;
                        }
                }
            }
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("[InternetServer].Win95MigrateDllMetabaseNew=%s. Does not exist!!!!! FAILURE.\n"), szWin95FixedMetabaseFile));
        }
    }

    return iReturn;
}


DWORD RemoveComponent(IN LPCTSTR SubcomponentId, int iThePartToDo)
{
    TCHAR szTheSectionToDo[100];

    int iWeAreGoingToRemoveSomething = FALSE;
    DWORD dwReturn = NO_ERROR;
    ACTION_TYPE atTheComponent;

    // Make sure there are not MyMessageBox popups!
    //int iSaveOld_AllowMessageBoxPopups = g_pTheApp->m_bAllowMessageBoxPopups;
    // g_pTheApp->m_bAllowMessageBoxPopups = FALSE;
	if (g_pTheApp->m_eInstallMode == IM_UPGRADE) goto RemoveComponent_Exit;

    // Check if we are going to remove something...
    atTheComponent = GetSubcompAction(SubcomponentId, FALSE);
    if (_tcsicmp(SubcomponentId, STRING_iis_core) == 0) 
    {
        atTheComponent = GetIISCoreAction(TRUE);;
    }
    if (atTheComponent == AT_REMOVE)
        {iWeAreGoingToRemoveSomething = TRUE;}

    if (iThePartToDo == 1)
    {
        // Check if we are supposed to do nothing.
        if (atTheComponent == AT_DO_NOTHING)
        {
            // ok, if we're supposed to do nothing
            // and the files are not supposed to be there
            // then just make sure they are not there by removing them!!!!!
            BOOL CurrentState,OriginalState;
            OriginalState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL);
            CurrentState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_CURRENT);

            // if we think that the original state is uninstalled
            // and the current state is not installed, then make sure that the files do not exist by
            // removing the files!
            if (_tcsicmp(SubcomponentId, STRING_iis_core) == 0)
            {
                // since we can't check the state of iis_core, then check the states of iis_www and iis_ftp
                // if any one of these remains installed, then don't remove it.
                int iSomethingIsOn = FALSE;
                
                CurrentState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,STRING_iis_www,OCSELSTATETYPE_CURRENT);
                if (CurrentState == 1) {iSomethingIsOn = TRUE;}
                CurrentState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,STRING_iis_ftp,OCSELSTATETYPE_CURRENT);
                if (CurrentState == 1) {iSomethingIsOn = TRUE;}

                iWeAreGoingToRemoveSomething = TRUE;
                if (iSomethingIsOn)
                {
                    iWeAreGoingToRemoveSomething = FALSE;
                }
            }
            else
            {
                if (OriginalState == 0 && CurrentState == 0)
                {
                    // but don't do it for the iis_doc files because there are too many files in that one.
                    if ((_tcsicmp(SubcomponentId, STRING_iis_common) == 0) ||
                        (_tcsicmp(SubcomponentId, STRING_iis_www) == 0) ||
                        (_tcsicmp(SubcomponentId, STRING_iis_ftp) == 0))
                    {
                        iWeAreGoingToRemoveSomething = TRUE;
                    }
                }
            }
        }
    }

    if (iThePartToDo == 2)
    {
        // Check if we are supposed to do nothing.
        if (atTheComponent == AT_DO_NOTHING)
        {
            if (_tcsicmp(SubcomponentId, _T("iis")) == 0)
            {
                BOOL CurrentState,OriginalState;
                OriginalState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_ORIGINAL);
                CurrentState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,SubcomponentId,OCSELSTATETYPE_CURRENT);

                // if we think that the original state is uninstalled
                // and the current state is not installed, then make sure that the files do not exist by
                // removing the files!
                if (OriginalState == 0 && CurrentState == 0)
                {
                    // but don't do it for the iis_doc files because there are too many files in that one.
                    // Special: if this is removing the iis section [all of iis] then, make sure to 
                    // clean everything up.
                    iWeAreGoingToRemoveSomething = TRUE;
                }
                else
                {
                    // check if every component is off
                    if (FALSE == AtLeastOneComponentIsTurnedOn(g_pTheApp->m_hInfHandle))
                    {
                        iWeAreGoingToRemoveSomething = TRUE;
                    }
                }
            }
        }
    }

    // Do the actual removing
    if (iWeAreGoingToRemoveSomething)
    {
        if (iThePartToDo == 1)
        {
            //
            // Queue the deletion of the files
            //
            ProgressBarTextStack_Set(IDS_IIS_ALL_REMOVE);
            _stprintf(szTheSectionToDo,_T("OC_QUEUE_FILE_OPS_remove.%s"),SubcomponentId);
            if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, (CString) szTheSectionToDo))
            {
              ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);
              dwReturn = g_GlobalFileQueueHandle_ReturnError ? NO_ERROR : GetLastError();
            }
            else
            {
              dwReturn = NO_ERROR;
            }
            ProgressBarTextStack_Pop();
        }
        else
        {
            ProgressBarTextStack_Set(IDS_IIS_ALL_REMOVE);

            _stprintf(g_MyLogFile.m_szLogPreLineInfo2,_T("Unreg %s:"),SubcomponentId);

            _stprintf(szTheSectionToDo,_T("OC_ABOUT_TO_COMMIT_QUEUE_remove.%s"),SubcomponentId);
            ProcessSection(g_pTheApp->m_hInfHandle, szTheSectionToDo);
            _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
            ProgressBarTextStack_Pop();
        }
    }
   
RemoveComponent_Exit:
    // Turn popups back on.
    //g_pTheApp->m_bAllowMessageBoxPopups = iSaveOld_AllowMessageBoxPopups;
    return dwReturn;
}

int AtLeastOneComponentIsTurnedOn(IN HINF hInfFileHandle)
{
    int iSomeIsOn = FALSE;
    TCHAR szTempSubComp[50];
    BOOL CurrentState,OriginalState;

    CStringList strList;
    CString csTheSection = OCM_OptionalComponents_Section;

    if (GetSectionNameToDo(hInfFileHandle, csTheSection))
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(hInfFileHandle, strList, csTheSection))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos;
            CString csEntry;
            pos = strList.GetHeadPosition();
            while (pos) 
            {
                csEntry = _T("");
                csEntry = strList.GetAt(pos);

                // We now have the entry, send it to the function.
                OriginalState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,csEntry,OCSELSTATETYPE_ORIGINAL);
                CurrentState = gHelperRoutines.QuerySelectionState(gHelperRoutines.OcManagerContext,csEntry,OCSELSTATETYPE_CURRENT);
                if (CurrentState == 1) {iSomeIsOn = TRUE;}

                // Get the next one.
                strList.GetNext(pos);
            }
        }
    }
    }
 
    return iSomeIsOn;
}


void AdvanceProgressBarTickGauge(int iTicks)
{
    // multiply the amount of ticks by our tick multiple
    iTicks = g_GlobalTickValue * iTicks;

    for(int i = 0; i < iTicks; i++)
    {
        gHelperRoutines.TickGauge(gHelperRoutines.OcManagerContext);
        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("--- TickGauge ---\n")));
    }
    g_GlobalTotalTickGaugeCount=g_GlobalTotalTickGaugeCount+iTicks;

    if (_tcsicmp(g_szCurrentSubComponent, STRING_iis_common) == 0) 
        {g_GlobalTickTotal_iis_common = g_GlobalTickTotal_iis_common + g_GlobalTotalTickGaugeCount;}
    if (_tcsicmp(g_szCurrentSubComponent, STRING_iis_inetmgr) == 0) 
        {g_GlobalTickTotal_iis_inetmgr = g_GlobalTickTotal_iis_inetmgr + g_GlobalTotalTickGaugeCount;}
    if (_tcsicmp(g_szCurrentSubComponent, STRING_iis_www) == 0) 
        {g_GlobalTickTotal_iis_www = g_GlobalTickTotal_iis_www + g_GlobalTotalTickGaugeCount;}
    if (_tcsicmp(g_szCurrentSubComponent, STRING_iis_pwmgr) == 0) 
        {g_GlobalTickTotal_iis_pwmgr = g_GlobalTickTotal_iis_pwmgr + g_GlobalTotalTickGaugeCount;}
    if (_tcsicmp(g_szCurrentSubComponent, STRING_iis_doc) == 0) 
        {g_GlobalTickTotal_iis_doc = g_GlobalTickTotal_iis_doc + g_GlobalTotalTickGaugeCount;}
    if (_tcsicmp(g_szCurrentSubComponent, STRING_iis_htmla) == 0) 
        {g_GlobalTickTotal_iis_htmla = g_GlobalTickTotal_iis_htmla + g_GlobalTotalTickGaugeCount;}
    if (_tcsicmp(g_szCurrentSubComponent, STRING_iis_ftp) == 0) 
        {g_GlobalTickTotal_iis_ftp = g_GlobalTickTotal_iis_ftp + g_GlobalTotalTickGaugeCount;}
}


void SumUpProgressBarTickGauge(IN LPCTSTR SubcomponentId)
{
    int iTicksYetToDo = 0;
    int iTicksSupposedToDo = 0;

    if (SubcomponentId)
    {
        ACTION_TYPE atComp = GetSubcompAction(SubcomponentId, FALSE);

        // Set the Tick Total value for iis_common (which includes iis_core)
        if (_tcsicmp(SubcomponentId, STRING_iis_common) == 0)
        {
            // Get the operations for Core instead since this is bigger.
            ACTION_TYPE atCORE = GetIISCoreAction(FALSE);
            if (atCORE == AT_REMOVE) 
                {iTicksSupposedToDo = GetTotalTickGaugeFromINF(SubcomponentId, FALSE);}
            else
                {iTicksSupposedToDo = GetTotalTickGaugeFromINF(SubcomponentId, TRUE);}
            if (atCORE == AT_DO_NOTHING) 
                {iTicksSupposedToDo = 0;}
        }
        else
        {
            if (atComp == AT_REMOVE)
                {iTicksSupposedToDo = GetTotalTickGaugeFromINF(SubcomponentId, FALSE);}
            else
                {iTicksSupposedToDo = GetTotalTickGaugeFromINF(SubcomponentId, TRUE);}
            if (atComp == AT_DO_NOTHING) 
                {iTicksSupposedToDo = 0;}
        }

        // 1. Take the amount that we're supposed to be finsihed with from the inf.
        // 2. take the amount that we are actually done with.
        // fill up the difference

        if (iTicksSupposedToDo > g_GlobalTotalTickGaugeCount)
        {
            int iTempVal = 0;
            if (_tcsicmp(SubcomponentId, STRING_iis_common) == 0) 
                {iTempVal = g_GlobalTickTotal_iis_common;}
            if (_tcsicmp(SubcomponentId, STRING_iis_inetmgr) == 0) 
                {iTempVal = g_GlobalTickTotal_iis_inetmgr;}
            if (_tcsicmp(SubcomponentId, STRING_iis_www) == 0) 
                {iTempVal = g_GlobalTickTotal_iis_www;}
            if (_tcsicmp(SubcomponentId, STRING_iis_pwmgr) == 0) 
                {iTempVal = g_GlobalTickTotal_iis_pwmgr;}
            if (_tcsicmp(SubcomponentId, STRING_iis_doc) == 0) 
                {iTempVal = g_GlobalTickTotal_iis_doc;}
            if (_tcsicmp(SubcomponentId, STRING_iis_htmla) == 0) 
                {iTempVal = g_GlobalTickTotal_iis_htmla;}
            if (_tcsicmp(SubcomponentId, STRING_iis_ftp) == 0) 
                {iTempVal = g_GlobalTickTotal_iis_ftp;}
            
            //iTicksYetToDo = iTicksSupposedToDo - g_GlobalTotalTickGaugeCount;
            iTicksYetToDo = iTicksSupposedToDo - iTempVal;
            
            // divide by the tick multiple.

            // multiply the amount of ticks by our tick multiple
            if (iTicksYetToDo > 0)
            {
                iTicksYetToDo = iTicksYetToDo / g_GlobalTickValue;
            }

            AdvanceProgressBarTickGauge(iTicksYetToDo);
        }
    }

    return;
}


// ===================================================================================================================
// service1  service2
//
// Upg       Upg
// Fresh     Fresh
// Remove    Remove
// Noop-Yes  Noop-Yes   Yes means ST_INSTALLED, No means ST_UNINSTALLED
// Noop-No   Noop-No
//                     Noop_Yes | Noop_No           | Remove   | Install_Fresh | Install_Upgrade | Install_Reinstall
//                   ------------------------------------------------------------------------------------------------
// Noop_Yes          | Noop_Yes | Noop_Yes          | Noop_Yes | Noop_Yes      | x               | x
// Noop_No           | Noop_Yes | Noop_No*          | Remove*  | Install_Fresh | Install_Upgrade | Install_Reinstall
// Remove            | Noop_Yes | Remove*           | Remove*  | Noop_Yes      | x               | x
// Install_Fresh     | Noop_Yes | Install_Fresh     | Noop_Yes | Install_Fresh | x               | x
// Install_Upgrade   | x        | Install_Upgrade   | x        | x             | Install_Upgrade | x
// Install_Reinstall | x        | Install_Reinstall | x        | x             | x               | Install_Reinstall
//
// *: if it is still needed by other groups (e.g., SMTP), then we shouldn't remove it
// ===================================================================================================================
ACTION_TYPE GetIISCoreAction(int iLogResult)
{
    ACTION_TYPE atCORE = AT_DO_NOTHING;
    ACTION_TYPE atFTP = GetSubcompAction(STRING_iis_ftp, iLogResult);
    ACTION_TYPE atWWW = GetSubcompAction(STRING_iis_www, iLogResult);
    STATUS_TYPE stFTP = GetSubcompInitStatus(STRING_iis_ftp);
    STATUS_TYPE stWWW = GetSubcompInitStatus(STRING_iis_www);

    do
    {
        if ((atFTP == AT_DO_NOTHING && stFTP == ST_INSTALLED) || (atWWW == AT_DO_NOTHING && stWWW == ST_INSTALLED) )
        {
            atCORE = AT_DO_NOTHING;
            break;
        }

        if (atFTP == AT_INSTALL_UPGRADE || atWWW == AT_INSTALL_UPGRADE)
        {
            atCORE = AT_INSTALL_UPGRADE;
            break;
        }

        if ((atFTP == AT_INSTALL_FRESH && atWWW == AT_INSTALL_FRESH) || (atFTP == AT_INSTALL_FRESH && atWWW == AT_DO_NOTHING && stWWW == ST_UNINSTALLED) || (atFTP == AT_DO_NOTHING && stFTP == ST_UNINSTALLED && atWWW == AT_INSTALL_FRESH) )
        {
            atCORE = AT_INSTALL_FRESH;
            break;
        }

        if ((atFTP == AT_REMOVE && atWWW == AT_DO_NOTHING && stWWW == ST_UNINSTALLED) || (atFTP == AT_DO_NOTHING && stFTP == ST_UNINSTALLED && atWWW == AT_REMOVE) )
        {
            atCORE = AT_REMOVE;
            break;
        }

        if ( atFTP == AT_REMOVE && atWWW == AT_REMOVE )
        {
            atCORE = AT_REMOVE;
            break;
        }

        if ( atFTP == AT_INSTALL_REINSTALL || atWWW == AT_INSTALL_REINSTALL )
        {
            atCORE = AT_INSTALL_REINSTALL;
            break;
        }

        atCORE = AT_DO_NOTHING;

    } while (0);

    if (iLogResult)
    {
        DebugOutAction(STRING_iis_core, atCORE);
    }

    return (atCORE);
}

void DisplayActionsForAllOurComponents(IN HINF hInfFileHandle)
{
    CStringList strList;
    ACTION_TYPE atTheComponent; 

    CString csTheSection = OCM_OptionalComponents_Section;

    if (GetSectionNameToDo(hInfFileHandle, csTheSection))
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(hInfFileHandle, strList, csTheSection))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos;
            CString csEntry;
            pos = strList.GetHeadPosition();
            while (pos) 
            {
                csEntry = _T("");
                csEntry = strList.GetAt(pos);

                // We now have the entry, send it to the function.
                atTheComponent = GetSubcompAction(csEntry, TRUE);

                // Get the next one.
                strList.GetNext(pos);
            }
        }
    }
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\elem.h ===
#ifndef _ELEM_H_
#define _ELEM_H_

class CElem : public CObject
{
public:
    CElem();
    ~CElem();

    HKEY m_hKey;
    int m_index;
    CString m_ip;
    CString m_name;
    CString m_value;

    BOOL OpenReg(LPCTSTR szSubKey);
    void CloseReg();
    BOOL GetNext();
    void ReadRegVRoots(LPCTSTR szSubKey, CMapStringToOb *pMap);
    void Add(CMapStringToOb *pMap);
};

#endif // _ELEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\initapp.cpp ===
#include "stdafx.h"
#include <ole2.h>
#include "ocmanage.h"
#include "log.h"
#include <winnetwk.h>
#include <setupapi.h>
#ifdef _CHICAGO_
    #include <winsock2.h>
#endif

const TCHAR REG_PRODUCTOPTIONS[] = _T("System\\CurrentControlSet\\Control\\ProductOptions");
const TCHAR UNATTEND_FILE_SECTION[] = _T("InternetServer");
const TCHAR REG_SETUP_UNINSTALLINFO[] = _T("UninstallInfo");

extern int g_GlobalDebugLevelFlag;
extern int g_GlobalDebugLevelFlag_WasSetByUnattendFile;
extern int g_CheckIfMetabaseValueWasWritten;
extern MyLogFile g_MyLogFile;

void Check_For_DebugServiceFlag(void)
{
    INFCONTEXT Context;
    TCHAR szSectionName[_MAX_PATH];
    TCHAR szEntry[_MAX_PATH] = _T("");

    // Do this only if unattended install
    if (!g_pTheApp->m_fUnattended) {return;}

    // The section name to look for in the unattended file
    _tcscpy(szSectionName, UNATTEND_FILE_SECTION);

    //
    // Look for our special setting
    //
    *szEntry = NULL;
    if ( SetupFindFirstLine(g_pTheApp->m_hUnattendFile, szSectionName, _T("DebugService"), &Context) ) 
    {
        SetupGetStringField(&Context, 1, szEntry, _MAX_PATH, NULL);
        if (0 == _tcsicmp(szEntry, _T("1")) || 0 == _tcsicmp(szEntry, _T("true")) )
        {
            SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle, 34101, szEntry);
        }
    }
    return;
}

void Check_For_DebugLevel(void)
{
    INFCONTEXT Context;
    TCHAR szSectionName[_MAX_PATH];
    TCHAR szEntry[_MAX_PATH] = _T("");

    // Do this only if unattended install
    if (!g_pTheApp->m_fUnattended) {return;}

    // The section name to look for in the unattended file
    _tcscpy(szSectionName, UNATTEND_FILE_SECTION);

    //
    // Look for our special setting
    //
    *szEntry = NULL;
    if ( SetupFindFirstLine(g_pTheApp->m_hUnattendFile, szSectionName, _T("DebugLevel"), &Context) ) 
        {
        SetupGetStringField(&Context, 1, szEntry, _MAX_PATH, NULL);

        if (IsValidNumber((LPCTSTR)szEntry)) 
            {
                g_GlobalDebugLevelFlag = _ttoi((LPCTSTR) szEntry);
                g_GlobalDebugLevelFlag_WasSetByUnattendFile = TRUE;

                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("DebugLevel=%d."),g_GlobalDebugLevelFlag));
            }

            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE_WIN32_API )
            {
                g_CheckIfMetabaseValueWasWritten = TRUE;
            }
        }

    return;
}

void Check_Custom_IIS_INF(void)
{
    INFCONTEXT Context;
    TCHAR szSectionName[_MAX_PATH];
    TCHAR szFullPathedFilename0[_MAX_PATH] = _T("");
    TCHAR szFullPathedFilename[_MAX_PATH] = _T("");

    // Do this only if unattended install
    if (!g_pTheApp->m_fUnattended) {return;}

    // The section name to look for in the unattended file
    _tcscpy(szSectionName, UNATTEND_FILE_SECTION);

    //
    // Look for our special setting
    //
    *szFullPathedFilename = NULL;
    if ( SetupFindFirstLine(g_pTheApp->m_hUnattendFile, szSectionName, _T("AlternateIISINF"), &Context) ) 
        {SetupGetStringField(&Context, 1, szFullPathedFilename, _MAX_PATH, NULL);}
    if (*szFullPathedFilename)
    {
        // check szFullPathedFilename for an string substitutions...
        // %windir%, etc...
        _tcscpy(szFullPathedFilename0, szFullPathedFilename);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szFullPathedFilename0, szFullPathedFilename, sizeof(szFullPathedFilename)/sizeof(TCHAR)))
            {_tcscpy(szFullPathedFilename,szFullPathedFilename0);}
        if (!IsFileExist(szFullPathedFilename))
        {
            iisDebugOut((LOG_TYPE_WARN, _T("Check_Custom_IIS_INF:AlternateIISINF=%s.Not Valid.ignoring unattend value. WARNING.\n"),szFullPathedFilename));
            goto Check_Custom_IIS_INF_Exit;
        }

        // try to open the alternate iis.inf file.
        g_pTheApp->m_hInfHandleAlternate = INVALID_HANDLE_VALUE;
        // Get a handle to it.
        g_pTheApp->m_hInfHandleAlternate = SetupOpenInfFile(szFullPathedFilename, NULL, INF_STYLE_WIN4, NULL);
        if (!g_pTheApp->m_hInfHandleAlternate || g_pTheApp->m_hInfHandleAlternate == INVALID_HANDLE_VALUE)
            {
            iisDebugOut((LOG_TYPE_WARN, _T("Check_Custom_IIS_INF: SetupOpenInfFile failed on file: %s.\n"),szFullPathedFilename));
            goto Check_Custom_IIS_INF_Exit;
            }

        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Check_Custom_IIS_INF:AlternateIISINF=%s\n"),szFullPathedFilename));
    }

Check_Custom_IIS_INF_Exit:
    return;
}


void Check_Custom_WWW_or_FTP_Path(void)
{
    INFCONTEXT Context;
    TCHAR szSectionName[_MAX_PATH];
    TCHAR szValue0[_MAX_PATH] = _T("");
    TCHAR szValue[_MAX_PATH] = _T("");


    // Do this only if unattended install
    if (!g_pTheApp->m_fUnattended) {return;}

    //iisDebugOut((LOG_TYPE_TRACE, _T("Check_Custom_WWW_or_FTP_Path:start\n")));

    // The section name to look for in the unattended file
    _tcscpy(szSectionName, UNATTEND_FILE_SECTION);

    //
    // FTP
    //
    *szValue = NULL;
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, szSectionName, _T("PathFTPRoot"), &Context) ) 
        {SetupGetStringField(&Context, 1, szValue, _MAX_PATH, NULL);}
    if (*szValue)
    {
        // check szValue for an string substitutions...
        // %windir%, etc...
        _tcscpy(szValue0, szValue);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szValue0, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {_tcscpy(szValue,szValue0);}
        if (IsValidDirectoryName(szValue))
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("Check_Custom_WWW_or_FTP_Path:Unattendfilepath:PathFTPRoot=%s\n"),szValue));
            CustomFTPRoot(szValue);
            g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_PATH_FTP;
        }
        else
        {
            iisDebugOut((LOG_TYPE_WARN, _T("Check_Custom_WWW_or_FTP_Path:Unattendfilepath:PathFTPRoot=%s.Not Valid.ignoring unattend value. WARNING.\n"),szValue));
        }
    }

    //
    // WWW
    //
    *szValue = NULL;
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, szSectionName, _T("PathWWWRoot"), &Context) ) 
        {SetupGetStringField(&Context, 1, szValue, _MAX_PATH, NULL);}
    if (*szValue)
    {
        // check szValue for an string substitutions...
        // %windir%, etc...
        _tcscpy(szValue0, szValue);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szValue0, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {_tcscpy(szValue,szValue0);}
        if (IsValidDirectoryName(szValue))
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("Check_Custom_WWW_or_FTP_Path:Unattendfilepath:PathWWWRoot=%s\n"),szValue));
            CustomWWWRoot(szValue);
            g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_PATH_WWW;
        }
        else
        {
            iisDebugOut((LOG_TYPE_WARN, _T("Check_Custom_WWW_or_FTP_Path:Unattendfilepath:PathFTPRoot=%s.Not Valid.ignoring unattend value. WARNING.\n"),szValue));
        }
    }

    //iisDebugOut((LOG_TYPE_TRACE, _T("Check_Custom_WWW_or_FTP_Path:end\n")));
    return;
}


CInitApp::CInitApp()
{
    m_err = 0;
    m_hInfHandle = NULL;
    m_hInfHandleAlternate = NULL;
    m_bAllowMessageBoxPopups = TRUE;
    m_bThereWereErrorsChkLogfile = FALSE;
    m_bThereWereErrorsFromMTS = FALSE;
    m_bWin95Migration = FALSE;

    // Product name and application name
    m_csAppName = _T("");
    m_csIISGroupName = _T("");

    // account + passwd for anonymous user
    m_csGuestName = _T("");
    m_csGuestPassword = _T("");
    m_csWAMAccountName = _T("");
    m_csWAMAccountPassword = _T("");
    m_csWWWAnonyName = _T("");
    m_csWWWAnonyPassword = _T("");
    m_csFTPAnonyName = _T("");
    m_csFTPAnonyPassword = _T("");

    dwUnattendConfig = 0;

    m_csWAMAccountName_Unattend = _T("");
    m_csWAMAccountPassword_Unattend = _T("");
    m_csWWWAnonyName_Unattend = _T("");
    m_csWWWAnonyPassword_Unattend = _T("");
    m_csFTPAnonyName_Unattend = _T("");
    m_csFTPAnonyPassword_Unattend = _T("");

    m_csWAMAccountName_Remove = _T("");
    m_csWWWAnonyName_Remove = _T("");
    m_csFTPAnonyName_Remove = _T("");

    // machine status
    m_csMachineName = _T("");
    m_csUsersDomain = _T("");
    m_csUsersAccount = _T("");

    m_fUninstallMapList_Dirty = FALSE;

    m_csWinDir = _T("");
    m_csSysDir = _T("");
    m_csSysDrive = _T("");

    m_csPathSource = _T("");
    m_csPathOldInetsrv = _T("");  // the primary destination used by previous iis/pws products
    m_csPathInetsrv = _T("");  // the primary destination defaults to m_csSysDir\inetsrv
    m_csPathInetpub = _T("");
    m_csPathFTPRoot = _T("");
    m_csPathWWWRoot = _T("");
    m_csPathWebPub = _T("");
    m_csPathProgramFiles = _T("");
    m_csPathIISSamples = _T("");
    m_csPathScripts = _T("");
    m_csPathASPSamp = _T("");
    m_csPathAdvWorks = _T("");
    m_csPathIASDocs = _T("");
    m_csPathOldPWSFiles = _T("");
    m_csPathOldPWSSystemFiles = _T("");

    m_dwOSServicePack = 0;
    m_eOS = OS_OTHERS;                  // OS_W95, OS_NT, OS_OTHERS
    m_fNT5 = FALSE;
    m_fW95 = FALSE;                 // TRUE if Win95 (build xxx) or greater

    m_eNTOSType = OT_NT_UNKNOWN;           // OT_PDC, OT_SAM, OT_BDC, OT_NTS, OT_NTW
    m_csPlatform = _T("");

    m_fTCPIP = FALSE;               // TRUE if TCP/IP is installed

    m_eUpgradeType = UT_NONE;       //  UT_NONE, UT_10, UT_20, etc.
    m_bUpgradeTypeHasMetabaseFlag = FALSE;
    m_eInstallMode = IM_FRESH;      // IM_FRESH, IM_MAINTENANCE, IM_UPGRADE
    m_dwSetupMode = SETUPMODE_CUSTOM;
    m_bRefreshSettings = FALSE;
    m_bPleaseDoNotInstallByDefault = FALSE;

    m_fNTOperationFlags=0;
    m_fNTGuiMode=0;
    m_fNtWorkstation=0;
    m_fInvokedByNT = 0;

    m_fUnattended = FALSE;
    m_csUnattendFile = _T("");
    m_hUnattendFile = NULL;

    m_fEULA = FALSE;

    // TRUE if m_csPathOldInetsrv != m_csPathInetsrv, which means, 
    // we need to migrate the old inetsrv to the new one that is system32\inetsrv.
    m_fMoveInetsrv = FALSE;

    m_csPathSrcDir = _T("");
    m_csMissingFile = _T("");
    m_csMissingFilePath = _T("");
    m_fWebDownload = FALSE;
}

CInitApp::~CInitApp()
{
}

// The one and only CInitApp object <Global variable>
// --------------------------------------------------
BOOL CInitApp::GetMachineName()
{
    TCHAR buf[ CNLEN + 10 ];
    DWORD dwLen = CNLEN + 10;

    m_csMachineName = _T("");

    // Get computername
    if ( GetComputerName( buf, &dwLen ))
    {
        if ( buf[0] != _T('\\') )
        {
            m_csMachineName = _T("\\");
            m_csMachineName += _T("\\");
        }
        m_csMachineName += buf;
    }
    else
    {
        m_err = IDS_CANNOT_GET_MACHINE_NAME;
    }

    return ( !(m_csMachineName.IsEmpty()) );
}


// Return TRUE, if NT or Win95
// --------------------------------------------------
BOOL CInitApp::GetOS()
{
    OSVERSIONINFO VerInfo;
    VerInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    GetVersionEx( &VerInfo );

    switch (VerInfo.dwPlatformId) 
    {
    case VER_PLATFORM_WIN32_NT:
        m_eOS = OS_NT;
        break;
    case VER_PLATFORM_WIN32_WINDOWS:
        m_eOS = OS_W95;
        break;
    default:
        m_eOS = OS_OTHERS;
        break;
    }

    if ( m_eOS == OS_OTHERS ) {m_err = IDS_OS_NOT_SUPPORT;}
    return (m_eOS != OS_OTHERS);
}

// Support NT 4.0 (SP3) or greater
// --------------------------------------------------

BOOL CInitApp::GetOSVersion()
/*++

Routine Description:

    This function detects OS version. NT5 or greater is required to run this setup.

Arguments:

    None

Return Value:

    BOOL
    return FALSE, if we fails to detect the OS version, 
                  or it is a NT version which is smaller than v5.0

--*/
{
    BOOL fReturn = FALSE;

    if ( m_eOS == OS_NT )
    {
        OSVERSIONINFO vInfo;

        vInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if ( GetVersionEx(&vInfo) )
        {
            // NT5 or greater is required.
            if ( vInfo.dwMajorVersion < 5 ) 
            {
        m_err = IDS_NT5_NEEDED;
        return FALSE;
            }
            if ( vInfo.dwMajorVersion == 5 )
            {
                m_fNT5 = TRUE;
                fReturn = TRUE;
            }
        }
    }

    // this line may be used for win98
    if (m_eOS == OS_W95) {fReturn = TRUE;}

    if ( !fReturn ) {m_err = IDS_OS_VERSION_NOT_SUPPORTED;}

    return (fReturn);
}

// find out it's a NTS, PDC, BDC, NTW, SAM(PDC)
// --------------------------------------------------
BOOL CInitApp::GetOSType()
{
    BOOL fReturn = TRUE;

    if ( m_eOS == OS_NT )
    {
#ifndef _CHICAGO_
        // If we are in NT guimode setup
        // then the registry key stuff is not yet setup
        // use the passed in ocmanage.dll stuff to determine
        // what we are installing upon.
        if (g_pTheApp->m_fNTGuiMode)
        {
            if (g_pTheApp->m_fNtWorkstation) {m_eNTOSType = OT_NTW;}
            else {m_eNTOSType = OT_NTS;}
        }
        else
        {

            m_eNTOSType = OT_NTS; // default to stand-alone NTS

            CRegKey regProductPath( HKEY_LOCAL_MACHINE, REG_PRODUCTOPTIONS, KEY_READ);
            if ( (HKEY)regProductPath )
            {
                CString strProductType;
                LONG lReturnedErrCode = regProductPath.QueryValue( _T("ProductType"), strProductType );
                if (lReturnedErrCode == ERROR_SUCCESS) 
                {
                    strProductType.MakeUpper();

                    // ToDo: Sam ?
                    if (strProductType == _T("WINNT")) 
                    {
                        m_eNTOSType = OT_NTW;
                    }
                    else if (strProductType == _T("SERVERNT")) 
                    {
                        m_eNTOSType = OT_NTS;
                    }
                    else if (strProductType == _T("LANMANNT"))
                    {
                        m_eNTOSType = OT_PDC_OR_BDC;
                    }
                    else 
                    {
                        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("ProductType=%1!s! (UnKnown). FAILER to detect ProductType\n"), strProductType));
                        fReturn = FALSE;
                    }
                }
                else 
                {
                    // Shoot, we can't get the registry key,
                    // let's try using the ocmanage.dll passed in stuff.
                    if (g_pTheApp->m_fNTGuiMode)
                    {
                        if (g_pTheApp->m_fNtWorkstation) {m_eNTOSType = OT_NTW;}
                        else {m_eNTOSType = OT_NTS;}
                    }
                    else
                    {
                        GetErrorMsg(lReturnedErrCode, REG_PRODUCTOPTIONS);
                        m_eNTOSType = OT_NTS; // default to stand-alone NTS
                    }
                }
            }
            else
            {
                // Shoot, we can't get the registry key,
                // let's try using the ocmanage.dll passed in stuff.
                if (g_pTheApp->m_fNTGuiMode)
                {
                    if (g_pTheApp->m_fNtWorkstation) {m_eNTOSType = OT_NTW;}
                    else {m_eNTOSType = OT_NTS;}
                }
                else
                {
                    GetErrorMsg(ERROR_CANTOPEN, REG_PRODUCTOPTIONS);
                }
            }
        }
#endif //_CHICAGO_            
    }

    if ( !fReturn )
        m_err = IDS_CANNOT_DETECT_OS_TYPE;

    return(fReturn);
}

// Get WinDir and SysDir of the machine
//  WinDir = C:\winnt           SysDir = C:\Winnt\system32
// --------------------------------------------------
BOOL CInitApp::GetSysDirs()
{
    BOOL fReturn = TRUE;

    TCHAR buf[_MAX_PATH];

    GetWindowsDirectory( buf, _MAX_PATH);
    m_csWinDir = buf;

    GetSystemDirectory( buf, _MAX_PATH);
    m_csSysDir = buf;

    buf[2] = _T('\0');  // now buf contains the system drive letter
    m_csSysDrive = buf;
    return fReturn;
}

// Return true if tcp installed on win95
// --------------------------------------------------
#ifdef _CHICAGO_
BOOL W95TcpInstalled()
{
    WORD wVersionRequested = MAKEWORD(1, 1);
    WSADATA wsaData;
    SOCKET sock;

    if (WSAStartup(wVersionRequested, &wsaData))
          return (FALSE);
    if ((LOBYTE(wsaData.wVersion) != 1 || HIBYTE(wsaData.wVersion) != 1))
        return (FALSE);

    sock = socket( AF_INET, SOCK_STREAM, 0 );

    if (sock == INVALID_SOCKET)
        return FALSE;

    closesocket( sock );
    return (TRUE);
}
#endif

BOOL CInitApp::IsTCPIPInstalled()
/*++

Routine Description:

    This function detects whether TCP/IP is installed, 
    and set m_fTCPIP appropriately.

Arguments:

    None

Return Value:

    BOOL
    set m_fTCPIP appropriately, and always return TRUE here. 
    m_fTCPIP will be used later.

--*/
{
#ifdef _CHICAGO_
    m_fTCPIP = W95TcpInstalled();
#else
    // NT 5.0 STUFF
    m_fTCPIP = TCPIP_Check_Temp_Hack();
#endif //_CHICAGO_

    return TRUE;
}



BOOL CInitApp::SetInstallMode()
{
    BOOL fReturn = TRUE;
    int iTempInstallFreshNT = TRUE;
    m_eInstallMode = IM_FRESH;
    m_eUpgradeType = UT_NONE;
    m_bUpgradeTypeHasMetabaseFlag = FALSE;

    // -----------------------------------
    // Get the install mode from NT setup (g_pTheApp->m_fNTUpgrade_Mode)
    // Can either be:  
    // 1. SETUPMODE_FRESH. user clicked on fresh option and wants to install NT5 fresh
    //    a. install iis fresh. do not attempt to upgrade the old iis stuff.
    // 2. SETUPMODE_UPGRADE. user clicked on upgrade option and wants to upgrade to NT5
    //    a. upgrade any iis installations
    //    b. if no old iis detected, then do not install iis
    // 3. SETUPMODE_MAINTENANCE.  user is running setup from the control panel add/remove.
    // -----------------------------------
    if (!m_fInvokedByNT)
    {
        // if we are not guimode or in add/remove
        // then we must be running standalone.
        // if we are running standalone, then everything is
        // either fresh or maintenance.
        m_eInstallMode = IM_FRESH;
        m_eUpgradeType = UT_NONE;
        if (TRUE == AreWeCurrentlyInstalled())
        {
            m_eInstallMode = IM_MAINTENANCE;
            m_eUpgradeType = UT_NONE;
            m_bUpgradeTypeHasMetabaseFlag = TRUE;
        }
        else
        {
            CRegKey regINetStp( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);
            if ((HKEY) regINetStp)
            {
                // This must be an upgrade....
                if (SetUpgradeType() == TRUE)
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("SetInstallMode=SETUPMODE_UPGRADE.Upgrading.\n")));
                }
                else
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("SetInstallMode=SETUPMODE_UPGRADE.NothingToUpgrade.\n")));
                }
            }
        }

        goto SetInstallMode_Exit;
    }

    // --------------------------------
    // Check if we are in the ADD/REMOVE mode...
    // --------------------------------
    if (g_pTheApp->m_fNTOperationFlags & SETUPOP_STANDALONE)
    {
        //
        // We are in add remove...
        //
        iisDebugOut((LOG_TYPE_TRACE, _T("SetInstallMode=IM_MAINTENANCE\n")));
        m_eInstallMode = IM_MAINTENANCE;
        m_eUpgradeType = UT_NONE;
        m_bUpgradeTypeHasMetabaseFlag = FALSE;
        goto SetInstallMode_Exit;
    }

    // --------------------------------
    //
    // FRESH IIS install
    // 
    // if we are not in NT upgrade
    // then set everything to do a fresh!
    //
    // --------------------------------
    iTempInstallFreshNT = TRUE;
    if (g_pTheApp->m_fNTOperationFlags & SETUPOP_WIN31UPGRADE){iTempInstallFreshNT = FALSE;}
    if (g_pTheApp->m_fNTOperationFlags & SETUPOP_WIN95UPGRADE){iTempInstallFreshNT = FALSE;}
    if (g_pTheApp->m_fNTOperationFlags & SETUPOP_NTUPGRADE){iTempInstallFreshNT = FALSE;}
    if (iTempInstallFreshNT)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("SetInstallMode=IM_FRESH\n")));
        m_eInstallMode = IM_FRESH;
        m_eUpgradeType = UT_NONE;
        m_bUpgradeTypeHasMetabaseFlag = FALSE;
        goto SetInstallMode_Exit;
    }
    
    // --------------------------------
    //
    // UPGRADE iis install
    //
    // if we get here then the user checked the "upgrade" button and
    // is trying to upgrade from an earlier WIN95/NT351/NT4/NT5 installation.
    //
    // --------------------------------
    //
    // Set Upgrade ONLY if there are iis components to upgrade!
    // do not install if there is nothing to upgrade
    ProcessSection(g_pTheApp->m_hInfHandle, _T("Set_Upgrade_Type_chk"));

    // if we processed the upgrade section from the inf and
    // we are still in a fresh install, then call this other
    // function to make sure we catch known iis upgrade types.
    if (g_pTheApp->m_eUpgradeType == UT_NONE)
        {SetUpgradeType();}

SetInstallMode_Exit:
    if (m_fInvokedByNT){DefineSetupModeOnNT();}
    return fReturn;
}


void CInitApp::DefineSetupModeOnNT()
/*++

Routine Description:

    This function defines IIS setup mode when invoked by NT5.

    NOTE:
    Since IIS setup does not run as a standalone program on NT5, 
    user won't see buttons like Minimum, Typical, Custom, 
    AddRemove, Reinstall, RemoveAll, UpgradeOnly, UpgradePlus 
    any more. Hence, we have a totally different way to decide 
    what mode the setup is running in.

Arguments:

    none

Return Value:

    set m_dwSetupMode appropriately.

--*/
{
    if (m_fInvokedByNT) {
        switch (m_eInstallMode) {
        case IM_FRESH:
            m_dwSetupMode = SETUPMODE_CUSTOM;
            break;
        case IM_MAINTENANCE:
            if (m_fNTGuiMode) {
                // invoked in NT GUI mode setup
                // treat minor os upgrade like a reinstall
                m_dwSetupMode = SETUPMODE_REINSTALL;
                m_bRefreshSettings = TRUE;
            } else {
                // invoked by ControlPanel\AddRemoveApplet
                m_dwSetupMode = SETUPMODE_ADDREMOVE;
            }
            break;
        case IM_UPGRADE:
            m_dwSetupMode = SETUPMODE_ADDEXTRACOMPS;
            break;
        default:
            break;
        }
    }

    return;
}

void GetVRootValue( CString strRegPath, CString csName, LPTSTR szRegName, CString &csRegValue)
{
    CString csRegName;

    strRegPath +=_T("\\Parameters\\Virtual Roots");
    CRegKey regVR( HKEY_LOCAL_MACHINE, strRegPath, KEY_READ);

    csRegName = szRegName;

    if ( (HKEY) regVR )
    {
        regVR.m_iDisplayWarnings = FALSE;

        csRegName = csName;
        if ( regVR.QueryValue( csName, csRegValue ) != ERROR_SUCCESS )
        {
            csName += _T(",");
            if ( regVR.QueryValue(csName, csRegValue) != ERROR_SUCCESS )
            {
                // well, we need to scan all the keys
                CRegValueIter regEnum( regVR );
                CString strName;
                DWORD dwType;
                int nLen = csName.GetLength();

                while ( regEnum.Next( &strName, &dwType ) == ERROR_SUCCESS )
                {
                    CString strLeft = strName.Left(nLen);
                    if ( strLeft.CompareNoCase(csName) == 0)
                    {
                        csRegName = strName;
                        regVR.QueryValue( strName, csRegValue );
                        break;
                    }
                }
            }
        }
        // remove the ending ",,something"
        int cPos = csRegValue.Find(_T(','));
        if ( cPos != (-1))
        {
            csRegValue = csRegValue.Left( cPos );
        }
    }
}


void CInitApp::DeriveInetpubFromWWWRoot(void)
{
    TCHAR szParentDir[_MAX_PATH];

    // Try to figure out InetPub Root
    // ------------------------------
    // Get inetpub dir from wwwroot
    // take the m_csPathWWWRoot and back off one dir to find it.
    InetGetFilePath(m_csPathWWWRoot, szParentDir);
    if ((IsFileExist(szParentDir)))
    {
        m_csPathInetpub = szParentDir;
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Old InetPub='%1!s!'.  Exists.  so we'll use it.\n"), m_csPathInetpub));
    }
    else
    {
        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("Old InetPub='%1!s!'.  Does not exist.  we'll use the default. WARNING.\n"), szParentDir));
    }

    return;
}



void CInitApp::GetOldInetSrvDir(void)
{
    CRegKey regINetStp( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);

    // Get old InetSrv dir
    // -------------------
    m_csPathOldInetsrv = m_csPathInetsrv;
    if ((HKEY)regINetStp) 
    {
        // Get the old inetsrv dir, and check if it's different
        regINetStp.m_iDisplayWarnings = FALSE;
        regINetStp.QueryValue( _T("InstallPath"), m_csPathOldInetsrv);
        if (-1 != m_csPathOldInetsrv.Find(_T('%')) )
        {
            // there is a '%' in the string
            TCHAR szTempDir[_MAX_PATH];
            _tcscpy(szTempDir, m_csPathOldInetsrv);
            if (ExpandEnvironmentStrings( (LPCTSTR)m_csPathOldInetsrv, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                {m_csPathOldInetsrv = szTempDir;}
        }
        m_fMoveInetsrv = (m_csPathOldInetsrv.CompareNoCase(m_csPathInetsrv) != 0);
    }

    return;
}


void CInitApp::GetOldWWWRootDir(void)
{
    CString csOldWWWRoot;
    //
    // Try to get it from the old iis2,3,4 setup location if it's there.
    //
    CRegKey regINetStp( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);
    if ((HKEY) regINetStp) 
    {
        //
        // get the old wwwroot from the registry if there.
        //
        regINetStp.m_iDisplayWarnings = FALSE;
        regINetStp.QueryValue(_T("PathWWWRoot"), csOldWWWRoot);
        if (-1 != csOldWWWRoot.Find(_T('%')) )
        {
            // there is a '%' in the string
            TCHAR szTempDir[_MAX_PATH];
            _tcscpy(szTempDir, csOldWWWRoot);
            if (ExpandEnvironmentStrings( (LPCTSTR)csOldWWWRoot, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                {csOldWWWRoot = szTempDir;}
        }

        // The old wwwRoot may be a network drive.
        // what to do then?
        // at least check if we can access it!
        if ((IsFileExist(csOldWWWRoot)))
        {
            TCHAR szParentDir[_MAX_PATH];
            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Old WWWRoot='%1!s!'.  Exists.  so we'll use it.\n"), csOldWWWRoot));
            m_csPathWWWRoot = csOldWWWRoot;
        }
        else
        {
            iisDebugOutSafeParams((LOG_TYPE_WARN, _T("OldWWWRoot='%1!s!'.  Does not exist.  we'll use the default. WARNING.\n"), csOldWWWRoot));
        }
    }

    //
    // Try to get it from the old iis2,3,4 Actual W3svc Service location if it's there.
    // and overwrite anything that we got from setup -- since w3svc is what is actually used!
    //
    GetVRootValue(REG_W3SVC, _T("/"), _T("/"), m_csPathWWWRoot);

    return;
}

void CInitApp::GetOldIISSamplesLocation(void)
{
    //
    // Try to get it from the old iis2,3,4 setup location if it's there.
    //
    CRegKey regINetStp( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);
    if ((HKEY)regINetStp)
    {
        //
        // Get the location of the where the samples were installed.
        //
        m_csPathIISSamples.Empty();
        regINetStp.m_iDisplayWarnings = FALSE;
        regINetStp.QueryValue( _T("/IISSamples"), m_csPathIISSamples );
        if (-1 != m_csPathIISSamples.Find(_T('%')) )
        {
            // there is a '%' in the string
            TCHAR szTempDir[_MAX_PATH];
            _tcscpy(szTempDir, m_csPathIISSamples);
            if (ExpandEnvironmentStrings( (LPCTSTR)m_csPathIISSamples, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                {m_csPathIISSamples = szTempDir;}
        }
        if ( m_csPathIISSamples.IsEmpty()) 
        {
            //
            // if Samples path is empty then this an Upgrade, 
            // Guess where to put Sample Site
            //
            TCHAR szParentDir[_MAX_PATH], szDir[_MAX_PATH];
            //
            // Get the parent Dir path
            //
            InetGetFilePath((LPCTSTR)m_csPathWWWRoot, szParentDir);
            //
            // Append the samples dir to parent path
            //
            AppendDir(szParentDir, _T("iissamples"), szDir);
            m_csPathIISSamples = szDir;
        }
    }

//#ifdef _CHICAGO_
    if (m_eUpgradeType == UT_10_W95) 
    {
        TCHAR szParentDir[_MAX_PATH], szDir[_MAX_PATH];
        InetGetFilePath(m_csPathWWWRoot, szParentDir);
        AppendDir(szParentDir, _T("iissamples"), szDir);
        m_csPathIISSamples = szDir;
        AppendDir(szParentDir, _T("webpub"), szDir);
        m_csPathWebPub = szDir;
    }
//#endif //_CHICAGO_

    return;
}

void CInitApp::GetOldIISDirs(void)
{
    CRegKey regINetStp( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);
    
    //
    // get values from the previous setup for II2/4 upgrade
    //

    // Try to get old WWW Root from the service itself
    // -----------------------
    GetOldWWWRootDir();
    // Set Inetpub from whatever we got from www root
    DeriveInetpubFromWWWRoot();

    // Reset Vars relying on Inetpub
    // -----------------------------
    m_csPathFTPRoot = m_csPathInetpub + _T("\\ftproot");
    m_csPathIISSamples = m_csPathInetpub + _T("\\iissamples");
    m_csPathScripts = m_csPathInetpub + _T("\\Scripts");
    m_csPathWebPub = m_csPathInetpub + _T("\\webpub");
    m_csPathASPSamp = m_csPathInetpub + _T("\\ASPSamp");
    m_csPathAdvWorks = m_csPathInetpub + _T("\\ASPSamp\\AdvWorks");

    // Try to get old FTP Root from the service itself
    // -----------------------
    GetVRootValue(REG_MSFTPSVC, _T("/"), _T("/"), m_csPathFTPRoot);

    // Get old iis samples location
    // ----------------------------
    GetOldIISSamplesLocation();

    // Get iis 3.0 locations.
    // ----------------------
    GetVRootValue(REG_W3SVC, _T("/Scripts"), _T("/Scripts"), m_csPathScripts);
    GetVRootValue(REG_W3SVC, _T("/ASPSamp"), _T("/ASPSamp"), m_csPathASPSamp);
    GetVRootValue(REG_W3SVC, _T("/AdvWorks"), _T("/AdvWorks"), m_csPathAdvWorks);
    GetVRootValue(REG_W3SVC, _T("/IASDocs"), _T("/IASDocs"), m_csPathIASDocs);

    // Get old InetSrv dir
    // -------------------
    GetOldInetSrvDir();

    return;
}



void CInitApp::SetInetpubDerivatives()
{
    m_csPathFTPRoot = m_csPathInetpub + _T("\\ftproot");
    m_csPathWWWRoot = m_csPathInetpub + _T("\\wwwroot");
    m_csPathWebPub = m_csPathInetpub + _T("\\webpub");
    m_csPathIISSamples = m_csPathInetpub + _T("\\iissamples");
    m_csPathScripts = m_csPathInetpub + _T("\\scripts");
    m_csPathASPSamp = m_csPathInetpub + _T("\\ASPSamp");
    m_csPathAdvWorks = m_csPathInetpub + _T("\\ASPSamp\\AdvWorks");

    switch (m_eInstallMode) 
    {
        case IM_DEGRADE:
        case IM_FRESH:
            // use the initialized values
            break;
        case IM_UPGRADE:
        case IM_MAINTENANCE:
            {
                // override, what ever we just set above!
                GetOldIISDirs();
                break;
            }
    }
}

void CInitApp::SetInetpubDir()
{
    m_csPathInetpub = m_csSysDrive + _T("\\Inetpub");
    // Check if the user wants to override this with a unattend setting
    Check_Custom_InetPub();
}

void CInitApp::ResetWAMPassword()
{
    LPTSTR pszPassword = NULL;
    // create a iwam password
    pszPassword = CreatePassword(LM20_PWLEN+1);
    if (pszPassword)
    {
        m_csWAMAccountPassword = pszPassword;
        GlobalFree(pszPassword);pszPassword = NULL;
    }
}

// Init/Set m_csGuestName, m_csGuestPassword, destinations
// -------------------------------------------------------
void CInitApp::SetSetupParams()
{
    // check if the debug level is set in the unattend file
    // ----------------------------------------------------
    Check_For_DebugLevel();

    // init m_csGuestName as IUSR_MachineName, init m_csGuestPassword as a random password
    TCHAR szGuestName[UNLEN+1];
    memset( (PVOID)szGuestName, 0, sizeof(szGuestName));

    CString csMachineName;
    csMachineName = m_csMachineName;
    csMachineName = csMachineName.Right(csMachineName.GetLength() - 2);
    LPTSTR pszPassword = NULL;

    // create a default guest name
    CString strDefGuest;
    MyLoadString( IDS_GUEST_NAME, strDefGuest);
    strDefGuest += csMachineName;
    _tcsncpy( szGuestName, (LPCTSTR) strDefGuest, LM20_UNLEN+1);
    m_csGuestName = szGuestName;
    // create a default guest password
    pszPassword = CreatePassword(LM20_PWLEN+1);
    if (pszPassword)
    {
        m_csGuestPassword = pszPassword;
        GlobalFree(pszPassword);pszPassword = NULL;
    }

    // Set the ftp/www users to use this default specified one...
    m_csWWWAnonyName = m_csGuestName;
    m_csWWWAnonyPassword = m_csGuestPassword;
    m_csFTPAnonyName = m_csGuestName;
    m_csFTPAnonyPassword = m_csGuestPassword;


     // init all 4 destinations
    m_csPathInetsrv = m_csSysDir + _T("\\inetsrv");

    m_csPathIASDocs = m_csPathInetsrv + _T("\\Docs");
    m_csPathProgramFiles = m_csSysDrive + _T("\\Program Files");
    CRegKey regCurrentVersion(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows\\CurrentVersion"), KEY_READ);
    if ( (HKEY)regCurrentVersion ) 
    {
        if (regCurrentVersion.QueryValue(_T("ProgramFilesDir"), m_csPathProgramFiles) != 0)
            {m_csPathProgramFiles = m_csSysDrive + _T("\\Program Files");}
        else
        {
            if (-1 != m_csPathProgramFiles.Find(_T('%')) )
            {
                // there is a '%' in the string
                TCHAR szTempDir[_MAX_PATH];
                _tcscpy(szTempDir, m_csPathProgramFiles);
                if (ExpandEnvironmentStrings( (LPCTSTR)m_csPathProgramFiles, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                    {
                    m_csPathProgramFiles = szTempDir;
                    }
            }
        }
    }

    CRegKey regCurrentVersionSetup(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows\\CurrentVersion\\Setup"), KEY_READ);
    if ( (HKEY)regCurrentVersionSetup ) 
    {
        // Get NT installation path
        if (regCurrentVersionSetup.QueryValue(_T("SourcePath"), m_csPathNTSrcDir) != 0)
            {m_csPathNTSrcDir = m_csSysDrive + _T("\\$WIN_NT$.~LS");}
        else
        {
            if (-1 != m_csPathNTSrcDir.Find(_T('%')) )
            {
                // there is a '%' in the string
                TCHAR szTempDir[_MAX_PATH];
                _tcscpy(szTempDir, m_csPathNTSrcDir);
                if (ExpandEnvironmentStrings( (LPCTSTR)m_csPathNTSrcDir, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                    {
                    m_csPathNTSrcDir = szTempDir;
                    }
            }
        }
    }


//#ifdef _CHICAGO_
    if (m_eUpgradeType == UT_10_W95) 
    {
        BOOL bOSR2 = TRUE; 
        CRegKey regVersion(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"), KEY_READ);
        if ((HKEY)regVersion) 
        {
            CString csString;
            // VersionNumber for OSR2 is 4.00.1111
            // VersionNumber for the original win95 is 4.00.950
            if (regVersion.QueryValue(_T("VersionNumber"), csString) == ERROR_SUCCESS) 
            {
                if (csString.Compare(_T("4.00.950")) == 0)
                    bOSR2 = FALSE;
            }
        }

        if (!bOSR2) 
        {
            g_pTheApp->m_csPathOldPWSFiles = m_csPathProgramFiles + _T("\\WebSvr");
            g_pTheApp->m_csPathOldPWSSystemFiles = m_csPathProgramFiles + _T("\\WebSvr\\System");
        }
        else 
        {
            g_pTheApp->m_csPathOldPWSFiles = m_csPathProgramFiles + _T("\\Personal Web Server");
            g_pTheApp->m_csPathOldPWSSystemFiles = m_csPathProgramFiles + _T("\\Personal Web Server\\WebServer");
        }
    }
//#endif //_CHICAGO

    return;
}

// Get Platform info
void CInitApp::GetPlatform()
{
    if ( m_eOS == OS_NT)
    {
        SYSTEM_INFO si;
        GetSystemInfo( &si );
        m_csPlatform = _T("x86");
        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {m_csPlatform = _T("x86");}
        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64) {m_csPlatform = _T("IA64");}
        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) {m_csPlatform = _T("IA64");}
        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA) {m_csPlatform = _T("ALPHA");}
        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_MIPS) {m_csPlatform = _T("MIPS");}
        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_PPC) {m_csPlatform = _T("PPC");}
        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_UNKNOWN) {m_csPlatform = _T("UNKNOWN");}

        // save the number of processors for this machine.
        m_dwNumberOfProcessors = si.dwNumberOfProcessors;

/* old
        TCHAR *p = _tgetenv(_T("PROCESSOR_ARCHITECTURE"));
        if ( p ) 
            {m_csPlatform = p;}
        else
            {m_csPlatform = _T("x86");}
*/
    }
    return;
}

BOOL CInitApp::GetMachineStatus()
{
    if ( ( !GetMachineName() )  ||    // m_csMachineName
         ( !GetOS() )           ||    // m_fOSNT
         ( !GetOSVersion() )    ||    // NT 4.0 (Build 1381) or greater
         ( !GetOSType() )       ||    // m_eOSType = NT_SRV or NT_WKS
         ( !GetSysDirs() )      ||    // m_csWinDir. m_csSysDir
         ( !IsTCPIPInstalled()) ||    // errmsg: if NO TCPIP is installed
         ( !SetInstallMode()) )       // errmsg: if down grade the product      
    {
        return FALSE;
    }

    SetSetupParams(); // Guest account, destinations
    ReGetMachineAndAccountNames();
    ResetWAMPassword();
    SetInetpubDir();
    SetInetpubDerivatives();
    UnInstallList_RegRead(); // Get Uninstall information
    UnInstallList_SetVars(); // set member variables for uninstall info
    // check for any unattend file\custom settings.
    Check_Unattend_Settings();

    GetPlatform();

    GetUserDomain();

    return TRUE;
}

int CInitApp::MsgBox(HWND hWnd, int iID, UINT nType, BOOL bGlobalTitle)
{
    if (iID == -1) {return IDOK;}

    CString csMsg, csTitle;
    MyLoadString(iID, csMsg);
    csTitle = m_csAppName;
    iisDebugOutSafeParams((LOG_TYPE_WARN, _T("CInitApp::MsgBox('%1!s!')\n"), csMsg));

    return (::MessageBoxEx(NULL, (LPCTSTR)csMsg, csTitle, nType | MB_SETFOREGROUND, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT)));
}

int CInitApp::MsgBox2(HWND hWnd, int iID,CString csInsertionString,UINT nType)
{
    if (iID == -1) {return IDOK;}
    CString csFormat, csMsg, csTitle;
    MyLoadString(iID, csFormat);
    csMsg.Format(csFormat, csInsertionString);
    csTitle = m_csAppName;
    iisDebugOutSafeParams((LOG_TYPE_WARN, _T("CInitApp::MsgBox2('%1!s!')\n"), csMsg));

    return (::MessageBoxEx(NULL, (LPCTSTR)csMsg, csTitle, nType | MB_SETFOREGROUND, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT)));
}

BOOL CInitApp::InitApplication()
// Return Value:
// TRUE: application is initiliazed correctly, continue processing
// FALSE: application is missing some required parameters, like the correct OS, TCPIP, etc.
//        setup should be terminated.
{
    BOOL fReturn = FALSE;

    do {
        // Get Machine Status: 
        // m_eInstallMode(Fresh, Maintenance, Upgrade, Degrade), 
        // m_eUpgradeType(PROD 2.0, PROD 3.0)

        if ( !GetMachineStatus() )
        {
            CString csMsg;
            MyLoadString(m_err, csMsg);
            ::MessageBoxEx(NULL, (LPCTSTR)csMsg, (LPCTSTR) g_pTheApp->m_csAppName , MB_SETFOREGROUND, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT));

            iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("GetMachineStatus(); MessageBoxEx('%1!s!') FAILER\n"), csMsg));
            break;
        }

        if ( g_pTheApp->m_eInstallMode == IM_MAINTENANCE )
            {g_pTheApp->m_fEULA = TRUE;}

        fReturn = TRUE;

    } while (0);

    return fReturn;
}



// open the tcp/ip registry key 
// if it's there then tcp/ip is installed
int TCPIP_Check_Temp_Hack(void)
{
    int TheReturn = FALSE;

    CRegKey regTheKey(HKEY_LOCAL_MACHINE,_T("System\\CurrentControlSet\\Services\\Tcpip"),KEY_READ);
    if ((HKEY) regTheKey)
    {
        TheReturn = TRUE;
    }

    if (FALSE == TheReturn)
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("DETECT:TCPIP not Installed (yet), but we'll proceed as if it were.")));
        TheReturn = TRUE;
    }
    
    return TheReturn;
}

void GetUserDomain(void)
{
    HANDLE hProcess, hAccessToken;
    TCHAR InfoBuffer[1000],szAccountName[200], szDomainName[200];
    
    PTOKEN_USER pTokenUser = (PTOKEN_USER)InfoBuffer;
    DWORD dwInfoBufferSize,dwAccountSize = sizeof(szAccountName), dwDomainSize = sizeof(szDomainName);
    SID_NAME_USE snu;

    hProcess = GetCurrentProcess();
    OpenProcessToken(hProcess,TOKEN_READ,&hAccessToken);
    GetTokenInformation(hAccessToken,TokenUser,InfoBuffer,1000, &dwInfoBufferSize);
    if (LookupAccountSid(NULL, pTokenUser->User.Sid, szAccountName,&dwAccountSize,szDomainName, &dwDomainSize, &snu))
    {
        if (dwDomainSize)
        {
            g_pTheApp->m_csUsersDomain = szDomainName;
            //_tcscpy(g_szUsersDomain, szDomainName);
        }
        else 
        {
            g_pTheApp->m_csUsersDomain = _T(" ");
            //_tcscpy(g_szUsersDomain, _T(" "));
        }

        if (dwDomainSize)
        {
            g_pTheApp->m_csUsersAccount = szAccountName;
            //_tcscpy(g_szUsersAccount, szAccountName);        
        }
        else
        {
            g_pTheApp->m_csUsersAccount = _T(" ");
        }
    }
}

// This function should only be called in FRESH NT5 setup.
void CInitApp::ReGetMachineAndAccountNames()
{
    GetMachineName();

    // re-calculate the IUSR_ and IWAM_ account names
    TCHAR szGuestName[UNLEN+1];
    memset( (PVOID)szGuestName, 0, sizeof(szGuestName));

    CString csMachineName;
    csMachineName = m_csMachineName;
    csMachineName = csMachineName.Right(csMachineName.GetLength() - 2);
    CString strDefGuest;

    MyLoadString( IDS_GUEST_NAME, strDefGuest);
    strDefGuest += csMachineName;
    _tcsncpy( szGuestName, (LPCTSTR) strDefGuest, LM20_UNLEN+1);
    m_csGuestName = szGuestName;

    MyLoadString( IDS_WAM_ACCOUNT_NAME, strDefGuest);
    strDefGuest += csMachineName;
    _tcsncpy( szGuestName, (LPCTSTR) strDefGuest, LM20_UNLEN+1);
    m_csWAMAccountName = szGuestName;
}

void CInitApp::DumpAppVars(void)
{
    int iDoOnlyInThisMode = LOG_TYPE_TRACE;

    // only do this if the debug mode is trace.
    if (g_GlobalDebugLevelFlag >= iDoOnlyInThisMode)
    {

    iisDebugOut((iDoOnlyInThisMode, _T("=======================\n")));
   
    // machine status
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csMachineName=%1!s!\n"), m_csMachineName));
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csUsersDomain=%1!s!\n"), m_csUsersDomain));
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csUsersAccount=%1!s!\n"), m_csUsersAccount));

    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csWinDir=%1!s!\n"), m_csWinDir));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csSysDir=%1!s!\n"), m_csSysDir));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csSysDrive=%1!s!\n"), m_csSysDrive));;

    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathNTSrcDir=%1!s!\n"), m_csPathNTSrcDir));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathSource=%1!s!\n"), m_csPathSource));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathOldInetsrv=%1!s!\n"), m_csPathOldInetsrv));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathInetsrv=%1!s!\n"), m_csPathInetsrv));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathInetpub=%1!s!\n"), m_csPathInetpub));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathFTPRoot=%1!s!\n"), m_csPathFTPRoot));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathWWWRoot=%1!s!\n"), m_csPathWWWRoot));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathWebPub=%1!s!\n"), m_csPathWebPub));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathProgramFiles=%1!s!\n"), m_csPathProgramFiles));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathIISSamples=%1!s!\n"), m_csPathIISSamples));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathScripts=%1!s!\n"), m_csPathScripts));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathASPSamp=%1!s!\n"), m_csPathASPSamp));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathAdvWorks=%1!s!\n"), m_csPathAdvWorks));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathIASDocs=%1!s!\n"), m_csPathIASDocs));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathOldPWSFiles=%1!s!\n"), m_csPathOldPWSFiles));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathOldPWSSystemFiles=%1!s!\n"), m_csPathOldPWSSystemFiles));;
    
    if (m_eOS == OS_NT) {iisDebugOut((iDoOnlyInThisMode, _T("OS=NT\n")));}
    if (m_eOS == OS_W95) {iisDebugOut((iDoOnlyInThisMode, _T("OS=W95\n")));}
    if (m_eOS == OS_OTHERS) {iisDebugOut((iDoOnlyInThisMode, _T("OS=OTHER\n")));}

    if (m_eNTOSType == OT_NTW){iisDebugOut((iDoOnlyInThisMode, _T("m_eNTOSType=OT_NTW (Workstation)\n")));}
    if (m_eNTOSType == OT_NTS){iisDebugOut((iDoOnlyInThisMode, _T("m_eNTOSType=OT_NTS (Server)\n")));}
    if (m_eNTOSType == OT_PDC_OR_BDC){iisDebugOut((iDoOnlyInThisMode, _T("m_eNTOSType=OT_PDC_OR_BDC (Primary/Backup Domain Controller)\n")));}

    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPlatform=%1!s!\n"), m_csPlatform));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_dwNumberOfProcessors=%1!d!\n"), m_dwNumberOfProcessors));;

    if (m_fNT5) {iisDebugOut((iDoOnlyInThisMode, _T("OSVersion=5\n")));}
    if (m_fW95) {iisDebugOut((iDoOnlyInThisMode, _T("OSVersion=Win95\n")));}
    iisDebugOut((iDoOnlyInThisMode, _T("m_dwOSBuild=%d\n"), m_dwOSBuild));
    iisDebugOut((iDoOnlyInThisMode, _T("m_dwOSServicePack=0x%x\n"), m_dwOSServicePack));
    iisDebugOut((iDoOnlyInThisMode, _T("m_fTCPIP Exists=%d\n"), m_fTCPIP));

    if (m_eUpgradeType == UT_NONE){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_NONE\n")));}
    if (m_eUpgradeType == UT_10_W95){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_10_W95\n")));}
    if (m_eUpgradeType == UT_351){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_351\n")));}
    if (m_eUpgradeType == UT_10){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_10\n")));}
    if (m_eUpgradeType == UT_20){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_20\n")));}
    if (m_eUpgradeType == UT_30){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_30\n")));}
    if (m_eUpgradeType == UT_40){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_40\n")));}
    if (m_eUpgradeType == UT_50){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_50\n")));}
    if (m_eUpgradeType == UT_51){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_51\n")));}
    if (m_eUpgradeType == UT_60){iisDebugOut((iDoOnlyInThisMode, _T("m_eUpgradeType=UT_60\n")));}

    if (m_eInstallMode == IM_FRESH){iisDebugOut((iDoOnlyInThisMode, _T("m_eInstallMode=IM_FRESH\n")));}
    if (m_eInstallMode == IM_UPGRADE){iisDebugOut((iDoOnlyInThisMode, _T("m_eInstallMode=IM_UPGRADE\n")));}
    if (m_eInstallMode == IM_MAINTENANCE){iisDebugOut((iDoOnlyInThisMode, _T("m_eInstallMode=IM_MAINTENANCE\n")));}
    if (m_eInstallMode == IM_DEGRADE){iisDebugOut((iDoOnlyInThisMode, _T("m_eInstallMode=IM_DEGRADE\n")));}

    if (m_dwSetupMode & SETUPMODE_UPGRADE){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_UPGRADE\n")));}
    if (m_dwSetupMode == SETUPMODE_UPGRADEONLY){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_UPGRADE | SETUPMODE_UPGRADEONLY\n")));}
    if (m_dwSetupMode == SETUPMODE_ADDEXTRACOMPS){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_UPGRADE | SETUPMODE_ADDEXTRACOMPS\n")));}
    if (m_dwSetupMode & SETUPMODE_UPGRADE){iisDebugOut((iDoOnlyInThisMode, _T("m_bUpgradeTypeHasMetabaseFlag=%d\n"),m_bUpgradeTypeHasMetabaseFlag));}

    if (m_dwSetupMode & SETUPMODE_MAINTENANCE){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_MAINTENANCE\n")));}
    if (m_dwSetupMode == SETUPMODE_ADDREMOVE){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_MAINTENANCE | SETUPMODE_ADDREMOVE\n")));}
    if (m_dwSetupMode == SETUPMODE_REINSTALL){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_MAINTENANCE | SETUPMODE_REINSTALL\n")));}
    if (m_dwSetupMode == SETUPMODE_REMOVEALL){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_MAINTENANCE | SETUPMODE_REMOVEALL\n")));}

    if (m_dwSetupMode & SETUPMODE_FRESH){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_FRESH\n")));}
    if (m_dwSetupMode == SETUPMODE_MINIMAL){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_FRESH | SETUPMODE_MINIMAL\n")));}
    if (m_dwSetupMode == SETUPMODE_TYPICAL){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_FRESH | SETUPMODE_TYPICAL\n")));}
    if (m_dwSetupMode == SETUPMODE_CUSTOM){iisDebugOut((iDoOnlyInThisMode, _T("m_dwSetupMode=SETUPMODE_FRESH | SETUPMODE_CUSTOM\n")));}

    iisDebugOut((iDoOnlyInThisMode, _T("m_bPleaseDoNotInstallByDefault=%d\n"), m_bPleaseDoNotInstallByDefault));
    
    //if (m_bRefreshSettings == TRUE){iisDebugOut((iDoOnlyInThisMode, _T("m_bRefreshSettings=refresh files + refresh all settings\n")));}
    //if (m_bRefreshSettings == FALSE){iisDebugOut((iDoOnlyInThisMode, _T("m_bRefreshSettings=refresh files only\n")));}

    if (m_eAction == AT_DO_NOTHING){iisDebugOut((iDoOnlyInThisMode, _T("m_eAction=AT_DO_NOTHING\n")));}
    if (m_eAction == AT_REMOVE){iisDebugOut((iDoOnlyInThisMode, _T("m_eAction=AT_REMOVE\n")));}
    if (m_eAction == AT_INSTALL_FRESH){iisDebugOut((iDoOnlyInThisMode, _T("m_eAction=AT_INSTALL_FRESH\n")));}
    if (m_eAction == AT_INSTALL_UPGRADE){iisDebugOut((iDoOnlyInThisMode, _T("m_eAction=AT_INSTALL_UPGRADE\n")));}
    if (m_eAction == AT_INSTALL_REINSTALL){iisDebugOut((iDoOnlyInThisMode, _T("m_eAction=AT_INSTALL_REINSTALL\n")));}

    iisDebugOut((iDoOnlyInThisMode, _T("m_fNTOperationFlags=0x%x\n"), m_fNTOperationFlags));
    iisDebugOut((iDoOnlyInThisMode, _T("m_fNTGuiMode=%d\n"), m_fNTGuiMode));
    iisDebugOut((iDoOnlyInThisMode, _T("m_fInvokedByNT=%d\n"), m_fInvokedByNT));
    iisDebugOut((iDoOnlyInThisMode, _T("m_fNtWorkstation=%d\n"), m_fNtWorkstation));

    iisDebugOut((iDoOnlyInThisMode, _T("m_fUnattended=%d\n"), m_fUnattended));
    iisDebugOut((iDoOnlyInThisMode, _T("m_csUnattendFile=%s\n"), m_csUnattendFile));;
    iisDebugOutSafeParams((iDoOnlyInThisMode, _T("m_csPathSrcDir=%1!s!\n"), m_csPathSrcDir));;
    iisDebugOut((iDoOnlyInThisMode, _T("=======================\n")));

    }
    return;
}


int AreWeCurrentlyInstalled()
{
    int iReturn = FALSE;
    DWORD dwMajorVersion = 0;

    CRegKey regINetStp( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);
    if ((HKEY) regINetStp)
    {
        LONG lReturnedErrCode = regINetStp.QueryValue(_T("MajorVersion"), dwMajorVersion);
        if (lReturnedErrCode == ERROR_SUCCESS)
        {
            if (dwMajorVersion == 5) 
            {
                iReturn = TRUE;
            }
        }
    }
    return iReturn;
}


#define sz_PreviousIISVersion_string _T("PreviousIISVersion")
int CInitApp::SetUpgradeType(void)
{
    int iReturn = FALSE;
    DWORD dwMajorVersion = 0;
    DWORD dwMinorVersion = 0;
    CString csFrontPage;

    m_eInstallMode = IM_UPGRADE;
    m_eUpgradeType = UT_NONE;
    m_bUpgradeTypeHasMetabaseFlag = FALSE;
    m_bPleaseDoNotInstallByDefault = TRUE;

    CRegKey regINetStp( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);
    if ((HKEY) regINetStp)
    {
        LONG lReturnedErrCode = regINetStp.QueryValue(_T("MajorVersion"), dwMajorVersion);
        if (lReturnedErrCode == ERROR_SUCCESS)
        {
            if (dwMajorVersion <= 1)
            {
                m_eUpgradeType = UT_10;
                m_eInstallMode = IM_UPGRADE;
                m_bUpgradeTypeHasMetabaseFlag = FALSE;
                m_bPleaseDoNotInstallByDefault = FALSE;
                iReturn = TRUE;
                iisDebugOut((LOG_TYPE_TRACE, _T("%s=0x%x.\n"),sz_PreviousIISVersion_string, dwMajorVersion));
                goto SetUpgradeType_Exit;
            }
            if (dwMajorVersion == 2)
            {
                m_eUpgradeType = UT_20;
                m_eInstallMode = IM_UPGRADE;
                m_bUpgradeTypeHasMetabaseFlag = FALSE;
                m_bPleaseDoNotInstallByDefault = FALSE;
                iReturn = TRUE;
                iisDebugOut((LOG_TYPE_TRACE, _T("%s=0x%x.\n"),sz_PreviousIISVersion_string, dwMajorVersion));
                goto SetUpgradeType_Exit;
            }
            if (dwMajorVersion == 3)
            {
                m_eUpgradeType = UT_30;
                m_eInstallMode = IM_UPGRADE;
                m_bUpgradeTypeHasMetabaseFlag = FALSE;
                m_bPleaseDoNotInstallByDefault = FALSE;
                iReturn = TRUE;
                iisDebugOut((LOG_TYPE_TRACE, _T("%s=0x%x.\n"),sz_PreviousIISVersion_string, dwMajorVersion));
                goto SetUpgradeType_Exit;
            }
            if (dwMajorVersion == 4)
            {
                CString csSetupString;
                m_eUpgradeType = UT_40; 
                m_eInstallMode = IM_UPGRADE;
                m_bUpgradeTypeHasMetabaseFlag = TRUE;
                m_bPleaseDoNotInstallByDefault = FALSE;
                iReturn = TRUE;
                regINetStp.m_iDisplayWarnings = FALSE;
                if (regINetStp.QueryValue(_T("SetupString"), csSetupString) == NERR_Success) 
                {
                    if (csSetupString.CompareNoCase(_T("K2 RTM")) != 0) 
                    {
                        // Error: upgrade not supported on K2 Beta versions
                        // Do a fresh if it's k2 beta2!!!!
                        m_eInstallMode = IM_FRESH;
                        m_eUpgradeType = UT_NONE;
                        m_bUpgradeTypeHasMetabaseFlag = FALSE;
                        m_bPleaseDoNotInstallByDefault = FALSE;
                        iReturn = FALSE;
                        iisDebugOut((LOG_TYPE_TRACE, _T("%s=0x%x.Beta2.\n"),sz_PreviousIISVersion_string, dwMajorVersion));
                        goto SetUpgradeType_Exit;
                    }
                }
                iisDebugOut((LOG_TYPE_TRACE, _T("%s=0x%x.\n"),sz_PreviousIISVersion_string, dwMajorVersion));
                goto SetUpgradeType_Exit;
            }
            if (dwMajorVersion == 5) 
            {
                // There is a previous version of iis5 on the machine...
                // Could be they are upgrading from nt5Workstation to and nt5Server machine!
                // or from and server to a workstation!  what a nightmare!!!
                //m_eInstallMode = IM_FRESH;
                m_eUpgradeType = UT_50;
                m_eInstallMode = IM_UPGRADE;
                m_bUpgradeTypeHasMetabaseFlag = TRUE;
                m_bPleaseDoNotInstallByDefault = FALSE;

                regINetStp.m_iDisplayWarnings = FALSE;
                if (regINetStp.QueryValue(_T("MinorVersion"), dwMinorVersion) == NERR_Success) 
                {
                    if (dwMinorVersion >= 1)
                    {
	                m_eUpgradeType = UT_51;
        	        m_eInstallMode = IM_UPGRADE;
                	m_bUpgradeTypeHasMetabaseFlag = TRUE;
	                m_bPleaseDoNotInstallByDefault = FALSE;
                    }
                }
                iReturn = TRUE;
                iisDebugOut((LOG_TYPE_TRACE, _T("%s=0x%x.0x%x\n"),sz_PreviousIISVersion_string, dwMajorVersion,dwMinorVersion));
                goto SetUpgradeType_Exit;
            }
            if (dwMajorVersion == 6) 
            {
                // There is a previous version of iis5 on the machine...
                // Could be they are upgrading from nt5Workstation to and nt5Server machine!
                // or from and server to a workstation!  what a nightmare!!!
                //m_eInstallMode = IM_FRESH;
                m_eUpgradeType = UT_60;
                m_eInstallMode = IM_UPGRADE;
                m_bUpgradeTypeHasMetabaseFlag = TRUE;
                m_bPleaseDoNotInstallByDefault = FALSE;
                iReturn = TRUE;
                iisDebugOut((LOG_TYPE_TRACE, _T("%s=0x%x.0x%x\n"),sz_PreviousIISVersion_string, dwMajorVersion,dwMinorVersion));
                goto SetUpgradeType_Exit;
            }

            if (dwMajorVersion > 6)
            {
                m_eInstallMode = IM_UPGRADE;
                m_eUpgradeType = UT_60;
                m_bUpgradeTypeHasMetabaseFlag = FALSE;
                m_bPleaseDoNotInstallByDefault = TRUE;
                iReturn = TRUE;
                iisDebugOut((LOG_TYPE_TRACE, _T("%s=0x%x.0x%x\n"),sz_PreviousIISVersion_string, dwMajorVersion,dwMinorVersion));
                goto SetUpgradeType_Exit;
            }

            // if we get here, then that means
            // that we found a version like 7.0 or something
            // which we should not upgrade since it is newer than us.
            // but hey we're in upgrade mode, so we should set something
            m_eInstallMode = IM_UPGRADE;
            m_eUpgradeType = UT_NONE;
            m_bUpgradeTypeHasMetabaseFlag = FALSE;
            m_bPleaseDoNotInstallByDefault = TRUE;
            iReturn = FALSE;
            iisDebugOut((LOG_TYPE_TRACE, _T("%s=some other iis version\n"),sz_PreviousIISVersion_string));
        }
    }

    // -----------------------------------
    //
    // Check for other Rogue versions of IIS
    // 
    // win95 pws 1.0
    // win95 fontpage installed pws 1.0 (actually totally different from pws 1.0)
    //
    // on NT5 we are able to upgrade from:
    //   Win95 pws 1.0
    //   Win95 pws 4.0
    // on win95 pws 1.0, there was no inetstp dir
    // so we must check other things.
    // -----------------------------------
    {
    CRegKey regW3SVC(HKEY_LOCAL_MACHINE, REG_WWWPARAMETERS, KEY_READ);
    if ((HKEY)regW3SVC) 
    {
        CByteArray baMajorVersion;
        regW3SVC.m_iDisplayWarnings = FALSE;
        if (regW3SVC.QueryValue(_T("MajorVersion"), baMajorVersion) == NERR_Success) 
        {
            // Check if we can read the MajorVersion value should be set to '\0' if pws 1.0
            if (baMajorVersion[0] == '\0')
            {
                m_eUpgradeType = UT_10_W95;
                m_eInstallMode = IM_UPGRADE;
                m_bUpgradeTypeHasMetabaseFlag = FALSE;
                m_bPleaseDoNotInstallByDefault = FALSE;
                iReturn = TRUE;
                iisDebugOut((LOG_TYPE_TRACE, _T("%s=1.\n"),sz_PreviousIISVersion_string));
                goto SetUpgradeType_Exit;
            }
        }
    }
    }

    //
    // on win 95 there could be an
    // installation of frontpg pws version 1.0
    // we don't support upgrading this, so we'll do a fresh if we ever get here.
    //
    csFrontPage = g_pTheApp->m_csSysDir + _T("\\frontpg.ini");
    if (IsFileExist(csFrontPage)) 
    {
        TCHAR buf[_MAX_PATH];
        GetPrivateProfileString(_T("FrontPage 1.1"), _T("PWSRoot"), _T(""), buf, _MAX_PATH, csFrontPage);
        if (*buf && IsFileExist(buf)) 
        {
            m_eInstallMode = IM_FRESH;
            m_eUpgradeType = UT_NONE;
            m_bUpgradeTypeHasMetabaseFlag = FALSE;
            m_bPleaseDoNotInstallByDefault = FALSE;
            iReturn = TRUE;
            iisDebugOut((LOG_TYPE_TRACE, _T("%s=1.FrontPage Installation.\n"),sz_PreviousIISVersion_string));
            goto SetUpgradeType_Exit;
        }
    }

    //
    // This could be an upgrade from WinNT 3.51
    // which could have an FTPSVC installed.
    // if it's here then install ftp.
    // Software\Microsoft\FTPSVC
    //
    {
    CRegKey regNT351FTP(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\FTPSVC"), KEY_READ);
    if ((HKEY) regNT351FTP)
    {
        m_eUpgradeType = UT_351;
        m_eInstallMode = IM_UPGRADE;
        m_bUpgradeTypeHasMetabaseFlag = FALSE;
        m_bPleaseDoNotInstallByDefault = FALSE;
        iReturn = TRUE;
        iisDebugOut((LOG_TYPE_TRACE, _T("%s=NT351.ftp.\n"),sz_PreviousIISVersion_string));
        goto SetUpgradeType_Exit;
    }
    }

    // if we get here...then
    // 1. we were not able to open the inetsrv reg
    // 2. did not find an old pws 1.0 installation
    // 3. did not find an old frontpg pws installation.
    // 4. did not find nt 3.51 FTPSVC installed.

    // since this is supposed to set the upgrade type, and there is nothing to upgrade...
    // then we will Not install.....
    //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("FRESH FRESH FRESH\n")));
    m_eInstallMode = IM_UPGRADE;
    m_eUpgradeType = UT_NONE;
    m_bUpgradeTypeHasMetabaseFlag = FALSE;
    m_bPleaseDoNotInstallByDefault = TRUE;
    iisDebugOut((LOG_TYPE_TRACE, _T("%s=None.\n"),sz_PreviousIISVersion_string));
    iReturn = FALSE;

SetUpgradeType_Exit:
    return iReturn;
}


int CInitApp::Check_Custom_InetPub(void)
{
    int iReturn = FALSE;
    INFCONTEXT Context;
    TCHAR szSectionName[_MAX_PATH];
    TCHAR szValue0[_MAX_PATH] = _T("");
    TCHAR szValue[_MAX_PATH] = _T("");

    // Do this only if unattended install
    if (!g_pTheApp->m_fUnattended) {return iReturn;}

    // The section name to look for in the unattended file
    _tcscpy(szSectionName, UNATTEND_FILE_SECTION);

    //
    // InetPub
    //
    *szValue = NULL;
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, szSectionName, _T("PathInetpub"), &Context) ) 
        {SetupGetStringField(&Context, 1, szValue, _MAX_PATH, NULL);}
    if (*szValue)
    {
        // check szValue for an string substitutions...
        // %windir%, etc...
        _tcscpy(szValue0, szValue);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szValue0, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {_tcscpy(szValue,szValue0);}
        if (IsValidDirectoryName(szValue))
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("Check_Custom_InetPub:PathInetpub=%s\n"),szValue));
            m_csPathInetpub = szValue;
            iReturn = TRUE;
            g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_PATH_INETPUB;
        }
        else
        {
            iisDebugOut((LOG_TYPE_WARN, _T("Check_Custom_InetPub:PathInetpub=%s.Not Valid.ignoring unattend value. WARNING.\n"),szValue));
        }
    }
    return iReturn;
}


void CInitApp::Check_Unattend_Settings(void)
{
    // if there are unattended values specified for the ftp or www root,
    // then set them here.
    Check_Custom_WWW_or_FTP_Path();
    DeriveInetpubFromWWWRoot();

    // Check if there is an alternate iis.inf specified in the unattend file.
    // this way the user can change sections in the iis.inf file without changing the iis.inf file itself
    Check_Custom_IIS_INF();

    // Check if the user wants to use a specific iusr\iwam name.
    Check_Custom_Users();

    // Check if user wants applications setup in inprocess by default (not pooled out of process)

    return;
}

void Check_Custom_Users(void)
{
    INFCONTEXT Context;
    TCHAR szSectionName[_MAX_PATH];
    TCHAR szValue0[_MAX_PATH] = _T("");
    TCHAR szValue[_MAX_PATH] = _T("");

    // Do this only if unattended install
    if (!g_pTheApp->m_fUnattended) {return;}

    // The section name to look for in the unattended file
    _tcscpy(szSectionName, UNATTEND_FILE_SECTION);

    //
    // IUSR:  BOTH FTP AND WWW
    //
    *szValue = NULL;
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, szSectionName, _T("IUSR"), &Context) ) 
        {SetupGetStringField(&Context, 1, szValue, _MAX_PATH, NULL);}
    if (*szValue)
    {
        // check szValue for an string substitutions...
        // %windir%, etc...
        _tcscpy(szValue0, szValue);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szValue0, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {_tcscpy(szValue,szValue0);}

        if (_tcsicmp(szValue, _T("")) != 0)
        {
            // assign it to the appropriate member variables.
            g_pTheApp->m_csWWWAnonyName_Unattend = szValue;
            g_pTheApp->m_csFTPAnonyName_Unattend = szValue;

            g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_NAME;
            g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_NAME;

            iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Custom iusr specified for ftp/www\n")));
        }
    }

    //
    // IUSR:  BOTH FTP AND WWW password
    //
    *szValue = NULL;
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, szSectionName, _T("IUSR_PASS"), &Context) ) 
        {SetupGetStringField(&Context, 1, szValue, _MAX_PATH, NULL);}
    if (*szValue)
    {
        // check szValue for an string substitutions...
        // %windir%, etc...
        _tcscpy(szValue0, szValue);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szValue0, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {_tcscpy(szValue,szValue0);}

        // assign it to the appropriate member variables.
        if (_tcsicmp(szValue, _T("")) != 0)
        {
            g_pTheApp->m_csWWWAnonyPassword_Unattend = szValue;
            g_pTheApp->m_csFTPAnonyPassword_Unattend = szValue;

            g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_PASS;
            g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_PASS;

            iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Custom iusr pass specified for ftp/www\n"))); 
        }
    }

    //
    // IUSR: FTP
    // If there a value specified here, then it will override the one taken from "IUSR"
    //
    *szValue = NULL;
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, szSectionName, _T("IUSR_FTP"), &Context) ) 
        {SetupGetStringField(&Context, 1, szValue, _MAX_PATH, NULL);}
    if (*szValue)
    {
        // check szValue for an string substitutions...
        // %windir%, etc...
        _tcscpy(szValue0, szValue);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szValue0, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {_tcscpy(szValue,szValue0);}

        if (_tcsicmp(szValue, _T("")) != 0)
        {
            // assign it to the appropriate member variables.
            g_pTheApp->m_csFTPAnonyName_Unattend = szValue;
            //g_pTheApp->m_csFTPAnonyPassword_Unattend = _T("");

            g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_NAME;

            iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Custom iusr specified for ftp\n"))); 
        }
    }
    //
    // IUSR: FTP password
    //
    *szValue = NULL;
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, szSectionName, _T("IUSR_FTP_PASS"), &Context) ) 
        {SetupGetStringField(&Context, 1, szValue, _MAX_PATH, NULL);}
    if (*szValue)
    {
        // check szValue for an string substitutions...
        // %windir%, etc...
        _tcscpy(szValue0, szValue);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szValue0, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {_tcscpy(szValue,szValue0);}

        if (_tcsicmp(szValue, _T("")) != 0)
        {
            // assign it to the appropriate member variables.
            g_pTheApp->m_csFTPAnonyPassword_Unattend = szValue;
            g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_PASS;

            iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Custom iusr pass specified for ftp\n"))); 
        }
    }

    //
    // IUSR: WWW
    // If there a value specified here, then it will override the one taken from "IUSR"
    //
    *szValue = NULL;
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, szSectionName, _T("IUSR_WWW"), &Context) ) 
        {SetupGetStringField(&Context, 1, szValue, _MAX_PATH, NULL);}
    if (*szValue)
    {
        // check szValue for an string substitutions...
        // %windir%, etc...
        _tcscpy(szValue0, szValue);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szValue0, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {_tcscpy(szValue,szValue0);}
        // assign it to the appropriate member variables.
        g_pTheApp->m_csWWWAnonyName_Unattend = szValue;
        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_NAME;
        //g_pTheApp->m_csWWWAnonyPassword_Unattend = _T("");
        iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Custom iusr specified for www\n"))); 
    }
    //
    // IUSR: WWW password
    // If there a value specified here, then it will override the one taken from "IUSR"
    //
    *szValue = NULL;
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, szSectionName, _T("IUSR_WWW_PASS"), &Context) ) 
        {SetupGetStringField(&Context, 1, szValue, _MAX_PATH, NULL);}
    if (*szValue)
    {
        // check szValue for an string substitutions...
        // %windir%, etc...
        _tcscpy(szValue0, szValue);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szValue0, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {_tcscpy(szValue,szValue0);}

        if (_tcsicmp(szValue, _T("")) != 0)
        {
            // assign it to the appropriate member variables.
            g_pTheApp->m_csWWWAnonyPassword_Unattend = szValue;
            g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_PASS;

            iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Custom iusr pass specified for www\n"))); 
        }
    }

    //
    // IWAM: WWW
    //
    *szValue = NULL;
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, szSectionName, _T("IWAM"), &Context) ) 
        {SetupGetStringField(&Context, 1, szValue, _MAX_PATH, NULL);}
    if (*szValue)
    {
        // check szValue for an string substitutions...
        // %windir%, etc...
        _tcscpy(szValue0, szValue);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szValue0, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {_tcscpy(szValue,szValue0);}

        // assign it to the appropriate member variables.
        g_pTheApp->m_csWAMAccountName_Unattend = szValue;
        //g_pTheApp->m_csWAMAccountPassword_Unattend = _T("");
        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WAM_USER_NAME;

        iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Custom iwam specified\n"))); 
    }
    //
    // IWAM: WWW password
    //
    *szValue = NULL;
    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, szSectionName, _T("IWAM_PASS"), &Context) ) 
        {SetupGetStringField(&Context, 1, szValue, _MAX_PATH, NULL);}
    if (*szValue)
    {
        // check szValue for an string substitutions...
        // %windir%, etc...
        _tcscpy(szValue0, szValue);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szValue0, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {_tcscpy(szValue,szValue0);}

        if (_tcsicmp(szValue, _T("")) != 0)
        {
            // assign it to the appropriate member variables.
            g_pTheApp->m_csWAMAccountPassword_Unattend = szValue;
            g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WAM_USER_PASS;

            iisDebugOut((LOG_TYPE_TRACE, _T("(unattend) Custom iwam pass specified\n"))); 
        }
    }

    return;
}


// reads the registry and fills up the list
void CInitApp::UnInstallList_RegRead()
{
    int iGetOut = FALSE;
    CString csBoth;
    CString csKey;
    CString csData;

    CRegKey regInetstp( HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);
    if ((HKEY) regInetstp)
    {
        int iPosition1;
        int iPosition2;
        int iPosition3;
        int iLength;
        CString csUninstallInfo;
        LONG lReturnedErrCode = regInetstp.QueryValue( REG_SETUP_UNINSTALLINFO, csUninstallInfo);
        if (lReturnedErrCode == ERROR_SUCCESS)
        {
            // add a "," to the end for parsing...
            iLength = csUninstallInfo.GetLength();
            if (iLength == 0)
            {
                goto UnInstallList_RegRead_Exit;
            }
            csUninstallInfo += _T(",");

            iPosition1 = 0;
#ifdef _CHICAGO_
            // quick fix so that it compiles under ansi
            // i guess Find(parm1,parm2) under ansi doesn't take 2 parms
#else
            iPosition1 = 0;
            iPosition2 = csUninstallInfo.Find(_T(','),iPosition1);
            iPosition3 = csUninstallInfo.Find(_T(','),iPosition2+1);
            if (-1 == iPosition3){iPosition3 = iLength + 1;}
            
            // loop thru and add to our list!
            iGetOut = FALSE;
            while (iGetOut == FALSE)
            {
                csKey = csUninstallInfo.Mid(iPosition1, iPosition2 - iPosition1);
                csData = csUninstallInfo.Mid(iPosition2+1, iPosition3 - (iPosition2 + 1));
                csKey.MakeUpper(); // uppercase the key
                //iisDebugOut((LOG_TYPE_TRACE, _T("  UnInstallList_RegRead: %s=%s\n"),csKey,csData));

                // add to our list
                m_cmssUninstallMapList.SetAt(csKey, csData);

                iPosition1 = iPosition3+1;
                iPosition2 = csUninstallInfo.Find(_T(','),iPosition1);
                if (-1 == iPosition2){iGetOut = TRUE;}
                
                iPosition3 = csUninstallInfo.Find(_T(','),iPosition2+1);
                if (-1 == iPosition3)
                {
                    iPosition3 = iLength + 1;
                    iGetOut = TRUE;
                }
            }
#endif
        }
    }
UnInstallList_RegRead_Exit:
    m_fUninstallMapList_Dirty = FALSE;
    return;
}

void CInitApp::UnInstallList_RegWrite()
{
    int i = 0;
    POSITION pos;
    CString csKey;
    CString csData;
    CString csAllData;
    csAllData = _T("");

    if (TRUE == m_fUninstallMapList_Dirty)
    {
        // loop thru the list to see if, we already have this entry
        if (m_cmssUninstallMapList.IsEmpty())
        {
            CRegKey regInetstp(REG_INETSTP,HKEY_LOCAL_MACHINE);
            if ((HKEY) regInetstp)
                {regInetstp.DeleteValue(REG_SETUP_UNINSTALLINFO);}
            //iisDebugOut((LOG_TYPE_TRACE, _T("  UnInstallList_RegWrite: empty\n")));
        }
        else
        {
            pos = m_cmssUninstallMapList.GetStartPosition();
            while (pos)
            {
                i++;
                csKey.Empty();
                csData.Empty();
                m_cmssUninstallMapList.GetNextAssoc(pos, csKey, csData);
                if (i > 1)
                {
                    csAllData += _T(",");
                }
                csAllData += csKey;
                csAllData += _T(",");
                csAllData += csData;
            }
            // write out csAllData
            CRegKey regInetstp(REG_INETSTP,HKEY_LOCAL_MACHINE);
            if ((HKEY) regInetstp)
            {
                regInetstp.SetValue(REG_SETUP_UNINSTALLINFO,csAllData);
            }
            else
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("UnInstallList_RegWrite: failed! not writen!!!\n")));
            }
        }
    }
}

void CInitApp::UnInstallList_Add(CString csItemUniqueKeyName,CString csDataToAdd)
{
    CString csGottenValue;

    csItemUniqueKeyName.MakeUpper(); // uppercase the key
    if (TRUE == m_cmssUninstallMapList.Lookup(csItemUniqueKeyName, csGottenValue))
    {
        // found the key, replace the value
        m_cmssUninstallMapList.SetAt(csItemUniqueKeyName, csDataToAdd);
    }
    else
    {
        // add the key and value pair
        m_cmssUninstallMapList.SetAt(csItemUniqueKeyName, csDataToAdd);
    }

    iisDebugOut((LOG_TYPE_TRACE, _T("UnInstallList_Add:please addkey=%s,%s\n"),csItemUniqueKeyName,csDataToAdd));
    m_fUninstallMapList_Dirty = TRUE;
}

void CInitApp::UnInstallList_DelKey(CString csItemUniqueKeyName)
{
    iisDebugOut((LOG_TYPE_TRACE, _T("UnInstallList_DelKey:please delkey=%s\n"),csItemUniqueKeyName));
    csItemUniqueKeyName.MakeUpper(); // uppercase the key
    m_cmssUninstallMapList.RemoveKey(csItemUniqueKeyName);
    m_fUninstallMapList_Dirty = TRUE;
}


void CInitApp::UnInstallList_DelData(CString csDataValue)
{
    POSITION pos;
    CString csKey;
    CString csData;
    
    // loop thru the list to see if, we already have this entry
    if (m_cmssUninstallMapList.IsEmpty())
    {
    }
    else
    {
        pos = m_cmssUninstallMapList.GetStartPosition();
        while (pos)
        {
            csKey.Empty();
            csData.Empty();
            m_cmssUninstallMapList.GetNextAssoc(pos, csKey, csData);
            if ( _tcsicmp(csData, csDataValue) == 0)
            {
                UnInstallList_DelKey(csKey);
            }
        }
    }
}


void CInitApp::UnInstallList_Dump()
{
    POSITION pos;
    CString csKey;
    CString csData;
    
    // loop thru the list to see if, we already have this entry
    if (m_cmssUninstallMapList.IsEmpty())
    {
        //iisDebugOut((LOG_TYPE_TRACE, _T("  UnInstallList_Dump: empty\n")));
    }
    else
    {
        pos = m_cmssUninstallMapList.GetStartPosition();
        while (pos)
        {
            csKey.Empty();
            csData.Empty();
            m_cmssUninstallMapList.GetNextAssoc(pos, csKey, csData);
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("  UnInstallList_Dump: %s=%s\n"), csKey, csData));
        }
    }
}

// Get values from list into our Variables!
void CInitApp::UnInstallList_SetVars()
{
    POSITION pos;
    CString csKey;
    CString csData;
    
    // loop thru the list to see if, we already have this entry
    if (m_cmssUninstallMapList.IsEmpty())
    {
        //iisDebugOut((LOG_TYPE_TRACE, _T("  UnInstallList_Dump: empty\n")));
    }
    else
    {
        pos = m_cmssUninstallMapList.GetStartPosition();
        while (pos)
        {
            csKey.Empty();
            csData.Empty();
            m_cmssUninstallMapList.GetNextAssoc(pos, csKey, csData);

            if ( _tcsicmp(csKey, _T("IUSR_WAM")) == 0)
            {
                m_csWAMAccountName_Remove = csData;
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("UnInstallList_SetVars: m_csWAMAccountName_Remove=%s\n"), m_csWAMAccountName_Remove));
            }
            else if ( _tcsicmp(csKey, _T("IUSR_WWW")) == 0)
            {
                m_csWWWAnonyName_Remove = csData;
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("UnInstallList_SetVars: m_csWWWAnonyName_Remove=%s\n"), m_csWWWAnonyName_Remove));
            }
            else if ( _tcsicmp(csKey, _T("IUSR_FTP")) == 0)
            {
                m_csFTPAnonyName_Remove = csData;
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("UnInstallList_SetVars: m_csFTPAnonyName_Remove=%s\n"), m_csFTPAnonyName_Remove));
            }
        }
    }
}


CString CInitApp::UnInstallList_QueryKey(CString csItemUniqueKeyName)
{
    CString csGottenValue;
    csGottenValue.Empty();

    csItemUniqueKeyName.MakeUpper(); // uppercase the key
    m_cmssUninstallMapList.Lookup(csItemUniqueKeyName, csGottenValue);

    return csGottenValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\ftp.cpp ===
#include "stdafx.h"
#include <ole2.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"
#include "mdentry.h"
#include "mdacl.h"
#include "setpass.h"
#include "www.h"
#include "dllmain.h"

#ifndef _CHICAGO_
    int Register_iis_ftp_handle_iusr_acct(void);
    int CheckForOtherIUsersAndUseItForFTP(void);
#endif // _CHICAGO_
INT Register_iis_ftp(void);
INT Unregister_iis_ftp(void);

// returns true if successfully registered ftp component.
// returns false if failed.
INT Register_iis_ftp()
{
    iisDebugOut_Start(_T("Register_iis_ftp"),LOG_TYPE_TRACE);
    int iReturn = TRUE;
    int iTempFlag = TRUE;
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    ACTION_TYPE atFTP = GetSubcompAction(_T("iis_ftp"), TRUE);

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_ftp_before"));
    AdvanceProgressBarTickGauge();

#ifndef _CHICAGO_
    // Grab the IUSR_machine name account
    // so we can save it in the metabase during FTP_Upgrade_RegToMetabase();
    Register_iis_ftp_handle_iusr_acct();
    SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle, 33003, g_pTheApp->m_csFTPAnonyName);
    AdvanceProgressBarTickGauge();
#endif // _CHICAGO_

    WriteToMD_Capabilities(_T("MSFTPSVC"));
    HandleSecurityTemplates(_T("MSFTPSVC"));
    // ================
    //
    // LM/MSFTPSVC/n/
    // LM/MSFTPSVC/n/ServerBindings
    // LM/MSFTPSVC/n/SecureBindings
    // LM/MSFTPSVC/n/ServerComment
    // LM/MSFTPSVC/n/ServerSize
    // LM/MSFTPSVC/n/MD_NOT_DELETABLE
    //
    // fresh = ok.
    // reinstall = ok -- Do not re-create these things if it is a reinstall...
    // upgrade 1,2,3 = ok, handles upgrades.
    // upgrade 4     = ok.  if exists, should leave what the user had.
    //                 otherwise write in the default stuff
    //
    //                 if the user does not have these virtual roots which we installed during iis4 days
    //                 then we don't need to verify that they are they.  the user removed them for some
    //                 reason, and we should honor that.
    //                 a. make sure the iishelp points to the right place though.
    // ================
    ProgressBarTextStack_Set(IDS_IIS_ALL_CONFIGURE);
    AddVRootsToMD(_T("MSFTPSVC"));

    iCount = 0;
    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("register_iis_ftp_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_ftp_after"));

    ProgressBarTextStack_Pop();
    goto Register_iis_ftp_Exit;

Register_iis_ftp_Exit:
    iisDebugOut_End(_T("Register_iis_ftp"),LOG_TYPE_TRACE);
    return iReturn;
}


INT Unregister_iis_ftp()
{
    int iReturn = TRUE;
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_ftp_before"));
    AdvanceProgressBarTickGauge();

    iCount = 0;
    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("unregister_iis_ftp_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_ftp_after"));
    AdvanceProgressBarTickGauge();
    return iReturn;
}

#ifndef _CHICAGO_


int Register_iis_ftp_handle_iusr_acct()
{
    int err = FALSE;
    int iReturn = TRUE;
    INT iUserWasNewlyCreated = 0;

    ACTION_TYPE atFTP = GetSubcompAction(_T("iis_ftp"),FALSE);

    // this was inited in initapp.cpp: CInitApp::SetSetupParams
    // and it could have been overridden by the time we get here
    g_pTheApp->m_csFTPAnonyName = g_pTheApp->m_csGuestName;
    g_pTheApp->m_csFTPAnonyPassword = g_pTheApp->m_csGuestPassword;

    if (0 != g_pTheApp->dwUnattendConfig)
    {
        // if some sort of unattended www user was specified
        // then use it.  if they specified only a password,
        // then use that password for the default user.
        if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_FTP_USER_NAME)
        {
            if (_tcsicmp(g_pTheApp->m_csFTPAnonyName_Unattend,_T("")) != 0)
            {
                g_pTheApp->m_csFTPAnonyName = g_pTheApp->m_csFTPAnonyName_Unattend;
            }
        }

        if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_FTP_USER_PASS)
        {
            g_pTheApp->m_csFTPAnonyPassword = g_pTheApp->m_csFTPAnonyPassword_Unattend;
        }

        err = CreateIUSRAccount(g_pTheApp->m_csFTPAnonyName, g_pTheApp->m_csFTPAnonyPassword,&iUserWasNewlyCreated);
        if ( err != NERR_Success )
        {
            // something went wrong, set the user back to guest!!!
            g_pTheApp->m_csFTPAnonyName = g_pTheApp->m_csGuestName;
            g_pTheApp->m_csFTPAnonyPassword = g_pTheApp->m_csGuestPassword;

            // flow down and process CheckIfThisServerHasAUserThenUseIt()
            // since things are now hosed!
        }
        else
        {
            // Check if the user was NewlyCreated.
            // if it was then add it to list that eventually gets written to
            // the registry -- so that when uninstall happens, setup knows
            // which users it added -- so that it can remove them!
            if (1 == iUserWasNewlyCreated)
            {
                // Add to the list
                g_pTheApp->UnInstallList_Add(_T("IUSR_FTP"),g_pTheApp->m_csFTPAnonyName);
            }
            WriteToMD_AnonymousUserName_FTP(FALSE);
            goto Register_iis_ftp_handle_iusr_acct_Exit;
        }
    }

    // check the metabase to see if it already has an entry in it
    if (TRUE == CheckIfThisServerHasAUserThenUseIt(DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER))
        {goto Register_iis_ftp_handle_iusr_acct_Exit;}

    // Well, i guess the there is no metabase entry for the iusr under ftp.

    // see if we can get it from somewhere else...
    if (atFTP == AT_INSTALL_FRESH)
    {
        // if this is a fresh install of ftp, then
        // let's try to use the www user
        if (TRUE == CheckIfServerAHasAUserThenUseForServerB(_T("LM/W3SVC"), DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER))
            {goto Register_iis_ftp_handle_iusr_acct_Exit;}
    }

    // if this is an upgrade or fresh or whatevers
    // see if we can get it from an older iis place
    if (TRUE == CheckForOtherIUsersAndUseItForFTP())
        {goto Register_iis_ftp_handle_iusr_acct_Exit;}

    // if there are no registry/existing user combinations
    // then we'll have to create a new iusr for ftp

    // let's use the iusr_computername deal
    g_pTheApp->m_csFTPAnonyName = g_pTheApp->m_csGuestName;
    g_pTheApp->m_csFTPAnonyPassword = g_pTheApp->m_csGuestPassword;
    CreateIUSRAccount(g_pTheApp->m_csFTPAnonyName, g_pTheApp->m_csFTPAnonyPassword,&iUserWasNewlyCreated);

    // ================
    // LM/MSFTPSVC/AnonymousUserName
    // LM/MSFTPSVC/AnonymousPwd
    // ================
    WriteToMD_AnonymousUserName_FTP(FALSE);
    goto Register_iis_ftp_handle_iusr_acct_Exit;
    
Register_iis_ftp_handle_iusr_acct_Exit:
    return iReturn;
}


// Look in the old iis1.0,2.0,3.0 spot for the ftp user and name.
// retrieve it from the registry..
int CheckForOtherIUsersAndUseItForFTP(void)
{
    int iReturn = FALSE;
    int IfTheUserNotExistThenDoNotDoThis = TRUE;

    TCHAR szAnonyName[UNLEN+1];
    CString csAnonyName;
    TCHAR szAnonyPassword[PWLEN+1];

    CRegKey regFTPParam(HKEY_LOCAL_MACHINE, REG_FTPPARAMETERS, KEY_READ);
    CRegKey regWWWParam(HKEY_LOCAL_MACHINE, REG_WWWPARAMETERS, KEY_READ);

    iisDebugOut_Start(_T("CheckForOtherIUsersAndUseItForFTP"));

    ACTION_TYPE atFTP = GetSubcompAction(_T("iis_ftp"),FALSE);
    if (atFTP != AT_INSTALL_UPGRADE)
        {goto CheckForOtherIUsersAndUseItForFTP_Exit;}

    if (g_pTheApp->m_eUpgradeType != UT_351 && g_pTheApp->m_eUpgradeType != UT_10 && g_pTheApp->m_eUpgradeType != UT_20 && g_pTheApp->m_eUpgradeType != UT_30)
        {goto CheckForOtherIUsersAndUseItForFTP_Exit;}

    if ( (HKEY) regFTPParam ) 
    {
        regFTPParam.m_iDisplayWarnings = FALSE;
        if (ERROR_SUCCESS == regFTPParam.QueryValue(_T("AnonymousUserName"), csAnonyName))
        {
            _tcscpy(szAnonyName, csAnonyName);
            GetAnonymousSecret( _T("FTPD_ANONYMOUS_DATA"), (LPTSTR)szAnonyPassword );
            int iThisIsFalseBecauseNoMetabase = FALSE;
            if (TRUE == MakeThisUserNameAndPasswordWork(DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER , szAnonyName, szAnonyPassword, iThisIsFalseBecauseNoMetabase, IfTheUserNotExistThenDoNotDoThis))
            {
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CheckForOtherIUsersAndUseItForFTP:using old ftp reg usr:%s.\n"),szAnonyName));
                iReturn = TRUE;
                goto CheckForOtherIUsersAndUseItForFTP_Exit;
            }
            else
            {
                // the user was not found, so don't use this registry data
                // just flow down to the next check
            }
        }
    }

    // retrieve from registry
    if ( (HKEY) regWWWParam ) 
    {
        regWWWParam.m_iDisplayWarnings = FALSE;
        if (ERROR_SUCCESS == regWWWParam.QueryValue(_T("AnonymousUserName"), csAnonyName))
        {
            _tcscpy(szAnonyName, csAnonyName);
            GetAnonymousSecret( _T("W3_ANONYMOUS_DATA"), szAnonyPassword );
            int iThisIsFalseBecauseNoMetabase = FALSE;
            if (TRUE == MakeThisUserNameAndPasswordWork(DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER , szAnonyName, szAnonyPassword, iThisIsFalseBecauseNoMetabase, IfTheUserNotExistThenDoNotDoThis))
            {
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CheckForOtherIUsersAndUseItForFTP:using old www reg usr:%s.\n"),szAnonyName));
                iReturn = TRUE;
            }
            else
            {
                // if this didn't work, then we'll have to return false
                // in other words -- we couldn't find a valid registry and existing user entry...
                iReturn = FALSE;
            }
            goto CheckForOtherIUsersAndUseItForFTP_Exit;
        }
    }

CheckForOtherIUsersAndUseItForFTP_Exit:
    iisDebugOut_End(_T("CheckForOtherIUsersAndUseItForFTP"));
    return iReturn;
}

#endif // _CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\htmla.cpp ===
#include "stdafx.h"
#include <time.h>
#include <stdlib.h>
#include <ole2.h>
#include "iadmw.h"
#include "iiscnfgp.h"
#include "mdkey.h"
#include "mdentry.h"
#include "mdacl.h"
#include "svc.h"
#include "dllmain.h"

#define PORT_NUM_MIN 2000
#define PORT_NUM_MAX 9999

extern OCMANAGER_ROUTINES gHelperRoutines;

void CreateHTMLALink(int iPort);
void RetrieveHTMLAInstanceNumFromMetabase(OUT TCHAR *p);
int RetrieveHTMLAPortNumFromMetabase();

INT Register_iis_htmla()
{
    UINT i = 1;  // instance number is in range of 1 - 4 billion
    UINT n, iPort;
    CString csRoot = _T("LM/W3SVC");
    CString strBuf;
    CString csPathRoot;
    
    ACTION_TYPE atHTMLA = GetSubcompAction(_T("iis_htmla"), TRUE);
    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_htmla_before"));

#ifndef _CHICAGO_

    //
    // HTMLA instance use a random port number
    // this port number is in the range of 2000 - 9999
    //
    srand((unsigned)time(NULL));
    iPort = (UINT) ( ((float)rand() / (float)RAND_MAX ) * (PORT_NUM_MAX - PORT_NUM_MIN) + PORT_NUM_MIN);
    // 
    // WARNING on upgrade. Get the next open instance number!!!!!!!
    //
    n = GetInstNumber(csRoot, i);
    strBuf.Format( _T("%d"), n );

    //
    //  Check if there is an existing HTMLA deal in the metabase!
    //

    // if this is upgrading from win95, then make sure to write the acl...
    if (!g_pTheApp->m_bWin95Migration)
    {
        if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
        {
            TCHAR szInst[_MAX_PATH];
            RetrieveHTMLAInstanceNumFromMetabase(szInst);
            if (*szInst) 
            {
                // let's use this Instance number instead of the one that we already have (next open one)
                strBuf = szInst;
                if (IsValidNumber((LPCTSTR)strBuf)) 
                {
                    n=_ttoi((LPCTSTR)strBuf);
                }
            }

            // HTMLA link in IISv4.0 is in "Start Menu/Programs/Microsoft Internet Information Server"
            // In IISv5.0, we need to set it in "Start Menu/Programs/Administrative Tools"
            UINT iTempPort = 0;
            iTempPort = RetrieveHTMLAPortNumFromMetabase();
            if (iTempPort != 0){iPort = iTempPort;}
        }
    }
    AdvanceProgressBarTickGauge();

    //
    // Create "LM/W3SVC/N"
    //
    CString csPath = csRoot;
    csPath += _T("/");
    csPath += strBuf; //  "LM/W3SVC/N"

    CMapStringToString HTMLA_VRootsMap;
    CString name, value;
    POSITION pos;

    name = _T("/");
    value.Format(_T("%s\\iisadmin,,%x"), g_pTheApp->m_csPathInetsrv, MD_ACCESS_SCRIPT | MD_ACCESS_READ);
    HTMLA_VRootsMap.SetAt(name, value);

    name = _T("/iisadmin");
    value.Format(_T("%s\\iisadmin,,%x"), g_pTheApp->m_csPathInetsrv, MD_ACCESS_SCRIPT | MD_ACCESS_READ);
    HTMLA_VRootsMap.SetAt(name, value);

    name = _T("/iisHelp");
    value.Format(_T("%s\\Help\\iishelp,,%x"), g_pTheApp->m_csWinDir, MD_ACCESS_SCRIPT | MD_ACCESS_READ);
    HTMLA_VRootsMap.SetAt(name, value);

    pos = HTMLA_VRootsMap.GetStartPosition();
    while (pos) 
    {
        HTMLA_VRootsMap.GetNextAssoc(pos, name, value);
        CreateMDVRootTree(csPath, name, value, NULL,n);
        AdvanceProgressBarTickGauge();
    }

    SetAppFriendlyName(csPath);

    //
    //  "LM/W3SVC/N"
    //
    WriteToMD_IIsWebServerInstance_WWW(csPath);
    WriteToMD_NotDeleteAble(csPath);
    WriteToMD_ServerSize(csPath);
    WriteToMD_ServerComment(csPath, IDS_ADMIN_SERVER_COMMENT);
    WriteToMD_ServerBindings_HTMLA(csPath, iPort);
    WriteToMD_CertMapper(csPath);

    //
    //  "LM/W3SVC/N/Root"
    //
    if (g_pTheApp->m_eOS == OS_NT && g_pTheApp->m_eNTOSType != OT_NTW) 
    {
        csPathRoot = csPath + _T("/Root");
        // Restrict the Access to the admin instance
        SetIISADMINRestriction(csPathRoot);
        WriteToMD_Authorization(csPathRoot, MD_AUTH_NT);

        // bug299809
        // removed per bug317177

        //CString csHttpCustomString;
        //MyLoadString(IDS_HTTPCUSTOM_UTF8, csHttpCustomString);
        //WriteToMD_HttpCustom(csPathRoot, csHttpCustomString, TRUE);
    }

    //
    //  "LM/W3SVC/N/Root"
    //
    // Add this extra asp thingy only for htmla

    // commented out for Beta3, will re-enable after beta3
    // bug#316682
    // re-enabled per bug#340576
    // removed per bug#340576
    //csPathRoot = csPath + _T("/Root");
    //WriteToMD_AspCodepage(csPathRoot, 65001, FALSE);

    // Add this extra asp thingy only for htmla
    csPathRoot = csPath + _T("/Root");
    WriteToMD_EnableParentPaths_WWW(csPathRoot, TRUE);

    //
    //  "LM/W3SVC"
    //
    WriteToMD_AdminInstance(csRoot, strBuf);

    CreateHTMLALink(iPort);
    AdvanceProgressBarTickGauge();

#endif // _CHICAGO_

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_htmla_after"));
    return (0);
}

void CreateHTMLALink(IN int iPort)
/*++

Routine Description:

    This function creates the HTMLA link in the "Start Menu/Programs/Administrative Tools".
    The link invokes: http://localhost:<iPort>

Arguments:

    iPort is the random port number used by the HTMLA instance. 
    It is in the range of 2000 - 9999. We create the link only when iPort is valid.

Return Value:

    void

--*/
{
    if (iPort >= PORT_NUM_MIN && iPort <= PORT_NUM_MAX) 
    {
        TCHAR szIPort[20];
        _stprintf(szIPort, _T("%d"), iPort);
        SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle, 34001, szIPort);

        ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_htmla_1_link"));
    }

    return;
}

INT Unregister_iis_htmla()
{
    TCHAR szInst[_MAX_PATH];

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_htmla_before"));
    AdvanceProgressBarTickGauge();

    if (CheckifServiceExist(_T("IISADMIN")) == 0 ) 
    {
        RetrieveHTMLAInstanceNumFromMetabase(szInst);
        if (*szInst) 
        {
            CString csPath = _T("LM/W3SVC/");
            csPath += szInst;
            DeleteInProc(csPath);

            CMDKey cmdKey;
            cmdKey.OpenNode(_T("LM/W3SVC"));
            if ( (METADATA_HANDLE)cmdKey ) 
            {
                cmdKey.DeleteNode(szInst); // delete the admin instance
                cmdKey.DeleteData(MD_ADMIN_INSTANCE, STRING_METADATA); // delete the admin instance pointer
                cmdKey.Close();
            }
            AdvanceProgressBarTickGauge();
        }
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_htmla_1"));
    AdvanceProgressBarTickGauge();
    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_htmla_after"));
    AdvanceProgressBarTickGauge();
    return (0);
}

void RetrieveHTMLAInstanceNumFromMetabase(OUT TCHAR *p)
/*++

Routine Description:

    This function retrieves the instance number for the HTMLA instance from the Metabase.
    The instance number is in the form of a string, e.g., "12".
    If succeeds, p will hold this string.
    oherwise, p will hold an empty string.

Arguments:

    Pointer to a string buffer to receive the instance number.

Return Value:

    void

--*/
{
    iisDebugOut_Start(_T("RetrieveHTMLAInstanceNumFromMetabase"));

    TCHAR szInst[_MAX_PATH] = _T("");;
    CMDKey cmdKey;

    cmdKey.OpenNode(_T("LM/W3SVC"));
    if ( (METADATA_HANDLE)cmdKey ) 
    {
        DWORD attr, uType, dType, cbLen;

        cmdKey.GetData(MD_ADMIN_INSTANCE, &attr, &uType, &dType, &cbLen, (PBYTE)szInst, _MAX_PATH);
        cmdKey.Close();
    }

    _tcscpy(p, szInst);

    iisDebugOut_End1(_T("RetrieveHTMLAInstanceNumFromMetabase"),p);
    return;
}

int RetrieveHTMLAPortNumFromMetabase()
/*++

Routine Description:

    This function retrieves the random Port number for HTMLA instance from the Metabase.
    If succeeds, return the random Port number found;
    oherwise, return 0.

Arguments:

    None

Return Value:

    int - the Port number

--*/
{
    iisDebugOut_Start(_T("RetrieveHTMLAPortNumFromMetabase"));

    BOOL bFound = FALSE;
    int iPort = 0;

    DWORD attr, uType, dType, cbLen;
    BUFFER bufData;
    PBYTE pData;
    int BufSize;
    LPTSTR p;
    TCHAR szInst[_MAX_PATH];

    RetrieveHTMLAInstanceNumFromMetabase(szInst);

    if (*szInst) 
    {
        CString csPath = _T("LM/W3SVC/");
        csPath += szInst;
        
        CMDKey cmdKey;
        cmdKey.OpenNode(csPath); //Open "LM/W3SVC/N"

        //
        // MD_SERVER_BINDINGS is a MULTI_SZ string, 
        // each one of them has the format of xxx:<Port>:xxx
        // our goal is to get the <Port>
        //
        if ( (METADATA_HANDLE)cmdKey ) 
        {
            pData = (PBYTE)(bufData.QueryPtr());
            BufSize = bufData.QuerySize();
            cbLen = 0;
            bFound = cmdKey.GetData(MD_SERVER_BINDINGS, &attr, &uType, &dType, &cbLen, pData, BufSize);
            if (!bFound && (cbLen > 0)) 
            {
                if ( bufData.Resize(cbLen) ) 
                {
                    pData = (PBYTE)(bufData.QueryPtr());
                    BufSize = cbLen;
                    cbLen = 0;
                    bFound = cmdKey.GetData(MD_SERVER_BINDINGS, &attr, &uType, &dType, &cbLen, pData, BufSize);
                }
            }
            cmdKey.Close();
        }
    }

    if (bFound && (dType == MULTISZ_METADATA)) 
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("RetrieveHTMLAPortNumFromMetabase():Found a previous HTMLA port num.\n")));
        p = (LPTSTR)pData;
        //
        // each string in pData is in the form of xxx:<Port>:xxx 
        // retrieve port number from the first string
        //
        iisDebugOut((LOG_TYPE_TRACE, _T("RetrieveHTMLAPortNumFromMetabase():entry=%s.\n"),p));
        TCHAR *token;
        token = _tcstok(p, _T(":"));
        if (token) 
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("RetrieveHTMLAPortNumFromMetabase():token=%s.\n"),token));
            if (IsValidNumber((LPCTSTR)token)) {iPort = _ttoi(token);}
        }
    }           

    iisDebugOut((LOG_TYPE_TRACE, _T("RetrieveHTMLAPortNumFromMetabase():Port=%d\n"), iPort));
    return iPort;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\helper.h ===
#ifndef _HELPER_H_
#define _HELPER_H_

#include "wmrgexp.h"
#include "ocmanage.h"
#include "setupapi.h"

#if DBG == 1
	#include <stdio.h>
	#include <stdarg.h>
	#define DECLARE_INFOLEVEL(comp) extern unsigned long comp##InfoLevel = DEF_INFOLEVEL;
	#define DECLARE_DEBUG(comp) \
	    extern unsigned long comp##InfoLevel; \
	    _inline void \
	    comp##InlineDebugOut(unsigned long fDebugMask, TCHAR *pszfmt, ...) \
	    { \
	        if (comp##InfoLevel & fDebugMask) \
	        { \
	            TCHAR acsString[1000];\
	            va_list va; \
	            va_start(va, pszfmt);\
	            _vstprintf(acsString, pszfmt, va); \
	            va_end(va);\
	            OutputDebugString(acsString);\
	        } \
	    }\
	    _inline void \
	    comp##InlineDebugOut( TCHAR *pszfmt, ...) \
	    { \
	        if ( TRUE ) \
	        { \
	            TCHAR acsString[1000];\
	            va_list va; \
	            va_start(va, pszfmt);\
	            _vstprintf(acsString, pszfmt, va); \
	            va_end(va);\
	            OutputDebugString(acsString);\
	        } \
	    }
#else  // DBG == 0
	#define DECLARE_DEBUG(comp)
	#define DECLARE_INFOLEVEL(comp)
#endif // DBG == 0

DECLARE_DEBUG(iis);
#define iisDebugOut(x) iisDebugOut2 x
#define iisDebugOutSafeParams(x) iisDebugOutSafeParams2 x
#define iisDebugOutSafe(x) iisDebugOutSafe2 x

#define DO_IT_FOR_W3SVC_ANONYMOUSUSER    1
#define DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER 2
#define DO_IT_FOR_W3SVC_WAMUSER          4

// External globals from other .cpp files
class  MyLogFile;
extern MyLogFile g_MyLogFile;
class  CInitApp;
extern CInitApp* g_pTheApp;
extern HANDLE g_MyModuleHandle;

// structs
typedef struct _CLUSTER_SVC_INFO_FILL_STRUCT
{
    LPTSTR szTheClusterName;
    LPWSTR pszTheServiceType;
    CString * csTheReturnServiceResName;
    DWORD dwReturnStatus;
} CLUSTER_SVC_INFO_FILL_STRUCT;

typedef struct _ScriptMapNode {
    TCHAR szExt[32];
    TCHAR szProcessor[_MAX_PATH];
    DWORD dwFlags;
    TCHAR szMethods[_MAX_PATH];
    struct _ScriptMapNode *prev, *next;
} ScriptMapNode;

//
// Functions
//
void iisDebugOut2(int iLogType, TCHAR *pszfmt, ...);
void iisDebugOutSafeParams2(int iLogType, TCHAR *pszfmt, ...);
void iisDebugOutSafe2(int iLogType, TCHAR *pszfmt);
void iisDebugOut_Start(TCHAR *pszString, int iLogType = LOG_TYPE_TRACE_WIN32_API);
void iisDebugOut_Start1(TCHAR *pszString1, TCHAR *pszString2, int iLogType = LOG_TYPE_TRACE_WIN32_API);
void iisDebugOut_Start1(TCHAR *pszString1, CString pszString2, int iLogType = LOG_TYPE_TRACE_WIN32_API);
void iisDebugOut_End(TCHAR *pszString, int iLogType = LOG_TYPE_TRACE_WIN32_API);
void iisDebugOut_End1(TCHAR *pszString1, TCHAR *pszString2, int iLogType = LOG_TYPE_TRACE_WIN32_API);
void iisDebugOut_End1(TCHAR *pszString1, CString pszString2, int iLogType = LOG_TYPE_TRACE_WIN32_API);
void ProgressBarTextStack_Push(CString csText);
void ProgressBarTextStack_Pop(void);
void ProgressBarTextStack_Set(int iStringID);
void ProgressBarTextStack_Set(int iStringID, const CString& csFileName);
void ProgressBarTextStack_Set(int iStringID, const CString& csString1, const CString& csString2);
void ProgressBarTextStack_Set(LPCTSTR szProgressTextString);
void ProgressBarTextStack_Inst_Set( int ServiceNameID, int iInstanceNum);
void ProgressBarTextStack_InstVRoot_Set( int ServiceNameID, int iInstanceNum, CString csVRName);
void ProgressBarTextStack_InstInProc_Set( int ServiceNameID, int iInstanceNum, CString csVRName);
void ListOfWarnings_Add(TCHAR * szEntry);
void ListOfWarnings_Display(void);
DWORD GetLastSectionToBeCalled(void);
INT  Register_iis_common();
INT  Unregister_iis_common();
INT  Unregister_old_asp();
INT  Register_iis_core();
INT  Unregister_iis_core();
INT  Register_iis_inetmgr();
INT  Unregister_iis_inetmgr();
INT  Register_iis_pwmgr();
INT  Unregister_iis_pwmgr();
INT  Register_iis_www();
INT  Unregister_iis_www();
INT  Register_iis_doc();
INT  Register_iis_htmla();
INT  Unregister_iis_htmla();
INT  Register_iis_ftp();
INT  Unregister_iis_ftp();
LPWSTR MakeWideStrFromAnsi(LPSTR psz);
int  GetMultiStrSize(LPTSTR p);
BOOL IsValidNumber(LPCTSTR szValue);
int  GetRandomNum(void);
void SetRebootFlag(void);
BOOL RunProgram( LPCTSTR pszProgram, LPTSTR CmdLine, BOOL fMinimized , DWORD dwWaitTimeInSeconds, BOOL fCreateNewConsole);
void HandleSpecificErrors(DWORD iTheErrorCode, DWORD dwFormatReturn, CString csMsg, TCHAR pMsg[], CString *);
BOOL GetDataFromMetabase(LPCTSTR szPath, int nID, LPBYTE Buffer, int BufSize);
void AddOLEAUTRegKey();
DWORD RegisterOLEControl(LPCTSTR lpszOcxFile, BOOL fAction);
void lodctr(LPCTSTR lpszIniFile);
void unlodctr(LPCTSTR lpszDriver);
INT  InstallPerformance(CString nlsRegPerf,CString nlsDll,CString nlsOpen,CString nlsClose,CString nlsCollect );
INT  AddEventLog(BOOL fSystem, CString nlsService, CString nlsMsgFile, DWORD dwType);
INT  RemoveEventLog(BOOL fSystem, CString nlsService );
INT  InstallAgent( CString nlsName, CString nlsPath );
INT  RemoveAgent( CString nlsServiceName );
void InstallMimeMap();
int  CreateInProc(LPCTSTR lpszPath, int iUseOOPPool);
void CreateInProc_Wrap(LPCTSTR lpszPath, int iUseOOPPool);
void DeleteInProc(LPCTSTR lpszKeyPath);
void SetAppFriendlyName(LPCTSTR szKeyPath);
void SetInProc(LPCTSTR szKeyPath);
void AddCustomError(IN DWORD dwCustErr, IN INT intSubCode, IN LPCTSTR szErrorString, IN LPCTSTR szKeyPath, IN BOOL fOverwriteExisting );
ScriptMapNode *AllocNewScriptMapNode(LPTSTR szExt, LPTSTR szProcessor, DWORD dwFlags, LPTSTR szMethods);
void InsertScriptMapList(ScriptMapNode *pList, ScriptMapNode *p, BOOL fReplace);
void FreeScriptMapList(ScriptMapNode *pList);
void GetScriptMapListFromRegistry(ScriptMapNode *pList);
void GetScriptMapListFromMetabase(ScriptMapNode *pList, int iUpgradeType);
void WriteScriptMapListToMetabase(ScriptMapNode *pList, LPTSTR szKeyPath, DWORD dwFlags);
DWORD CallProcedureInDll_wrap(LPCTSTR lpszDLLFile, LPCTSTR lpszProcedureToCall, BOOL bDisplayMsgOnErrFlag, BOOL bInitOleFlag, BOOL iFunctionPrototypeFlag);
DWORD CallProcedureInDll(LPCTSTR lpszDLLFile, LPCTSTR lpszProcedureToCall, BOOL bDisplayMsgOnErrFlag, BOOL bInitOleFlag, BOOL iFunctionPrototypeFlag);
void  GetDebugLevelFromInf(IN HINF hInfFileHandle);
int  IsThisStringInThisCStringList(CStringList &strList, LPCTSTR szStringToLookFor);
int  KillProcess_Wrap(LPCTSTR lpFullPathOrJustFileName);
int  ProcessSection(IN HINF hFile, IN LPCTSTR szTheSection);
void uiCenterDialog( HWND hwndDlg );
int  AfterRemoveAll_SaveMetabase(void);
int  iOleInitialize(void);
void iOleUnInitialize(int iBalanceOLE);
BOOL SetupSetDirectoryId_Wrapper(HINF InfHandle,DWORD Id,LPCTSTR Directory);
BOOL SetupSetStringId_Wrapper(HINF InfHandle,DWORD Id,LPCTSTR TheString);
void LogImportantFiles(void);
HRESULT FTestForOutstandingCoInits(void);
void DisplayStringForMetabaseID(DWORD dwMetabaseID);
void ReturnStringForMetabaseID(DWORD dwMetabaseID, LPTSTR lpReturnString);
void SetErrorFlag(char *szFileName, int iLineNumber);
DWORD FillStrListWithListOfSections(IN HINF hFile, CStringList &strList, IN LPCTSTR szSection);
void MesssageBoxErrors_IIS(void);
void MesssageBoxErrors_MTS(int iMtsThingWeWereDoing, DWORD dwErrorCode);
void ShowIfModuleUsedForGroupOfSections(IN HINF hFile, int iUnlockThem);
int ReadGlobalsFromInf(HINF InfHandle);
int CheckIfPlatformMatchesInf(HINF InfHandle);
int CheckSpecificBuildinInf(HINF InfHandle);
int CheckForOldGopher(HINF InfHandle);
void SetOCGlobalPrivateData(void);
BOOL GetJavaTLD(LPTSTR lpszDir);
void SetDIRIDforThisInf(HINF InfHandle);
void ShowStateOfTheseServices(IN HINF hFile);
int  GetScriptMapAllInclusionVerbs(CString &csTheVerbList);
void DumpScriptMapList();
int  GetSectionNameToDo(IN HINF hFile, CString & csTheSection);
void CustomWWWRoot(LPCTSTR szWWWRoot);
void CustomFTPRoot(LPCTSTR szFTPRoot);
void AdvanceProgressBarTickGauge(int iTicks = 1);
int  IsMetabaseCorrupt(void);
int ReadUserConfigurable(HINF InfHandle);
int ReverseExpandEnvironmentStrings(LPTSTR szOriginalDir,LPTSTR szNewlyMungedDir);
BOOL SetupFindFirstLine_Wrapped(IN HINF InfHandle,IN LPCTSTR Section,IN LPCTSTR Key,OPTIONAL INFCONTEXT *Context);
INT IsThisOnNotStopList(IN HINF hFile, CString csInputName, BOOL bServiceFlag);
HRESULT MofCompile(TCHAR * szPathMofFile);
DWORD   DoesEntryPointExist(LPCTSTR lpszDLLFile, LPCTSTR lpszProcedure);
void    CreateDummyMetabaseBin(void);
BOOL    RunningAsAdministrator();
LPTSTR  CreatePassword(int iSize);
void    CreatePasswordOld(TCHAR *pszPassword,int iSize);
void StopAllServicesRegardless(int iShowErrorsFlag);

#endif // _HELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\initapp.h ===
#include "itemlist.hxx"

#ifndef _INITAPP_H_
#define _INITAPP_H_

typedef PVOID HINF;

#define USER_SPECIFIED_INFO_WWW_USER_NAME 0x00000001
#define USER_SPECIFIED_INFO_WWW_USER_PASS 0x00000002
#define USER_SPECIFIED_INFO_FTP_USER_NAME 0x00000004
#define USER_SPECIFIED_INFO_FTP_USER_PASS 0x00000008
#define USER_SPECIFIED_INFO_WAM_USER_NAME 0x00000010
#define USER_SPECIFIED_INFO_WAM_USER_PASS 0x00000020

#define USER_SPECIFIED_INFO_PATH_WWW     0x000000040
#define USER_SPECIFIED_INFO_PATH_FTP     0x000000080
#define USER_SPECIFIED_INFO_PATH_INETPUB 0x000000100

int  TCPIP_Check_Temp_Hack(void);
void GetUserDomain(void);
int  AreWeCurrentlyInstalled();
void Check_Custom_WWW_or_FTP_Path(void);
void Check_Custom_Users(void);
void Check_Unattend_Settings(void);
int  Check_Custom_InetPub(void);
void Check_For_DebugServiceFlag(void);


class CInitApp : public CObject
{
public:
        CInitApp();
        ~CInitApp();
public:
    int m_err;
    HINF m_hInfHandle;
    HINF m_hInfHandleAlternate;
    BOOL m_bAllowMessageBoxPopups;
    BOOL m_bThereWereErrorsChkLogfile;
    BOOL m_bThereWereErrorsFromMTS;
    BOOL m_bWin95Migration;

    // Product name and application name
    CString m_csAppName;
    CString m_csIISGroupName;      // Start menu IIS Program Group Name

    // account + passwd for anonymous user
    CString m_csGuestName;
    CString m_csGuestPassword;

    CString m_csWAMAccountName;
    CString m_csWAMAccountPassword;
    CString m_csWWWAnonyName;
    CString m_csWWWAnonyPassword;
    CString m_csFTPAnonyName;
    CString m_csFTPAnonyPassword;

    // dwUnattendUserSpecified Values:
    //   USER_SPECIFIED_INFO_WWW_USER_NAME
    //   USER_SPECIFIED_INFO_WWW_USER_PASS
    //   USER_SPECIFIED_INFO_FTP_USER_NAME
    //   USER_SPECIFIED_INFO_FTP_USER_PASS
    //   USER_SPECIFIED_INFO_WAM_USER_NAME
    //   USER_SPECIFIED_INFO_WAM_USER_PASS
    // USER_SPECIFIED_INFO_PATH_WWW
    // USER_SPECIFIED_INFO_PATH_FTP
    // USER_SPECIFIED_INFO_PATH_INETPUB

    DWORD dwUnattendConfig;

    // storage for the user specified unattended iwam/iusr users
    CString m_csWAMAccountName_Unattend;
    CString m_csWAMAccountPassword_Unattend;
    CString m_csWWWAnonyName_Unattend;
    CString m_csWWWAnonyPassword_Unattend;
    CString m_csFTPAnonyName_Unattend;
    CString m_csFTPAnonyPassword_Unattend;

    // storage for the iusr/iwam accounts which need to get
    // removed during a removal, this could be different from
    // what is getting added -- since unattend parameters could
    // have been specified!
    CString m_csWAMAccountName_Remove;
    CString m_csWWWAnonyName_Remove;
    CString m_csFTPAnonyName_Remove;

    CMapStringToString m_cmssUninstallMapList;
    BOOL m_fUninstallMapList_Dirty;
   
    // machine status
    CString m_csMachineName;
    CString m_csUsersDomain;
    CString m_csUsersAccount;

    CString m_csWinDir;
    CString m_csSysDir;
    CString m_csSysDrive;

    CString m_csPathSource;
    CString m_csPathOldInetsrv;
    CString m_csPathInetsrv;
    CString m_csPathInetpub;
    CString m_csPathFTPRoot;
    CString m_csPathWWWRoot;
    CString m_csPathWebPub;
    CString m_csPathProgramFiles;
    CString m_csPathIISSamples;
    CString m_csPathScripts;
    CString m_csPathASPSamp;
    CString m_csPathAdvWorks;
    CString m_csPathIASDocs;
    CString m_csPathOldPWSFiles;
    CString m_csPathOldPWSSystemFiles;

    NT_OS_TYPE m_eNTOSType;
    OS m_eOS;
    DWORD m_dwOSBuild;
    DWORD m_dwOSServicePack;
    BOOL m_fNT5;                // TRUE if OS is NT
    BOOL m_fW95;                // TRUE if OS is NT
    CString m_csPlatform;       // Alpha, Mips, PPC, i386
    DWORD m_dwNumberOfProcessors;

    BOOL m_fTCPIP;               // TRUE if TCP/IP is installed

    UPGRADE_TYPE m_eUpgradeType;       //  UT_NONE, UT_10, UT_20, etc.
    BOOL m_bUpgradeTypeHasMetabaseFlag;
    INSTALL_MODE m_eInstallMode;      // IM_FRESH, IM_MAINTENANCE, IM_UPGRADE
    DWORD m_dwSetupMode;
    BOOL m_bPleaseDoNotInstallByDefault;
    BOOL m_bRefreshSettings;    // FALSE: refresh files only, TRUE: refresh files + refresh all settings

    ACTION_TYPE m_eAction;    // AT_FRESH, AT_ADDREMOVE, AT_REINSTALL, AT_REMOVEALL, AT_UPGRADE

    // Some Specific flags set from ocmanage
    DWORDLONG m_fNTOperationFlags;
    BOOL m_fNTGuiMode;
    BOOL m_fNtWorkstation;
    BOOL m_fInvokedByNT; // superset of m_fNTGuiMode and ControlPanel which contains sysoc.inf

    BOOL m_fUnattended;
    CString m_csUnattendFile;
    HINF m_hUnattendFile;

    BOOL m_fEULA;
    BOOL m_fMoveInetsrv;

    CString m_csPathSrcDir;
    CString m_csPathNTSrcDir;
    CString m_csMissingFile;
    CString m_csMissingFilePath;
    BOOL m_fWebDownload;

public:
    // Implementation
    int MsgBox(HWND hWnd, int strID, UINT nType, BOOL bGlobalTitle);
    int MsgBox2(HWND hWnd, int iID,CString csInsertionString,UINT nType);

public:
    BOOL InitApplication();
    void DumpAppVars();
    void ReGetMachineAndAccountNames();
    void DefineSetupModeOnNT();
    BOOL IsTCPIPInstalled();
    void SetInetpubDerivatives();
    void ResetWAMPassword();
    void UnInstallList_Add(CString csItemUniqueKeyName,CString csDataToAdd);
    void UnInstallList_DelKey(CString csItemUniqueKeyName);
    void UnInstallList_DelData(CString csDataValue);
    void UnInstallList_Dump();
    void UnInstallList_RegRead();
    void UnInstallList_RegWrite();
    void UnInstallList_SetVars();
    CString UnInstallList_QueryKey(CString csItemUniqueKeyName);

private:
    BOOL GetSysDirs();
    BOOL GetOS();
    BOOL GetOSVersion();
    BOOL GetOSType();
    BOOL SetInstallMode();
    void GetPlatform();
    BOOL GetMachineStatus();
    BOOL GetMachineName();
    int  SetUpgradeType();

    void SetSetupParams();
    void SetInetpubDir();
    void GetOldIISDirs();
    void GetOldWWWRootDir();
    void DeriveInetpubFromWWWRoot();
    void GetOldIISSamplesLocation();
    void GetOldInetSrvDir();
    int  Check_Custom_InetPub();
    void Check_Unattend_Settings();
};

/////////////////////////////////////////////////////////////////////////////
#endif  // _INITAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\helper.cpp ===
#include "stdafx.h"
#include "lzexpand.h"
#include <loadperf.h>
#include "setupapi.h"
#include <ole2.h>
#include <iis64.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"
#include "mdentry.h"
#include "mdacl.h"
#include "dcomperm.h"
#include "ocmanage.h"
#include "log.h"
#include "other.h"
#include "kill.h"
#include "strfn.h"
#include "shellutl.h"
#include "svc.h"
#include "setuser.h"
#include "wolfpack.h"
#include <wbemcli.h>
#include <direct.h>
#include <aclapi.h>
#include <wincrypt.h>
#include <Dsgetdc.h>

// for backward compat
#define     PWS_TRAY_WINDOW_CLASS       _T("PWS_TRAY_WINDOW")

GUID g_FTPGuid      = { 0x91604620, 0x6305, 0x11ce, 0xae, 0x00, 0x00, 0xaa, 0x00, 0x4a, 0x38, 0xb9 };
GUID g_HTTPGuid     = { 0x585908c0, 0x6305, 0x11ce, 0xae, 0x00, 0x00, 0xaa, 0x00, 0x4a, 0x38, 0xb9 };
GUID g_InetInfoGuid = { 0xa5569b20, 0xabe5, 0x11ce, 0x9c, 0xa4, 0x00, 0x00, 0x4c, 0x75, 0x27, 0x31 };
GUID g_GopherGuid   = { 0x62388f10, 0x58a2, 0x11ce, 0xbe, 0xc8, 0x00, 0xaa, 0x00, 0x47, 0xae, 0x4e };

// guid stuff
#define MY_DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) extern "C" const GUID name = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#define MY_DEFINE_OLEGUID(name, l, w1, w2) MY_DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)
MY_DEFINE_OLEGUID(IID_IPersistFile, 0x0000010b, 0, 0);
// must be defined after the guid stuff
#include "shlobj.h"

extern int g_GlobalGuiOverRide;
extern int g_GlobalTickValue;
extern int g_CheckIfMetabaseValueWasWritten;
extern HSPFILEQ g_GlobalFileQueueHandle;
extern int g_GlobalFileQueueHandle_ReturnError;

const TCHAR PARSE_ERROR_ENTRY_TO_BIG[] = _T("ProcessEntry_Entry:ParseError:%1!s!:%2!s! -- entry to big. FAIL.\n");
const TCHAR csz101_NOT_SPECIFIED[] = _T("%s():101 Required for this 100 type and not specified, fail. entry=%s. Section=%s.\n");
const TCHAR csz102_NOT_SPECIFIED[] = _T("%s():102 Required for this 100 type and not specified, fail. entry=%s. Section=%s.\n");
const TCHAR csz103_NOT_SPECIFIED[] = _T("%s():103 Required for this 100 type and not specified, fail. entry=%s. Section=%s.\n");
const TCHAR csz104_NOT_SPECIFIED[] = _T("%s():104 Required for this 100 type and not specified, fail. entry=%s. Section=%s.\n");
const TCHAR csz105_NOT_SPECIFIED[] = _T("%s():105 Required for this 100 type and not specified, fail. entry=%s. Section=%s.\n");
const TCHAR csz805_NOT_SPECIFIED[] = _T("%s():805 Required for this 100 type and not specified, fail. entry=%s. Section=%s.\n");

typedef struct _MTS_ERROR_CODE_STRUCT 
{
    int iMtsThingWeWereDoing;
    DWORD dwErrorCode;
} MTS_ERROR_CODE_STRUCT;

MTS_ERROR_CODE_STRUCT gTempMTSError;


const TCHAR ThingToDoNumType_100[] = _T("100=");
const TCHAR ThingToDoNumType_101[] = _T("101=");
const TCHAR ThingToDoNumType_102[] = _T("102=");
const TCHAR ThingToDoNumType_103[] = _T("103=");
const TCHAR ThingToDoNumType_104[] = _T("104=");
const TCHAR ThingToDoNumType_105[] = _T("105=");
const TCHAR ThingToDoNumType_106[] = _T("106=");

const TCHAR ThingToDoNumType_200[] = _T("200=");
const TCHAR ThingToDoNumType_701[] = _T("701=");
const TCHAR ThingToDoNumType_702[] = _T("702=");
const TCHAR ThingToDoNumType_703[] = _T("703=");
const TCHAR ThingToDoNumType_801[] = _T("801=");
const TCHAR ThingToDoNumType_802[] = _T("802=");
const TCHAR ThingToDoNumType_803[] = _T("803=");
const TCHAR ThingToDoNumType_804[] = _T("804=");
const TCHAR ThingToDoNumType_805[] = _T("805=");

typedef struct _ThingToDo {
    TCHAR szType[20];
    TCHAR szFileName[_MAX_PATH];
    TCHAR szData1[_MAX_PATH + _MAX_PATH];
    TCHAR szData2[_MAX_PATH];
    TCHAR szData3[_MAX_PATH];
    TCHAR szData4[_MAX_PATH];
    TCHAR szChangeDir[_MAX_PATH];
   
    TCHAR szOS[10];
    TCHAR szPlatformArchitecture[10];
    TCHAR szEnterprise[10];
    TCHAR szErrIfFileNotFound[10];
    TCHAR szMsgBoxBefore[10];
    TCHAR szMsgBoxAfter[10];
    TCHAR szDoNotDisplayErrIfFunctionFailed[10];
    TCHAR szProgressTitle[100];
} ThingToDo;


extern OCMANAGER_ROUTINES gHelperRoutines;

extern int g_GlobalDebugLevelFlag;
extern int g_GlobalDebugLevelFlag_WasSetByUnattendFile;
extern int g_GlobalDebugCallValidateHeap;
extern int g_GlobalDebugCrypto;
extern int g_GlobalFastLoad;


// Our Global List of Warnings to display after setup is completed.
CStringList gcstrListOfWarnings;
CStringList gcstrProgressBarTextStack;

CStringList gcstrListOfOleInits;

#define FUNCTION_PARAMS_NONE 0
#define FUNCTION_PARAMS_HMODULE 1


#define MAX_FAKE_METABASE_STRING_LEN 500



LCID g_MyTrueThreadLocale;

DWORD WINAPI GetNewlyCreatedThreadLocale(LPVOID lpParameter)
{
    g_MyTrueThreadLocale = GetThreadLocale ();
    return 0;
}

int CheckForWriteAccess(LPCTSTR szFile)
{
    int iReturn = FALSE;

    // check if the file exists
    // if it doesn't then return true!
    if (IsFileExist(szFile) != TRUE)
    {
        // we've got write access!
        return TRUE;
    }

    // try to open the file for write; if we can't, the file is read-only
    HANDLE hFile = CreateFile(szFile, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        // we've got write access!
        iReturn = TRUE;
        CloseHandle (hFile);
    }

    return iReturn;
}


/////////////////////////////////////////////////////////////////////////////
//++
// Return Value:
//    TRUE - the operating system is NTS Enterprise
//    FALSE - the operating system is not correct.
//--
/////////////////////////////////////////////////////////////////////////////
int iReturnTrueIfEnterprise(void)
{
    BOOL              fReturnValue;
    OSVERSIONINFOEX   osiv;
    ZeroMemory( &osiv, sizeof( OSVERSIONINFOEX ) );

    osiv.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );
    osiv.dwMajorVersion = 5;
    osiv.dwMinorVersion = 0;
    osiv.wServicePackMajor = 0;
    osiv.wSuiteMask = VER_SUITE_ENTERPRISE;

    DWORDLONG   dwlConditionMask;
    dwlConditionMask = (DWORDLONG) 0L;

    VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    fReturnValue = VerifyVersionInfo( &osiv,VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SUITENAME,dwlConditionMask );
    if ( fReturnValue != (BOOL) TRUE )
    {
        DWORD dwErrorCode = GetLastError();
    }

    return ( fReturnValue );
}


void GlobalOleInitList_Push(int iTrueOrFalse)
{
    if (FALSE == iTrueOrFalse)
    {
        gcstrListOfOleInits.AddTail(_T("TRUE"));
    }
    else
    {
        gcstrListOfOleInits.AddTail(_T("FALSE"));
    }
    return;
}

int GlobalOleInitList_Find(void)
{
    if (gcstrListOfOleInits.IsEmpty() == TRUE)
    {
        return FALSE;
    }
    return TRUE;
}

int GlobalOleInitList_Pop(void)
{
    CString csText;
    if (gcstrListOfOleInits.IsEmpty() == FALSE)
    {
        csText = gcstrListOfWarnings.RemoveTail();
        if (_tcsicmp(csText, _T("TRUE")) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}

void ProgressBarTextStack_Push(CString csText)
{
    gcstrListOfWarnings.AddTail(csText);
    if (gHelperRoutines.OcManagerContext)
    {
        gHelperRoutines.SetProgressText(gHelperRoutines.OcManagerContext,csText);
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("SetProgressText = %s\n"),csText));
    }
    return;
}


void ProgressBarTextStack_Pop(void)
{
    int iFoundLastEntry = FALSE;
    CString csText;
    // Get the last entry off of the stack and display it.
    if (gcstrListOfWarnings.IsEmpty() == FALSE) 
    {
        csText = gcstrListOfWarnings.RemoveTail();
        if (gcstrListOfWarnings.IsEmpty() == FALSE) 
        {
            csText = gcstrListOfWarnings.GetTail();
            if (csText)
            {
                iFoundLastEntry = TRUE;
            }
        }
    }

    if (iFoundLastEntry)
    {
        if (gHelperRoutines.OcManagerContext)
        {
            gHelperRoutines.SetProgressText(gHelperRoutines.OcManagerContext,csText);
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("SetProgressText = %s\n"),csText));
        }
    }
    else
    {
        if (gHelperRoutines.OcManagerContext)
        {
            gHelperRoutines.SetProgressText(gHelperRoutines.OcManagerContext,_T(" "));
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("SetProgressText = ' '\n")));
        }
    }
    return;
}


void ListOfWarnings_Add(TCHAR * szEntry)
{
    //Add entry to the list of warnings if not already there
    if (_tcsicmp(szEntry, _T("")) != 0)
    {
        // Add it if it is not already there.
        if (TRUE != IsThisStringInThisCStringList(gcstrListOfWarnings, szEntry))
        {
            gcstrListOfWarnings.AddTail(szEntry);
        }
    }
    return;
}

void ListOfWarnings_Display(void)
{
    if (gcstrListOfWarnings.IsEmpty() == FALSE)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("************** WARNINGS START **************")));
        POSITION pos = NULL;
        CString csEntry;
        pos = gcstrListOfWarnings.GetHeadPosition();
        while (pos) 
        {
            csEntry = gcstrListOfWarnings.GetAt(pos);
            iisDebugOutSafeParams((LOG_TYPE_WARN, _T("%1!s!\n"), csEntry));
            gcstrListOfWarnings.GetNext(pos);
        }
        iisDebugOut((LOG_TYPE_WARN, _T("************** WARNINGS END **************")));
    }
    return;
}

int DebugLevelRegistryOveride(TCHAR * szSectionName, TCHAR * ValueName, int * iValueToSet)
{
    int iReturn = FALSE;

    CRegKey regKey(HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_READ);
    if ((HKEY)regKey) 
    {
        // create the key to lookup
        // iis5_SectionName_ValueName
        // iis5_SetupInfo_
        if (szSectionName && ValueName)
        {
            TCHAR szTempRegString[255];
            DWORD dwValue = 0x0;
            _stprintf(szTempRegString, _T("IIS5:%s:%s"), szSectionName, ValueName);
            regKey.m_iDisplayWarnings = FALSE;
            if (regKey.QueryValue(szTempRegString, dwValue) == ERROR_SUCCESS)
            {
                if (dwValue <= 32000)
                {
                    *iValueToSet = (int) dwValue;
                    iReturn = TRUE;
                }
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("RegistryINFValuesOveride:%s=%d."),szTempRegString, *iValueToSet));
            }
        }
    }
    return iReturn;
}


void GetDebugLevelFromInf(IN HINF hInfFileHandle)
{
    int iTempDisplayLogging = FALSE;
    INFCONTEXT Context;
    TCHAR szTempString[10] = _T("");

    //
    //  DebugLevel
    //
    if (!g_GlobalDebugLevelFlag_WasSetByUnattendFile)
    {
        iTempDisplayLogging = FALSE;
        g_GlobalDebugLevelFlag = LOG_TYPE_ERROR;
        if (SetupFindFirstLine_Wrapped(hInfFileHandle, _T("SetupInfo"), _T("DebugLevel"), &Context) )
            {
                SetupGetStringField(&Context, 1, szTempString, 10, NULL);

                if (IsValidNumber((LPCTSTR)szTempString)) 
                    {
                    g_GlobalDebugLevelFlag = _ttoi((LPCTSTR) szTempString);
                    iTempDisplayLogging = TRUE;
                    }

                if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE_WIN32_API )
                {
                    g_CheckIfMetabaseValueWasWritten = TRUE;
                }
            }
        if (DebugLevelRegistryOveride(_T("SetupInfo"), _T("DebugLevel"), &g_GlobalDebugLevelFlag))
            {iTempDisplayLogging = TRUE;}
        if (iTempDisplayLogging)
            {iisDebugOut((LOG_TYPE_TRACE, _T("DebugLevel=%d."),g_GlobalDebugLevelFlag));}
    }
    else
    {
        if (DebugLevelRegistryOveride(_T("SetupInfo"), _T("DebugLevel"), &g_GlobalDebugLevelFlag))
            {iTempDisplayLogging = TRUE;}
        if (iTempDisplayLogging)
            {iisDebugOut((LOG_TYPE_TRACE, _T("DebugLevel=%d."),g_GlobalDebugLevelFlag));}
    }

    //
    //  DebugValidateHeap
    //
    iTempDisplayLogging = FALSE;
    g_GlobalDebugCallValidateHeap = TRUE;
    if (SetupFindFirstLine_Wrapped(hInfFileHandle, _T("SetupInfo"), _T("DebugValidateHeap"), &Context) )
        {
        SetupGetStringField(&Context, 1, szTempString, 10, NULL);
        if (IsValidNumber((LPCTSTR)szTempString)) 
            {
            g_GlobalDebugCallValidateHeap = _ttoi((LPCTSTR) szTempString);
            iTempDisplayLogging = TRUE;
            }
        }
    if (DebugLevelRegistryOveride(_T("SetupInfo"), _T("DebugValidateHeap"), &g_GlobalDebugCallValidateHeap))
        {iTempDisplayLogging = TRUE;}
    if (iTempDisplayLogging)
        {iisDebugOut((LOG_TYPE_TRACE, _T("DebugValidateHeap=%d."),g_GlobalDebugCallValidateHeap));}

    //
    //  DebugCrypto
    //
    iTempDisplayLogging = FALSE;
    g_GlobalDebugCrypto = 0;
    if (SetupFindFirstLine_Wrapped(hInfFileHandle, _T("SetupInfo"), _T("DebugCrypto"), &Context) )
        {
        SetupGetStringField(&Context, 1, szTempString, 10, NULL);
        if (IsValidNumber((LPCTSTR)szTempString)) 
            {
            g_GlobalDebugCrypto = _ttoi((LPCTSTR) szTempString);
            iTempDisplayLogging = TRUE;
            }
        }
    if (DebugLevelRegistryOveride(_T("SetupInfo"), _T("DebugCrypto"), &g_GlobalDebugCrypto))
        {iTempDisplayLogging = TRUE;}
    if (iTempDisplayLogging)
        {iisDebugOut((LOG_TYPE_TRACE, _T("DebugCrypto=%d."),g_GlobalDebugCrypto));}


    //
    //  FastDllInit
    //
    iTempDisplayLogging = FALSE;
    g_GlobalFastLoad = FALSE;
    if (SetupFindFirstLine_Wrapped(hInfFileHandle, _T("SetupInfo"), _T("FastDllInit"), &Context) )
        {
        SetupGetStringField(&Context, 1, szTempString, 10, NULL);
        if (IsValidNumber((LPCTSTR)szTempString)) 
            {
            g_GlobalFastLoad = _ttoi((LPCTSTR) szTempString);
            iTempDisplayLogging = TRUE;
            }
        }
    if (DebugLevelRegistryOveride(_T("SetupInfo"), _T("FastDllInit"), &g_GlobalFastLoad))
        {iTempDisplayLogging = TRUE;}
    if (iTempDisplayLogging)
        {iisDebugOut((LOG_TYPE_TRACE, _T("GlobalFastLoad=%d."),g_GlobalFastLoad));}

    //
    //  Check if we should display messagebox popups
    //
    iTempDisplayLogging = FALSE;
    if (SetupFindFirstLine_Wrapped(hInfFileHandle, _T("SetupInfo"), _T("DisplayMsgbox"), &Context) )
        {
        SetupGetStringField(&Context, 1, szTempString, 10, NULL);
        if (IsValidNumber((LPCTSTR)szTempString)) 
            {
            int iTempNum = 0;
            iTempNum = _ttoi((LPCTSTR) szTempString);
            if (iTempNum > 0)
                {
                g_pTheApp->m_bAllowMessageBoxPopups = TRUE;
                iTempDisplayLogging = TRUE;
                }
            }
        }
    if (DebugLevelRegistryOveride(_T("SetupInfo"), _T("DisplayMsgbox"), &g_pTheApp->m_bAllowMessageBoxPopups))
        {iTempDisplayLogging = TRUE;}
    if (iTempDisplayLogging)
        {iisDebugOut((LOG_TYPE_TRACE, _T("DisplayMsgbox=%d."),g_pTheApp->m_bAllowMessageBoxPopups));}
    
    return;
}


//****************************************************************************
//*
//* This routine will center a dialog in the active windows.
//*
//* ENTRY:
//*  hwndDlg     - Dialog window.
//*
//****************************************************************************
void uiCenterDialog( HWND hwndDlg )
{
    RECT    rc;
    RECT    rcScreen;
    int     x, y;
    int     cxDlg, cyDlg;
    int     cxScreen; 
    int     cyScreen; 

    SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, 0);

    cxScreen = rcScreen.right - rcScreen.left;
    cyScreen = rcScreen.bottom - rcScreen.top;

    GetWindowRect(hwndDlg,&rc);

    x = rc.left;    // Default is to leave the dialog where the template
    y = rc.top;     //  was going to place it.

    cxDlg = rc.right - rc.left;
    cyDlg = rc.bottom - rc.top;

    y = rcScreen.top + ((cyScreen - cyDlg) / 2);
    x = rcScreen.left + ((cxScreen - cxDlg) / 2);

    // Position the dialog.
    SetWindowPos(hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
}



/*

//***************************************************************************
//*                                                                         *
//* SYNOPSIS:   Checks if a specific key in the given section and given file*
//*             is defined.  IF so, get the value.  OW return -1            *
//*                                                                         *
//***************************************************************************
DWORD IsMyKeyExists( LPCTSTR lpSec, LPCTSTR lpKey, LPTSTR lpBuf, UINT uSize, LPCTSTR lpFile )
{
    DWORD dwRet;

    dwRet = GetPrivateProfileString( lpSec, lpKey, "ZZZZZZ", lpBuf, uSize, lpFile );

    if ( !lstrcmp( lpBuf, "ZZZZZZ" ) )
    {
         // no key defined
         dwRet = (DWORD)(-1);
    }
    return dwRet;
}


//***************************************************************************
//
// FormStrWithoutPlaceHolders( LPTSTR szDst, LPCTSTR szSrc, LPCTSTR lpFile );
//
// This function can be easily described by giving examples of what it
// does:
//        Input:  GenFormStrWithoutPlaceHolders(dest,"desc=%MS_XYZ%", hinf) ;
//                INF file has MS_VGA="Microsoft XYZ" in its [Strings] section!
//
//        Output: "desc=Microsoft XYZ" in buffer dest when done.
//
//
// ENTRY:
//  szDst         - the destination where the string after the substitutions
//                  for the place holders (the ones enclosed in "%' chars!)
//                  is placed. This buffer should be big enough (LINE_LEN)
//  szSrc         - the string with the place holders.
//
// EXIT:
//
// NOTES:
//  To use a '%' as such in the string, one would use %% in szSrc! 
//  For the sake of simplicity, we have placed a restriction that the place
//  holder name string cannot have a '%' as part of it! If this is a problem
//  for internationalization, we can revisit this and support it too! Also,
//  the way it is implemented, if there is only one % in the string, it is
//  also used as such! Another point to note is that if the key is not
//  found in the [Strings] section, we just use the %strkey% as such in the
//  destination. This should really help in debugging.
//
//  Get/modified it from setupx: gen1.c
//***************************************************************************
DWORD FormStrWithoutPlaceHolders( LPTSTR szDst, LPCTSTR szSrc, LPCTSTR lpFile)
{
    int     uCnt ;
    DWORD   dwRet;
    TCHAR   *pszTmp;
    LPTSTR  pszSaveDst;

    pszSaveDst = szDst;
    // Do until we reach the end of source (null char)
    while( (*szDst++ = *szSrc) )
    {
        // Increment source as we have only incremented destination above
        if(*szSrc++ == '%')
        {
            if (*szSrc == '%')
            {
                // One can use %% to get a single percentage char in message
                szSrc++ ;
                continue ;
            }

            // see if it is well formed -- there should be a '%' delimiter
            if ( (pszTmp = strchr( szSrc, '%')) != NULL )
            {
                szDst--; // get back to the '%' char to replace

                // yes, there is a STR_KEY to be looked for in [Strings] sect.
                *pszTmp = '\0' ; // replace '%' with a NULL char

                dwRet = IsMyKeyExists( _T("Strings"), szSrc, szDst, _MAX_PATH, lpFile );
                if ( dwRet == -1 )
                {
                    *pszTmp = '%';      // put back original character
                    szSrc-- ;                    // get back to first '%' in Src
                    uCnt = DIFF(pszTmp - szSrc) + 1; // include 2nd '%'

                    // UGHHH... It copies 1 less byte from szSrc so that it can put
                    // in a NULL character, that I don't care about!!!
                    // Different from the normal API I am used to...
                    lstrcpyn( szDst, szSrc, uCnt + 1 ) ;
                    return (DWORD)-1;
                }
                else
                {
                    // all was well, Dst filled right, but unfortunately count not passed
                    // back, like it used too... :-( quick fix is a lstrlen()...
                    uCnt = lstrlen( szDst ) ;
                }

                *pszTmp = '%'  ; // put back original character
                szSrc = pszTmp + 1 ;      // set Src after the second '%'
                szDst += uCnt ;           // set Dst also right.
            }
            // else it is ill-formed -- we use the '%' as such!
            else
            {
                return (DWORD)-1;
            }
        }

    } // while
    return (DWORD)lstrlen(pszSaveDst);
}
*/


void LogImportantFiles(void)
{
    TCHAR buf[_MAX_PATH];
    if (g_pTheApp->m_hInfHandle)
    {
        LogFileVersionsForGroupOfSections(g_pTheApp->m_hInfHandle);
    }

    // display current files in inetsrv date/version.
    CString csTempPath = g_pTheApp->m_csPathInetsrv;
    LogFilesInThisDir(csTempPath);

    // display the setup iis.dll file
    GetSystemDirectory( buf, _MAX_PATH);
    csTempPath = buf;
    csTempPath = AddPath(csTempPath, _T("iis.dll"));
    LogFileVersion(csTempPath, TRUE);

    return;
}   

#ifndef _CHICAGO_
int CreateIUSRAccount(CString csUsername, CString csPassword, INT* piNewlyCreatedUser)
{
    int err;
    CString csComment, csFullName;
    INT iUserWasDeleted = 0;

    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("CreateIUSRAccount(): %1!s!\n"), csUsername));

    // delete the old user first
    //DeleteGuestUser((LPTSTR)(LPCTSTR)csUsername,&iUserWasDeleted);

    // create the new user
    MyLoadString(IDS_USER_COMMENT, csComment);
    MyLoadString(IDS_USER_FULLNAME, csFullName);

    // Create user either returns NERR_Success or err code
    err = CreateUser(csUsername, csPassword, csComment, csFullName, FALSE, piNewlyCreatedUser);
	if (err == NERR_Success) 
		{iisDebugOut((LOG_TYPE_TRACE, _T("CreateIUSRAccount(): Return 0x%x  Suceess\n"), err));}
	else
		{
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateIUSRAccount(): Return Err=0x%x  FAILURE. deleting and retrying.\n"), err));

        // try to delete it first then create it.
        DeleteGuestUser((LPTSTR)(LPCTSTR)csUsername,&iUserWasDeleted);
        err = CreateUser(csUsername, csPassword, csComment, csFullName, FALSE, piNewlyCreatedUser);
        iisDebugOut((LOG_TYPE_TRACE, _T("CreateIUSRAccount(): Return 0x%x\n"), err));
        }
	    
    return err;
}

int CreateIWAMAccount(CString csUsername, CString csPassword,INT* piNewlyCreatedUser)
{
    int err;
    CString csComment, csFullName;
    INT iUserWasDeleted = 0;

    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("CreateIWAMAccount(): %1!s!\n"), csUsername));
    //iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("CreateIWAMAccount(): %1!s!\n"), csPassword));

    // delete the old user first
    //DeleteGuestUser((LPTSTR)(LPCTSTR)csUsername,&iUserWasDeleted);
    
    // create the new user
    MyLoadString(IDS_WAMUSER_COMMENT, csComment);
    MyLoadString(IDS_WAMUSER_FULLNAME, csFullName);

    // Create user either returns NERR_Success or err code
    err = CreateUser(csUsername, csPassword, csComment, csFullName, TRUE, piNewlyCreatedUser);
	if (err == NERR_Success) 
		{iisDebugOut((LOG_TYPE_TRACE, _T("CreateIWAMAccount(): Return 0x%x  Suceess\n"), err));}
	else
		{
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateIWAMAccount(): Return Err=0x%x  FAILURE. deleting and retrying.\n"), err));

        // try to delete it first then create it.
        DeleteGuestUser((LPTSTR)(LPCTSTR)csUsername,&iUserWasDeleted);
        err = CreateUser(csUsername, csPassword, csComment, csFullName, TRUE, piNewlyCreatedUser);
        iisDebugOut((LOG_TYPE_TRACE, _T("CreateIWAMAccount(): Return 0x%x\n"), err));
        }
   
    return err;
}
#endif //_CHICAGO_


INT InstallPerformance(CString nlsRegPerf,CString nlsDll,CString nlsOpen,CString nlsClose,CString nlsCollect )
{
    iisDebugOut_Start1(_T("InstallPerformance"),nlsDll);
    INT err = NERR_Success;

    if (g_pTheApp->m_eOS != OS_W95)
    {
        CRegKey regPerf( nlsRegPerf, HKEY_LOCAL_MACHINE );
        if (regPerf)
        {
            regPerf.SetValue(_T("Library"), nlsDll );
            regPerf.SetValue(_T("Open"),    nlsOpen );
            regPerf.SetValue(_T("Close"),   nlsClose );
            regPerf.SetValue(_T("Collect"), nlsCollect );
        }
    }

    iisDebugOut_End1(_T("InstallPerformance"),nlsDll);
    return(err);
}
//
// Add eventlog to the registry
//
INT AddEventLog(BOOL fSystem, CString nlsService, CString nlsMsgFile, DWORD dwType)
{
    iisDebugOut_Start1(_T("AddEventLog"),nlsMsgFile);
    INT err = NERR_Success;
    CString nlsLog = (fSystem)? REG_EVENTLOG_SYSTEM : REG_EVENTLOG_APPLICATION;
    nlsLog += _T("\\");
    nlsLog += nlsService;

    CRegKey regService( nlsLog, HKEY_LOCAL_MACHINE );
    if ( regService )
    {
        regService.SetValue( _T("EventMessageFile"), nlsMsgFile, TRUE );
        regService.SetValue( _T("TypesSupported"), dwType );
    }
    iisDebugOut_End1(_T("AddEventLog"),nlsMsgFile);
    return(err);
}

//
// Remove eventlog from the registry
//

INT RemoveEventLog( BOOL fSystem, CString nlsService )
{
    iisDebugOut_Start1(_T("RemoveEventLog"),nlsService);
    INT err = NERR_Success;
    CString nlsLog = (fSystem)? REG_EVENTLOG_SYSTEM : REG_EVENTLOG_APPLICATION;

    CRegKey regService( HKEY_LOCAL_MACHINE, nlsLog );
    if ( regService )
    {
        regService.DeleteTree( nlsService );
    }
    iisDebugOut_End1(_T("RemoveEventLog"),nlsService);
    return(err);
}

//
// Install SNMP agent to the registry
//
INT InstallAgent( CString nlsName, CString nlsPath )
{
    iisDebugOut_Start1(_T("InstallAgent"),nlsPath);
    INT err = NERR_Success;
    do
    {
        CString nlsSnmpParam = REG_SNMPPARAMETERS;
        CRegKey regSnmpParam( HKEY_LOCAL_MACHINE, nlsSnmpParam );
        if ( regSnmpParam == (HKEY)NULL )
            break;

        CString nlsSoftwareMSFT = _T("Software\\Microsoft");
        CRegKey regSoftwareMSFT( HKEY_LOCAL_MACHINE, nlsSoftwareMSFT );
        if ( (HKEY) NULL == regSoftwareMSFT )
            break;

        // add agent key
        CRegKey regAgent( nlsName, regSoftwareMSFT );
        if ( (HKEY) NULL == regAgent )
            break;

        CString nlsCurVersion = _T("CurrentVersion");
        CRegKey regAgentCurVersion( nlsCurVersion, regAgent );
        if ((HKEY) NULL == regAgentCurVersion )
            break;
        regAgentCurVersion.SetValue(_T("Pathname"), nlsPath );

        CRegKey regAgentParam( nlsName, regSnmpParam );
        if ((HKEY) NULL == regAgentParam )
            break;

        CString nlsSnmpExt = REG_SNMPEXTAGENT;
        CRegKey regSnmpExt( nlsSnmpExt, HKEY_LOCAL_MACHINE );
        if ((HKEY) NULL == regSnmpExt )
            break;

        // find the first available number slot
        for ( INT i=0; ;i++ )
        {
            CString nlsPos;
            nlsPos.Format( _T("%d"),i);
            CString nlsValue;

            if ( regSnmpExt.QueryValue( nlsPos, nlsValue ) != NERR_Success )
            {
                // okay, an empty spot
                nlsValue.Format(_T("%s\\%s\\%s"),_T("Software\\Microsoft"),(LPCTSTR)nlsName,_T("CurrentVersion") );

                regSnmpExt.SetValue( nlsPos, nlsValue );
                break;
            } else
            {
                if ( nlsValue.Find( nlsName) != (-1))
                {
                    break;
                }
            }
        }

    } while (FALSE);

    iisDebugOut_End1(_T("InstallAgent"),nlsPath);
    return(err);
}

//
// Remove an SNMP agent from the registry
//

INT RemoveAgent( CString nlsServiceName )
{
    iisDebugOut_Start1(_T("RemoveAgent"),nlsServiceName);
    INT err = NERR_Success;
    do
    {
        CString nlsSoftwareAgent = _T("Software\\Microsoft");

        CRegKey regSoftwareAgent( HKEY_LOCAL_MACHINE, nlsSoftwareAgent );
        if ((HKEY)NULL == regSoftwareAgent )
            break;
        regSoftwareAgent.DeleteTree( nlsServiceName );

        CString nlsSnmpParam = REG_SNMPPARAMETERS;

        CRegKey regSnmpParam( HKEY_LOCAL_MACHINE, nlsSnmpParam );
        if ((HKEY) NULL == regSnmpParam )
            break;
        regSnmpParam.DeleteTree( nlsServiceName );

        CString nlsSnmpExt = REG_SNMPEXTAGENT;
        CRegKey regSnmpExt( HKEY_LOCAL_MACHINE, nlsSnmpExt );
        if ((HKEY) NULL == regSnmpExt )
            break;

        CRegValueIter enumSnmpExt( regSnmpExt );

        CString strName;
        DWORD dwType;
        CString csServiceName;

        csServiceName = _T("\\") + nlsServiceName;
        csServiceName += _T("\\");

        while ( enumSnmpExt.Next( &strName, &dwType ) == NERR_Success )
        {
            CString nlsValue;

            regSnmpExt.QueryValue( strName, nlsValue );

            if ( nlsValue.Find( csServiceName ) != (-1))
            {
                // found it
                regSnmpExt.DeleteValue( (LPCTSTR)strName );
                break;
            }
        }
    } while (FALSE);

    iisDebugOut_End1(_T("RemoveAgent"),nlsServiceName);
    return(err);
}

void lodctr(LPCTSTR lpszIniFile)
{
#ifndef _CHICAGO_
    iisDebugOut_Start1(_T("lodctr"),lpszIniFile);
    CString csCmdLine = _T("lodctr ");
    csCmdLine += g_pTheApp->m_csSysDir;
    csCmdLine += _T("\\");
    csCmdLine += lpszIniFile;

    iisDebugOut_Start((_T("loadperf.dll:LoadPerfCounterTextStrings")));
    LoadPerfCounterTextStrings((LPTSTR)(LPCTSTR)csCmdLine, TRUE);
    iisDebugOut_End((_T("loadperf.dll:LoadPerfCounterTextStrings")));
    iisDebugOut_End1(_T("lodctr"),lpszIniFile);
#endif
    return;
}

void unlodctr(LPCTSTR lpszDriver)
{
#ifndef _CHICAGO_
    iisDebugOut_Start1(_T("unlodctr"),lpszDriver);
    CString csCmdLine = _T("unlodctr ");
    csCmdLine += lpszDriver;
    iisDebugOut_Start(_T("loadperf.dll:UnloadPerfCounterTextStrings"));
    UnloadPerfCounterTextStrings((LPTSTR)(LPCTSTR)csCmdLine, TRUE);
    iisDebugOut_End((_T("loadperf.dll:UnloadPerfCounterTextStrings")));
    iisDebugOut_End1(_T("unlodctr"),lpszDriver);
#endif
    return;
}


typedef void (*P_SslGenerateRandomBits)( PUCHAR pRandomData, LONG size );
P_SslGenerateRandomBits ProcSslGenerateRandomBits = NULL;

BOOL GenRandom(int *lpGoop, DWORD cbGoop) 
{
    BOOL fRet = FALSE;
    HCRYPTPROV hProv = 0;

    if (::CryptAcquireContext(&hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT))
        if (::CryptGenRandom(hProv,cbGoop,(BYTE *) lpGoop)) 
        {
                    fRet = TRUE;
        }

    if (hProv) ::CryptReleaseContext(hProv,0);

    return fRet;
}


int GetRandomNum(void)
{
    int RandomNum;
    UCHAR cRandomByte;

    RandomNum = rand();

    __try
    {

        // call the random number function
        if (!GenRandom(& RandomNum,1)) 
        {
            // if that fails then try this one...
            if ( ProcSslGenerateRandomBits != NULL )
            {
                (*ProcSslGenerateRandomBits)( &cRandomByte, 1 );
                RandomNum = cRandomByte;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("nException Caught in SCHANNEL.dll:ProcSslGenerateRandomBits()=0x%x.."),GetExceptionCode()));
    }

    return(RandomNum);
}

void ShuffleCharArray(int iSizeOfTheArray, TCHAR * lptsTheArray)
{
    int i;
    int iTotal;
    int RandomNum;

    iTotal = iSizeOfTheArray / sizeof(_TCHAR);
    for (i=0; i<iTotal;i++ )
    {
        // shuffle the array
        RandomNum=GetRandomNum();
        TCHAR c = lptsTheArray[i];
        lptsTheArray[i]=lptsTheArray[RandomNum%iTotal];
        lptsTheArray[RandomNum%iTotal]=c;
    }
    return;
}


// password categories
enum {STRONG_PWD_UPPER=0, 
      STRONG_PWD_LOWER, 
      STRONG_PWD_NUM, 
      STRONG_PWD_PUNC};

#define STRONG_PWD_CATS (STRONG_PWD_PUNC + 1)
#define NUM_LETTERS 26
#define NUM_NUMBERS 10
#define MIN_PWD_LEN 8

// password must contain at least one each of: 
// uppercase, lowercase, punctuation and numbers
DWORD CreateGoodPassword(BYTE *szPwd, DWORD dwLen) {

    if (dwLen-1 < MIN_PWD_LEN)
        return ERROR_PASSWORD_RESTRICTION;

    HCRYPTPROV hProv;
    DWORD dwErr = 0;

    if (CryptAcquireContext(&hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT) == FALSE) 
        return GetLastError();

    // zero it out and decrement the size to allow for trailing '\0'
    ZeroMemory(szPwd,dwLen);
    dwLen--;

    // generate a pwd pattern, each byte is in the range 
    // (0..255) mod STRONG_PWD_CATS
    // this indicates which character pool to take a char from
    BYTE *pPwdPattern = new BYTE[dwLen];
    BOOL fFound[STRONG_PWD_CATS];
    do {
        // bug!bug! does CGR() ever fail?
        CryptGenRandom(hProv,dwLen,pPwdPattern);

        fFound[STRONG_PWD_UPPER] = 
        fFound[STRONG_PWD_LOWER] =
        fFound[STRONG_PWD_PUNC] =
        fFound[STRONG_PWD_NUM] = FALSE;

        for (DWORD i=0; i < dwLen; i++) 
            fFound[pPwdPattern[i] % STRONG_PWD_CATS] = TRUE;

#ifdef _DEBUG
            if (!fFound[STRONG_PWD_UPPER] ||
                !fFound[STRONG_PWD_LOWER] ||
                !fFound[STRONG_PWD_PUNC] ||
                !fFound[STRONG_PWD_NUM]) {
                iisDebugOut((LOG_TYPE_TRACE,_T("Oops! Regen pattern required [%d, %d, %d, %d]\n"),
                    fFound[STRONG_PWD_UPPER],
                    fFound[STRONG_PWD_LOWER], 
                    fFound[STRONG_PWD_PUNC],
                    fFound[STRONG_PWD_NUM]));
             }
#endif

    // check that each character category is in the pattern
    } while (!fFound[STRONG_PWD_UPPER] || 
                !fFound[STRONG_PWD_LOWER] || 
                !fFound[STRONG_PWD_PUNC] || 
                !fFound[STRONG_PWD_NUM]);

    // populate password with random data 
    // this, in conjunction with pPwdPattern, is
    // used to determine the actual data
    CryptGenRandom(hProv,dwLen,szPwd);

    for (DWORD i=0; i < dwLen; i++) { 
        BYTE bChar = 0;

        // there is a bias in each character pool because of the % function
        switch (pPwdPattern[i] % STRONG_PWD_CATS) {

            case STRONG_PWD_UPPER : bChar = 'A' + szPwd[i] % NUM_LETTERS;
                                    break;

            case STRONG_PWD_LOWER : bChar = 'a' + szPwd[i] % NUM_LETTERS;
                                    break;

            case STRONG_PWD_NUM :   bChar = '0' + szPwd[i] % NUM_NUMBERS;
                                    break;

            case STRONG_PWD_PUNC :
            default:                char *szPunc="!@#$%^&*()_-+=[{]};:\'\"<>,./?\\|~`";
                                    DWORD dwLenPunc = lstrlenA(szPunc);
                                    bChar = szPunc[szPwd[i] % dwLenPunc];
                                    break;
        }

        szPwd[i] = bChar;

#ifdef _DEBUG
        iisDebugOut((LOG_TYPE_TRACE,_T("[%03d] Pattern is %d, index is %d, char is '%c'\n"),i,pPwdPattern[i] % STRONG_PWD_CATS,szPwd[i],bChar));
#endif

    }

    delete pPwdPattern;

    if (hProv != NULL) 
        CryptReleaseContext(hProv,0);

    return dwErr;
}


//
// Create a random password
//
void CreatePasswordOld(TCHAR *pszPassword, int iSize)
{
    //
    // Use Maximum available password length, as
    // setting any other length might run afoul
    // of the minimum password length setting
    //
    int nLength = (iSize - 1);
    int iTotal = 0;
    int RandomNum = 0;
    int i;
    TCHAR six2pr[64] =
    {
        _T('A'), _T('B'), _T('C'), _T('D'), _T('E'), _T('F'), _T('G'), _T('H'), _T('I'), _T('J'), _T('K'), _T('L'), _T('M'),
        _T('N'), _T('O'), _T('P'), _T('Q'), _T('R'), _T('S'), _T('T'), _T('U'), _T('V'), _T('W'), _T('X'), _T('Y'), _T('Z'),
        _T('a'), _T('b'), _T('c'), _T('d'), _T('e'), _T('f'), _T('g'), _T('h'), _T('i'), _T('j'), _T('k'), _T('l'), _T('m'),
        _T('n'), _T('o'), _T('p'), _T('q'), _T('r'), _T('s'), _T('t'), _T('u'), _T('v'), _T('w'), _T('x'), _T('y'), _T('z'),
        _T('0'), _T('1'), _T('2'), _T('3'), _T('4'), _T('5'), _T('6'), _T('7'), _T('8'), _T('9'), _T('*'), _T('_')
    };

    // create a random password
    ProcSslGenerateRandomBits = NULL;

    HINSTANCE hSslDll = LoadLibraryEx(_T("schannel.dll"), NULL, 0 );
    if ( hSslDll )
        {
        ProcSslGenerateRandomBits = (P_SslGenerateRandomBits)GetProcAddress( hSslDll, "SslGenerateRandomBits");
        }
    else
    {
        // check if this file has missing file it's supposed to be linked with.
        // or if the file has mismatched import\export dependencies with linked files.
#ifdef _WIN64
        // don't call cause it's broken
#else
        //Check_File_Dependencies(_T("schannel.dll"));
#endif
    }

    // See the random number generation for rand() call in GetRandomNum()
    time_t timer;
    time( &timer );
    srand( (unsigned int) timer );

    // shuffle around the global six2pr[] array
    ShuffleCharArray(sizeof(six2pr), (TCHAR*) &six2pr);
    // assign each character of the password array
    iTotal = sizeof(six2pr) / sizeof(_TCHAR);
    for ( i=0;i<nLength;i++ )
    {
        RandomNum=GetRandomNum();
        pszPassword[i]=six2pr[RandomNum%iTotal];
    }

    //
    // in order to meet a possible
    // policy set upon passwords..
    //
    // replace the last 4 chars with these:
    //  
    // 1) something from !@#$%^&*()-+=
    // 2) something from 1234567890
    // 3) an uppercase letter
    // 4) a lowercase letter
    //
    TCHAR something1[12] = {_T('!'), _T('@'), _T('#'), _T('$'), _T('^'), _T('&'), _T('*'), _T('('), _T(')'), _T('-'), _T('+'), _T('=')};
    ShuffleCharArray(sizeof(something1), (TCHAR*) &something1);
    TCHAR something2[10] = {_T('0'), _T('1'), _T('2'), _T('3'), _T('4'), _T('5'), _T('6'), _T('7'), _T('8'), _T('9')};
    ShuffleCharArray(sizeof(something2),(TCHAR*) &something2);
    TCHAR something3[26] = {_T('A'), _T('B'), _T('C'), _T('D'), _T('E'), _T('F'), _T('G'), _T('H'), _T('I'), _T('J'), _T('K'), _T('L'), _T('M'), _T('N'), _T('O'), _T('P'), _T('Q'), _T('R'), _T('S'), _T('T'), _T('U'), _T('V'), _T('W'), _T('X'), _T('Y'), _T('Z')};
    ShuffleCharArray(sizeof(something3),(TCHAR*) &something3);
    TCHAR something4[26] = {_T('a'), _T('b'), _T('c'), _T('d'), _T('e'), _T('f'), _T('g'), _T('h'), _T('i'), _T('j'), _T('k'), _T('l'), _T('m'), _T('n'), _T('o'), _T('p'), _T('q'), _T('r'), _T('s'), _T('t'), _T('u'), _T('v'), _T('w'), _T('x'), _T('y'), _T('z')};
    ShuffleCharArray(sizeof(something4),(TCHAR*)&something4);
    
    RandomNum=GetRandomNum();
    iTotal = sizeof(something1) / sizeof(_TCHAR);
    pszPassword[nLength-4]=something1[RandomNum%iTotal];

    RandomNum=GetRandomNum();
    iTotal = sizeof(something2) / sizeof(_TCHAR);
    pszPassword[nLength-3]=something2[RandomNum%iTotal];

    RandomNum=GetRandomNum();
    iTotal = sizeof(something3) / sizeof(_TCHAR);
    pszPassword[nLength-2]=something3[RandomNum%iTotal];

    RandomNum=GetRandomNum();
    iTotal = sizeof(something4) / sizeof(_TCHAR);
    pszPassword[nLength-1]=something4[RandomNum%iTotal];

    pszPassword[nLength]=_T('\0');

    if (hSslDll)
        {FreeLibrary( hSslDll );}
}


// Creates a secure password
// caller must GlobalFree Return pointer
// iSize = size of password to create
LPTSTR CreatePassword(int iSize)
{
    LPTSTR pszPassword =  NULL;
    BYTE *szPwd = new BYTE[iSize];
    DWORD dwPwdLen = iSize;
    int i = 0;

    // use the new secure password generator
    // unfortunately this baby doesn't use unicode.
    // so we'll call it and then convert it to unicode afterwards.
    if (0 == CreateGoodPassword(szPwd,dwPwdLen))
    {
#if defined(UNICODE) || defined(_UNICODE)
        // convert it to unicode and copy it back into our unicode buffer.
        // compute the length
        i = MultiByteToWideChar(CP_ACP, 0, (LPSTR) szPwd, -1, NULL, 0);
        if (i <= 0) 
            {goto CreatePassword_Exit;}
        pszPassword = (LPTSTR) GlobalAlloc(GPTR, i * sizeof(TCHAR));
        if (!pszPassword)
            {goto CreatePassword_Exit;}
        i =  MultiByteToWideChar(CP_ACP, 0, (LPSTR) szPwd, -1, pszPassword, i);
        if (i <= 0) 
            {
            GlobalFree(pszPassword);
            pszPassword = NULL;
            goto CreatePassword_Exit;
            }
        // make sure ends with null
        pszPassword[i - 1] = 0;
#else
        pszPassword = (LPSTR) GlobalAlloc(GPTR, _tcslen((LPTSTR) szPwd) * sizeof(TCHAR));
#endif
    }
    else
    {
        iisDebugOut((LOG_TYPE_WARN,_T("CreateGoodPassword FAILED, using other password generator\n")));
        // CreateGoodPassword failed...
        // lets go with one that we know works...
        pszPassword = (LPTSTR) GlobalAlloc(GPTR, iSize * sizeof(TCHAR));
        if (!pszPassword)
            {goto CreatePassword_Exit;}
        CreatePasswordOld(pszPassword,iSize);
    }

CreatePassword_Exit:
    if (szPwd){delete szPwd;szPwd=NULL;}
    return pszPassword;
}


BOOL RunProgram( LPCTSTR pszProgram, LPTSTR CmdLine, BOOL fMinimized , DWORD dwWaitTimeInSeconds, BOOL fCreateNewConsole)
{
    DWORD dwProcessType = NORMAL_PRIORITY_CLASS;
    STARTUPINFO si;
    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof( STARTUPINFO );
    if (fMinimized) 
    {
        GetStartupInfo(&si);
        si.dwFlags |= STARTF_USESHOWWINDOW;
        si.wShowWindow = SW_HIDE;

        // Per bug #321409
        // if you don't specify sw_hide, then this
        // "accessibility magnifier" app will get funky focus events during setup
        // from this CreateProcess.
        //si.wShowWindow = SW_SHOWMINIMIZED;
    }
    PROCESS_INFORMATION pi;

    if (fCreateNewConsole)
    {
        dwProcessType = CREATE_NEW_CONSOLE | NORMAL_PRIORITY_CLASS;
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("RunProgram:Start:Exe=%1!s!,Parm=%2!s!,NewConsole"),pszProgram, CmdLine));    }
    else
    {
        // for some reason, a cmd window pops up during setup when we call "iisreset.exe /scm"
        // only way to prevent this is specify DETACHED_PROCESS
        dwProcessType = DETACHED_PROCESS | NORMAL_PRIORITY_CLASS;
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("RunProgram:Start:Exe=%1!s!,Parm=%2!s!"),pszProgram, CmdLine));
    }

    if (!CreateProcess( pszProgram, CmdLine, NULL, NULL, FALSE, dwProcessType, NULL, NULL, &si, &pi ))
    {
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("RunProgram:Failed:Exe=%1!s!\n, Parm=%2!s!"),pszProgram, CmdLine));
        return FALSE;
    }

    if ( pi.hProcess != NULL )
    {
        DWORD dwSecondsToWait;

        if (dwWaitTimeInSeconds == INFINITE)
        {
            dwSecondsToWait = INFINITE;
        }
        else
        {
            dwSecondsToWait = dwWaitTimeInSeconds * 1000;
        }
        DWORD dwEvent = WaitForSingleObject( pi.hProcess, dwSecondsToWait);
        if ( dwEvent != ERROR_SUCCESS )
        {
            // check if wait failed
            if ( dwEvent == WAIT_FAILED )
                {iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("RunProgram:WaitForSingleObject() ERROR.WAIT_FAILED.Err=0x%1!x!."),GetLastError()));}
            else if ( dwEvent == WAIT_ABANDONED )
                {iisDebugOutSafeParams((LOG_TYPE_WARN, _T("RunProgram:WaitForSingleObject() WARNING.WAIT_ABANDONED.Err=0x%1!x!."),dwEvent));}
            else if ( dwEvent == WAIT_OBJECT_0 )
                {iisDebugOutSafeParams((LOG_TYPE_WARN, _T("RunProgram:WaitForSingleObject() WARNING.WAIT_OBJECT_0.Err=0x%1!x!."),dwEvent));}
            else if ( dwEvent == WAIT_TIMEOUT )
                {iisDebugOutSafeParams((LOG_TYPE_WARN, _T("RunProgram:WaitForSingleObject() WARNING.WAIT_TIMEOUT.Err=0x%1!x!."),dwEvent));}
            else
                {iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("RunProgram:WaitForSingleObject() FAILED.Err=0x%1!x!."),dwEvent));}

            TerminateProcess( pi.hProcess, -1 );
            CloseHandle( pi.hThread );
        }
        CloseHandle( pi.hProcess );
    }

    iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("RunProgram:End:Exe=%1!s!,Parm=%2!s!"),pszProgram, CmdLine));
    return TRUE;
}


void SetAppFriendlyName(LPCTSTR szKeyPath)
{
    CString csKeyPath, csPath, csDesc;
    CStringArray aPath, aDesc;
    int nArray = 0, i = 0;
    CMDKey cmdKey;

    // szKeyPath is in the form of LM/W3SVC/i
    csKeyPath = szKeyPath;

    csPath = csKeyPath + _T("/Root");
    aPath.Add(csPath);
    MyLoadString(IDS_APP_FRIENDLY_ROOT, csDesc);
    aDesc.Add(csDesc);
    csPath = csKeyPath + _T("/Root/IISADMIN");
    aPath.Add(csPath);
    MyLoadString(IDS_APP_FRIENDLY_IISADMIN, csDesc);
    aDesc.Add(csDesc);
    csPath = csKeyPath + _T("/Root/WEBPUB");
    aPath.Add(csPath);
    MyLoadString(IDS_APP_FRIENDLY_WEBPUB, csDesc);
    aDesc.Add(csDesc);
    csPath = csKeyPath + _T("/Root/IISSAMPLES");
    aPath.Add(csPath);
    MyLoadString(IDS_APP_FRIENDLY_IISSAMPLES, csDesc);
    aDesc.Add(csDesc);
    csPath = csKeyPath + _T("/Root/IISHELP");
    aPath.Add(csPath);
    MyLoadString(IDS_APP_FRIENDLY_IISHELP, csDesc);
    aDesc.Add(csDesc);

    nArray = (int)aPath.GetSize();
    for (i=0; i<nArray; i++) 
    {
        cmdKey.OpenNode(aPath[i]);
        if ( (METADATA_HANDLE)cmdKey ) 
        {
            CString csName;
            TCHAR szName[_MAX_PATH];
            DWORD attr, uType, dType, cbLen;
            BOOL b;
            b = cmdKey.GetData(MD_APP_FRIENDLY_NAME, &attr, &uType, &dType, &cbLen, (PBYTE)szName, _MAX_PATH);
            if (!b || !(*szName))
            {
                csName = aDesc[i];
                cmdKey.SetData(MD_APP_FRIENDLY_NAME,METADATA_INHERIT,IIS_MD_UT_WAM,STRING_METADATA,(csName.GetLength() + 1) * sizeof(TCHAR),(LPBYTE)(LPCTSTR)csName);
            }
            cmdKey.Close();
        }
    }

    return;
}

void SetInProc( LPCTSTR szKeyPath)
{
    CString csKeyPath, csPath;
    CStringArray aPath;
    int nArray = 0, i = 0;
    CMDKey cmdKey;

    // szKeyPath is in the form of LM/W3SVC/i
    csKeyPath = szKeyPath;

    csPath = csKeyPath + _T("/Root/IISSAMPLES");
    aPath.Add(csPath);
    csPath = csKeyPath + _T("/Root/IISHELP");
    aPath.Add(csPath);
    csPath = csKeyPath + _T("/Root/WEBPUB");
    aPath.Add(csPath);

    nArray = (int)aPath.GetSize();
    for (i=0; i<nArray; i++) {
        cmdKey.OpenNode(aPath[i]);
        if ( (METADATA_HANDLE)cmdKey )
        {
            CString csName;
            TCHAR szName[_MAX_PATH];
            DWORD attr, uType, dType, cbLen;
            BOOL b;

            b = cmdKey.GetData(MD_APP_ROOT, &attr, &uType, &dType, &cbLen, (PBYTE)szName, _MAX_PATH);
            cmdKey.Close();

            if (!b || !(*szName))
            {
                CreateInProc_Wrap(aPath[i], TRUE);
            }
        }
    }

    return;
}


//------------------------------------------------------------------------------
// Add a custom error string to the existing custom errors. We are only adding FILE type
// error so that is assumed.
// dwCustErr is the ID of the error
// intSubCode is the sub code of the error. Pass in -1 to get a * for all subcodes
// szFilePath is the file to link to the custom error
// szKeyPath is the path in the metabase to write to
//#define  SZ_CUSTOM_ERROR          _T("404,*,FILE,%s\\help\\iishelp\\common\\404.htm|")
void AddCustomError(IN DWORD dwCustErr, IN INT intSubCode, IN LPCTSTR szErrorString, IN LPCTSTR szKeyPath, IN BOOL fOverwriteExisting )
{
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddCustomError().Start.%d:%d:%s:%s:%d\n"),dwCustErr,intSubCode,szErrorString,szKeyPath,fOverwriteExisting ));
    CMDKey  cmdKey;
    DWORD   err;
    PVOID   pData = NULL;
    BOOL    fFoundExisting = FALSE;

    CString csCustomErrorString;

    // start by building our new error string
    // if intSubCode is < 1 use a * instead of a numerical value
    if ( intSubCode < 0 )
        csCustomErrorString.Format( _T("%d,*,%s"), dwCustErr, szErrorString );
    else
        csCustomErrorString.Format( _T("%d,%d,%s"), dwCustErr, intSubCode, szErrorString );

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddCustomError().part1:%s\n"),csCustomErrorString));

    cmdKey.OpenNode(szKeyPath);
    if ( (METADATA_HANDLE)cmdKey )
    {
        DWORD dwAttr = METADATA_INHERIT;
        DWORD dwUType = IIS_MD_UT_FILE;
        DWORD dwDType = MULTISZ_METADATA;
        DWORD dwLength = 0;

        // we need to start this process by getting the existing multisz data from the metabase
        // first, figure out how much memory we will need to do this
        if (_tcsicmp(szKeyPath,_T("LM/W3SVC/Info")) == 0)
        {
            dwAttr = METADATA_NO_ATTRIBUTES;
            dwUType = IIS_MD_UT_SERVER;
            cmdKey.GetData( MD_CUSTOM_ERROR_DESC,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,MULTISZ_METADATA);
        }
        else
        {
            cmdKey.GetData( MD_CUSTOM_ERROR,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA);
        }

        // unfortunatly, the above routine only returns TRUE or FALSE. And since we are purposefully
        // passing in a null ponter of 0 size in order to get the length of the data, it will always
        // return 0 whether it was because the metabase is inacessable, or there pointer was NULL,
        // which it is. So - I guess we assume it worked, allocate the buffer and attempt to read it
        // in again.

        TCHAR*      pErrors;
        DWORD       cbBuffer = dwLength;

        // add enough space to the allocated space that we can just append the string
        cbBuffer += (csCustomErrorString.GetLength() + 4) * sizeof(WCHAR);
        dwLength = cbBuffer;

        // allocate the space, if it fails, we fail
        // note that GPTR causes it to be initialized to zero
        pData = GlobalAlloc( GPTR, cbBuffer );
        if ( !pData )
            {
            cmdKey.Close();
            return;
            }
        pErrors = (TCHAR*)pData;

        // now get the data from the metabase
        BOOL f;
        if (_tcsicmp(szKeyPath,_T("LM/W3SVC/Info")) == 0)
        {
            f = cmdKey.GetData( MD_CUSTOM_ERROR_DESC,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)pData,cbBuffer,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,MULTISZ_METADATA );
        }
        else
        {
            f = cmdKey.GetData( MD_CUSTOM_ERROR,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)pData,cbBuffer,METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA );
        }

        // if we have successfully retrieved the existing custom errors, then we need to scan them
        // and remove or find any duplicates. Then we can add our new custom error. Then we can write it
        // out. If we didn't retrieve it, then we should just try to write out what we have.
        if ( f )
            {
            // got the existing errors, scan them now - pErrors will be pointing at the second end \0
            // when it is time to exit the loop.
            while ( *pErrors )
                {
                CString csError = pErrors;
                CString cs;
                DWORD   dwTestErrorID;
                INT     intTestSubCode;

                // get the first error ID code
                cs = csError.Left( csError.Find(_T(',')) );
                csError = csError.Right( csError.GetLength() - (cs.GetLength() +1) );
                _stscanf( cs, _T("%d"), &dwTestErrorID );

                // get the second code
                cs = csError.Left( csError.Find(_T(',')) );
                if ( cs == _T('*') )
                    intTestSubCode = -1;
                else
                    _stscanf( cs, _T("%d"), &intTestSubCode );

                // if it is the same, then chop off this custom error string and do NOT increment pErrors
                if ( (dwTestErrorID == dwCustErr) && (intTestSubCode == intSubCode) )
                    {
                    fFoundExisting = TRUE;
                    // NOTE: if we are not overwriting existing, then just break because we
                    // won't be doing anything after all - we found an existing one
                    if ( !fOverwriteExisting )
                    {
                        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddCustomError().Do not overwritexisting\n")));
                        break;
                    }

                    // get the location of the next string in the multisz
                    TCHAR* pNext = _tcsninc( pErrors, _tcslen(pErrors))+1;

                    // Get the length of the data to copy
                    DWORD   cbCopyLength = cbBuffer - DIFF((PBYTE)pNext - (PBYTE)pData);

                    // copy the memory down.
                    MoveMemory( pErrors, pNext, cbCopyLength );

                    // do not increment the string
                    continue;
                    }

                // increment pErrors to the next string
                pErrors = _tcsninc( pErrors, _tcslen(pErrors))+1;
                }
            }

        // check if we need to finish this or not
        if ( fOverwriteExisting || !fFoundExisting )
            {
                // append our new error to the end of the list. The value pErrors should be pointing
                // to the correct location to copy it in to
                _tcscpy( pErrors, csCustomErrorString );

                // calculate the correct data length for this thing
                // get the location of the end of the multisz
                TCHAR* pNext = _tcsninc( pErrors, _tcslen(pErrors))+2;
                // Get the length of the data to copy
                cbBuffer = DIFF((PBYTE)pNext - (PBYTE)pData);

                // write the new errors list back out to the metabase
                if (_tcsicmp(szKeyPath,_T("LM/W3SVC/Info")) == 0)
                {
                    cmdKey.SetData(MD_CUSTOM_ERROR_DESC,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,MULTISZ_METADATA,cbBuffer,(PUCHAR)pData);
                }
                else
                {
                    cmdKey.SetData(MD_CUSTOM_ERROR,METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA,cbBuffer,(PUCHAR)pData);
                }
            }
        else
        {
            //
            //
            //
        }
        
        // always close the metabase key
        cmdKey.Close();
    }
    else
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddCustomError().OpenNode failed:%s\n"),szKeyPath));
    }

    // clean up
    if ( pData ){GlobalFree(pData);pData=NULL;}
    iisDebugOut_End((_T("AddCustomError")));
    return;
}


ScriptMapNode *AllocNewScriptMapNode(LPTSTR szExt, LPTSTR szProcessor, DWORD dwFlags, LPTSTR szMethods)
{
    ScriptMapNode *pNew = NULL;

    pNew = (ScriptMapNode *)calloc(1, sizeof(ScriptMapNode));
    if (pNew) 
    {
        _tcscpy(pNew->szExt, szExt);
        _tcscpy(pNew->szProcessor, szProcessor);
        pNew->dwFlags = dwFlags;
        _tcscpy(pNew->szMethods, szMethods);
        pNew->prev = NULL;
        pNew->next = NULL;
    }

    return pNew;
}

//
// The script map should not be sored because
// the order is infact important.
void InsertScriptMapList(ScriptMapNode *pList, ScriptMapNode *p, BOOL fReplace)
{
    ScriptMapNode *t;
    int i;
    int bFound = FALSE;

    if (!p) {return;}

#ifdef SCRIPTMAP_SORTED
    t = pList->next;
    while (t != pList) 
    {
        i = _tcsicmp(t->szExt, p->szExt);

        // if the next entry in the list is less than what we have.
        // then
        if (i < 0) 
        {
            t = t->next;
            // continue
        }

        if (i == 0) 
        {
            if (fReplace) 
            {
                // replace t
                p->next = t->next;
                p->prev = t->prev;
                (t->prev)->next = p;
                (t->next)->prev = p;
                free(t);
            }
            else 
            {
                // don't replace t
                free(p);
            }
            return;
        }

        if (i > 0) 
        {
            // location found: insert before t
            break;
        }
    }

    // insert before t
    p->next = t;
    p->prev = t->prev;
    (t->prev)->next = p;
    t->prev = p;
#else
    // loop thru the whole list and see if we can find our entry.
    // if we cannot find it then add it to the end.
    // if we can find it then replace it if we need to.
    bFound = FALSE;
    t = pList->next;
    while (t != pList)
    {
        i = _tcsicmp(t->szExt, p->szExt);

        // we found a match, do replace or don't replace
        if (i == 0) 
        {
            bFound = TRUE;
            if (fReplace) 
            {
                // replace t
                p->next = t->next;
                p->prev = t->prev;
                (t->prev)->next = p;
                (t->next)->prev = p;
                free(t);
            }
            else 
            {
                // don't replace t
                free(p);
            }
            return;
        }

        // Go get the next one
        t = t->next;
    }

    // see if we found something
    if (FALSE == bFound)
    {
        // insert before t
        p->next = t;
        p->prev = t->prev;
        (t->prev)->next = p;
        t->prev = p;
    }
#endif

    return;
}

void FreeScriptMapList(ScriptMapNode *pList)
{
    ScriptMapNode *t = NULL, *p = NULL;

    t = pList->next;
    while (t != pList) 
    {
        p = t->next;
        free(t);
        t = p;
    }

    t->prev = t;
    t->next = t;

    return;
}


void GetScriptMapListFromRegistry(ScriptMapNode *pList)
{
    iisDebugOut_Start(_T("GetScriptMapListFromRegistry"), LOG_TYPE_TRACE);
    int iFound = FALSE;

    GetScriptMapListFromClean(pList, _T("ScriptMaps_CleanList"));

    CRegKey regScriptMap( HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\W3svc\\Parameters\\Script Map"));
    if ((HKEY)regScriptMap ) 
    {
        // delete mappings of .bat and .cmd
        regScriptMap.DeleteValue( _T(".bat") );
        regScriptMap.DeleteValue( _T(".cmd") );

        CRegValueIter regEnum( regScriptMap );
        CString csExt, csProcessor, csMethods;
        CString csTemp;
        ScriptMapNode *pNode;

        while ( regEnum.Next( &csExt, &csProcessor ) == ERROR_SUCCESS ) 
        {
            iFound = FALSE;
            csTemp = csProcessor;
            csTemp.MakeLower();
            csMethods = _T("");

            if (csTemp.Right(7) == _T("asp.dll"))
            {
                // Make sure it points to the new location...
                csProcessor = g_pTheApp->m_csPathInetsrv + _T("\\asp.dll");
                // asp has special methods.

                // add PROPFIND,PROPPATCH,MKCOL,COPY,MOVE,LOCK,UNLOCK,MS-SEARCH 6/17 per vanvan for Dav.
                csMethods = _T("PUT,DELETE,OPTIONS,PROPFIND,PROPPATCH,MKCOL,COPY,MOVE,LOCK,UNLOCK,MS-SEARCH");
            }

            if (csTemp.Right(7) == _T("ism.dll"))
            {
                // Make sure it points to the new location...
                // remap since ism.dll has a security hole
                csProcessor = g_pTheApp->m_csPathInetsrv + _T("\\asp.dll");
            }

            if (csTemp.Right(12) == _T("httpodbc.dll"))
            {
                // Make sure it points to the new location...
                csProcessor = g_pTheApp->m_csPathInetsrv + _T("\\httpodbc.dll");
            }

            if (csTemp.Right(9) == _T("ssinc.dll"))
            {
                // Make sure it points to the new location...
                csProcessor = g_pTheApp->m_csPathInetsrv + _T("\\ssinc.dll");
            }

            // Add it to the script map 
            pNode = AllocNewScriptMapNode((LPTSTR)(LPCTSTR)csExt, (LPTSTR)(LPCTSTR)csProcessor, MD_SCRIPTMAPFLAG_SCRIPT, _T(""));
            InsertScriptMapList(pList, pNode, FALSE);
        }
    }
    iisDebugOut_End(_T("GetScriptMapListFromRegistry"),LOG_TYPE_TRACE);
    return;
}

void GetScriptMapListFromMetabase(ScriptMapNode *pList, int iUpgradeType)
{
    iisDebugOut_Start(_T("GetScriptMapListFromMetabase"), LOG_TYPE_TRACE);

    //DumpScriptMapList();
    // When upgrading from a metabase we should not add other script maps
    // which the user probably explicitly removed!
    // GetScriptMapListFromClean(pList, _T("ScriptMaps_CleanList"));
    //DumpScriptMapList();

    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    LPTSTR p, rest, token;
    CString csName, csValue;
    PBYTE pData;
    int BufSize;

    CString csBinPath;

    cmdKey.OpenNode(_T("LM/W3SVC"));
    if ( (METADATA_HANDLE)cmdKey ) 
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_SCRIPT_MAPS, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (!bFound && (cbLen > 0)) 
        {
            if ( ! (bufData.Resize(cbLen)) ) 
            {
                cmdKey.Close();
                return;  // insufficient memory
            }
            else 
            {
                pData = (PBYTE)(bufData.QueryPtr());
                BufSize = cbLen;
                cbLen = 0;
                bFound = cmdKey.GetData(MD_SCRIPT_MAPS, &attr, &uType, &dType, &cbLen, pData, BufSize);
            }
        }
        cmdKey.Close();

        ScriptMapNode *pNode;
        CString csString;
        TCHAR szExt[32], szProcessor[_MAX_PATH], szMethods[_MAX_PATH];
        DWORD dwFlags;
        int i, j, len;
        if (bFound && (dType == MULTISZ_METADATA)) 
        {
            p = (LPTSTR)pData;
            while (*p) 
            {
                rest = p + _tcslen(p) + 1;

                // szExt,szProcessor,dwFlags[,szMethods]

                LPTSTR q = p;
                i = 0;
                while ( *q ) 
                {
                    if (*q == _T(',')) 
                    {
                        i++;
                        *q = _T('\0');
                        q = _tcsinc(q);
                        if (i == 1)
                            _tcscpy(szExt, p);
                        if (i == 2)
                            _tcscpy(szProcessor, p);
                        if (i == 3)
                            break;
                        p = q;
                    }
                    else 
                    {
                        q = _tcsinc(q);
                    }
                }
                dwFlags = atodw(p);
                _tcscpy(szMethods, q);

                CString csProcessor = szProcessor;
                csProcessor.MakeLower();

                //
                // Check if this is the one for asp.dll
                //
                if (csProcessor.Right(7) == _T("asp.dll")) 
                {
                    // metabase should now have inclusion list and not exclusion list, so
                    // don't do this for UT_50. 2/23/99 aaronl.

                    // But UT_40 have a exclusion list.
                    // So we have to make sure it have the full exclusion list
                    if ( iUpgradeType == UT_40)
                    {
                        CString csMethods = szMethods;
                        csMethods.MakeUpper();

                        // changed 4/21/98 aaronl, added 'Options'
                        // add PROPFIND,PROPPATCH,MKCOL,COPY,MOVE,LOCK,UNLOCK,MS-SEARCH 6/17 per vanvan for Dav.
                        if (csMethods.Find(_T("PUT,DELETE,OPTIONS,PROPFIND,PROPPATCH,MKCOL,COPY,MOVE,LOCK,UNLOCK,MS-SEARCH")) == -1)
                        {
                            if (csMethods.IsEmpty())
                            {
                                // if it's empty, then put to the default.
                                csMethods = _T("PUT,DELETE,OPTIONS,PROPFIND,PROPPATCH,MKCOL,COPY,MOVE,LOCK,UNLOCK,MS-SEARCH");
                            }
                            else
                            {
                                if (csMethods.Find(_T("GET")) == -1)
                                {
                                    // We didn't find the "GET" verb so we can safely say
                                    // that we are looking at an exclusion list
                                    CString csMethodsNew;
                                    csMethodsNew = _T("");
                                    
                                    // is put in there? if not add it
                                    if (csMethods.Find(_T("PUT")) == -1) {csMethodsNew += _T("PUT,");}
                                    if (csMethods.Find(_T("DELETE")) == -1) {csMethodsNew += _T("DELETE,");}
                                    if (csMethods.Find(_T("OPTIONS")) == -1) {csMethodsNew += _T("OPTIONS,");}
                                    if (csMethods.Find(_T("PROPFIND")) == -1) {csMethodsNew += _T("PROPFIND,");}
                                    if (csMethods.Find(_T("PROPPATCH")) == -1) {csMethodsNew += _T("PROPPATCH,");}
                                    if (csMethods.Find(_T("MKCOL")) == -1) {csMethodsNew += _T("MKCOL,");}
                                    if (csMethods.Find(_T("COPY")) == -1) {csMethodsNew += _T("COPY,");}
                                    if (csMethods.Find(_T("MOVE")) == -1) {csMethodsNew += _T("MOVE,");}
                                    if (csMethods.Find(_T("LOCK")) == -1) {csMethodsNew += _T("LOCK,");}
                                    if (csMethods.Find(_T("UNLOCK")) == -1) {csMethodsNew += _T("UNLOCK,");}
                                    if (csMethods.Find(_T("MS-SEARCH")) == -1) {csMethodsNew += _T("MS-SEARCH,");}

                                    // has an extra ',' at the end
                                    //csMethods = _T("PUT,DELETE,OPTIONS,PROPFIND,PROPPATCH,MKCOL,COPY,MOVE,LOCK,UNLOCK,MS-SEARCH,");
                                    csMethods = csMethodsNew;
                                    csMethods += szMethods;
                                }
                            }
                            _tcscpy(szMethods, csMethods);
                        }
                    }

                    // make sure it points to the new asp.dll location
                    csBinPath = g_pTheApp->m_csPathInetsrv + _T("\\asp.dll");
                    _tcscpy(szProcessor, csBinPath);
                }
                
                //
                // Check if this is the one for ism.dll
                //
                if (csProcessor.Right(7) == _T("ism.dll")) 
                {
                    // make sure it points to the new location
                    // remap since ism.dll has a security hole
                    csBinPath = g_pTheApp->m_csPathInetsrv + _T("\\asp.dll");
                    _tcscpy(szProcessor, csBinPath);
                }

                //
                // Check if this is the one for httpodbc.dll
                //
                if (csProcessor.Right(12) == _T("httpodbc.dll")) 
                {
                    // make sure it points to the new location
                    csBinPath = g_pTheApp->m_csPathInetsrv + _T("\\httpodbc.dll");
                    _tcscpy(szProcessor, csBinPath);
                }

                //
                // Check if this is the one for ssinc.dll
                //
                if (csProcessor.Right(9) == _T("ssinc.dll")) 
                {
                    // make sure it points to the new location
                    csBinPath = g_pTheApp->m_csPathInetsrv + _T("\\ssinc.dll");
                    _tcscpy(szProcessor, csBinPath);
                }

                p = rest; // points to the next string
                pNode = AllocNewScriptMapNode(szExt, szProcessor, dwFlags | MD_SCRIPTMAPFLAG_SCRIPT, szMethods);
                //iisDebugOut((LOG_TYPE_TRACE, _T("Calling InsertScriptMapList=%s:%s:%d:%s.\n"),szExt,szProcessor,dwFlags | MD_SCRIPTMAPFLAG_SCRIPT,szMethods));
                InsertScriptMapList(pList, pNode, TRUE);
            }
        }
    }

    iisDebugOut_End(_T("GetScriptMapListFromMetabase"),LOG_TYPE_TRACE);
    return;
}

void DumpScriptMapList()
{
    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    LPTSTR p, rest, token;
    CString csName, csValue;
    PBYTE pData;
    int BufSize;

    CString csBinPath;

    cmdKey.OpenNode(_T("LM/W3SVC"));
    if ( (METADATA_HANDLE)cmdKey ) 
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_SCRIPT_MAPS, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (!bFound && (cbLen > 0)) 
        {
            if ( ! (bufData.Resize(cbLen)) ) 
            {
                cmdKey.Close();
                return;  // insufficient memory
            }
            else 
            {
                pData = (PBYTE)(bufData.QueryPtr());
                BufSize = cbLen;
                cbLen = 0;
                bFound = cmdKey.GetData(MD_SCRIPT_MAPS, &attr, &uType, &dType, &cbLen, pData, BufSize);
            }
        }
        cmdKey.Close();

        ScriptMapNode *pNode;
        CString csString;
        TCHAR szExt[32], szProcessor[_MAX_PATH], szMethods[_MAX_PATH];
        DWORD dwFlags;
        int i, j, len;
        if (bFound && (dType == MULTISZ_METADATA)) 
        {
            p = (LPTSTR)pData;
            while (*p) 
            {
                rest = p + _tcslen(p) + 1;

                // szExt,szProcessor,dwFlags[,szMethods]

                LPTSTR q = p;
                i = 0;
                while ( *q ) 
                {
                    if (*q == _T(',')) 
                    {
                        i++;
                        *q = _T('\0');
                        q = _tcsinc(q);
                        if (i == 1)
                            _tcscpy(szExt, p);
                        if (i == 2)
                            _tcscpy(szProcessor, p);
                        if (i == 3)
                            break;
                        p = q;
                    }
                    else 
                    {
                        q = _tcsinc(q);
                    }
                }
                dwFlags = atodw(p);
                _tcscpy(szMethods, q);

                CString csProcessor = szProcessor;
                csProcessor.MakeLower();

                iisDebugOut((LOG_TYPE_TRACE, _T("DumpScriptMapList=%s,%s,%s\n"),szExt, csProcessor,szMethods));

                p = rest; // points to the next string
            }
        }
    }

    return;
}


void WriteScriptMapListToMetabase(ScriptMapNode *pList, LPTSTR szKeyPath, DWORD dwFlags)
{
    iisDebugOut_Start1(_T("WriteScriptMapListToMetabase"), szKeyPath, LOG_TYPE_TRACE);

    CString csString, csTemp;
    ScriptMapNode *t = NULL;
    int len = 0;

    t = pList->next;
    while (t != pList)
    {
        if ( *(t->szMethods) )
            csTemp.Format( _T("%s,%s,%d,%s|"), t->szExt, t->szProcessor, (t->dwFlags | dwFlags), t->szMethods );
        else
            csTemp.Format( _T("%s,%s,%d|"), t->szExt, t->szProcessor, (t->dwFlags | dwFlags) );
        len += csTemp.GetLength();

        //iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("WriteScriptMapListToMetabase().ADDEntry=%1!s!\n"), csTemp));

        csString += csTemp;
        t = t->next;
    }

    if (len > 0)
    {
        HGLOBAL hBlock = NULL;

        len++;
        hBlock = GlobalAlloc(GPTR, len * sizeof(TCHAR));
        if (hBlock)
        {
            LPTSTR s;
            s = (LPTSTR)hBlock;
            _tcscpy(s, csString);
            while (*s)
            {
                if (*s == _T('|'))
                    {*s = _T('\0');}
                s = _tcsinc(s);
            }

            CMDKey cmdKey;
            cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, szKeyPath);
            if ( (METADATA_HANDLE)cmdKey )
            {
                cmdKey.SetData(MD_SCRIPT_MAPS,METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA,len * sizeof(TCHAR),(LPBYTE)hBlock);
                cmdKey.Close();
            }
        }
    }

    iisDebugOut_End1(_T("WriteScriptMapListToMetabase"),szKeyPath,LOG_TYPE_TRACE);
    //DumpScriptMapList();
    return;
}


// this function does not use the va_list stuff because if 
// there ever is this case: iisDebugOut("<SYSTEMROOT>") it will hose
// because it will try to put something in the %s part when there were no
// variables passed in.
void iisDebugOutSafe2(int iLogType, TCHAR * acsString)
{
    // Check what type of log this should be.
    int iProceed = FALSE;

    if (iLogType == LOG_TYPE_ERROR)
        {SetErrorFlag(__FILE__, __LINE__);}

    switch(iLogType)
	{
        case LOG_TYPE_TRACE_WIN32_API:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE_WIN32_API)
                {iProceed = TRUE;}
            break;
		case LOG_TYPE_TRACE:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_PROGRAM_FLOW:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_PROGRAM_FLOW)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_WARN:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_WARN)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_ERROR:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_ERROR)
                {iProceed = TRUE;}
            break;
        default:
            // this must be an error
            iProceed = TRUE;
            break;
    }

    if (iProceed)
    {
        if (LOG_TYPE_ERROR == iLogType)
        {
            g_MyLogFile.LogFileWrite(_T("!FAIL! "));
        }
        // always output to the log file
        g_MyLogFile.LogFileWrite(_T("%s"), acsString);
        //#if DBG == 1 || DEBUG == 1 || _DEBUG == 1
            // OK.  Here is the deal.
            // nt5 does not want to see any OutputDebugString stuff
            // so, we need to remove it for them.
            // Actually we'll check the registry key
            // to see if it is turned on for the ocmanage component.
            // if it is then, set it on for us.
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE_WIN32_API)
            {
                if (LOG_TYPE_ERROR == iLogType)
                    {OutputDebugString(_T("!FAIL!"));}
                // output to screen
                if (g_MyLogFile.m_szLogPreLineInfo) {OutputDebugString(g_MyLogFile.m_szLogPreLineInfo);}
                OutputDebugString(acsString);

                // if it does not end if '\r\n' then make one.
                int nLen = _tcslen(acsString);
                if (acsString[nLen-1] != _T('\n'))
	                {OutputDebugString(_T("\r\n"));}
            }
        //#endif // DBG
    }
    return;
}


void iisDebugOut2(int iLogType, TCHAR *pszfmt, ...)
{
    // Check what type of log this should be.
    int iProceed = FALSE;

    switch(iLogType)
	{
        case LOG_TYPE_TRACE_WIN32_API:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE_WIN32_API)
                {iProceed = TRUE;}
            break;
		case LOG_TYPE_TRACE:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_PROGRAM_FLOW:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_PROGRAM_FLOW)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_WARN:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_WARN)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_ERROR:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_ERROR)
                {iProceed = TRUE;}
            break;
        default:
            // this must be an error
            iProceed = TRUE;
            break;
    }

    if (iProceed)
    {
        TCHAR acsString[1000];
        // Encompass this whole iisdebugout deal in a try-catch.
        // not too good to have this one access violating.
        // when trying to produce a debugoutput!
        __try
        {
            va_list va;
            va_start(va, pszfmt);
            _vstprintf(acsString, pszfmt, va);
            va_end(va);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            TCHAR szErrorString[100];
            _stprintf(szErrorString, _T("\r\n\r\nException Caught in iisDebugOut2().  GetExceptionCode()=0x%x.\r\n\r\n"), GetExceptionCode());
            OutputDebugString(szErrorString);
            g_MyLogFile.LogFileWrite(szErrorString);
        }

        // output to log file and the screen.
        iisDebugOutSafe2(iLogType, acsString);
    }
    return;
}


// This function requires inputs like this:
//   iisDebugOutSafeParams2("this %1!s! is %2!s! and has %3!d! args", "function", "kool", 3);
//   you must specify the %1 deals.  this is so that
//   if something like this is passed in "this %SYSTEMROOT% %1!s!", it will put the string into %1 not %s!
void iisDebugOutSafeParams2(int iLogType, TCHAR *pszfmt, ...)
{
    // Check what type of log this should be.
    int iProceed = FALSE;
    switch(iLogType)
	{
        case LOG_TYPE_TRACE_WIN32_API:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE_WIN32_API)
                {iProceed = TRUE;}
            break;
		case LOG_TYPE_TRACE:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_PROGRAM_FLOW:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_PROGRAM_FLOW)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_WARN:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_WARN)
                {iProceed = TRUE;}
            break;
        case LOG_TYPE_ERROR:
            if (g_GlobalDebugLevelFlag >= LOG_TYPE_ERROR)
                {iProceed = TRUE;}
            break;
        default:
            // this must be an error
            iProceed = TRUE;
            break;
    }

    if (iProceed)
    {
        // The count of parameters do not match
        va_list va;
        TCHAR *pszFullErrMsg = NULL;

        va_start(va, pszfmt);

        __try
        {
            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING, (LPCVOID) pszfmt, 0, 0, (LPTSTR) &pszFullErrMsg, 0, &va);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            TCHAR szErrorString[100];
            _stprintf(szErrorString, _T("\r\n\r\nException Caught in iisDebugOutSafeParams2().  GetExceptionCode()=0x%x.\r\n\r\n"), GetExceptionCode());
            OutputDebugString(szErrorString);
            g_MyLogFile.LogFileWrite(szErrorString);
        }
        
        if (pszFullErrMsg)
        {
            // output to log file and the screen.
            iisDebugOutSafe2(iLogType, pszFullErrMsg);
        }
        va_end(va);

        if (pszFullErrMsg) {LocalFree(pszFullErrMsg);pszFullErrMsg=NULL;}
    }
    return;
}


void HandleSpecificErrors(DWORD iTheErrorCode, DWORD dwFormatReturn, CString csMsg, TCHAR pMsg[], CString *pcsErrMsg)
{
    CString csErrMsg;
    CString csExtraMsg;

    switch(iTheErrorCode)
	{
		case NTE_BAD_SIGNATURE:
            // load extra error message for this error!
            MyLoadString(IDS_BAD_SIGNATURE_RELNOTES, csExtraMsg);

            if (dwFormatReturn) {csErrMsg.Format(_T("%s\n\n0x%x=%s\n\n%s"), csMsg, iTheErrorCode, pMsg, csExtraMsg);}
            else{csErrMsg.Format(_T("%s\n\nErrorCode=0x%x.\n\n%s"), csMsg, iTheErrorCode, csExtraMsg);}
            break;
        case CO_E_RUNAS_LOGON_FAILURE:
            // we should get the mts runas user from the registry and display it.

        default:
            // Put everything into csErrMsg
            if (dwFormatReturn) {csErrMsg.Format(_T("%s\n\n0x%x=%s"), csMsg, iTheErrorCode, pMsg);}
            else{csErrMsg.Format(_T("%s\n\nErrorCode=0x%x."), csMsg, iTheErrorCode);}
            break;
    }

    // copy the error string into the passed in CString
    (*pcsErrMsg) = csErrMsg;
    return;
}


//***************************************************************************
//*                                                                         
//* purpose:
//*
//***************************************************************************
LPWSTR MakeWideStrFromAnsi(LPSTR psz)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoTaskMemAlloc().Start.")));
    pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoTaskMemAlloc().End.")));

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}


DWORD CallProcedureInDll_wrap(LPCTSTR lpszDLLFile, LPCTSTR lpszProcedureToCall, BOOL bDisplayMsgOnErrFlag, BOOL bInitOleFlag,BOOL iFunctionPrototypeFlag)
{
    int bFinishedFlag = FALSE;
    UINT iMsg = NULL;
    DWORD dwReturn = ERROR_SUCCESS;
    TCHAR szExceptionString[50] = _T("");
    LogHeapState(FALSE, __FILE__, __LINE__);

	do
	{
        __try
        {
		    dwReturn = CallProcedureInDll(lpszDLLFile, lpszProcedureToCall, bDisplayMsgOnErrFlag, bInitOleFlag, iFunctionPrototypeFlag);
            LogHeapState(FALSE, __FILE__, __LINE__);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("ExceptionCaught!:CallProcedureInDll_wrap(): File:%1!s!, Procedure:%2!s!\n"), lpszDLLFile, lpszProcedureToCall));
            switch (GetExceptionCode())
            {
            case EXCEPTION_ACCESS_VIOLATION:
                _tcscpy(szExceptionString, _T("EXCEPTION_ACCESS_VIOLATION"));
                break;
            case EXCEPTION_BREAKPOINT:
                _tcscpy(szExceptionString, _T("EXCEPTION_BREAKPOINT"));
                break;
            case EXCEPTION_DATATYPE_MISALIGNMENT:
                _tcscpy(szExceptionString, _T("EXCEPTION_DATATYPE_MISALIGNMENT"));
                break;
            case EXCEPTION_SINGLE_STEP:
                _tcscpy(szExceptionString, _T("EXCEPTION_SINGLE_STEP"));
                break;
            case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
                _tcscpy(szExceptionString, _T("EXCEPTION_ARRAY_BOUNDS_EXCEEDED"));
                break;
            case EXCEPTION_FLT_DENORMAL_OPERAND:
                _tcscpy(szExceptionString, _T("EXCEPTION_FLT_DENORMAL_OPERAND"));
                break;
            case EXCEPTION_FLT_DIVIDE_BY_ZERO:
                _tcscpy(szExceptionString, _T("EXCEPTION_FLT_DIVIDE_BY_ZERO"));
                break;
            case EXCEPTION_FLT_INEXACT_RESULT:
                _tcscpy(szExceptionString, _T("EXCEPTION_FLT_INEXACT_RESULT"));
                break;
            case EXCEPTION_FLT_INVALID_OPERATION:
                _tcscpy(szExceptionString, _T("EXCEPTION_FLT_INVALID_OPERATION"));
                break;
            case EXCEPTION_FLT_OVERFLOW:
                _tcscpy(szExceptionString, _T("EXCEPTION_FLT_OVERFLOW"));
                break;
            case EXCEPTION_FLT_STACK_CHECK:
                _tcscpy(szExceptionString, _T("EXCEPTION_FLT_STACK_CHECK"));
                break;
            case EXCEPTION_FLT_UNDERFLOW:
                _tcscpy(szExceptionString, _T("EXCEPTION_FLT_UNDERFLOW"));
                break;
            case EXCEPTION_INT_DIVIDE_BY_ZERO:
                _tcscpy(szExceptionString, _T("EXCEPTION_INT_DIVIDE_BY_ZERO"));
                break;
            case EXCEPTION_INT_OVERFLOW:
                _tcscpy(szExceptionString, _T("EXCEPTION_INT_OVERFLOW"));
                break;
            case EXCEPTION_PRIV_INSTRUCTION:
                _tcscpy(szExceptionString, _T("EXCEPTION_PRIV_INSTRUCTION"));
                break;
            case EXCEPTION_NONCONTINUABLE_EXCEPTION:
                _tcscpy(szExceptionString, _T("EXCEPTION_NONCONTINUABLE_EXCEPTION"));
                break;
            default:
                _tcscpy(szExceptionString, _T("Unknown Exception Type"));
                break;
            }
            //MyMessageBox( NULL, IDS_REGSVR_CAUGHT_EXCEPTION, lpszProcedureToCall, lpszDLLFile, GetExceptionCode(), MB_OK | MB_SETFOREGROUND );
            MyMessageBox( NULL, IDS_REGSVR_CAUGHT_EXCEPTION, szExceptionString, lpszProcedureToCall, lpszDLLFile, GetExceptionCode(), MB_OK | MB_SETFOREGROUND );
            dwReturn = E_FAIL;
        }

		if (dwReturn == ERROR_SUCCESS)
		{
			break;
		}
		else
		{
			if (bDisplayMsgOnErrFlag == TRUE)
			{
                iMsg = MyMessageBox( NULL, IDS_RETRY, MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
				switch ( iMsg )
				{
				    case IDRETRY:
					    break;
                    case IDIGNORE:
				    case IDABORT:
                    default:
                        // return whatever err happened
					    goto CallProcedureInDll_wrap_Exit;
                        break;
				}
			}
			else
			{
				// return whatever err happened
				goto CallProcedureInDll_wrap_Exit;
			}

        }
    } while (dwReturn != ERROR_SUCCESS);

CallProcedureInDll_wrap_Exit:
    return dwReturn;
}


void AddOLEAUTRegKey()
{
    CRegKey regCLSID46(_T("CLSID\\{00020424-0000-0000-C000-000000000046}"),HKEY_CLASSES_ROOT);
    if ((HKEY)regCLSID46)
    {
#ifdef _CHICAGO_
        regCLSID46.SetValue(_T(""), _T("PSAutomation"));
#else
        regCLSID46.SetValue(_T(""), _T("PSOAInterface"));
#endif
    }

    CRegKey regInProcServer(_T("CLSID\\{00020424-0000-0000-C000-000000000046}\\InprocServer"),HKEY_CLASSES_ROOT);
    if ((HKEY)regInProcServer)
    {
        regInProcServer.SetValue(_T(""), _T("ole2disp.dll"));
    }

    CRegKey regInProcServer32(_T("CLSID\\{00020424-0000-0000-C000-000000000046}\\InprocServer32"),HKEY_CLASSES_ROOT);
    if ((HKEY)regInProcServer32)
    {
        regInProcServer32.SetValue(_T(""), _T("oleaut32.dll"));
        regInProcServer32.SetValue(_T("ThreadingModel"), _T("Both"));
    }

    return;
}


// Returns:
// ERROR_SUCCESS if successfull.
// ERROR_OPERATION_ABORTED if the operation failed and the user wants to abort setup!
DWORD RegisterOLEControl(LPCTSTR lpszOcxFile, BOOL fAction)
{
    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("RegisterOLEControl():File=%1!s!, Action=%2!d!\n"), lpszOcxFile, fAction));

    DWORD dwReturn = ERROR_SUCCESS;
    if (fAction)
        {
        dwReturn = CallProcedureInDll_wrap(lpszOcxFile, _T("DllRegisterServer"), TRUE, TRUE, FUNCTION_PARAMS_NONE);
        }
    else
        {
#if DBG == 1 || DEBUG == 1 || _DEBUG == 1
        // Show errors if this is a debug build
        dwReturn = CallProcedureInDll_wrap(lpszOcxFile, _T("DllUnregisterServer"), TRUE, TRUE, FUNCTION_PARAMS_NONE);
#else
        // Set 3rd parameter to false so that there are no MyMessageBox popups if any errors
        dwReturn = CallProcedureInDll_wrap(lpszOcxFile, _T("DllUnregisterServer"), FALSE, TRUE, FUNCTION_PARAMS_NONE);
#endif
        }
    return dwReturn;
}


typedef HRESULT (CALLBACK *HCRET)(void);
typedef HRESULT (*PFUNCTION2)(HMODULE myDllHandle);

DWORD CallProcedureInDll(LPCTSTR lpszDLLFile, LPCTSTR lpszProcedureToCall, BOOL bDisplayMsgOnErrFlag, BOOL bInitOleFlag, BOOL iFunctionPrototypeFlag)
{
    iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("------------------\n")));
    iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("CallProcedureInDll(%1!s!): %2!s!\n"), lpszDLLFile, lpszProcedureToCall));
    DWORD dwReturn = ERROR_SUCCESS;
    HINSTANCE hDll = NULL;

    // Diferent function prototypes...
    HCRET hProc = NULL;
    PFUNCTION2 hProc2 = NULL;
    int iTempProcGood = FALSE;
    HRESULT hRes = 0;

    BOOL bBalanceOLE = FALSE;
    HRESULT hInitRes = NULL;

    int err = NOERROR;

    // Variables to changing and saving dirs
    TCHAR szDirName[_MAX_PATH], szFilePath[_MAX_PATH];
    // Variable to set error string
    TCHAR szErrString[256];

    _tcscpy(szDirName, _T(""));
    _tcscpy(szErrString, _T(""));

    // perform a defensive check
    if ( FAILED(FTestForOutstandingCoInits()) )
    {
        iisDebugOut((LOG_TYPE_WARN, _T("Outstanding CoInit in %s. WARNING."), lpszDLLFile));
    }


    // If we need to initialize the ole library then init it.
    if (bInitOleFlag)
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32(OleInitialize):start.\n")));
        bBalanceOLE = iOleInitialize();
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32(OleInitialize):end.\n")));
        if (FALSE == bBalanceOLE)
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32(OleInitialize):start.\n")));
            hInitRes = OleInitialize(NULL);
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32(OleInitialize):end.\n")));
			// Ole Failed.
			dwReturn = hInitRes;
            SetLastError(dwReturn);
		    if (bDisplayMsgOnErrFlag) 
		    {
			    MyMessageBox(NULL, IDS_OLE_INIT_FAILED, lpszDLLFile, hInitRes, MB_OK | MB_SETFOREGROUND);
		    }
    		goto CallProcedureInDll_Exit;
		}
	}

	// Check if the file exists
    if (!IsFileExist(lpszDLLFile)) 
	{
		dwReturn = ERROR_FILE_NOT_FOUND;
		if (bDisplayMsgOnErrFlag) 
		{
			MyMessageBox(NULL, IDS_FILE_DOES_NOT_EXIST, lpszDLLFile, ERROR_FILE_NOT_FOUND, MB_OK | MB_SETFOREGROUND);
		}
        SetLastError(dwReturn);
    	goto CallProcedureInDll_Exit;
	}

    // Change Directory
    GetCurrentDirectory( _MAX_PATH, szDirName );
    InetGetFilePath(lpszDLLFile, szFilePath);

    // Change to The Drive.
    if (-1 == _chdrive( _totupper(szFilePath[0]) - 'A' + 1 )) {}
    if (SetCurrentDirectory(szFilePath) == 0) {}

    // Try to load the module,dll,ocx.
    hDll = LoadLibraryEx(lpszDLLFile, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
	if (!hDll)
	{
		// Failed to load library, Probably because some .dll file is missing.
		// Show the error message.
		iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("CallProcedureInDll():%1!s!:%2!s!:LoadLibraryEx FAILED.\n"), lpszDLLFile, lpszProcedureToCall));
		dwReturn = TYPE_E_CANTLOADLIBRARY;
		if (bDisplayMsgOnErrFlag) 
		{
			MyMessageBox(NULL, IDS_LOADLIBRARY_FAILED, lpszDLLFile, TYPE_E_CANTLOADLIBRARY, MB_OK | MB_SETFOREGROUND);
		}
        SetLastError(dwReturn);

        // check if this file has missing file it's supposed to be linked with.
        // or if the file has mismatched import\export dependencies with linked files.
#ifdef _WIN64
        // don't call cause it's broken
#else
        //Check_File_Dependencies(lpszDLLFile);
#endif

    	goto CallProcedureInDll_Exit;
	}
	
	// Ok module was successfully loaded.  now let's try to get the Address of the Procedure
	// Convert the function name to ascii before passing it to GetProcAddress()
	char AsciiProcedureName[255];
#if defined(UNICODE) || defined(_UNICODE)
    // convert to ascii
    WideCharToMultiByte( CP_ACP, 0, (TCHAR *)lpszProcedureToCall, -1, AsciiProcedureName, 255, NULL, NULL );
#else
    // the is already ascii so just copy
    strcpy(AsciiProcedureName, lpszProcedureToCall);
#endif

    iTempProcGood = TRUE;
    if (iFunctionPrototypeFlag == FUNCTION_PARAMS_HMODULE)
    {
        hProc2 = (PFUNCTION2)GetProcAddress(hDll, AsciiProcedureName);
        if (!hProc2){iTempProcGood = FALSE;}
    }
    else
    {
        hProc = (HCRET)GetProcAddress(hDll, AsciiProcedureName);
        if (!hProc){iTempProcGood = FALSE;}
    }
	if (!iTempProcGood)
	{
		// failed to load,find or whatever this function.
		iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("CallProcedureInDll():%1!s!:%2!s!:() FAILED.\n"), lpszDLLFile, lpszProcedureToCall));
	    dwReturn = ERROR_PROC_NOT_FOUND;
		if (bDisplayMsgOnErrFlag) 
		{
			MyMessageBox(NULL, IDS_UNABLE_TO_LOCATE_PROCEDURE, lpszProcedureToCall, lpszDLLFile, ERROR_PROC_NOT_FOUND, MB_OK | MB_SETFOREGROUND);
		}
        SetLastError(dwReturn);
    	goto CallProcedureInDll_Exit;
	}

	// Call the function that we got the handle to
    iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("CallProcedureInDll: Calling '%1!s!'.Start\n"), lpszProcedureToCall));
    __try
    {
        if (iFunctionPrototypeFlag == FUNCTION_PARAMS_HMODULE)
        {
            hRes = (*hProc2)((HMODULE) g_MyModuleHandle);
        }
        else
        {
            hRes = (*hProc)();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TCHAR szErrorString[100];
        _stprintf(szErrorString, _T("\r\n\r\nException Caught in CallProcedureInDll().  GetExceptionCode()=0x%x.\r\n\r\n"), GetExceptionCode());
        OutputDebugString(szErrorString);
        g_MyLogFile.LogFileWrite(szErrorString);
    }
	
	if (FAILED(hRes))
	{
        dwReturn = E_FAIL;
		if (bDisplayMsgOnErrFlag) 
		{
			MyMessageBox(NULL, IDS_ERR_CALLING_DLL_PROCEDURE, lpszProcedureToCall, lpszDLLFile, hRes, MB_OK | MB_SETFOREGROUND);
		}
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("CallProcedureInDll: Calling '%1!s!'.End.FAILED. Err=%2!x!.\n"), lpszProcedureToCall, hRes));
        // this function returns E_FAIL but
        // the actual error is in GetLastError()
        // set the last error to whatever was returned from the function call
        SetLastError(hRes);
	}
    else
    {
        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("CallProcedureInDll: Calling '%1!s!'.End.SUCCESS.\n"), lpszProcedureToCall));
    }

CallProcedureInDll_Exit:
    if (hDll)
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("FreeLibrary.start.\n")));
        FreeLibrary(hDll);
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("FreeLibrary.end.\n")));
    }
    else
    {
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Did not FreeLibrary: %1!s! !!!!!!!!!!!!\n"), lpszDLLFile));
    }
    if (_tcscmp(szDirName, _T("")) != 0){SetCurrentDirectory(szDirName);}
    // To close the library gracefully, each successful call to OleInitialize,
    // including those that return S_FALSE, must be balanced by a corresponding
    // call to the OleUninitialize function.
    iOleUnInitialize(bBalanceOLE);

    // perform a defensive check
    if ( FAILED(FTestForOutstandingCoInits()) )
    {
        iisDebugOut((LOG_TYPE_WARN, _T("Outstanding CoInit in %s. WARNING."), lpszDLLFile));
    }

    iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("------------------\n")));
    return dwReturn;
}


int IsThisStringInThisCStringList(CStringList &strList, LPCTSTR szStringToLookFor)
{
    int iReturn = FALSE;

    if (strList.IsEmpty() == FALSE)
    {
        POSITION pos = NULL;
        CString csOurString;
        LPTSTR p;
        int nLen = 0;

        pos = strList.GetHeadPosition();
        while (pos) 
        {
            csOurString = strList.GetAt(pos);
            nLen += csOurString.GetLength() + 1;

            // check if we have a match.
            if (0 == _tcsicmp(csOurString, szStringToLookFor))
            {
                // we found a match, return true!
                iReturn = TRUE;
                goto IsThisStringInThisCStringList_Exit;
            }
            strList.GetNext(pos);
        }

    }

IsThisStringInThisCStringList_Exit:
    return iReturn;
}




int KillProcess_Wrap(LPCTSTR lpFullPathOrJustFileName)
{
    int iReturn = FALSE;

    TCHAR szJustTheFileName[_MAX_FNAME];

    // make sure to get only just the filename.
    ReturnFileNameOnly(lpFullPathOrJustFileName, szJustTheFileName);

	// Convert it to ansi for our "kill" function
	char szFile[_MAX_FNAME];
	#if defined(UNICODE) || defined(_UNICODE)
		WideCharToMultiByte( CP_ACP, 0, (WCHAR*)szJustTheFileName, -1, szFile, _MAX_FNAME, NULL, NULL );
	#else
		_tcscpy(szFile, szJustTheFileName);
	#endif

	if (KillProcessNameReturn0(szFile) == 0) 
    {
        iReturn = TRUE;
    }

    return iReturn;
}


void ProgressBarTextStack_Set(int iStringID)
{
    CString csText;
    MyLoadString(iStringID, csText);
    ProgressBarTextStack_Push(csText);
}


void ProgressBarTextStack_Set(int iStringID, const CString& csFileName)
{
    CString csText, csPart;

    // configuring the %s deal....
    MyLoadString(iStringID, csPart);

    // configuring the "filename" deal....
    csText.Format(csPart,csFileName);

    ProgressBarTextStack_Push(csText);
}

void ProgressBarTextStack_Set(int iStringID, const CString& csString1, const CString& csString2)
{
    CString csText, csPart;

    // configuring the %s deal....
    MyLoadString(iStringID, csPart);

    // configuring the "filename" deal....
    csText.Format(csPart,csString1, csString2);

    ProgressBarTextStack_Push(csText);
}

void ProgressBarTextStack_Set(LPCTSTR szProgressTextString)
{
    ProgressBarTextStack_Push(szProgressTextString);
}

void ProgressBarTextStack_Inst_Set( int ServiceNameID, int iInstanceNum)
{
    CString csText, csSvcs;
    TCHAR szShortDesc[_MAX_PATH];

    // Configuring Web Site %d
    MyLoadString(ServiceNameID, csSvcs);
    // Configuring Web Site 1
    csText.Format(csSvcs, iInstanceNum);

    ProgressBarTextStack_Push(csText);
}

void ProgressBarTextStack_InstVRoot_Set( int ServiceNameID, int iInstanceNum, CString csVRName)
{
    CString csText, csSvcs;
    TCHAR szShortDesc[_MAX_PATH];
    // Configuring Web Site %d, %s
    MyLoadString(ServiceNameID, csSvcs);
    // Configuring Web Site 1, Virtual Dir %s
    csText.Format(csSvcs, iInstanceNum, csVRName);

    ProgressBarTextStack_Push(csText);    
}

void ProgressBarTextStack_InstInProc_Set( int ServiceNameID, int iInstanceNum, CString csVRName)
{
    CString csText, csSvcs;
    TCHAR szShortDesc[_MAX_PATH];

    // Configuring Web Site %d, %s
    MyLoadString(ServiceNameID, csSvcs);
    // Configuring Web Site 1, In process Application %s
    csText.Format(csSvcs, iInstanceNum, csVRName);
    
    ProgressBarTextStack_Push(csText);
}


int ProcessEntry_CheckOS(IN LPCTSTR szOSstring)
{
    int iTempFlag = TRUE;
    int iOSTypes = 0;
    if (szOSstring)
    {
        // This is workstation, check if we should be installing this on workstation...
        if (g_pTheApp->m_eNTOSType == OT_NTW)
        {
            iTempFlag = FALSE;
            if (IsValidNumber((LPCTSTR)szOSstring))
                {iOSTypes = _ttoi(szOSstring);}
            if (iOSTypes == 0) {iTempFlag = TRUE;}
            if (iOSTypes == 1+2+4) {iTempFlag = TRUE;}
            if (iOSTypes == 1+2) {iTempFlag = TRUE;}
            if (iOSTypes == 2+4) {iTempFlag = TRUE;}
            if (iOSTypes == 2) {iTempFlag = TRUE;}
        }

        if (g_pTheApp->m_eNTOSType == OT_NTS)
        {
            iTempFlag = FALSE;
            if (IsValidNumber((LPCTSTR)szOSstring))
                {iOSTypes = _ttoi(szOSstring);}
            if (iOSTypes == 0) {iTempFlag = TRUE;}
            if (iOSTypes == 1+2+4) {iTempFlag = TRUE;}
            if (iOSTypes == 1+2) {iTempFlag = TRUE;}
            if (iOSTypes == 1+4) {iTempFlag = TRUE;}
            if (iOSTypes == 1) {iTempFlag = TRUE;}
        }

        if (g_pTheApp->m_eNTOSType == OT_PDC_OR_BDC)
        {
            iTempFlag = FALSE;
            if (IsValidNumber((LPCTSTR)szOSstring))
                {iOSTypes = _ttoi(szOSstring);}
            if (iOSTypes == 0) {iTempFlag = TRUE;}
            if (iOSTypes == 1+2+4) {iTempFlag = TRUE;}
            if (iOSTypes == 1+2) {iTempFlag = TRUE;}
            if (iOSTypes == 1+4) {iTempFlag = TRUE;}
            if (iOSTypes == 1) {iTempFlag = TRUE;}
        }
    }

    return iTempFlag;
}

int ProcessEntry_CheckEnterprise(IN LPCTSTR szEnterprise)
{
    int iTempFlag = TRUE;
    int iEnterpriseFlag = 0;
    if (szEnterprise)
    {
        if (IsValidNumber((LPCTSTR)szEnterprise))
            {iEnterpriseFlag = _ttoi(szEnterprise);}

        // This entry should only get installed on enterprise.
        // so check if this machine is an enterprise machine...
        if (iEnterpriseFlag != 0)
        {
            // if this is not an enterprise machine.
            // then return false, since it should not be installed.
            if (TRUE == iReturnTrueIfEnterprise())
            {
                iTempFlag = TRUE;
            }
            else
            {
                iTempFlag = FALSE;
            }
        }
    }

    return iTempFlag;
}

int ProcessEntry_PlatArch(IN LPCTSTR szPlatArch)
{
    int iTempFlag = TRUE;
    int iPlatArchTypes = 0;
    if (szPlatArch)
    {
        // This is x86, then check if we should be installing on x86
        if (_tcsicmp(g_pTheApp->m_csPlatform, _T("x86")) == 0)
        {
            iTempFlag = FALSE;
            if (IsValidNumber((LPCTSTR)szPlatArch))
                {iPlatArchTypes = _ttoi(szPlatArch);}
            if (iPlatArchTypes == 0) {iTempFlag = TRUE;}
            if (iPlatArchTypes == 1+2) {iTempFlag = TRUE;}
            if (iPlatArchTypes == 1) {iTempFlag = TRUE;}
        }

        if (_tcsicmp(g_pTheApp->m_csPlatform, _T("IA64")) == 0)
        {
            iTempFlag = FALSE;
            if (IsValidNumber((LPCTSTR)szPlatArch))
                {iPlatArchTypes = _ttoi(szPlatArch);}
            if (iPlatArchTypes == 0) {iTempFlag = TRUE;}
            if (iPlatArchTypes == 1+2) {iTempFlag = TRUE;}
            if (iPlatArchTypes == 2) {iTempFlag = TRUE;}
        }
    }
    return iTempFlag;
}


void ProcessEntry_AskLast(ThingToDo ParsedLine, int iWhichOneToUse)
{
    if (_tcsicmp(ParsedLine.szMsgBoxAfter, _T("1")) == 0) 
    {
        // just incase we have don't display user messagebox off.
        int iSaveOld_AllowMessageBoxPopups = g_pTheApp->m_bAllowMessageBoxPopups;
        // Make sure there are MyMessageBox popups!
        // Make sure there are MyMessageBox popups!
        g_pTheApp->m_bAllowMessageBoxPopups = TRUE; 
        if (iWhichOneToUse == 2)
            {MyMessageBox( NULL, IDS_COMPLETED_FILE_CALL,ParsedLine.szData1,MB_OK | MB_SETFOREGROUND );}
        else
            {MyMessageBox( NULL, IDS_COMPLETED_FILE_CALL,ParsedLine.szFileName,MB_OK | MB_SETFOREGROUND );}
        g_pTheApp->m_bAllowMessageBoxPopups = iSaveOld_AllowMessageBoxPopups;
    }
    return;
}


int ProcessEntry_AskFirst(ThingToDo ParsedLine, int iWhichOneToUse)
{
    int iReturn = TRUE;
    int iReturnTemp = 0;

    // check if we need to ask the user if they want to call it for sure.
    if (_tcsicmp(ParsedLine.szMsgBoxBefore, _T("1")) == 0)
    {
        // just incase we have don't display user messagebox off.
        int iSaveOld_AllowMessageBoxPopups = g_pTheApp->m_bAllowMessageBoxPopups;
        // Make sure there are MyMessageBox popups!
        g_pTheApp->m_bAllowMessageBoxPopups = TRUE; 
        if (iWhichOneToUse == 2)
        {
            iReturnTemp = MyMessageBox(NULL, IDS_BEFORE_CALLING_FILE, ParsedLine.szData1, MB_YESNO | MB_SETFOREGROUND);
        }
        else
        {
            iReturnTemp = MyMessageBox(NULL, IDS_BEFORE_CALLING_FILE, ParsedLine.szFileName, MB_YESNO | MB_SETFOREGROUND);
        }
        g_pTheApp->m_bAllowMessageBoxPopups = iSaveOld_AllowMessageBoxPopups;

        // display the messagebox
        if (IDYES != iReturnTemp)
        {
            iReturn = FALSE;
            iisDebugOut((LOG_TYPE_TRACE, _T("ProcessEntry_AskFirst:MyMessageBox Response = IDNO. Exiting.\n")));
        }            
    }

    return iReturn;
}

int ProcessEntry_CheckAll(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = TRUE;

    // Check if we pass for os system
    if (!ProcessEntry_CheckOS(ParsedLine.szOS))
    {
        iReturn = FALSE;
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ProcessEntry_CheckAll():File=%s. Section=%s. Should not be setup on this OS platform (workstation, server, etc...).  Skipping.\n"),ParsedLine.szFileName, szTheSection));
        goto ProcessEntry_CheckAll_Exit;
    }

    // check if we pass for platform arch
    if (!ProcessEntry_PlatArch(ParsedLine.szPlatformArchitecture))
    {
        iReturn = FALSE;
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ProcessEntry_CheckAll():File=%s. Section=%s. Should not be setup on this plat arch (%s).  Skipping.\n"), ParsedLine.szFileName, szTheSection, ParsedLine.szPlatformArchitecture));
        goto ProcessEntry_CheckAll_Exit;
    }

    // check if we pass for enterprise
    if (!ProcessEntry_CheckEnterprise(ParsedLine.szEnterprise))
    {
        iReturn = FALSE;
        goto ProcessEntry_CheckAll_Exit;
    }

ProcessEntry_CheckAll_Exit:
    return iReturn;
}



int ProcessEntry_CallDll(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;
    int iProgressBarUpdated = FALSE;
    int iShowErrorsOnFail = TRUE;

    TCHAR szDirBefore[_MAX_PATH];
    _tcscpy(szDirBefore, _T(""));
    
    // Get the type.
    // 100=Type (1=DllFunction,2=DllFunctionInitOle, 2=Executable, 3=RunThisExe, 4=DoSection, 5=DoINFSection)
    if ( _tcsicmp(ParsedLine.szType, _T("1")) != 0 && _tcsicmp(ParsedLine.szType, _T("2")) != 0 )
    {
        goto ProcessEntry_CallDll_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine ) )
    {
        goto ProcessEntry_CallDll_Exit;
    }
    
    // Make sure we have a value for the entry point..
    iTempFlag = FALSE;
    if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
    if (iTempFlag == FALSE)
    {
        iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
        goto ProcessEntry_CallDll_Exit;
    }

    // make sure we have a filename entry
    iTempFlag = FALSE;
    if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
    if (iTempFlag == FALSE)
    {
        iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
        goto ProcessEntry_CallDll_Exit;
    }

    // make sure the szFileName exists
    if (!IsFileExist(ParsedLine.szFileName))
    {
        // The file does not exists.
        // Check if we need to display an error!
        if (_tcsicmp(ParsedLine.szErrIfFileNotFound, _T("1")) == 0) 
        {
            // display the messagebox
            MyMessageBox(NULL, IDS_FILE_DOES_NOT_EXIST, ParsedLine.szFileName, ERROR_FILE_NOT_FOUND, MB_OK | MB_SETFOREGROUND);
        }
        else
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("ProcessEntry_CallDll():FileDoesNotExist=%s.\n"),ParsedLine.szFileName));
        }
        //goto ProcessEntry_CallDll_Exit;
    }

    // At this point the file exists...
    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    // update the progress bar if we need to
    if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0) 
        {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
        iProgressBarUpdated = TRUE;
        }

    // Check if we need to change to a specific dir first...
    if (ParsedLine.szChangeDir)
    {
        if (IsFileExist(ParsedLine.szChangeDir))
        {
            // save the current dir
            GetCurrentDirectory( _MAX_PATH, szDirBefore);
            // change to this dir
            SetCurrentDirectory(ParsedLine.szChangeDir);
        }
    }

    // check if we need to ask the user if they want to call it for sure.
    if (!ProcessEntry_AskFirst(ParsedLine, 1))
    {
        goto ProcessEntry_CallDll_Exit;
    }
    
    // Call the function!!!!!
    if (_tcsicmp(ParsedLine.szType, _T("2")) == 0)
    {
        // Initialize OLE

        // check if they want us to pass them the hmodule for this module
        // so they can call our exported functions (for logging)
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
        {
            CallProcedureInDll_wrap(ParsedLine.szFileName, ParsedLine.szData1, iShowErrorsOnFail, TRUE, FUNCTION_PARAMS_HMODULE);
        }
        else
        {
            CallProcedureInDll_wrap(ParsedLine.szFileName, ParsedLine.szData1, iShowErrorsOnFail, TRUE, FUNCTION_PARAMS_NONE);
        }
    }
    else
    {
        // do not initialize ole!

        // check if they want us to pass them the hmodule for this module
        // so they can call our exported functions (for logging)
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
        {
            CallProcedureInDll_wrap(ParsedLine.szFileName, ParsedLine.szData1, iShowErrorsOnFail, FALSE, FUNCTION_PARAMS_HMODULE);
        }
        else
        {
            CallProcedureInDll_wrap(ParsedLine.szFileName, ParsedLine.szData1, iShowErrorsOnFail, FALSE, FUNCTION_PARAMS_NONE);
        }
    }

    iReturn = TRUE;

    if (ParsedLine.szChangeDir)
    {
        if (szDirBefore)
        {
            // change back to the original dir
            SetCurrentDirectory(szDirBefore);
        }
    }

    // display the messagebox that we completed the call...
    ProcessEntry_AskLast(ParsedLine,1);
   
   
ProcessEntry_CallDll_Exit:
    if (TRUE == iProgressBarUpdated){ProgressBarTextStack_Pop();}
    return iReturn;
}



int ProcessEntry_Call_Exe(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempNotMinimizedFlag = FALSE;
    int iTempFlag = FALSE;
    int iProgressBarUpdated = FALSE;
    int iShowErrorsOnFail = TRUE;
    int iReturnCode = FALSE;
    int iType = 0;
    DWORD dwTimeOut = INFINITE;

    TCHAR szDirBefore[_MAX_PATH];
    _tcscpy(szDirBefore, _T(""));

    // Get the type.
    // 100=Type (1=DllFunction,2=DllFunctionInitOle, 2=Executable, 3=RunThisExe, 4=DoSection, 5=DoINFSection)
    if ( _tcsicmp(ParsedLine.szType, _T("3")) != 0)
    {
        goto ProcessEntry_Call_Exe_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_Call_Exe_Exit;
    }
        
    // make sure we have a filename entry
    iTempFlag = FALSE;
    if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
    if (iTempFlag == FALSE)
    {
        iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
        goto ProcessEntry_Call_Exe_Exit;
    }

    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0) 
        {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
        iProgressBarUpdated = TRUE;
        }

    // Check if we need to change to a specific dir first...
    if (ParsedLine.szChangeDir)
    {
        if (IsFileExist(ParsedLine.szChangeDir))
        {
            // save the current dir
            GetCurrentDirectory( _MAX_PATH, szDirBefore);
            // change to this dir
            SetCurrentDirectory(ParsedLine.szChangeDir);
        }
    }

    // check if we need to ask the user if they want to call it for sure.
    if (!ProcessEntry_AskFirst(ParsedLine, 1))
    {
        goto ProcessEntry_Call_Exe_Exit;
    }

    // make sure the szFileName exists
    if (!IsFileExist(ParsedLine.szFileName))
    {
        // The file does not exists.
        // Check if we need to display an error!
        if (_tcsicmp(ParsedLine.szErrIfFileNotFound, _T("1")) == 0) 
        {
            // display the messagebox
            MyMessageBox(NULL, IDS_FILE_DOES_NOT_EXIST, ParsedLine.szFileName, ERROR_FILE_NOT_FOUND, MB_OK | MB_SETFOREGROUND);
        }
        else
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("ProcessEntry_Call_Exe():FileDoesNotExist=%s.\n"),ParsedLine.szFileName));
        }
        //goto ProcessEntry_Call_Exe_Exit;
    }

    // Run The Executable...
    // iShowErrorsOnFail
    iReturnCode = FALSE;
    iType = 0;
    TCHAR szFullPathString[_MAX_PATH + _MAX_PATH + _MAX_PATH];
    _tcscpy(szFullPathString, ParsedLine.szFileName);
    _tcscat(szFullPathString, _T(" "));
    _tcscat(szFullPathString, ParsedLine.szData1);

    // Check if they specified timeout in sections.
    dwTimeOut = INFINITE;
    if (_tcsicmp(ParsedLine.szData2, _T("")) != 0)
        {dwTimeOut = atodw(ParsedLine.szData2);}

    if (_tcsicmp(ParsedLine.szData3, _T("")) != 0)
        {iType = _ttoi(ParsedLine.szData3);}

    if (_tcsicmp(ParsedLine.szData4, _T("")) != 0)
        {iTempNotMinimizedFlag = TRUE;}

    if (ParsedLine.szData1 && _tcsicmp(ParsedLine.szData1, _T("")) != 0)
        {
            switch (iType)
            {
                case 1:
                        iReturnCode = RunProgram(ParsedLine.szFileName, ParsedLine.szData1, !iTempNotMinimizedFlag, dwTimeOut, FALSE);
                        break;
                case 2:
                        iReturnCode = RunProgram(szFullPathString, NULL, !iTempNotMinimizedFlag, dwTimeOut, FALSE);
                        break;
                default:
                        iReturnCode = RunProgram(NULL, szFullPathString, !iTempNotMinimizedFlag, dwTimeOut, FALSE);
            }
       }
    else
        {
        iReturnCode = RunProgram(ParsedLine.szFileName, NULL, !iTempNotMinimizedFlag, dwTimeOut, FALSE);
        }
    if (iReturnCode != TRUE)
        {
        if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szFileName, GetLastError(), MB_OK | MB_SETFOREGROUND);}
        else{iisDebugOut((LOG_TYPE_TRACE, _T("RunProgram(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szFileName, GetLastError() ));}
        }


    iReturn = TRUE;

    // change back to the original dir
    if (ParsedLine.szChangeDir)
        {if (szDirBefore){SetCurrentDirectory(szDirBefore);}}

    // display the messagebox that we completed the call...
    ProcessEntry_AskLast(ParsedLine,1);

ProcessEntry_Call_Exe_Exit:
    if (TRUE == iProgressBarUpdated){ProgressBarTextStack_Pop();}
    return iReturn;
}


// 100=4
int ProcessEntry_Internal_iisdll(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;
    int iProgressBarUpdated = FALSE;
    int iShowErrorsOnFail = TRUE;
    int iReturnCode = FALSE;
    DWORD dwTimeOut = INFINITE;

    int iFound = FALSE;

    TCHAR szDirBefore[_MAX_PATH];
    _tcscpy(szDirBefore, _T(""));

    // Get the type.
    // 100=Type (1=DllFunction,2=DllFunctionInitOle, 2=Executable, 3=RunThisExe, 4=DoSection, 5=DoINFSection)
    if ( _tcsicmp(ParsedLine.szType, _T("4")) != 0)
    {
        goto ProcessEntry_Internal_iisdll_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_Internal_iisdll_Exit;
    }
        
    // make sure we have a filename entry
    iTempFlag = FALSE;
    if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
    if (iTempFlag == FALSE)
    {
        iisDebugOut((LOG_TYPE_TRACE,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
        goto ProcessEntry_Internal_iisdll_Exit;
    }

    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0) 
        {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
        iProgressBarUpdated = TRUE;
        }

    // Check if we need to change to a specific dir first...
    if (ParsedLine.szChangeDir)
    {
        if (IsFileExist(ParsedLine.szChangeDir))
        {
            // save the current dir
            GetCurrentDirectory( _MAX_PATH, szDirBefore);
            // change to this dir
            SetCurrentDirectory(ParsedLine.szChangeDir);
        }
    }

    // check if we need to ask the user if they want to call it for sure.
    if (!ProcessEntry_AskFirst(ParsedLine, 1))
    {
        goto ProcessEntry_Internal_iisdll_Exit;
    }

    // Get the internal function to call...
    if (_tcsicmp(ParsedLine.szFileName, _T("Register_iis_common")) == 0)
        {iReturnCode = Register_iis_common();iFound=TRUE;}

    if (_tcsicmp(ParsedLine.szFileName, _T("Register_iis_core")) == 0)
        {iReturnCode = Register_iis_core();iFound=TRUE;}

    if (_tcsicmp(ParsedLine.szFileName, _T("Register_iis_inetmgr")) == 0)
        {iReturnCode = Register_iis_inetmgr();iFound=TRUE;}
    if (_tcsicmp(ParsedLine.szFileName, _T("Register_iis_pwmgr")) == 0)
        {iReturnCode = Register_iis_pwmgr();iFound=TRUE;}

    if (_tcsicmp(ParsedLine.szFileName, _T("Register_iis_doc")) == 0)
        {iReturnCode = Register_iis_doc();iFound=TRUE;}
    if (_tcsicmp(ParsedLine.szFileName, _T("Register_iis_htmla")) == 0)
        {iReturnCode = Register_iis_htmla();iFound=TRUE;}

    if (_tcsicmp(ParsedLine.szFileName, _T("Register_iis_www")) == 0)
        {iReturnCode = Register_iis_www();iFound=TRUE;}
    if (_tcsicmp(ParsedLine.szFileName, _T("Register_iis_ftp")) == 0)
        {iReturnCode = Register_iis_ftp();iFound=TRUE;}

    if (_tcsicmp(ParsedLine.szFileName, _T("Unregister_old_asp")) == 0)
        {iReturnCode = Unregister_old_asp();iFound=TRUE;}

    if (_tcsicmp(ParsedLine.szFileName, _T("Unregister_iis_common")) == 0)
        {iReturnCode = Unregister_iis_common();iFound=TRUE;}
    if (_tcsicmp(ParsedLine.szFileName, _T("Unregister_iis_core")) == 0)
        {iReturnCode = Unregister_iis_core();iFound=TRUE;}
    if (_tcsicmp(ParsedLine.szFileName, _T("Unregister_iis_htmla")) == 0)
        {iReturnCode = Unregister_iis_htmla();iFound=TRUE;}
    if (_tcsicmp(ParsedLine.szFileName, _T("Unregister_iis_inetmgr")) == 0)
        {iReturnCode = Unregister_iis_inetmgr();iFound=TRUE;}
    if (_tcsicmp(ParsedLine.szFileName, _T("Unregister_iis_pwmgr")) == 0)
        {iReturnCode = Unregister_iis_pwmgr();iFound=TRUE;}
    if (_tcsicmp(ParsedLine.szFileName, _T("Unregister_iis_www")) == 0)
        {iReturnCode = Unregister_iis_www();iFound=TRUE;}
    if (_tcsicmp(ParsedLine.szFileName, _T("Unregister_iis_ftp")) == 0)
        {iReturnCode = Unregister_iis_ftp();iFound=TRUE;}


    if (iFound != TRUE)
    {
        iisDebugOut((LOG_TYPE_ERROR,  _T("%s():FAILURE. Internal Function Does not exist. entry=%s. Section=%s.\n"), _T("ProcessEntry_Internal_iisdll"), csEntry, szTheSection));
    }
 
    /*
    if (iReturnCode != TRUE)
        {
        if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szFileName, GetLastError(), MB_OK | MB_SETFOREGROUND);}
        else{iisDebugOut((LOG_TYPE_TRACE, _T("RunProgram(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szFileName, GetLastError() ));}
        }
    */


    iReturn = TRUE;

    // change back to the original dir
    if (ParsedLine.szChangeDir)
        {if (szDirBefore){SetCurrentDirectory(szDirBefore);}}

    // display the messagebox that we completed the call...
    ProcessEntry_AskLast(ParsedLine,1);

ProcessEntry_Internal_iisdll_Exit:
    if (TRUE == iProgressBarUpdated){ProgressBarTextStack_Pop();}
    return iReturn;
}


int ProcessEntry_Call_Section(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;
    int iProgressBarUpdated = FALSE;
    int iShowErrorsOnFail = TRUE;

    TCHAR szDirBefore[_MAX_PATH];
    _tcscpy(szDirBefore, _T(""));

    // Get the type.
    // 100=Type (1=DllFunction,2=DllFunctionInitOle, 2=Executable, 3=RunThisExe, 4=DoSection, 5=DoINFSection)
    if ( _tcsicmp(ParsedLine.szType, _T("0")) != 0 && _tcsicmp(ParsedLine.szType, _T("5")) != 0 && _tcsicmp(ParsedLine.szType, _T("6")) != 0 )
    {
        goto ProcessEntry_6_Exit;
    }

    // make sure we have a INF Section
    iTempFlag = FALSE;
    if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
    if (iTempFlag == FALSE)
    {
        iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
        goto ProcessEntry_6_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, ParsedLine.szData1, ParsedLine) )
    {
        goto ProcessEntry_6_Exit;
    }

    // set the show erros on fail flag
    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    // update the progress bar if we need to
    if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0) 
        {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
        iProgressBarUpdated = TRUE;
        }

    // Check if we need to change to a specific dir first...
    if (ParsedLine.szChangeDir)
    {
        if (IsFileExist(ParsedLine.szChangeDir))
        {
            // save the current dir
            GetCurrentDirectory( _MAX_PATH, szDirBefore);
            // change to this dir
            SetCurrentDirectory(ParsedLine.szChangeDir);
        }
    }

    // check if we need to ask the user if they want to call it for sure.
    if (!ProcessEntry_AskFirst(ParsedLine, 2))
    {
        goto ProcessEntry_6_Exit;
    }


    //
    //
    // Run The INF Section ...
    //
    // ParsedLine.szData1
    //

    if ( _tcsicmp(ParsedLine.szType, _T("5")) == 0)
    {
        //
        // Do another one of these "special" install sections
        //
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
        iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));

            // Check if it failed...
            if (FALSE == iTempFlag)
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("SetupInstallFromInfSection(%s). section missing\n"), ParsedLine.szData1));
            }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("6")) == 0)
    {
        //
        // Do a regular ole inf section
        //
        CString csTempSectionName;
        csTempSectionName = ParsedLine.szData1;
        if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, csTempSectionName))
        {
            TCHAR szTempSectionName[_MAX_PATH];
            _tcscpy(szTempSectionName,csTempSectionName);

            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling InstallInfSection:%1!s!:Start.\n"), ParsedLine.szData1));
            iTempFlag = InstallInfSection_NoFiles(g_pTheApp->m_hInfHandle,_T(""),szTempSectionName);
            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling InstallInfSection:%1!s!:End.\n"), ParsedLine.szData1));

            // Check if it failed...
            if (FALSE == iTempFlag)
            {
                // the call failed..
                iisDebugOut((LOG_TYPE_WARN, _T("SetupInstallFromInfSection(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));
            }
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("0")) == 0)
    {
        //
        // Do a special installsection deal which queues files in the ocm manage global file queue.
        //
        if (g_GlobalFileQueueHandle)
        {
            // SP_COPY_NOPRUNE = setupapi has a new deal which will prune files from the copyqueue if they already exist on the system.
            //                   however, the problem with the new deal is that the pruning code does not check if you have the same file
            //                   queued in the delete or rename queue.  specify SP_COPY_NOPRUNE to make sure that our file never gets
            //                   pruned (removed) from the copy queue. aaronl 12/4/98
            int iCopyType = SP_COPY_NOPRUNE;
            //int iCopyType = SP_COPY_FORCE_NEWER | SP_COPY_NOPRUNE;
            if (_tcsicmp(ParsedLine.szData2, _T("")) != 0)
                {iCopyType = _ttoi(ParsedLine.szData2);}

            CString csTempSectionName;
            csTempSectionName = ParsedLine.szData1;
            if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, csTempSectionName))
            {
                TCHAR szTempSectionName[_MAX_PATH];
                _tcscpy(szTempSectionName,csTempSectionName);

                iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("Calling SetupInstallFilesFromInfSection:%1!s!, copytype=%2!d!:Start.\n"), ParsedLine.szData1, iCopyType));
                iTempFlag = SetupInstallFilesFromInfSection(g_pTheApp->m_hInfHandle,NULL,g_GlobalFileQueueHandle,szTempSectionName,NULL,iCopyType);
                g_GlobalFileQueueHandle_ReturnError = iTempFlag;
            }
        }

        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling SetupInstallFilesFromInfSection:%1!s!:End.\n"), ParsedLine.szData1));

        // Check if it failed...
        if (FALSE == iTempFlag)
        {
            // the call failed..
            iisDebugOut((LOG_TYPE_WARN, _T("SetupInstallFromInfSection(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));
        }
    }
        
    iReturn = TRUE;
    
    if (ParsedLine.szChangeDir)
    {
        if (szDirBefore)
        {
            // change back to the original dir
            SetCurrentDirectory(szDirBefore);
        }
    }

    // display the messagebox that we completed the call...
    ProcessEntry_AskLast(ParsedLine,2);

ProcessEntry_6_Exit:
    if (TRUE == iProgressBarUpdated){ProgressBarTextStack_Pop();}
    return iReturn;
}


int ProcessEntry_Misc1(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;
    int iProgressBarUpdated = FALSE;
    int iShowErrorsOnFail = TRUE;

    TCHAR szDirBefore[_MAX_PATH];
    _tcscpy(szDirBefore, _T(""));

    // Get the type.
    if ( _tcsicmp(ParsedLine.szType, _T("7")) != 0 && _tcsicmp(ParsedLine.szType, _T("8")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("9")) != 0 && _tcsicmp(ParsedLine.szType, _T("10")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("11")) != 0 && _tcsicmp(ParsedLine.szType, _T("12")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("12")) != 0 && _tcsicmp(ParsedLine.szType, _T("13")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("14")) != 0 && _tcsicmp(ParsedLine.szType, _T("17")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("18")) != 0 
         )
    {
        goto ProcessEntry_Misc1_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_Misc1_Exit;
    }
        
    // make sure we have a filename entry
    iTempFlag = FALSE;
    if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
    if (iTempFlag == FALSE)
    {
        // type 10
        // type 12 do not need filename
        if ( _tcsicmp(ParsedLine.szType, _T("10")) != 0 && _tcsicmp(ParsedLine.szType, _T("12")) != 0)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc1_Exit;
        }
    }

    //
    // Counters.ini files are always in the system dir
    // tack on the extra stuff, and make sure the file exists...
    //
    if ( _tcsicmp(ParsedLine.szType, _T("7")) == 0)
    {
        CString csFullFilePath;
        csFullFilePath = g_pTheApp->m_csSysDir;
        csFullFilePath += _T("\\");
        csFullFilePath += ParsedLine.szFileName;
        // make sure the szFileName exists
        if (!IsFileExist(csFullFilePath))
        {
            // The file does not exists.
            // Check if we need to display an error!
            if (_tcsicmp(ParsedLine.szErrIfFileNotFound, _T("1")) == 0) 
            {
                // display the messagebox
                MyMessageBox(NULL, IDS_FILE_DOES_NOT_EXIST, csFullFilePath, ERROR_FILE_NOT_FOUND, MB_OK | MB_SETFOREGROUND);
            }
            else
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("ProcessEntry_Misc1():FileDoesNotExist=%s.\n"),csFullFilePath));
            }
            goto ProcessEntry_Misc1_Exit;
        }
    }

    //
    // Check if the binary exists for addevent log!
    //
    if ( _tcsicmp(ParsedLine.szType, _T("9")) == 0)
    {
        // make sure the szFileName exists
        if (!IsFileExist(ParsedLine.szFileName))
        {
            // The file does not exists.
            // Check if we need to display an error!
            if (_tcsicmp(ParsedLine.szErrIfFileNotFound, _T("1")) == 0) 
            {
                // display the messagebox
                MyMessageBox(NULL, IDS_FILE_DOES_NOT_EXIST, ParsedLine.szFileName, ERROR_FILE_NOT_FOUND, MB_OK | MB_SETFOREGROUND);
            }
            else
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("ProcessEntry_Misc1():FileDoesNotExist=%s.\n"),ParsedLine.szFileName));
            }
            goto ProcessEntry_Misc1_Exit;
        }
    }

    // if this is for addevent log, then check for the other information...
    //  AddEventLog( TRUE, _T("W3SVC"), csBinPath, 0x0 );
    //  InstallPerformance(REG_WWWPERFORMANCE, _T("w3ctrs.DLL"), _T("OpenW3PerformanceData"), _T("CloseW3PerformanceData"), _T("CollectW3PerformanceData"));
    if ( _tcsicmp(ParsedLine.szType, _T("9")) == 0 || _tcsicmp(ParsedLine.szType, _T("13")) == 0)
    {
        // make sure we have a szData1 entry (
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc1_Exit;
        }

        // make sure we have a szData2 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc1_Exit;
        }

        // make sure we have a szData3 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc1_Exit;
        }

        if ( _tcsicmp(ParsedLine.szType, _T("13")) == 0)
        {
            // make sure we have a szData4 entry
            iTempFlag = FALSE;
            if (_tcsicmp(ParsedLine.szData4, _T("")) != 0) {iTempFlag = TRUE;}
            if (iTempFlag == FALSE)
            {
                iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz105_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
                goto ProcessEntry_Misc1_Exit;
            }
        }

    }


    // if this is for addevent log, then check for the other information...
    //RemoveEventLog( FALSE, _T("W3Ctrs") );
    if ( _tcsicmp(ParsedLine.szType, _T("10")) == 0)
    {
        // make sure we have a szData1 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc1_Exit;
        }

        // make sure we have a szData2 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc1_Exit;
        }
    }

    // if this is for installAgent, check for other data..
    // 
    // INT InstallAgent( CString nlsName, CString nlsPath )
    // INT RemoveAgent( CString nlsServiceName )
    //
    if ( _tcsicmp(ParsedLine.szType, _T("11")) == 0 || _tcsicmp(ParsedLine.szType, _T("12")) == 0)
    {
        // make sure we have a szData1 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc1_Exit;
        }
    }

    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0) 
        {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
        iProgressBarUpdated = TRUE;
        }

    // Check if we need to change to a specific dir first...
    if (ParsedLine.szChangeDir)
    {
        if (IsFileExist(ParsedLine.szChangeDir))
        {
            // save the current dir
            GetCurrentDirectory( _MAX_PATH, szDirBefore);
            // change to this dir
            SetCurrentDirectory(ParsedLine.szChangeDir);
        }
    }

    // check if we need to ask the user if they want to call it for sure.
    if (!ProcessEntry_AskFirst(ParsedLine, 1))
    {
        goto ProcessEntry_Misc1_Exit;
    }


    //
    // send this to the lodctr function...
    // lodctr(_T("w3ctrs.ini"));
    //
    // see if it's lodctr or unlodctr ....
    //
    if ( _tcsicmp(ParsedLine.szType, _T("7")) == 0)
    {
        lodctr(ParsedLine.szFileName);
    }

    // if this is a unlodctr, should look like this....
    //
    // unlodctr( _T("W3SVC") );
    //
    if ( _tcsicmp(ParsedLine.szType, _T("8")) == 0)
    {
        unlodctr(ParsedLine.szFileName);
    }

    // if this is a AddEventLog, should look like this...
    //
    // AddEventLog( TRUE, _T("W3SVC"), csBinPath, 0x0 );
    //
    if ( _tcsicmp(ParsedLine.szType, _T("9")) == 0)
    {
        int iTempSystemFlag = 0;
        int dwTempEventLogtype = 0;
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0){iTempSystemFlag = 1;}
        dwTempEventLogtype = atodw(ParsedLine.szData3);
        // Call event log registration function
        AddEventLog( iTempSystemFlag, ParsedLine.szData1, ParsedLine.szFileName, dwTempEventLogtype);
    }

    // if this is a RemoveEventLog, should look like this...
    //
    // RemoveEventLog( FALSE, _T("W3Ctrs") );
    //
    if ( _tcsicmp(ParsedLine.szType, _T("10")) == 0)
    {
        int iTempSystemFlag = 0;
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0){iTempSystemFlag = 1;}
        // Call event log registration function
        RemoveEventLog(iTempSystemFlag, ParsedLine.szData1);
    }

    // if this is installagent
    //
    // INT InstallAgent( CString nlsName, CString nlsPath )
    // INT RemoveAgent( CString nlsServiceName )
    //
    if ( _tcsicmp(ParsedLine.szType, _T("11")) == 0)
    {
        InstallAgent(ParsedLine.szData1, ParsedLine.szFileName);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("12")) == 0)
    {
        RemoveAgent(ParsedLine.szData1);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("13")) == 0)
    {
        InstallPerformance(ParsedLine.szData1, ParsedLine.szFileName, ParsedLine.szData2, ParsedLine.szData3, ParsedLine.szData4);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("14")) == 0)
    {
        CString csPath = ParsedLine.szFileName;
        CreateLayerDirectory(csPath);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("17")) == 0)
    {
        int iUseWildCards = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("1")) == 0){iUseWildCards = TRUE;}

        CString csPath = ParsedLine.szFileName;
        if (iUseWildCards)
        {
            TCHAR szTempDir[_MAX_DRIVE + _MAX_PATH];
            TCHAR szTempFileName[_MAX_PATH + _MAX_EXT];
            if (ReturnFilePathOnly(csPath,szTempDir))
            {
                if (TRUE == ReturnFileNameOnly(csPath, szTempFileName))
                   {DeleteFilesWildcard(szTempDir,szTempFileName);}
            }
        }
        else
        {
            InetDeleteFile(csPath);
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("18")) == 0)
    {
        int iTempDeleteEvenIfFull = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("1")) == 0){iTempDeleteEvenIfFull = 1;}
        
        CString csPath = ParsedLine.szFileName;
        if (iTempDeleteEvenIfFull)
        {
            RecRemoveDir(csPath);
        }
        else
        {
            RecRemoveEmptyDir(csPath);
        }
    }

    // We called the function, so return true.
    iReturn = TRUE;

    // change back to the original dir
    if (ParsedLine.szChangeDir){if (szDirBefore){SetCurrentDirectory(szDirBefore);}}

    ProcessEntry_AskLast(ParsedLine, 1);


ProcessEntry_Misc1_Exit:
    if (TRUE == iProgressBarUpdated){ProgressBarTextStack_Pop();}
    return iReturn;
}


int ProcessEntry_SVC_Clus(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iReturnTemp = FALSE;
    int iTempFlag = FALSE;
    int iProgressBarUpdated = FALSE;
    int iShowErrorsOnFail = TRUE;
    DWORD dwFailed = ERROR_SUCCESS;


    // Get the type.
    if ( _tcsicmp(ParsedLine.szType, _T("50")) != 0 && _tcsicmp(ParsedLine.szType, _T("51")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("52")) != 0 && _tcsicmp(ParsedLine.szType, _T("53")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("54")) != 0 && _tcsicmp(ParsedLine.szType, _T("55")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("56")) != 0 && _tcsicmp(ParsedLine.szType, _T("57")) != 0 && 
        _tcsicmp(ParsedLine.szType, _T("58")) != 0 && _tcsicmp(ParsedLine.szType, _T("59")) != 0 && 
        _tcsicmp(ParsedLine.szType, _T("60")) != 0 && _tcsicmp(ParsedLine.szType, _T("61")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("62")) != 0 && _tcsicmp(ParsedLine.szType, _T("63")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("64")) != 0 && _tcsicmp(ParsedLine.szType, _T("65")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("66")) != 0  && _tcsicmp(ParsedLine.szType, _T("67")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("68")) != 0  && _tcsicmp(ParsedLine.szType, _T("69")) != 0
        )
    {
        goto ProcessEntry_SVC_Clus_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_SVC_Clus_Exit;
    }

    if (_tcsicmp(ParsedLine.szType, _T("66")) == 0 || _tcsicmp(ParsedLine.szType, _T("67")) == 0)
    {
        // make sure not to require 102 parameter for 66 or 67
    }
    else
    {
        // make sure we have a szData1 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_SVC_Clus_Exit;
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("50")) == 0 || _tcsicmp(ParsedLine.szType, _T("52")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_SVC_Clus_Exit;
        }

        CString csFullFilePath;
        // Check if the file exists....
        if ( _tcsicmp(ParsedLine.szType, _T("50")) == 0)
        {
            csFullFilePath = g_pTheApp->m_csSysDir;
            csFullFilePath += _T("\\Drivers\\");
            csFullFilePath += ParsedLine.szFileName;
        }
        else
        {
            csFullFilePath = ParsedLine.szFileName;
        }
        // make sure the szFileName exists
        if (!IsFileExist(csFullFilePath))
        {
            // The file does not exists.
            // Check if we need to display an error!
            if (_tcsicmp(ParsedLine.szErrIfFileNotFound, _T("1")) == 0) 
            {
                // display the messagebox
                MyMessageBox(NULL, IDS_FILE_DOES_NOT_EXIST, csFullFilePath, ERROR_FILE_NOT_FOUND, MB_OK | MB_SETFOREGROUND);
                goto ProcessEntry_SVC_Clus_Exit;
            }
            else
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("o ProcessEntry_SVC_Clus():FileDoesNotExist=%s.\n"),csFullFilePath));
            }
        }

        // make sure we have a szData2 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_SVC_Clus_Exit;
        }
    }

      
    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0) 
        {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
        iProgressBarUpdated = TRUE;
        }

    // check if we need to ask the user if they want to call it for sure.
    if (!ProcessEntry_AskFirst(ParsedLine, 1))
    {
        goto ProcessEntry_SVC_Clus_Exit;
    }

    // Run The Executable...
    // iShowErrorsOnFail
    dwFailed = ERROR_SUCCESS;
    // Call the function!!!!!
    if (_tcsicmp(ParsedLine.szType, _T("50")) == 0)
    {
        // Create the driver, retry if failed...
        dwFailed = CreateDriver_Wrap(ParsedLine.szData1, ParsedLine.szData2, ParsedLine.szFileName, TRUE);
        if (dwFailed != ERROR_SUCCESS)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szFileName, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("CreateDriver(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szFileName, GetLastError() ));}
        }
        else
        {
            iReturn = TRUE;
        }
    }
    if (_tcsicmp(ParsedLine.szType, _T("51")) == 0)
    {
        // Remove driver.
        dwFailed = InetDeleteService( ParsedLine.szData1 );
        if (dwFailed != 0)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szData1, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("InetDeleteService(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));}
        }
        else
        {
            iReturn = TRUE;
        }
        // flag the reboot flag.
        SetRebootFlag();
    }
    if (_tcsicmp(ParsedLine.szType, _T("52")) == 0)
    {
        // Create the service, retry if failed...
        dwFailed = CreateService_wrap(ParsedLine.szData1, ParsedLine.szData2, ParsedLine.szFileName, ParsedLine.szData3, ParsedLine.szData4, TRUE);
        if (dwFailed != ERROR_SUCCESS)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szFileName, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("CreateService(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szFileName, GetLastError() ));}
        }
        else
        {
            iReturn = TRUE;
        }

    }

    if (_tcsicmp(ParsedLine.szType, _T("53")) == 0)
    {
        // Remove Service.
        dwFailed = InetDeleteService( ParsedLine.szData1 );
        if (dwFailed != 0 && dwFailed != ERROR_SERVICE_DOES_NOT_EXIST)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szData1, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("InetDeleteService(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));}
        }
        else
        {
            iReturn = TRUE;
        }
    }

    if (_tcsicmp(ParsedLine.szType, _T("54")) == 0)
    {
        // Start Service
        dwFailed = InetStartService(ParsedLine.szData1);
        if (dwFailed == 0 || dwFailed == ERROR_SERVICE_ALREADY_RUNNING)
        {
            // yeah, the service started.
            iReturn = TRUE;
        }
        else
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szData1, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_WARN, _T("InetStartService(%s).  Unable to start.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));}
        }
    }

    if (_tcsicmp(ParsedLine.szType, _T("55")) == 0)
    {
        int iAddToRestartList=FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0) {iAddToRestartList=TRUE;}

        // Stop Service
        dwFailed = StopServiceAndDependencies(ParsedLine.szData1, iAddToRestartList);
        if (dwFailed == FALSE)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szData1, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));}
        }
        else
        {
            // yeah, the service stopped.
            iReturn = TRUE;
        }
    }

    if (_tcsicmp(ParsedLine.szType, _T("56")) == 0 || _tcsicmp(ParsedLine.szType, _T("57")) == 0)
    {
        int iAdd = FALSE;
        if (_tcsicmp(ParsedLine.szType, _T("56")) == 0) {iAdd = TRUE;}
        // map/unmap to HTTP
        InetRegisterService( g_pTheApp->m_csMachineName, ParsedLine.szData1, &g_HTTPGuid, 0, 80, iAdd);
        iReturn = TRUE;
    }

    if (_tcsicmp(ParsedLine.szType, _T("58")) == 0 || _tcsicmp(ParsedLine.szType, _T("59")) == 0)
    {
        int iAdd = FALSE;
        if (_tcsicmp(ParsedLine.szType, _T("58")) == 0) {iAdd = TRUE;}
        // map/unmap to FTP
        InetRegisterService( g_pTheApp->m_csMachineName, ParsedLine.szData1, &g_FTPGuid, 0, 21, iAdd);
        iReturn = TRUE;
    }

    if (_tcsicmp(ParsedLine.szType, _T("60")) == 0 || _tcsicmp(ParsedLine.szType, _T("61")) == 0)
    {
        int iAdd = FALSE;
        if (_tcsicmp(ParsedLine.szType, _T("60")) == 0) {iAdd = TRUE;}
        // map/unmap to Gopher
        InetRegisterService( g_pTheApp->m_csMachineName, ParsedLine.szData1, &g_GopherGuid, 0, 70, iAdd);
        iReturn = TRUE;
    }

    if (_tcsicmp(ParsedLine.szType, _T("62")) == 0 || _tcsicmp(ParsedLine.szType, _T("63")) == 0)
    {
        int iAdd = FALSE;
        if (_tcsicmp(ParsedLine.szType, _T("62")) == 0) {iAdd = TRUE;}
        // map/unmap to Inetinfo
        InetRegisterService( g_pTheApp->m_csMachineName, ParsedLine.szData1, &g_InetInfoGuid, 0x64e, 0x558, iAdd);
        iReturn = TRUE;
    }

    if (_tcsicmp(ParsedLine.szType, _T("64")) == 0 || _tcsicmp(ParsedLine.szType, _T("65")) == 0)
    {
        iReturn = TRUE;

        // make sure we have everything
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_SVC_Clus_Exit;
        }

        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_SVC_Clus_Exit;
        }

        if (_tcsicmp(ParsedLine.szType, _T("64")) == 0)
        {
            iTempFlag = FALSE;
            if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
            if (iTempFlag == FALSE)
            {
                iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
                goto ProcessEntry_SVC_Clus_Exit;
            }
            iTempFlag = FALSE;
            if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag = TRUE;}
            if (iTempFlag == FALSE)
            {
                iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
                goto ProcessEntry_SVC_Clus_Exit;
            }

            // this function only takes wide characters...
#ifndef _CHICAGO_
            iReturn = RegisterIisServerInstanceResourceType(ParsedLine.szFileName,ParsedLine.szData1,ParsedLine.szData2,ParsedLine.szData3);
#else
            iisDebugOut((LOG_TYPE_TRACE,  _T("RegisterIisServerInstanceResourceType(): not supported under ansi. only unicode.") ));
#endif
        }
        else
        {
            iTempFlag = FALSE;
            if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0) {iTempFlag = TRUE;}

            // this function only takes wide characters...
#ifndef _CHICAGO_
            iReturn = UnregisterIisServerInstanceResourceType(ParsedLine.szFileName,ParsedLine.szData1,iTempFlag,TRUE);
#else
            iisDebugOut((LOG_TYPE_TRACE,  _T("UnregisterIisServerInstanceResourceType(): not supported under ansi. only unicode.") ));
#endif
        }
        // iReturn = TRUE;
    }

    if (_tcsicmp(ParsedLine.szType, _T("66")) == 0)
    {
#ifndef _CHICAGO_
        DWORD dwReturn = 0;
        dwReturn = BringALLIISClusterResourcesOffline();
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("BringALLIISClusterResourcesOffline ret=%d\n"),dwReturn));
#endif
        iReturn = TRUE;
    }

    if (_tcsicmp(ParsedLine.szType, _T("67")) == 0)
    {
#ifndef _CHICAGO_
        DWORD dwReturn = 0;
        dwReturn = BringALLIISClusterResourcesOnline();
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("BringALLIISClusterResourcesOnline ret=%d\n"),dwReturn));
#endif
        iReturn = TRUE;
    }

    //    Add/remove interactive flag to/from service
    if (_tcsicmp(ParsedLine.szType, _T("68")) == 0 || _tcsicmp(ParsedLine.szType, _T("69")) == 0)
    {
        int iAdd = FALSE;
        if (_tcsicmp(ParsedLine.szType, _T("68")) == 0) {iAdd = TRUE;}
        
        InetConfigServiceInteractive(ParsedLine.szData1, iAdd);
        iReturn = TRUE;
    }

    // display the messagebox that we completed the call...
    ProcessEntry_AskLast(ParsedLine,1);

ProcessEntry_SVC_Clus_Exit:
    if (TRUE == iProgressBarUpdated){ProgressBarTextStack_Pop();}
    return iReturn;
}



int ProcessEntry_Dcom(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;
    int iProgressBarUpdated = FALSE;
    int iShowErrorsOnFail = TRUE;
    DWORD dwFailed = ERROR_SUCCESS;

    // Get the type.
    if ( _tcsicmp(ParsedLine.szType, _T("70")) != 0 && _tcsicmp(ParsedLine.szType, _T("71")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("72")) != 0 && _tcsicmp(ParsedLine.szType, _T("73")) != 0 &&
		_tcsicmp(ParsedLine.szType, _T("74")) != 0 && _tcsicmp(ParsedLine.szType, _T("75")) != 0 &&
		_tcsicmp(ParsedLine.szType, _T("76")) != 0 && _tcsicmp(ParsedLine.szType, _T("77")) != 0
        )
    {
        goto ProcessEntry_Dcom_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_Dcom_Exit;
    }

    // make sure we have a szData1 entry
    iTempFlag = FALSE;
    if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
    if (iTempFlag == FALSE)
    {
        iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
        goto ProcessEntry_Dcom_Exit;
    }

    if (_tcsicmp(ParsedLine.szType, _T("74")) == 0 ||
		_tcsicmp(ParsedLine.szType, _T("75")) == 0 || 
		_tcsicmp(ParsedLine.szType, _T("76")) == 0 ||
		_tcsicmp(ParsedLine.szType, _T("77")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Dcom_Exit;
        }
	}

    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0) 
        {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
        iProgressBarUpdated = TRUE;
        }

    // check if we need to ask the user if they want to call it for sure.
    if (!ProcessEntry_AskFirst(ParsedLine, 1))
    {
        goto ProcessEntry_Dcom_Exit;
    }

    // Run The Executable...
    // iShowErrorsOnFail
    dwFailed = ERROR_SUCCESS;

    // Call the function!!!!!

	// Set dcom launch and access permissions
	if (_tcsicmp(ParsedLine.szType, _T("70")) == 0 || _tcsicmp(ParsedLine.szType, _T("71")) == 0)
    {
        BOOL bDumbCall = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
            {bDumbCall = TRUE;}

		if (_tcsicmp(ParsedLine.szType, _T("70")) == 0)
		{
			dwFailed = ChangeDCOMLaunchACL((LPTSTR)(LPCTSTR)ParsedLine.szData1, TRUE, TRUE, bDumbCall);
		}
		else
		{
			dwFailed = ChangeDCOMLaunchACL((LPTSTR)(LPCTSTR)ParsedLine.szData1, FALSE, FALSE, bDumbCall);
		}
        if (dwFailed != ERROR_SUCCESS)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szData1, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("ChangeDCOMAccessACL(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));}
        }
        else
        {
            iReturn = TRUE;
        }
    }
	if (_tcsicmp(ParsedLine.szType, _T("72")) == 0 || _tcsicmp(ParsedLine.szType, _T("73")) == 0)
    {
        BOOL bDumbCall = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
            {bDumbCall = TRUE;}

		if (_tcsicmp(ParsedLine.szType, _T("72")) == 0)
		{
			dwFailed = ChangeDCOMAccessACL((LPTSTR)(LPCTSTR)ParsedLine.szData1, TRUE, TRUE, bDumbCall);
		}
		else
		{
			dwFailed = ChangeDCOMAccessACL((LPTSTR)(LPCTSTR)ParsedLine.szData1, FALSE, FALSE, bDumbCall);
		}
        if (dwFailed != ERROR_SUCCESS)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szData1, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("ChangeDCOMAccessACL(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));}
        }
        else
        {
            iReturn = TRUE;
        }
    }

	// dcom launch and access permissions
    if (_tcsicmp(ParsedLine.szType, _T("74")) == 0 || _tcsicmp(ParsedLine.szType, _T("75")) == 0)
    {
        BOOL bDumbCall = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
            {bDumbCall = TRUE;}

		if (_tcsicmp(ParsedLine.szType, _T("74")) == 0)
		{
			dwFailed = ChangeAppIDLaunchACL(ParsedLine.szFileName, (LPTSTR)(LPCTSTR) ParsedLine.szData1, TRUE, TRUE, bDumbCall);
		}
		else
		{
			dwFailed = ChangeAppIDLaunchACL(ParsedLine.szFileName, (LPTSTR)(LPCTSTR) ParsedLine.szData1, FALSE, FALSE, bDumbCall);
		}
        if (dwFailed != ERROR_SUCCESS)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szData1, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("ChangeAppIDLaunchACL(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));}
        }
        else
        {
            iReturn = TRUE;
        }
    }

	// dcom launch and access permissions
	if (_tcsicmp(ParsedLine.szType, _T("76")) == 0 || _tcsicmp(ParsedLine.szType, _T("77")) == 0)
    {
        BOOL bDumbCall = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
            {bDumbCall = TRUE;}

		if (_tcsicmp(ParsedLine.szType, _T("76")) == 0)
		{
			dwFailed = ChangeAppIDAccessACL(ParsedLine.szFileName, (LPTSTR)(LPCTSTR) ParsedLine.szData1, TRUE, TRUE, bDumbCall);
		}
		else
		{
			dwFailed = ChangeAppIDAccessACL(ParsedLine.szFileName, (LPTSTR)(LPCTSTR) ParsedLine.szData1, FALSE, FALSE, bDumbCall);
		}
        if (dwFailed != ERROR_SUCCESS)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szData1, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("ChangeAppIDAccessACL(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szData1, GetLastError() ));}
        }
        else
        {
            iReturn = TRUE;
        }
    }


    // display the messagebox that we completed the call...
    ProcessEntry_AskLast(ParsedLine,1);
        
    // We called the function, so return true.
    iReturn = TRUE;

ProcessEntry_Dcom_Exit:
    return iReturn;
}

// function: IsMachineInDomain
//
// Test to see if the machine is in a domain, or if it
// is in a workstation
//
// Return Values:
//   TRUE - In a domain
//   FALSE - Not in a domain
//
int IsMachineInDomain()
{
    DWORD dwRet;
    LPBYTE pDomain = NULL;

    // Retrieve the domain which this computer trusts.
    // Hence: success->in a domain; error->not in a domain
    dwRet = NetGetAnyDCName(NULL,NULL,&pDomain);

    if (pDomain)
    {
        NetApiBufferFree(pDomain);
    }

    if (dwRet == NERR_Success)
    {
        return TRUE;
    }

    // Default Return Value is FALSE
    return FALSE;
}

// function: RetrieveDomain
//
// Retrieve the domain that the current machine is in
//
// Parameters:
//   [out] csDomainName - The name of the domain
//
// Return:
//   TRUE - It worked
//   FALSE - It Failed
//
int RetrieveDomain(CString &csDomainName)
{
  PDOMAIN_CONTROLLER_INFO pDci;

  if ( NO_ERROR != DsGetDcName( NULL,   // Localhost
                                NULL,   // No specific domain
                                NULL,   // No Guid Specified
                                NULL,   // No Site
                                0,      // No Flags
                                &pDci)
                                )
  {
      return FALSE;
  }

  // Copy string into csDomainName
  csDomainName = pDci->DomainName;

  NetApiBufferFree(pDci);

  return TRUE;
}

int ProcessEntry_If(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;
    int iTempFlag2 = FALSE;

    int ifTrueStatementExists = FALSE;
    int ifFalseStatementExists = FALSE;

    // Get the type.
    if (_tcsicmp(ParsedLine.szType, _T("39")) != 0 && 
        _tcsicmp(ParsedLine.szType, _T("40")) != 0 && _tcsicmp(ParsedLine.szType, _T("41")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("42")) != 0 && _tcsicmp(ParsedLine.szType, _T("43")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("44")) != 0 && _tcsicmp(ParsedLine.szType, _T("45")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("46")) != 0 && _tcsicmp(ParsedLine.szType, _T("47")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("48")) != 0 && _tcsicmp(ParsedLine.szType, _T("49")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("100")) != 0 && _tcsicmp(ParsedLine.szType, _T("119")) != 0
        )
    {
        goto ProcessEntry_If_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_If_Exit;
    }

    if ( _tcsicmp(ParsedLine.szType, _T("40")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData3 or a szData4.
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData3 or szData4

        HKEY hRootKeyType = HKEY_LOCAL_MACHINE;
        // check if the registry key exists...
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKLM")) == 0){hRootKeyType = HKEY_LOCAL_MACHINE;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCR")) == 0){hRootKeyType = HKEY_CLASSES_ROOT;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCU")) == 0){hRootKeyType = HKEY_CURRENT_USER;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKU")) == 0){hRootKeyType = HKEY_USERS;}

        iTempFlag = FALSE;
        CRegKey regTheKey(hRootKeyType, ParsedLine.szData1,KEY_READ);
        if ((HKEY) regTheKey) {iTempFlag = TRUE;}
        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("41")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData3 or a szData4.
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData4, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz105_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData3 or szData4

        HKEY hRootKeyType = HKEY_LOCAL_MACHINE;
        // check if the registry key exists...
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKLM")) == 0){hRootKeyType = HKEY_LOCAL_MACHINE;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCR")) == 0){hRootKeyType = HKEY_CLASSES_ROOT;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCU")) == 0){hRootKeyType = HKEY_CURRENT_USER;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKU")) == 0){hRootKeyType = HKEY_USERS;}

        iTempFlag = FALSE;
        CRegKey regTheKey(hRootKeyType, ParsedLine.szData1,KEY_READ);
        CString strReturnQueryValue;
        if ((HKEY) regTheKey)
        {
            if (ERROR_SUCCESS == regTheKey.QueryValue(ParsedLine.szData2, strReturnQueryValue))
                {iTempFlag = TRUE;}

            // If we failed to read it as a string, try a dword
            if (FALSE == iTempFlag)
            {
                DWORD dwTheReturnDword = 0;
                if (ERROR_SUCCESS == regTheKey.QueryValue(ParsedLine.szData2, dwTheReturnDword))
                    {iTempFlag = TRUE;}
            }

            // If we failed to read it as dword, try a binary
            if (FALSE == iTempFlag)
            {
                CByteArray baData;
                if (ERROR_SUCCESS == regTheKey.QueryValue(ParsedLine.szData2, baData))
                    {iTempFlag = TRUE;}
            }
        }

        if (iTempFlag == TRUE)
        {
            if (ifTrueStatementExists)
            {
                // the key exists, so let's do the section...
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }
        }
        else
        {
            if (ifFalseStatementExists)
            {
                // the key exists, so let's do the section...
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData4));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData4);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData4, iTempFlag));
            }
        }
    }


    if ( _tcsicmp(ParsedLine.szType, _T("42")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData1 or a szData2
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData1 or szData2

        // Check if the filename or dir exists...
        iTempFlag = FALSE;
        if (IsFileExist(ParsedLine.szFileName))
            {iTempFlag = TRUE;}
        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }

        }
    }


    if ( _tcsicmp(ParsedLine.szType, _T("43")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData3 or a szData4.
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData4, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz105_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData3 or szData4

        HKEY hRootKeyType = HKEY_LOCAL_MACHINE;
        // check if the registry key exists...
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKLM")) == 0){hRootKeyType = HKEY_LOCAL_MACHINE;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCR")) == 0){hRootKeyType = HKEY_CLASSES_ROOT;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCU")) == 0){hRootKeyType = HKEY_CURRENT_USER;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKU")) == 0){hRootKeyType = HKEY_USERS;}

        // ParsedLine.szData1 = Software\Microsoft\etc..\TheValueToCheck
        // so take off the last one and use that as the value to look up.
        TCHAR theRegValuePart[100];
        LPTSTR pszTempPointer = NULL;
        pszTempPointer = _tcsrchr((LPTSTR) ParsedLine.szData1, _T('\\'));
        if (pszTempPointer)
        {
            *pszTempPointer = _T('\0');
            //set the "\" to a null
            // increment to after the pointer
            pszTempPointer = _tcsninc( pszTempPointer, _tcslen(pszTempPointer))+1;
            _tcscpy(theRegValuePart, pszTempPointer );
        }
        //iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Var:Key=%1!s!:Value=%2!s!.\n"), ParsedLine.szData1, theRegValuePart));

        iTempFlag = FALSE;
        CRegKey regTheKey(hRootKeyType, ParsedLine.szData1,KEY_READ);
        DWORD dwTheReturnDword = 0;
        if ((HKEY) regTheKey)
        {
            if (ERROR_SUCCESS == regTheKey.QueryValue(theRegValuePart, dwTheReturnDword))
                {
                    // Check against the value they want to check against.
                    DWORD dwCheckDword = atodw(ParsedLine.szData2);
                    if (dwTheReturnDword == dwCheckDword)
                        {
                        iTempFlag = TRUE;
                        }
                }
        }

        if (iTempFlag == TRUE)
        {
            if (ifTrueStatementExists)
            {
                // the key exists, so let's do the section...
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }
        }
        else
        {
            if (ifFalseStatementExists)
            {
                // the key exists, so let's do the section...
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData4));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData4);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData4, iTempFlag));
            }
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("44")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData3 or a szData4.
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData4, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz105_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData3 or szData4

        HKEY hRootKeyType = HKEY_LOCAL_MACHINE;
        // check if the registry key exists...
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKLM")) == 0){hRootKeyType = HKEY_LOCAL_MACHINE;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCR")) == 0){hRootKeyType = HKEY_CLASSES_ROOT;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCU")) == 0){hRootKeyType = HKEY_CURRENT_USER;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKU")) == 0){hRootKeyType = HKEY_USERS;}

        // ParsedLine.szData1 = Software\Microsoft\etc..\TheValueToCheck
        // so take off the last one and use that as the value to look up.
        TCHAR theRegValuePart[100];
        LPTSTR pszTempPointer = NULL;
        pszTempPointer = _tcsrchr((LPTSTR) ParsedLine.szData1, _T('\\'));
        if (pszTempPointer)
        {
            *pszTempPointer = _T('\0');
            //set the "\" to a null
            // increment to after the pointer
            pszTempPointer = _tcsninc( pszTempPointer, _tcslen(pszTempPointer))+1;
            _tcscpy(theRegValuePart, pszTempPointer );
        }
        //iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Var:Key=%1!s!:Value=%2!s!.\n"), ParsedLine.szData1, theRegValuePart));

        iTempFlag = FALSE;
        CRegKey regTheKey(hRootKeyType, ParsedLine.szData1,KEY_READ);
        CString strReturnQueryValue;
        if ((HKEY) regTheKey)
        {
            if (ERROR_SUCCESS == regTheKey.QueryValue(theRegValuePart, strReturnQueryValue))
                {
                    if (_tcsicmp(strReturnQueryValue,ParsedLine.szData2) == 0)
                        {
                        iTempFlag = TRUE;
                        }
                }
        }

        if (iTempFlag == TRUE)
        {
            if (ifTrueStatementExists)
            {
                // the key exists, so let's do the section...
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }
        }
        else
        {
            if (ifFalseStatementExists)
            {
                // the key exists, so let's do the section...
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData4));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData4);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData4, iTempFlag));
            }
        }
    }


    if ( _tcsicmp(ParsedLine.szType, _T("45")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData1 or a szData2
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData1 or szData2

        // Check if the Service exists...
        iTempFlag = FALSE;
        if (CheckifServiceExist(ParsedLine.szFileName) == 0 )
        {
            // yes the service exists..
            iTempFlag = TRUE;
        }
           
        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("46")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData1 or a szData2
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData1 or szData2

        // Check if the Service exists...and is running..
        iTempFlag = FALSE;
       
        if (InetQueryServiceStatus(ParsedLine.szFileName) == SERVICE_RUNNING)
        {
            // yes the service exists..and is running...
            iTempFlag = TRUE;
        }
           
        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("47")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData3 or a szData4.
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData3 or szData4
        // Check if the values match.
        iTempFlag = FALSE;
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("ProcessEntry_If:check if [%1!s!=%2!s!]\n"), ParsedLine.szFileName, ParsedLine.szData1));

        if ( _tcsicmp(ParsedLine.szFileName, ParsedLine.szData1) == 0)
            {
            iTempFlag = TRUE;
            }

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("48")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData1 or a szData2
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData1 or szData2

        // Check if the language specified in the .inf corresponds to
        // our systems language.
        iTempFlag = FALSE;

        // Get our language
        // set iTempFlag to true if it matches the same language they specified.
        DWORD           thid;
        LCID ThisThreadsLocale = GetThreadLocale();
        LCID SystemDefaultLocale = GetSystemDefaultLCID();
        LCID UserDefaultLocale = GetUserDefaultLCID();

        HANDLE hHackThread = CreateThread (NULL,0,GetNewlyCreatedThreadLocale,NULL,0,&thid);
        if (hHackThread)
        {
            // wait for 10 secs only
            DWORD res = WaitForSingleObject (hHackThread,10*1000);
            if (res == WAIT_TIMEOUT)
            {
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ERROR GetNewlyCreatedThreadLocale thread never finished...\n")));
                // iTempFlag will be false.
            }
            else
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("ThisThreadsLocale=%0x, GetNewlyCreatedThreadLocale=%0x\n"),ThisThreadsLocale,g_MyTrueThreadLocale));
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("SystemDefaultLocale=%0x, UserDefaultLocale=%0x\n"),SystemDefaultLocale,UserDefaultLocale));

                CloseHandle (hHackThread);

                // Check if g_MyTrueThreadLocale matches the one in the .inf file!
                DWORD dwTheLocaleSpecifiedinINF = 0;
                dwTheLocaleSpecifiedinINF = atodw(ParsedLine.szFileName);
                if (g_MyTrueThreadLocale == dwTheLocaleSpecifiedinINF)
                {
                    iTempFlag = TRUE;
                }
                else if (ThisThreadsLocale == dwTheLocaleSpecifiedinINF)
                {
                    iTempFlag = TRUE;
                }
                else if (SystemDefaultLocale == dwTheLocaleSpecifiedinINF)
                {
                    iTempFlag = TRUE;
                }
                else if (UserDefaultLocale == dwTheLocaleSpecifiedinINF)
                {
                    iTempFlag = TRUE;
                }
            }
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("Failed to start GetNewlyCreatedThreadLocale thread. error =%0x\n"),GetLastError()));
        }

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("49")) == 0)
    {
        BOOL bOperator_EqualTo = 0;
        BOOL bOperator_GreaterThan = 0;
        BOOL bOperator_LessThan = 0;

        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        // make sure there is an operator "=,>,<,>=,<="
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        iTempFlag = FALSE;
        LPTSTR pchResult;
        pchResult = _tcschr( ParsedLine.szData1, _T('=') );
        if(pchResult){bOperator_EqualTo = TRUE;iTempFlag = TRUE;}

        pchResult = NULL;
        pchResult = _tcschr( ParsedLine.szData1, _T('>') );
        if(pchResult){bOperator_GreaterThan = TRUE;iTempFlag = TRUE;}

        pchResult = NULL;
        pchResult = _tcschr( ParsedLine.szData1, _T('<') );
        if(pchResult){bOperator_LessThan = TRUE;iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        // make sure the version to compare it to is specified
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure there is a szData3 or a szData4.
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData4, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz105_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure to return true from here on!
        iReturn = TRUE;

        // check if the file exists
        // Check if the filename or dir exists...
        if (!IsFileExist(ParsedLine.szFileName))
            {goto ProcessEntry_If_Exit;}

        BOOL bThisIsABinary = FALSE;
        TCHAR szExtensionOnly[_MAX_EXT] = _T("");
        _tsplitpath(ParsedLine.szFileName, NULL, NULL, NULL, szExtensionOnly);

        // Get version info for dll,exe,ocx only
        if (_tcsicmp(szExtensionOnly, _T(".exe")) == 0){bThisIsABinary=TRUE;}
        if (_tcsicmp(szExtensionOnly, _T(".dll")) == 0){bThisIsABinary=TRUE;}
        if (_tcsicmp(szExtensionOnly, _T(".ocx")) == 0){bThisIsABinary=TRUE;}
        if (FALSE == bThisIsABinary)
        {
            // no version, bail
            goto ProcessEntry_If_Exit;
        }

        DWORD  dwMSVer, dwLSVer = 0;
        TCHAR  szLocalizedVersion[100] = _T("");

        // the file exists, lets get the file version and compare it with
        // the inputed version, if the fileversion is <= inputversion, then do TRUE section, 
        // otherwise to FALSE section

        // get the fileinformation
        MyGetVersionFromFile(ParsedLine.szFileName, &dwMSVer, &dwLSVer, szLocalizedVersion);
        if (!dwMSVer)
            {
            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("ProcessEntry_If:No Version in %1!s!, or filenot found\n"), ParsedLine.szFileName));
            // no version, leave
            goto ProcessEntry_If_Exit;
            }

        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("ProcessEntry_If:check if [%1!s! (%2!s!  %3!s!  %4!s!)]\n"), ParsedLine.szFileName, szLocalizedVersion, ParsedLine.szData1));

        int iTempVerValue = 0;
        iTempVerValue = VerCmp(szLocalizedVersion,ParsedLine.szData1);
        if (0 == iTempVerValue)
        {
            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("ProcessEntry_If:VerCmp=%d\n"), iTempVerValue));
            goto ProcessEntry_If_Exit;
        }

        iTempFlag = FALSE;
        if (bOperator_EqualTo)
        {
            // check if the above operation was equal
            if (1 == iTempVerValue){iTempFlag = TRUE;}
        }

        if (bOperator_GreaterThan)
        {
            // check if the above operation was greater than
            if (2 == iTempVerValue){iTempFlag = TRUE;}
        }

        if (bOperator_LessThan)
        {
            // check if the above operation was less than
            if (3 == iTempVerValue){iTempFlag = TRUE;}
        }

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData4));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData4);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData4, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("39")) == 0)
    {
        BOOL bOperator_EqualTo = 0;
        BOOL bOperator_GreaterThan = 0;
        BOOL bOperator_LessThan = 0;

        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }
        // make sure the description string to comprare it to is specified
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // make sure to return true from here on!
        iReturn = TRUE;

        // check if the file exists
        // Check if the filename or dir exists...
        if (!IsFileExist(ParsedLine.szFileName))
            {goto ProcessEntry_If_Exit;}

        TCHAR  szFileDescriptionInfo[_MAX_PATH] = _T("");

        // Get the file description info

        // get the DescriptionInfo
        if (!MyGetDescriptionFromFile(ParsedLine.szFileName, szFileDescriptionInfo))
        {
            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("ProcessEntry_If:No file desc in %1!s!, or filenot found\n"), ParsedLine.szFileName));
            goto ProcessEntry_If_Exit;
        }

        iTempFlag = FALSE;
        if ( _tcsicmp(szFileDescriptionInfo,ParsedLine.szData1) == 0)
        {
            // if they match the do the true!
            iTempFlag = TRUE;
        }

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }

        }
    }


    if ( _tcsicmp(ParsedLine.szType, _T("100")) == 0)
    {
        TCHAR buf[_MAX_PATH];
        GetSystemDirectory(buf, _MAX_PATH);

        // make sure there is a szData1 or a szData2
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_If_Exit;
        }

        // okay we have either szData1 or szData2

        // Check if the Service exists...
        iTempFlag = FALSE;
        if (IsThisDriveNTFS(buf) == 0 )
        {
            // yes it is FAT
            iTempFlag = TRUE;
        }
           
        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("119")) == 0)
    {

        if ( IsMachineInDomain() )
        {
            if (_tcsicmp(ParsedLine.szData2, _T("")) != 0 )
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }
        }
        else
        {
            if (_tcsicmp(ParsedLine.szData3, _T("")) != 0 )
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }
        }

    }


    // We called the function, so return true.
    iReturn = TRUE;

ProcessEntry_If_Exit:
    return iReturn;
}





int ProcessEntry_Metabase(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iShowErrorsOnFail = TRUE;
    int iReturn = FALSE;
    int iTempFlag = FALSE;

    // Get the type.
    if ( _tcsicmp(ParsedLine.szType, _T("82")) != 0 && _tcsicmp(ParsedLine.szType, _T("83")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("84")) != 0 && _tcsicmp(ParsedLine.szType, _T("85")) != 0
        )
    {
        goto ProcessEntry_Metabase_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_Metabase_Exit;
    }

    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}
        
    if ( _tcsicmp(ParsedLine.szType, _T("82")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Metabase_Exit;
        }

        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Metabase_Exit;
        }

        // Check if hte szData1 includes a "/*"
        // if it does, then that means to do it for every server instance.
        iTempFlag = FALSE;
        if (_tcsstr(ParsedLine.szFileName, _T("/*"))) 
            {iTempFlag = TRUE;}

        // Check if we need to do this for every server instance.
        if (iTempFlag)
        {
            CString csTempString;
            CString BeforeString;
            CString AfterString;

            csTempString = ParsedLine.szFileName;
            BeforeString = csTempString;
            AfterString = _T("");

            // Find the "/*" and get the stuff before it.
            int iWhere = 0;
            iWhere = csTempString.Find(_T("/*"));
            if (-1 != iWhere)
            {
                // there is a '/*' in the string
                BeforeString = csTempString.Left(iWhere);

                // Get the after comma vlues
                CString csVeryTemp;
                csVeryTemp = _T("/*");
                AfterString = csTempString.Right( csTempString.GetLength() - (iWhere + csVeryTemp.GetLength()));
            }

            CStringArray arrayInstance;
            int nArray = 0, i = 0;
            if (CheckifServiceExist(_T("IISADMIN")) == 0 ) 
            {
                CMDKey cmdKey;
                //cmdKey.OpenNode(ParsedLine.szFileName);
                cmdKey.OpenNode(BeforeString);
                if ( (METADATA_HANDLE) cmdKey )
                    {
                    // enumerate thru this key for other keys...
                    CMDKeyIter cmdKeyEnum(cmdKey);
                    CString csKeyName;
                    while (cmdKeyEnum.Next(&csKeyName) == ERROR_SUCCESS) 
                    {
                        // make sure that it's a number that we are adding.
                        if (IsValidNumber(csKeyName))
                        {
                            arrayInstance.Add(csKeyName);
                        }
                    }
                    cmdKey.Close();

                    nArray = (int)arrayInstance.GetSize();
                    for (i=0; i<nArray; i++) 
                    {
                        /*
                        // Recurse Thru This nodes entries
                        // Probably look something like these...
                        [/W3SVC]
                        [/W3SVC/1/ROOT/IISSAMPLES/ExAir]
                        [/W3SVC/1/ROOT/IISADMIN]
                        [/W3SVC/1/ROOT/IISHELP]
                        [/W3SVC/1/ROOT/specs]
                        [/W3SVC/2/ROOT]
                        [/W3SVC/2/ROOT/IISADMIN]
                        [/W3SVC/2/ROOT/IISHELP]
                        etc...
                        */
                        CString csPath;
                        csPath = BeforeString;
                        csPath += _T("/");
                        csPath += arrayInstance[i];
                        csPath += AfterString;

                        // delete the metabase node.
                        cmdKey.OpenNode(csPath);
                        if ( (METADATA_HANDLE)cmdKey ) 
                        {
                            cmdKey.DeleteNode(ParsedLine.szData1);
                            cmdKey.Close();
                        }
                    }
                }
            }
        }
        else
        {
            // delete the metabase node.
            if (CheckifServiceExist(_T("IISADMIN")) == 0 ) 
            {
                CMDKey cmdKey;
                cmdKey.OpenNode(ParsedLine.szFileName);
                if ( (METADATA_HANDLE)cmdKey ) 
                {
                    cmdKey.DeleteNode(ParsedLine.szData1);
                    cmdKey.Close();
                }
            }
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("83")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Metabase_Exit;
        }

        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Metabase_Exit;
        }

        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Metabase_Exit;
        }

        // Check if hte szData1 includes a "/*"
        // if it does, then that means to do it for every server instance.
        iTempFlag = FALSE;
        if (_tcsstr(ParsedLine.szFileName, _T("/*"))) 
            {iTempFlag = TRUE;}

        // Check if we need to do this for every server instance.
        if (iTempFlag)
        {
            CString csTempString;
            CString BeforeString;
            CString AfterString;

            csTempString = ParsedLine.szFileName;
            BeforeString = csTempString;
            AfterString = _T("");

            // Find the "/*" and get the stuff before it.
            int iWhere = 0;
            iWhere = csTempString.Find(_T("/*"));
            if (-1 != iWhere)
            {
                // there is a '/*' in the string
                BeforeString = csTempString.Left(iWhere);

                // Get the after comma vlues
                CString csVeryTemp;
                csVeryTemp = _T("/*");
                AfterString = csTempString.Right( csTempString.GetLength() - (iWhere + csVeryTemp.GetLength()));
            }

            CStringArray arrayInstance;
            int nArray = 0, i = 0;
            if (CheckifServiceExist(_T("IISADMIN")) == 0 ) 
            {
                CMDKey cmdKey;
                //cmdKey.OpenNode(ParsedLine.szFileName);
                cmdKey.OpenNode(BeforeString);
                if ( (METADATA_HANDLE) cmdKey )
                    {
                    // enumerate thru this key for other keys...
                    CMDKeyIter cmdKeyEnum(cmdKey);
                    CString csKeyName;
                    while (cmdKeyEnum.Next(&csKeyName) == ERROR_SUCCESS) 
                    {
                        // make sure that it's a number that we are adding.
                        if (IsValidNumber(csKeyName))
                        {
                            arrayInstance.Add(csKeyName);
                        }
                    }
                    cmdKey.Close();

                    nArray = (int)arrayInstance.GetSize();
                    for (i=0; i<nArray; i++) 
                    {
                        /*
                        // Recurse Thru This nodes entries
                        // Probably look something like these...
                        [/W3SVC]
                        [/W3SVC/1/ROOT/IISSAMPLES/ExAir]
                        [/W3SVC/1/ROOT/IISADMIN]
                        [/W3SVC/1/ROOT/IISHELP]
                        [/W3SVC/1/ROOT/specs]
                        [/W3SVC/2/ROOT]
                        [/W3SVC/2/ROOT/IISADMIN]
                        [/W3SVC/2/ROOT/IISHELP]
                        etc...
                        */
                        CString csPath;
                        csPath = BeforeString;
                        csPath += _T("/");
                        csPath += arrayInstance[i];
                        csPath += AfterString;

                        // DO WHATEVER YOU NEED TO DO.
                        int arrayInstanceNum = _ttoi(arrayInstance[i]);
                        // Add the virtual root

                        iTempFlag = FALSE;
                        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag = TRUE;}

                        // make sure it ParsedLine.szData1 starts with a "/"
                        TCHAR szTempString[_MAX_PATH];
                        _tcscpy(szTempString, ParsedLine.szData1);
                        if (szTempString[0] != _T('/'))
                            {_stprintf(ParsedLine.szData1, _T("/%s"), szTempString);}

                        if (iTempFlag)
                        {
                            AddMDVRootTree(csPath, ParsedLine.szData1, ParsedLine.szData2, ParsedLine.szData3, arrayInstanceNum);
                        }
                        else
                        {
                            AddMDVRootTree(csPath, ParsedLine.szData1, ParsedLine.szData2, NULL, arrayInstanceNum);
                        }
                    }
                }
            }
        }
        else
        {
            // Add the virtual root
            if (CheckifServiceExist(_T("IISADMIN")) == 0 ) 
            {
                iTempFlag = FALSE;
                if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag = TRUE;}

                // make sure it ParsedLine.szData1 starts with a "/"
                TCHAR szTempString[_MAX_PATH];
                _tcscpy(szTempString, ParsedLine.szData1);
                if (szTempString[0] != _T('/'))
                    {_stprintf(ParsedLine.szData1, _T("/%s"), szTempString);}

                if (iTempFlag)
                {
                    AddMDVRootTree(ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2, ParsedLine.szData3, 0);
                }
                else
                {
                    AddMDVRootTree(ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2, NULL, 0);
                }

                
            }
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("84")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Metabase_Exit;
        }

        // call that particular migration section
        CString csTheSection = ParsedLine.szFileName;
        if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, csTheSection))
        {
            MigrateInfSectionToMD(g_pTheApp->m_hInfHandle, csTheSection);
        }
    }

#ifndef _CHICAGO_
    if ( _tcsicmp(ParsedLine.szType, _T("85")) == 0)
    {
        int iTheReturn = TRUE;
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Metabase_Exit;
        }

        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Metabase_Exit;
        }

        iTheReturn = ChangeUserPassword(ParsedLine.szFileName,ParsedLine.szData1);
        if (FALSE == iTheReturn)
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, _T("ChangeUserPassword failed"), ParsedLine.szFileName, MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("ChangeUserPassword(%s).  Failed..\n"), ParsedLine.szFileName));}
        }
    }
#endif

    // We called the function, so return true.
    iReturn = TRUE;

ProcessEntry_Metabase_Exit:
    return iReturn;
}


int ProcessEntry_Misc2(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;

    // Get the type.
    if ( _tcsicmp(ParsedLine.szType, _T("15")) != 0 && _tcsicmp(ParsedLine.szType, _T("16")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("78")) != 0 && _tcsicmp(ParsedLine.szType, _T("79")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("80")) != 0 && _tcsicmp(ParsedLine.szType, _T("81")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("86")) != 0 && _tcsicmp(ParsedLine.szType, _T("87")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("88")) != 0 && _tcsicmp(ParsedLine.szType, _T("89")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("90")) != 0 && _tcsicmp(ParsedLine.szType, _T("91")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("92")) != 0 && _tcsicmp(ParsedLine.szType, _T("93")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("94")) != 0 && _tcsicmp(ParsedLine.szType, _T("95")) != 0 &&
		_tcsicmp(ParsedLine.szType, _T("96")) != 0 && _tcsicmp(ParsedLine.szType, _T("97")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("98")) != 0 && _tcsicmp(ParsedLine.szType, _T("99")) != 0
        )
    {
        goto ProcessEntry_Misc2_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_Misc2_Exit;
    }
        
    // make sure we have a progresstitle
    if ( _tcsicmp(ParsedLine.szType, _T("15")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz805_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
    }


    if ( _tcsicmp(ParsedLine.szType, _T("15")) == 0)
    {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("16")) == 0)
    {
        ProgressBarTextStack_Pop();
    }

    if ( _tcsicmp(ParsedLine.szType, _T("78")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        if (!IsFileExist(ParsedLine.szFileName))
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("ProcessEntry_other():'%s' does not exist.\n"),ParsedLine.szFileName));
            goto ProcessEntry_Misc2_Exit;
        }

        MakeSureDirAclsHaveAtLeastRead((LPTSTR) ParsedLine.szFileName);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("79")) == 0)
    {
        int ifTrueStatementExists = FALSE;
        int ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {ifFalseStatementExists = TRUE;}

        iTempFlag = FALSE;
        iTempFlag = IsMetabaseCorrupt();
        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szFileName));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szFileName);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szFileName, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
                iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));
            }
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("80")) == 0)
    {
        // initialize ole
        iisDebugOut_Start((_T("ole32:OleInitialize")));
        int iBalanceOLE = iOleInitialize();
        iisDebugOut_End((_T("ole32:OleInitialize")));
        // add it to the stack of ole inits and uninits...
        GlobalOleInitList_Push(iBalanceOLE);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("81")) == 0)
    {
        // Uninitialize ole.
        // Check if there is a corresponding oleinit, if there is,
        // then uninit, else uninit anyways.
        // Grab the last thing on the stack...
        // if there is one, then do whatever it is.
        // if there is none, then OleUninitialize anyway
        if (GlobalOleInitList_Find() == TRUE)
        {
            if (TRUE == GlobalOleInitList_Pop())
            {
                iOleUnInitialize(TRUE);
            }
            else
            {
                iOleUnInitialize(FALSE);
            }
        }
        else
        {
            iOleUnInitialize(TRUE);
        }
        
    }

    if ( _tcsicmp(ParsedLine.szType, _T("86")) == 0)
    {
        // See if there is an extra param in the other field
        int iTicksToAdvance = 1;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) 
        {
            if (IsValidNumber((LPCTSTR)ParsedLine.szFileName)) 
                {iTicksToAdvance = _ttoi((LPCTSTR)ParsedLine.szFileName);}
        }
        AdvanceProgressBarTickGauge(iTicksToAdvance);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("87")) == 0)
    {
        LogFilesInThisDir(ParsedLine.szFileName);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("88")) == 0)
    {
        LogFileVersion(ParsedLine.szFileName, TRUE);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("89")) == 0)
    {
        // make sure the metabase writes all the information to disk now.
        WriteToMD_ForceMetabaseToWriteToDisk();
    }

    if ( _tcsicmp(ParsedLine.szType, _T("90")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        DWORD dwTheID = _ttol(ParsedLine.szFileName);
        //iisDebugOut((LOG_TYPE_ERROR,  _T("Values: %s, %d"), ParsedLine.szFileName, dwTheID));
        
        if ( ( dwTheID == 32802 ) &&  // DomainName
             ( _tcsicmp(ParsedLine.szData1, _T("")) == 0)
           )
        {
            CString DomainName;
            
            if ( RetrieveDomain(DomainName) )
            {
                SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle,dwTheID,DomainName.GetBuffer(0));
            }
        }
        else
        {
            SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle,dwTheID,ParsedLine.szData1);
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("91")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        DWORD dwTheID = atodw(ParsedLine.szFileName);
        SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle,dwTheID,ParsedLine.szData1);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("92")) == 0)
    {
        // 100=92|101=Inst mode (0,1,2,3)|102=UpgType(UT_10,etc..)|103=UpgTypeHasMetabaseFlag (0|1)|104=AllCompOffByDefaultFlag
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        //m_eInstallMode = IM_FRESH;
        //m_eUpgradeType = UT_NONE;
        //m_bUpgradeTypeHasMetabaseFlag = FALSE;
        //m_bPleaseDoNotInstallByDefault = TRUE;
        if (_tcsicmp(ParsedLine.szFileName, _T("1")) == 0) 
            {g_pTheApp->m_eInstallMode = IM_FRESH;}
        if (_tcsicmp(ParsedLine.szFileName, _T("2")) == 0) 
            {g_pTheApp->m_eInstallMode = IM_UPGRADE;}
        if (_tcsicmp(ParsedLine.szFileName, _T("3")) == 0) 
            {g_pTheApp->m_eInstallMode = IM_MAINTENANCE;}

        if (_tcsicmp(ParsedLine.szData1, _T("UT_NONE")) == 0) 
            {g_pTheApp->m_eUpgradeType = UT_NONE;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_351")) == 0) 
            {g_pTheApp->m_eUpgradeType = UT_351;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_10")) == 0) 
            {g_pTheApp->m_eUpgradeType = UT_10;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_20")) == 0) 
            {g_pTheApp->m_eUpgradeType = UT_20;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_30")) == 0) 
            {g_pTheApp->m_eUpgradeType = UT_30;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_40")) == 0) 
            {g_pTheApp->m_eUpgradeType = UT_40;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_50")) == 0) 
            {g_pTheApp->m_eUpgradeType = UT_50;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_51")) == 0) 
            {g_pTheApp->m_eUpgradeType = UT_51;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_60")) == 0) 
            {g_pTheApp->m_eUpgradeType = UT_60;}
        if (_tcsicmp(ParsedLine.szData1, _T("UT_10_W95")) == 0) 
            {g_pTheApp->m_eUpgradeType = UT_10_W95;}

        g_pTheApp->m_bUpgradeTypeHasMetabaseFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0) 
            {g_pTheApp->m_bUpgradeTypeHasMetabaseFlag = TRUE;}

        g_pTheApp->m_bPleaseDoNotInstallByDefault = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("1")) == 0) 
            {g_pTheApp->m_bPleaseDoNotInstallByDefault = TRUE;}
    }

    if ( _tcsicmp(ParsedLine.szType, _T("93")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("1")) == 0) {iTempFlag = TRUE;}
        StopAllServicesRegardless(iTempFlag);
    }
    
    if ( _tcsicmp(ParsedLine.szType, _T("94")) == 0)
    {
        DisplayActionsForAllOurComponents(g_pTheApp->m_hInfHandle);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("95")) == 0)
    {
        // Check if the specified file has a version >= iis4.
        // if it does then rename the file.

        // make sure it has a 101
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        // make sure the file exists.
        if (!IsFileExist(ParsedLine.szFileName))
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("ProcessEntry_other():'%s' does not exist.\n"),ParsedLine.szFileName));
            goto ProcessEntry_Misc2_Exit;
        }

        DWORD dwMajorVersion = 0x0;
        DWORD dwMinorVersion = 0x0;
        // make sure it has a 102
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        // make sure it has a 103
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        else
        {
            dwMajorVersion = atodw(ParsedLine.szData2);
        }
                
        // make sure it has a 104
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc2_Exit;
        }
        else
        {
            dwMinorVersion = atodw(ParsedLine.szData3);
        }

        // Check if the file has a larger version.
        //DWORD dwNtopMSVer = 0x40002;
        //DWORD dwNtopLSVer = 0x26e0001;
        if (FALSE == IsFileLessThanThisVersion(ParsedLine.szFileName, dwMajorVersion, dwMinorVersion))
        {
            // ok, this is a 'special' built file that the user built themselves.
            // let's rename it to something else.

            // check if the "to" filename exists.
            iTempFlag = FALSE;
            int I1 = 0;
            TCHAR szTempFileName[_MAX_PATH];
            _tcscpy(szTempFileName, ParsedLine.szData1);
            do
            {
                if (!IsFileExist(szTempFileName) || (I1 > 10))
                {
                    iTempFlag = TRUE;
                    // rename it
                    if (MoveFileEx( ParsedLine.szFileName, szTempFileName, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH|MOVEFILE_REPLACE_EXISTING))
                        {iisDebugOut((LOG_TYPE_WARN, _T("%s was renamed to %s for safety because it is probably a user compiled file. WARNING."),ParsedLine.szFileName, szTempFileName));}
                    else
                        {iisDebugOut((LOG_TYPE_ERROR, _T("Rename of %s to %s for safety because it is probably a user compiled file. FAILED."),ParsedLine.szFileName, szTempFileName));}
                }
                else
                {
                    // add on some other stuff.
                    I1++;
                    _stprintf(szTempFileName, _T("%s%d"), ParsedLine.szData1, I1);
                }
            } while (iTempFlag == FALSE);
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("96")) == 0)
    {
		// show messagebox
		int iSaveOld_AllowMessageBoxPopups = g_pTheApp->m_bAllowMessageBoxPopups;
		g_pTheApp->m_bAllowMessageBoxPopups = TRUE; 
		MyMessageBox(NULL, ParsedLine.szData1, ParsedLine.szFileName, MB_OK | MB_SETFOREGROUND);
		g_pTheApp->m_bAllowMessageBoxPopups = iSaveOld_AllowMessageBoxPopups;
    }

    if ( _tcsicmp(ParsedLine.szType, _T("97")) == 0)
    {
        // do nothing...
    }


    if ( _tcsicmp(ParsedLine.szType, _T("98")) == 0)
    {
        //Reboot
        SetRebootFlag();
    }
    
    if ( _tcsicmp(ParsedLine.szType, _T("99")) == 0)
    {
        // dump internal variables
        g_pTheApp->DumpAppVars();
        int iDoExtraStuff = 0;

        if (ParsedLine.szFileName && _tcsicmp(ParsedLine.szFileName, _T("")) != 0) 
        {
            if (IsValidNumber((LPCTSTR)ParsedLine.szFileName)) 
                {
                iDoExtraStuff = _ttoi((LPCTSTR)ParsedLine.szFileName);
                }
        }

        if (g_GlobalDebugLevelFlag >= LOG_TYPE_TRACE)
        {
            if (iDoExtraStuff >= 2)
            {
                // display locked dlls by setup
                LogThisProcessesDLLs();
                // display running processes
                LogCurrentProcessIDs();
                // free some memory used for the task list
                FreeTaskListMem();
                UnInit_Lib_PSAPI();
            }

            // display running services
            if (iDoExtraStuff >= 1)
            {
                LogEnumServicesStatus();
            }
            // log file versions
            LogImportantFiles();
            // check if temp dir is writeable
            LogCheckIfTempDirWriteable();
        }
    }

    // We called the function, so return true.
    iReturn = TRUE;

ProcessEntry_Misc2_Exit:
    return iReturn;
}


int ProcessEntry_Misc3(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;
    int ifTrueStatementExists = FALSE;
    int ifFalseStatementExists = FALSE;
    
    int iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    // Get the type.
    if ( _tcsicmp(ParsedLine.szType, _T("101")) != 0 && _tcsicmp(ParsedLine.szType, _T("102")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("103")) != 0 && _tcsicmp(ParsedLine.szType, _T("104")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("105")) != 0 && _tcsicmp(ParsedLine.szType, _T("106")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("107")) != 0 && _tcsicmp(ParsedLine.szType, _T("108")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("109")) != 0 && _tcsicmp(ParsedLine.szType, _T("110")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("111")) != 0 && _tcsicmp(ParsedLine.szType, _T("112")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("113")) != 0 && _tcsicmp(ParsedLine.szType, _T("114")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("115")) != 0 && _tcsicmp(ParsedLine.szType, _T("116")) != 0 &&
        _tcsicmp(ParsedLine.szType, _T("117")) != 0 && _tcsicmp(ParsedLine.szType, _T("118")) != 0
       )
    {
        goto ProcessEntry_Misc3_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_Misc3_Exit;
    }
        
    if ( _tcsicmp(ParsedLine.szType, _T("101")) == 0)
    {
        // Remove filter
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        // Check for extra flag
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("1")) == 0){iTempFlag = TRUE;}

		// Remove the filter
		RemoveMetabaseFilter(ParsedLine.szFileName, iTempFlag);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("102")) == 0)
    {
        // Remove bad filters
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // Check for extra flag
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("1")) == 0){iTempFlag = TRUE;}

        // Remove the filter
        RemoveIncompatibleMetabaseFilters(ParsedLine.szFileName,iTempFlag);

    }

    if ( _tcsicmp(ParsedLine.szType, _T("103")) == 0)
    {
		// Compile mof file

        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

		// Remove the filter
		HRESULT hres = MofCompile(ParsedLine.szFileName);
        if (FAILED(hres))
        {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, ParsedLine.szFileName, hres, MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_ERROR, _T("MofCompile(%s).  Failed.  Err=0x%x.\n"), ParsedLine.szFileName,hres));}
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("104")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // Make sure we have a value for the entry point..
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // make sure there is a szData3 or a szData4.
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // okay we have either szData3 or szData4
        // Check Entry point exists
        iTempFlag = FALSE;
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("ProcessEntry_If:check for entrypoint [%1!s! (%2!s!)]\n"), ParsedLine.szFileName, ParsedLine.szData1));

		// check if entry point exists
		DWORD dwReturn = DoesEntryPointExist(ParsedLine.szFileName,ParsedLine.szData1);
        if (ERROR_SUCCESS == dwReturn)
        {
            iTempFlag = TRUE;
        }
        else
        {
            if (ERROR_FILE_NOT_FOUND == dwReturn)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("FileNot found:[%1!s!]\n"), ParsedLine.szFileName));
            }
        }

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData3));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData3);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData3, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("105")) == 0)
    {
        HRESULT hr;
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // Make sure we have a value for the entry point..
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // Make sure we have a value for the entry point..
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // call function to  CreateGroup
#ifndef _CHICAGO_
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
        {
            // add group
            hr = CreateGroup(ParsedLine.szFileName,ParsedLine.szData1,TRUE);
            if (FAILED(hr))
            {
                iisDebugOut((LOG_TYPE_WARN, _T("CreateGroup:%s,%s.failed.code=0x%x\n"),ParsedLine.szFileName, ParsedLine.szData1,hr));
            }
        }
        else
        {
            // remove group
            hr = CreateGroup(ParsedLine.szFileName,ParsedLine.szData1,FALSE);
            if (FAILED(hr))
            {
                iisDebugOut((LOG_TYPE_WARN, _T("DeleteGroup:%s,%s.failed.code=0x%x\n"),ParsedLine.szFileName, ParsedLine.szData1,hr));
            }
        }
#endif
    }

    if ( _tcsicmp(ParsedLine.szType, _T("106")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // Make sure we have a value for the entry point..
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // call function to  CreateGroup
        DWORD dwPermissions = MD_ACR_ENUM_KEYS;
        dwPermissions = atodw(ParsedLine.szData1);
#ifndef _CHICAGO_
        iTempFlag = TRUE;
        if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
        {
            if (DoesAdminACLExist(ParsedLine.szFileName) == TRUE)
                {iTempFlag = FALSE;}
        }
        // if this is upgrading from win95, then make sure to write the acl...
        if (g_pTheApp->m_bWin95Migration){iTempFlag = TRUE;}
        if (iTempFlag)
        {
            SetAdminACL_wrap(ParsedLine.szFileName,dwPermissions,TRUE);
        }
#endif
    }

    if ( _tcsicmp(ParsedLine.szType, _T("107")) == 0)
    {
        // Run the ftp, upgrade code to move registry stuff to the metabase
        FTP_Upgrade_RegToMetabase(g_pTheApp->m_hInfHandle);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("108")) == 0)
    {
        // Run the w3svc, upgrade code to move registry stuff to the metabase
        WWW_Upgrade_RegToMetabase(g_pTheApp->m_hInfHandle);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("109")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        UpgradeFilters(ParsedLine.szFileName);
    }


    if ( _tcsicmp(ParsedLine.szType, _T("110")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
#ifndef _CHICAGO_
        if (_tcsicmp(ParsedLine.szData1, _T("1")) == 0)
        {
            // add
            RegisterAccountToLocalGroup(_T("system"),ParsedLine.szFileName,TRUE);
            RegisterAccountToLocalGroup(_T("service"),ParsedLine.szFileName,TRUE);
            RegisterAccountToLocalGroup(_T("networkservice"),ParsedLine.szFileName,TRUE);
        }
        else
        {
            // remove
            RegisterAccountToLocalGroup(_T("system"),ParsedLine.szFileName,FALSE);
            RegisterAccountToLocalGroup(_T("service"),ParsedLine.szFileName,FALSE);
            RegisterAccountToLocalGroup(_T("networkservice"),ParsedLine.szFileName,FALSE);
        }
#endif
    }


    if ( _tcsicmp(ParsedLine.szType, _T("111")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
#ifndef _CHICAGO_
        AddUserToMetabaseACL(ParsedLine.szFileName,ParsedLine.szData1);
#endif
    }

    if ( _tcsicmp(ParsedLine.szType, _T("112")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

#ifndef _CHICAGO_
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0)
        {
            // add
            RegisterAccountToLocalGroup(ParsedLine.szData1,ParsedLine.szFileName,TRUE);
        }
        else
        {
            // remove
            RegisterAccountToLocalGroup(ParsedLine.szData1,ParsedLine.szFileName,FALSE);
        }
#endif
    }

    if ( _tcsicmp(ParsedLine.szType, _T("113")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        HKEY hRootKeyType = HKEY_LOCAL_MACHINE;
        // check if the registry key exists...
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKLM")) == 0){hRootKeyType = HKEY_LOCAL_MACHINE;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCR")) == 0){hRootKeyType = HKEY_CLASSES_ROOT;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKCU")) == 0){hRootKeyType = HKEY_CURRENT_USER;}
        if ( _tcsicmp(ParsedLine.szFileName, _T("HKU")) == 0){hRootKeyType = HKEY_USERS;}
#ifndef _CHICAGO_
        DWORD dwAccessMask = atodw(ParsedLine.szData3);
        DWORD dwInheritMask = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
        SetRegistryKeySecurity(hRootKeyType,ParsedLine.szData1,ParsedLine.szData2,dwAccessMask,dwInheritMask,TRUE,ParsedLine.szData4);
#endif
    }

    if ( _tcsicmp(ParsedLine.szType, _T("114")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        // rename the metabase node.
        if (CheckifServiceExist(_T("IISADMIN")) == 0 ) 
        {
            CMDKey cmdKey;
            cmdKey.OpenNode(ParsedLine.szFileName);
            if ( (METADATA_HANDLE)cmdKey ) 
            {
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("RenameNode:%s=%s\n"),ParsedLine.szData1,ParsedLine.szData2));
                cmdKey.RenameNode(ParsedLine.szData1, ParsedLine.szData2);
                cmdKey.Close();
            }
        }
    }


    if ( _tcsicmp(ParsedLine.szType, _T("115")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // make sure there is a szData1 or a szData2
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // okay we have either szData1 or szData2

        // Check if the language specified in the .inf corresponds to
        // our systems language.
        iTempFlag = FALSE;

        // Get our language
        // set iTempFlag to true if it matches the same language they specified.

        DWORD dwCodePage = GetACP();
        DWORD dwTheCodePageSpecifiedinINF = 0;
        dwTheCodePageSpecifiedinINF = atodw(ParsedLine.szFileName);

        iisDebugOut((LOG_TYPE_TRACE, _T("CodePage=0x%x,%d\n"),dwCodePage,dwCodePage));

        if (dwTheCodePageSpecifiedinINF == dwCodePage)
        {
            iTempFlag = TRUE;
        }

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }

        }
    }


    if ( _tcsicmp(ParsedLine.szType, _T("116")) == 0)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("CreateDummyMetabaseBin\n")));
        CreateDummyMetabaseBin();
    }

    if ( _tcsicmp(ParsedLine.szType, _T("117")) == 0)
    {
        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // make sure there is a szData1 or a szData2
        ifTrueStatementExists = FALSE;
        ifFalseStatementExists = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {ifTrueStatementExists = TRUE;}
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {ifFalseStatementExists = TRUE;}
        if (ifTrueStatementExists == FALSE && ifFalseStatementExists == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }

        // okay we have either szData1 or szData2
        iTempFlag = CheckForWriteAccess(ParsedLine.szFileName);

        if (iTempFlag == TRUE)
        {
            // the result was true
            // the key exists, so let's do the section...
            if (ifTrueStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData1));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData1);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData1, iTempFlag));
            }
        }
        else
        {
            // the result was false
            if (ifFalseStatementExists)
            {
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:Start.\n"), ParsedLine.szData2));
                iTempFlag = ProcessSection(g_pTheApp->m_hInfHandle,ParsedLine.szData2);
                iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("Calling ProcessSection:%1!s!:End.return=%2!d!\n"), ParsedLine.szData2, iTempFlag));
            }

        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("118")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_Misc3_Exit;
        }
#ifndef _CHICAGO_
        if ( ( _tcsicmp(ParsedLine.szData4, _T("")) != 0) &&
             ( _ttoi(ParsedLine.szData4) == 1 )
           )
        {
            RemovePrincipalFromFileAcl(ParsedLine.szFileName,ParsedLine.szData1);
        }
        else
        {
            DWORD dwAccessMask = atodw(ParsedLine.szData2);
            //DWORD dwInheritMask = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
            // don't remove any iheritance, keep all inheritance
            DWORD dwInheritMask = 0;
            INT iAceType = ACCESS_ALLOWED_ACE_TYPE;
            if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) 
            {
                iAceType = _ttoi(ParsedLine.szData3);
                //dwInheritMask = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE | INHERITED_ACE;
            }

            SetDirectorySecurity(ParsedLine.szFileName,ParsedLine.szData1,iAceType,dwAccessMask,dwInheritMask);
        }

#endif
    }

    // We called the function, so return true.
    iReturn = TRUE;

ProcessEntry_Misc3_Exit:
    return iReturn;
}


int ProcessEntry_other(IN CString csEntry,IN LPCTSTR szTheSection,ThingToDo ParsedLine)
{
    int iReturn = FALSE;
    int iTempFlag = FALSE;
    int iProgressBarUpdated = FALSE;
    int iShowErrorsOnFail = TRUE;

    TCHAR szDirBefore[_MAX_PATH];
    _tcscpy(szDirBefore, _T(""));

    // Get the type.
    if ( _tcsicmp(ParsedLine.szType, _T("19")) != 0 && _tcsicmp(ParsedLine.szType, _T("20")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("21")) != 0 && _tcsicmp(ParsedLine.szType, _T("22")) != 0 &&
		 _tcsicmp(ParsedLine.szType, _T("23")) != 0 && _tcsicmp(ParsedLine.szType, _T("24")) != 0 &&
		 _tcsicmp(ParsedLine.szType, _T("25")) != 0 && _tcsicmp(ParsedLine.szType, _T("26")) != 0 &&
		 _tcsicmp(ParsedLine.szType, _T("27")) != 0 && _tcsicmp(ParsedLine.szType, _T("28")) != 0 && 
         _tcsicmp(ParsedLine.szType, _T("29")) != 0 && _tcsicmp(ParsedLine.szType, _T("30")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("31")) != 0 && _tcsicmp(ParsedLine.szType, _T("32")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("33")) != 0 && _tcsicmp(ParsedLine.szType, _T("34")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("35")) != 0 && _tcsicmp(ParsedLine.szType, _T("36")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("37")) != 0 && _tcsicmp(ParsedLine.szType, _T("38")) != 0 &&
         _tcsicmp(ParsedLine.szType, _T("120"))
         )
    {
        goto ProcessEntry_other_Exit;
    }

    // Check if there is other criteria we need to pass
    if (!ProcessEntry_CheckAll(csEntry, szTheSection, ParsedLine) )
    {
        goto ProcessEntry_other_Exit;
    }

    if (_tcsicmp(ParsedLine.szType, _T("28")) != 0)
    {
        if (_tcsicmp(ParsedLine.szType, _T("37")) != 0)
        {
            // make sure we have a filename entry
            iTempFlag = FALSE;
            if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
            if (iTempFlag == FALSE)
            {
                iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
                goto ProcessEntry_other_Exit;
            }
        }
    }

    iShowErrorsOnFail = TRUE;
    if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
        {iShowErrorsOnFail = FALSE;}

    if (_tcsicmp(ParsedLine.szProgressTitle, _T("")) != 0) 
        {
        ProgressBarTextStack_Set(ParsedLine.szProgressTitle);
        iProgressBarUpdated = TRUE;
        }

    // Check if we need to change to a specific dir first...
    if (ParsedLine.szChangeDir)
    {
        if (IsFileExist(ParsedLine.szChangeDir))
        {
            // save the current dir
            GetCurrentDirectory( _MAX_PATH, szDirBefore);
            // change to this dir
            SetCurrentDirectory(ParsedLine.szChangeDir);
        }
    }

    // check if we need to ask the user if they want to call it for sure.
    if (!ProcessEntry_AskFirst(ParsedLine, 1))
    {
        goto ProcessEntry_other_Exit;
    }

    if ( _tcsicmp(ParsedLine.szType, _T("19")) == 0)
    {
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyAddGroup:%1!s!\n"),ParsedLine.szFileName));
        MyAddGroup(ParsedLine.szFileName);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("20")) == 0)
    {
		if ( _tcsicmp(ParsedLine.szData1, _T("1")) == 0)
		{
			iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyDeleteGroup:%1!s!. even if not empty.\n"),ParsedLine.szFileName));
			MyDeleteGroup(ParsedLine.szFileName);
		}
		else
		{
			iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyDeleteGroup:%1!s!. only if empty.\n"),ParsedLine.szFileName));
			if (MyIsGroupEmpty(ParsedLine.szFileName)) {MyDeleteGroup(ParsedLine.szFileName);}
		}
    }

    if ( _tcsicmp(ParsedLine.szType, _T("21")) == 0)
    {
       
        //MyAddItem(csGroupName, csAppName, csProgram, NULL, NULL);
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyAddItem:Type=%1!s!,%2!s!,%3!s!,%4!s!,%5!s!\n"),ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2, ParsedLine.szData3, ParsedLine.szData4));
        if ( _tcsicmp(ParsedLine.szData3, _T("")) == 0 && _tcsicmp(ParsedLine.szData4, _T("")) == 0)
        {
            MyAddItem(ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2, NULL, NULL, NULL);
        }
        else
        {
            // if ParsedLine.szData4 is a directory, then
            // the start in dir should be used there.

            // if ParsedLine.szData4 is a filename, then
            // the start in dir should be used there.
            // and you ought to use the filename specified for the icon
            if (IsFileExist(ParsedLine.szData4))
            {
                DWORD retCode = GetFileAttributes(ParsedLine.szData4);
                
                if (retCode & FILE_ATTRIBUTE_DIRECTORY)
                {
                    // It is a directory, so pass in only the directory information
                    MyAddItem(ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2, ParsedLine.szData3, ParsedLine.szData4, NULL);
                }
                else
                {
                    // it is a file so get the directory and pass in the filename as well.
                    TCHAR szDirOnly[_MAX_PATH];
                    TCHAR szDirOnly2[_MAX_PATH];
                    _tcscpy(szDirOnly, _T(""));
                    _tcscpy(szDirOnly2, _T(""));
                    InetGetFilePath(ParsedLine.szData4, szDirOnly);

                    // change e:\winnt\system32 to %systemroot%\system32 if we need to.
                    ReverseExpandEnvironmentStrings(szDirOnly, szDirOnly2);

                    MyAddItem(ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2, ParsedLine.szData3, szDirOnly2, ParsedLine.szData4);
                }
                
            }
            else
            {
                MyAddItem(ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2, NULL, NULL, NULL);
            }
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("22")) == 0)
    {
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyDeleteItem:%1!s!,%2!s!\n"),ParsedLine.szFileName, ParsedLine.szData1));
        MyDeleteItem(ParsedLine.szFileName, ParsedLine.szData1);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("23")) == 0)
    {
		//MyAddDeskTopItem(csAppName, csProgram, NULL, NULL, csProgram, 7);
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyAddDeskTopItem:Type=%1!s!,%2!s!,%3!s!\n"),ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2));
        if ( _tcsicmp(ParsedLine.szData2, _T("")) == 0)
        {
			// icon number not specified
			MyAddDeskTopItem(ParsedLine.szFileName, ParsedLine.szData1, NULL, NULL, ParsedLine.szData1, 7);
        }
        else
        {
			// icon specified use what they said to use
			int iIconIndex = 7 ;
            if (IsValidNumber((LPCTSTR)ParsedLine.szData2)) 
                {iIconIndex = _ttoi((LPCTSTR)ParsedLine.szData2);}
			MyAddDeskTopItem(ParsedLine.szFileName, ParsedLine.szData1, NULL, NULL, ParsedLine.szData1, iIconIndex);
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("24")) == 0)
    {
		//MyDeleteDeskTopItem(csAppName);
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyDeleteDeskTopItem:%1!s!\n"),ParsedLine.szFileName));
        MyDeleteDeskTopItem(ParsedLine.szFileName);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("120")) == 0)
    {
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("DeleteFromGroup:%1!s!\n"),ParsedLine.szFileName));
        DeleteFromGroup(ParsedLine.szFileName, ParsedLine.szData1);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("25")) == 0)
    {
		//MyAddSendToItem(csAppName, csProgram, NULL, NULL);
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyAddSendToItem:Type=%1!s!,%2!s!\n"),ParsedLine.szFileName, ParsedLine.szData1));
		MyAddSendToItem(ParsedLine.szFileName, ParsedLine.szData1, NULL, NULL);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("26")) == 0)
    {
		//MyDeleteSendToItem(csAppName);
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyDeleteSendToItem:%1!s!\n"),ParsedLine.szFileName));
        MyDeleteSendToItem(ParsedLine.szFileName);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("27")) == 0)
    {
		if (ParsedLine.szFileName)
		{
			if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0)
			{
                INT iUserWasNewlyCreated = 0;
                //CreateIUSRAccount(g_pTheApp->m_csWWWAnonyName, g_pTheApp->m_csWWWAnonyPassword);
#ifndef _CHICAGO_
				CreateIUSRAccount( (LPTSTR)(LPCTSTR) ParsedLine.szFileName, (LPTSTR)(LPCTSTR) ParsedLine.szData1,&iUserWasNewlyCreated);
#endif //_CHICAGO_
			}
		}
    }

    if ( _tcsicmp(ParsedLine.szType, _T("28")) == 0)
    {
		if (ParsedLine.szFileName)
		{
			if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0)
			{
#ifndef _CHICAGO_
                int iUserWasDeleted = 0;
				DeleteGuestUser( (LPTSTR)(LPCTSTR) ParsedLine.szFileName,&iUserWasDeleted);
                // if the user was deleted, then remove it
                // from the uninstall list!
                if (1 == iUserWasDeleted)
                {
                    g_pTheApp->UnInstallList_DelData(ParsedLine.szFileName);
                }
#endif
			}
		}
    }

    // move location of directory recursive
    if ( _tcsicmp(ParsedLine.szType, _T("29")) == 0)
    {
		if (ParsedLine.szFileName && _tcsicmp(ParsedLine.szFileName, _T("")) != 0)
		{
            // Check if the from directory even exist...
            // see if the file exists
            if (IsFileExist(ParsedLine.szFileName)) 
            {
                if (ParsedLine.szData1 && _tcsicmp(ParsedLine.szData1, _T("")) != 0)
                {
                    if (TRUE == MoveFileEx( ParsedLine.szFileName, ParsedLine.szData1, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH ))
                    {
                        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("MoveFileEx:%1!s! to %2!s!.  success.\n"),ParsedLine.szFileName, ParsedLine.szData1));
                    }
                    else
                    {
                        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("MoveFileEx:%1!s! to %2!s!.  failed.\n"),ParsedLine.szFileName, ParsedLine.szData1));
                    }
                }
            }
		}
    }

    if ( _tcsicmp(ParsedLine.szType, _T("30")) == 0)
    {
		if (ParsedLine.szFileName && _tcsicmp(ParsedLine.szFileName, _T("")) != 0)
		{
			BOOL b;
			BOOL bInstalled = FALSE;
			CString csFile;

			b = AddFontResource(ParsedLine.szFileName);
			if (!b)
			{
				csFile = g_pTheApp->m_csWinDir + _T("\\Fonts\\");
				csFile += ParsedLine.szFileName;
				b = AddFontResource((LPCTSTR)csFile);
				if (!b)
				{
					iisDebugOut((LOG_TYPE_ERROR, _T("AddFontResource:FAILED:, csFile=%s, err=0x%x,\n"), csFile, GetLastError()));
				}
			}

			if (b)
			{
			SendMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0);
			}

		}
	}

    if ( _tcsicmp(ParsedLine.szType, _T("31")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }

        AddURLShortcutItem( ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("32")) == 0)
    {
        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyAddItem:Type=%1!s!,%2!s!,%3!s!\n"),ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2));
        MyAddItemInfoTip(ParsedLine.szFileName, ParsedLine.szData1, ParsedLine.szData2);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("33")) == 0)
    {
        CString strUseThisFileName;
        int iShowErrorsOnFail = TRUE;
        if (_tcsicmp(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T("1")) == 0)
            {iShowErrorsOnFail = FALSE;}

        // the user can specify a filename or
        // they can specify a registry location to get the filename from
        // if the registry location is not there then use the filename.

        // make sure we have a filename entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }

        strUseThisFileName = ParsedLine.szFileName;

        // if we have a valid registry entry then use that.
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) 
        {
            if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) 
            {
                if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) 
                {
                    // try to get the filename stored there.
                    HKEY hRootKeyType = HKEY_LOCAL_MACHINE;
                    // check if the registry key exists...
                    if ( _tcsicmp(ParsedLine.szData1, _T("HKLM")) == 0){hRootKeyType = HKEY_LOCAL_MACHINE;}
                    if ( _tcsicmp(ParsedLine.szData1, _T("HKCR")) == 0){hRootKeyType = HKEY_CLASSES_ROOT;}
                    if ( _tcsicmp(ParsedLine.szData1, _T("HKCU")) == 0){hRootKeyType = HKEY_CURRENT_USER;}
                    if ( _tcsicmp(ParsedLine.szData1, _T("HKU")) == 0){hRootKeyType = HKEY_USERS;}

                    iTempFlag = FALSE;
                    CRegKey regTheKey(hRootKeyType, ParsedLine.szData2,KEY_READ);
                    CString strReturnQueryValue;
                    if ((HKEY) regTheKey)
                    {
                        if (ERROR_SUCCESS == regTheKey.QueryValue(ParsedLine.szData3, strReturnQueryValue))
                            {
                            strUseThisFileName = strReturnQueryValue;
                            iTempFlag = TRUE;
                            }
                    }
                }
            }
        }

        // check if the the filename we want to use 
        // needs to get expanded "%windir%\myfile" or something.
        if (-1 != strUseThisFileName.Find(_T('%')) )
        {
            // there is a '%' in the string
            TCHAR szTempDir[_MAX_PATH];
            _tcscpy(szTempDir, strUseThisFileName);
            if (ExpandEnvironmentStrings( (LPCTSTR)strUseThisFileName, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                {
                strUseThisFileName = szTempDir;
                }
        }

        if (TRUE == iTempFlag)
        {
            iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("CreateAnEmptyFile:%1!s!. From Registry location.\n"),strUseThisFileName));
        }
        else
        {
            iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("CreateAnEmptyFile:%1!s!\n"),strUseThisFileName));
        }
        
        if (TRUE != CreateAnEmptyFile(strUseThisFileName))
            {
            if (iShowErrorsOnFail){MyMessageBox(NULL, IDS_RUN_PROG_FAILED, strUseThisFileName, GetLastError(), MB_OK | MB_SETFOREGROUND);}
            else{iisDebugOut((LOG_TYPE_TRACE, _T("CreateAnEmptyFile(%s).  Failed.  Err=0x%x.\n"), strUseThisFileName, GetLastError() ));}
            }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("34")) == 0)
    {
        CString strUseThisFileName;
        TCHAR szUseThisFileName[_MAX_PATH];

        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }

        strUseThisFileName = ParsedLine.szFileName;

        // if we have a valid registry entry then use that.
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) 
        {
            if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) 
            {
                if (_tcsicmp(ParsedLine.szData4, _T("")) != 0) 
                {
                    // try to get the filename stored there.
                    HKEY hRootKeyType = HKEY_LOCAL_MACHINE;
                    // check if the registry key exists...
                    if ( _tcsicmp(ParsedLine.szData2, _T("HKLM")) == 0){hRootKeyType = HKEY_LOCAL_MACHINE;}
                    if ( _tcsicmp(ParsedLine.szData2, _T("HKCR")) == 0){hRootKeyType = HKEY_CLASSES_ROOT;}
                    if ( _tcsicmp(ParsedLine.szData2, _T("HKCU")) == 0){hRootKeyType = HKEY_CURRENT_USER;}
                    if ( _tcsicmp(ParsedLine.szData2, _T("HKU")) == 0){hRootKeyType = HKEY_USERS;}

                    iTempFlag = FALSE;
                    CRegKey regTheKey(hRootKeyType, ParsedLine.szData3, KEY_READ);
                    CString strReturnQueryValue;
                    if ((HKEY) regTheKey)
                    {
                        if (ERROR_SUCCESS == regTheKey.QueryValue(ParsedLine.szData4, strReturnQueryValue))
                            {
                            strUseThisFileName = strReturnQueryValue;
                            iTempFlag = TRUE;
                            }
                    }
                }
            }
        }

        // check if the the filename we want to use 
        // needs to get expanded "%windir%\myfile" or something.
        if (-1 != strUseThisFileName.Find(_T('%')) )
        {
            // there is a '%' in the string
            TCHAR szTempDir[_MAX_PATH];
            _tcscpy(szTempDir, strUseThisFileName);
            if (ExpandEnvironmentStrings( (LPCTSTR)strUseThisFileName, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                {
                strUseThisFileName = szTempDir;
                }
        }

        iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("GrantUserAccessToFile:%1!s!,%2!s!\n"),strUseThisFileName, ParsedLine.szData1));
        _tcscpy(szUseThisFileName, strUseThisFileName);
        GrantUserAccessToFile(szUseThisFileName, ParsedLine.szData1);
    }

    if ( _tcsicmp(ParsedLine.szType, _T("35")) == 0)
    {
        DWORD dwID = 0;
        DWORD dwAttrib = 0;
        DWORD dwUserType = 0;
        DWORD dwTheData = 0;
        INT iOverwriteFlag = FALSE;

        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }

        // make sure we have a szData2 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData2, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz103_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }

        // make sure we have a szData3 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData3, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz104_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }

        dwID = atodw(ParsedLine.szData1);
        dwAttrib = METADATA_INHERIT;
        dwUserType = atodw(ParsedLine.szData2);
        dwTheData = atodw(ParsedLine.szData3);

        iOverwriteFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData4, _T("1")) == 0) 
            {iOverwriteFlag = TRUE;}

        if (CheckifServiceExist(_T("IISADMIN")) == 0 ) 
        {
            WriteToMD_DwordEntry(ParsedLine.szFileName, dwID, dwAttrib, dwUserType, dwTheData, iOverwriteFlag);
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("36")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz101_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }
#ifndef _CHICAGO_
        SetIISADMINRestriction(ParsedLine.szFileName);
#endif
    }

    if ( _tcsicmp(ParsedLine.szType, _T("37")) == 0)
    {
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szFileName, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == TRUE)
        {
            int MyLogErrorType = LOG_TYPE_TRACE;
            if (_tcsicmp(ParsedLine.szData1, _T("0")) == 0) 
                {MyLogErrorType = LOG_TYPE_ERROR;}
            if (_tcsicmp(ParsedLine.szData1, _T("1")) == 0) 
                {MyLogErrorType = LOG_TYPE_WARN;}
            if (_tcsicmp(ParsedLine.szData1, _T("2")) == 0) 
                {MyLogErrorType = LOG_TYPE_PROGRAM_FLOW;}
            if (_tcsicmp(ParsedLine.szData1, _T("3")) == 0) 
                {MyLogErrorType = LOG_TYPE_TRACE;}
            if (_tcsicmp(ParsedLine.szData1, _T("4")) == 0) 
                {MyLogErrorType = LOG_TYPE_TRACE_WIN32_API;}
            iisDebugOut((MyLogErrorType, _T("%s"), ParsedLine.szFileName));
        }
    }

    if ( _tcsicmp(ParsedLine.szType, _T("38")) == 0)
    {
        BOOL bOK = FALSE;
        BOOL bDeleteOld = FALSE;
        BOOL bOverWriteToFile = FALSE;

        // make sure we have a szData1 entry
        iTempFlag = FALSE;
        if (_tcsicmp(ParsedLine.szData1, _T("")) != 0) {iTempFlag = TRUE;}
        if (iTempFlag == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR,  (TCHAR *) csz102_NOT_SPECIFIED, _T(".."), csEntry, szTheSection));
            goto ProcessEntry_other_Exit;
        }

        bDeleteOld = FALSE; 
        if (_tcsicmp(ParsedLine.szData2, _T("1")) == 0) {bDeleteOld = TRUE;}
        bOverWriteToFile = FALSE; 
        if (_tcsicmp(ParsedLine.szData3, _T("1")) == 0) {bOverWriteToFile = TRUE;}

        if (IsFileExist(ParsedLine.szFileName))
        {
            //Save file attributes so they can be restored after we are done.
            DWORD dwSourceAttrib = GetFileAttributes(ParsedLine.szFileName);

            //Now set the file attributes to normal to ensure file ops succeed.
            SetFileAttributes(ParsedLine.szFileName, FILE_ATTRIBUTE_NORMAL);
        
            //from=ParsedLine.szFileName
            //to=ParsedLine.szData1
            // check if the 'to' filename exists.
            if (!IsFileExist(ParsedLine.szData1))
            {
                    // go ahead and try to copy it over 
                    bOK = CopyFile(ParsedLine.szFileName, ParsedLine.szData1, FALSE);
                    if (bOK)
                    {
                        SetFileAttributes(ParsedLine.szData1, dwSourceAttrib);
                        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("%1!s! copied to %2!s!.\n"), ParsedLine.szFileName, ParsedLine.szData1));
                        // the file was copied. let's delete it now.
                        if (bDeleteOld)
                        {
                            if(!DeleteFile(ParsedLine.szFileName))
                            {
                                MoveFileEx(ParsedLine.szFileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                            }
                        }
                        else
                        {
                            // set this files attribs back to what it was
                            SetFileAttributes(ParsedLine.szFileName, dwSourceAttrib);
                        }
                    }
                    else
                    {
                        // we were unable to copy the file over!
                        // don't delete the old one.
                        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("unabled to copy %1!s! to %2!s!.\n"), ParsedLine.szFileName, ParsedLine.szData1));
                    }
            }
            else
            {
                // the 'to' file exists, shall we overwrite it?
                if (bOverWriteToFile)
                {
                    if(DeleteFile(ParsedLine.szData1))
                    {
                        bOK = FALSE;
                        bOK = CopyFile(ParsedLine.szFileName, ParsedLine.szData1, FALSE);
                        if (bOK)
                        {
                            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("%1!s! copied to %2!s!.\n"), ParsedLine.szFileName, ParsedLine.szData1));
                            // the file was copied. let's delete it now.
                            if (bDeleteOld)
                            {
                                if(!DeleteFile(ParsedLine.szFileName))
                                {
                                    MoveFileEx(ParsedLine.szFileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                                }
                            }
                            else
                            {
                                // set this files attribs back to what it was
                                SetFileAttributes(ParsedLine.szFileName, dwSourceAttrib);
                            }
                        }
                        else
                        {
                            iisDebugOutSafeParams((LOG_TYPE_WARN, _T("unabled to copy %1!s! to %2!s!.\n"), ParsedLine.szFileName, ParsedLine.szData1));
                        }
                    }
                    else
                    {
                        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("unabled to copy %1!s! to %2!s!.  file#2 cannot be deleted.\n"), ParsedLine.szFileName, ParsedLine.szData1));
                    }
                }
                else
                {
                    iisDebugOutSafeParams((LOG_TYPE_WARN, _T("unabled to copy %1!s! to %2!s!.  file#2 already exists.\n"), ParsedLine.szFileName, ParsedLine.szData1));
                }
            }
        }
    }

    // We called the function, so return true.
    iReturn = TRUE;

    // change back to the original dir
    if (ParsedLine.szChangeDir){if (szDirBefore){SetCurrentDirectory(szDirBefore);}}

    ProcessEntry_AskLast(ParsedLine, 1);

ProcessEntry_other_Exit:
    if (TRUE == iProgressBarUpdated){ProgressBarTextStack_Pop();}
    return iReturn;
}


int ProcessEntry_Entry(IN HINF hFile, IN LPCTSTR szTheSection, IN CString csOneParseableLine)
{
    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("ProcessEntry_Entry:%1!s!, %2!s!\n"),szTheSection, csOneParseableLine));
    int iReturn = FALSE;
    int iReturnTemp = FALSE;
    int iTempFlag = FALSE;

    ThingToDo ParsedLine;

    _tcscpy(ParsedLine.szType, _T(""));
    _tcscpy(ParsedLine.szFileName, _T(""));
    _tcscpy(ParsedLine.szData1, _T(""));
    _tcscpy(ParsedLine.szData2, _T(""));
    _tcscpy(ParsedLine.szData3, _T(""));
    _tcscpy(ParsedLine.szData4, _T(""));
    _tcscpy(ParsedLine.szChangeDir, _T(""));

    _tcscpy(ParsedLine.szOS, _T(""));
    _tcscpy(ParsedLine.szPlatformArchitecture, _T(""));
    _tcscpy(ParsedLine.szEnterprise, _T(""));
    _tcscpy(ParsedLine.szErrIfFileNotFound, _T(""));
    _tcscpy(ParsedLine.szMsgBoxBefore, _T(""));
    _tcscpy(ParsedLine.szMsgBoxAfter, _T(""));
    _tcscpy(ParsedLine.szDoNotDisplayErrIfFunctionFailed, _T(""));
    _tcscpy(ParsedLine.szProgressTitle, _T(""));

    // parse the line and put into another big cstring list
    CStringList strListOrderImportant;
    //
    // Parse the long string and put into another list
    //
    LPTSTR      lpBuffer = NULL;
    lpBuffer = (LPTSTR) LocalAlloc(LPTR, (csOneParseableLine.GetLength() + 1) * sizeof(TCHAR) );
    if ( !lpBuffer )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("ProcessEntry_Entry:Failed to allocate memory.")));
        return iReturn;
    }

    _tcscpy(lpBuffer, csOneParseableLine);
    TCHAR *token = NULL;
    token = _tcstok(lpBuffer, _T("|"));
    while (token != NULL)
    {
        strListOrderImportant.AddTail(token);
        token = _tcstok(NULL, _T("|"));
    }
   
    // Loop thru the new list and set variables
    int i = 0;
    int iFoundMatch = FALSE;
    POSITION pos = NULL;
    CString csEntry;
    int iEntryLen = 0;

    pos = strListOrderImportant.GetHeadPosition();
    while (pos) 
    {
        iFoundMatch = FALSE;
        csEntry = strListOrderImportant.GetAt(pos);
        iEntryLen=(csEntry.GetLength() + 1) * sizeof(TCHAR);

        // Look for "100:"
        // 100=Type (1=DllFunction,2=DllFunctionInitOle, 2=Executable, 3=RunThisExe, 4=DoSection, 5=DoINFSection)
        if (csEntry.Left(4) == ThingToDoNumType_100 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szType)) {_tcscpy(ParsedLine.szType, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR,  (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_100,csEntry));}
            
            iFoundMatch = TRUE;
        }

        // 101=File
        if (csEntry.Left(4) == ThingToDoNumType_101 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szFileName)) {_tcscpy(ParsedLine.szFileName, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_101, csEntry));}
            if (-1 != csEntry.Find(_T('<')) )
            {
                // there is a < in the string
                int iWhere = 0;
                CString csValue2;
                csEntry.MakeUpper();
                if (csEntry.Find(_T("<SYSTEMROOT>")) != (-1) )
                {
                    // We Found the cheesy <SYSTEMROOT> deal.  Now replace it with the real SYSTEMROOT
                    iWhere = csEntry.Find(_T("<SYSTEMROOT>"));
                    iWhere = iWhere + _tcslen(_T("<SYSTEMROOT>"));
                    csValue2 = g_pTheApp->m_csWinDir + csEntry.Right( csEntry.GetLength() - (iWhere) );
                    csEntry = csValue2;
                    if (iEntryLen <= sizeof(ParsedLine.szFileName)) {_tcscpy(ParsedLine.szFileName, csEntry);}
                    else {iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("ProcessEntry_Entry:ParseError:%s.1:%1!s! -- entry to big\n"),ThingToDoNumType_101,csEntry));}
                }

                if (csEntry.Find(_T("<SYSTEMDRIVE>")) != (-1) )
                {
                    // We Found the cheesy <SYSTEMDRIVE> deal.  Now replace it with the real systemdrive
                    iWhere = csEntry.Find(_T("<SYSTEMDRIVE>"));
                    iWhere = iWhere + _tcslen(_T("<SYSTEMDRIVE>"));
                    csValue2 = g_pTheApp->m_csSysDrive + csEntry.Right( csEntry.GetLength() - (iWhere) );
                    csEntry = csValue2;
                    if (iEntryLen <= sizeof(ParsedLine.szFileName)) {_tcscpy(ParsedLine.szFileName, csEntry);}
                    else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_101,csEntry));}
                }
            }

            iFoundMatch = TRUE;
        }

        // ThingToDoNumType_102=szData1
        if (csEntry.Left(4) == ThingToDoNumType_102 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szData1)) {_tcscpy(ParsedLine.szData1, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_102,csEntry));}
            iFoundMatch = TRUE;
            if (-1 != csEntry.Find(_T('<')) )
            {
                // there is a < in the string
                int iWhere = 0;
                CString csValue2;
                csEntry.MakeUpper();
                if (csEntry.Find(_T("<SYSTEMROOT>")) != (-1) )
                {
                    // We Found the cheesy <SYSTEMROOT> deal.  Now replace it with the real SYSTEMROOT
                    iWhere = csEntry.Find(_T("<SYSTEMROOT>"));
                    iWhere = iWhere + _tcslen(_T("<SYSTEMROOT>"));
                    csValue2 = g_pTheApp->m_csWinDir + csEntry.Right( csEntry.GetLength() - (iWhere) );
                    csEntry = csValue2;
                    if (iEntryLen <= sizeof(ParsedLine.szData1)) {_tcscpy(ParsedLine.szData1, csEntry);}
                    else {iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("ProcessEntry_Entry:ParseError:%s.1:%1!s! -- entry to big\n"),ThingToDoNumType_102, csEntry));}
                }

                if (csEntry.Find(_T("<SYSTEMDRIVE>")) != (-1) )
                {
                    // We Found the cheesy <SYSTEMDRIVE> deal.  Now replace it with the real SYSTEMROOT
                    iWhere = csEntry.Find(_T("<SYSTEMDRIVE>"));
                    iWhere = iWhere + _tcslen(_T("<SYSTEMDRIVE>"));
                    csValue2 = g_pTheApp->m_csSysDrive + csEntry.Right( csEntry.GetLength() - (iWhere) );
                    csEntry = csValue2;
                    if (iEntryLen <= sizeof(ParsedLine.szData1)) {_tcscpy(ParsedLine.szData1, csEntry);}
                    else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_102,csEntry));}
                }
            }
        }


        // ThingToDoNumType_103=szData2
        if (csEntry.Left(4) == ThingToDoNumType_103 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szData2)) {_tcscpy(ParsedLine.szData2, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_103,csEntry));}
            iFoundMatch = TRUE;
        }
        // ThingToDoNumType_104=szData3
        if (csEntry.Left(4) == ThingToDoNumType_104 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szData3)) {_tcscpy(ParsedLine.szData3, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_104,csEntry));}
            iFoundMatch = TRUE;
        }

        // ThingToDoNumType_105=szData4
        if (csEntry.Left(4) == ThingToDoNumType_105 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szData4)) {_tcscpy(ParsedLine.szData4, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_105,csEntry));}
            iFoundMatch = TRUE;
        }



        // 200=ChangeToThisDirFirst
        if (csEntry.Left(4) == ThingToDoNumType_200 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szChangeDir)) {_tcscpy(ParsedLine.szChangeDir, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_200,csEntry));}
            iFoundMatch = TRUE;

            if (-1 != csEntry.Find(_T('<')) )
            {
                // there is a < in the string
                int iWhere = 0;
                CString csValue2;
                csEntry.MakeUpper();
                if (csEntry.Find(_T("<SYSTEMROOT>")) != (-1) )
                {
                    // We Found the cheesy <SYSTEMROOT> deal.  Now replace it with the real SYSTEMROOT
                    iWhere = csEntry.Find(_T("<SYSTEMROOT>"));
                    iWhere = iWhere + _tcslen(_T("<SYSTEMROOT>"));
                    csValue2 = g_pTheApp->m_csWinDir + csEntry.Right( csEntry.GetLength() - (iWhere) );
                    csEntry = csValue2;
                    if (iEntryLen <= sizeof(ParsedLine.szChangeDir)) {_tcscpy(ParsedLine.szChangeDir, csEntry);}
                    else {iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("ProcessEntry_Entry:ParseError:%s.1:%1!s! -- entry to big\n"),ThingToDoNumType_200,csEntry));}
                }

                if (csEntry.Find(_T("<SYSTEMDRIVE>")) != (-1) )
                {
                    // We Found the cheesy <SYSTEMDRIVE> deal.  Now replace it with the real SYSTEMROOT
                    iWhere = csEntry.Find(_T("<SYSTEMDRIVE>"));
                    iWhere = iWhere + _tcslen(_T("<SYSTEMDRIVE>"));
                    csValue2 = g_pTheApp->m_csSysDrive + csEntry.Right( csEntry.GetLength() - (iWhere) );
                    csEntry = csValue2;
                    if (iEntryLen <= sizeof(ParsedLine.szChangeDir)) {_tcscpy(ParsedLine.szChangeDir, csEntry);}
                    else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_200,csEntry));}
                }
            }

        }

        // 701=OS (0=ALL,1=NTS,2=NTW,4=NTDC)
        if (csEntry.Left(4) == ThingToDoNumType_701 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szOS)) {_tcscpy(ParsedLine.szOS, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_701,csEntry));}
            iFoundMatch = TRUE;
        }

        // 702=PlatformArchitecture (0=ALL,1=x86,2=alpha)
        if (csEntry.Left(4) == ThingToDoNumType_702 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szPlatformArchitecture)) {_tcscpy(ParsedLine.szPlatformArchitecture, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_702,csEntry));}
            iFoundMatch = TRUE;
        }

        // 703=Enterprise (1=yes,0=no)
        if (csEntry.Left(4) == ThingToDoNumType_703 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szEnterprise)) {_tcscpy(ParsedLine.szEnterprise, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_703,csEntry));}
            iFoundMatch = TRUE;
        }

        // 801=ErrIfFileNotFound (1=Show error if filenot found, 0=don't show error)
        if (csEntry.Left(4) == ThingToDoNumType_801 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szErrIfFileNotFound)) {_tcscpy(ParsedLine.szErrIfFileNotFound, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_801,csEntry));}
            iFoundMatch = TRUE;
        }

        // 802=Ask User if they want to call this function with msgbox (1=yes,0=no)
        if (csEntry.Left(4) == ThingToDoNumType_802 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szMsgBoxBefore)) {_tcscpy(ParsedLine.szMsgBoxBefore, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_802,csEntry));}
            iFoundMatch = TRUE;
        }

        // 803=notify use after calling the function (1=yes,0=no)
        if (csEntry.Left(4) == ThingToDoNumType_803 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szMsgBoxAfter)) {_tcscpy(ParsedLine.szMsgBoxAfter, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_803,csEntry));}
            iFoundMatch = TRUE;
        }

        // 804=szDoNotDisplayErrIfFunctionFailed (1= dont Show error , 0=show error)
        if (csEntry.Left(4) == ThingToDoNumType_804 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szDoNotDisplayErrIfFunctionFailed)) {_tcscpy(ParsedLine.szDoNotDisplayErrIfFunctionFailed, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_804,csEntry));}
            iFoundMatch = TRUE;
        }

        // 805=szProgressTitle
        if (csEntry.Left(4) == ThingToDoNumType_805 && iFoundMatch != TRUE)
        {
            csEntry = csEntry.Right( csEntry.GetLength() - 4);
            if (iEntryLen <= sizeof(ParsedLine.szProgressTitle)) {_tcscpy(ParsedLine.szProgressTitle, csEntry);}
            else {iisDebugOutSafeParams((LOG_TYPE_ERROR, (TCHAR *) PARSE_ERROR_ENTRY_TO_BIG,ThingToDoNumType_805,csEntry));}
            iFoundMatch = TRUE;
        }

        if (iFoundMatch != TRUE)
        {
            // We didn't find a match, so output the problem to the logs..
            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("ProcessEntry_Entry():UnknownOption '%1!s!'.  Section=%2!s!..\n"),csEntry, szTheSection));
        }
       
        // Get next value
        strListOrderImportant.GetNext(pos);
        i++;
    }

    iFoundMatch = FALSE;
    /*
    iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("ProcessEntry_Entry:PleaseProcess:type=%1!s!,filename=%2!s!,data=%3!s!,os=%4!s!,plat=%5!s!,errnofile=%6!s!,msgb=%7!s!,msga=%8!s!,noerr=%9!s!\n"),
        ParsedLine.szType,
        ParsedLine.szFileName,
        ParsedLine.szData1,
        ParsedLine.szOS,
        ParsedLine.szPlatformArchitecture,
        ParsedLine.szEnterprise
        ParsedLine.szErrIfFileNotFound,
        ParsedLine.szMsgBoxBefore,
        ParsedLine.szMsgBoxAfter,
        ParsedLine.szDoNotDisplayErrIfFunctionFailed
        ));
    */
    if (i >= 1)
    {
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("...ProcessEntry:100=%1!s!...\n"),ParsedLine.szType));

        // Get the type.
        //
        // 100=Type (1=DllFunction,2=DllFunctionInitOle, 2=Executable, 3=RunThisExe, 4=DoSection, 5=DoINFSection)
        //
        if ( _tcsicmp(ParsedLine.szType, _T("1")) == 0 || _tcsicmp(ParsedLine.szType, _T("2")) == 0 )
        {
            // 100=1=DllFunction,2=DllFunctionInitOle
            // We are doing a call to a function in a DLL.
            iReturnTemp = ProcessEntry_CallDll(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        // 100=7,8,9,10,11,12,13,14
        if ( _tcsicmp(ParsedLine.szType, _T("7")) == 0 || _tcsicmp(ParsedLine.szType, _T("8")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("9")) == 0 || _tcsicmp(ParsedLine.szType, _T("10")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("11")) == 0 || _tcsicmp(ParsedLine.szType, _T("12")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("13")) == 0 || _tcsicmp(ParsedLine.szType, _T("14")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("17")) == 0 || _tcsicmp(ParsedLine.szType, _T("18")) == 0
            )
        {
            iReturnTemp = ProcessEntry_Misc1(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        if ( _tcsicmp(ParsedLine.szType, _T("19")) == 0 || _tcsicmp(ParsedLine.szType, _T("20")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("21")) == 0 || _tcsicmp(ParsedLine.szType, _T("22")) == 0 ||
			_tcsicmp(ParsedLine.szType, _T("23")) == 0 || _tcsicmp(ParsedLine.szType, _T("24")) == 0 ||
			_tcsicmp(ParsedLine.szType, _T("25")) == 0 || _tcsicmp(ParsedLine.szType, _T("26")) == 0 ||
			_tcsicmp(ParsedLine.szType, _T("27")) == 0 || _tcsicmp(ParsedLine.szType, _T("28")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("29")) == 0 || _tcsicmp(ParsedLine.szType, _T("30")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("31")) == 0 || _tcsicmp(ParsedLine.szType, _T("32")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("33")) == 0 || _tcsicmp(ParsedLine.szType, _T("34")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("35")) == 0 || _tcsicmp(ParsedLine.szType, _T("36")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("37")) == 0 || _tcsicmp(ParsedLine.szType, _T("38")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("120")) == 0
            )
        {
            iReturnTemp = ProcessEntry_other(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        if ( _tcsicmp(ParsedLine.szType, _T("39")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("40")) == 0 || _tcsicmp(ParsedLine.szType, _T("41")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("42")) == 0 || _tcsicmp(ParsedLine.szType, _T("43")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("44")) == 0 || _tcsicmp(ParsedLine.szType, _T("45")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("46")) == 0 || _tcsicmp(ParsedLine.szType, _T("47")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("48")) == 0 || _tcsicmp(ParsedLine.szType, _T("49")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("100")) == 0 || _tcsicmp(ParsedLine.szType, _T("119")) == 0 
			 )
        {
            iReturnTemp = ProcessEntry_If(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        if ( _tcsicmp(ParsedLine.szType, _T("50")) == 0 || _tcsicmp(ParsedLine.szType, _T("51")) == 0 ||
            _tcsicmp(ParsedLine.szType, _T("52")) == 0 || _tcsicmp(ParsedLine.szType, _T("53")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("54")) == 0 || _tcsicmp(ParsedLine.szType, _T("55")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("56")) == 0 || _tcsicmp(ParsedLine.szType, _T("57")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("58")) == 0 || _tcsicmp(ParsedLine.szType, _T("59")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("60")) == 0 || _tcsicmp(ParsedLine.szType, _T("61")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("62")) == 0 || _tcsicmp(ParsedLine.szType, _T("63")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("64")) == 0 || _tcsicmp(ParsedLine.szType, _T("65")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("66")) == 0 || _tcsicmp(ParsedLine.szType, _T("67")) == 0  ||
            _tcsicmp(ParsedLine.szType, _T("68")) == 0 || _tcsicmp(ParsedLine.szType, _T("69")) == 0 
            )
        {
            iReturnTemp = ProcessEntry_SVC_Clus(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        if ( _tcsicmp(ParsedLine.szType, _T("70")) == 0 || _tcsicmp(ParsedLine.szType, _T("71")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("72")) == 0 || _tcsicmp(ParsedLine.szType, _T("73")) == 0 ||
			 _tcsicmp(ParsedLine.szType, _T("74")) == 0 || _tcsicmp(ParsedLine.szType, _T("75")) == 0 ||
			 _tcsicmp(ParsedLine.szType, _T("76")) == 0 || _tcsicmp(ParsedLine.szType, _T("77")) == 0
			 )
        {
            iReturnTemp = ProcessEntry_Dcom(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        if ( _tcsicmp(ParsedLine.szType, _T("82")) == 0 || _tcsicmp(ParsedLine.szType, _T("83")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("84")) == 0 || _tcsicmp(ParsedLine.szType, _T("85")) == 0
             )
        {
            iReturnTemp = ProcessEntry_Metabase(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }
        
        if ( _tcsicmp(ParsedLine.szType, _T("15")) == 0 || _tcsicmp(ParsedLine.szType, _T("16")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("78")) == 0 || _tcsicmp(ParsedLine.szType, _T("79")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("80")) == 0 || _tcsicmp(ParsedLine.szType, _T("81")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("86")) == 0 || _tcsicmp(ParsedLine.szType, _T("87")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("88")) == 0 || _tcsicmp(ParsedLine.szType, _T("89")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("90")) == 0 || _tcsicmp(ParsedLine.szType, _T("91")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("92")) == 0 || _tcsicmp(ParsedLine.szType, _T("93")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("94")) == 0 || _tcsicmp(ParsedLine.szType, _T("95")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("96")) == 0 || _tcsicmp(ParsedLine.szType, _T("97")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("98")) == 0 || _tcsicmp(ParsedLine.szType, _T("99")) == 0
             )
        {
            iReturnTemp = ProcessEntry_Misc2(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        if ( _tcsicmp(ParsedLine.szType, _T("101")) == 0 || _tcsicmp(ParsedLine.szType, _T("102")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("103")) == 0 || _tcsicmp(ParsedLine.szType, _T("104")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("105")) == 0 || _tcsicmp(ParsedLine.szType, _T("106")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("107")) == 0 || _tcsicmp(ParsedLine.szType, _T("108")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("109")) == 0 || _tcsicmp(ParsedLine.szType, _T("110")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("111")) == 0 || _tcsicmp(ParsedLine.szType, _T("112")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("113")) == 0 || _tcsicmp(ParsedLine.szType, _T("114")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("115")) == 0 || _tcsicmp(ParsedLine.szType, _T("116")) == 0 ||
             _tcsicmp(ParsedLine.szType, _T("117")) == 0 || _tcsicmp(ParsedLine.szType, _T("118")) == 0
             )
        {
            iReturnTemp = ProcessEntry_Misc3(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        //
        // 100= 3=Executable
        //
        if ( _tcsicmp(ParsedLine.szType, _T("3")) == 0)
        {
            iReturnTemp = ProcessEntry_Call_Exe(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        //
        // 100= 4=Call InternalSectionInIISDll
        //
        if ( _tcsicmp(ParsedLine.szType, _T("4")) == 0)
        {
            
            iReturnTemp = ProcessEntry_Internal_iisdll(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        //
        // 100= 0=DoINFSection queue file ops special
        // 100= 5=DoSection
        // 100= 6=DoINFSection
        //
        if ( _tcsicmp(ParsedLine.szType, _T("0")) == 0 || _tcsicmp(ParsedLine.szType, _T("5")) == 0 || _tcsicmp(ParsedLine.szType, _T("6")) == 0 )
        {
            iReturnTemp = ProcessEntry_Call_Section(csEntry,szTheSection,ParsedLine);
            if (iReturnTemp == FALSE) (iReturn = FALSE);
            iFoundMatch = TRUE;
        }

        if (TRUE != iFoundMatch)
        {
            iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("ProcessEntry_Entry:ExecuteThing:Unknown Type:%1!s! FAILURE.\n"),ParsedLine.szType));
        }
    }

    if (lpBuffer) {LocalFree(lpBuffer);lpBuffer=NULL;}
    return iReturn;
}


int DoesThisSectionExist(IN HINF hFile, IN LPCTSTR szTheSection)
{
    int iReturn = FALSE;

    INFCONTEXT Context;

    // go to the beginning of the section in the INF file
    if (SetupFindFirstLine_Wrapped(hFile, szTheSection, NULL, &Context))
        {iReturn = TRUE;}

    return iReturn;
}


int GetSectionNameToDo(IN HINF hFile, CString & csTheSection)
{
    iisDebugOut_Start1(_T("GetSectionNameToDo"),csTheSection);
    int iReturn = FALSE;

    // Check if this section has other sections which have something else appended to it.
    //
    // for example:
    // csTheSection = iis_www_reg_CreateIISPackage
    //
    // could have:
    // iis_www_reg_CreateIISPackage.UT_NONE
    // iis_www_reg_CreateIISPackage.UT_351
    // iis_www_reg_CreateIISPackage.UT_10
    // iis_www_reg_CreateIISPackage.UT_20
    // iis_www_reg_CreateIISPackage.UT_30
    // iis_www_reg_CreateIISPackage.UT_40
    // iis_www_reg_CreateIISPackage.UT_50
    // iis_www_reg_CreateIISPackage.UT_51
    // iis_www_reg_CreateIISPackage.UT_60
    // iis_www_reg_CreateIISPackage.UT_10_W95.GUIMODE
    //
    // In That case, we only want to do the iis_www_reg_CreateIISPackage.UT_40
    // and not do the iis_www_reg_CreateIISPackage one!
    //
    // Check for other upgrade specific sections...
    // if we find one then do that, otherwise, just do the regular section...
    TCHAR szTheSectionToDo[100];
    TCHAR szTheUT[30];
    _tcscpy(szTheUT,_T("UT_NONE"));
    if (g_pTheApp->m_eUpgradeType == UT_351){_tcscpy(szTheUT,_T("UT_351"));}
    if (g_pTheApp->m_eUpgradeType == UT_10){_tcscpy(szTheUT,_T("UT_10"));}
    if (g_pTheApp->m_eUpgradeType == UT_20){_tcscpy(szTheUT,_T("UT_20"));}
    if (g_pTheApp->m_eUpgradeType == UT_30){_tcscpy(szTheUT,_T("UT_30"));}
    if (g_pTheApp->m_eUpgradeType == UT_40){_tcscpy(szTheUT,_T("UT_40"));}
    if (g_pTheApp->m_eUpgradeType == UT_50){_tcscpy(szTheUT,_T("UT_50"));}
    if (g_pTheApp->m_eUpgradeType == UT_51){_tcscpy(szTheUT,_T("UT_51"));}
    if (g_pTheApp->m_eUpgradeType == UT_60){_tcscpy(szTheUT,_T("UT_60"));}
    if (g_pTheApp->m_eUpgradeType == UT_10_W95){_tcscpy(szTheUT,_T("UT_10_W95"));}

    BOOL bSectionFound = FALSE;
    // If this is an upgrade from win95 then tack that one on...
    if (g_pTheApp->m_bWin95Migration)
    {
        // Check for guimode of this...
        if (g_pTheApp->m_fNTGuiMode)
        {
            _stprintf(szTheSectionToDo,TEXT("%s.%s.MIG95.GUIMODE"),csTheSection,szTheUT);
            if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
        }

        if (bSectionFound == FALSE)
        {
            _stprintf(szTheSectionToDo,TEXT("%s.%s.MIG95"),csTheSection,szTheUT);
            if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
        }
    }

    // check with out the extract mig95 thingy
    if (bSectionFound == FALSE)
    {
        if (g_pTheApp->m_fNTGuiMode)
        {
            _stprintf(szTheSectionToDo,TEXT("%s.%s.GUIMODE"),csTheSection,szTheUT);
            if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
        }

        if (bSectionFound == FALSE)
        {
            _stprintf(szTheSectionToDo,TEXT("%s.%s"),csTheSection,szTheUT);
            if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
        }
    }

    // if we didn't find a specific section, then see if this is an upgrade
    // and if there is upgrade type box.
    if (bSectionFound == FALSE)
    {
        if (_tcsicmp(szTheUT, _T("UT_NONE")) != 0)
        {
            if (TRUE == g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
            {
            if (g_pTheApp->m_fNTGuiMode)
            {
                _stprintf(szTheSectionToDo,TEXT("%s.UT_ANYMETABASEUPGRADE.GUIMODE"),csTheSection);
                if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
            }
            if (bSectionFound == FALSE)
            {
                _stprintf(szTheSectionToDo,TEXT("%s.UT_ANYMETABASEUPGRADE"),csTheSection);
                if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
            }
            }

            if (bSectionFound == FALSE)
            {
            if (g_pTheApp->m_fNTGuiMode)
            {
                _stprintf(szTheSectionToDo,TEXT("%s.UT_ANYUPGRADE.GUIMODE"),csTheSection);
                if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
            }
            if (bSectionFound == FALSE)
            {
                _stprintf(szTheSectionToDo,TEXT("%s.UT_ANYUPGRADE"),csTheSection);
                if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
            }
            }
        }
    }
    // if we didn't find a specific section, then turn the regular one.
    if (bSectionFound == FALSE)
    {
            if (g_pTheApp->m_fNTGuiMode)
            {
                _stprintf(szTheSectionToDo,TEXT("%s.GUIMODE"),csTheSection);
                if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
            }

            if (bSectionFound == FALSE)
            {
                _tcscpy(szTheSectionToDo,csTheSection);
                if (TRUE == DoesThisSectionExist(hFile, szTheSectionToDo)) {bSectionFound = TRUE;}
            }
    }

    if (bSectionFound == FALSE)
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetSectionNameToDo.[%s].Section not found.\n"), csTheSection));
        iReturn = FALSE;
    }
    else
    {
        iReturn = TRUE;
        csTheSection = szTheSectionToDo;
    }

    iisDebugOut_End1(_T("GetSectionNameToDo"),csTheSection);
    return iReturn;
}




int ProcessSection(IN HINF hFile, IN LPCTSTR szTheSection)
{
    int iReturn = FALSE;
    CStringList strList;

    CString csTheSection;
    csTheSection = szTheSection;

    if (GetSectionNameToDo(hFile, csTheSection))
    {
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("ProcessSection.[%s].Start.\n"), csTheSection));
        if (ERROR_SUCCESS == FillStrListWithListOfSections(hFile, strList, csTheSection))
        {
            // loop thru the list returned back
            if (strList.IsEmpty() == FALSE)
            {
                POSITION pos = NULL;
                CString csEntry;

                pos = strList.GetHeadPosition();
                while (pos) 
                {
                    csEntry = strList.GetAt(pos);
                    iReturn = ProcessEntry_Entry(hFile, csTheSection, csEntry);
                    strList.GetNext(pos);
                }
            }
        }
        iisDebugOut_End1(_T("ProcessSection"),csTheSection);

        iReturn = TRUE;
    }

    return iReturn;
}


int iOleInitialize(void)
{
    int iBalanceOLE = FALSE;
    HRESULT hInitRes = NULL;

    iisDebugOut_Start((_T("ole32:OleInitialize")));
    hInitRes = OleInitialize(NULL);
    iisDebugOut_End((_T("ole32:OleInitialize")));
    if ( SUCCEEDED(hInitRes) || hInitRes == RPC_E_CHANGED_MODE ) 
        {
            if ( SUCCEEDED(hInitRes))
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("iOleInitialize: Succeeded: %x.  MakeSure to call OleUninitialize.\n"), hInitRes));
                iBalanceOLE = TRUE;
            }
            else
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("iOleInitialize: Failed 0x%x. RPC_E_CHANGED_MODE\n"), hInitRes));
            }
        }
    else
        {iisDebugOut((LOG_TYPE_ERROR, _T("iOleInitialize: Failed 0x%x.\n"), hInitRes));}

    return iBalanceOLE;
}



void iOleUnInitialize(int iBalanceOLE)
{
    // ----------------------------------------------
    //
    // uninit ole if we need to 
    //
    // ----------------------------------------------
    if (iBalanceOLE)
    {
        iisDebugOut_Start(_T("ole32:OleInitialize"),LOG_TYPE_TRACE_WIN32_API);
        OleUninitialize();
        iisDebugOut_End(_T("ole32:OleInitialize"),LOG_TYPE_TRACE_WIN32_API);
    }
    return;
}

BOOL SetupSetDirectoryId_Wrapper(HINF InfHandle,DWORD Id,LPCTSTR Directory)
{
    TCHAR szTempDir[_MAX_PATH];
    BOOL bTempFlag;

    // default it with something
    _tcscpy(szTempDir,Directory);

    if (_tcscmp(szTempDir, _T("")) != 0)
    {
        // Check if the passed in parameter looks like this:
        // %systemroot%\system32\inetsrv or something like that...
        LPTSTR pch = NULL;
        pch = _tcschr( (LPTSTR) Directory, _T('%'));
        if (pch) 
        {
            if (!ExpandEnvironmentStrings( (LPCTSTR)Directory, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                {_tcscpy(szTempDir,Directory);}
        }

        // Check to see if the old Drive still exists -- it may not because 
        // the user could have added/removed a drive so now c:\winnt is really d:\winnt
        if (!IsFileExist(Directory))
        {
            TCHAR szDrive_only[_MAX_DRIVE];
            TCHAR szPath_only[_MAX_PATH];
            _tsplitpath( Directory, szDrive_only, szPath_only, NULL, NULL);

            // See if that drive exists...
            if (!IsFileExist(szDrive_only))
            {
                // the drive doesn't exist.
                // so replace it with the system drive.
                GetSystemDirectory(szTempDir, _MAX_PATH);
                // Get the DriveOnly
                _tsplitpath(szTempDir, szDrive_only, NULL, NULL, NULL);
                // Assemble the full path with the new drive
                _tcscpy(szTempDir, szDrive_only);
                _tcscat(szTempDir, szPath_only);
                // do some extra debug output so we can see what happend.
                iisDebugOutSafeParams((LOG_TYPE_WARN, _T("%1!s! Not exist.  Instead use %2!s!\n"), Directory, szTempDir));
            }
        }
    }

    iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("%1!d!=%2!s!\n"), Id, szTempDir));
    bTempFlag = SetupSetDirectoryId(InfHandle,Id,szTempDir);

    // check for the alternate .inf file
    if (g_pTheApp->m_hInfHandleAlternate && InfHandle != g_pTheApp->m_hInfHandleAlternate)
    {
        bTempFlag = SetupSetDirectoryId(g_pTheApp->m_hInfHandleAlternate,Id,szTempDir);
    }

    return bTempFlag;
}

BOOL SetupSetStringId_Wrapper(HINF InfHandle,DWORD Id,LPCTSTR TheString)
{
    BOOL bTempFlag;
    iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("%1!d!=%2!s!\n"), Id, TheString));

    bTempFlag = SetupSetDirectoryIdEx(InfHandle,Id,TheString,SETDIRID_NOT_FULL_PATH,0,0);
    // check for the alternate .inf file
    if (g_pTheApp->m_hInfHandleAlternate && InfHandle != g_pTheApp->m_hInfHandleAlternate)
    {
        bTempFlag = SetupSetDirectoryIdEx(g_pTheApp->m_hInfHandleAlternate,Id,TheString,SETDIRID_NOT_FULL_PATH,0,0);
    }

    return bTempFlag;
}




//-------------------------------------------------------------------------------------
HRESULT FTestForOutstandingCoInits(void)
{
    HRESULT hInitRes = ERROR_SUCCESS;

#if defined(UNICODE) || defined(_UNICODE)
    // perform a defensive check
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("TestForOutstandingCoInits:...COINIT_MULTITHREADED\n")));
    hInitRes = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if ( SUCCEEDED(hInitRes) )
    {
        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().Start.")));
        CoUninitialize();
        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().End.")));
    }
    else
    {
        goto FTestForOutstandingCoInits_Exit;
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("TestForOutstandingCoInits:...COINIT_APARTMENTTHREADED\n")));
    hInitRes = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
    if ( SUCCEEDED(hInitRes) )
    {
        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().Start.")));
        CoUninitialize();
        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().End.")));
    }
    else
    {
        goto FTestForOutstandingCoInits_Exit;
    }
#endif

    // it worked out OK
    hInitRes = NOERROR;
    goto FTestForOutstandingCoInits_Exit;
    
FTestForOutstandingCoInits_Exit:
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("TestForOutstandingCoInits:...End. Return=0x%x.\n"), hInitRes));
    return hInitRes;
}


void ReturnStringForMetabaseID(DWORD dwMetabaseID, LPTSTR lpReturnString)
{
    switch (dwMetabaseID) 
    {
        case IIS_MD_SERVER_BASE:
            _tcscpy(lpReturnString, _T("IIS_MD_SERVER_BASE"));
            break;
        case MD_KEY_TYPE:
            _tcscpy(lpReturnString, _T("MD_KEY_TYPE"));
            break;
        case MD_MAX_BANDWIDTH_BLOCKED:
            _tcscpy(lpReturnString, _T("MD_MAX_BANDWIDTH_BLOCKED"));
            break;
        case MD_SERVER_COMMAND:
            _tcscpy(lpReturnString, _T("MD_SERVER_COMMAND"));
            break;
        case MD_CONNECTION_TIMEOUT:
            _tcscpy(lpReturnString, _T("MD_CONNECTION_TIMEOUT"));
            break;
        case MD_MAX_CONNECTIONS:
            _tcscpy(lpReturnString, _T("MD_MAX_CONNECTIONS"));
            break;
        case MD_SERVER_COMMENT:
            _tcscpy(lpReturnString, _T("MD_SERVER_COMMENT"));
            break;
        case MD_SERVER_STATE:
            _tcscpy(lpReturnString, _T("MD_SERVER_STATE"));
            break;
        case MD_SERVER_AUTOSTART:
            _tcscpy(lpReturnString, _T("MD_SERVER_AUTOSTART"));
            break;
        case MD_SERVER_SIZE:
            _tcscpy(lpReturnString, _T("MD_SERVER_SIZE"));
            break;
        case MD_SERVER_LISTEN_BACKLOG:
            _tcscpy(lpReturnString, _T("MD_SERVER_LISTEN_BACKLOG"));
            break;
        case MD_SERVER_LISTEN_TIMEOUT:
            _tcscpy(lpReturnString, _T("MD_SERVER_LISTEN_TIMEOUT"));
            break;
        case MD_DOWNLEVEL_ADMIN_INSTANCE:
            _tcscpy(lpReturnString, _T("MD_DOWNLEVEL_ADMIN_INSTANCE"));
            break;
        case MD_LEVELS_TO_SCAN:
            _tcscpy(lpReturnString, _T("MD_LEVELS_TO_SCAN"));
            break;
        case MD_SERVER_BINDINGS:
            _tcscpy(lpReturnString, _T("MD_SERVER_BINDINGS"));
            break;
        case MD_MAX_ENDPOINT_CONNECTIONS:
            _tcscpy(lpReturnString, _T("MD_MAX_ENDPOINT_CONNECTIONS"));
            break;
        case MD_SERVER_CONFIGURATION_INFO:
            _tcscpy(lpReturnString, _T("MD_SERVER_CONFIGURATION_INFO"));
            break;
        case MD_IISADMIN_EXTENSIONS:
            _tcscpy(lpReturnString, _T("MD_IISADMIN_EXTENSIONS"));
            break;
        case IIS_MD_HTTP_BASE:
            _tcscpy(lpReturnString, _T("IIS_MD_HTTP_BASE"));
            break;
        case MD_SECURE_BINDINGS:
            _tcscpy(lpReturnString, _T("MD_SECURE_BINDINGS"));
            break;
        case MD_FILTER_LOAD_ORDER:
            _tcscpy(lpReturnString, _T("MD_FILTER_LOAD_ORDER"));
            break;
        case MD_FILTER_IMAGE_PATH:
            _tcscpy(lpReturnString, _T("MD_FILTER_IMAGE_PATH"));
            break;
        case MD_FILTER_STATE:
            _tcscpy(lpReturnString, _T("MD_FILTER_STATE"));
            break;
        case MD_FILTER_ENABLED:
            _tcscpy(lpReturnString, _T("MD_FILTER_ENABLED"));
            break;
        case MD_FILTER_FLAGS:
            _tcscpy(lpReturnString, _T("MD_FILTER_FLAGS"));
            break;
        case MD_FILTER_DESCRIPTION:
            _tcscpy(lpReturnString, _T("MD_FILTER_DESCRIPTION"));
            break;
        case MD_ADV_NOTIFY_PWD_EXP_IN_DAYS:
            _tcscpy(lpReturnString, _T("MD_ADV_NOTIFY_PWD_EXP_IN_DAYS"));
            break;
        case MD_ADV_CACHE_TTL:
            _tcscpy(lpReturnString, _T("MD_ADV_CACHE_TTL"));
            break;
        case MD_NET_LOGON_WKS:
            _tcscpy(lpReturnString, _T("MD_NET_LOGON_WKS"));
            break;
        case MD_USE_HOST_NAME:
            _tcscpy(lpReturnString, _T("MD_USE_HOST_NAME"));
            break;
        case MD_AUTH_CHANGE_FLAGS:
            _tcscpy(lpReturnString, _T("MD_AUTH_CHANGE_FLAGS"));
            break;
        case MD_PROCESS_NTCR_IF_LOGGED_ON:
            _tcscpy(lpReturnString, _T("MD_PROCESS_NTCR_IF_LOGGED_ON"));
            break;
        case MD_FRONTPAGE_WEB:
            _tcscpy(lpReturnString, _T("MD_FRONTPAGE_WEB"));
            break;
        case MD_IN_PROCESS_ISAPI_APPS:
            _tcscpy(lpReturnString, _T("MD_IN_PROCESS_ISAPI_APPS"));
            break;
        case MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS:
            _tcscpy(lpReturnString, _T("MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS"));
            break;
        case MD_APP_FRIENDLY_NAME:
            _tcscpy(lpReturnString, _T("MD_APP_FRIENDLY_NAME"));
            break;
        case MD_APP_ROOT:
            _tcscpy(lpReturnString, _T("MD_APP_ROOT"));
            break;
        case MD_APP_ISOLATED:
            _tcscpy(lpReturnString, _T("MD_APP_ISOLATED"));
            break;
        case MD_APP_WAM_CLSID:
            _tcscpy(lpReturnString, _T("MD_APP_WAM_CLSID"));
            break;
        case MD_APP_PACKAGE_ID:
            _tcscpy(lpReturnString, _T("MD_APP_PACKAGE_ID"));
            break;
        case MD_APP_PACKAGE_NAME:
            _tcscpy(lpReturnString, _T("MD_APP_PACKAGE_NAME"));
            break;
        case MD_APP_OOP_RECOVER_LIMIT:
            _tcscpy(lpReturnString, _T("MD_APP_OOP_RECOVER_LIMIT"));
            break;
        case MD_ADMIN_INSTANCE:
            _tcscpy(lpReturnString, _T("MD_ADMIN_INSTANCE"));
            break;
        case MD_NOT_DELETABLE:
            _tcscpy(lpReturnString, _T("MD_NOT_DELETABLE"));
            break;
        case MD_CUSTOM_ERROR_DESC:
            _tcscpy(lpReturnString, _T("MD_CUSTOM_ERROR_DESC"));
            break;
        case MD_CAL_VC_PER_CONNECT:
            _tcscpy(lpReturnString, _T("MD_CAL_VC_PER_CONNECT"));
            break;
        case MD_CAL_AUTH_RESERVE_TIMEOUT:
            _tcscpy(lpReturnString, _T("MD_CAL_AUTH_RESERVE_TIMEOUT"));
            break;
        case MD_CAL_SSL_RESERVE_TIMEOUT:
            _tcscpy(lpReturnString, _T("MD_CAL_SSL_RESERVE_TIMEOUT"));
            break;
        case MD_CAL_W3_ERROR:
            _tcscpy(lpReturnString, _T("MD_CAL_W3_ERROR"));
            break;
        case MD_CPU_CGI_ENABLED:
            _tcscpy(lpReturnString, _T("MD_CPU_CGI_ENABLED"));
            break;
        case MD_CPU_APP_ENABLED:
            _tcscpy(lpReturnString, _T("MD_CPU_APP_ENABLED"));
            break;
        case MD_CPU_LIMITS_ENABLED:
            _tcscpy(lpReturnString, _T("MD_CPU_LIMITS_ENABLED"));
            break;
        case MD_CPU_RESET_INTERVAL:
            _tcscpy(lpReturnString, _T("MD_CPU_RESET_INTERVAL"));
            break;
        case MD_CPU_LOGGING_INTERVAL:
            _tcscpy(lpReturnString, _T("MD_CPU_LOGGING_INTERVAL"));
            break;
        case MD_CPU_LOGGING_OPTIONS:
            _tcscpy(lpReturnString, _T("MD_CPU_LOGGING_OPTIONS"));
            break;
        case MD_CPU_CGI_LIMIT:
            _tcscpy(lpReturnString, _T("MD_CPU_CGI_LIMIT"));
            break;
        case MD_CPU_LIMIT_LOGEVENT:
            _tcscpy(lpReturnString, _T("MD_CPU_LIMIT_LOGEVENT"));
            break;
        case MD_CPU_LIMIT_PRIORITY:
            _tcscpy(lpReturnString, _T("MD_CPU_LIMIT_PRIORITY"));
            break;
        case MD_CPU_LIMIT_PROCSTOP:
            _tcscpy(lpReturnString, _T("MD_CPU_LIMIT_PROCSTOP"));
            break;
        case MD_CPU_LIMIT_PAUSE:
            _tcscpy(lpReturnString, _T("MD_CPU_LIMIT_PAUSE"));
            break;
        case MD_MD_SERVER_SS_AUTH_MAPPING:
            _tcscpy(lpReturnString, _T("MD_MD_SERVER_SS_AUTH_MAPPING"));
            break;
        case MD_HC_COMPRESSION_DIRECTORY:
            _tcscpy(lpReturnString, _T("MD_HC_COMPRESSION_DIRECTORY"));
            break;
        case MD_HC_CACHE_CONTROL_HEADER:
            _tcscpy(lpReturnString, _T("MD_HC_CACHE_CONTROL_HEADER"));
            break;
        case MD_HC_EXPIRES_HEADER:
            _tcscpy(lpReturnString, _T("MD_HC_EXPIRES_HEADER"));
            break;
        case MD_HC_DO_DYNAMIC_COMPRESSION:
            _tcscpy(lpReturnString, _T("MD_HC_DO_DYNAMIC_COMPRESSION"));
            break;
        case MD_HC_DO_STATIC_COMPRESSION:
            _tcscpy(lpReturnString, _T("MD_HC_DO_STATIC_COMPRESSION"));
            break;
        case MD_HC_DO_ON_DEMAND_COMPRESSION:
            _tcscpy(lpReturnString, _T("MD_HC_DO_ON_DEMAND_COMPRESSION"));
            break;
        case MD_HC_DO_DISK_SPACE_LIMITING:
            _tcscpy(lpReturnString, _T("MD_HC_DO_DISK_SPACE_LIMITING"));
            break;
        case MD_HC_NO_COMPRESSION_FOR_HTTP_10:
            _tcscpy(lpReturnString, _T("MD_HC_NO_COMPRESSION_FOR_HTTP_10"));
            break;
        case MD_HC_NO_COMPRESSION_FOR_PROXIES:   
            _tcscpy(lpReturnString, _T("MD_HC_NO_COMPRESSION_FOR_PROXIES"));
            break;
        case MD_HC_NO_COMPRESSION_FOR_RANGE:     
            _tcscpy(lpReturnString, _T("MD_HC_NO_COMPRESSION_FOR_RANGE"));
            break;
        case MD_HC_SEND_CACHE_HEADERS:           
            _tcscpy(lpReturnString, _T("MD_HC_SEND_CACHE_HEADERS"));
            break;
        case MD_HC_MAX_DISK_SPACE_USAGE:         
            _tcscpy(lpReturnString, _T("MD_HC_MAX_DISK_SPACE_USAGE"));
            break;
        case MD_HC_IO_BUFFER_SIZE:               
            _tcscpy(lpReturnString, _T("MD_HC_IO_BUFFER_SIZE"));
            break;
        case MD_HC_COMPRESSION_BUFFER_SIZE:
            _tcscpy(lpReturnString, _T("MD_HC_COMPRESSION_BUFFER_SIZE"));
            break;
        case MD_HC_MAX_QUEUE_LENGTH:
            _tcscpy(lpReturnString, _T("MD_HC_MAX_QUEUE_LENGTH"));
            break;
        case MD_HC_FILES_DELETED_PER_DISK_FREE:  
            _tcscpy(lpReturnString, _T("MD_HC_FILES_DELETED_PER_DISK_FREE"));
            break;
        case MD_HC_MIN_FILE_SIZE_FOR_COMP:       
            _tcscpy(lpReturnString, _T("MD_HC_MIN_FILE_SIZE_FOR_COMP"));
            break;
        case MD_HC_COMPRESSION_DLL:              
            _tcscpy(lpReturnString, _T("MD_HC_COMPRESSION_DLL"));
            break;
        case MD_HC_FILE_EXTENSIONS:              
            _tcscpy(lpReturnString, _T("MD_HC_FILE_EXTENSIONS"));
            break;
        case MD_HC_MIME_TYPE:                    
            _tcscpy(lpReturnString, _T("MD_HC_MIME_TYPE"));
            break;
        case MD_HC_PRIORITY:                     
            _tcscpy(lpReturnString, _T("MD_HC_PRIORITY"));
            break;
        case MD_HC_DYNAMIC_COMPRESSION_LEVEL:    
            _tcscpy(lpReturnString, _T("MD_HC_DYNAMIC_COMPRESSION_LEVEL"));
            break;
        case MD_HC_ON_DEMAND_COMP_LEVEL:         
            _tcscpy(lpReturnString, _T("MD_HC_ON_DEMAND_COMP_LEVEL"));
            break;
        case MD_HC_CREATE_FLAGS:                 
            _tcscpy(lpReturnString, _T("MD_HC_CREATE_FLAGS"));
            break;
        case MD_WIN32_ERROR:                  
            _tcscpy(lpReturnString, _T("MD_WIN32_ERROR"));
            break;
        case IIS_MD_VR_BASE:                  
            _tcscpy(lpReturnString, _T("IIS_MD_VR_BASE"));
            break;
        case MD_VR_PATH:                      
            _tcscpy(lpReturnString, _T("MD_VR_PATH"));
            break;
        case MD_VR_USERNAME:                  
            _tcscpy(lpReturnString, _T("MD_VR_USERNAME"));
            break;
        case MD_VR_PASSWORD:                  
            _tcscpy(lpReturnString, _T("MD_VR_PASSWORD"));
            break;
        case MD_VR_PASSTHROUGH:               
            _tcscpy(lpReturnString, _T("MD_VR_PASSTHROUGH"));
            break;
        case MD_LOG_TYPE:                     
            _tcscpy(lpReturnString, _T("MD_LOG_TYPE"));
            break;
        case MD_LOGFILE_DIRECTORY:            
            _tcscpy(lpReturnString, _T("MD_LOGFILE_DIRECTORY"));
            break;
        case MD_LOG_UNUSED1:                  
            _tcscpy(lpReturnString, _T("MD_LOG_UNUSED1"));
            break;
        case MD_LOGFILE_PERIOD:               
            _tcscpy(lpReturnString, _T("MD_LOGFILE_PERIOD"));
            break;
        case MD_LOGFILE_TRUNCATE_SIZE:        
            _tcscpy(lpReturnString, _T("MD_LOGFILE_TRUNCATE_SIZE"));
            break;
        case MD_LOG_PLUGIN_MOD_ID:            
            _tcscpy(lpReturnString, _T("MD_LOG_PLUGIN_MOD_ID"));
            break;
        case MD_LOG_PLUGIN_UI_ID:             
            _tcscpy(lpReturnString, _T("MD_LOG_PLUGIN_UI_ID"));
            break;
        case MD_LOGSQL_DATA_SOURCES:          
            _tcscpy(lpReturnString, _T("MD_LOGSQL_DATA_SOURCES"));
            break;
        case MD_LOGSQL_TABLE_NAME:            
            _tcscpy(lpReturnString, _T("MD_LOGSQL_TABLE_NAME"));
            break;
        case MD_LOGSQL_USER_NAME:             
            _tcscpy(lpReturnString, _T("MD_LOGSQL_USER_NAME"));
            break;
        case MD_LOGSQL_PASSWORD:              
            _tcscpy(lpReturnString, _T("MD_LOGSQL_PASSWORD"));
            break;
        case MD_LOG_PLUGIN_ORDER:             
            _tcscpy(lpReturnString, _T("MD_LOG_PLUGIN_ORDER"));
            break;
        case MD_LOG_PLUGINS_AVAILABLE:        
            _tcscpy(lpReturnString, _T("MD_LOG_PLUGINS_AVAILABLE"));
            break;
        case MD_LOGEXT_FIELD_MASK:            
            _tcscpy(lpReturnString, _T("MD_LOGEXT_FIELD_MASK"));
            break;
        case MD_LOGEXT_FIELD_MASK2:           
            _tcscpy(lpReturnString, _T("MD_LOGEXT_FIELD_MASK2"));
            break;
        case MD_LOGFILE_LOCALTIME_ROLLOVER:   
            _tcscpy(lpReturnString, _T("MD_LOGFILE_LOCALTIME_ROLLOVER"));
            break;
        case IIS_MD_LOGCUSTOM_BASE:           
            _tcscpy(lpReturnString, _T("IIS_MD_LOGCUSTOM_BASE"));
            break;
        case MD_LOGCUSTOM_PROPERTY_NAME:      
            _tcscpy(lpReturnString, _T("MD_LOGCUSTOM_PROPERTY_NAME"));
            break;
        case MD_LOGCUSTOM_PROPERTY_HEADER:    
            _tcscpy(lpReturnString, _T("MD_LOGCUSTOM_PROPERTY_HEADER"));
            break;
        case MD_LOGCUSTOM_PROPERTY_ID:        
            _tcscpy(lpReturnString, _T("MD_LOGCUSTOM_PROPERTY_ID"));
            break;
        case MD_LOGCUSTOM_PROPERTY_MASK:      
            _tcscpy(lpReturnString, _T("MD_LOGCUSTOM_PROPERTY_MASK"));
            break;
        case MD_LOGCUSTOM_PROPERTY_DATATYPE:  
            _tcscpy(lpReturnString, _T("MD_LOGCUSTOM_PROPERTY_DATATYPE"));
            break;
        case MD_LOGCUSTOM_SERVICES_STRING:    
            _tcscpy(lpReturnString, _T("MD_LOGCUSTOM_SERVICES_STRING"));
            break;
        case MD_CPU_LOGGING_MASK:             
            _tcscpy(lpReturnString, _T("MD_CPU_LOGGING_MASK"));
            break;
        case IIS_MD_FTP_BASE:                 
            _tcscpy(lpReturnString, _T("IIS_MD_FTP_BASE"));
            break;
        case MD_EXIT_MESSAGE:                 
            _tcscpy(lpReturnString, _T("MD_EXIT_MESSAGE"));
            break;
        case MD_GREETING_MESSAGE:             
            _tcscpy(lpReturnString, _T("MD_GREETING_MESSAGE"));
            break;
        case MD_MAX_CLIENTS_MESSAGE:          
            _tcscpy(lpReturnString, _T("MD_MAX_CLIENTS_MESSAGE"));
            break;
        case MD_MSDOS_DIR_OUTPUT:             
            _tcscpy(lpReturnString, _T("MD_MSDOS_DIR_OUTPUT"));
            break;
        case MD_ALLOW_ANONYMOUS:              
            _tcscpy(lpReturnString, _T("MD_ALLOW_ANONYMOUS"));
            break;
        case MD_ANONYMOUS_ONLY:               
            _tcscpy(lpReturnString, _T("MD_ANONYMOUS_ONLY"));
            break;
        case MD_LOG_ANONYMOUS:                
            _tcscpy(lpReturnString, _T("MD_LOG_ANONYMOUS"));
            break;
        case MD_LOG_NONANONYMOUS:             
            _tcscpy(lpReturnString, _T("MD_LOG_NONANONYMOUS"));
            break;
        case MD_ALLOW_REPLACE_ON_RENAME:
            _tcscpy(lpReturnString, _T("MD_ALLOW_REPLACE_ON_RENAME"));
            break;
        case MD_SSL_PUBLIC_KEY:
            _tcscpy(lpReturnString, _T("MD_SSL_PUBLIC_KEY"));
            break;
        case MD_SSL_PRIVATE_KEY:
            _tcscpy(lpReturnString, _T("MD_SSL_PRIVATE_KEY"));
            break;
        case MD_SSL_KEY_PASSWORD:
            _tcscpy(lpReturnString, _T("MD_SSL_KEY_PASSWORD"));
            break;
        case MD_SSL_KEY_REQUEST:
            _tcscpy(lpReturnString, _T("MD_SSL_KEY_REQUEST"));
            break;
        case MD_AUTHORIZATION:
            _tcscpy(lpReturnString, _T("MD_AUTHORIZATION"));
            break;
        case MD_REALM:
            _tcscpy(lpReturnString, _T("MD_REALM"));
            break;
        case MD_HTTP_EXPIRES:
            _tcscpy(lpReturnString, _T("MD_HTTP_EXPIRES"));
            break;
        case MD_HTTP_PICS:
            _tcscpy(lpReturnString, _T("MD_HTTP_PICS"));
            break;
        case MD_HTTP_CUSTOM:
            _tcscpy(lpReturnString, _T("MD_HTTP_CUSTOM"));
            break;
        case MD_DIRECTORY_BROWSING:
            _tcscpy(lpReturnString, _T("MD_DIRECTORY_BROWSING"));
            break;
        case MD_DEFAULT_LOAD_FILE:
            _tcscpy(lpReturnString, _T("MD_DEFAULT_LOAD_FILE"));
            break;
        case MD_CUSTOM_ERROR:
            _tcscpy(lpReturnString, _T("MD_CUSTOM_ERROR"));
            break;
        case MD_FOOTER_DOCUMENT:
            _tcscpy(lpReturnString, _T("MD_FOOTER_DOCUMENT"));
            break;
        case MD_FOOTER_ENABLED:
            _tcscpy(lpReturnString, _T("MD_FOOTER_ENABLED"));
            break;
        case MD_HTTP_REDIRECT:
            _tcscpy(lpReturnString, _T("MD_HTTP_REDIRECT"));
            break;
        case MD_DEFAULT_LOGON_DOMAIN:
            _tcscpy(lpReturnString, _T("MD_DEFAULT_LOGON_DOMAIN"));
            break;
        case MD_LOGON_METHOD:
            _tcscpy(lpReturnString, _T("MD_LOGON_METHOD"));
            break;
        case MD_SCRIPT_MAPS:
            _tcscpy(lpReturnString, _T("MD_SCRIPT_MAPS"));
            break;
        case MD_MIME_MAP:
            _tcscpy(lpReturnString, _T("MD_MIME_MAP"));
            break;
        case MD_ACCESS_PERM:
            _tcscpy(lpReturnString, _T("MD_ACCESS_PERM"));
            break;
        case MD_IP_SEC:
            _tcscpy(lpReturnString, _T("MD_IP_SEC"));
            break;
        case MD_ANONYMOUS_USER_NAME:
            _tcscpy(lpReturnString, _T("MD_ANONYMOUS_USER_NAME"));
            break;
        case MD_ANONYMOUS_PWD:
            _tcscpy(lpReturnString, _T("MD_ANONYMOUS_PWD"));
            break;
        case MD_ANONYMOUS_USE_SUBAUTH:
            _tcscpy(lpReturnString, _T("MD_ANONYMOUS_USE_SUBAUTH"));
            break;
        case MD_DONT_LOG:
            _tcscpy(lpReturnString, _T("MD_DONT_LOG"));
            break;
        case MD_ADMIN_ACL:
            _tcscpy(lpReturnString, _T("MD_ADMIN_ACL"));
            break;
        case MD_SSI_EXEC_DISABLED:
            _tcscpy(lpReturnString, _T("MD_SSI_EXEC_DISABLED"));
            break;
        case MD_DO_REVERSE_DNS:
            _tcscpy(lpReturnString, _T("MD_DO_REVERSE_DNS"));
            break;
        case MD_SSL_ACCESS_PERM:
            _tcscpy(lpReturnString, _T("MD_SSL_ACCESS_PERM"));
            break;
        case MD_AUTHORIZATION_PERSISTENCE:
            _tcscpy(lpReturnString, _T("MD_AUTHORIZATION_PERSISTENCE"));
            break;
        case MD_NTAUTHENTICATION_PROVIDERS:
            _tcscpy(lpReturnString, _T("MD_NTAUTHENTICATION_PROVIDERS"));
            break;
        case MD_SCRIPT_TIMEOUT:
            _tcscpy(lpReturnString, _T("MD_SCRIPT_TIMEOUT"));
            break;
        case MD_CACHE_EXTENSIONS:
            _tcscpy(lpReturnString, _T("MD_CACHE_EXTENSIONS"));
            break;
        case MD_CREATE_PROCESS_AS_USER:
            _tcscpy(lpReturnString, _T("MD_CREATE_PROCESS_AS_USER"));
            break;
        case MD_CREATE_PROC_NEW_CONSOLE:
            _tcscpy(lpReturnString, _T("MD_CREATE_PROC_NEW_CONSOLE"));
            break;
        case MD_POOL_IDC_TIMEOUT:
            _tcscpy(lpReturnString, _T("MD_POOL_IDC_TIMEOUT"));
            break;
        case MD_ALLOW_KEEPALIVES:
            _tcscpy(lpReturnString, _T("MD_ALLOW_KEEPALIVES"));
            break;
        case MD_IS_CONTENT_INDEXED:
            _tcscpy(lpReturnString, _T("MD_IS_CONTENT_INDEXED"));
            break;
        case MD_CC_NO_CACHE:
            _tcscpy(lpReturnString, _T("MD_CC_NO_CACHE"));
            break;
        case MD_CC_MAX_AGE:
            _tcscpy(lpReturnString, _T("MD_CC_MAX_AGE"));
            break;
        case MD_CC_OTHER:
            _tcscpy(lpReturnString, _T("MD_CC_OTHER"));
            break;
        case MD_REDIRECT_HEADERS:
            _tcscpy(lpReturnString, _T("MD_REDIRECT_HEADERS"));
            break;
        case MD_UPLOAD_READAHEAD_SIZE:
            _tcscpy(lpReturnString, _T("MD_UPLOAD_READAHEAD_SIZE"));
            break;
        case MD_PUT_READ_SIZE:
            _tcscpy(lpReturnString, _T("MD_PUT_READ_SIZE"));
            break;
        case MD_WAM_USER_NAME:
            _tcscpy(lpReturnString, _T("MD_WAM_USER_NAME"));
            break;
        case MD_WAM_PWD:
            _tcscpy(lpReturnString, _T("MD_WAM_PWD"));
            break;
        case MD_SCHEMA_METAID:
            _tcscpy(lpReturnString, _T("MD_SCHEMA_METAID"));
            break;
        case MD_DISABLE_SOCKET_POOLING:
            _tcscpy(lpReturnString, _T("MD_DISABLE_SOCKET_POOLING"));
            break;
        case MD_METADATA_ID_REGISTRATION:
            _tcscpy(lpReturnString, _T("MD_METADATA_ID_REGISTRATION"));
            break;
        case MD_CPU_ENABLE_LOGGING:
            _tcscpy(lpReturnString, _T("MD_CPU_ENABLE_LOGGING"));
            break;
        case MD_HC_SCRIPT_FILE_EXTENSIONS:
            _tcscpy(lpReturnString, _T("MD_HC_SCRIPT_FILE_EXTENSIONS"));
            break;
        case MD_SHOW_4_DIGIT_YEAR:
            _tcscpy(lpReturnString, _T("MD_SHOW_4_DIGIT_YEAR"));
            break;
        case MD_SSL_USE_DS_MAPPER:
            _tcscpy(lpReturnString, _T("MD_SSL_USE_DS_MAPPER"));
            break;
        case MD_FILTER_ENABLE_CACHE:
            _tcscpy(lpReturnString, _T("MD_FILTER_ENABLE_CACHE"));
            break;
        case MD_USE_DIGEST_SSP:
            _tcscpy(lpReturnString, _T("MD_USE_DIGEST_SSP"));
            break;
        case MD_APPPOOL_PERIODIC_RESTART_TIME:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_PERIODIC_RESTART_TIME"));
            break;
        case MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT"));
            break;
        case MD_APPPOOL_MAX_PROCESS_COUNT:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_MAX_PROCESS_COUNT"));
            break;
        case MD_APPPOOL_PINGING_ENABLED:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_PINGING_ENABLED"));
            break;
        case MD_APPPOOL_IDLE_TIMEOUT:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_IDLE_TIMEOUT"));
            break;
        case MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_RAPID_F_PROTECTION_ENABLED"));
            break;
        case MD_APPPOOL_SMP_AFFINITIZED:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_SMP_AFFINITIZED"));
            break;
        case MD_APPPOOL_SMP_AFFINITIZED_PROCESSOR_MASK:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_SMP_AFFINITIZED_PROCESSOR_MASK"));
            break;
        case MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING"));
            break;
        case MD_APPPOOL_RUN_AS_LOCALSYSTEM:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_RUN_AS_LOCALSYSTEM"));
            break;
        case MD_APPPOOL_STARTUP_TIMELIMIT:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_STARTUP_TIMELIMIT"));
            break;
        case MD_APPPOOL_SHUTDOWN_TIMELIMIT:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_SHUTDOWN_TIMELIMIT"));
            break;
        case MD_APPPOOL_PING_INTERVAL:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_PING_INTERVAL"));
            break;
        case MD_APPPOOL_PING_RESPONSE_TIMELIMIT:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_PING_RESPONSE_TIMELIMIT"));
            break;
        case MD_APPPOOL_DISALLOW_OVERLAPPING_ROTATION:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_DISALLOW_OVERLAPPING_ROTATION"));
            break;
        case MD_APPPOOL_ORPHAN_ACTION:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_ORPHAN_ACTION"));
            break;
        case MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH"));
            break;
        case MD_APPPOOL_DISALLOW_ROTATION_ON_CONFIG_CHANGE:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_DISALLOW_ROTATION_ON_CONFIG_CHANGE"));
            break;
        case MD_APPPOOL_FRIENDLY_NAME:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_FRIENDLY_NAME"));
            break;
        case MD_APPPOOL_PERIODIC_RESTART_SCHEDULE:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_PERIODIC_RESTART_SCHEDULE"));
            break;
        case MD_APPPOOL_IDENTITY_TYPE:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_IDENTITY_TYPE"));
            break;
        case MD_CPU_ACTION:
            _tcscpy(lpReturnString, _T("MD_CPU_ACTION"));
            break;
        case MD_CPU_LIMIT:
            _tcscpy(lpReturnString, _T("MD_CPU_LIMIT"));
            break;
        case MD_APPPOOL_PERIODIC_RESTART_MEMORY:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_PERIODIC_RESTART_MEMORY"));
            break;
        case MD_DISABLE_PUBLISHING:
            _tcscpy(lpReturnString, _T("MD_DISABLE_PUBLISHING"));
            break;
        case MD_APP_APPPOOL_ID:
            _tcscpy(lpReturnString, _T("MD_APP_APPPOOL_ID"));
            break;
        case MD_APP_ALLOW_TRANSIENT_REGISTRATION:
            _tcscpy(lpReturnString, _T("MD_APP_ALLOW_TRANSIENT_REGISTRATION"));
            break;
        case MD_APP_AUTO_START:
            _tcscpy(lpReturnString, _T("MD_APP_AUTO_START"));
            break;
        case MD_APPPOOL_PERIODIC_RESTART_CONNECTIONS:
            _tcscpy(lpReturnString, _T("MD_APPPOOL_PERIODIC_RESTART_CONNECTIONS"));
            break;
        case MD_MAX_GLOBAL_BANDWIDTH:
            _tcscpy(lpReturnString, _T("MD_MAX_GLOBAL_BANDWIDTH"));
            break;
        case MD_MAX_GLOBAL_CONNECTIONS:
            _tcscpy(lpReturnString, _T("MD_MAX_GLOBAL_CONNECTIONS"));
            break;
        case MD_GLOBAL_STANDARD_APP_MODE_ENABLED:
            _tcscpy(lpReturnString, _T("MD_GLOBAL_STANDARD_APP_MODE_ENABLED"));
            break;
        case MD_HEADER_WAIT_TIMEOUT:
            _tcscpy(lpReturnString, _T("MD_HEADER_WAIT_TIMEOUT"));
            break;
        case MD_MIN_FILE_KB_SEC:
            _tcscpy(lpReturnString, _T("MD_MIN_FILE_KB_SEC"));
            break;
        case MD_GLOBAL_LOG_IN_UTF_8:
            _tcscpy(lpReturnString, _T("MD_GLOBAL_LOG_IN_UTF_8"));
            break;
        case MD_ASP_ENABLEPARENTPATHS:
            _tcscpy(lpReturnString, _T("MD_ASP_ENABLEPARENTPATHS"));
            break;
        case ASP_MD_SERVER_BASE:
        case MD_ASP_LOGERRORREQUESTS:
        case MD_ASP_SCRIPTERRORSSENTTOBROWSER:
        case MD_ASP_SCRIPTERRORMESSAGE:
        case MD_ASP_SCRIPTFILECACHESIZE:
        case MD_ASP_SCRIPTENGINECACHEMAX:
        case MD_ASP_SCRIPTTIMEOUT:
        case MD_ASP_SESSIONTIMEOUT:
        case MD_ASP_MEMFREEFACTOR:
        case MD_ASP_MINUSEDBLOCKS:
        case MD_ASP_ALLOWSESSIONSTATE:
        case MD_ASP_SCRIPTLANGUAGE:
        case MD_ASP_QUEUETIMEOUT:
        case MD_ASP_ALLOWOUTOFPROCCOMPONENTS:
        case MD_ASP_EXCEPTIONCATCHENABLE:
        case MD_ASP_CODEPAGE:
        case MD_ASP_SCRIPTLANGUAGELIST:
        case MD_ASP_ENABLESERVERDEBUG:
        case MD_ASP_ENABLECLIENTDEBUG:
        case MD_ASP_TRACKTHREADINGMODEL:
        case MD_ASP_ENABLEASPHTMLFALLBACK:
        case MD_ASP_ENABLECHUNKEDENCODING:
        case MD_ASP_ENABLETYPELIBCACHE:
        case MD_ASP_ERRORSTONTLOG:
        case MD_ASP_PROCESSORTHREADMAX:
        case MD_ASP_REQEUSTQUEUEMAX:
        case MD_ASP_ENABLEAPPLICATIONRESTART:
        case MD_ASP_QUEUECONNECTIONTESTTIME:
        case MD_ASP_SESSIONMAX:
        case MD_ASP_THREADGATEENABLED:
        case MD_ASP_THREADGATETIMESLICE:
        case MD_ASP_THREADGATESLEEPDELAY:
        case MD_ASP_THREADGATESLEEPMAX:
        case MD_ASP_THREADGATELOADLOW:
        case MD_ASP_THREADGATELOADHIGH:
            _tcscpy(lpReturnString, _T("MD_ASP_????"));
            break;
        case WAM_MD_SERVER_BASE:
            _tcscpy(lpReturnString, _T("WAM_MD_SERVER_BASE"));
            break;
        default:
            _stprintf(lpReturnString, _T("%d"), dwMetabaseID);
            break;
    }
    return;
}

void SetErrorFlag(char *szFileName, int iLineNumber)
{
    // set flag to say that there was an error!!!
    g_pTheApp->m_bThereWereErrorsChkLogfile = TRUE;
    return;
}



DWORD FillStrListWithListOfSections(IN HINF hFile, CStringList &strList, IN LPCTSTR szSection)
{
    DWORD dwReturn = ERROR_SUCCESS;
    LPTSTR  szLine = NULL;
    DWORD   dwRequiredSize;
    BOOL    b = FALSE;
    INFCONTEXT Context;

    // go to the beginning of the section in the INF file
    b = SetupFindFirstLine_Wrapped(hFile, szSection, NULL, &Context);
    if (!b)
        {
        dwReturn = E_FAIL;
        goto FillStrListWithListOfSections_Exit;
        }

    // loop through the items in the section.
    while (b) 
    {
        // get the size of the memory we need for this
        b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);

        // prepare the buffer to receive the line
        szLine = (LPTSTR)GlobalAlloc( GPTR, dwRequiredSize * sizeof(TCHAR) );
        if ( !szLine )
            {
            iisDebugOut((LOG_TYPE_ERROR, _T("FillStrListWithListOfSections %s. Failed on GlobalAlloc.\n"), szSection));
            goto FillStrListWithListOfSections_Exit;
            }
        
        // get the line from the inf file1
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL) == FALSE)
            {
            iisDebugOut((LOG_TYPE_ERROR, _T("FillStrListWithListOfSections %s. Failed on SetupGetLineText.\n"), szSection));
            goto FillStrListWithListOfSections_Exit;
            }

        // Add it to the list
        strList.AddTail(szLine);

        // find the next line in the section. If there is no next line it should return false
        b = SetupFindNextLine(&Context, &Context);

        // free the temporary buffer
        GlobalFree( szLine );
        szLine = NULL;
    }
    if (szLine) {GlobalFree(szLine);szLine=NULL;}
    
FillStrListWithListOfSections_Exit:
    return dwReturn;
}


void DisplayStringForMetabaseID(DWORD dwMetabaseID)
{
    TCHAR lpReturnString[50];
    ReturnStringForMetabaseID(dwMetabaseID, lpReturnString);
    iisDebugOut((LOG_TYPE_TRACE, _T("%d=%s\n"), dwMetabaseID, lpReturnString));
    return;
}


DWORD WINAPI MessageBoxFreeThread_MTS(LPVOID p)
{
    HRESULT nNetErr = (HRESULT) gTempMTSError.dwErrorCode;
    TCHAR pMsg[_MAX_PATH] = _T("");
    DWORD dwFormatReturn = 0;
    dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,NULL, gTempMTSError.dwErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
    if ( dwFormatReturn == 0) 
    {
        if (nNetErr >= NERR_BASE) 
		{
            HMODULE hDll = (HMODULE)LoadLibrary(_T("netmsg.dll"));
            if (hDll) 
			{
                dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,hDll, gTempMTSError.dwErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
                FreeLibrary(hDll);
            }
        }
    }

    CString csErrorString;
    MyLoadString(IDS_SETUP_ERRORS_ENCOUNTERED_MTS, csErrorString);

    CString csErrArea;
    MyLoadString(gTempMTSError.iMtsThingWeWereDoing, csErrArea);

    CString csTitle;
    MyLoadString(IDS_MTS_ERROR_TITLEBAR, csTitle);

    CString csMsg;
    csMsg.Format(csErrorString, csErrArea);

    CString csErrMsg;
    HandleSpecificErrors(gTempMTSError.dwErrorCode, dwFormatReturn, csMsg, pMsg, &csErrMsg);

    MyMessageBox(NULL, csErrMsg, csTitle, MB_OK | MB_SETFOREGROUND);

	return 0;
}


DWORD WINAPI MessageBoxFreeThread_IIS(PVOID p)
{
    INT_PTR iStringID = (INT_PTR) p;
    MyMessageBox(NULL, (UINT) iStringID, g_MyLogFile.m_szLogFileName_Full, MB_OK | MB_SETFOREGROUND);
	return 0;
}

void MesssageBoxErrors_IIS(void)
{
    if (g_pTheApp->m_bThereWereErrorsChkLogfile == TRUE)
    {
        int iSaveOld_AllowMessageBoxPopups = g_pTheApp->m_bAllowMessageBoxPopups;

        g_pTheApp->m_bAllowMessageBoxPopups = TRUE;

        DWORD   id;
        INT_PTR iStringID = IDS_SETUP_ERRORS_ENCOUNTERED;

        // show the messagebox display from another thread, so that setup can continue!
        HANDLE  hProc = NULL;
        hProc = CreateThread(NULL, 0, MessageBoxFreeThread_IIS, (PVOID) iStringID, 0, &id);
        g_pTheApp->m_bAllowMessageBoxPopups = iSaveOld_AllowMessageBoxPopups;

        CString csErrMsg;
        TCHAR szErrorString[255];
        MyLoadString(IDS_SETUP_ERRORS_ENCOUNTERED, csErrMsg);
        _stprintf(szErrorString, csErrMsg, g_MyLogFile.m_szLogFileName_Full);

        //LogSevInformation           0x00000000
        //LogSevWarning               0x00000001
        //LogSevError                 0x00000002
        //LogSevFatalError            0x00000003
        //LogSevMaximum               0x00000004
        // Write it to the setupapi log file!
        SetupLogError(szErrorString, LogSevError);
    }
    return;
}


void MesssageBoxErrors_MTS(int iMtsThingWeWereDoing, DWORD dwErrorCode)
{
    if (!g_pTheApp->m_bThereWereErrorsFromMTS)
    {
        DWORD   id;
        int iSaveOld_AllowMessageBoxPopups = g_pTheApp->m_bAllowMessageBoxPopups;

        gTempMTSError.iMtsThingWeWereDoing = iMtsThingWeWereDoing;
        gTempMTSError.dwErrorCode = dwErrorCode;

        g_pTheApp->m_bAllowMessageBoxPopups = TRUE;

        // show the messagebox display from another thread, so that setup can continue!
        HANDLE  hProc = NULL;
        hProc = CreateThread(NULL, 0, MessageBoxFreeThread_MTS, 0, 0, &id);

        g_pTheApp->m_bAllowMessageBoxPopups = iSaveOld_AllowMessageBoxPopups;

        g_pTheApp->m_bThereWereErrorsFromMTS = TRUE;
    }

    return;
}


void PleaseKillOrStopTheseExeFromRunning(LPCTSTR szModuleWhichIsLocked, CStringList &strList)
{
    if (strList.IsEmpty() == FALSE)
    {
        POSITION pos;
        CString csExeName;
        LPTSTR p;
        int nLen = 0;

        TCHAR szReturnedServiceName[_MAX_PATH];

        pos = strList.GetHeadPosition();
        while (pos) 
        {
            csExeName = strList.GetAt(pos);
            nLen = 0;
            nLen = csExeName.GetLength();

            if (nLen > 0)
            {
                //iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("%1!s! is locking %2!s! service and is locking %3!s!\n"),csExeName, szModuleWhichIsLocked));

                if (TRUE == InetIsThisExeAService(csExeName, szReturnedServiceName))
                {
                    iisDebugOutSafeParams((LOG_TYPE_WARN, _T("%1!s! is the %2!s! service and is locking %3!s!.  Let's stop that service.\n"),csExeName,szReturnedServiceName, szModuleWhichIsLocked));

                    // Check if it is the netlogon service, We no don't want to stop this service for sure!!!
                    /*
                    if (_tcsicmp(szReturnedServiceName, _T("NetLogon")) == 0)
                    {
                        // no we do not want to stop this service!!!
                        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("%1!s! is the %2!s! service and is locking %3!s!.  This service should not be stopped.\n"),csExeName,szReturnedServiceName, szModuleWhichIsLocked));
                        break;
                    }
                    */

                    // Don't stop any services which are not win32 services
                    // Don't stop any system services...
                    if (TRUE == IsThisOnNotStopList(g_pTheApp->m_hInfHandle, szReturnedServiceName, TRUE))
                    {
                        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("%1!s! is the %2!s! service and is locking %3!s!.  This service should not be stopped.\n"),csExeName,szReturnedServiceName, szModuleWhichIsLocked));
                    }
                    else
                    {
                      // add this service to the list of 
                      // services we need to restart after setup is done!!
                      ServicesRestartList_Add(szReturnedServiceName);

                      // Check the list of services which we are sure we do not want to stop!

                      // net stop it
                      InetStopService(szReturnedServiceName);
                    }
                    // otherwise go on to the next .exe file
                }
                else
                {
                    // This .exe file is not a Service....
                    // Should we kill it???????

                    if (TRUE == IsThisOnNotStopList(g_pTheApp->m_hInfHandle, csExeName, FALSE))
                    {
                        iisDebugOutSafeParams((LOG_TYPE_PROGRAM_FLOW, _T("%1!s! is locking it. This process should not be killed\n"),csExeName));
                    }
                    else
                    {
                      // Check the list of .exe which we are sure we do not want to kill!
                      iisDebugOutSafeParams((LOG_TYPE_WARN, _T("%1!s! is locking %2!s!.  Let's kill that process.\n"),csExeName,szModuleWhichIsLocked));
                      KillProcess_Wrap(csExeName);
                    }
                }
            }
            strList.GetNext(pos);
        }
    }

    return;
}

void ShowIfModuleUsedForThisINFSection(IN HINF hFile, IN LPCTSTR szSection, int iUnlockThem)
{
    LPTSTR  szLine = NULL;
    DWORD   dwRequiredSize;
    BOOL    b = FALSE;
    CString csFile;
    DWORD   dwMSVer, dwLSVer;

    INFCONTEXT Context;

    TCHAR buf[_MAX_PATH];
    GetSystemDirectory( buf, _MAX_PATH);

    // go to the beginning of the section in the INF file
    b = SetupFindFirstLine_Wrapped(hFile, szSection, NULL, &Context);
    if (!b)
        {
        goto ShowIfModuleUsedForThisINFSection_Exit;
        }

    // loop through the items in the section.
    while (b) 
    {
        // get the size of the memory we need for this
        b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);

        // prepare the buffer to receive the line
        szLine = (LPTSTR)GlobalAlloc( GPTR, dwRequiredSize * sizeof(TCHAR) );
        if ( !szLine )
            {
            goto ShowIfModuleUsedForThisINFSection_Exit;
            }
        
        // get the line from the inf file1
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL) == FALSE)
            {
            goto ShowIfModuleUsedForThisINFSection_Exit;
            }

        // Attach the path to the from of this...
        // check in this directory:
        // 1. winnt\system32
        // --------------------------------------

        // may look like this "iisrtl.dll,,4"
        // so get rid of the ',,4'
        LPTSTR pch = NULL;
        pch = _tcschr(szLine, _T(','));
        if (pch) {_tcscpy(pch, _T(" "));}

        // Remove any trailing spaces.
        StripLastBackSlash(szLine);

        // Get the system dir
        csFile = buf;

        csFile = AddPath(csFile, szLine);

        CStringList strList;
        strList.RemoveAll();

        LogProcessesUsingThisModule(csFile, strList);

        // if we're supposed to unlock this file, then
        // we'll try it.
        if (iUnlockThem)
        {
            PleaseKillOrStopTheseExeFromRunning(csFile, strList);
        }

        // find the next line in the section. If there is no next line it should return false
        b = SetupFindNextLine(&Context, &Context);

        // free the temporary buffer
        GlobalFree( szLine );
        szLine = NULL;
    }

    // free some memory used for the task list
    FreeTaskListMem();
    UnInit_Lib_PSAPI();

    if (szLine) {GlobalFree(szLine);szLine=NULL;}

ShowIfModuleUsedForThisINFSection_Exit:
    return;
}


void ShowIfModuleUsedForGroupOfSections(IN HINF hFile, int iUnlockThem)
{
    CStringList strList;

    CString csTheSection = _T("VerifyFileSections_Lockable");

    if (GetSectionNameToDo(hFile, csTheSection))
    {
        if (ERROR_SUCCESS == FillStrListWithListOfSections(hFile, strList, csTheSection))
        {
            // loop thru the list returned back
            if (strList.IsEmpty() == FALSE)
            {
                POSITION pos;
                CString csEntry;

                pos = strList.GetHeadPosition();
                while (pos) 
                {
                    csEntry = strList.GetAt(pos);
                    ShowIfModuleUsedForThisINFSection(hFile, csEntry, iUnlockThem);
                    strList.GetNext(pos);
                }
            }
        }
    }

    return;
}


int ReadGlobalsFromInf(HINF InfHandle)
{
    int iReturn = FALSE;
    INFCONTEXT Context;
    TCHAR szTempString[_MAX_PATH] = _T("");

    //
    // Set the m_csAppName
    //
    if (!SetupFindFirstLine_Wrapped(InfHandle, _T("SetupInfo"), _T("AppName"), &Context) )
        {iisDebugOut((LOG_TYPE_ERROR, _T("SetupFindFirstLine_Wrapped(SetupInfo, AppName) FAILED")));}
    if (!SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {iisDebugOut((LOG_TYPE_ERROR, _T("SetupGetStringField(SetupInfo, AppName) FAILED")));}
    // Set the global.
    g_pTheApp->m_csAppName = szTempString;

    //
    // Set the m_csIISGroupName
    //
    _tcscpy(szTempString, _T(""));
    if (!SetupFindFirstLine_Wrapped(InfHandle, _T("SetupInfo"), _T("StartMenuGroupName"), &Context) )
        {iisDebugOut((LOG_TYPE_ERROR, _T("SetupFindFirstLine_Wrapped(SetupInfo, StartMenuGroupName) FAILED")));}
    if (!SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {iisDebugOut((LOG_TYPE_ERROR, _T("SetupGetStringField(SetupInfo, StartMenuGroupName) FAILED")));}
    g_pTheApp->m_csIISGroupName = szTempString;
    iReturn = TRUE;

    //
    // Get the value of one tick on the progressbar
    //
    g_GlobalTickValue = 1;
    _tcscpy(szTempString, _T(""));
    SetupFindFirstLine_Wrapped(InfHandle, _T("SetupInfo"), _T("OneTick"), &Context);
    if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {g_GlobalTickValue = _ttoi(szTempString);}

    //
    // See if we want to fake out setup when it's running in add\remove, to think it's actually guimode
    //
    g_GlobalGuiOverRide = 0;
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupInfo"), _T("GuiMode"), &Context))
    {
      if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
          {g_GlobalGuiOverRide = _ttoi(szTempString);}
    }


    return iReturn;
}


int CheckIfPlatformMatchesInf(HINF InfHandle)
{
    int iReturn = TRUE;
    INFCONTEXT Context;

    TCHAR szPlatform[_MAX_PATH] = _T("");
    BOOL fPlatform = FALSE;
    int nPlatform = IDS_INCORRECT_PLATFORM;

    if (!SetupFindFirstLine_Wrapped(InfHandle, _T("SetupInfo"), _T("Platform"), &Context) )
        {iisDebugOut((LOG_TYPE_ERROR, _T("SetupFindFirstLine_Wrapped(SetupInfo, Platform) FAILED")));}
    SetupGetStringField(&Context, 1, szPlatform, _MAX_PATH, NULL);

    // Check if .inf file is for NTS
    if (_tcsicmp(szPlatform, _T("NTS")) == 0)
    {
        if (g_pTheApp->m_eOS == OS_NT && g_pTheApp->m_eNTOSType != OT_NTW) 
            {fPlatform = TRUE;}
        else
        {
            if (g_pTheApp->m_fInvokedByNT)
            {
                iisDebugOut((LOG_TYPE_WARN,   _T("TemporaryHack.  iis.inf=NTS system=NTW, but wait till nt5 fixes. FAIL.\n")));
                g_pTheApp->m_eNTOSType = OT_NTS;
                fPlatform = TRUE;
            }
            else
            {
                nPlatform = IDS_NEED_PLATFORM_NTW;
            }
        }
    }

    // Check if .inf file is for NTW
    if (_tcsicmp(szPlatform, _T("NTW")) == 0)
    {
        if (g_pTheApp->m_eOS == OS_NT && g_pTheApp->m_eNTOSType == OT_NTW){fPlatform = TRUE;}
        else{nPlatform = IDS_NEED_PLATFORM_NTW;}
    }

    /*
    // Check if .inf file is for Windows 95
    if (_tcsicmp(szPlatform, _T("W95")) == 0)
    {
        if (g_pTheApp->m_eOS == OS_W95){fPlatform = TRUE;}
        else{nPlatform = IDS_NEED_PLATFORM_W95;}
    }
    */

    // If We didn't find the specific platform, then produce error message.
    if (!fPlatform)
    {
        MyMessageBox(NULL, nPlatform, MB_OK | MB_SETFOREGROUND);
        iReturn = FALSE;
    }

    return iReturn;
}


int CheckSpecificBuildinInf(HINF InfHandle)
{
    int iReturn = TRUE;
    INFCONTEXT Context;

    // Check for a specific build of nt5...
    if ( g_pTheApp->m_eOS == OS_NT )
    {
        int iBuildNumRequired = 0;
        TCHAR szBuildRequired[20] = _T("");

        // check for Debug Keyword
        if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupInfo"), _T("Debug"), &Context) )
            {
            SetupGetStringField(&Context, 1, szBuildRequired, 50, NULL);
            if (IsValidNumber((LPCTSTR)szBuildRequired)) 
                {
                iBuildNumRequired = _ttoi(szBuildRequired);
                if (iBuildNumRequired >= 1) {g_pTheApp->m_bAllowMessageBoxPopups = TRUE;}
                }
            }
       
        if (!SetupFindFirstLine_Wrapped(InfHandle, _T("SetupInfo"), _T("OSBuildRequired"), &Context) )
            {iisDebugOut((LOG_TYPE_ERROR, _T("SetupFindFirstLine_Wrapped(SetupInfo, OSBuildRequired) FAILED")));}
        SetupGetStringField(&Context, 1, szBuildRequired, 20, NULL);

        // Since this is nt, we should be able to get the build number
        CRegKey regWindowsNT( HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"),KEY_READ);
        if ( (HKEY)regWindowsNT )
        {
            CString strBuildNumString;
            regWindowsNT.m_iDisplayWarnings = FALSE;
            if (ERROR_SUCCESS == regWindowsNT.QueryValue(_T("CurrentBuildNumber"), strBuildNumString))
            {
                int iBuildNumOS = 0;
                if (IsValidNumber((LPCTSTR)strBuildNumString)) 
                    {iBuildNumOS = _ttoi(strBuildNumString);}
                iisDebugOut((LOG_TYPE_TRACE, _T("NTCurrentBuildNumber=%d\n"), iBuildNumOS));

                // We have a build entry.
                // lets check if it larger than or equal to what the underlying operting system is...
                if (_tcsicmp(szBuildRequired, _T("")) != 0)
                {
                    if (IsValidNumber((LPCTSTR)szBuildRequired)) 
                        {iBuildNumRequired = _ttoi(szBuildRequired);}
                    if ((iBuildNumOS !=0 && iBuildNumRequired !=0) && (iBuildNumOS < iBuildNumRequired))
                    {
                        // They don't have a big enough build num
                        // give the error message.
                        MyMessageBox(NULL, IDS_OS_BUILD_NUM_REQUIREMENT,szBuildRequired, MB_OK | MB_SETFOREGROUND);
                    }
                }
            }
        }
    }

    return iReturn;
}

int CheckForOldGopher(HINF InfHandle)
{
    int iReturn = TRUE;
    INFCONTEXT Context;

    if ( !(g_pTheApp->m_fUnattended) && g_pTheApp->m_eInstallMode == IM_UPGRADE )
    {
        CRegKey regGopher(HKEY_LOCAL_MACHINE, REG_GOPHERSVC,KEY_READ);
        if ( (HKEY)regGopher )
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("GopherCurrentlyInstalled=YES")));
            if (g_pTheApp->MsgBox(NULL, IDS_REMOVE_GOPHER, MB_OKCANCEL, FALSE) == IDCANCEL)
            {
                // setup should be terminated.
                iReturn = FALSE;
                goto CheckForOldGopher_Exit;
            }
        }

    }

CheckForOldGopher_Exit:
    return iReturn;
}

// IIS publish the following directories to iis partners products
// Note: Inetpub directory can be customized later, and we'll re-publish
// those affected directories again later.
void SetOCGlobalPrivateData(void)
{
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathInetsrv"),(PVOID)(LPCTSTR)g_pTheApp->m_csPathInetsrv,(g_pTheApp->m_csPathInetsrv.GetLength() + 1) * sizeof(TCHAR),REG_SZ);

    CString csPathIISAdmin = g_pTheApp->m_csPathInetsrv + _T("\\iisadmin");
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathIISAdmin"),(PVOID)(LPCTSTR)csPathIISAdmin,(csPathIISAdmin.GetLength() + 1) * sizeof(TCHAR),REG_SZ);

    CString csPathIISHelp = g_pTheApp->m_csWinDir + _T("\\Help\\iishelp");
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathIISHelp"),(PVOID)(LPCTSTR)csPathIISHelp,(csPathIISHelp.GetLength() + 1) * sizeof(TCHAR),REG_SZ);

    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathFTPRoot"),(PVOID)(LPCTSTR)g_pTheApp->m_csPathFTPRoot,(g_pTheApp->m_csPathFTPRoot.GetLength() + 1) * sizeof(TCHAR),REG_SZ);
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathWWWRoot"),(PVOID)(LPCTSTR)g_pTheApp->m_csPathWWWRoot,(g_pTheApp->m_csPathWWWRoot.GetLength() + 1) * sizeof(TCHAR),REG_SZ);
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathIISSamples"),(PVOID)(LPCTSTR)g_pTheApp->m_csPathIISSamples,(g_pTheApp->m_csPathIISSamples.GetLength() + 1) * sizeof(TCHAR),REG_SZ);

    CString csPathScripts = g_pTheApp->m_csPathIISSamples + _T("\\Scripts");
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("PathScripts"),(PVOID)(LPCTSTR)csPathScripts,(csPathScripts.GetLength() + 1) * sizeof(TCHAR),REG_SZ);
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("IISProgramGroup"),(PVOID)(LPCTSTR)g_pTheApp->m_csIISGroupName,(g_pTheApp->m_csIISGroupName.GetLength() + 1) * sizeof(TCHAR),REG_SZ);

    DWORD dwUpgradeType = (DWORD)(g_pTheApp->m_eUpgradeType);
    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("UpgradeType"),(PVOID)&dwUpgradeType,sizeof(DWORD),REG_DWORD);

    return;
}


void SetDIRIDforThisInf(HINF InfHandle)
{
    BOOL bTempFlag = FALSE;

    // Create Directory IDs for the coresponding .inf file
    bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32768, g_pTheApp->m_csPathInetsrv);
    bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32769, g_pTheApp->m_csPathFTPRoot);
    bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32770, g_pTheApp->m_csPathWWWRoot);
    bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32771, g_pTheApp->m_csPathIISSamples);
    bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32772, g_pTheApp->m_csPathScripts);
    bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32773, g_pTheApp->m_csPathInetpub);
    bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32774, g_pTheApp->m_csPathOldInetsrv);
    
    if (g_pTheApp->m_eUpgradeType == UT_10_W95) 
    {
        bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32775, g_pTheApp->m_csPathOldPWSFiles);
        bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32776, g_pTheApp->m_csPathOldPWSSystemFiles);
    }
    
    TCHAR szJavaDir[_MAX_PATH];
    GetJavaTLD(szJavaDir);
    bTempFlag = SetupSetDirectoryId_Wrapper(InfHandle, 32778, szJavaDir);
    SetupSetDirectoryId_Wrapper(InfHandle, 32777, g_pTheApp->m_csPathProgramFiles);

    SetupSetDirectoryId_Wrapper(InfHandle, 32779, g_pTheApp->m_csPathWebPub);

    if (g_pTheApp->m_eUpgradeType == UT_NONE){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_NONE"));}
    if (g_pTheApp->m_eUpgradeType == UT_351){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_351"));}
    if (g_pTheApp->m_eUpgradeType == UT_10){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_10"));}
    if (g_pTheApp->m_eUpgradeType == UT_20){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_20"));}
    if (g_pTheApp->m_eUpgradeType == UT_30){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_30"));}
    if (g_pTheApp->m_eUpgradeType == UT_40){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_40"));} // can also be from win95
    if (g_pTheApp->m_eUpgradeType == UT_50){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_50"));}
    if (g_pTheApp->m_eUpgradeType == UT_51){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_51"));}
    if (g_pTheApp->m_eUpgradeType == UT_60){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_60"));}
    if (g_pTheApp->m_eUpgradeType == UT_10_W95){SetupSetStringId_Wrapper(InfHandle, 32801, _T("UT_10_W95"));}

	CString csMachineName = g_pTheApp->m_csMachineName.Right(g_pTheApp->m_csMachineName.GetLength() - 2);
    SetupSetStringId_Wrapper(InfHandle, 32800, csMachineName);
    SetupSetStringId_Wrapper(InfHandle, 32802, _T(""));
   
    SetupSetStringId_Wrapper(InfHandle, 33000, g_pTheApp->m_csGuestName);
    SetupSetStringId_Wrapper(InfHandle, 33001, g_pTheApp->m_csWAMAccountName);
    SetupSetStringId_Wrapper(InfHandle, 33002, g_pTheApp->m_csWWWAnonyName);
    SetupSetStringId_Wrapper(InfHandle, 33003, g_pTheApp->m_csFTPAnonyName);

    if ( _tcsicmp(g_pTheApp->m_csWAMAccountName_Remove, _T("")) == 0)
        {g_pTheApp->m_csWAMAccountName_Remove = g_pTheApp->m_csWAMAccountName;}
    SetupSetStringId_Wrapper(InfHandle, 33004, g_pTheApp->m_csWAMAccountName_Remove);

    if ( _tcsicmp(g_pTheApp->m_csWWWAnonyName_Remove, _T("")) == 0)
        {g_pTheApp->m_csWWWAnonyName_Remove = g_pTheApp->m_csWWWAnonyName;  }
    SetupSetStringId_Wrapper(InfHandle, 33005, g_pTheApp->m_csWWWAnonyName_Remove);

    if ( _tcsicmp(g_pTheApp->m_csWWWAnonyName_Remove, _T("")) == 0)
        {g_pTheApp->m_csFTPAnonyName_Remove = g_pTheApp->m_csFTPAnonyName;}
    SetupSetStringId_Wrapper(InfHandle, 33006, g_pTheApp->m_csFTPAnonyName_Remove);
    
    SYSTEM_INFO SystemInfo;
    GetSystemInfo( &SystemInfo );

    TCHAR szSourceCatOSName[20];
    _tcscpy(szSourceCatOSName, _T("\\i386"));
    switch(SystemInfo.wProcessorArchitecture) 
    {
      case PROCESSOR_ARCHITECTURE_AMD64:
          _tcscpy(szSourceCatOSName, _T("\\AMD64"));
          break;
//      case PROCESSOR_ARCHITECTURE_IA64:
//          _tcscpy(szSourceCatOSName, _T("\\IA64"));
//          break;
        case PROCESSOR_ARCHITECTURE_INTEL:
            if (IsNEC_98) {_tcscpy(szSourceCatOSName, _T("\\Nec98"));}
            break;
        default:
            break;
    }
    SetupSetStringId_Wrapper(InfHandle, 34000, szSourceCatOSName);
    return;
}

BOOL GetJavaTLD(LPTSTR lpszDir)
{
    CRegKey regKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\JAVA VM"),KEY_READ);
    BOOL bFound = FALSE;
    CString csValue;
    CString csValue2;
    int iWhere = -1;

    if ((HKEY)regKey)
    {
        regKey.m_iDisplayWarnings = FALSE;
        if (regKey.QueryValue(_T("TrustedLibsDirectory"), csValue) == ERROR_SUCCESS) {bFound = TRUE;}
        // Warning: we are expecting something like this = "C:\WINNT\java\trustlib"
        // However, recently 12/18 the nt5 "java vm" setup seems to be hosing and passing us:
        // %systemroot%\java\trustlib

        if (-1 != csValue.Find(_T('%')) )
        {
            // there is a '%' in the string
            TCHAR szTempDir[_MAX_PATH];
            _tcscpy(szTempDir, csValue);
            if (ExpandEnvironmentStrings( (LPCTSTR)csValue, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                {
                csValue = szTempDir;
                }
        }
/*
        // if we see %systemroot% in there then, i'm going to substitute WinDir in place of %Systemroot%
        csValue.MakeUpper();
        if (csValue.Find(_T("%SYSTEMROOT%")) != (-1) )
        {
            // We Found the cheesy %systemroot% deal.  Now replace it with the real systemroot
            iWhere = csValue.Find(_T("%SYSTEMROOT%"));
            iWhere = iWhere + _tcslen(_T("%SYSTEMROOT%"));
            csValue2 = g_pTheApp->m_csWinDir + csValue.Right( csValue.GetLength() - (iWhere) );
            csValue = csValue2;
        }
*/
    }

    if (!bFound) {csValue = g_pTheApp->m_csWinDir + _T("\\Java\\TrustLib");}
    _tcscpy(lpszDir, csValue);
    return bFound;
}


void ShowStateOfTheseServices(IN HINF hFile)
{
    CStringList strList;
    DWORD dwStatus;
    
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T(" --- Display status of services which are required for IIS to run --- \n")));

    CString csTheSection = _T("VerifyServices");
    if (GetSectionNameToDo(hFile, csTheSection))
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(hFile, strList, csTheSection))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos;
            CString csEntry;

            pos = strList.GetHeadPosition();
            while (pos) 
            {
                csEntry = strList.GetAt(pos);

                // Display state of this service.
                dwStatus = InetQueryServiceStatus(csEntry);
                switch(dwStatus)
                {
                    case SERVICE_STOPPED:
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_STOPPED [%s].\n"), csEntry));
                        break;
                    case SERVICE_START_PENDING:
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_START_PENDING [%s].\n"), csEntry));
                        break;
                    case SERVICE_STOP_PENDING:
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_STOP_PENDING [%s].\n"), csEntry));
                        break;
                    case SERVICE_RUNNING:
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_RUNNING [%s].\n"), csEntry));
                        break;
                    case SERVICE_CONTINUE_PENDING:
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_CONTINUE_PENDING [%s].\n"), csEntry));
                        break;
                    case SERVICE_PAUSE_PENDING:
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_PAUSE_PENDING [%s].\n"), csEntry));
                        break;
                    case SERVICE_PAUSED:
                        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_PAUSED [%s].\n"), csEntry));
                        break;
                }

                strList.GetNext(pos);
            }
        }
    }
    }

    return;
}


#define MD_SIGNATURE_STRINGA    "*&$MetaData$&*"
#define MD_SIGNATURE_STRINGW    L##"*&$MetaData$&*"

int IsMetabaseCorrupt(void)
{
    // We've had a problem where sometimes the metabase.bin file
    // gets corrupted and set to only spaces...
    // so this function is here to determine where and when the metabase.bin is hosed!
    int    iTheMetabaseIsCorrupt = FALSE;
    TCHAR  szSystemDir[_MAX_PATH];
    TCHAR  szFullPath[_MAX_PATH];
    HANDLE hReadFileHandle = INVALID_HANDLE_VALUE;
    BYTE   *chBuffer = NULL;
    DWORD   dwSize = 0;
    DWORD   dwWideSignatureLen = 0;
    DWORD   dwAnsiSignatureLen = 0;
    TCHAR buf[MAX_FAKE_METABASE_STRING_LEN];

    // get the c:\winnt\system32 dir
    if (0 == GetSystemDirectory(szSystemDir, _MAX_PATH))
        {goto IsMetabaseCorrupt_Exit;}

    // Tack on the inf\iis.inf subdir and filename
    _stprintf(szFullPath, _T("%s\\inetsrv\\metabase.bin"),szSystemDir);

	// Check if the file exists
    if (TRUE != IsFileExist(szFullPath))
        {
            iTheMetabaseIsCorrupt = FALSE;
            // this function only works on version less than or equal to iis5
            // since that's the only versions which had a metabase.bin file
            // so just return that the metabase is not corrupt
            goto IsMetabaseCorrupt_Exit;
        }

    // okay, so the metabase.bin file exists...
    // let's open it and see if we can get something out of it.

    //
    // Open the file.
    //
    hReadFileHandle = CreateFile(szFullPath,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
    if (hReadFileHandle == INVALID_HANDLE_VALUE)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("IsMetabaseCorrupt: CreateFile on %s failed with 0x%x!\n"),szFullPath,GetLastError()));
        goto IsMetabaseCorrupt_Exit;
    }

    dwSize = GetFileSize(hReadFileHandle, NULL);
    dwWideSignatureLen = sizeof(MD_SIGNATURE_STRINGW);
    dwAnsiSignatureLen = sizeof(MD_SIGNATURE_STRINGA);

    // get the size of the whole file
    //chBuffer = (BYTE *)HeapAlloc(GetProcessHeap(), 0, dwSize+1 );
    if ((dwSize) >= dwWideSignatureLen)
    {
        chBuffer = (BYTE *)HeapAlloc(GetProcessHeap(), 0, dwWideSignatureLen+1);
        dwSize = dwWideSignatureLen+1;
    }
    else
    {
        if ( dwSize >= dwAnsiSignatureLen)
        {
            chBuffer = (BYTE *)HeapAlloc(GetProcessHeap(), 0, dwAnsiSignatureLen+1 );
            dwSize = dwAnsiSignatureLen+1;
        }
        else
        {
            iisDebugOut((LOG_TYPE_WARN, _T("IsMetabaseCorrupt: ReadFile on %s.  Not enough data in there! Less than metabase signature len!\n"),szFullPath));
            // Things are not kool
            // This metabase must be hosed!
            iTheMetabaseIsCorrupt = FALSE;
            goto IsMetabaseCorrupt_Exit;
        }
    }

    if (!chBuffer)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("IsMetabaseCorrupt: HeapAlloc failed to get %d space.\n"),dwWideSignatureLen+1));
        goto IsMetabaseCorrupt_Exit;
    }

    SetFilePointer(hReadFileHandle,0,0,FILE_BEGIN);

    // kool, try to read the file
    if (0 == ReadFile(hReadFileHandle, chBuffer, dwSize, &dwSize, NULL))
    {
        iisDebugOut((LOG_TYPE_WARN, _T("IsMetabaseCorrupt: ReadFile on %s failed with 0x%x!. size=%d\n"),szFullPath,GetLastError(),dwSize));
        goto IsMetabaseCorrupt_Exit;
    }

    //
    // take chBuffer and check if it matches the unicode/ansi signature.
    //
    if (0 == memcmp(MD_SIGNATURE_STRINGW,chBuffer,dwWideSignatureLen))
    {
        // things are kool, and this metabase should not be hosed.
        iTheMetabaseIsCorrupt = FALSE;
        goto IsMetabaseCorrupt_Exit;
    }
    if (0 == memcmp(MD_SIGNATURE_STRINGA,chBuffer,dwAnsiSignatureLen))
    {
        // if not, then check if it matches the ansi signature.
        // things are kool, and this metabase should not be hosed.
        iTheMetabaseIsCorrupt = FALSE;
        goto IsMetabaseCorrupt_Exit;
    }

    // on other check...
    // in iis6 there is a dummy fake metabase.bin put there by setup
    // check if this is that dummy file.
    if (chBuffer)
        {HeapFree(GetProcessHeap(), 0, chBuffer); chBuffer = NULL;}
   
    memset(buf, 0, _tcslen(buf) * sizeof(TCHAR));
    // this iis.dll is always compiled unicode, so
    // we know that buf is unicode
    if (LoadString((HINSTANCE) g_MyModuleHandle, IDS_FAKE_METABASE_BIN_TEXT, buf, MAX_FAKE_METABASE_STRING_LEN))
    {
        dwSize = _tcslen(buf) * sizeof(TCHAR);
        // add space for the FF and FE bytes
        dwSize = dwSize + 2;

        // open the file
        SetFilePointer(hReadFileHandle,0,0,FILE_BEGIN);

        chBuffer = (BYTE *)HeapAlloc(GetProcessHeap(), 0, dwSize);

        // kool, try to read the file
        if (0 == ReadFile(hReadFileHandle, chBuffer, dwSize, &dwSize, NULL))
        {
            iisDebugOut((LOG_TYPE_WARN, _T("IsMetabaseCorrupt: ReadFile on %s failed with 0x%x!. size=%d\n"),szFullPath,GetLastError(),dwSize));
            goto IsMetabaseCorrupt_Exit;
        }

        // check if the input file is unicode
        if (0xFF == chBuffer[0] && 0xFE == chBuffer[1])
        {
            // skip past these characters
            chBuffer++;
            chBuffer++;

            // Compare what you got with what we think is in there
            if (0 == memcmp(buf,chBuffer,dwSize))
            {
                // things are kool, and this metabase should not be hosed.
                chBuffer--;
                chBuffer--;
                iTheMetabaseIsCorrupt = FALSE;
                goto IsMetabaseCorrupt_Exit;
            }
            chBuffer--;
            chBuffer--;
        }
    }

    // if not then, it must be corrupt!
    // Things are not kool
    // This metabase must be hosed!
    iTheMetabaseIsCorrupt = TRUE;
    iisDebugOut((LOG_TYPE_WARN, _T("IsMetabaseCorrupt: unable to verify signature in Metabase.bin. Corrupt.\n")));

IsMetabaseCorrupt_Exit:
    if (chBuffer)
        {HeapFree(GetProcessHeap(), 0, chBuffer);}
    if (hReadFileHandle != INVALID_HANDLE_VALUE)
        {CloseHandle(hReadFileHandle);}
    return iTheMetabaseIsCorrupt;
}


void iisDebugOut_Start(TCHAR *pszString, int iLogType)
{
    iisDebugOut((iLogType, _T("%s:Start.\n"),pszString));
    return;
}
void iisDebugOut_Start1(TCHAR *pszString1, TCHAR *pszString2, int iLogType)
{
    iisDebugOut((iLogType, _T("%s:(%s)Start.\n"),pszString1,pszString2));
    return;
}
void iisDebugOut_Start1(TCHAR *pszString1, CString pszString2, int iLogType)
{
    iisDebugOut((iLogType, _T("%s:(%s)Start.\n"),pszString1,pszString2));
    return;
}
void iisDebugOut_End(TCHAR *pszString, int iLogType)
{
    iisDebugOut((iLogType, _T("%s:End.\n"),pszString));
    return;
}
void iisDebugOut_End1(TCHAR *pszString1, TCHAR *pszString2, int iLogType)
{
    iisDebugOut((iLogType, _T("%s(%s):End.\n"),pszString1, pszString2));
    return;
}
void iisDebugOut_End1(TCHAR *pszString1, CString pszString2, int iLogType)
{
    iisDebugOut((iLogType, _T("%s(%s):End.\n"),pszString1,pszString2));
    return;
}


BOOL SetupFindFirstLine_Wrapped(
    IN  HINF        InfHandle,
    IN  LPCTSTR     Section,
    IN  LPCTSTR     Key,          OPTIONAL
    INFCONTEXT *Context
    )
{
    BOOL bReturn = FALSE;
    BOOL bGoGetWhatTheyOriginallyWanted = TRUE;

    // check for the alternate .inf file
    if (g_pTheApp->m_hInfHandleAlternate && InfHandle != g_pTheApp->m_hInfHandleAlternate)
    {
        bReturn = SetupFindFirstLine(g_pTheApp->m_hInfHandleAlternate, Section, Key, Context);
        if (bReturn)
        {
            iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("Using alternate iis.inf section:[%s]"),Section));
            bGoGetWhatTheyOriginallyWanted = FALSE;
        }
    }

    if (bGoGetWhatTheyOriginallyWanted)
        {bReturn = SetupFindFirstLine(InfHandle, Section, Key, Context);}

    return bReturn;
}


int ReadUserConfigurable(HINF InfHandle)
{
    int iReturn = TRUE;
    INFCONTEXT Context;
    TCHAR szTempString[_MAX_PATH] = _T("");
    DWORD dwValue = 0x0;

    DWORD dwSomethingSpecifiedHere = 0;


    //
    // Get the IUSR name
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("IUSR"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WWW_USER_NAME))
            {
                g_pTheApp->m_csWWWAnonyName_Unattend = szTempString;
                dwSomethingSpecifiedHere |= USER_SPECIFIED_INFO_WWW_USER_NAME;
                //g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_NAME;
                iisDebugOut((LOG_TYPE_TRACE, _T("Custom iusr specified for www\n")));
            }

            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_FTP_USER_NAME))
            {
                g_pTheApp->m_csFTPAnonyName_Unattend = szTempString;
                dwSomethingSpecifiedHere |= USER_SPECIFIED_INFO_FTP_USER_NAME;
                //g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_NAME;
                iisDebugOut((LOG_TYPE_TRACE, _T("Custom iusr specified for ftp\n")));
            }
        }
    }

/*
    // this stuff should not be configurable from the iis.inf file

    //
    // Get the IUSR password
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("IUSR_PASS"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WWW_USER_PASS))
            {
                if (_tcsicmp(szTempString, _T("")) != 0)
                {
                    if (_tcsicmp(szTempString, _T("(blank)")) == 0)
                    {
                        _tcscpy(szTempString, _T(""));
                    }
                    g_pTheApp->m_csWWWAnonyPassword_Unattend = szTempString;
                    dwSomethingSpecifiedHere |= USER_SPECIFIED_INFO_WWW_USER_PASS;
                    //g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_PASS;
                    iisDebugOut((LOG_TYPE_TRACE, _T("Custom iusr pass specified for www\n")));
                }
            }

            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_FTP_USER_PASS))
            {
                if (_tcsicmp(szTempString, _T("")) != 0)
                {
                    if (_tcsicmp(szTempString, _T("(blank)")) == 0)
                    {
                        _tcscpy(szTempString, _T(""));
                    }
                    g_pTheApp->m_csFTPAnonyPassword_Unattend = szTempString;
                    
                    dwSomethingSpecifiedHere |= USER_SPECIFIED_INFO_FTP_USER_PASS;
                    //g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_PASS;
                    iisDebugOut((LOG_TYPE_TRACE, _T("Custom iusr pass specified for ftp\n")));
                }
            }
        }
    }
*/

    //
    // Get the IUSR name for WWW
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("IUSR_WWW"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WWW_USER_NAME))
            {
                g_pTheApp->m_csWWWAnonyName_Unattend = szTempString;
                g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_NAME;
                iisDebugOut((LOG_TYPE_TRACE, _T("Custom iusr specified for www\n")));
            }
        }
    }

/*
    // this stuff should not be configurable from the iis.inf file

    //
    // Get the IUSR pass for WWW
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("IUSR_WWW_PASS"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WWW_USER_PASS))
            {
                if (_tcsicmp(szTempString, _T("")) != 0)
                {
                    if (_tcsicmp(szTempString, _T("(blank)")) == 0)
                    {
                        _tcscpy(szTempString, _T(""));
                    }
                    g_pTheApp->m_csWWWAnonyPassword_Unattend = szTempString;
                    g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_PASS;
                    iisDebugOut((LOG_TYPE_TRACE, _T("Custom iusr pass specified for www\n")));
                }
            }
        }
    }
*/
    //
    // Get the IUSR name for FTP
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("IUSR_FTP"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_FTP_USER_NAME))
            {
                g_pTheApp->m_csFTPAnonyName_Unattend = szTempString;
                g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_NAME;
                iisDebugOut((LOG_TYPE_TRACE, _T("Custom iusr specified for ftp\n")));
            }
        }
    }

/*
    // this stuff should not be configurable from the iis.inf file

    //
    // Get the IUSR password for FTP
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("IUSR_FTP_PASS"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_FTP_USER_PASS))
            {
                if (_tcsicmp(szTempString, _T("")) != 0)
                {
                    if (_tcsicmp(szTempString, _T("(blank)")) == 0)
                    {
                        _tcscpy(szTempString, _T(""));
                    }
                    g_pTheApp->m_csFTPAnonyPassword_Unattend = szTempString;
                    g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_PASS;
                    iisDebugOut((LOG_TYPE_TRACE, _T("Custom iusr pass specified for ftp\n")));
                }
            }
        }
    }
*/

    //
    // Get the WAM username
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("IWAM"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WAM_USER_NAME))
            {
                g_pTheApp->m_csWAMAccountName_Unattend = szTempString;
                g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WAM_USER_NAME;
                iisDebugOut((LOG_TYPE_TRACE, _T("Custom iwam specified for www\n")));
            }
        }
    }

/*
    // this stuff should not be configurable from the iis.inf file
    //

    // Get the WAM password
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("IWAM_PASS"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WAM_USER_PASS))
            {
                if (_tcsicmp(szTempString, _T("")) != 0)
                {
                    if (_tcsicmp(szTempString, _T("(blank)")) == 0)
                    {
                        _tcscpy(szTempString, _T(""));
                    }
                    g_pTheApp->m_csWAMAccountPassword_Unattend = szTempString;
                    g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WAM_USER_PASS;
                    iisDebugOut((LOG_TYPE_TRACE, _T("Custom iwam pass specified for www\n")));
                }
            }
        }
    }

*/

    //
    // Get Path for Inetpub
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("PathInetpub"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_PATH_INETPUB))
            {
                if (_tcsicmp(szTempString, _T("")) != 0)
                {
                    if (IsValidDirectoryName(szTempString))
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("Custom PathInetpub=%s\n"),szTempString));
                        g_pTheApp->m_csPathInetpub = szTempString;
                        g_pTheApp->SetInetpubDerivatives();
                        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_PATH_INETPUB;
                    }
                    else
                    {
                        iisDebugOut((LOG_TYPE_WARN, _T("Custom PathInetpub specified (%s), however path not valid.ignoring unattend value. WARNING.\n"),szTempString));
                    }
                }
            }
        }
    }

    //
    // Get Path for ftp root
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("PathFTPRoot"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_PATH_FTP))
            {
                if (_tcsicmp(szTempString, _T("")) != 0)
                {
                    if (IsValidDirectoryName(szTempString))
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("Custom PathFTPRoot=%s\n"),szTempString));
                        CustomFTPRoot(szTempString);
                        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_PATH_FTP;
                    }
                    else
                    {
                        iisDebugOut((LOG_TYPE_WARN, _T("Custom PathFTPRoot specified (%s), however path not valid.ignoring unattend value. WARNING.\n"),szTempString));
                    }
                }
            }
        }
    }

    //
    // Get Path for www root
    //
    _tcscpy(szTempString, _T(""));
    if (SetupFindFirstLine_Wrapped(InfHandle, _T("SetupConfig"), _T("PathWWWRoot"), &Context) )
    {
        if (SetupGetStringField(&Context, 1, szTempString, _MAX_PATH, NULL))
        {
            // WARNING: these values can be changed by a user supplied unattend file
            // The User defined unattend file takes precidence over these!
            if (!(g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_PATH_WWW))
            {
                if (_tcsicmp(szTempString, _T("")) != 0)
                {
                    if (IsValidDirectoryName(szTempString))
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("Custom PathWWWRoot=%s\n"),szTempString));
                        CustomWWWRoot(szTempString);
                        g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_PATH_WWW;
                    }
                    else
                    {
                        iisDebugOut((LOG_TYPE_WARN, _T("Custom PathWWWRoot specified (%s), however path not valid.ignoring unattend value. WARNING.\n"),szTempString));
                    }
                }
            }
        }
    }

//ReadUserConfigurable_Exit:
    if (dwSomethingSpecifiedHere & USER_SPECIFIED_INFO_WWW_USER_NAME){g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_NAME;}
    if (dwSomethingSpecifiedHere & USER_SPECIFIED_INFO_FTP_USER_NAME){g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_NAME;}
    if (dwSomethingSpecifiedHere & USER_SPECIFIED_INFO_WWW_USER_PASS){g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_WWW_USER_PASS;}
    if (dwSomethingSpecifiedHere & USER_SPECIFIED_INFO_FTP_USER_PASS){g_pTheApp->dwUnattendConfig |= USER_SPECIFIED_INFO_FTP_USER_PASS;}
    return iReturn;
}


INT IsThisOnNotStopList(IN HINF hFile, CString csInputName, BOOL bServiceFlag)
{
    INT iReturn = FALSE;
    CStringList strList;

    // if the entry is not a service name,
    // then it must be a process filename,
    // so make sure to get just the end of it
    if (!bServiceFlag)
    {
        TCHAR szJustTheFileName[_MAX_FNAME];
        // make sure to get only just the filename.
        if (TRUE == ReturnFileNameOnly(csInputName, szJustTheFileName))
        {
            csInputName = szJustTheFileName;
        }
    }
    
    CString csTheSection = _T("NonStopList");
    if (GetSectionNameToDo(hFile, csTheSection))
    {
        if (ERROR_SUCCESS == FillStrListWithListOfSections(hFile, strList, csTheSection))
        {
            // loop thru the list returned back
            if (strList.IsEmpty() == FALSE)
            {
                POSITION pos;
                CString csEntry;

                pos = strList.GetHeadPosition();
                while (pos) 
                {
                    csEntry = strList.GetAt(pos);

                    // check if this entry matchs the entry that was passed in...
                    if (_tcsicmp(csEntry, csInputName) == 0)
                    {
                        // it matches so return TRUE;
                        iReturn = TRUE;
                        goto IsThisOnNotStopList_Exit;
                    }

                    strList.GetNext(pos);
                }
            }
        }
    }

IsThisOnNotStopList_Exit:
    return iReturn;
}


HRESULT MofCompile(TCHAR * szPathMofFile)
{    
    HRESULT hRes = E_FAIL;
    WCHAR wszFileName[_MAX_PATH];
    IMofCompiler    *pMofComp = NULL;
    WBEM_COMPILE_STATUS_INFO    Info;

    hRes = CoInitialize(NULL);
    if (FAILED(hRes))
    {
        goto MofCompile_Exit;
    }
   
    hRes = CoCreateInstance( CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (LPVOID *)&pMofComp);
    if (FAILED(hRes))
    {
        goto MofCompile_Exit;
    }

    // Ensure that the string is WCHAR.
#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wszFileName, szPathMofFile);
#else
    MultiByteToWideChar( CP_ACP, 0, szPathMofFile, -1, wszFileName, _MAX_PATH);
#endif

    pMofComp->CompileFile (
                (LPWSTR) wszFileName,
                NULL,			// load into namespace specified in MOF file
                NULL,           // use default User
                NULL,           // use default Authority
                NULL,           // use default Password
                0,              // no options
                0,				// no class flags
                0,              // no instance flags
                &Info);

    pMofComp->Release();
    CoUninitialize();

MofCompile_Exit:
	return hRes;
}


DWORD DoesEntryPointExist(LPCTSTR lpszDLLFile, LPCTSTR lpszProcedure)
{
    DWORD dwReturn = E_FAIL;
    HINSTANCE hDll = NULL;
    HCRET hProc = NULL;
    TCHAR szDirName[_MAX_PATH], szFilePath[_MAX_PATH];
    _tcscpy(szDirName, _T(""));

	// Check if the file exists
    if (!IsFileExist(lpszDLLFile)) 
	{
		dwReturn = ERROR_FILE_NOT_FOUND;
    	goto DoesEntryPointExist_Exit;
	}

    // Change Directory
    GetCurrentDirectory( _MAX_PATH, szDirName );
    InetGetFilePath(lpszDLLFile, szFilePath);

    // Change to The Drive.
    if (-1 == _chdrive( _totupper(szFilePath[0]) - 'A' + 1 )) {}
    if (SetCurrentDirectory(szFilePath) == 0) {}

    // Try to load the module,dll,ocx.
    hDll = LoadLibraryEx(lpszDLLFile, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
	if (!hDll)
	{
		dwReturn = TYPE_E_CANTLOADLIBRARY;
    	goto DoesEntryPointExist_Exit;
	}
	
	// Ok module was successfully loaded.  now let's try to get the Address of the Procedure
	// Convert the function name to ascii before passing it to GetProcAddress()
	char AsciiProcedureName[255];
#if defined(UNICODE) || defined(_UNICODE)
    // convert to ascii
    WideCharToMultiByte( CP_ACP, 0, (TCHAR *)lpszProcedure, -1, AsciiProcedureName, 255, NULL, NULL );
#else
    // the is already ascii so just copy
    strcpy(AsciiProcedureName, lpszProcedure);
#endif

    // see if the entry point exists...
    hProc = (HCRET)GetProcAddress(hDll, AsciiProcedureName);
	if (!hProc)
	{
		// failed to load,find or whatever this function.
	    dwReturn = ERROR_PROC_NOT_FOUND;
    	goto DoesEntryPointExist_Exit;
	}
    iisDebugOut((LOG_TYPE_TRACE, _T("DoesEntryPointExist:%s=true\n"),lpszProcedure));
    dwReturn = ERROR_SUCCESS;

DoesEntryPointExist_Exit:
    if (hDll){FreeLibrary(hDll);}
    if (_tcscmp(szDirName, _T("")) != 0){SetCurrentDirectory(szDirName);}
    return dwReturn;
}


void CreateDummyMetabaseBin(void)
{
    TCHAR szFullPath1[_MAX_PATH];
    TCHAR szFullPath2[_MAX_PATH];
    HANDLE hfile = INVALID_HANDLE_VALUE;
    DWORD dwBytesWritten = 0;
    TCHAR buf[MAX_FAKE_METABASE_STRING_LEN];
    BYTE bOneByte = 0;

    // check if there is an existing metabase.bin
    // if there is then rename it to a unique filename.
    // if we cannot rename it because its in use or something, then leave it and get out.
    _stprintf(szFullPath1, _T("%s\\metabase.bin"),g_pTheApp->m_csPathInetsrv);
    if (IsFileExist(szFullPath1)) 
    {
        // Check to see how big it is.
        DWORD dwFileSize = ReturnFileSize(szFullPath1);
        if (dwFileSize != 0xFFFFFFFF)
        {
            // if it's less than 2k then it must be the fake file already (must be an upgrade)
            // leave it alone and don't replace it with the dummy (since it already is the dummy)
            if (dwFileSize < 2000)
            {
                return;
            }
        }

        int iCount = 0;
        int iFlag = FALSE;
        do
        {
            // check if the new unique file name exists...
            _stprintf(szFullPath2, _T("%s.dfu.%d"),szFullPath1,iCount);
            if (!IsFileExist(szFullPath2)) 
            {
                iFlag = TRUE;
            }
        } while (iFlag == FALSE && iCount < 9999);

        // this is a unique filename, so let's use it and
        // rename the metabase.bin to it
        if (!MoveFileEx(szFullPath1, szFullPath2, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH|MOVEFILE_REPLACE_EXISTING))
        {
            // log the failure at least
            iisDebugOut((LOG_TYPE_WARN, _T("CreateDummyMetabaseBin: unable to rename existing metabase.bin file\n")));
            return;
        }
     
    }

    // Create a unicode text file named metabase.bin
    // and stick some sting into it (from our setup resource)
    // should be localized when localization localizes the iis.dll
    memset(buf, 0, _tcslen(buf) * sizeof(TCHAR));

    // this iis.dll is always compiled unicode, so
    // we know that buf is unicode
    if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_FAKE_METABASE_BIN_TEXT, buf, MAX_FAKE_METABASE_STRING_LEN))
    {
        iisDebugOut((LOG_TYPE_WARN, _T("LoadString(%d) Failed.\n"), IDS_FAKE_METABASE_BIN_TEXT));
        return;
    }
    DeleteFile(szFullPath1);

    // create the new metabase.bin file
    hfile = CreateFile((LPTSTR)szFullPath1, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if( hfile == INVALID_HANDLE_VALUE)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("CreateDummyMetabaseBin:CreateFile on %s failed with 0x%x!\n"),szFullPath1,GetLastError()));
        return;
    }
    // write a couple of bytes to the beginning of the file say that it's "unicode"
    bOneByte = 0xFF;
    WriteFile(hfile, (LPCVOID) &bOneByte, 1, &dwBytesWritten, NULL);
    bOneByte = 0xFE;
    WriteFile(hfile, (LPCVOID) &bOneByte, 1, &dwBytesWritten, NULL);
    if ( WriteFile( hfile, buf, _tcslen(buf) * sizeof(TCHAR), &dwBytesWritten, NULL ) == FALSE )
    {
        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("WriteFile(%1!s!) Failed.  Error=0x%2!x!.\n"), szFullPath1, GetLastError()));
    }

    CloseHandle(hfile);
    return;
}

//
// Check whether we are running as administrator on the machine
// or not
//
BOOL RunningAsAdministrator()
{
#ifdef _CHICAGO_
    return TRUE;
#else
    BOOL   fReturn = FALSE;
    PSID   psidAdmin;
    DWORD  err;
    
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;
    
    if ( AllocateAndInitializeSid ( &SystemSidAuthority, 2, 
            SECURITY_BUILTIN_DOMAIN_RID, 
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psidAdmin) )
    {
        if (!CheckTokenMembership( NULL, psidAdmin, &fReturn )) {
            err = GetLastError();
            iisDebugOut((LOG_TYPE_ERROR, _T("CheckTokenMembership failed on err %d.\n"), err));
        }

        FreeSid ( psidAdmin);
    }
    
    return ( fReturn );
#endif //_CHICAGO_
}


void StopAllServicesRegardless(int iShowErrorsFlag)
{
#ifndef _CHICAGO_
    // important: you must take iis clusters off line before doing anykind of upgrade\installs...
    // but incase the user didn't do this... try to take them off line for the user
	DWORD dwResult = ERROR_SUCCESS;
	dwResult = BringALLIISClusterResourcesOffline();

    if (StopServiceAndDependencies(_T("W3SVC"), FALSE) == FALSE)
    {
        if (iShowErrorsFlag)
        {
            MyMessageBox(NULL, IDS_UNABLE_TO_STOP_SERVICE,_T("W3SVC"), MB_OK | MB_SETFOREGROUND);
        }
    }

    if (StopServiceAndDependencies(_T("MSFTPSVC"), FALSE) == FALSE)
    {
        if (iShowErrorsFlag)
        {
            MyMessageBox(NULL, IDS_UNABLE_TO_STOP_SERVICE,_T("MSFTPSVC"), MB_OK | MB_SETFOREGROUND);
        }
    }

    if (StopServiceAndDependencies(_T("IISADMIN"), TRUE) == FALSE)
    {
        if (iShowErrorsFlag)
        {
            MyMessageBox(NULL, IDS_UNABLE_TO_STOP_SERVICE,_T("IISADMIN"), MB_OK | MB_SETFOREGROUND);
        }
    }

    /*
    DWORD dwStatus = 0;
    dwStatus = InetQueryServiceStatus(_T("MSDTC"));
    if (SERVICE_RUNNING == dwStatus)
    {
        // if the service is running, then let' stop it!
        if (StopServiceAndDependencies(_T("MSDTC"), TRUE) == FALSE)
        {
            if (iShowErrorsFlag){MyMessageBox(NULL, IDS_UNABLE_TO_STOP_SERVICE,_T("MSDTC"), MB_OK | MB_SETFOREGROUND);}
        }
    }
    */

    /*
    dwStatus = InetQueryServiceStatus(_T("SPOOLER"));
    if (SERVICE_RUNNING == dwStatus)
    {
        // if the service is running, then let' stop it!
        if (StopServiceAndDependencies(_T("SPOOLER"), TRUE) == FALSE)
        {
            if (iShowErrorsFlag){MyMessageBox(NULL, IDS_UNABLE_TO_STOP_SERVICE,_T("SPOOLER"), MB_OK | MB_SETFOREGROUND);}
        }
    }
    */
    
#else
    // Shutdown newer than 1.0 pws methods.
    W95ShutdownW3SVC();
    W95ShutdownIISADMIN( );

    // Shutdown peer web services 1.0
    HWND hwnd = FindWindow("MS_INetPeerServerWindowClass", NULL);
    if ( hwnd )
    {
        ::PostMessage(hwnd,(WM_USER+305),(WPARAM)0,0L);
        ::PostMessage(hwnd,(WM_USER+301),(WPARAM)-1,0L);
    }
#endif

    // kill pwstray.exe in case of IIS4.0 Beta2 upgrade, to release admprox.dll
    HWND hwndTray = NULL;
    hwndTray = FindWindow(PWS_TRAY_WINDOW_CLASS, NULL);
    if ( hwndTray ){::PostMessage( hwndTray, WM_CLOSE, 0, 0 );}

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\ipsec.cpp ===
// to be linked with:
// uuid.lib ole32.lib user32.lib kernel32.lib advapi32.lib wsock32.lib
// iis\svcs\infocomm\rdns\obj\i386\isrdns.lib iis\svcs\lib\i386\tsstr.lib iis\svcs\lib\i386\isdebug.lib


#include "stdafx.h"

#ifndef _CHICAGO_

#define _RDNS_STANDALONE

#include <winsock2.h>
#include <rdns.hxx>
#include <buffer.hxx>
#include <ole2.h>
#include <iadm.h>
#include <iiscnfg.h>
#include "mdkey.h"
#include "mdentry.h"
#include "helper.h"
#include <inetinfo.h>

extern int g_CheckIfMetabaseValueWasWritten;

#define TIMEOUT_VALUE   5000
//
//  Global Data
//

//
//  The registry parameter key names for the grant list and deny
//  list.  We use the kludgemultisz thing for Chicago
//

#define IPSEC_DENY_LIST             L"Deny IP List"
#define IPSEC_GRANT_LIST            L"Grant IP List"


//
//  Private prototypes.
//

BOOL
DottedDecimalToDword(
    CHAR * * ppszAddress,
    DWORD *  pdwAddress
    );

CHAR *
KludgeMultiSz(
    HKEY hkey,
    LPDWORD lpdwLength
    )
{
    LONG  err;
    DWORD iValue;
    DWORD cchTotal;
    DWORD cchValue;
    CHAR  szValue[MAX_PATH];
    LPSTR lpMultiSz;
    LPSTR lpTmp;
    LPSTR lpEnd;

    //
    //  Enumerate the values and total up the lengths.
    //

    iValue = 0;
    cchTotal = 0;

    for( ; ; )
    {
        cchValue = sizeof(szValue);

        err = RegEnumValueA( hkey,
                            iValue,
                            szValue,
                            &cchValue,
                            NULL,
                            NULL,
                            NULL,
                            NULL );

        if( err != NO_ERROR )
        {
            break;
        }

        //
        //  Add the length of the value's name, plus one
        //  for the terminator.
        //

        cchTotal += strlen( szValue ) + 1;

        //
        //  Advance to next value.
        //

        iValue++;
    }

    //
    //  Add one for the final terminating NULL.
    //

    cchTotal++;
    *lpdwLength = cchTotal;

    //
    //  Allocate the MULTI_SZ buffer.
    //

    lpMultiSz = (CHAR *) LocalAlloc( LMEM_FIXED, cchTotal * sizeof(CHAR) );

    if( lpMultiSz == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return NULL;
    }

    memset( lpMultiSz, 0, cchTotal * sizeof(CHAR) );

    //
    //  Enumerate the values and append to the buffer.
    //

    iValue = 0;
    lpTmp = lpMultiSz;
    lpEnd = lpMultiSz + cchTotal;

    for( ; ; )
    {
        cchValue = sizeof(szValue)/sizeof(CHAR);

        err = RegEnumValueA( hkey,
                            iValue,
                            szValue,
                            &cchValue,
                            NULL,
                            NULL,
                            NULL,
                            NULL );

        if( err != NO_ERROR )
        {
            break;
        }

        //
        //  Compute the length of the value name (including
        //  the terminating NULL).
        //

        cchValue = strlen( szValue ) + 1;

        //
        //  Determine if there is room in the array, taking into
        //  account the second NULL that terminates the string list.
        //

        if( ( lpTmp + cchValue + 1 ) > lpEnd )
        {
            break;
        }

        //
        //  Append the value name.
        //

        strcpy( lpTmp, szValue );
        lpTmp += cchValue;

        //
        //  Advance to next value.
        //

        iValue++;
    }

    //
    //  Success!
    //

    return (LPSTR)lpMultiSz;

}   // KludgeMultiSz


BOOL
ReadIPList(
    LPWSTR  pszRegKey,
    LPWSTR  pszRegSubKey,
    INETA_IP_SEC_LIST** ppIpSec
    )
/*++
  Description:
    This function reads the IP list from registry location
     specified in the pszRegKey + pszRegSubKey and stores the list in the
     internal list in memory.

     If there are no entries in the registry then this returns
      a NULL IP Security list object.
     If there is a new list, this function also frees the old list
      present in *ppIPSecList

  Arguments:
    pszRegKey - pointer to string containing the registry key
                where pszRegSubKey is located
    pszRegSubKey - pointer to string containing the registry key
                where IP list is stored relative to pszRegKey

  Returns:

    TRUE on success and FALSE on failure
--*/
{
    HKEY    hkey;
    DWORD   dwError;
    BOOL    fReturn = TRUE;
    LPWSTR  pszK;

    *ppIpSec = NULL;

    if ( (pszK = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(pszRegKey)+wcslen(pszRegSubKey)+2)*sizeof(WCHAR))) == NULL )
    {
        return FALSE;
    }

    wcscpy( pszK, pszRegKey );
    wcscat( pszK, L"\\" );
    wcscat( pszK, pszRegSubKey );

    dwError = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            pszK,
                            0,
                            KEY_ALL_ACCESS,
                            &hkey );

    LocalFree( pszK );

    if ( dwError != NO_ERROR) {

        if ( dwError != ERROR_FILE_NOT_FOUND ) {

            // maybe access denied or some other error.

            SetLastError( dwError );
            return (FALSE);
        }

        //
        //  A non-existent key is the same as a blank key
        //

    } else {

        CHAR *              psz;
        CHAR *              pszTmp;
        DWORD               cb;
        DWORD               cEntries = 0;
        INETA_IP_SEC_LIST * pIPSec = NULL;

        psz = pszTmp = KludgeMultiSz( hkey, &cb );

        RegCloseKey( hkey );

        //
        // Count the number of addresses and then add them to the list
        //

        if ( psz != NULL ) {

            for( ; *pszTmp; cEntries++ ) {

                pszTmp += strlen( pszTmp ) + 1;
            }

            pszTmp = psz;

            if ( cEntries > 0) {

                pIPSec = ((INETA_IP_SEC_LIST *)
                          LocalAlloc( LMEM_FIXED,
                                      sizeof(INETA_IP_SEC_LIST) +
                                      cEntries * sizeof(INETA_IP_SEC_ENTRY ))
                          );

                if ( pIPSec == NULL ) {

                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    fReturn = FALSE;
                } else {

                    for( pIPSec->cEntries = 0;
                        *pszTmp;
                        pszTmp += strlen( pszTmp ) + 1
                        ) {

                        if (!DottedDecimalToDword( &pszTmp,
                                                  &pIPSec->aIPSecEntry[pIPSec->cEntries].dwMask ) ||
                            !DottedDecimalToDword( &pszTmp,
                                              &pIPSec->aIPSecEntry[pIPSec->cEntries].dwNetwork )
                            ) {
                        } else {

                            pIPSec->cEntries++;
                        }
                    } // for

                    dwError = NO_ERROR;
                }
            }

            if ( dwError == NO_ERROR) {
                *ppIpSec = pIPSec;
            }

            LocalFree( psz );
        }

        if ( !fReturn) {

            SetLastError( dwError);
        }
    }

    return ( fReturn);
} // IPAccessList::ReadIPList()


BOOL
DottedDecimalToDword(
    CHAR * * ppszAddress,
    DWORD *  pdwAddress )
/*++

Routine Description:

    Converts a dotted decimal IP string to it's network equivalent

    Note: White space is eaten before *pszAddress and pszAddress is set
    to the character following the converted address

Arguments:

    ppszAddress - Pointer to address to convert.  White space before the
        address is OK.  Will be changed to point to the first character after
        the address
    pdwAddress - DWORD equivalent address in network order

    returns TRUE if successful, FALSE if the address is not correct

--*/
{
    CHAR *          psz;
    USHORT          i;
    ULONG           value;
    int             iSum =0;
    ULONG           k = 0;
    UCHAR           Chr;
    UCHAR           pArray[4];

    psz = *ppszAddress;

    //
    //  Skip white space
    //

    while ( *psz && !isdigit( (UCHAR)(*psz) ))
        psz++;

    //
    //  Convert the four segments
    //

    pArray[0] = 0;

    while ((Chr = *psz) && (Chr != ' ') )
    {
        if (Chr == '.')
        {
            // be sure not to overflow a byte.
            if (iSum <= 0xFF)
                pArray[k] = (UCHAR)iSum;
            else
                return FALSE;

            // check for too many periods in the address
            if (++k > 3)
                return FALSE;

            pArray[k] = 0;
            iSum = 0;
        }
        else
        {
            Chr = Chr - '0';

            // be sure character is a number 0..9
            if ((Chr < 0) || (Chr > 9))
                return FALSE;

            iSum = iSum*10 + Chr;
        }

        psz++;
    }

    // save the last sum in the byte and be sure there are 4 pieces to the
    // address
    if ((iSum <= 0xFF) && (k == 3))
        pArray[k] = (UCHAR)iSum;
    else
        return FALSE;

    // now convert to a ULONG, in network order...
    value = 0;

    // go through the array of bytes and concatenate into a ULONG
    for (i=0; i < 4; i++ )
    {
        value = (value << 8) + pArray[i];
    }
    *pdwAddress = htonl( value );

    *ppszAddress = psz;

    return TRUE;
}


BOOL
FillAddrCheckFromIpList(
    BOOL fIsGrant,
    LPINET_INFO_IP_SEC_LIST pInfo,
    ADDRESS_CHECK *pCheck
    )
/*++

Routine Description:

    Fill an access check object from an IP address list from

Arguments:

    fIsGrant - TRUE to access grant list, FALSE to access deny list
    pInfo - ptr to IP address list
    pCheck - ptr to address check object to update

Return:

    TRUE if success, otherwise FALSE

--*/
{
    UINT    x;

    if ( pInfo )
    {
        for ( x = 0 ; x < pInfo->cEntries ; ++x )
        {
            if ( ! pCheck->AddAddr( fIsGrant,
                                    AF_INET,
                                    (LPBYTE)&pInfo->aIPSecEntry[x].dwMask,
                                    (LPBYTE)&pInfo->aIPSecEntry[x].dwNetwork ) )
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

DWORD
MigrateServiceIpSec(
    LPWSTR  pszSrvRegKey,
    LPWSTR  pszSrvMetabasePath
    )
{
    INETA_IP_SEC_LIST*  pGrant = NULL;
    INETA_IP_SEC_LIST*  pDeny = NULL;
    ADDRESS_CHECK       acCheck;
    DWORD               err = 0;

    if ( ReadIPList( pszSrvRegKey, IPSEC_GRANT_LIST, &pGrant ) &&
         ReadIPList( pszSrvRegKey, IPSEC_DENY_LIST, &pDeny ) )
    {
        if ( pGrant || pDeny )
        {
            acCheck.BindCheckList( NULL, 0 );

            if ( FillAddrCheckFromIpList( TRUE, pGrant, &acCheck ) &&
                 FillAddrCheckFromIpList( FALSE, pDeny, &acCheck ) )
            {
                CMDKey cmdKey;
                cmdKey.OpenNode(pszSrvMetabasePath);
                if ( (METADATA_HANDLE)cmdKey ) {
                        cmdKey.SetData(
                            MD_IP_SEC,
                            METADATA_INHERIT | METADATA_REFERENCE,
                            IIS_MD_UT_FILE,
                            BINARY_METADATA,
                            acCheck.GetStorage()->GetUsed(),
                            (acCheck.GetStorage()->GetAlloc()
                                          ? acCheck.GetStorage()->GetAlloc() : (LPBYTE)"")
                                      );
                    cmdKey.Close();
                }
            }
        }

        acCheck.UnbindCheckList();
    }
    else
    {
        err = GetLastError();
    }

    if ( pGrant )
    {
        LocalFree( pGrant );
    }

    if ( pDeny )
    {
        LocalFree( pDeny );
    }

    return err;
}

VOID SetLocalHostRestriction(LPCTSTR szKeyPath)
{
    DWORD dwReturn = 0;
    ADDRESS_CHECK       acCheck;

    iisDebugOut_Start1(_T("SetLocalHostRestriction"), (LPTSTR) szKeyPath, LOG_TYPE_TRACE);

    acCheck.BindCheckList( NULL, 0 );
    acCheck.AddAddr(TRUE, AF_INET, (LPBYTE)"\xff\xff\xff\xff", (LPBYTE)"\x7f\x0\x0\x1");

    MDEntry stMDEntry;
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)szKeyPath;
    stMDEntry.dwMDIdentifier = MD_IP_SEC;
    stMDEntry.dwMDAttributes = METADATA_INHERIT | METADATA_REFERENCE;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = BINARY_METADATA;
    stMDEntry.dwMDDataLen = acCheck.GetStorage()->GetUsed();
    if (acCheck.GetStorage()->GetAlloc())
    {
        stMDEntry.pbMDData = (LPBYTE) acCheck.GetStorage()->GetAlloc();
        dwReturn = SetMDEntry_Wrap(&stMDEntry);
    }
    else
    {
        stMDEntry.pbMDData = (LPBYTE) "";

        int iBeforeValue = FALSE;
        iBeforeValue = g_CheckIfMetabaseValueWasWritten;
        g_CheckIfMetabaseValueWasWritten = FALSE;
        dwReturn = SetMDEntry_Wrap(&stMDEntry);
        // Set the flag back after calling the function
        g_CheckIfMetabaseValueWasWritten = iBeforeValue;
    }
    /*
    CMDKey cmdKey;
    cmdKey.OpenNode(szKeyPath);
    if ( (METADATA_HANDLE)cmdKey ) 
    {
        cmdKey.SetData(MD_IP_SEC,METADATA_INHERIT | METADATA_REFERENCE,IIS_MD_UT_FILE,BINARY_METADATA,acCheck.GetStorage()->GetUsed(),(acCheck.GetStorage()->GetAlloc()? acCheck.GetStorage()->GetAlloc() : (LPBYTE)"")  );
        cmdKey.Close();
   }
   */
   acCheck.UnbindCheckList();
   iisDebugOut_End1(_T("SetLocalHostRestriction"), (LPTSTR) szKeyPath, LOG_TYPE_TRACE);
   return;
}

DWORD SetIISADMINRestriction(LPCTSTR szKeyPath)
{
    SetLocalHostRestriction(szKeyPath);
    return 0;
}

#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\itemlist.cpp ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

        itemlist.cpp

   Abstract:

        Class to parse different parameters coming in from the inf

   Author:

        Christopher Achille (cachille)

   Project:

        Internet Services Setup

   Revision History:
     
       June 2001: Created

--*/

#include "stdafx.h"

// Constructor for CItemList
//
// Initialize everything to NULL's and 0's
CItemList::CItemList()
 : m_dwItemsinList(0),
   m_pItems(NULL)
{

}

// Destructor for CItemList
//
// 
CItemList::~CItemList()
{
  if ( m_pItems )
  {
    delete m_pItems;
    m_pItems = NULL;
  }
}

// function: LoadList
//
// Load a list of items into our array
//
// Parameters:
//   szList - A string containind a comma seperated list of items
//
// Return:
//   FALSE - We could not load the list (either memory problems, or it was 
//                                       incorrectly formatted)
//   TRUE - We loaded the list
//
BOOL
CItemList::LoadList(LPTSTR szList)
{
  DWORD dwNumItems = 0;
  DWORD dwCurrentItem;
  DWORD dwListLen;
  LPTSTR szListCurrent;

  if (szList == NULL)
  {
    // No pointer was passed in
    return FALSE;
  }

  // Find the number of items in list
  szListCurrent = szList;
  while (szListCurrent)
  {
    // Increment the Items
    dwNumItems++;

    szListCurrent = _tcsstr(szListCurrent, ITEMLIST_TERMINATIONCHARACTER);

    if (szListCurrent)
    {
      szListCurrent++;
    }
  }

  dwListLen = (_tcslen(szList) + 1) * sizeof(TCHAR);
  if ( !m_Buff.Resize( dwListLen ) )
  {
    // Could not allocate memory
    return FALSE;
  }

  m_pItems = new ( LPTSTR[dwNumItems] );
  if ( !m_pItems )
  {
    // Could not allocate memory
    return FALSE;
  }

  // Copy the List into our own memory
  memcpy(m_Buff.QueryPtr(), szList, dwListLen);
  m_dwItemsinList = dwNumItems;

  // Terminate each item in list, and set pointer accordingly
  szListCurrent = (LPTSTR) m_Buff.QueryPtr();
  dwCurrentItem = 0;
  while (szListCurrent)
  {
    // Set pointer for each item
    m_pItems[dwCurrentItem++] = szListCurrent;

    szListCurrent = _tcsstr(szListCurrent, ITEMLIST_TERMINATIONCHARACTER);

    if (szListCurrent)
    {
      *szListCurrent = '\0';
      szListCurrent++;
    }
  }

  return TRUE;
}

// function: GetItem
//
// Get an item in the list, according to its index
//
// Parameters
//   dwIndex - Index of the Item (0 Based)
//
// Return:
//   A Pointer to the begining of that string

LPTSTR 
CItemList::GetItem(DWORD dwIndex)
{
  if ( dwIndex >= m_dwItemsinList )
  {
    return NULL;
  }

  return m_pItems[dwIndex];
}

// function: GetNumberOfItems
// 
// return the number of items in the list
//
DWORD 
CItemList::GetNumberOfItems()
{
  return m_dwItemsinList;
}

// function: FindItem
//
// Find an Item in the list
//
// Parameters:
//   szSearchString - The string that we want to find
// 
// Return
//   TRUE - It was found
//   FALSE - It was not found
BOOL 
CItemList::FindItem(LPTSTR szSearchString, BOOL bCaseSensitive )
{
  DWORD dwCurrentItem;

  for ( dwCurrentItem = 0; dwCurrentItem < m_dwItemsinList; dwCurrentItem++ )
  {
    if ( bCaseSensitive )
    { 
      // Case Sensitive Compare
      if ( _tcscmp( m_pItems[dwCurrentItem], szSearchString ) == 0)
      {
        // Found item
        return TRUE;
      }
    }
    else
    { 
      // Case Insensitive Compare
      if ( _tcsicmp( m_pItems[dwCurrentItem], szSearchString ) == 0)
      {
        // Found item
        return TRUE;
      }
    }
  }

  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\log.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "log.h"


// critical section needed to safely write to the logfile
CRITICAL_SECTION        critical_section;


//***************************************************************************
//*                                                                         
//* purpose: constructor
//*
//***************************************************************************
MyLogFile::MyLogFile(void)
{
	_tcscpy(m_szLogFileName, _T(""));
	_tcscpy(m_szLogFileName_Full, _T(""));
	_tcscpy(m_szLogPreLineInfo, _T(""));
	_tcscpy(m_szLogPreLineInfo2, _T(""));
	m_bDisplayTimeStamp = TRUE;
	m_bDisplayPreLineInfo = TRUE;
    m_bFlushLogToDisk = FALSE;

	m_hFile = NULL;

	// initialize the critical section
	INITIALIZE_CRITICAL_SECTION( &critical_section );
}

//***************************************************************************
//*                                                                         
//* purpose: destructor
//*
//***************************************************************************
MyLogFile::~MyLogFile(void)
{
	DeleteCriticalSection( &critical_section );
}


//***************************************************************************
//*                                                                         
//* purpose:
//*
//***************************************************************************
int MyLogFile::LogFileCreate(TCHAR *lpLogFileName )
{
	int iReturn = FALSE;
	TCHAR szDrive_only[_MAX_DRIVE];
	TCHAR szPath_only[_MAX_PATH];
	TCHAR szFilename_only[_MAX_PATH];
	TCHAR szFilename_bak[_MAX_PATH];
	LPWSTR  pwsz = NULL;

	// because of the global flags and such, we'll make this critical
	EnterCriticalSection( &critical_section );

	if (lpLogFileName == NULL)
	{
		TCHAR szModuleFileName[_MAX_PATH];

		// if a logfilename was not specified then use the module name.
        if (0 == GetModuleFileName(NULL, szModuleFileName, _MAX_PATH))
        {
            _tcscpy(szFilename_only, _T("iis.log"));
        }
        else
        {
		    // get only the filename
		    _tsplitpath( szModuleFileName, NULL, NULL, szFilename_only, NULL);
		    _tcscat(szFilename_only, _T(".LOG"));
        }

		_tcscpy(m_szLogFileName, szFilename_only);
	}
	else
	{
		_tcscpy(m_szLogFileName, lpLogFileName);
	}

	if (GetWindowsDirectory(m_szLogFileName_Full, sizeof(m_szLogFileName_Full)/sizeof(TCHAR)))
    {
        AddPath(m_szLogFileName_Full, m_szLogFileName);
        if (GetFileAttributes(m_szLogFileName_Full) != 0xFFFFFFFF)
        {
            // there is a current .log file already there.
            // if it is larger than 2megs then rename it.
            DWORD dwSize1 = ReturnFileSize(m_szLogFileName_Full);
            if (dwSize1 == 0xFFFFFFFF || dwSize1 > 2000000)
            {
                // unable to retrieve the size of one of those files
                // or the size is bigger than 2megs.
                // backup the old one.

                // Make a backup of the current log file
			    _tsplitpath( m_szLogFileName_Full, szDrive_only, szPath_only, szFilename_only, NULL);

			    _tcscpy(szFilename_bak, szDrive_only);
			    _tcscat(szFilename_bak, szPath_only);
			    _tcscat(szFilename_bak, szFilename_only);
                _tcscat(szFilename_bak, _T(".BAK"));

                SetFileAttributes(szFilename_bak, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(szFilename_bak);
                if (MoveFile(m_szLogFileName_Full, szFilename_bak) == 0)
			    {
				    // This failed
                    //MyMessageBox(NULL,_T("LogFile MoveFile Failed"),_T("LogFile Error"), MB_OK | MB_SETFOREGROUND);
			    }
            }
        }

#if defined(UNICODE) || defined(_UNICODE)
	pwsz = m_szLogFileName_Full;
#else
	pwsz = MakeWideStrFromAnsi( m_szLogFileName_Full);
#endif

        // Open existing file or create a new one.
		m_hFile = CreateFile(m_szLogFileName_Full,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
		if (m_hFile == INVALID_HANDLE_VALUE)
		{
			m_hFile = NULL;
			//MyMessageBox(NULL, _T("Unable to create iis setup log file"), _T("LogFile Error"), MB_OK | MB_SETFOREGROUND);
		}
		else 
		{
            SetFilePointer( m_hFile, NULL, NULL, FILE_END );
			iReturn = TRUE;
		}

		//LogFileTimeStamp();
		LogFileWrite(_T("LogFile Open. [***** Search on FAIL/MessageBox keywords for failures *****].\r\n"));
	}


	// safe to leave the critical section
	LeaveCriticalSection( &critical_section );

	return iReturn;
}


//***************************************************************************
//*                                                                         
//* purpose:
//*
//***************************************************************************
int MyLogFile::LogFileClose(void)
{
	if (m_hFile)
	{
		LogFileWrite(_T("LogFile Close.\r\n"));
		CloseHandle(m_hFile);
		return TRUE;
	}
	return FALSE;
}


//***************************************************************************
//*                                                                         
//* purpose: add stuff to logfile
//*
//***************************************************************************
void MyLogFile::LogFileTimeStamp()
{
    SYSTEMTIME  SystemTime;
    GetLocalTime(&SystemTime);
	m_bDisplayTimeStamp = FALSE;
	m_bDisplayPreLineInfo = FALSE;
    LogFileWrite(_T("[%d/%d/%d %d:%d:%d]\r\n"),SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
	m_bDisplayTimeStamp = TRUE;
	m_bDisplayPreLineInfo = TRUE;
}


//***************************************************************************
//*                                                                         
//* purpose: 
//* 
//***************************************************************************
#define LOG_STRING_LEN 1000
void MyLogFile::LogFileWrite(TCHAR *pszFormatString, ...)
{
    if (m_hFile)
    {
       // because of the global flags and such, we'll make this critical
       EnterCriticalSection( &critical_section );

       va_list args;
       TCHAR pszFullErrMsg[LOG_STRING_LEN];
       char  pszFullErrMsgA[LOG_STRING_LEN];
       strcpy(pszFullErrMsgA, "");

       DWORD dwBytesWritten = 0;

       if (_tcslen(pszFormatString) > LOG_STRING_LEN)
       {
         // this will overrun our buffer, just get out
         goto MyLogFile_LogFileWrite_Exit;
       }

       __try
       {
           va_start(args, pszFormatString);
           if (!_vsntprintf(pszFullErrMsg, LOG_STRING_LEN, pszFormatString, args))
           {
             goto MyLogFile_LogFileWrite_Exit;
           }
            va_end(args);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            goto MyLogFile_LogFileWrite_Exit;
        }

        if (pszFullErrMsg)
        {
#if defined(UNICODE) || defined(_UNICODE)
	// convert to ascii then write to stream
    WideCharToMultiByte( CP_ACP, 0, (TCHAR *)pszFullErrMsg, -1, pszFullErrMsgA, LOG_STRING_LEN, NULL, NULL );
#else
	// the is already ascii so just copy the pointer
	strcpy(pszFullErrMsgA,pszFullErrMsg);
#endif

			// If the Display timestap is set then display the timestamp
			if (m_bDisplayTimeStamp == TRUE)
			{
				// Get timestamp
				SYSTEMTIME  SystemTime;
				GetLocalTime(&SystemTime);
				char szDateandtime[50];
				sprintf(szDateandtime,"[%d/%d/%d %d:%d:%d] ",SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
				// Write time to stream
				if (m_hFile) {WriteFile(m_hFile,szDateandtime,strlen(szDateandtime),&dwBytesWritten,NULL);}
			}

			char szPrelineWriteString[100];
			char szPrelineWriteString2[100];

			// If the Display timestap is set then display the timestamp
			if (m_bDisplayPreLineInfo == TRUE)
			{
				if (_tcscmp(m_szLogPreLineInfo,_T("")) != 0)
				{
#if defined(UNICODE) || defined(_UNICODE)
					// convert to ascii
					WideCharToMultiByte( CP_ACP, 0, (TCHAR *)m_szLogPreLineInfo, -1, szPrelineWriteString, 100, NULL, NULL );
#else
					// the is already ascii so just copy
					strcpy(szPrelineWriteString, m_szLogPreLineInfo);
#endif
					if (m_hFile) {WriteFile(m_hFile,szPrelineWriteString,strlen(szPrelineWriteString),&dwBytesWritten,NULL);}
				}

				if (_tcscmp(m_szLogPreLineInfo2,_T("")) != 0)
				{
#if defined(UNICODE) || defined(_UNICODE)
					// convert to ascii
					WideCharToMultiByte( CP_ACP, 0, (TCHAR *)m_szLogPreLineInfo2, -1, szPrelineWriteString2, 100, NULL, NULL );
#else
					// the is already ascii so just copy
					strcpy(szPrelineWriteString2, m_szLogPreLineInfo2);
#endif
					if (m_hFile) {WriteFile(m_hFile,szPrelineWriteString2,strlen(szPrelineWriteString2),&dwBytesWritten,NULL);}
				}
			}

			// if it does not end if '\r\n' then make one.
			int nLen = strlen(pszFullErrMsgA);

			if (pszFullErrMsgA[nLen-1] != '\n')
				{strcat(pszFullErrMsgA, "\r\n");}
			else
			{
				if (pszFullErrMsgA[nLen-2] != '\r') 
					{
					char * pPointer = NULL;
					pPointer = pszFullErrMsgA + (nLen-1);
					strcpy(pPointer, "\r\n");
					}
			}


			// Write Regular data to stream
			if (m_hFile) 
            {
                WriteFile(m_hFile,pszFullErrMsgA,strlen(pszFullErrMsgA),&dwBytesWritten,NULL);
                // since setup can get the rug pulled out from under it from anything
                // make sure the file is flushed to disk
                if (m_bFlushLogToDisk)
                {
                    FlushFileBuffers(m_hFile);
                }
            }
        }

MyLogFile_LogFileWrite_Exit:
		// safe to leave the critical section
		LeaveCriticalSection( &critical_section );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\kill.cpp ===
#include "stdafx.h"
#include <windows.h>
#include <winuserp.h>
#include <winperf.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "kill.h"


PUCHAR  g_CommonLargeBuffer = NULL;
ULONG   g_CommonLargeBufferSize = 64*1024;

DWORD
GetTaskListEx(
    PTASK_LIST                          pTask,
    DWORD                               dwNumTasks,
    BOOL                                fThreadInfo,
    DWORD                               dwNumServices,
    const _ENUM_SERVICE_STATUS_PROCESSA* pServiceInfo
    )

/*++

Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses internal NT apis and data structures.  This
    api is MUCH faster that the non-internal version that uses the registry.

Arguments:
    pTask           - Array of TASK_LIST structures to fill.
    dwNumTasks      - Maximum number of tasks that the pTask array can hold.
    fThreadInfo     - TRUE if thread information is desired.
    dwNumServices   - Maximum number of entries in pServiceInfo.
    pServiceInfo    - Array of service status structures to reference
                      for supporting services in processes.

Return Value:

    Number of tasks placed into the pTask array.

--*/
{
#ifndef _CHICAGO_
    PSYSTEM_PROCESS_INFORMATION  ProcessInfo = NULL;
    NTSTATUS                     status;
    ANSI_STRING                  pname;
    PCHAR                        p = NULL;
    
    ULONG                        TotalOffset;
    ULONG                        totalTasks = 0;

retry:

    if (g_CommonLargeBuffer == NULL) 
    {
        g_CommonLargeBuffer = (PUCHAR) VirtualAlloc(NULL,g_CommonLargeBufferSize,MEM_COMMIT,PAGE_READWRITE);
        if (g_CommonLargeBuffer == NULL) 
        {
            return 0;
        }
    }
    status = NtQuerySystemInformation(SystemProcessInformation,g_CommonLargeBuffer,g_CommonLargeBufferSize,NULL);

    if (status == STATUS_INFO_LENGTH_MISMATCH) 
    {
        g_CommonLargeBufferSize += 8192;
        VirtualFree (g_CommonLargeBuffer, 0, MEM_RELEASE);
        g_CommonLargeBuffer = NULL;
        goto retry;
    }

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) g_CommonLargeBuffer;
    TotalOffset = 0;
    while (TRUE) 
    {
        pname.Buffer = NULL;
        if ( ProcessInfo->ImageName.Buffer ) 
        {
            RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
            if (pname.Buffer) 
            {
                p = strrchr(pname.Buffer,'\\');
                if ( p ) 
                {
                    p++;
                }
                else 
                {
                    p = pname.Buffer;
                }
            }
            else 
            {
                p = "";
            }
        }
        else 
        {
            p = "System Process";
        }

        strcpy( pTask->ProcessName, p );
       
        pTask->flags = 0;
        pTask->dwProcessId = (DWORD)(DWORD_PTR)ProcessInfo->UniqueProcessId;
        pTask->dwInheritedFromProcessId = (DWORD)(DWORD_PTR)ProcessInfo->InheritedFromUniqueProcessId;
        pTask->CreateTime.QuadPart = (ULONGLONG)ProcessInfo->CreateTime.QuadPart;

        pTask->PeakVirtualSize = ProcessInfo->PeakVirtualSize;
        pTask->VirtualSize = ProcessInfo->VirtualSize;
        pTask->PageFaultCount = ProcessInfo->PageFaultCount;
        pTask->PeakWorkingSetSize = ProcessInfo->PeakWorkingSetSize;
        pTask->WorkingSetSize = ProcessInfo->WorkingSetSize;
        pTask->NumberOfThreads = ProcessInfo->NumberOfThreads;

        if (fThreadInfo) 
        {
            if (pTask->pThreadInfo = (PTHREAD_INFO) malloc(pTask->NumberOfThreads * sizeof(THREAD_INFO))) {

                UINT nThread = pTask->NumberOfThreads;
                PTHREAD_INFO pThreadInfo = pTask->pThreadInfo;
                PSYSTEM_THREAD_INFORMATION pSysThreadInfo =
                    (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);

                while (nThread--) {
                    pThreadInfo->ThreadState = pSysThreadInfo->ThreadState;
                    pThreadInfo->UniqueThread = pSysThreadInfo->ClientId.UniqueThread;

                    pThreadInfo++;
                    pSysThreadInfo++;
                }
            }
        }
        else 
        {
            pTask->pThreadInfo = NULL;
        }

        // Initialize the ServiceNames if this task hosts any.
        //
        *pTask->ServiceNames = 0;
        if (dwNumServices)
        {
            // For each service with this process id, append it's service
            // name to the buffer.  Separate each with a comma.
            //
            BOOL    fFirstTime = TRUE;
            DWORD   iSvc;
            size_t  cchRemain = SERVICENAMES_SIZE - 1;
            size_t  cch;

            for (iSvc = 0; iSvc < dwNumServices; iSvc++) {
                if (pTask->dwProcessId == pServiceInfo[iSvc].ServiceStatusProcess.dwProcessId) {
                    cch = strlen(pServiceInfo[iSvc].lpServiceName);

                    if (fFirstTime) {
                        fFirstTime = FALSE;

                        strncpy(
                            pTask->ServiceNames,
                            pServiceInfo[iSvc].lpServiceName,
                            cchRemain);

                        // strncpy may not terminate the string if
                        // cchRemain <= cch so we do it regardless.
                        //
                        pTask->ServiceNames[cchRemain] = 0;
                    } else if (cchRemain > 1) { // ensure room for the comma
                        strncat(
                            pTask->ServiceNames,
                            ",",
                            cchRemain--);

                        strncat(
                            pTask->ServiceNames,
                            pServiceInfo[iSvc].lpServiceName,
                            cchRemain);
                    }

                    // Counts are unsigned so we have to check before
                    // subtracting.
                    //
                    if (cchRemain < cch) {
                        // No more room for any more.
                        break;
                    } else {
                        cchRemain -= cch;
                    }
                }
            }
        }

        pTask++;
        totalTasks++;
        if (totalTasks >= dwNumTasks) 
        {
            break;
        }
        if (ProcessInfo->NextEntryOffset == 0) 
        {
            break;
        }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&g_CommonLargeBuffer[TotalOffset];
    }

    return totalTasks;
#else
    return 0;
#endif
}

DWORD
GetTaskList(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    )
{
    return GetTaskListEx(pTask, dwNumTasks, FALSE, 0, NULL);
}

void FreeTaskListMem(void)
{
    if (g_CommonLargeBuffer)
    {
        VirtualFree (g_CommonLargeBuffer, 0, MEM_RELEASE);
        g_CommonLargeBuffer = NULL;
    }
    return;
}
BOOL DetectOrphans(PTASK_LIST pTask,DWORD dwNumTasks)
{
    DWORD i, j;
    BOOL Result = FALSE;

    for (i=0; i<dwNumTasks; i++) {
        if (pTask[i].dwInheritedFromProcessId != 0) {
            for (j=0; j<dwNumTasks; j++) {
                if (i != j && pTask[i].dwInheritedFromProcessId == pTask[j].dwProcessId) {
                    if (pTask[i].CreateTime.QuadPart <= pTask[j].CreateTime.QuadPart) {
                        pTask[i].dwInheritedFromProcessId = 0;
                        Result = TRUE;
                        }

                    break;
                    }
                }
            }
        }

    return Result;
}

/*++
Routine Description:
    Changes the tlist process's privilige so that kill works properly.
Return Value:
    TRUE             - success
    FALSE            - failure

--*/
BOOL EnableDebugPriv(VOID)
{
    HANDLE hToken;
    LUID DebugValue;
    TOKEN_PRIVILEGES tkp;

    //
    // Retrieve a handle of the access token
    //
    if (!OpenProcessToken(GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &hToken)) {
        //printf("OpenProcessToken failed with %d\n", GetLastError());
        return FALSE;
    }

    //
    // Enable the SE_DEBUG_NAME privilege or disable
    // all privileges, depending on the fEnable flag.
    //
    //if (!LookupPrivilegeValue((LPSTR) NULL,SE_DEBUG_NAME,&DebugValue))
    if (!LookupPrivilegeValueA((LPSTR) NULL,"SeDebugPrivilege",&DebugValue))
    {
        //printf("LookupPrivilegeValue failed with %d\n", GetLastError());
        return FALSE;
    }

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = DebugValue;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tkp,
            sizeof(TOKEN_PRIVILEGES),
            (PTOKEN_PRIVILEGES) NULL,
            (PDWORD) NULL)) {
        //
        // The return value of AdjustTokenPrivileges be texted
        //
        //printf("AdjustTokenPrivileges failed with %d\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

BOOL KillProcess(PTASK_LIST tlist,BOOL fForce)
{
    HANDLE            hProcess1 = NULL;
    HANDLE            hProcess2 = NULL;
    HDESK             hdeskSave = NULL;
    HDESK             hdesk = NULL;
    HWINSTA           hwinsta = NULL;
    HWINSTA           hwinstaSave = NULL;

    if (fForce || !tlist->hwnd) {
        hProcess1 = OpenProcess( PROCESS_ALL_ACCESS, FALSE, (DWORD) (DWORD_PTR) tlist->dwProcessId );
        if (hProcess1) 
        {
            hProcess2 = OpenProcess( PROCESS_ALL_ACCESS, FALSE, (DWORD) (DWORD_PTR) tlist->dwProcessId );
            if (hProcess2 == NULL) 
            {
                // clean up memory already allocated
                CloseHandle( hProcess1 );
                return FALSE;
            }

            if (!TerminateProcess( hProcess2, 1 )) 
            {
                CloseHandle( hProcess1 );
                CloseHandle( hProcess2 );
                return FALSE;
            }

            CloseHandle( hProcess1 );
            CloseHandle( hProcess2 );
            return TRUE;
        }
    }

    //
    // save the current windowstation
    //
    hwinstaSave = GetProcessWindowStation();

    //
    // save the current desktop
    //
    hdeskSave = GetThreadDesktop( GetCurrentThreadId() );

    //
    // open the windowstation
    //
    hwinsta = OpenWindowStationA( tlist->lpWinsta, FALSE, MAXIMUM_ALLOWED );
    if (!hwinsta) {
        return FALSE;
    }

    //
    // change the context to the new windowstation
    //
    SetProcessWindowStation( hwinsta );

    //
    // open the desktop
    //
    hdesk = OpenDesktopA( tlist->lpDesk, 0, FALSE, MAXIMUM_ALLOWED );
    if (!hdesk) {
        return FALSE;
    }

    //
    // change the context to the new desktop
    //
    SetThreadDesktop( hdesk );

    //
    // kill the process
    //
    PostMessage( (HWND) tlist->hwnd, WM_CLOSE, 0, 0 );

    //
    // restore the previous desktop
    //
    if (hdesk != hdeskSave) {
        SetThreadDesktop( hdeskSave );
        CloseDesktop( hdesk );
    }

    //
    // restore the context to the previous windowstation
    //
    if (hwinsta != hwinstaSave) {
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hwinsta );
    }

    return TRUE;
}


VOID GetWindowTitles(PTASK_LIST_ENUM te)
{
    //
    // enumerate all windows and try to get the window
    // titles for each task
    //
    EnumWindowStations( (WINSTAENUMPROC) EnumWindowStationsFunc, (LPARAM)te );
}


/*++
Routine Description:
    Callback function for windowstation enumeration.
Arguments:
    lpstr            - windowstation name
    lParam           - ** not used **
Return Value:
    TRUE  - continues the enumeration
--*/
BOOL CALLBACK EnumWindowStationsFunc(LPSTR lpstr,LPARAM lParam)
{
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    HWINSTA           hwinsta;
    HWINSTA           hwinstaSave;


    //
    // open the windowstation
    //
    hwinsta = OpenWindowStationA( lpstr, FALSE, MAXIMUM_ALLOWED );
    if (!hwinsta) {
        return FALSE;
    }

    //
    // save the current windowstation
    //
    hwinstaSave = GetProcessWindowStation();

    //
    // change the context to the new windowstation
    //
    SetProcessWindowStation( hwinsta );

    te->lpWinsta = _strdup( lpstr );

    //
    // enumerate all the desktops for this windowstation
    //
    EnumDesktops( hwinsta, (DESKTOPENUMPROC) EnumDesktopsFunc, lParam );

    //
    // restore the context to the previous windowstation
    //
    if (hwinsta != hwinstaSave) {
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hwinsta );
    }

    //
    // continue the enumeration
    //
    return TRUE;
}


/*++
Routine Description:
    Callback function for desktop enumeration.
Arguments:
    lpstr            - desktop name
    lParam           - ** not used **
Return Value:
    TRUE  - continues the enumeration

--*/
BOOL CALLBACK EnumDesktopsFunc(LPSTR  lpstr,LPARAM lParam)
{
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    HDESK             hdeskSave;
    HDESK             hdesk;


    //
    // open the desktop
    //
    hdesk = OpenDesktopA( lpstr, 0, FALSE, MAXIMUM_ALLOWED );
    if (!hdesk) {
        return FALSE;
    }

    //
    // save the current desktop
    //
    hdeskSave = GetThreadDesktop( GetCurrentThreadId() );

    //
    // change the context to the new desktop
    //
    SetThreadDesktop( hdesk );

    te->lpDesk = _strdup( lpstr );

    //
    // enumerate all windows in the new desktop
    //

    ((PTASK_LIST_ENUM)lParam)->bFirstLoop = TRUE;
    EnumWindows( (WNDENUMPROC)EnumWindowsProc, lParam );

    ((PTASK_LIST_ENUM)lParam)->bFirstLoop = FALSE;
    EnumWindows( (WNDENUMPROC)EnumWindowsProc, lParam );

    //
    // restore the previous desktop
    //
    if (hdesk != hdeskSave) {
        SetThreadDesktop( hdeskSave );
        CloseDesktop( hdesk );
    }

    return TRUE;
}


/*++
Routine Description:
    Callback function for window enumeration.
Arguments:
    hwnd             - window handle
    lParam           - pte
Return Value:
    TRUE  - continues the enumeration
--*/
BOOL CALLBACK EnumWindowsProc(HWND hwnd,LPARAM lParam)
{
    DWORD             pid = 0;
    DWORD             i;
    CHAR              buf[TITLE_SIZE];
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    PTASK_LIST        tlist = te->tlist;
    DWORD             numTasks = te->numtasks;


    //
    // Use try/except block when enumerating windows,
    // as a window may be destroyed by another thread
    // when being enumerated.
    //
    //try {
        //
        // get the processid for this window
        //
        if (!GetWindowThreadProcessId( hwnd, &pid )) {
            return TRUE;
        }

        if ((GetWindow( hwnd, GW_OWNER )) ||
            (!(GetWindowLong(hwnd, GWL_STYLE) & WS_VISIBLE)) && te->bFirstLoop) {
            //
            // not a top level window
            //
            return TRUE;
        }

        //
        // look for the task in the task list for this window
        // If this is the second time let invisible windows through if we don't
        // have a window already
        //
        for (i=0; i<numTasks; i++) {
            if (((DWORD) (DWORD_PTR)tlist[i].dwProcessId == pid) && (te->bFirstLoop || (tlist[i].hwnd == 0))) {
                tlist[i].hwnd = hwnd;
                tlist[i].lpWinsta = te->lpWinsta;
                tlist[i].lpDesk = te->lpDesk;
                //
                // we found the task no lets try to get the
                // window text
                //
                if (GetWindowTextA( (HWND) tlist[i].hwnd, buf, sizeof(buf) )) {
                    //
                    // go it, so lets save it
                    //
                    lstrcpyA( tlist[i].WindowTitle, buf );
                }
                break;
            }
        }
    //} except(EXCEPTION_EXECUTE_HANDLER) {
    //}

    //
    // continue the enumeration
    //
    return TRUE;
}


BOOL MatchPattern(PUCHAR String,PUCHAR Pattern)
{
    UCHAR   c, p, l;

    for (; ;) {
        switch (p = *Pattern++) {
            case 0:                             // end of pattern
                return *String ? FALSE : TRUE;  // if end of string TRUE

            case '*':
                while (*String) {               // match zero or more char
                    if (MatchPattern (String++, Pattern))
                        return TRUE;
                }
                return MatchPattern (String, Pattern);

            case '?':
                if (*String++ == 0)             // match any one char
                    return FALSE;                   // not end of string
                break;

            case '[':
                if ( (c = *String++) == 0)      // match char set
                    return FALSE;                   // syntax

                c = (UCHAR)toupper(c);
                l = 0;
                while (p = *Pattern++) {
                    if (p == ']')               // if end of char set, then
                        return FALSE;           // no match found

                    if (p == '-') {             // check a range of chars?
                        p = *Pattern;           // get high limit of range
                        if (p == 0  ||  p == ']')
                            return FALSE;           // syntax

                        if (c >= l  &&  c <= p)
                            break;              // if in range, move on
                    }

                    l = p;
                    if (c == p)                 // if char matches this element
                        break;                  // move on
                }

                while (p  &&  p != ']')         // got a match in char set
                    p = *Pattern++;             // skip to end of set

                break;

            default:
                c = *String++;
                if (toupper(c) != p)            // check for exact char
                    return FALSE;                   // not a match

                break;
        }
    }
}


struct _ProcessIDStruct
{
    DWORD pid;
    CHAR pname[MAX_PATH];
} g_Arguments[ 64 ];

DWORD g_dwNumberOfArguments;

int _cdecl KillProcessNameReturn0(CHAR *ProcessNameToKill)
{
    DWORD          i, j;
    DWORD          numTasks;
    TASK_LIST_ENUM te;
    int            rval = 0;
    CHAR           tname[PROCESS_SIZE];
    LPSTR          p;
    DWORD          ThisPid;

    BOOL           iForceKill  = TRUE;
    TASK_LIST      The_TList[MAX_TASKS];

    g_dwNumberOfArguments = 0;
    //
    // Get the process name into the array
    //
    g_Arguments[g_dwNumberOfArguments].pid = 0;

    // make sure there is no path specified.
    char pfilename_only[_MAX_FNAME];
    char pextention_only[_MAX_EXT];
    _splitpath( ProcessNameToKill, NULL, NULL, pfilename_only, pextention_only);
    if (pextention_only) {strcat(pfilename_only,pextention_only);}

    // make it uppercase
    char *copy1 = _strupr(_strdup(pfilename_only));
    lstrcpyA(g_Arguments[g_dwNumberOfArguments].pname, copy1);
    free( copy1 );

    g_dwNumberOfArguments += 1;

    //
    // lets be god
    //
    EnableDebugPriv();

    //
    // get the task list for the system
    //
    numTasks = GetTaskList( The_TList, MAX_TASKS );

    //
    // enumerate all windows and try to get the window
    // titles for each task
    //
    te.tlist = The_TList;
    te.numtasks = numTasks;
    GetWindowTitles( &te );

    ThisPid = GetCurrentProcessId();

    for (i=0; i<numTasks; i++) {
        //
        // this prevents the user from killing KILL.EXE and
        // it's parent cmd window too
        //
        if (ThisPid == (DWORD) (DWORD_PTR) The_TList[i].dwProcessId) {
            continue;
        }
        if (MatchPattern( (PUCHAR) The_TList[i].WindowTitle, (PUCHAR) "*KILL*" )) {
            continue;
        }

        tname[0] = 0;
        lstrcpyA( tname, The_TList[i].ProcessName );
        p = strchr( tname, '.' );
        if (p) {
            p[0] = '\0';
        }

        for (j=0; j<g_dwNumberOfArguments; j++) {
            if (g_Arguments[j].pname) {
                if (MatchPattern( (PUCHAR) tname, (PUCHAR) g_Arguments[j].pname )) {
                    The_TList[i].flags = TRUE;
                } else if (MatchPattern( (PUCHAR) The_TList[i].ProcessName, (PUCHAR) g_Arguments[j].pname )) {
                    The_TList[i].flags = TRUE;
                } else if (MatchPattern( (PUCHAR) The_TList[i].WindowTitle, (PUCHAR) g_Arguments[j].pname )) {
                    The_TList[i].flags = TRUE;
                }
            } else if (g_Arguments[j].pid) {
                    if ((DWORD) (DWORD_PTR) The_TList[i].dwProcessId == g_Arguments[j].pid) {
                        The_TList[i].flags = TRUE;
                    }
            }
        }
    }

    for (i=0; i<numTasks; i++)
        {
        if (The_TList[i].flags)
            {
            if (KillProcess( &The_TList[i], iForceKill ))
                {
                //printf( "process %s (%d) - '%s' killed\n", The_TList[i].ProcessName,The_TList[i].dwProcessId,The_TList[i].hwnd ? The_TList[i].WindowTitle : "");
                }
            else
                {
                //printf( "process %s (%d) - '%s' could not be killed\n",The_TList[i].ProcessName,The_TList[i].dwProcessId,The_TList[i].hwnd ? The_TList[i].WindowTitle : "");
                rval = 1;
                }
            }
        }

    FreeTaskListMem();

    return rval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\log.h ===
#include "stdafx.h"
#include "resource.h"

// Stuff for logfile
LPWSTR	MakeWideStrFromAnsi(LPSTR psz);
void	MakePath(LPTSTR lpPath);
void	AddPath(LPTSTR szPath, LPCTSTR szName );
CString AddPath(CString szPath, LPCTSTR szName );

class MyLogFile
{
protected:
	// for our log file
	TCHAR		m_szLogFileName[MAX_PATH];
	BOOL        m_bDisplayTimeStamp;
	BOOL        m_bDisplayPreLineInfo;

	HANDLE  m_hFile;

public:
    TCHAR		m_szLogFileName_Full[MAX_PATH];

    MyLogFile();
    ~MyLogFile();

	TCHAR		m_szLogPreLineInfo[100];
	TCHAR		m_szLogPreLineInfo2[100];
    BOOL        m_bFlushLogToDisk;
	
	int  LogFileCreate(TCHAR * lpLogFileName);
	int  LogFileClose();

	void LogFileTimeStamp();
	void LogFileWrite(TCHAR * pszFormatString, ...);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\kill.h ===
#pragma once

#if defined(__cplusplus)
extern "C" {
#endif

#define MAX_TASKS           256
#define TITLE_SIZE          128
#define PROCESS_SIZE        16
#define SERVICENAMES_SIZE   256

typedef struct _THREAD_INFO {
    ULONG ThreadState;
    HANDLE UniqueThread;
} THREAD_INFO, *PTHREAD_INFO;

typedef struct _FIND_MODULE_INFO {
    LPSTR  szModuleToFind;
    LPSTR  szMatchingModuleName;
    BOOL   fFound;
} FIND_MODULE_INFO, *PFIND_MODULE_INFO;


//
// task list structure
//
typedef struct _TASK_LIST {
    DWORD       dwProcessId;
    DWORD       dwInheritedFromProcessId;
    ULARGE_INTEGER CreateTime;
    BOOL        flags;
    HANDLE      hwnd;
    LPSTR       lpWinsta;
    LPSTR       lpDesk;
    CHAR        ProcessName[PROCESS_SIZE];
    CHAR        WindowTitle[TITLE_SIZE];
    SIZE_T      PeakVirtualSize;
    SIZE_T      VirtualSize;
    ULONG       PageFaultCount;
    SIZE_T      PeakWorkingSetSize;
    SIZE_T      WorkingSetSize;
    ULONG       NumberOfThreads;
    PTHREAD_INFO pThreadInfo;
    CHAR        ServiceNames[SERVICENAMES_SIZE];
} TASK_LIST, *PTASK_LIST;

typedef struct _TASK_LIST_ENUM {
    PTASK_LIST  tlist;
    DWORD       numtasks;
    LPSTR       lpWinsta;
    LPSTR       lpDesk;
    BOOL        bFirstLoop;
} TASK_LIST_ENUM, *PTASK_LIST_ENUM;


DWORD
GetTaskList(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    );

DWORD
GetTaskListEx(
    PTASK_LIST                          pTask,
    DWORD                               dwNumTasks,
    BOOL                                fThreadInfo,
    DWORD                               dwNumServices,
    const ENUM_SERVICE_STATUS_PROCESSA*  pServiceInfo
    );

BOOL
DetectOrphans(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    );

BOOL
EnableDebugPriv(
    VOID
    );

BOOL
KillProcess(
    PTASK_LIST tlist,
    BOOL       fForce
    );

VOID
GetWindowTitles(
    PTASK_LIST_ENUM te
    );

BOOL
MatchPattern(
    PUCHAR String,
    PUCHAR Pattern
    );

BOOL
EmptyProcessWorkingSet(
    DWORD pid
    );

void FreeTaskListMem(void);

#if defined(__cplusplus)
}
#endif

int _cdecl KillProcessNameReturn0(CHAR *ProcessNameToKill);
BOOL CALLBACK EnumWindowsProc(HWND hwnd,LPARAM lParam);
BOOL CALLBACK EnumWindowStationsFunc(LPSTR lpstr, LPARAM lParam);
BOOL CALLBACK EnumDesktopsFunc(LPSTR lpstr,LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\massupdt.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        massupdt.cpp

   Abstract:

        functions to udpate bunches of properties at once

   Author:

        Boyd Multerer (boydm)

   Project:

        IIS Setup

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include <iis64.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "strfn.h"
#include "mdkey.h"
#include "mdentry.h"
#include "massupdt.h"


//============================================================
// first the Abstract CMassPropertyUpdater class


//============================================================
//=================== CMassPropertyUpdater ===================
//============================================================

//------------------------------------------------------------
CMassPropertyUpdater::CMassPropertyUpdater(
        DWORD dwMDIdentifier,
        DWORD dwMDDataType ) :
    m_dwMDIdentifier( dwMDIdentifier ),
    m_dwMDDataType( dwMDDataType )
{
}

//------------------------------------------------------------
CMassPropertyUpdater::~CMassPropertyUpdater()
{
}

//------------------------------------------------------------
HRESULT CMassPropertyUpdater::Update(
        LPCTSTR strStartNode,
        BOOL fStopOnErrors          OPTIONAL )
{
    HRESULT         hRes;
    CString         szPath;
    POSITION        pos;
    LPWSTR          pwstr;

    // start by getting the list of nodes with script maps on them
    // first open the node that we will start searching on
    hRes = OpenNode( strStartNode );
    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMassPropertyUpdater::Update()-OpenNode failed. err=%x.\n"), hRes));
        return hRes;
    }

    // get the sub-paths that have the data on them
    hRes = GetDataPaths( m_dwMDIdentifier, m_dwMDDataType, m_pathList );
    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMassPropertyUpdater::Update()-GetDataPaths failed. err=%x.\n"), hRes));
        goto cleanup;
    }

    // we now have the cstringlist of paths that need to be updated. Loop through the
    // list and update them all.
    // get the list's head position
    pos = m_pathList.GetHeadPosition();
    while ( NULL != pos )
    {
        // get the next path in question
        szPath = m_pathList.GetNext( pos );

        // make a special case of the "/" path
        if ( szPath == _T("/") )
            szPath.Empty();

        // drat. ANSI stuff is a mess so deal with it here
#ifdef UNICODE
        pwstr = (LPWSTR)(LPCTSTR)szPath;
#else
        pwstr = AllocWideString( szPath );
#endif

        // operate on it
        hRes = UpdateOne( pwstr );

#ifndef UNICODE
        FreeMem( pwstr );
#endif

        // if we are stopping of failures, then check
        if ( FAILED(hRes) )
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMassPropertyUpdater::Update():FAILED: update path =%s.\n"), szPath));

        //if requested to stop the loop, then do so
        if ( fStopOnErrors )
            break;
        }
    }

    // cleanup - close the node once and for all
cleanup:
    Close();

    // return the answer
    return hRes;
}



//============================================================
//==================== CInvertScriptMaps =====================
//============================================================

//------------------------------------------------------------
HRESULT CInvertScriptMaps::UpdateOne( LPWSTR strPath )
{
    HRESULT         hRes;
    POSITION        pos;
    POSITION        posCurrent;
    CString         szMap;

    DWORD dwattributes = 0;

    CStringList cslScriptMaps;

    // get the full script map in question.
    hRes = GetMultiSzAsStringList (
        m_dwMDIdentifier,
        &m_dwMDDataType,
        &dwattributes,
        cslScriptMaps,
        strPath );

    
    //iisDebugOut((LOG_TYPE_ERROR, _T("CInvertScriptMaps::UpdateOne() GetMultiSzAsStringList. Attrib=0x%x.\n"), dwattributes));

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CInvertScriptMaps::UpdateOne()-GetMultiSzAsStringList failed. err=%x.\n"), hRes));
        return hRes;
    }

    // HACK. The first thing we need to do is make sure we haven't already inverted this script
    // map during a previous build-to-build upgrade. If we invert it twice, then we are back
    // to an exclusion list and that would not be desirable. The way to detect this is to see
    // if the GET verb is listed for the ASP script map or not. If it is there, then it has been
    // inverted. This will only be a problem when doing build-to-build upgrades in IIS5.
    pos = cslScriptMaps.GetHeadPosition();
    while ( NULL != pos )
    {
        // get the next path in question
        szMap = cslScriptMaps.GetNext( pos );

        // if it is the .asp scriptmap, then finish the test
        if ( szMap.Left(4) == _T(".asp") )
        {
            if ( szMap.Find(_T("GET")) >= 0 )
            {
                return ERROR_SUCCESS;
            }
            else
            {
                break;
            }
        }

    }

    // we now have the cstringlist of paths that need to be updated. Loop through the
    // list and update them all.
    // get the list's head position
    pos = cslScriptMaps.GetHeadPosition();
    while ( NULL != pos )
    {
        // store the current position
        posCurrent = pos;

        // get the next path in question
        szMap = cslScriptMaps.GetNext( pos );

        // operate on it
        hRes = InvertOneScriptMap( szMap );

        // if that worked, put it back in place
        if ( SUCCEEDED(hRes) )
        {
            cslScriptMaps.SetAt ( posCurrent, szMap );
        }
    }

    //iisDebugOut((LOG_TYPE_ERROR, _T("CInvertScriptMaps::UpdateOne() SetMultiSzAsStringList. Attrib=0x%x.\n"), dwattributes));

    // Put it back.
    hRes = SetMultiSzAsStringList (
        m_dwMDIdentifier,
        m_dwMDDataType,
        dwattributes,
        cslScriptMaps,
        strPath );
    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CInvertScriptMaps::UpdateOne()-SetMultiSzAsStringList failed. err=%x.\n"), hRes));
        return hRes;
    }

    return hRes;
}


//------------------------------------------------------------
HRESULT CInvertScriptMaps::InvertOneScriptMap( CString& csMap )
{
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CInvertScriptMaps::InvertOneScriptMap():%s.start.\n"), csMap));
    // the script mapping is yet another list. This time seperated
    // by commas. The first 4 items are standard and don't get messed
    // with. The n last items are all verbs that need to be inverted.
    int             numParts;
    int             numVerbs;

    CStringList   cslMapParts;
    CStringList   cslVerbs;
    CString         szComma = _T(",");
    CString         szVerb;

    POSITION        posMap;
    POSITION        posVerb;

    // break the source map into a string list
    numParts = ConvertSepLineToStringList(
        csMap,
        cslMapParts,
        szComma
        );

    CString szAllVerbs;
    if (!GetScriptMapAllInclusionVerbs(szAllVerbs))
        {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetScriptMapAllInclusionVerbs():FAIL.WARNING.UseDefaults\n")));
        szAllVerbs = SZ_INVERT_ALL_VERBS;
        }
    

    // start by making a string list with all the verbs to invert against
    numVerbs = ConvertSepLineToStringList(
        SZ_INVERT_ALL_VERBS,
        cslVerbs,
        szComma
        );

    // start with the 3rd indexed item in the source list. This should be the
    // first verb in the old "exclusion" list. Then use it and scan
    // the new "Inclusion" list of verbs. If it is there, rememove it.
    posMap = cslMapParts.FindIndex( 3 );
    while ( NULL != posMap )
    {
        // set to the next verb in the map list
        szVerb = cslMapParts.GetNext( posMap );

        // make sure the verb is normalized to capitals and
        // no whitespace before or after
        szVerb.MakeUpper();
        szVerb.TrimLeft();
        szVerb.TrimRight();

        // try to find the verb in the invertion list
        posVerb = cslVerbs.Find( szVerb );

        // if we found it, remove it
        if ( NULL != posVerb )
        {
            cslVerbs.RemoveAt( posVerb );
        }
    }

    // strip all the verbs off the source list
    while ( cslMapParts.GetCount() > 3 )
    {
        cslMapParts.RemoveTail();
    }

    // combine the lists
    cslMapParts.AddTail( &cslVerbs );    

    // put it back into the comma list
    ConvertStringListToSepLine(
        cslMapParts,
        csMap,
        szComma
        );

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CInvertScriptMaps::InvertOneScriptMap():%s.End.\n"), csMap));
    return ERROR_SUCCESS;
}



//============================================================
//================= CIPSecPhysicalPathFixer ==================
//============================================================


//------------------------------------------------------------
CPhysicalPathFixer::CPhysicalPathFixer( CString& szOldSysPath, CString &szNewSysPath ):
        CMassPropertyUpdater(0, 0),     // bad values on purpose - see Update below...
        m_szOldSysPath( szOldSysPath ),
        m_szNewSysPath( szNewSysPath )
{
    m_szOldSysPath.MakeUpper();
}

//------------------------------------------------------------
HRESULT CPhysicalPathFixer::Update( LPCTSTR strStartNode, BOOL fStopOnErrors )
{
    HRESULT hRes;

    // vrpath -- should we do this too? yes.
    m_dwMDIdentifier = MD_VR_PATH;
    m_dwMDDataType = STRING_METADATA;
    hRes = CMassPropertyUpdater::Update( strStartNode, fStopOnErrors );

    // inproc isapi apps.
    m_dwMDIdentifier = MD_IN_PROCESS_ISAPI_APPS;
    m_dwMDDataType = MULTISZ_METADATA;
    hRes = CMassPropertyUpdater::Update( strStartNode, fStopOnErrors );

    // prepare and update the scriptmappings multi sz strings
    m_dwMDIdentifier = MD_SCRIPT_MAPS;
    m_dwMDDataType = MULTISZ_METADATA;
    hRes = CMassPropertyUpdater::Update( strStartNode, fStopOnErrors );

    // prepare to update the FilterImagePath multi sz strings
    m_dwMDIdentifier = MD_FILTER_IMAGE_PATH;
    m_dwMDDataType = STRING_METADATA;
    hRes = CMassPropertyUpdater::Update( strStartNode, fStopOnErrors );

    // prepare to update the FilterImagePath multi sz strings
    m_dwMDIdentifier = MD_LOGFILE_DIRECTORY;
    m_dwMDDataType = EXPANDSZ_METADATA;
    hRes = CMassPropertyUpdater::Update( strStartNode, fStopOnErrors );

    return hRes;
}

//MD_FILTER_LOAD_ORDER
// in process isapi apps
// custom errors


//------------------------------------------------------------
HRESULT CPhysicalPathFixer2::Update( LPCTSTR strStartNode, BOOL fStopOnErrors )
{
    HRESULT hRes;
    // prepare and update the scriptmappings multi sz strings
    m_dwMDIdentifier = MD_CUSTOM_ERROR;
    m_dwMDDataType = MULTISZ_METADATA;
    hRes = CMassPropertyUpdater::Update( strStartNode, fStopOnErrors );

    return hRes;
}


//------------------------------------------------------------
HRESULT CPhysicalPathFixer::UpdateOne( LPWSTR strPath )
{
    HRESULT hRes = 0xFFFFFFFF;

    if ( m_dwMDDataType == STRING_METADATA )
    {
        hRes = UpdateOneSTRING_DATA( strPath );
    }
    else if ( m_dwMDDataType == MULTISZ_METADATA )
    {
        hRes = UpdateOneMULTISZ_DATA( strPath );
    }
    else if ( m_dwMDDataType == EXPANDSZ_METADATA )
    {
        hRes = UpdateOneSTRING_DATA_EXPAND( strPath );
    }

    return hRes;
}

//------------------------------------------------------------
HRESULT CPhysicalPathFixer::UpdateOneMULTISZ_DATA( LPWSTR strPath )
{
    HRESULT         hRes;
    POSITION        pos;
    POSITION        posCurrent;
    CString         csPath;

    CStringList     cslPaths;
    BOOL            fSomethingChanged = FALSE;

    DWORD dwattributes = 0;

    // get the full script map in question.
    hRes = GetMultiSzAsStringList (
        m_dwMDIdentifier,
        &m_dwMDDataType,
        &dwattributes,
        cslPaths,
        strPath );
    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CIPSecPhysicalPathFixer::UpdateOne()-GetMultiSzAsStringList failed. err=%x.\n"), hRes));
        return hRes;
    }

    // we now have the cstringlist of paths that need to be updated. Loop through the
    // list and update them all.
    // get the list's head position
    pos = cslPaths.GetHeadPosition();
    while ( NULL != pos )
    {
        // store the current position
        posCurrent = pos;

        // get the next path in question
        csPath = cslPaths.GetNext( pos );

        // operate on it
        hRes = UpdateOnePath( csPath );

        // if that worked, put it back in place
        if ( SUCCEEDED(hRes) )
        {
            cslPaths.SetAt ( posCurrent, csPath );
            fSomethingChanged = TRUE;
        }
        // if there was nothing to update..
        if (hRes == 0xFFFFFFFF)
            {hRes = ERROR_SUCCESS;}
    }

    // Put it back. - unless nothing changed
    if ( fSomethingChanged )
    {
        hRes = SetMultiSzAsStringList (
            m_dwMDIdentifier,
            m_dwMDDataType,
            dwattributes,
            cslPaths,
            strPath );
        if ( FAILED(hRes) )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CIPSecPhysicalPathFixer::UpdateOne()-SetMultiSzAsStringList failed. err=%x.\n"), hRes));
            return hRes;
        }
    }

    return hRes;
}


//------------------------------------------------------------
HRESULT CPhysicalPathFixer::UpdateOneSTRING_DATA_EXPAND( LPWSTR strPath )
{
    HRESULT         hRes;
    CString         csPath;
    BOOL            fSomethingChanged = FALSE;

    // get the full script map in question.
    hRes = GetStringAsCString (
        m_dwMDIdentifier,
        m_dwMDDataType,
        NULL,
        csPath,
        strPath,
        1);
    
    if ( MD_ERROR_DATA_NOT_FOUND == hRes)
    {
        hRes = ERROR_SUCCESS;
        return hRes;
    }

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CIPSecPhysicalPathFixer::UpdateOne()-GetMultiSzAsStringList failed. err=%x.\n"), hRes));
        return hRes;
    }

    //iisDebugOut((LOG_TYPE_TRACE, _T("GetStringAsCString:Read.%S\n"), csPath));

    // operate on it
    hRes = UpdateOnePath( csPath );

    // if that worked, put it back in place
    if ( SUCCEEDED(hRes) )
    {
        fSomethingChanged = TRUE;
    }

    // if there was nothing to update..
    if (hRes == 0xFFFFFFFF)
        {hRes = ERROR_SUCCESS;}

    // Put it back. - unless nothing changed
    if ( fSomethingChanged )
    {
        //iisDebugOut((LOG_TYPE_TRACE, _T("GetStringAsCString:write.%S\n"), csPath));
        hRes = SetCStringAsString (
            m_dwMDIdentifier,
            m_dwMDDataType,
            NULL,
            csPath,
            strPath,
            1);
        if ( FAILED(hRes) )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CIPSecPhysicalPathFixer::UpdateOne()-SetMultiSzAsStringList failed. err=%x.\n"), hRes));
            return hRes;
        }
    }

    return hRes;
}

//------------------------------------------------------------
HRESULT CPhysicalPathFixer::UpdateOneSTRING_DATA( LPWSTR strPath )
{
    HRESULT         hRes;
    CString         csPath;
    BOOL            fSomethingChanged = FALSE;

    // get the full script map in question.
    hRes = GetStringAsCString (
        m_dwMDIdentifier,
        m_dwMDDataType,
        NULL,
        csPath,
        strPath,
        0);

    if ( MD_ERROR_DATA_NOT_FOUND == hRes)
    {
        hRes = ERROR_SUCCESS;
        return hRes;
    }

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CIPSecPhysicalPathFixer::UpdateOne()-GetMultiSzAsStringList failed. err=%x.\n"), hRes));
        return hRes;
    }


    // operate on it
    hRes = UpdateOnePath( csPath );

    // if that worked, put it back in place
    if ( SUCCEEDED(hRes) )
    {
        fSomethingChanged = TRUE;
    }

    // if there was nothing to update..
    if (hRes == 0xFFFFFFFF)
        {hRes = ERROR_SUCCESS;}

    // Put it back. - unless nothing changed
    if ( fSomethingChanged )
    {
        hRes = SetCStringAsString (
            m_dwMDIdentifier,
            m_dwMDDataType,
            NULL,
            csPath,
            strPath,
            0);
        if ( FAILED(hRes) )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CIPSecPhysicalPathFixer::UpdateOne()-SetMultiSzAsStringList failed. err=%x.\n"), hRes));
            return hRes;
        }
    }

    return hRes;
}

//------------------------------------------------------------
// note: returns 0xFFFFFFFF if nothing changed
HRESULT CPhysicalPathFixer::UpdateOnePath( CString& csPath )
{
    // buffer the incoming string and make it upper case for the find
    CString csUpper = csPath;
    csUpper.MakeUpper();


    // first, find the old syspath in the csPath
    int iOldPath = csUpper.Find( m_szOldSysPath );

    // if it wasn't there, then return with 0xFFFFFFFF
    if ( iOldPath == -1 )
    {
        return 0xFFFFFFFF;
    }

    // the plan is the build a new string from the old one.
    CString csNewPath;

    // start by copying everything to the left of the substring
    csNewPath = csPath.Left( iOldPath );

    // now add to it the new path
    csNewPath += m_szNewSysPath;

    // now add to that the rest of the string
    csNewPath += csPath.Right( csPath.GetLength() - (iOldPath + m_szOldSysPath.GetLength()) );

    // finally, put the new string into place
    csPath = csNewPath;

    return 0;
}



//============================================================
//==================== CIPSecRefBitAdder =====================
//============================================================

//------------------------------------------------------------
//MD_IP_SEC, BINARY_METADATA
// Unfortunately, at this time there is no way to directly manipulate the
// attribuites on a property in the metabase without reading in
// the actual property data. This could be made much simpler if a IADM level
// method to do this is added to the metabase interface at some point in the
// future.
HRESULT CIPSecRefBitAdder::UpdateOne( LPWSTR strPath )
{
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    DWORD   cbBuffer;


    // get the ipsec data. The loop accounts for a buffer that is too small...
    DWORD  dwMDBufferSize = 1024;
    PWCHAR pwchBuffer = NULL;
    do
    {
        if ( pwchBuffer )
        {
            delete pwchBuffer;
            pwchBuffer = NULL;
        }

        pwchBuffer = new WCHAR[dwMDBufferSize];
        if (pwchBuffer == NULL)
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        // prepare the metadata parameter block
        MD_SET_DATA_RECORD(&mdrData, MD_IP_SEC, 0,
                IIS_MD_UT_FILE, BINARY_METADATA, dwMDBufferSize, pwchBuffer);

        // make the call to get the data
        // If the buffer is too small, the correct size will be put into dwMDBufferSize
        hRes = m_pcCom->GetData(
            m_hKey,
            strPath,
            &mdrData,
            &dwMDBufferSize
            );
    }
    while( HRESULT_CODE(hRes) == ERROR_INSUFFICIENT_BUFFER);

    // if there were any failures, go to the cleanup code now...
    if ( SUCCEEDED(hRes) )
    {
        // at this point we can check to see if the reference bit is part of the attributes.
        // if it is, then we can just clean up. If it isn't, we should add it and write it
        // back out.
        if ( (mdrData.dwMDAttributes & METADATA_REFERENCE) == 0 )
        {
            // the attributes flag is not set. Set it.
            mdrData.dwMDAttributes |= METADATA_REFERENCE;

            // write it back out to the metabase
            hRes = m_pcCom->SetData(
                m_hKey,
                strPath,
                &mdrData
                );
        }
    }

    // clean up
    if ( pwchBuffer )
        delete pwchBuffer;

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CIPSecRefBitAdder::UpdateOne() failed. err=%x.\n"), hRes));
    }

    return hRes;
}



//============================================================
//==================== CFixCustomErrors ======================
//============================================================

HRESULT CustomErrorProcessOneLine(CString& csInputOneBlobEntry)
{
    HRESULT hReturn = E_FAIL;
    CStringList cslBlobEntryParts;
    CString csComma = _T(",");

    TCHAR szDrive_only[_MAX_DRIVE];
    TCHAR szPath_only[_MAX_PATH];
    TCHAR szPath_only2[_MAX_PATH];
    TCHAR szFilename_only[_MAX_PATH];
    TCHAR szFilename_ext_only[_MAX_EXT];

    CString csFilePath;
    CString csFilePathNew;
    CString csFilePath2;

    CString csEntry;
    CString csEntry0;
    CString csEntry1;
    CString csEntry2;
    CString csEntry3;

    TCHAR szNewFileName[_MAX_PATH];

    POSITION pos;
    
    //"500,15,FILE,D:\WINNT\help\iisHelp\common\500-15.htm" 
    //"500,100,URL,/iisHelp/common/500-100.asp"

    // break the source map into a string list
    ConvertSepLineToStringList(csInputOneBlobEntry,cslBlobEntryParts,csComma);

    // we now have the cstringlist. Loop through the list
    // which should look like this:
    // 0:500
    // 1:15
    // 2:FILE
    // 3:D:\WINNT\help\iisHelp\common\500-15.htm
    pos = cslBlobEntryParts.GetHeadPosition();
    if (!pos) {goto CustomErrorProcessOneLine_Exit;}

    // 0:500
    csEntry = cslBlobEntryParts.GetAt(pos);
    csEntry0 = csEntry;
    if (!pos) {goto CustomErrorProcessOneLine_Exit;}

    // 1:15
    cslBlobEntryParts.GetNext(pos);
    if (!pos) {goto CustomErrorProcessOneLine_Exit;}
    csEntry = cslBlobEntryParts.GetAt(pos);
    csEntry1 = csEntry;
    if (!pos) {goto CustomErrorProcessOneLine_Exit;}
    
    // 2:FILE
    // Check to make sure this is the "file" type 
    // that we will act upon.  if it's not then get out
    cslBlobEntryParts.GetNext(pos);
    if (!pos) {goto CustomErrorProcessOneLine_Exit;}
    csEntry = cslBlobEntryParts.GetAt(pos);
    if ( csEntry.Left(4) != _T("FILE") )
        {goto CustomErrorProcessOneLine_Exit;}
    csEntry2 = csEntry;

    // 3:D:\WINNT\help\iisHelp\common\500-15.htm
    cslBlobEntryParts.GetNext(pos);
    if (!pos) {goto CustomErrorProcessOneLine_Exit;}
    csEntry = cslBlobEntryParts.GetAt(pos);
    csEntry3 = csEntry;

    // KOOL, this is one we need to process.
    // D:\WINNT\help\iisHelp\common\500-15.htm

    // Get the filename
    // Trim off the filename and return only the path
    _tsplitpath(csEntry, szDrive_only, szPath_only, szFilename_only, szFilename_ext_only);

    // Check if the path points to the old place...
    csFilePath.Format(_T("%s\\help\\common\\fakefile"), g_pTheApp->m_csWinDir);
    _tsplitpath( csFilePath, NULL, szPath_only2, NULL, NULL);
    if (_tcsicmp(szPath_only, szPath_only2) != 0)
    {
        // nope this one does not point to the old place so we can get out
        goto CustomErrorProcessOneLine_Exit;
    }

    // yes, it points to the old place.
    // let's see if it exists in the new place first...
    csFilePathNew.Format(_T("%s\\help\\iishelp\\common"), g_pTheApp->m_csWinDir);
    csFilePath.Format(_T("%s\\%s%s"), csFilePathNew, szFilename_only, szFilename_ext_only);
    if (IsFileExist(csFilePath)) 
    {
        // yes, it does, then let's replace it.
        csInputOneBlobEntry.Format(_T("%s,%s,%s,%s\\%s%s"), csEntry0, csEntry1, csEntry2, csFilePathNew, szFilename_only, szFilename_ext_only);
        // return
        hReturn = ERROR_SUCCESS;
        goto CustomErrorProcessOneLine_Exit;
    }

    // no it does not exist...
    // see if there is a *.bak file with that name...
    csFilePath2 = csFilePath;
    csFilePath2 += _T(".bak");
    if (IsFileExist(csFilePath2)) 
    {
        // yes, it does, then let's replace it.
        csInputOneBlobEntry.Format(_T("%s,%s,%s,%s\\%s%s.bak"), csEntry0, csEntry1, csEntry2, csFilePathNew, szFilename_only, szFilename_ext_only);
        // return
        hReturn = ERROR_SUCCESS;
        goto CustomErrorProcessOneLine_Exit;
    }

    // They must be pointing to some other file which we don't have.
    // let's try to copy the old file from the old directory...

    // rename file to *.bak and move it to the new location..
    _stprintf(szNewFileName, _T("%s\\%s%s"), csFilePathNew, szFilename_only, szFilename_ext_only);
    // move it
    if (IsFileExist(csEntry3))
    {
        //iisDebugOut((LOG_TYPE_TRACE, _T("CustomErrorProcessOneLine: MoveFileEx:%s,%s.\n"),csEntry3, szNewFileName));
        if (MoveFileEx(csEntry3, szNewFileName, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH|MOVEFILE_REPLACE_EXISTING))
        {
            // yes, it does, then let's replace it.
            csInputOneBlobEntry.Format(_T("%s,%s,%s,%s"), csEntry0, csEntry1, csEntry2, szNewFileName);
            hReturn = ERROR_SUCCESS;
        }
        // we were not able to move it so don't make it poiint to the new place.
    }
    else
    {
        // Check if the file was renamed...
        // rename file to *.bak and move it to the new location..
        _stprintf(szNewFileName, _T("%s\\%s%s.bak"), csFilePathNew, szFilename_only, szFilename_ext_only);
        // yes, it does, then let's replace it.
        if (IsFileExist(szNewFileName))
        {
            csInputOneBlobEntry.Format(_T("%s,%s,%s,%s"), csEntry0, csEntry1, csEntry2, szNewFileName);
            hReturn = ERROR_SUCCESS;
        }
        else
        {
            // they must be pointing to some other file which we don't install.
            // so don't change this entry...
        }
    }

CustomErrorProcessOneLine_Exit:
    if (hReturn == ERROR_SUCCESS)
        {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CustomErrorProcessOneLine:End.value=%s.\n"),csInputOneBlobEntry));
        }
    return hReturn;
}


//------------------------------------------------------------
HRESULT CFixCustomErrors::UpdateOne( LPWSTR strPath )
{
    HRESULT hRes = ERROR_SUCCESS;
    POSITION        pos;
    POSITION        posCurrent;
    CString         szMap;

    DWORD dwattributes = 0;

    CStringList cslScriptMaps;

    //iisDebugOut((LOG_TYPE_TRACE, _T("CFixCustomErrors::UpdateOne() %s.\n"), strPath));

    CString csTheNode;
    csTheNode = _T("LM/W3SVC");
    csTheNode += strPath;

    // get the full script map in question.
    hRes = GetMultiSzAsStringList (
        m_dwMDIdentifier,
        &m_dwMDDataType,
        &dwattributes,
        cslScriptMaps,
        strPath );
    
    //iisDebugOut((LOG_TYPE_TRACE, _T("CFixCustomErrors::UpdateOne() GetMultiSzAsStringList. Attrib=0x%x.\n"), dwattributes));

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CFixCustomErrors::UpdateOne()-GetMultiSzAsStringList failed. err=%x.\n"), hRes));
        return hRes;
    }

    // we now have the cstringlist of paths that need to be updated. Loop through the
    // list and update them all.
    // get the list's head position
    pos = cslScriptMaps.GetHeadPosition();
    while ( NULL != pos )
    {
        // store the current position
        posCurrent = pos;

        // get the next path in question
        szMap = cslScriptMaps.GetNext( pos );

        // print it out to the screen for debug purposes
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CFixCustomErrors::UpdateOne().Data=%s.\n"), szMap));

        // operate on it
        hRes = CustomErrorProcessOneLine( szMap );

        // if that worked, put it back in place
        if ( SUCCEEDED(hRes) ){cslScriptMaps.SetAt ( posCurrent, szMap );}
    }

    //iisDebugOut((LOG_TYPE_ERROR, _T("CFixCustomErrors::UpdateOne() SetMultiSzAsStringList. Attrib=0x%x.\n"), dwattributes));

    // Put it back.
    hRes = SetMultiSzAsStringList (
        m_dwMDIdentifier,
        m_dwMDDataType,
        dwattributes,
        cslScriptMaps,
        strPath );
    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CFixCustomErrors::UpdateOne()-SetMultiSzAsStringList failed. err=%x.\n"), hRes));
        return hRes;
    }

    return hRes;
}






HRESULT CEnforceMaxConnection::UpdateOne( LPWSTR strPath )
{
    HRESULT hRes = 0xFFFFFFFF;
    iisDebugOut((LOG_TYPE_ERROR, _T("CEnforceMaxConnection::UpdateOne(%s).start\n"), strPath));

    DWORD theDword;
    BOOL  fSomethingChanged = FALSE;

    if ( m_dwMDDataType == DWORD_METADATA )
    {
        // Get the value into a dword
        // get the full script map in question.
        hRes = GetDword(m_dwMDIdentifier,m_dwMDDataType,NULL,theDword,strPath);
        if ( MD_ERROR_DATA_NOT_FOUND == hRes)
        {
            hRes = ERROR_SUCCESS;
            return hRes;
        }

        if ( FAILED(hRes) )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CEnforceMaxConnection::UpdateOne()-GetDword failed. err=%x.\n"), hRes));
            return hRes;
        }

        if (theDword > 10)
        {
            theDword = 10;
            fSomethingChanged = TRUE;
        }
        else
        {
            hRes = ERROR_SUCCESS;
        }
                  

        // Put it back. - unless nothing changed
        if ( fSomethingChanged )
        {
            //hRes = SetDword(m_dwMDIdentifier,m_dwMDDataType,NULL,theDword,strPath);
            if ( FAILED(hRes) )
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("CEnforceMaxConnection::UpdateOne()-GetDword failed. err=%x.\n"), hRes));
                return hRes;
            }
        }
    }
    else
    {
        hRes = ERROR_SUCCESS;
    }

    iisDebugOut((LOG_TYPE_ERROR, _T("CEnforceMaxConnection::UpdateOne(%s).End.ret=0x%x\n"), strPath,hRes));
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\lsakeys.cpp ===
// This class is to help setup retrieve the old-style LSA keys and convert them
// into the new MetaData keys.
// created by BoydM 4/2/97

#include "stdafx.h"
#include "LSAKeys.h"

#ifndef _CHICAGO_

// it is assumed that #include "ntlsa.h" is included in stdafx.h

#define KEYSET_LIST				L"W3_KEY_LIST"
#define KEYSET_PUB_KEY			L"W3_PUBLIC_KEY_%s"
#define KEYSET_PRIV_KEY			L"W3_PRIVATE_KEY_%s"
#define KEYSET_PASSWORD			L"W3_KEY_PASSWORD_%s"
#define KEYSET_DEFAULT			L"Default"

#define	KEY_NAME_BASE			"W3_KEYMAN_KEY_"
#define	KEY_LINKS_SECRET_W		L"W3_KEYMAN_LINKS"
#define	KEYMAN_LINK_DEFAULT		"DEFAULT"
#define KEY_VERSION		0x102				// version we are converting from

#define	MDNAME_INCOMPLETE	"incomplete"
#define	MDNAME_DISABLED		"disabled"
#define	MDNAME_DEFAULT		"default"
#define	MDNAME_PORT			":443"			// use the default SSL port

//----------------------------------------------------------------------
// construction
CLSAKeys::CLSAKeys():
		m_cbPublic(0),
		m_pPublic(NULL),
		m_cbPrivate(0),
		m_pPrivate(NULL),
		m_cbPassword(0),
		m_pPassword(NULL),
		m_cbRequest(0),
		m_pRequest(NULL),
		m_hPolicy(NULL)
	{
	}

//----------------------------------------------------------------------
CLSAKeys::~CLSAKeys()
	{
	DWORD	err;

	// clear out the last loaded key
	UnloadKey();

	// if it is opehn, close the LSA policy
	if ( m_hPolicy )
		FCloseLSAPolicy( m_hPolicy, &err );
	};

//----------------------------------------------------------------------
// clean up the currently loaded key
void CLSAKeys::UnloadKey()
	{
	// unload the public key
	if ( m_cbPublic && m_pPublic )
		{
		GlobalFree( m_pPublic );
		m_cbPublic = 0;
		m_pPublic = NULL;
		}

	// unload the private key
	if ( m_cbPrivate && m_pPrivate )
		{
		GlobalFree( m_pPrivate );
		m_cbPrivate = 0;
		m_pPrivate = NULL;
		}

	// unload the password
	if ( m_cbPassword && m_pPassword )
		{
		GlobalFree( m_pPassword );
		m_cbPassword = 0;
		m_pPassword = NULL;
		}

	// unload the key request
	if ( m_cbRequest && m_pRequest )
		{
		GlobalFree( m_pRequest );
		m_cbRequest = 0;
		m_pRequest = NULL;
		}
	
	// empty the strings too
	m_szFriendlyName[0] = 0;
	m_szMetaName[0] = 0;
	}


//----------------------------------------------------------------------
// DeleteAllLSAKeys deletes ALL remenents of the LSA keys in the Metabase.
// (not including, of course anything written out there in the future as part
// of some backup scheme when uninstalling). Call this only AFTER ALL the keys
// have been converted to the metabase. They will no longer be there after
// this routine is used.
// NOTE: this also blows away any really-old KeySet keys because they look
// like the KeyMan keys. And we have to kill both the keyset keys and the
// generic storage used by the server.
DWORD CLSAKeys::DeleteAllLSAKeys()
	{
	DWORD	err;

	// first, delete the KeyManager type keys.
	err = DeleteKMKeys();
	if ( err != KEYLSA_SUCCESS )
		return err;

	// second, delete the keyset style keys. - this also removes the ones
	// that the server uses and any keyset keys.
	return DeleteServerKeys();
	}

//----------------------------------------------------------------------
DWORD CLSAKeys::DeleteKMKeys()
	{
	PCHAR				pName = (PCHAR)GlobalAlloc( GPTR, MAX_PATH+1 );
	PWCHAR				pWName = (PWCHAR)GlobalAlloc( GPTR, (MAX_PATH+1) * sizeof(WCHAR) );
	PLSA_UNICODE_STRING	pLSAData;
	DWORD				err;

	if ( !pName || !pWName )
		return ERROR_NOT_ENOUGH_MEMORY;

	// reset the index so we get the first key
	m_iKey = 0;

	// loop through the keys, deleting each in turn
	while( TRUE )
		{
		// increment the index
		m_iKey++;

		// build the key secret name
		sprintf( pName, "%s%d", KEY_NAME_BASE, m_iKey );
		// unicodize the name
		MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pName, -1, pWName, MAX_PATH+1 );

		// get the secret
		pLSAData = FRetrieveLSASecret( m_hPolicy, pWName, &err );
		// if we don't get the secret, exit
		if ( !pLSAData )
			{
			break;
			}

		// The secret is there. Clean up first
		DisposeLSAData( pLSAData );

		// now delete the secret
		FStoreLSASecret( m_hPolicy, pWName, NULL, 0, &err );
		};

	return KEYLSA_SUCCESS;
	}

//----------------------------------------------------------------------
DWORD CLSAKeys::DeleteServerKeys()
	{
	DWORD				err;
	PLSA_UNICODE_STRING	pLSAData;

	// get the secret list of keys
	pLSAData = FRetrieveLSASecret( m_hPolicy, KEYSET_LIST, &err );

	// if we get lucky, there won't be any keys to get rid of
	if ( !pLSAData )
		return KEYLSA_SUCCESS;

	// allocate the name buffer
	PWCHAR	pWName = (PWCHAR)GlobalAlloc( GPTR, (MAX_PATH+1) * sizeof(WCHAR) );
	ASSERT( pWName );
	if ( !pWName )
		{
		return 0xFFFFFFFF;
		}

	// No such luck. Now we have to walk the list and delete all those secrets
	WCHAR*	pszAddress = (WCHAR*)(pLSAData->Buffer);
	WCHAR*	pchKeys;

	// loop the items in the list, deleting the associated items
	while( pchKeys = wcschr(pszAddress, L',') )
		{
		// ignore empty segments
		if ( *pszAddress != L',' )
			{
			*pchKeys = L'\0';

			// Nuke the secrets, one at a time
			swprintf( pWName, KEYSET_PUB_KEY, pszAddress );
			FStoreLSASecret( m_hPolicy, pWName, NULL, 0, &err );

			swprintf( pWName, KEYSET_PRIV_KEY, pszAddress );
			FStoreLSASecret( m_hPolicy, pWName, NULL, 0, &err );

			swprintf( pWName, KEYSET_PASSWORD, pszAddress );
			FStoreLSASecret( m_hPolicy, pWName, NULL, 0, &err );
			}

		// increment the pointers
		pchKeys++;
		pszAddress = pchKeys;
		}

	// delete the list key itself
	FStoreLSASecret( m_hPolicy, KEYSET_LIST, NULL, 0, &err );

	// free the buffer for the names
	GlobalFree( (HANDLE)pWName );

	// free the info we originally retrieved from the secret
	if ( pLSAData )
		DisposeLSAData( pLSAData );

	// return success
	return KEYLSA_SUCCESS;
	}


//----------------------------------------------------------------------
// loading the keys
// LoadFirstKey loads the first key on the specified target machine. Until
// this method is called, the data values in the object are meaningless
// this method works by preparing the list of keys to load. Then it calls
// LoadNextKey to start the process
// Unfortunately, the whole process of saving keys in the LSA registry was a bit
// of a mess because they all had to be on the same level.
DWORD CLSAKeys::LoadFirstKey( PWCHAR pszwTargetMachine )
	{
	DWORD	err;

	// open the policy on the target machine being administered
	m_hPolicy = HOpenLSAPolicy( pszwTargetMachine, &err );
	if ( !m_hPolicy ) return KEYLSA_UNABLE_TO_OPEN_POLICY;

	// tell it to load the first key. The first key's index is actually 1, 
	// but LoadNextKey impliess that it is ++LoadNextKey, so start it at 0
	m_iKey = 0;

	// load that first key and return the response
	return LoadNextKey();
	}


//----------------------------------------------------------------------
// LoadNextKey loads the next key on the target machine specified in LoadFirstKey
// LoadNextKey automatically cleans up the memory used by the previous key.
DWORD CLSAKeys::LoadNextKey()
	{
	// the very first thing we do is - get rid of any previously loaded key
	UnloadKey();

	PCHAR				pName = (PCHAR)GlobalAlloc( GPTR, MAX_PATH+1 );
	PWCHAR				pWName = (PWCHAR)GlobalAlloc( GPTR, (MAX_PATH+1) * sizeof(WCHAR) );
	PLSA_UNICODE_STRING	pLSAData = NULL;
	DWORD				err = 0xFFFFFFFF;

	PUCHAR				pSrc;
	WORD				cbSrc;
	DWORD				dword, version, i;
	DWORD				cbChar;
	PUCHAR				p;

	CHAR				szIPAddress[256];
	BOOL				fDefault;

	if ( !pName || !pWName )
		return err;

	// increment the index so we get the next key
	m_iKey++;

	// build the key secret name
	sprintf( pName, "%s%d", KEY_NAME_BASE, m_iKey );
	// unicodize the name
	MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pName, -1, pWName, MAX_PATH+1 );

	// get the secret
	pLSAData = FRetrieveLSASecret( m_hPolicy, pWName, &err );
	// if we don't get the secret, exit with the error
	if ( !pLSAData )
		{
		err = KEYLSA_NO_MORE_KEYS;
		goto cleanup;
		}


	// we have the data from the secret. Now we parse it out into the components we desire
	// this probably could have been done cleaner the first time - but now it doesn't matter
	// anyway because the MetaBase takes care of storing all the individual pieces of info
	// anyway. It should also be way faster too.
	// This part of the routine is pretty much lifted out of CW3Key::InitializeFromPointer
	// from the w3key.dll. The appropriate sections have been either commented out or changed.

	pSrc = (PUCHAR)pLSAData->Buffer;
	cbSrc = pLSAData->Length;
	cbChar = sizeof(TCHAR);
	p = pSrc;

//========================== start from CW3Key::InitializeFromPointer

	ASSERT(pSrc && cbSrc);

	// get the version of the data - just put it into dword for now
	version = *((UNALIGNED DWORD*)p);
	// check the version for validity
//	if ( version > KEY_VERSION )
//		{
//		return FALSE;
//		}
	p += sizeof(DWORD);

	// anything below version 0x101 is BAD. Do not accept it
	if ( version < 0x101 )
		{
		err = KEYLSA_INVALID_VERSION;
		goto cleanup;
		}
	
	// get the bits and the complete flag
	// no longer used
	p += sizeof(DWORD);
	p += sizeof(BOOL);
	ASSERT( p < (pSrc + cbSrc) );

	// get the reserved dword - (acutally, just skip over it)
	p += sizeof(DWORD);

	// now the strings......
	// for each string, first get the size of the string, then the data from the string

	// get the reserved string - (actually, just skip over it)
	dword = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
	p += dword;

	// get the name
	dword = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
	strcpy( m_szFriendlyName, (PCHAR)p );
	p += dword;
	ASSERT( p < (pSrc + cbSrc) );

	// get the password
	dword = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
	// if there is no password, don't worry, just skip it
	if ( dword )
		{
		// make a new pointer for it
		m_cbPassword = dword;
		m_pPassword = (PVOID)GlobalAlloc( GPTR, m_cbPassword );
		if ( !m_pPassword )
			{
			err = 0xFFFFFFFF;
			goto cleanup;
			}
		// put in the private key
		CopyMemory( m_pPassword, p, m_cbPassword );

		p += dword;
		ASSERT( p < (pSrc + cbSrc) );
		}

	// get the organization
	// no longer used - skip the DN info
	for ( i = 0; i < 6; i++ )
		{
		dword = *((UNALIGNED DWORD*)p);
		p += sizeof(DWORD);
		p += dword;
		ASSERT( p < (pSrc + cbSrc) );
		}

	// get the ip addres it is attached to
	dword = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
//	szIPAddress = p;
	strcpy( szIPAddress, (PCHAR)p );
	p += dword;
	ASSERT( p < (pSrc + cbSrc) );

	// get the default flag
	fDefault = *((UNALIGNED BOOL*)p);
	p += sizeof(BOOL);

	// now put get the number of bytes in the private key
	m_cbPrivate = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
	ASSERT( p < (pSrc + cbSrc) );

	// make a new pointer for it
	m_pPrivate = (PVOID)GlobalAlloc( GPTR, m_cbPrivate );
	if ( !m_pPrivate )
		{
		err = 0xFFFFFFFF;
		goto cleanup;
		}

	// put in the private key
	CopyMemory( m_pPrivate, p, m_cbPrivate );
	p += m_cbPrivate;
	ASSERT( p < (pSrc + cbSrc) );


	// now put get the number of bytes in the certificate
	m_cbPublic = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
	ASSERT( p < (pSrc + cbSrc) );

	// only make a certificate pointer if m_cbCertificate is greater than zero
	m_pPublic = NULL;
	if ( m_cbPublic )
		{
		m_pPublic = (PVOID)GlobalAlloc( GPTR, m_cbPublic );
		if ( !m_pPublic )
			{
			err = 0xFFFFFFFF;
			goto cleanup;
			}

		// put in the private key
		CopyMemory( m_pPublic, p, m_cbPublic );
		p += m_cbPublic;
		if ( version >= KEY_VERSION ) {
			ASSERT( p < (pSrc + cbSrc) );
        } else {
			ASSERT( p == (pSrc + cbSrc) );
        }
		}

	// added near the end
	if ( version >= KEY_VERSION )
		{
		// now put get the number of bytes in the certificte request
		m_cbRequest = *((UNALIGNED DWORD*)p);
		p += sizeof(DWORD);
		ASSERT( p < (pSrc + cbSrc) );

		// only make a certificate pointer if m_cbCertificate is greater than zero
		m_pRequest = NULL;
		if ( m_cbRequest )
			{
			m_pRequest = (PVOID)GlobalAlloc( GPTR, m_cbRequest );
			if ( !m_pRequest )
				{
				err = 0xFFFFFFFF;
				goto cleanup;
				}

			// put in the private key
			CopyMemory( m_pRequest, p, m_cbRequest );
			p += m_cbRequest;
			ASSERT( p < (pSrc + cbSrc) );
			}
		}
	else
		{
		m_cbRequest = 0;
		m_pRequest = NULL;
		}
//========================== end from CW3Key::InitializeFromPointer

	// now we figure out the appropriate metabase name for this key
	// this isn't too bad. If the targets a specific address, then the title
	// is the in the form of {IP}:{PORT}. Since there were no ports in the old
	// version, we will assume an appropriate default number. If it is the
	// default key, then the name is "default". If it is a disabled key, then
	// the name is "disabled". If it is an incomplete key, then the name is
	// "incomplete". Of course, it takes a little logic to tell the difference
	// between some of these.

	// first, see if it is an incomplete key. - test for the public portion
	if ( !m_pPublic )
		{
		// there may be multiple incomplete keys, so make sure they have unique names
//		m_szMetaName.Format( _T("%s%d"), MDNAME_INCOMPLETE, m_iKey );
		sprintf( m_szMetaName, "%s%d", MDNAME_INCOMPLETE, m_iKey );
		}
	// now test if it is the default key
	else if ( fDefault )
		{
//		m_szMetaName = MDNAME_DEFAULT;
		strcpy( m_szMetaName, MDNAME_DEFAULT );
		}
	// test for a disabled key
	else if ( szIPAddress[0] == 0 )
		{
		// there may be multiple disabled keys, so make sure they have unique names
//		m_szMetaName.Format( _T("%s%d"), MDNAME_DISABLED, m_iKey );
		sprintf( m_szMetaName, "%s%d", MDNAME_DISABLED, m_iKey );
		}
	else
		{
		// it is a regular old IP targeted key
//		m_szMetaName = szIPAddress;
		// add on the default port specification
//		m_szMetaName += MDNAME_PORT;
//		sprintf( m_szMetaName, "%s%s", szIPAddress, MDNAME_PORT );
        strcpy(m_szMetaName, szIPAddress);
		}

	// free the buffers
cleanup:
	GlobalFree( (HANDLE)pName );
	GlobalFree( (HANDLE)pWName );
	if ( pLSAData )
		DisposeLSAData( pLSAData );

	return err;
	}


//============================================= LSA Utility routines

//-------------------------------------------------------------
// pass in a NULL pszwServer name to open the local machine
HANDLE	CLSAKeys::HOpenLSAPolicy( WCHAR *pszwServer, DWORD *pErr )
	{
	NTSTATUS				ntStatus;
	LSA_OBJECT_ATTRIBUTES	objectAttributs;
	LSA_HANDLE				hPolicy;

	LSA_UNICODE_STRING		unicodeServer;

	// prepare the object attributes
	InitializeObjectAttributes( &objectAttributs, NULL, 0L, NULL, NULL );

	// prepare the lsa_unicode name of the server
	if ( pszwServer )
		{
		unicodeServer.Buffer = pszwServer;
		unicodeServer.Length = wcslen(pszwServer) * sizeof(WCHAR);
		unicodeServer.MaximumLength = unicodeServer.Length + sizeof(WCHAR);
		}


	// attempt to open the policy
	ntStatus = LsaOpenPolicy( pszwServer ? &unicodeServer : NULL,
						&objectAttributs, POLICY_ALL_ACCESS, &hPolicy );

	// check for an error
	if ( !NT_SUCCESS(ntStatus) )
		{
		*pErr = LsaNtStatusToWinError( ntStatus );
		return NULL;
		}

	// success, so return the policy handle as a regular handle
	*pErr = 0;
	return hPolicy;
	}


//-------------------------------------------------------------
BOOL	CLSAKeys::FCloseLSAPolicy( HANDLE hPolicy, DWORD *pErr )
	{
	NTSTATUS				ntStatus;

	// close the policy
	ntStatus = LsaClose( hPolicy );

	// check for an error
	if ( !NT_SUCCESS(ntStatus) )
		{
		*pErr = LsaNtStatusToWinError( ntStatus );
		return FALSE;
		}

	// success, so return the policy handle as a regular handle
	*pErr = 0;
	return TRUE;
}

//-------------------------------------------------------------
// passing NULL in for pvData deletes the secret
BOOL	CLSAKeys::FStoreLSASecret( HANDLE hPolicy, WCHAR* pszwSecretName, void* pvData, WORD cbData, DWORD *pErr )
	{
	LSA_UNICODE_STRING		unicodeSecretName;
	LSA_UNICODE_STRING		unicodeData;
	NTSTATUS				ntStatus;
	
	// make sure we have a policy and a secret name
	if ( !hPolicy || !pszwSecretName )
		{
		*pErr = 1;
		return FALSE;
		}

	// prepare the lsa_unicode name of the server
	unicodeSecretName.Buffer = pszwSecretName;
	unicodeSecretName.Length = wcslen(pszwSecretName) * sizeof(WCHAR);
	unicodeSecretName.MaximumLength = unicodeSecretName.Length + sizeof(WCHAR);

	// prepare the unicode data record
	if ( pvData )
		{
		unicodeData.Buffer = (WCHAR*)pvData;
		unicodeData.Length = cbData;
		unicodeData.MaximumLength = cbData;
		}

	// it is now time to store the secret
	ntStatus = LsaStorePrivateData( hPolicy, &unicodeSecretName, pvData ? &unicodeData : NULL );

	// check for an error
	if ( !NT_SUCCESS(ntStatus) )
		{
		*pErr = LsaNtStatusToWinError( ntStatus );
		return FALSE;
		}

	// success, so return the policy handle as a regular handle
	*pErr = 0;
	return TRUE;
	}

//-------------------------------------------------------------
// passing NULL in for pvData deletes the secret
PLSA_UNICODE_STRING	CLSAKeys::FRetrieveLSASecret( HANDLE hPolicy, WCHAR* pszwSecretName, DWORD *pErr )
{
	LSA_UNICODE_STRING		unicodeSecretName;
	LSA_UNICODE_STRING*		pUnicodeData = NULL;
	NTSTATUS				ntStatus;
	
	// make sure we have a policy and a secret name
	if ( !hPolicy || !pszwSecretName )
		{
		*pErr = 1;
		return FALSE;
		}

	// prepare the lsa_unicode name of the server
	unicodeSecretName.Buffer = pszwSecretName;
	unicodeSecretName.Length = wcslen(pszwSecretName) * sizeof(WCHAR);
	unicodeSecretName.MaximumLength = unicodeSecretName.Length + sizeof(WCHAR);

	// it is now time to store the secret
	ntStatus = LsaRetrievePrivateData( hPolicy, &unicodeSecretName, &pUnicodeData );

	// check for an error
	if ( !NT_SUCCESS(ntStatus) )
		{
		*pErr = LsaNtStatusToWinError( ntStatus );
		return NULL;
		}

	// success, so return the policy handle as a regular handle
	*pErr = 0;
	return pUnicodeData;
	}

//-------------------------------------------------------------
void CLSAKeys::DisposeLSAData( PVOID pData )
	{
	PLSA_UNICODE_STRING pDataLSA = (PLSA_UNICODE_STRING)pData;
	if ( !pDataLSA || !pDataLSA->Buffer ) return;
	GlobalFree(pDataLSA);
	}

#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\lsakeys.h ===
#ifndef _LSAKEYS_H_
#define _LSAKEYS_H_

#ifndef _CHICAGO_

// This class is to help setup retrieve the old-style LSA keys and convert them
// into the new MetaData keys.

// error codes
enum {
	KEYLSA_SUCCESS = 0,
	KEYLSA_INVALID_VERSION,
	KEYLSA_NO_MORE_KEYS,
	KEYLSA_UNABLE_TO_OPEN_POLICY
	};


// Note: once you call LoadFirstKey, there is an open LSA policy until the object is deleted.
// This is done for speed purposes. So if you don't want the policy hanging around, don't
// keep the object around.

class CLSAKeys : public CObject
	{
	public:

	// construction
	CLSAKeys();
	~CLSAKeys();

	// loading the keys
	// LoadFirstKey loads the first key on the specified target machine. Until
	// this method is called, the data values in the object are meaningless
	DWORD	LoadFirstKey( PWCHAR pszwTargetMachine );

	// LoadNextKey loads the next key on the target machine specified in LoadFirstKey
	// LoadNextKey automatically cleans up the memory used by the previous key.
	DWORD	LoadNextKey();

	// DeleteAllLSAKeys deletes ALL remenents of the LSA keys in the Metabase.
	// (not including, of course anything written out there in the future as part
	// of some backup scheme when uninstalling). Call this only AFTER ALL the keys
	// have been converted to the metabase. They will no longer be there after
	// this routine is used.
	DWORD DeleteAllLSAKeys();

	// the data values that are to be filled in.
	// The public portion of the key - may be NULL and zero size
	DWORD	m_cbPublic;
	PVOID	m_pPublic;

	// the private portion of the key
	DWORD	m_cbPrivate;
	PVOID	m_pPrivate;

	// the password
	DWORD	m_cbPassword;
	PVOID	m_pPassword;

	// the certificate request - may be NULL and zero size
	DWORD	m_cbRequest;
	PVOID	m_pRequest;


	// the friendly name
	CHAR m_szFriendlyName[256];

	// the name that should be given to the metabase object for this key
	CHAR	m_szMetaName[256];

	private:
	// clean up the currently loaded key
	void UnloadKey();

	// delete utilities
	DWORD DeleteKMKeys();
	DWORD DeleteServerKeys();

	// LSA Utility routines
	HANDLE	HOpenLSAPolicy( PWCHAR pszwServer, DWORD *pErr );
	BOOL	FCloseLSAPolicy( HANDLE hPolicy, DWORD *pErr );

	BOOL	FStoreLSASecret( HANDLE hPolicy, WCHAR* pszwSecretName, void* pvData, WORD cbData, DWORD *pErr );
	PLSA_UNICODE_STRING	FRetrieveLSASecret( HANDLE hPolicy, WCHAR* pszwSecretName, DWORD *pErr );

	void	DisposeLSAData( PVOID pData );

	// the handle to the LSA policy
	HANDLE	m_hPolicy;

	// index of the current key
	DWORD	m_iKey;
	};

#endif //_CHICAGO_
#endif //_LSAKEYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\mdacl.h ===
#include "stdafx.h"

DWORD AddUserToMetabaseACL(CString csKeyPath, LPTSTR szUserToAdd);
BOOL  IsLocalAccount(LPCTSTR pAccnt, DWORD *dwErr );
int IsDomainSpecifiedOtherThanLocalMachine(LPCTSTR pDomainUserName);
#ifndef _CHICAGO_
    int CreateIUSRAccount(CString csUsername, CString csPassword, INT* piNewlyCreatedUser);
    int CreateIWAMAccount(CString csUsername, CString csPassword, INT* piNewlyCreatedUser);

    DWORD MigrateServiceIpSec(LPWSTR  pszSrvRegKey,LPWSTR  pszSrvMetabasePath);
    BOOL  CleanAdminACL(SECURITY_DESCRIPTOR *pSD);
    void  FixAdminACL(LPTSTR szKeyPath);
    DWORD SetAdminACL(LPCTSTR szKeyPath, DWORD dwAccessForEveryone);
    DWORD SetAdminACL_wrap(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount, BOOL bDisplayMsgOnErrFlag);
    VOID  SetLocalHostRestriction(LPCTSTR szKeyPath);
    DWORD SetIISADMINRestriction(LPCTSTR szKeyPath);
    DWORD WriteSDtoMetaBase(PSECURITY_DESCRIPTOR outpSD, LPCTSTR szKeyPath);
    DWORD WriteSessiontoMetaBase(LPCTSTR szKeyPath);

    BOOL AddUserAccessToSD(IN  PSECURITY_DESCRIPTOR pSd,IN  PSID pSid,IN  DWORD  NewAccess,IN  UCHAR TheAceType,OUT PSECURITY_DESCRIPTOR *ppSdNew);
    void DumpAdminACL(HANDLE hFile,PSECURITY_DESCRIPTOR pSD);
#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\mdacl.cpp ===
#include "stdafx.h"
#include <ole2.h>
#include <aclapi.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "log.h"
#include "mdkey.h"
#include "dcomperm.h"
#include "other.h"
#include "mdacl.h"
#include <sddl.h>       // ConvertSidToStringSid

extern int g_GlobalDebugCrypto;

#ifndef _CHICAGO_

BOOL CleanAdminACL(SECURITY_DESCRIPTOR *pSD)
{
    // iisDebugOut((LOG_TYPE_TRACE, _T("CleanAdminACL(): Start.\n")));
    BOOL fSetData = FALSE;
    BOOL b= FALSE, bDaclPresent = FALSE, bDaclDefaulted = FALSE;;
    PACL pDacl = NULL;
    LPVOID pAce = NULL;
    int i = 0;
    ACE_HEADER *pAceHeader;
    ACCESS_MASK dwOldMask, dwNewMask,  dwExtraMask, dwMask;

    dwMask = (MD_ACR_READ |
            MD_ACR_WRITE |
            MD_ACR_RESTRICTED_WRITE |
            MD_ACR_UNSECURE_PROPS_READ |
            MD_ACR_ENUM_KEYS |
            MD_ACR_WRITE_DAC);

    b = GetSecurityDescriptorDacl(pSD, &bDaclPresent, &pDacl, &bDaclDefaulted);
    if (NULL == pDacl)
    {
        return FALSE;
    }
    if (b) {
        //iisDebugOut((LOG_TYPE_TRACE, _T("CleanAdminACL:ACE count: %d\n"), (int)pDacl->AceCount));
        for (i=0; i<(int)pDacl->AceCount; i++) {
            b = GetAce(pDacl, i, &pAce);
            if (b) {
                pAceHeader = (ACE_HEADER *)pAce;
                switch (pAceHeader->AceType) {
                case ACCESS_ALLOWED_ACE_TYPE:
                    dwOldMask = ((ACCESS_ALLOWED_ACE *)pAce)->Mask;
                    dwExtraMask = dwOldMask & (~dwMask);
                    if (dwExtraMask) {
                        fSetData = TRUE;
                        dwNewMask = dwOldMask & dwMask;
                        ((ACCESS_ALLOWED_ACE *)pAce)->Mask = dwNewMask;
                    }
                    break;
                case ACCESS_DENIED_ACE_TYPE:
                    dwOldMask = ((ACCESS_DENIED_ACE *)pAce)->Mask;
                    dwExtraMask = dwOldMask & (~dwMask);
                    if (dwExtraMask) {
                        fSetData = TRUE;
                        dwNewMask = dwOldMask & dwMask;
                        ((ACCESS_DENIED_ACE *)pAce)->Mask = dwNewMask;
                    }
                    break;
                case SYSTEM_AUDIT_ACE_TYPE:
                    dwOldMask = ((SYSTEM_AUDIT_ACE *)pAce)->Mask;
                    dwExtraMask = dwOldMask & (~dwMask);
                    if (dwExtraMask) {
                        fSetData = TRUE;
                        dwNewMask = dwOldMask & dwMask;
                        ((SYSTEM_AUDIT_ACE *)pAce)->Mask = dwNewMask;
                    }
                    break;
                default:
                    break;
                }
            } else {
                //iisDebugOut((LOG_TYPE_TRACE, _T("CleanAdminACL:GetAce:err=%x\n"), GetLastError()));
            }
        }
    } else {
        //iisDebugOut((LOG_TYPE_TRACE, _T("CleanAdminACL:GetSecurityDescriptorDacl:err=%x\n"), GetLastError()));
    }

    //iisDebugOut_End(_T("CleanAdminACL"),LOG_TYPE_TRACE);
    return (fSetData);
}

void FixAdminACL(LPTSTR szKeyPath)
{
    // iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("FixAdminACL Path=%1!s!. Start.\n"), szKeyPath));
    BOOL bFound = FALSE, b = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    LPTSTR p, rest, token;
    CString csName, csValue;
    PBYTE pData;
    int BufSize;
    SECURITY_DESCRIPTOR *pSD;

    cmdKey.OpenNode(szKeyPath);
    if ( (METADATA_HANDLE)cmdKey )
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (!bFound && (cbLen > 0))
        {
            if ( ! (bufData.Resize(cbLen)) )
            {
                cmdKey.Close();
                return;  // insufficient memory
            }
            else
            {
                pData = (PBYTE)(bufData.QueryPtr());
                BufSize = cbLen;
                cbLen = 0;
                bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
            }
        }
        cmdKey.Close();

        if (bFound && (dType == BINARY_METADATA))
        {
            pSD = (SECURITY_DESCRIPTOR *)pData;

            b = CleanAdminACL(pSD);
            if (b)
            {
                // need to reset the data
                DWORD dwLength = GetSecurityDescriptorLength(pSD);
                cmdKey.OpenNode(szKeyPath);
                if ( (METADATA_HANDLE)cmdKey )
                {
                    cmdKey.SetData(MD_ADMIN_ACL,METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE,IIS_MD_UT_SERVER,BINARY_METADATA,dwLength,(LPBYTE)pSD);
                    cmdKey.Close();
                }
            }
        }
    }

    //iisDebugOut_End1(_T("FixAdminACL"),szKeyPath,LOG_TYPE_TRACE);
    return;
}

#endif //_CHICAGO_

#ifndef _CHICAGO_
DWORD SetAdminACL(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount)
{
    iisDebugOut_Start1(_T("SetAdminACL"), szKeyPath, LOG_TYPE_TRACE);

    int iErr=0;
    DWORD dwErr=0;

    DWORD dwRetCode = ERROR_SUCCESS;
    BOOL b = FALSE;
    DWORD dwLength = 0;

    PSECURITY_DESCRIPTOR pSD = NULL;
    PSECURITY_DESCRIPTOR outpSD = NULL;
    DWORD cboutpSD = 0;
    PACL pACLNew = NULL;
    DWORD cbACL = 0;
    PSID pAdminsSID = NULL, pEveryoneSID = NULL;
    BOOL bWellKnownSID = FALSE;

    // Initialize a new security descriptor
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (!pSD)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:LocalAlloc FAILED.out of memory. GetLastError()= 0x%x\n"), ERROR_NOT_ENOUGH_MEMORY));
        dwRetCode = E_FAIL;
        goto Cleanup;
    }
    iErr = InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
    if (iErr == 0)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:InitializeSecurityDescriptor FAILED.  GetLastError()= 0x%x\n"), GetLastError() ));
        dwRetCode = E_FAIL;
        goto Cleanup;
    }

    // Get Local Admins Sid
    dwErr = GetPrincipalSID (_T("Administrators"), &pAdminsSID, &bWellKnownSID);
    if (dwErr != ERROR_SUCCESS)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:GetPrincipalSID(Administrators) FAILED.  Return Code = 0x%x\n"), dwErr));
        dwRetCode = E_FAIL;
        goto Cleanup;
    }

    // Get everyone Sid
    dwErr = GetPrincipalSID (_T("Everyone"), &pEveryoneSID, &bWellKnownSID);
    if (dwErr != ERROR_SUCCESS)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:GetPrincipalSID(Everyone) FAILED.  Return Code = 0x%x\n"), dwErr));
        dwRetCode = E_FAIL;
        goto Cleanup;
    }

    // Initialize a new ACL, which only contains 2 aaace
    cbACL = sizeof(ACL) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminsSID) - sizeof(DWORD)) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pEveryoneSID) - sizeof(DWORD)) ;
    pACLNew = (PACL) LocalAlloc(LPTR, cbACL);
    if ( !pACLNew )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:pACLNew LocalAlloc(LPTR,  FAILED. size = %u GetLastError()= 0x%x\n"), cbACL, GetLastError()));
        dwRetCode = E_FAIL;
        goto Cleanup;
    }

    if (!InitializeAcl(pACLNew, cbACL, ACL_REVISION))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:InitializeAcl FAILED.  GetLastError()= 0x%x\n"), GetLastError));
        dwRetCode = E_FAIL;
        goto Cleanup;
    }

    if (!AddAccessAllowedAce(pACLNew,ACL_REVISION,(MD_ACR_READ |MD_ACR_WRITE |MD_ACR_RESTRICTED_WRITE |MD_ACR_UNSECURE_PROPS_READ |MD_ACR_ENUM_KEYS |MD_ACR_WRITE_DAC),pAdminsSID))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:AddAccessAllowedAce(pAdminsSID) FAILED.  GetLastError()= 0x%x\n"), GetLastError));
        dwRetCode = E_FAIL;
        goto Cleanup;
    }
    if (!AddAccessAllowedAce(pACLNew,ACL_REVISION,dwAccessForEveryoneAccount,pEveryoneSID))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:AddAccessAllowedAce(pEveryoneSID) FAILED.  GetLastError()= 0x%x\n"), GetLastError()));
        dwRetCode = E_FAIL;
        goto Cleanup;
    }

    // Add the ACL to the security descriptor
    b = SetSecurityDescriptorDacl(pSD, TRUE, pACLNew, FALSE);
    if (!b)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:SetSecurityDescriptorDacl(pACLNew) FAILED.  GetLastError()= 0x%x\n"), GetLastError()));
        dwRetCode = E_FAIL;
        goto Cleanup;
    }

    b = SetSecurityDescriptorOwner(pSD, pAdminsSID, TRUE);
    if (!b)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:SetSecurityDescriptorOwner(pAdminsSID) FAILED.  GetLastError()= 0x%x\n"), GetLastError()));
        dwRetCode = E_FAIL;
        goto Cleanup;
    }

    b = SetSecurityDescriptorGroup(pSD, pAdminsSID, TRUE);
    if (!b)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:SetSecurityDescriptorGroup(pAdminsSID) FAILED.  GetLastError()= 0x%x\n"), GetLastError()));
        dwRetCode = E_FAIL;
        goto Cleanup;
    }

    // Security descriptor blob must be self relative
    b = MakeSelfRelativeSD(pSD, outpSD, &cboutpSD);
    outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR, cboutpSD);
    if ( !outpSD )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:GlobalAlloc FAILED. cboutpSD = %u  GetLastError()= 0x%x\n"), cboutpSD, GetLastError()));
        dwRetCode = E_FAIL;
        goto Cleanup;
    }

    b = MakeSelfRelativeSD( pSD, outpSD, &cboutpSD );
    if (!b)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:MakeSelfRelativeSD() FAILED. cboutpSD = %u GetLastError()= 0x%x\n"),cboutpSD, GetLastError()));
        dwRetCode = E_FAIL;
        goto Cleanup;
    }

    if (outpSD)
    {
        if (IsValidSecurityDescriptor(outpSD))
        {
            // Apply the new security descriptor to the metabase
            iisDebugOut_Start(_T("SetAdminACL:Write the new security descriptor to the Metabase"),LOG_TYPE_TRACE);
            iisDebugOut((LOG_TYPE_TRACE, _T("SetAdminACL:  At this point we have already been able to write basic entries to the metabase, so...")));
            iisDebugOut((LOG_TYPE_TRACE, _T("SetAdminACL:  If this has a problem then there is a problem with setting up encryption for the metabase (Crypto).")));
            //DoesAdminACLExist(szKeyPath);

            if (g_GlobalDebugCrypto == 2)
            {
                // if we want to call this over and over...
                do
                {
                    dwRetCode = WriteSDtoMetaBase(outpSD, szKeyPath);
                    if (FAILED(dwRetCode))
                    {
                        OutputDebugString(_T("\nCalling WriteSDtoMetaBase again...Set iis!g_GlobalDebugCrypto to 0 to stop looping on failure."));
                        OutputDebugString(_T("\nSet iis!g_GlobalDebugCrypto to 0 to stop looping on crypto failure.\n"));
                    }
                } while (FAILED(dwRetCode) && g_GlobalDebugCrypto == 2);
            }
            else
            {
                dwRetCode = WriteSDtoMetaBase(outpSD, szKeyPath);
            }
            //DoesAdminACLExist(szKeyPath);
            iisDebugOut_End(_T("SetAdminACL:Write the new security descriptor to the Metabase"),LOG_TYPE_TRACE);
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("SetAdminACL:IsValidSecurityDescriptor.4.SelfRelative(%u) FAILED!"),outpSD));
        }
    }

    if (outpSD){GlobalFree(outpSD);outpSD=NULL;}
  

Cleanup:
  // both of Administrators and Everyone are well-known SIDs, use FreeSid() to free them.
  if (pAdminsSID){FreeSid(pAdminsSID);}
  if (pEveryoneSID){FreeSid(pEveryoneSID);}
  if (pSD){LocalFree((HLOCAL) pSD);}
  if (pACLNew){LocalFree((HLOCAL) pACLNew);}
  iisDebugOut_End1(_T("SetAdminACL"),szKeyPath,LOG_TYPE_TRACE);
  return (dwRetCode);
}


DWORD SetAdminACL_wrap(LPCTSTR szKeyPath, DWORD dwAccessForEveryoneAccount, BOOL bDisplayMsgOnErrFlag)
{
	int bFinishedFlag = FALSE;
	UINT iMsg = NULL;
	DWORD dwReturn = ERROR_SUCCESS;
    LogHeapState(FALSE, __FILE__, __LINE__);

	do
	{
		dwReturn = SetAdminACL(szKeyPath, dwAccessForEveryoneAccount);
        LogHeapState(FALSE, __FILE__, __LINE__);
		if (FAILED(dwReturn))
		{
			if (bDisplayMsgOnErrFlag == TRUE)
			{
                iMsg = MyMessageBox( NULL, IDS_RETRY, MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
				switch ( iMsg )
				{
				case IDIGNORE:
					dwReturn = ERROR_SUCCESS;
					goto SetAdminACL_wrap_Exit;
				case IDABORT:
					dwReturn = ERROR_OPERATION_ABORTED;
					goto SetAdminACL_wrap_Exit;
				case IDRETRY:
					break;
				default:
					break;
				}
			}
			else
			{
				// return whatever err happened
				goto SetAdminACL_wrap_Exit;
			}
		}
                                    else
                                    {
                                                      break;
                                    } 
	} while ( FAILED(dwReturn) );

SetAdminACL_wrap_Exit:
	return dwReturn;
}

#endif


#ifndef _CHICAGO_
DWORD WriteSDtoMetaBase(PSECURITY_DESCRIPTOR outpSD, LPCTSTR szKeyPath)
{
    iisDebugOut_Start(_T("WriteSDtoMetaBase"), LOG_TYPE_TRACE);
    DWORD dwReturn = E_FAIL;
    DWORD dwLength = 0;
    DWORD dwMDFlags = 0;
    CMDKey cmdKey;
    HRESULT hReturn = E_FAIL;
    int iSavedFlag = 0;
        
    dwMDFlags = METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE,IIS_MD_UT_SERVER,BINARY_METADATA;
    iSavedFlag = g_GlobalDebugCrypto;

    if (!outpSD)
    {
        dwReturn = ERROR_INVALID_SECURITY_DESCR;
        goto WriteSDtoMetaBase_Exit;
    }

    // Apply the new security descriptor to the metabase
    dwLength = GetSecurityDescriptorLength(outpSD);

    // open the metabase
    // stick it into the metabase.  warning those hoses a lot because
    // it uses encryption.  rsabase.dll

    // Check for special debug flag in metabase to break right before this call!
    if (g_GlobalDebugCrypto != 0)
    {
        // special flag to say... hey "stop setup so that the crypto team can debug they're stuff"
        iisDebugOut((LOG_TYPE_TRACE, _T("Breakpoint enabled thru setup (to debug crypto api). look at debugoutput.")));
        OutputDebugString(_T("\n\nBreakpoint enabled thru setup (to debug crypto api)"));
        OutputDebugString(_T("\n1.in this process:"));
        OutputDebugString(_T("\n  set breakpoint on admwprox!IcpGetContainerHelper"));
        OutputDebugString(_T("\n  set breakpoint on advapi32!CryptAcquireContextW"));
        OutputDebugString(_T("\n  IcpGetKeyHelper will call CryptAcquireContext and try to open an existing key container,"));
        OutputDebugString(_T("\n  if it doesn't exist it will return NTE_BAD_KEYSET, and IcpGetContainerHelper will try to create the container."));
        OutputDebugString(_T("\n2.in the inetinfo process:"));
        OutputDebugString(_T("\n  set breakpoint on admwprox!IcpGetContainerHelper"));
        OutputDebugString(_T("\n  set breakpoint on advapi32!CryptAcquireContextW\n"));
    }

    hReturn = cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, szKeyPath);
    if ( (METADATA_HANDLE)cmdKey ) 
    {
        TCHAR szErrorString[50];
        iisDebugOut((LOG_TYPE_TRACE, _T("WriteSDtoMetaBase:cmdKey():SetData(MD_ADMIN_ACL), dwdata = %d; outpSD = %x, Start\n"), dwLength, (DWORD_PTR) outpSD ));
        if (g_GlobalDebugCrypto != 0)
        {
            OutputDebugString(_T("\nCalling SetData....\n"));
            DebugBreak();
        }
        dwReturn = cmdKey.SetData(MD_ADMIN_ACL,dwMDFlags,IIS_MD_UT_SERVER,BINARY_METADATA,dwLength,(LPBYTE)outpSD);
        if (FAILED(dwReturn))
        {
           iisDebugOut((LOG_TYPE_ERROR, _T("WriteSDtoMetaBase:cmdKey():SetData(MD_ADMIN_ACL), FAILED. Code=0x%x.End.\n"), dwReturn));
           if (g_GlobalDebugCrypto != 0)
            {
               _stprintf(szErrorString, _T("\r\nSetData Failed. code=0x%x\r\n\r\n"), dwReturn);
               OutputDebugString(szErrorString);
            }
 
        }
        else
        {
            dwReturn = ERROR_SUCCESS;
            iisDebugOut((LOG_TYPE_TRACE, _T("WriteSDtoMetaBase:cmdKey():SetData(MD_ADMIN_ACL), Success.End.\n")));
            if (g_GlobalDebugCrypto != 0)
            {
               _stprintf(szErrorString, _T("\r\nSetData Succeeded. code=0x%x\r\n\r\n"), dwReturn);
               OutputDebugString(szErrorString);
            }
        }
        cmdKey.Close();
    }
    else
    {
        dwReturn = hReturn;
    }
   
WriteSDtoMetaBase_Exit:
    g_GlobalDebugCrypto = iSavedFlag;
    iisDebugOut((LOG_TYPE_TRACE, _T("WriteSDtoMetaBase:End.  Return=0x%x"), dwReturn));
    return dwReturn;
}

DWORD WriteSessiontoMetaBase(LPCTSTR szKeyPath)
{
    iisDebugOut_Start(_T("WriteSessiontoMetaBase"), LOG_TYPE_TRACE);
    DWORD dwReturn = E_FAIL;
    CMDKey cmdKey;
    HRESULT hReturn = E_FAIL;
    
    hReturn = cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, szKeyPath);
    if ( (METADATA_HANDLE)cmdKey ) 
    {
        dwReturn = cmdKey.SetData(9999,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,BINARY_METADATA,0,(LPBYTE)"");
        if (FAILED(dwReturn))
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("WriteSessiontoMetaBase:cmdKey():SetData(), FAILED. Code=0x%x.End.\n"), dwReturn));
        }
        else
        {
            dwReturn = ERROR_SUCCESS;
            iisDebugOut((LOG_TYPE_TRACE, _T("WriteSessiontoMetaBase:cmdKey():SetData(), Success.End.\n")));
        }
        cmdKey.Close();
    }
    else
    {
        dwReturn = hReturn;
    }
   
    iisDebugOut((LOG_TYPE_TRACE, _T("WriteSessiontoMetaBase:End.  Return=0x%x"), dwReturn));
    return dwReturn;
}
#endif

//----------------------------------------------------------------------------
// Test if the given account name is an account on the local machine or not.
//----------------------------------------------------------------------------
BOOL IsLocalAccount(LPCTSTR pAccnt, DWORD *dwErr )
    {
    BOOL        fIsLocalAccount = FALSE;
    CString     csDomain, csComputer;
    DWORD       cbDomain = 0;

    PSID         pSid = NULL;
    DWORD        cbSid = 0;
    SID_NAME_USE snu;

    // get the computer name
    cbDomain = _MAX_PATH;
    GetComputerName(
        csComputer.GetBuffer( cbDomain ), // address of name buffer
        &cbDomain                         // address of size of name buffer
        );
    csComputer.ReleaseBuffer();
    cbDomain = 0;

    // have security look up the account name and get the domain name. We dont' care about
    // the other stuff it can return, so pass in nulls
    BOOL fLookup = LookupAccountName(
        NULL,                       // address of string for system name
        pAccnt,                     // address of string for account name
        NULL,                       // address of security identifier
        &cbSid,                     // address of size of security identifier
        NULL,// address of string for referenced domain
        &cbDomain,                  // address of size of domain string
        &snu                        // address of SID-type indicator
        );

    // check the error - it should be insufficient buffer
    *dwErr = GetLastError();
    if (*dwErr != ERROR_INSUFFICIENT_BUFFER)
        return FALSE;

    // allocate the sid
    pSid = (PSID) malloc (cbSid);
    if (!pSid )
        {
        *dwErr = GetLastError();
        return FALSE;
        }

    // do the real lookup
    fLookup = LookupAccountName (NULL,pAccnt,pSid,&cbSid,csDomain.GetBuffer(cbDomain+2),&cbDomain,&snu);
    csDomain.ReleaseBuffer();

    // free the pSid we allocated above and set the final error code
    *dwErr = GetLastError();
    free( pSid );
    pSid = NULL;

    // compare the domain to the machine name, if it is the same, then set the sub auth
    if ( fLookup && (csDomain.CompareNoCase(csComputer) == 0) )
        fIsLocalAccount = TRUE;

    // return the answer
    return fIsLocalAccount;
    }


// pDomainUserName can be one of the following:
//
// domainname\username       <-- this function returns true
// computername\username     <-- this function returns false
// username                  <-- this function returns false
//
int IsDomainSpecifiedOtherThanLocalMachine(LPCTSTR pDomainUserName)
{
    int iReturn = TRUE;
    TCHAR szTempDomainUserName[_MAX_PATH];
    iisDebugOut_Start1(_T("IsDomainSpecifiedOtherThanLocalMachine"),pDomainUserName);

    CString     csComputer;
    DWORD       cbDomain = 0;

    // Make a copy to be sure not to move the pointer around.
    _tcscpy(szTempDomainUserName, pDomainUserName);
    
    // Check if there is a "\" in there.
    LPTSTR pch = NULL;
    pch = _tcschr(szTempDomainUserName, _T('\\'));
    if (!pch) 
        {
        // no '\' found so, they must be specifying only the username, return false
        iReturn = FALSE;
        goto IsDomainSpecifiedOtherThanLocalMachine_Exit;
        }

    // We have at least a '\' in there, so set default return to true.
    // let's check if the name is the local computername!

    // get the computer name
    cbDomain = _MAX_PATH;
    if (0 == GetComputerName(csComputer.GetBuffer( cbDomain ),&cbDomain) )
    {
        // failed to get computername so, let's bail
        iReturn = TRUE;
        csComputer.ReleaseBuffer();
        goto IsDomainSpecifiedOtherThanLocalMachine_Exit;
    }
    csComputer.ReleaseBuffer();
    cbDomain = 0;

    // trim off the '\' character to leave just the domain\computername so we can check against it.
    *pch = _T('\0');
    
    // Compare the domainname with the computername
    // if they match then it's the local system account.
    iReturn = TRUE;
    iisDebugOut((LOG_TYPE_TRACE, _T("IsDomainSpecifiedOtherThanLocalMachine(): %s -- %s.\n"), szTempDomainUserName, csComputer));
    if (  0 == csComputer.CompareNoCase(szTempDomainUserName) )
    {
        // The domain name and the computername are the same.
        // it is the same place.
        iReturn = FALSE;
    }

IsDomainSpecifiedOtherThanLocalMachine_Exit:
    iisDebugOut((LOG_TYPE_TRACE, _T("IsDomainSpecifiedOtherThanLocalMachine():%s.End.Ret=%d.\n"), pDomainUserName,iReturn));
    return iReturn;
}



#ifndef _CHICAGO_
void DumpAdminACL(HANDLE hFile,PSECURITY_DESCRIPTOR pSD)
{
    BOOL b= FALSE, bDaclPresent = FALSE, bDaclDefaulted = FALSE;;
    PACL pDacl = NULL;
    ACCESS_ALLOWED_ACE* pAce;
    ACCESS_MASK dwOldMask, dwNewMask,  dwExtraMask, dwMask;

    iisDebugOut((LOG_TYPE_TRACE, _T("DumpAdminACL:Start\n")));

    b = GetSecurityDescriptorDacl(pSD, &bDaclPresent, &pDacl, &bDaclDefaulted);
    if (NULL == pDacl)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("DumpAdminACL:No Security.\n")));
        return;
    }
    if (b) 
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("DumpAdminACL:ACE count: %d\n"), (int)pDacl->AceCount));

        // get dacl length  
        DWORD cbDacl = pDacl->AclSize;
        // now check if SID's ACE is there  
        for (int i = 0; i < pDacl->AceCount; i++)  
        {
            if (!GetAce(pDacl, i, (LPVOID *) &pAce))
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("DumpAdminACL:GetAce failed with 0x%x\n"),GetLastError()));
            }

		    if (IsValidSid(   (PSID) &(pAce->SidStart)   ) )
		    {
			    LPTSTR pszSid;

                LPCTSTR ServerName = NULL; // local machine
                DWORD cbName = UNLEN+1;
                TCHAR ReferencedDomainName[200];
                DWORD cbReferencedDomainName = sizeof(ReferencedDomainName);
                SID_NAME_USE sidNameUse = SidTypeUser;
                TCHAR szUserName[UNLEN + 1];

                // dump out the sid in string format
			    if (ConvertSidToStringSid(  (PSID) &(pAce->SidStart)  , &pszSid))
			    {
                    _tcscpy(szUserName, _T("(unknown...)"));
                    if (LookupAccountSid(ServerName, (PSID) &(pAce->SidStart), szUserName, &cbName, ReferencedDomainName, &cbReferencedDomainName, &sidNameUse))
                    {
                        // Get the rights for this user.
                        // pAce->Mask
                        DWORD dwBytesWritten = 0;
                        TCHAR szBuf[UNLEN+1 + 20 + 20];
                        memset(szBuf, 0, _tcslen(szBuf) * sizeof(TCHAR));

                        /*
                        typedef struct _ACCESS_ALLOWED_ACE {
                            ACE_HEADER Header;
                            ACCESS_MASK Mask;
                            ULONG SidStart;
                        } ACCESS_ALLOWED_ACE;

                        typedef struct _ACE_HEADER {
                            UCHAR AceType;
                            UCHAR AceFlags;
                            USHORT AceSize;
                        } ACE_HEADER;
                        typedef ACE_HEADER *PACE_HEADER;

                          typedef ULONG ACCESS_MASK;
                        */
                        _stprintf(szBuf, _T("%s,0x%x,0x%x,0x%x,0x%x\r\n"), 
                            szUserName,
                            pAce->Header.AceType,
                            pAce->Header.AceFlags,
                            pAce->Header.AceSize,
                            pAce->Mask
                            );

                        if (hFile != NULL && hFile != INVALID_HANDLE_VALUE)
                        {
                            if (WriteFile(hFile, szBuf, _tcslen(szBuf) * sizeof(TCHAR), &dwBytesWritten, NULL ) == FALSE )
                                {iisDebugOut((LOG_TYPE_WARN, _T("WriteFile Failed=0x%x.\n"), GetLastError()));}
                        }
                        else
                        {
                            // echo to logfile
                            iisDebugOut((LOG_TYPE_TRACE, _T("DumpAdminACL:Sid[%i]=%s,%s,0x%x,0x%x,0x%x,0x%x\n"),i,
                                pszSid,
                                szUserName,
                                pAce->Header.AceType,
                                pAce->Header.AceFlags,
                                pAce->Header.AceSize,
                                pAce->Mask
                                ));
                        }
                    }
                    else
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("DumpAdminACL:Sid[%i]=%s='%s'\n"),i,pszSid,szUserName));
                    }

                    
				    LocalFree(LocalHandle(pszSid));
			    }
		    }
            else
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("DumpAdminACL:IsVAlidSid failed with 0x%x\n"),GetLastError()));
            }
        }
    }

    iisDebugOut((LOG_TYPE_TRACE, _T("DumpAdminACL:End\n")));
    return;
}
#endif

DWORD MDDumpAdminACL(CString csKeyPath)
{
    DWORD dwReturn = E_FAIL;

    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    PBYTE pData;
    int BufSize;

    PSECURITY_DESCRIPTOR pOldSd = NULL;

    cmdKey.OpenNode(csKeyPath);
    if ( (METADATA_HANDLE) cmdKey )
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (!bFound)
        {
            if (cbLen > 0)
            {
                if ( ! (bufData.Resize(cbLen)) )
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("MDDumpAdminACL():  cmdKey.GetData.  failed to resize to %d.!\n"), cbLen));
                }
                else
                {
                    pData = (PBYTE)(bufData.QueryPtr());
                    BufSize = cbLen;
                    cbLen = 0;
                    bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
                }
            }
        }
        cmdKey.Close();

        if (bFound)
        {
            // dump out the info
            // We've got the acl
            pOldSd = (PSECURITY_DESCRIPTOR) pData;
            if (IsValidSecurityDescriptor(pOldSd))
            {
#ifndef _CHICAGO_
                DumpAdminACL(INVALID_HANDLE_VALUE,pOldSd);
                dwReturn = ERROR_SUCCESS;
#endif
            }
        }
        else
        {
            // there was no acl to be found.
        }
    }
    return dwReturn;
}

DWORD AddUserToMetabaseACL(CString csKeyPath, LPTSTR szUserToAdd)
{
    DWORD dwReturn = E_FAIL;

    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    PBYTE pData;
    int BufSize;

    PSECURITY_DESCRIPTOR pOldSd = NULL;
    PSECURITY_DESCRIPTOR pNewSd = NULL;

    cmdKey.OpenNode(csKeyPath);
    if ( (METADATA_HANDLE) cmdKey )
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (!bFound)
        {
            if (cbLen > 0)
            {
                if ( ! (bufData.Resize(cbLen)) )
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("AddUserToMetabaseACL():  cmdKey.GetData.  failed to resize to %d.!\n"), cbLen));
                }
                else
                {
                    pData = (PBYTE)(bufData.QueryPtr());
                    BufSize = cbLen;
                    cbLen = 0;
                    bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
                }
            }
        }

        cmdKey.Close();

        if (bFound)
        {
            // We've got the acl
            // so now we want to add a user to it.
            pOldSd = (PSECURITY_DESCRIPTOR) pData;
            if (IsValidSecurityDescriptor(pOldSd))
            {
                DWORD AccessMask = (MD_ACR_READ |MD_ACR_WRITE |MD_ACR_RESTRICTED_WRITE |MD_ACR_UNSECURE_PROPS_READ |MD_ACR_ENUM_KEYS |MD_ACR_WRITE_DAC);
                PSID principalSID = NULL;
                BOOL bWellKnownSID = FALSE;

                // Get the SID for the certain string (administrator or everyone or whoever)
                dwReturn = GetPrincipalSID(szUserToAdd, &principalSID, &bWellKnownSID);
                if (dwReturn != ERROR_SUCCESS)
                    {
                    iisDebugOut((LOG_TYPE_WARN, _T("AddUserToMetabaseACL:GetPrincipalSID(%s) FAILED.  Error()= 0x%x\n"), szUserToAdd, dwReturn));
                    return dwReturn;
                    }

#ifndef _CHICAGO_
                if (FALSE == AddUserAccessToSD(pOldSd,principalSID,AccessMask,ACCESS_ALLOWED_ACE_TYPE,&pNewSd))
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("AddUserToMetabaseACL:AddUserAccessToSD FAILED\n")));
                    return dwReturn;
                }
                if (pNewSd)
                {
                    // We have a new self relative SD
                    // lets write it to the metabase.
                    if (IsValidSecurityDescriptor(pNewSd))
                    {
                       dwReturn = WriteSDtoMetaBase(pNewSd, csKeyPath);
                    }
                }
#endif
            }
        }
        else
        {
            // there was no acl to be found.

        }

    }

    if (pNewSd){GlobalFree(pNewSd);}
    iisDebugOut((LOG_TYPE_TRACE, _T("AddUserToMetabaseACL():End.  Return=0x%x.\n"), dwReturn));
    return dwReturn;
}




DWORD DoesAdminACLExist(CString csKeyPath)
{
    DWORD dwReturn = FALSE;

    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    PBYTE pData;
    int BufSize;

    cmdKey.OpenNode(csKeyPath);
    if ( (METADATA_HANDLE) cmdKey )
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (bFound)
        {
            dwReturn = TRUE;
        }
        else
        {
            if (cbLen > 0)
            {
                if ( ! (bufData.Resize(cbLen)) )
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("DoesAdminACLExist():  cmdKey.GetData.  failed to resize to %d.!\n"), cbLen));
                }
                else
                {
                    pData = (PBYTE)(bufData.QueryPtr());
                    BufSize = cbLen;
                    cbLen = 0;
                    bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
                    if (bFound)
                    {
                        dwReturn = TRUE;
                    }
                }
            }
        }

        cmdKey.Close();
    }

    if (dwReturn != TRUE)
    {
        //No the acl Does not exist
    }

    iisDebugOut((LOG_TYPE_TRACE, _T("DoesAdminACLExist():End.  Return=0x%x.\n"), dwReturn));
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\mdentry.cpp ===
#include "stdafx.h"

#include <ole2.h>
#include "iadm.h"
#include "iiscnfgp.h"
#include "mdkey.h"
#include "lsaKeys.h"

#include "setupapi.h"
#undef MAX_SERVICE_NAME_LEN
#include "elem.h"
#include "mdentry.h"
#include "mdacl.h"
#include "inetinfo.h"
#include <iis64.h>

#include "inetcom.h"
#include "logtype.h"
#include "ilogobj.hxx"
#include "ocmanage.h"
#include "log.h"
#include "sslkeys.h"
#include "massupdt.h"
#include "strfn.h"
#include "svc.h"
#include "setpass.h"
#include "dcomperm.h"
#include "wolfpack.h"
#include "dllmain.h"

#define MAX_FIELDS  12
#define FIELD_SEPERATOR   _T("\t")

#define MDENTRY_FROMINFFILE_FAILED  0
#define MDENTRY_FROMINFFILE_DO_ADD  1
#define MDENTRY_FROMINFFILE_DO_DEL  2
#define MDENTRY_FROMINFFILE_DO_NOTHING  3


// These must be global because that's how they passed around
LPTSTR g_field[MAX_FIELDS];
LPBYTE g_pbData = NULL;

int g_CheckIfMetabaseValueWasWritten = FALSE;


HRESULT WINAPI Add_WWW_VDirA(CHAR * pszMetabasePath, CHAR * pszVDirName, CHAR * pszPhysicalPath, DWORD dwPermissions, DWORD iApplicationType)
{
    HRESULT hr = ERROR_BAD_PATHNAME;
    WCHAR wszMetabasePath[_MAX_PATH];
    WCHAR wszVDirName[_MAX_PATH];
    WCHAR wszPhysicalPath[_MAX_PATH];
    INT i = 0;

    // check to make sure it's not larger than max_length!
    if (strlen(pszMetabasePath) > _MAX_PATH){goto Add_WWW_VDirA_Exit;}
    if (strlen(pszVDirName) > _MAX_PATH){goto Add_WWW_VDirA_Exit;}
    if (strlen(pszPhysicalPath) > _MAX_PATH){goto Add_WWW_VDirA_Exit;}

    // convert it to unicode then call the wide function
    memset( (PVOID)wszMetabasePath, 0, sizeof(wszMetabasePath));
    memset( (PVOID)wszVDirName, 0, sizeof(wszVDirName));
    memset( (PVOID)wszPhysicalPath, 0, sizeof(wszPhysicalPath));
    i = MultiByteToWideChar(CP_ACP, 0, (LPCSTR) wszMetabasePath, -1, (LPWSTR)wszMetabasePath, _MAX_PATH);
    if (i <= 0) {goto Add_WWW_VDirA_Exit;}
    i = MultiByteToWideChar(CP_ACP, 0, (LPCSTR) wszVDirName, -1, (LPWSTR)wszVDirName, _MAX_PATH);
    if (i <= 0) {goto Add_WWW_VDirA_Exit;}
    i = MultiByteToWideChar(CP_ACP, 0, (LPCSTR) wszPhysicalPath, -1, (LPWSTR)wszPhysicalPath, _MAX_PATH);
    if (i <= 0) {goto Add_WWW_VDirA_Exit;}

    hr = Add_WWW_VDirW(wszMetabasePath, wszVDirName, wszPhysicalPath,dwPermissions, iApplicationType);

Add_WWW_VDirA_Exit:
    return hr;
}

HRESULT WINAPI Remove_WWW_VDirA(CHAR * pszMetabasePath, CHAR * pszVDirName)
{
    HRESULT hr = ERROR_BAD_PATHNAME;
    WCHAR wszMetabasePath[_MAX_PATH];
    WCHAR wszVDirName[_MAX_PATH];
    WCHAR wszPhysicalPath[_MAX_PATH];
    INT i = 0;

    // check to make sure it's not larger than max_length!
    if (strlen(pszMetabasePath) > _MAX_PATH){goto Remove_WWW_VDirA_Exit;}
    if (strlen(pszVDirName) > _MAX_PATH){goto Remove_WWW_VDirA_Exit;}

    // convert it to unicode then call the wide function
    memset( (PVOID)wszMetabasePath, 0, sizeof(wszMetabasePath));
    memset( (PVOID)wszVDirName, 0, sizeof(wszVDirName));
    i = MultiByteToWideChar(CP_ACP, 0, (LPCSTR) wszMetabasePath, -1, (LPWSTR)wszMetabasePath, _MAX_PATH);
    if (i <= 0) {goto Remove_WWW_VDirA_Exit;}
    i = MultiByteToWideChar(CP_ACP, 0, (LPCSTR) wszVDirName, -1, (LPWSTR)wszVDirName, _MAX_PATH);
    if (i <= 0) {goto Remove_WWW_VDirA_Exit;}

    hr = Remove_WWW_VDirW(wszMetabasePath, wszVDirName);

Remove_WWW_VDirA_Exit:
    return hr;
}


HRESULT WINAPI Add_WWW_VDirW(WCHAR * pwszMetabasePath, WCHAR * pwszVDirName, WCHAR * pwszPhysicalPath, DWORD dwPermissions, DWORD iApplicationType)
{
    HRESULT hr = ERROR_BAD_PATHNAME;
    IMSAdminBase *pIMSAdminBase = NULL;

    // check to make sure it's not larger than max_length!
    if ((wcslen(pwszMetabasePath) * sizeof(WCHAR))  > _MAX_PATH){goto Add_WWW_VDirW_Exit2;}
    if ((wcslen(pwszVDirName) * sizeof(WCHAR)) > _MAX_PATH){goto Add_WWW_VDirW_Exit2;}
    if ((wcslen(pwszPhysicalPath) * sizeof(WCHAR)) > _MAX_PATH){goto Add_WWW_VDirW_Exit2;}

    // only allow this if they are running as admin.
    hr = ERROR_ACCESS_DENIED;
    if (!RunningAsAdministrator())
    {
        goto Add_WWW_VDirW_Exit;
    }

    // if the service doesn't exist, then
    // we don't have to do anyting
    if (CheckifServiceExist(_T("IISADMIN")) != 0 ) 
    {
        hr = ERROR_SERVICE_DOES_NOT_EXIST;
        goto Add_WWW_VDirW_Exit;
    }

    hr = E_FAIL;
#ifndef _CHICAGO_
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
#else
    hr = CoInitialize(NULL);
#endif
    // no need to call uninit
    if( FAILED (hr)) {goto Add_WWW_VDirW_Exit2;}
    hr = ::CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase,(void **) & pIMSAdminBase);
    if(FAILED (hr)) 
        {goto Add_WWW_VDirW_Exit;}

    hr = AddVirtualDir( pIMSAdminBase, pwszMetabasePath, pwszVDirName, pwszPhysicalPath, dwPermissions, iApplicationType);
    if(SUCCEEDED(hr))
        {hr = pIMSAdminBase->SaveData();}

    if (pIMSAdminBase) 
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }

Add_WWW_VDirW_Exit:
    CoUninitialize();
Add_WWW_VDirW_Exit2:
    return hr;
}

HRESULT WINAPI Remove_WWW_VDirW(WCHAR * pwszMetabasePath, WCHAR * pwszVDirName)
{
    HRESULT hr = ERROR_BAD_PATHNAME;
    IMSAdminBase *pIMSAdminBase = NULL;

    // check to make sure it's not larger than max_length!
    if ((wcslen(pwszMetabasePath) * sizeof(WCHAR))  > _MAX_PATH){goto Remove_WWW_VDirW_Exit2;}
    if ((wcslen(pwszVDirName) * sizeof(WCHAR)) > _MAX_PATH){goto Remove_WWW_VDirW_Exit2;}

    // only allow this if they are running as admin.
    hr = ERROR_ACCESS_DENIED;
    if (!RunningAsAdministrator())
    {
        goto Remove_WWW_VDirW_Exit;
    }

    // if the service doesn't exist, then
    // we don't have to do anyting
    if (CheckifServiceExist(_T("IISADMIN")) != 0 ) 
    {
        hr = ERROR_SUCCESS;
        goto Remove_WWW_VDirW_Exit2;
    }

    hr = E_FAIL;
#ifndef _CHICAGO_
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
#else
    hr = CoInitialize(NULL);
#endif
    // no need to call uninit
    if( FAILED (hr)) {goto Remove_WWW_VDirW_Exit2;}

    hr = ::CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase,(void **) & pIMSAdminBase);
    if( FAILED (hr)) 
        {goto Remove_WWW_VDirW_Exit;}

    hr = RemoveVirtualDir(pIMSAdminBase, pwszMetabasePath, pwszVDirName);
    if(SUCCEEDED(hr))
        {hr = pIMSAdminBase->SaveData();}

    if (pIMSAdminBase) 
    {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }
Remove_WWW_VDirW_Exit:
    CoUninitialize();
Remove_WWW_VDirW_Exit2:
    return hr;
}


// Split a line of entry into iExpectedNumOfFields g_fields for MDEntry datatype
BOOL SplitLine(LPTSTR szLine, INT iExpectedNumOfFields)
{
    int i = 0;
    TCHAR *token = NULL;

    token = _tcstok(szLine, FIELD_SEPERATOR);
    while (token && i < iExpectedNumOfFields)
    {
        g_field[i++] = token;
        token = _tcstok(NULL, FIELD_SEPERATOR);
    }

    if (i == iExpectedNumOfFields)
        return TRUE;
    else
        return FALSE;
}

// Split a line of entry into iExpectedNumOfFields g_fields for MDEntry datatype
BOOL SplitLineCommaDelimited(LPTSTR szLine, INT iExpectedNumOfFields)
{
    int i = 0;
    TCHAR *token;
    token = _tcstok(szLine, _T(","));
    while (token && i < iExpectedNumOfFields)
    {
        g_field[i++] = token;
        token = _tcstok(NULL, _T(","));
    }
    if (i == iExpectedNumOfFields)
        return TRUE;
    else
        return FALSE;
}

DWORD GetSizeBasedOnMetaType(DWORD dwDataType,LPTSTR szString)
{
    DWORD dwRet = 0;

    switch (dwDataType)
    {
        case DWORD_METADATA:
            dwRet = 4;
            break;
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
            if (szString == NULL)
            {
                dwRet = 0;
            }
            else
            {
                dwRet = (_tcslen((LPTSTR)szString) + 1) * sizeof(TCHAR);
            }
            break;
        case MULTISZ_METADATA:
            if (szString == NULL)
            {
                dwRet = 0;
            }
            else
            {
                dwRet = GetMultiStrSize((LPTSTR)szString) * sizeof(TCHAR);
            }
            break;
        case BINARY_METADATA:
            break;
    }

    return dwRet;
}

// function: MDEntry_Process
//
// The prupose of this function, is to read in a location and value from
// the inf file, if the location in the metabase equals that value, then
// change it to the new value.
// The main use of this function is to change values that we might of set
// incorrectly before.
//
// Format:
//  g_field[0] = "2" 
//  g_field[1] = Location
//  g_field[2] = ID
//  g_field[3] = DataType
//  g_field[4] = DataSize
//  g_field[5] = Old Value (if this matches the metabase, we will replace with new value)
//  g_field[6] = Inheritable
//  g_field[7] = UserType
//  g_field[8] = DataType
//  g_field[9] = Length
//  g_field[10] = Value
//
// Return:
//   TRUE - Processed line fine
//   FALSE - Error Occurred
BOOL MDEntry_Process(LPTSTR szLine)
{
    CMDKey      cmdKey;
    CMDValue    cmdMetaValue;
    DWORD       dwSize;
    DWORD       dwDataType;

    // Split the line into the difference fields
    if (!SplitLine(szLine, 11))
    {
        return FALSE;
    }

    // Open the Node
    if ( FAILED(cmdKey.OpenNode(g_field[1]) ) )
    {
        return FALSE;
    }

    // Retrieve Value
    if ( !cmdKey.GetData(cmdMetaValue, _ttoi(g_field[2])) )
    {
        return FALSE;
    }

    dwDataType = _ttoi(g_field[3]);
    dwSize = _ttoi(g_field[4]);

    if (dwSize == 0)
    {
        dwSize = GetSizeBasedOnMetaType(dwDataType, g_field[5]);
    }

    if ( dwDataType == DWORD_METADATA )
    {
        if ( !cmdMetaValue.IsEqual(dwDataType,dwSize, _ttoi(g_field[5])) )
        {
            // The values did not match
            return TRUE;
        }
    }
    else
    {
        if ( !cmdMetaValue.IsEqual(dwDataType,dwSize,g_field[5]) )
        {
            // The values did not match
            return TRUE;
        }
    }

    dwSize = _ttoi(g_field[9]);

    if (dwSize == 0)
    {
        dwSize = GetSizeBasedOnMetaType(dwDataType, g_field[10]);
    }

    // At this point, we know that the values matched, so lets replace with the new value.
    if ( dwDataType == DWORD_METADATA )
    {
        DWORD dwValue = _ttoi(g_field[10]);

        cmdKey.SetData(_ttoi(g_field[2]),atodw(g_field[6]),_ttoi(g_field[7]),_ttoi(g_field[8]),dwSize,(LPBYTE) &dwValue);
    }
    else
    {
        cmdKey.SetData(_ttoi(g_field[2]),atodw(g_field[6]),_ttoi(g_field[7]),_ttoi(g_field[8]),dwSize,(LPBYTE) g_field[10]);
    }
          
    cmdKey.Close();

    return TRUE;
}

// function: MDEntry_MoveValue
//
// The prupose of this function, is to move a value set in the metabase from one location
// to another.  If that value does not exist, then we set a new value for it.
//
// Format:
//  g_field[0] = "3" 
//  g_field[1] = Old Location
//  g_field[2] = Old ID
//  g_field[3] = New Location
//  g_field[4] = New ID
//  g_field[5] = Inheritable (Hex)
//  g_field[6] = UserType
//  g_field[7] = DataType
//  g_field[8] = Length
//  g_field[9] = Value (if none was detected before)
//
// Return:
//   TRUE - Processed line fine
//   FALSE - Error Occurred
BOOL MDEntry_MoveValue(LPTSTR szLine)
{
    CMDKey      cmdKey;
    CMDValue    cmdMetaValue;
    CMDValue    cmdDummyValue;
    DWORD       dwSize;
    BOOL        fRet = TRUE;
   
    // Split the line into the difference fields
    if (!SplitLine(szLine, 10))
    {
        return FALSE;
    }

    dwSize = _ttoi(g_field[8]);

    if (dwSize == 0)
    {
        dwSize = GetSizeBasedOnMetaType(_ttoi(g_field[7]), g_field[9]);
    }

    // First set the value that we are changing the data to
    cmdMetaValue.SetValue(_ttoi(g_field[4]),atodw(g_field[5]),_ttoi(g_field[6]),_ttoi(g_field[7]),dwSize,(LPTSTR) g_field[9]);

    // Open the Retrieve from Node
    if ( SUCCEEDED(cmdKey.OpenNode(g_field[1]) ) )
    {
        // Retrieve the old Value
        if ( cmdKey.GetData(cmdMetaValue, _ttoi(g_field[2])) )
        {
            // Delete Old Value if it exists
            if (FAILED(cmdKey.DeleteData(_ttoi(g_field[2]), ALL_METADATA)))
            {
                fRet = FALSE;
            }
        }

        cmdKey.Close();
    }

    // Open the node to Set
    if ( FAILED(cmdKey.OpenNode(g_field[3]) ) )
    {
        return FALSE;
    }

    // Set New Value (at this point cmdMetaValue, is either the value we orinally set, or
    // the value that was retrieved from the old location)
    if ( !cmdKey.GetData(cmdDummyValue, _ttoi(g_field[4])) )
    {
        if (!cmdKey.SetData(cmdMetaValue, _ttoi(g_field[4])))
        {
            fRet = FALSE;
        }
    }
    
    cmdKey.Close();

    return fRet;
}

INT GetMDEntryFromInfLineEx(LPTSTR szLine, MDEntry *pMDEntry)
{
    INT iTemp  = MDENTRY_FROMINFFILE_DO_ADD;
    INT iReturn = MDENTRY_FROMINFFILE_FAILED;

    if (!SplitLine(szLine, 8)){goto GetMDEntryFromInfLineEx_Exit;}

    if ( _tcscmp(g_field[0], _T("-1")) != 0)
    {
        if ( _tcscmp(g_field[0], _T("-0")) != 0)
        {
            goto GetMDEntryFromInfLineEx_Exit;
        }
        else
        {
            iTemp = MDENTRY_FROMINFFILE_DO_DEL;
        }
    }
    
    pMDEntry->szMDPath = g_field[1];
    pMDEntry->dwMDIdentifier = _ttoi(g_field[2]);
    pMDEntry->dwMDAttributes = atodw(g_field[3]);
    pMDEntry->dwMDUserType = _ttoi(g_field[4]);
    pMDEntry->dwMDDataType = _ttoi(g_field[5]);
    pMDEntry->dwMDDataLen = _ttoi(g_field[6]);

    switch ( pMDEntry->dwMDDataType )
    {
        case DWORD_METADATA:
            {
                *(DWORD *)g_pbData = atodw(g_field[7]);
                pMDEntry->pbMDData = g_pbData;
                break;
            }
        case MULTISZ_METADATA:
            {
                CString csMultiSZ;
                int nLen = 0;
                ReadMultiSZFromInfSection(&csMultiSZ, g_pTheApp->m_hInfHandle, g_field[7]);
                nLen = csMultiSZ.GetLength();

                HGLOBAL hBlock = NULL;
                hBlock = GlobalAlloc(GPTR, (nLen+1)*sizeof(TCHAR));
                if (hBlock)
                {
                    TCHAR *p = (LPTSTR)hBlock;
                    memcpy((LPVOID)hBlock, (LPVOID)(LPCTSTR)csMultiSZ, (nLen+1)*sizeof(TCHAR));
                    while (*p)
                    {
                        if (*p == _T('|'))
                            *p = _T('\0');
                        p = _tcsinc(p);
                    }
                    pMDEntry->pbMDData = (LPBYTE)hBlock;
                }
                else
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("GetMDEntryFromInfLine.1.Failed to allocate memory.\n")));
                    pMDEntry->dwMDDataLen = 0;
                    pMDEntry->pbMDData = NULL;
                    goto GetMDEntryFromInfLineEx_Exit;
                }
                break;
            }
        default:
            {
                // treat the whole thing as string
                pMDEntry->pbMDData = (LPBYTE)g_field[7];
                break;
            }
    }

    switch (pMDEntry->dwMDDataType)
    {
        case DWORD_METADATA:
            pMDEntry->dwMDDataLen = 4;
            break;
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
            pMDEntry->dwMDDataLen = (_tcslen((LPTSTR)pMDEntry->pbMDData) + 1) * sizeof(TCHAR);
            break;
        case MULTISZ_METADATA:
            pMDEntry->dwMDDataLen = GetMultiStrSize((LPTSTR)pMDEntry->pbMDData) * sizeof(TCHAR);
            break;
        case BINARY_METADATA:
            break;
    }
    iReturn = iTemp;
    
GetMDEntryFromInfLineEx_Exit:
    return iReturn;
}

// Fill in the structure of MDEntry
INT GetMDEntryFromInfLine(LPTSTR szLine, MDEntry *pMDEntry)
{
    INT iReturn = MDENTRY_FROMINFFILE_FAILED;
    BOOL fMigrate;
    BOOL fKeepOldReg;
    HKEY hRegRootKey;
    LPTSTR szRegSubKey;
    LPTSTR szRegValueName;

    // Check if the first character is = "-1"
    // if it is then do the special metabase slam deal none of this
    // upgrade and look up registry junk, just slam the data into the metabase.
    if (szLine[0] == _T('-') && szLine[1] == _T('1'))
    {
        iReturn = GetMDEntryFromInfLineEx(szLine, pMDEntry);
        goto GetMDEntryFromInfLine_Exit;
    }
    if (szLine[0] == _T('-') && szLine[1] == _T('0'))
    {
        iReturn = GetMDEntryFromInfLineEx(szLine, pMDEntry);
        goto GetMDEntryFromInfLine_Exit;
    }
    if (szLine[0] == _T('2') )
    {
        MDEntry_Process(szLine);
        return MDENTRY_FROMINFFILE_DO_NOTHING;
    }
    if (szLine[0] == _T('3') )
    {
        MDEntry_MoveValue(szLine);
        return MDENTRY_FROMINFFILE_DO_NOTHING;
    }

    if (!SplitLine(szLine, 12))
        return FALSE;

    if ( _tcscmp(g_field[0], _T("1")) == 0)
        fMigrate = (g_pTheApp->m_eUpgradeType == UT_10_W95 || g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30);
    else
        fMigrate = FALSE;

    if ( _tcscmp(g_field[1], _T("1")) == 0)
        fKeepOldReg = TRUE;
    else
        fKeepOldReg = FALSE;

    if (_tcsicmp(g_field[2], _T("HKLM")) == 0) {hRegRootKey = HKEY_LOCAL_MACHINE;}
    else if (_tcsicmp(g_field[2], _T("HKCR")) == 0) {hRegRootKey = HKEY_CLASSES_ROOT;}
    else if (_tcsicmp(g_field[2], _T("HKCU")) == 0) {hRegRootKey = HKEY_CURRENT_USER;}
    else if (_tcsicmp(g_field[2], _T("HKU")) == 0) {hRegRootKey = HKEY_USERS;}
    else {hRegRootKey = HKEY_LOCAL_MACHINE;}

    szRegSubKey = g_field[3];
    szRegValueName = g_field[4];

    pMDEntry->szMDPath = g_field[5];
    pMDEntry->dwMDIdentifier = _ttoi(g_field[6]);
    pMDEntry->dwMDAttributes = atodw(g_field[7]);
    pMDEntry->dwMDUserType = _ttoi(g_field[8]);
    pMDEntry->dwMDDataType = _ttoi(g_field[9]);
    pMDEntry->dwMDDataLen = _ttoi(g_field[10]);

    switch ( pMDEntry->dwMDDataType )
    {
        case DWORD_METADATA:
            {
                *(DWORD *)g_pbData = atodw(g_field[11]);
                pMDEntry->pbMDData = g_pbData;
                break;
            }
        case MULTISZ_METADATA:
            {
                CString csMultiSZ;
                int nLen = 0;
                ReadMultiSZFromInfSection(&csMultiSZ, g_pTheApp->m_hInfHandle, g_field[11]);
                nLen = csMultiSZ.GetLength();

                HGLOBAL hBlock = NULL;
                hBlock = GlobalAlloc(GPTR, (nLen+1)*sizeof(TCHAR));
                if (hBlock)
                {
                    TCHAR *p = (LPTSTR)hBlock;
                    memcpy((LPVOID)hBlock, (LPVOID)(LPCTSTR)csMultiSZ, (nLen+1)*sizeof(TCHAR));
                    while (*p)
                    {
                        if (*p == _T('|'))
                            *p = _T('\0');
                        p = _tcsinc(p);
                    }
                    pMDEntry->pbMDData = (LPBYTE)hBlock;
                }
                else
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("GetMDEntryFromInfLine.1.Failed to allocate memory.\n")));
                    pMDEntry->dwMDDataLen = 0;
                    pMDEntry->pbMDData = NULL;
                    goto GetMDEntryFromInfLine_Exit;
                }
                break;
            }
        default:
            {
                // treat the whole thing as string
                pMDEntry->pbMDData = (LPBYTE)g_field[11];
                break;
            }
    }

    // migrate if necessary
    if (fMigrate)
    {
        HKEY hKey = NULL;
        LONG err = ERROR_SUCCESS;
        DWORD dwType = 0;
        DWORD cbData = sizeof(g_pbData);
        err = RegOpenKeyEx(hRegRootKey, szRegSubKey, 0, KEY_ALL_ACCESS, &hKey);
        if ( err == ERROR_SUCCESS )
        {
            err = RegQueryValueEx(hKey, szRegValueName, NULL, &dwType, g_pbData, &cbData);
            if (err == ERROR_MORE_DATA)
            {
                free(g_pbData);
                g_pbData = NULL;
                g_pbData = (LPBYTE)malloc(cbData);
                if (!g_pbData)
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("GetMDEntryFromInfLine.2.Failed to allocate memory.\n")));
                    err = E_FAIL;
                }
                else
                {
                    err = RegQueryValueEx(hKey, szRegValueName, NULL, &dwType, g_pbData, &cbData);
                }
            }
            if ( err == ERROR_SUCCESS)
            {
                if (_tcsicmp(szRegValueName, _T("MaxConnections")) == 0)
                {
                    if (*(DWORD *)g_pbData == 0x186a0) {*(DWORD *)g_pbData = 0x77359400;}
                }
                pMDEntry->pbMDData = g_pbData;
                pMDEntry->dwMDDataLen = cbData;
            }

            if (fKeepOldReg == FALSE) {err = RegDeleteValue(hKey, szRegValueName);}
            RegCloseKey(hKey);
        }
    }
    else if (fKeepOldReg == FALSE)
    {
        HKEY hKey = NULL;
        LONG err = ERROR_SUCCESS;
        DWORD dwType = 0;
        DWORD cbData = sizeof(g_pbData);
        err = RegOpenKeyEx(hRegRootKey, szRegSubKey, 0, KEY_ALL_ACCESS, &hKey);
        if ( err == ERROR_SUCCESS )
        {
            err = RegDeleteValue(hKey, szRegValueName);
            RegCloseKey(hKey);
        }
    }

    switch (pMDEntry->dwMDDataType)
    {
        case DWORD_METADATA:
            pMDEntry->dwMDDataLen = 4;
            break;
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
            pMDEntry->dwMDDataLen = (_tcslen((LPTSTR)pMDEntry->pbMDData) + 1) * sizeof(TCHAR);
            break;
        case MULTISZ_METADATA:
            pMDEntry->dwMDDataLen = GetMultiStrSize((LPTSTR)pMDEntry->pbMDData) * sizeof(TCHAR);
            break;
        case BINARY_METADATA:
            break;
    }
    iReturn = MDENTRY_FROMINFFILE_DO_ADD;

GetMDEntryFromInfLine_Exit:
    return iReturn;
}


DWORD WriteToMD_AdminInstance(CString csKeyPath,CString& csInstNumber)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_ADMIN_INSTANCE;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csInstNumber.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csInstNumber;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}


DWORD WriteToMD_VRootPath(CString csKeyPath, CString csPath, int iOverWriteAlways)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    // LM/W3SVC/1/ROOT/something
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_VR_PATH;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csPath.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csPath;
    //dwReturn = SetMDEntry_Wrap(&stMDEntry);
    if (iOverWriteAlways)
    {
        dwReturn = SetMDEntry(&stMDEntry);
    }
    else
    {
        dwReturn = SetMDEntry_NoOverWrite(&stMDEntry);
    }

    return dwReturn;
}

DWORD WriteToMD_AccessPerm(CString csKeyPath, DWORD dwRegularPerm, int iOverWriteAlways)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    // LM/W3SVC/1/ROOT/something
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_ACCESS_PERM;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwRegularPerm;
    if (iOverWriteAlways)
    {
        dwReturn = SetMDEntry(&stMDEntry);
    }
    else
    {
        dwReturn = SetMDEntry_NoOverWrite(&stMDEntry);
    }
    return dwReturn;
}

DWORD WriteToMD_SSLPerm(CString csKeyPath, DWORD dwSSLPerm, int iOverWriteAlways)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    // LM/W3SVC/1/ROOT/
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_SSL_ACCESS_PERM;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwSSLPerm;
    if (iOverWriteAlways)
    {
        dwReturn = SetMDEntry(&stMDEntry);
    }
    else
    {
        dwReturn = SetMDEntry_NoOverWrite(&stMDEntry);
    }
    return dwReturn;
}


DWORD WriteToMD_Authorization(CString csKeyPath, DWORD dwValue)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    // MD_AUTH_ANONYMOUS
    // MD_AUTH_BASIC
    // MD_AUTH_NT

    // LM/W3SVC/1/ROOT/
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_AUTHORIZATION;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwValue;
    dwReturn = SetMDEntry_Wrap(&stMDEntry);

    return dwReturn;
}


DWORD WriteToMD_DirBrowsing_WWW(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    DWORD dwData = 0;

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_DIRECTORY_BROWSING;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);

    // default
    dwData = MD_DIRBROW_SHOW_DATE |
        MD_DIRBROW_SHOW_TIME |
        MD_DIRBROW_SHOW_SIZE |
        MD_DIRBROW_SHOW_EXTENSION |
        MD_DIRBROW_LONG_DATE |
        MD_DIRBROW_LOADDEFAULT |
        MD_DIRBROW_ENABLED;

    stMDEntry.pbMDData = (LPBYTE)&dwData;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}


DWORD WriteToMD_VRUserName(CString csKeyPath, CString csUserName)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    // LM/W3SVC/1/ROOT/
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_VR_USERNAME;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csUserName.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csUserName;
    dwReturn = SetMDEntry_Wrap(&stMDEntry);

    return dwReturn;
}

DWORD WriteToMD_VRPassword(CString csKeyPath, CString csPassword)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    // LM/W3SVC/1/ROOT/
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_VR_PASSWORD;
    stMDEntry.dwMDAttributes = METADATA_INHERIT | METADATA_SECURE;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csPassword.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csPassword;
    dwReturn = SetMDEntry_Wrap(&stMDEntry);

    return dwReturn;
}

DWORD WriteToMD_IIsWebVirtualDir(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csKeyType;

    csKeyType = _T("IIsWebVirtualDir");
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csKeyType.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csKeyType;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}

DWORD WriteToMD_IIsFtpVirtualDir(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csKeyType;

    csKeyType = _T("IIsFtpVirtualDir");
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csKeyType.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csKeyType;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}

DWORD WriteToMD_IIsWebServerInstance_WWW(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csKeyType;

    csKeyType = _T("IIsWebServer");
    //  LM/W3SVC/N
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csKeyType.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csKeyType;
    SetMDEntry(&stMDEntry);

    return dwReturn;
}

DWORD WriteToMD_IIsFtpServerInstance_FTP(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csKeyType;

    csKeyType = _T("IIsFtpServer");
    //  LM/FTP/N
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csKeyType.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csKeyType;
    SetMDEntry(&stMDEntry);

    return dwReturn;
}

DWORD WriteToMD_AnonymousUserName_FTP(int iUpgradeScenarioSoOnlyOverWriteIfAlreadyThere)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    int iOverWriteName = TRUE;
    int iOverWritePass = TRUE;

    CMDKey cmdKey;
    MDEntry stMDEntry;
    MDEntry stMDEntry_Pass;

    // Add the anonymous user name
    stMDEntry.szMDPath = _T("LM/MSFTPSVC");
    stMDEntry.dwMDIdentifier = MD_ANONYMOUS_USER_NAME;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (g_pTheApp->m_csFTPAnonyName.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)g_pTheApp->m_csFTPAnonyName;

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("FTP Anonymous usrname=%s.\n"), g_pTheApp->m_csFTPAnonyName));

    // add anonymous password
    stMDEntry_Pass.szMDPath = _T("LM/MSFTPSVC");
    stMDEntry_Pass.dwMDIdentifier = MD_ANONYMOUS_PWD;
    stMDEntry_Pass.dwMDAttributes = METADATA_INHERIT | METADATA_SECURE;
    stMDEntry_Pass.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry_Pass.dwMDDataType = STRING_METADATA;
    stMDEntry_Pass.dwMDDataLen = (g_pTheApp->m_csFTPAnonyPassword.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry_Pass.pbMDData = (LPBYTE)(LPCTSTR)g_pTheApp->m_csFTPAnonyPassword;
    // make sure and delete it first
    // DeleteMDEntry(&stMDEntry_Pass);

    if (iUpgradeScenarioSoOnlyOverWriteIfAlreadyThere)
    {
        iOverWriteName = FALSE;
        iOverWritePass = FALSE;
        if (ChkMdEntry_Exist(&stMDEntry))
        {
            iOverWriteName = TRUE;
        }
        if (ChkMdEntry_Exist(&stMDEntry_Pass))
        {
            iOverWritePass = TRUE;
        }
    }

    // --------------------------------------------------
    // always overwrite, we may have changed the password
    // important: Set the username and the password on a single open and close!
    // --------------------------------------------------
    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, (LPCTSTR)stMDEntry.szMDPath);
    if ( (METADATA_HANDLE) cmdKey )
    {
        if (iOverWriteName)
        {
            dwReturnTemp = ERROR_SUCCESS;
            dwReturnTemp = cmdKey.SetData(stMDEntry.dwMDIdentifier,stMDEntry.dwMDAttributes,stMDEntry.dwMDUserType,stMDEntry.dwMDDataType,stMDEntry.dwMDDataLen,stMDEntry.pbMDData);
            if (FAILED(dwReturnTemp))
            {
                SetErrorFlag(__FILE__, __LINE__);
                iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry:SetData(%d), FAILED. Code=0x%x.End.\n"), stMDEntry.dwMDIdentifier, dwReturnTemp));
                dwReturn = dwReturnTemp;
            }
        }


        if (iOverWritePass)
        {
            dwReturnTemp = ERROR_SUCCESS;
            dwReturnTemp = cmdKey.SetData(stMDEntry_Pass.dwMDIdentifier,stMDEntry_Pass.dwMDAttributes,stMDEntry_Pass.dwMDUserType,stMDEntry_Pass.dwMDDataType,stMDEntry_Pass.dwMDDataLen,stMDEntry_Pass.pbMDData);
            if (FAILED(dwReturnTemp))
            {
                SetErrorFlag(__FILE__, __LINE__);
                iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry:SetData(%d), FAILED. Code=0x%x.End.\n"), stMDEntry_Pass.dwMDIdentifier, dwReturnTemp));
                dwReturn = dwReturnTemp;
            }
        }
        cmdKey.Close();
    }

    return dwReturn;
}



DWORD WriteToMD_AnonymousUserName_WWW(int iUpgradeScenarioSoOnlyOverWriteIfAlreadyThere)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    CMDKey cmdKey;
    MDEntry stMDEntry;
    MDEntry stMDEntry_Pass;

    int iOverWriteName = TRUE;
    int iOverWritePass = TRUE;

    // add anonymous username
    stMDEntry.szMDPath = _T("LM/W3SVC");
    stMDEntry.dwMDIdentifier = MD_ANONYMOUS_USER_NAME;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (g_pTheApp->m_csWWWAnonyName.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)g_pTheApp->m_csWWWAnonyName;

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("WWW Anonymous usrname=%s.\n"), g_pTheApp->m_csWWWAnonyName));

    // add anonymous password
    stMDEntry_Pass.szMDPath = _T("LM/W3SVC");
    stMDEntry_Pass.dwMDIdentifier = MD_ANONYMOUS_PWD;
    stMDEntry_Pass.dwMDAttributes = METADATA_INHERIT | METADATA_SECURE;
    stMDEntry_Pass.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry_Pass.dwMDDataType = STRING_METADATA;
    stMDEntry_Pass.dwMDDataLen = (g_pTheApp->m_csWWWAnonyPassword.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry_Pass.pbMDData = (LPBYTE)(LPCTSTR)g_pTheApp->m_csWWWAnonyPassword;
    // make sure and delete it first
    // DeleteMDEntry(&stMDEntry_Pass);

    if (iUpgradeScenarioSoOnlyOverWriteIfAlreadyThere)
    {
        iOverWriteName = FALSE;
        iOverWritePass = FALSE;
        if (ChkMdEntry_Exist(&stMDEntry))
        {
            iOverWriteName = TRUE;
        }
        if (ChkMdEntry_Exist(&stMDEntry_Pass))
        {
            iOverWritePass = TRUE;
        }
    }

    // --------------------------------------------------
    // always overwrite, we may have changed the password
    // important: Set the username and the password on a single open and close!
    // --------------------------------------------------
    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, (LPCTSTR)stMDEntry.szMDPath);
    if ( (METADATA_HANDLE) cmdKey )
    {
        if (iOverWriteName)
        {
            dwReturnTemp = ERROR_SUCCESS;
            dwReturnTemp = cmdKey.SetData(stMDEntry.dwMDIdentifier,stMDEntry.dwMDAttributes,stMDEntry.dwMDUserType,stMDEntry.dwMDDataType,stMDEntry.dwMDDataLen,stMDEntry.pbMDData);
            if (FAILED(dwReturnTemp))
            {
                SetErrorFlag(__FILE__, __LINE__);
                iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry:SetData(%d), FAILED. Code=0x%x.End.\n"), stMDEntry.dwMDIdentifier, dwReturnTemp));
                dwReturn = dwReturnTemp;
            }
        }

        if (iOverWritePass)
        {
            dwReturnTemp = ERROR_SUCCESS;
            dwReturnTemp = cmdKey.SetData(stMDEntry_Pass.dwMDIdentifier,stMDEntry_Pass.dwMDAttributes,stMDEntry_Pass.dwMDUserType,stMDEntry_Pass.dwMDDataType,stMDEntry_Pass.dwMDDataLen,stMDEntry_Pass.pbMDData);
            if (FAILED(dwReturnTemp))
            {
                SetErrorFlag(__FILE__, __LINE__);
                iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry:SetData(%d), FAILED. Code=0x%x.End.\n"), stMDEntry_Pass.dwMDIdentifier, dwReturnTemp));
                dwReturn = dwReturnTemp;
            }
        }
        cmdKey.Close();
    }

    return dwReturn;
}


DWORD WriteToMD_AnonymousUseSubAuth_FTP(void)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    DWORD dwData = 0;

    // if not PDC, BDC, SamNT, Win95
    stMDEntry.szMDPath = _T("LM/MSFTPSVC");
    stMDEntry.dwMDIdentifier = MD_ANONYMOUS_USE_SUBAUTH;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    if ((g_pTheApp->m_csFTPAnonyName).CompareNoCase(g_pTheApp->m_csGuestName) == 0)
        dwData = 0x1;
    else
        dwData = 0x0;
    stMDEntry.pbMDData = (LPBYTE)&dwData;
    dwReturn = SetMDEntry_Wrap(&stMDEntry);

    return dwReturn;
}

// This is the same as
//   enable password synchronization
DWORD WriteToMD_AnonymousUseSubAuth_WWW(void)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    DWORD dwData = 0;

    // if not PDC, BDC, SamNT, Win95
    stMDEntry.szMDPath = _T("LM/W3SVC");
    stMDEntry.dwMDIdentifier = MD_ANONYMOUS_USE_SUBAUTH;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);

    // set the sub authority bit on whether or not the anonymous name is an account
    // on this local machine, or whether it is a domain account somewhere.
    // if ((g_pTheApp->m_csWWWAnonyName).CompareNoCase(g_pTheApp->m_csGuestName) == 0)
    DWORD dwErr;
    if ( IsLocalAccount(g_pTheApp->m_csWWWAnonyName, &dwErr) )
    {
        dwData = 0x1;
    }
    else
    {
        dwData = 0x0;
    }

    stMDEntry.pbMDData = (LPBYTE)&dwData;
    dwReturn = SetMDEntry_Wrap(&stMDEntry);

    return dwReturn;
}



DWORD WriteToMD_GreetingMessage_FTP(void)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    CRegKey regFTPParam(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\MSFTPSVC\\Parameters"), KEY_READ);

    CStringList csGreetingsList;
    int nLen = 0;
    HGLOBAL hBlock = NULL;
    regFTPParam.QueryValue(_T("GreetingMessage"), csGreetingsList);
    if (csGreetingsList.IsEmpty() == FALSE)
    {
        POSITION pos = NULL;
        CString csGreetings;
        LPTSTR p;

        pos = csGreetingsList.GetHeadPosition();
        while (pos)
        {
            csGreetings = csGreetingsList.GetAt(pos);
            nLen += csGreetings.GetLength() + 1;
            iisDebugOut((LOG_TYPE_TRACE, _T("pos=%x, greeting=%s, nLen=%d\n"), pos, csGreetings, nLen));
            csGreetingsList.GetNext(pos);
        }
        nLen++;

        hBlock = GlobalAlloc(GPTR, nLen * sizeof(TCHAR));
        if (!hBlock)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("WriteToMD_GreetingMessage_FTP.1.Failed to allocate memory.\n")));
            return E_FAIL;
        }

        p = (LPTSTR)hBlock;
        pos = csGreetingsList.GetHeadPosition();
        while (pos)
        {
            csGreetings = csGreetingsList.GetAt(pos);
            _tcscpy(p, csGreetings);
            p = _tcsninc(p, csGreetings.GetLength())+1;
            iisDebugOut((LOG_TYPE_TRACE, _T("pos=%x, greeting=%s\n"), pos, csGreetings));
            csGreetingsList.GetNext(pos);
        }
        *p = _T('\0');
        p = _tcsinc(p);
    }
    else
    {
        nLen = 2;
        hBlock = GlobalAlloc(GPTR, nLen * sizeof(TCHAR));
        if (!hBlock)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("WriteToMD_GreetingMessage_FTP.2.Failed to allocate memory.\n")));
            return E_FAIL;
        }
    }
    stMDEntry.szMDPath = _T("LM/MSFTPSVC");
    stMDEntry.dwMDIdentifier = MD_GREETING_MESSAGE;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = MULTISZ_METADATA;
    stMDEntry.dwMDDataLen = nLen * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)hBlock;
    dwReturn = SetMDEntry_Wrap(&stMDEntry);
    if (stMDEntry.pbMDData)
    {
        GlobalFree(stMDEntry.pbMDData);
        stMDEntry.pbMDData = NULL;
    }

    return dwReturn;
}



DWORD WriteToMD_ServerBindings_HTMLA(CString csKeyPath, UINT iPort)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    TCHAR szData[_MAX_PATH];
    memset( (PVOID)szData, 0, sizeof(szData));
    _stprintf(szData, _T(":%d:"), iPort);

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_SERVER_BINDINGS;
    stMDEntry.dwMDAttributes = 0;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = MULTISZ_METADATA;
    stMDEntry.dwMDDataLen = GetMultiStrSize(szData) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)szData;
    dwReturn = SetMDEntry_Wrap(&stMDEntry);

    return dwReturn;
}






DWORD WriteToMD_ServerBindings(LPCTSTR szSvcName, CString csKeyPath, CString csIP)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    MDEntry stMDEntry;

    int nPort = 0;

    HGLOBAL hBlock = NULL;
    hBlock = GlobalAlloc(GPTR, _MAX_PATH * sizeof(TCHAR));
    if (!hBlock)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("WriteToMD_ServerBindings.Failed to allocate memory.\n")));
        return E_FAIL;
    }

    //  LM/W3SVC/N
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_SERVER_BINDINGS;
    stMDEntry.dwMDAttributes = 0;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = MULTISZ_METADATA;

    nPort = GetPortNum(szSvcName);
    if (csIP.Compare(_T("null")) == 0)
        _stprintf((LPTSTR)hBlock, _T(":%d:"), nPort);
    else
        _stprintf((LPTSTR)hBlock, _T("%s:%d:"), csIP, nPort);

    stMDEntry.dwMDDataLen = GetMultiStrSize((LPTSTR)hBlock) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)hBlock;
    dwReturnTemp = SetMDEntry_Wrap(&stMDEntry);
    if (stMDEntry.pbMDData)
    {
        GlobalFree(stMDEntry.pbMDData);
        stMDEntry.pbMDData = NULL;
    }

    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    return dwReturn;
}





DWORD WriteToMD_SecureBindings(CString csKeyPath, CString csIP)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    MDEntry stMDEntry;

    HGLOBAL hBlock = NULL;
    hBlock = GlobalAlloc(GPTR, _MAX_PATH * sizeof(TCHAR));
    if (!hBlock)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("WriteToMD_SecureBindings.Failed to allocate memory.\n")));
        return E_FAIL;
    }

    //  LM/W3SVC/N
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_SECURE_BINDINGS;
    stMDEntry.dwMDAttributes = 0;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = MULTISZ_METADATA;
    if (csIP.Compare(_T("null"))==0)
        _tcscpy((LPTSTR)hBlock, _T(":443:"));
    else
        _stprintf((LPTSTR)hBlock, _T("%s:443:"), csIP);
    stMDEntry.dwMDDataLen = GetMultiStrSize((LPTSTR)hBlock) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)hBlock;
    dwReturnTemp = SetMDEntry_Wrap(&stMDEntry);
    if (stMDEntry.pbMDData)
    {
        GlobalFree(stMDEntry.pbMDData);
        stMDEntry.pbMDData = NULL;
    }

    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    return dwReturn;
}

DWORD WriteToMD_ServerSize(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    DWORD dwServerSize = 0x1;

    //  LM/W3SVC/N
    //  LM/MSFTPSVC/N
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_SERVER_SIZE;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwServerSize;
    dwReturn = SetMDEntry_Wrap(&stMDEntry);

    return dwReturn;
}



DWORD WriteToMD_NotDeleteAble(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    DWORD dwNotDeletable = 0x1;

    //  LM/W3SVC/N
    //  LM/MSFTPSVC/N
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_NOT_DELETABLE;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwNotDeletable;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}

DWORD WriteToMD_ServerComment(CString csKeyPath, UINT iCommentID)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    CString csDefaultSite;

    MyLoadString(IDS_DEFAULT_WEB_SITE, csDefaultSite);
    if (iCommentID)
    {
        MyLoadString(iCommentID, csDefaultSite);
    }

    //  LM/W3SVC/N
    //  LM/MSFTPSVC/N
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_SERVER_COMMENT;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csDefaultSite.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csDefaultSite;
    dwReturn = SetMDEntry_NoOverWrite(&stMDEntry);

    return dwReturn;
}

DWORD WriteToMD_DefaultSiteAndSize(CString csKeyPath)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;
    UINT iCommentID = IDS_DEFAULT_WEB_SITE;

    // Get Resource ID
    if (csKeyPath.Find(_T("W3SVC")) != -1)
        iCommentID = IDS_DEFAULT_WEB_SITE;
    else
        iCommentID = IDS_DEFAULT_FTP_SITE;

    dwReturnTemp = WriteToMD_ServerComment(csKeyPath, iCommentID);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    dwReturnTemp = WriteToMD_ServerSize(csKeyPath);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    if (g_pTheApp->m_eNTOSType == OT_NTW)
    {
        dwReturnTemp = WriteToMD_NotDeleteAble(csKeyPath);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}
    }

    return dwReturn;
}


DWORD WriteToMD_CertMapper(CString csKeyPath)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    MDEntry stMDEntry;
    CString csKeyType;
    CString csKeyPath2;

    csKeyPath2 = csKeyPath;
    csKeyPath2 += _T("/IIsCertMapper");

    //  LM/W3SVC/N/IIsCertMapper
    csKeyType = _T("IIsCertMapper");

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath2;
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csKeyType.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csKeyType;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    return dwReturn;
}

//
// Returns the amount of filters that iis5 needs
//
int AddRequiredFilters(CString csTheSection, CStringArray& arrayName,CStringArray& arrayPath)
{
    iisDebugOut_Start(_T("AddRequiredFilters"),LOG_TYPE_TRACE);

    int c = 0;
    CString csName = _T("");
    CString csPath = _T("");

    CStringList strList;

    iisDebugOut((LOG_TYPE_TRACE, _T("ProcessFilters:%s\n"),csTheSection));
    if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, csTheSection))
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(g_pTheApp->m_hInfHandle, strList, csTheSection))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos = NULL;
            CString csEntry;
            pos = strList.GetHeadPosition();
            while (pos)
            {
                csEntry = _T("");
                csEntry = strList.GetAt(pos);
                // Split into name, and value. look for ","
                int i;
                i = csEntry.ReverseFind(_T(','));
                if (i != -1)
                {
                    int len =0;
                    len = csEntry.GetLength();
                    csPath = csEntry.Right(len - i - 1);
                    csName = csEntry.Left(i);

                    // only add the filter if the file exists..
                    // Check if exists..
                    if (IsFileExist(csPath))
                    {
                        // Add it to our array...
                        iisDebugOut((LOG_TYPE_TRACE, _T("Add filter Entry:%s:%s\n"),csName, csPath));
                        arrayName.Add(csName);
                        arrayPath.Add(csPath);
                        c++;
                    }
                    else
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("Missing Filter:Cannot Find:%s:%s\n"),csName, csPath));
                    }
                }

                strList.GetNext(pos);
            }
        }
    }
    }

    iisDebugOut_End(_T("AddRequiredFilters"),LOG_TYPE_TRACE);
    return c;
}


DWORD WriteToMD_Filters_WWW(CString csTheSection)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csKeyType;

    CString csPath = _T("");

    int c = 0;
    int j = 0, k=0;
    CStringArray arrayName, arrayPath;
    CString csName, csFilterDlls;

    CRegKey regWWWParam(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\W3SVC\\Parameters"), KEY_READ);

    // Add Required Filters to the arrayName
    c = AddRequiredFilters(csTheSection, arrayName, arrayPath);

    // Look thru the registry and
    // find the users filters -- grab then and stick them into our
    // big array of filters...
    if ( (g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30) && (HKEY)regWWWParam )
    {
        if ( regWWWParam.QueryValue(_T("Filter Dlls"), csFilterDlls) == ERROR_SUCCESS )
        {
            csFilterDlls.TrimLeft();
            csFilterDlls.TrimRight();
            csFilterDlls.MakeLower();
            if (!(csFilterDlls.IsEmpty()))
            {
                CString csTemp;

                while (csFilterDlls.IsEmpty() == FALSE)
                {
                    j = csFilterDlls.Find(_T(','));
                    if ( j != -1 )
                    {
                        // means more than 1 item
                        csTemp = csFilterDlls.Mid(0, j); // retrieve the first one
                        csFilterDlls = csFilterDlls.Mid(j+1);
                        csFilterDlls.TrimLeft();
                    }
                    else
                    { // has only one item
                        csTemp = csFilterDlls.Mid(0);
                        csFilterDlls.Empty();
                    }

                    csPath = csTemp;
                    // get the filename of this dll, i.e., <path>\f1.dll ==> f1
                    j = csTemp.ReverseFind(_T('\\'));
                    j = (j==-1) ? 0 : j+1; // move j to the first char of the pure filename

                    // change csTemp = f1.dll
                    csTemp = csTemp.Mid(j);

                    j = csTemp.Find(_T('.'));
                    csName = (j==-1) ? csTemp : csTemp.Mid(0, j);

                    // add to arrary, avoid redundency
                    for (k=0; k<c; k++)
                    {
                        if (csName.Compare((CString)arrayName[k]) == 0)
                            break;
                    }
                    if (k==c)
                    {
                        arrayName.Add(csName);
                        arrayPath.Add(csPath);
                        c++;
                    }
                }
            }
        }
    }

    // make sure there are entries to write out...
    if (arrayName.GetSize() > 0)
    {
        // if we are upgrading from Beta3 we need to take care to add the new filters to
        // the existing ones that are in the metabase. - boydm
        CString csOrder;                            // cstrings initialize to empty
        // now the array is ready to use, and it has at least 2 items
        csOrder = (CString)arrayName[0];
        for (k=1; k<c; k++)
            {
            csOrder += _T(",");
            csOrder += arrayName[k];
            }

        // now we have csOrder=f1,f2,f3,sspifilt
        // About KeyType
        dwReturnTemp = WriteToMD_Filters_List_Entry(csOrder);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        CString csMDPath;
        for (k=0; k<c; k++)
        {
            dwReturnTemp = WriteToMD_Filter_Entry((CString) arrayName[k], (CString) arrayPath[k]);
            if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}
        }
    }

    return dwReturn;
}

#ifndef _CHICAGO_
// UNDONE: WE NEED TO DO ERROR CHECKING HERE!!!!!!!!!!!!!
DWORD UpgradeCryptoKeys_WWW(void)
{
    DWORD dwReturn = E_FAIL;
    if ( g_pTheApp->m_eOS != OS_W95 )
    {
        // if upgrading iis 2 or 3, then the keys are stored in the LSA/Registry.
        if (g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30 )
        {
            // prepare the machine name
            WCHAR wchMachineName[UNLEN + 1];
            memset( (PVOID)wchMachineName, 0, sizeof(wchMachineName));
#if defined(UNICODE) || defined(_UNICODE)
            wcsncpy(wchMachineName, g_pTheApp->m_csMachineName, UNLEN);
#else
            MultiByteToWideChar(CP_ACP, 0, (LPCSTR)g_pTheApp->m_csMachineName, -1, (LPWSTR)wchMachineName, UNLEN);
#endif
            // upgrade the keys
            UpgradeLSAKeys( wchMachineName );

            dwReturn = ERROR_SUCCESS;
        }

        // if upgrading iis 4, then the keys are stored in the metabase
        if (!g_pTheApp->m_bWin95Migration)
        {
            if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
            {
                Upgradeiis4Toiis5MetabaseSSLKeys();
                dwReturn = ERROR_SUCCESS;
            }
        }
    }
    return dwReturn;
}
#endif //_CHICAGO_


// add pSrc on top of pDest
void Merge2IPNodes(CMapStringToString *pSrc, CMapStringToString *pDest)
{
    CString csName, csSrcValue, csDestValue;
    POSITION pos = pSrc->GetStartPosition();
    while (pos)
    {
        pSrc->GetNextAssoc(pos, csName, csSrcValue);
        if (pDest->Lookup(csName, csDestValue) == FALSE)
        {
            // add this new value to pDest
            pDest->SetAt(csName, csSrcValue);
        }
    }
    return;
}

/*
Logic:
1. Create pNew, which contains new vroots except the home root
2. Get pMap from registry in Upgrade case, or pMap is empty in Fresh case.
3. If pMap is empty, add home root into pNews, set pMap to contain null==>pNew. goto 8.
4. If pMap is not empty and nullNode exists, Merge nullNode into pNew. goto 6.
5. If pMap is not empty and nullNode does not exist, goto 6.
6. Merge pNew onto each ipNodes in the pMap
7. For nullNode in pMap, if there is no / (home root) exists, delete this nullNode from the pMap.
8. Done.
*/
void CreateWWWVRMap(CMapStringToOb *pMap)
{
    CString name, value;
    CMapStringToString *pNew;

    {
        pNew = new CMapStringToString;

        // only create new scripts directories if this is either new or maintenance. If we were to
        // create it here on an upgrade, it replaces the user's old scripts directory. - Actually
        // this is only true if the user's old script directory has different capitalization than
        // what is listed below. This is because the merge routine that mushes together the pNew
        // and pMap lists is case sensitive. The old ones are usually "Scripts" with a capital S.
		/*
        if ( (g_pTheApp->m_eInstallMode == IM_FRESH)||(g_pTheApp->m_eInstallMode == IM_MAINTENANCE) )
            {
            name = _T("/scripts");
            value.Format(_T("%s,,%x"), g_pTheApp->m_csPathScripts, MD_ACCESS_EXECUTE);
            value.MakeLower();
            pNew->SetAt(name, value);
            }
		*/

		// Create the scripts dir always.
        // HANDLED in the inf file in iis6
        /*
        name = _T("/scripts");
        value.Format(_T("%s,,%x"), g_pTheApp->m_csPathScripts, MD_ACCESS_EXECUTE);
        value.MakeLower();
        pNew->SetAt(name, value);
        */

        name = _T("/iishelp");
        value.Format(_T("%s\\Help\\iishelp,,%x"), g_pTheApp->m_csWinDir, MD_ACCESS_SCRIPT | MD_ACCESS_READ);
        value.MakeLower();
        pNew->SetAt(name, value);

	// bug # 123133	iis5.1 Remove samples from install
        // name = _T("/iissamples");
        // value.Format(_T("%s,,%x"), g_pTheApp->m_csPathIISSamples, MD_ACCESS_SCRIPT | MD_ACCESS_READ);
        // value.MakeLower();
        // pNew->SetAt(name, value);

		/*
		removed per bug#197982 8/11/98
		The decision was made NOT to setup the IISADMPWD vdir.
		can you pls still copy the files but not set up the vdir?
        if (g_pTheApp->m_eOS != OS_W95)
        {
            name = _T("/iisadmpwd");
            value.Format(_T("%s\\iisadmpwd,,%x"), g_pTheApp->m_csPathInetsrv, MD_ACCESS_EXECUTE);
            value.MakeLower();
            pNew->SetAt(name, value);
        }
		*/

/*
        // actually this was removed per bug318938 
        // --------------------------------
        // handled in the inf file for iis6
        // --------------------------------
        // Add the msadc virtual root

        // Get the path for msadc...
        // C:\Program Files\Common Files\system\msadc
        CString csCommonFilesPath;
        csCommonFilesPath = g_pTheApp->m_csSysDrive + _T("\\Program Files\\Common Files");
        CRegKey regCurrentVersion(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows\\CurrentVersion"), KEY_READ);
        if ( (HKEY)regCurrentVersion )
        {
            if (regCurrentVersion.QueryValue(_T("CommonFilesDir"), csCommonFilesPath) != 0)
            {
                csCommonFilesPath = g_pTheApp->m_csSysDrive + _T("\\Program Files\\Common Files");
            }
            else
            {
                if (-1 != csCommonFilesPath.Find(_T('%')) )
                {
                    // there is a '%' in the string
                    TCHAR szTempDir[_MAX_PATH];
                    _tcscpy(szTempDir, csCommonFilesPath);
                    if (ExpandEnvironmentStrings( (LPCTSTR)csCommonFilesPath, szTempDir, sizeof(szTempDir)/sizeof(TCHAR)))
                        {
                        csCommonFilesPath = szTempDir;
                        }
                }
            }
        }
		SetupSetDirectoryId_Wrapper(g_pTheApp->m_hInfHandle, 32777, g_pTheApp->m_csPathProgramFiles);

        CString csCommonFilesPath2;
        csCommonFilesPath2 = AddPath(csCommonFilesPath, _T("System\\msadc"));

        name = _T("/msadc");
        value.Format(_T("%s,,%x"), csCommonFilesPath2, MD_ACCESS_READ | MD_ACCESS_EXECUTE | MD_ACCESS_SCRIPT);
        value.MakeLower();
        pNew->SetAt(name, value);
*/

    }

    if (g_pTheApp->m_eUpgradeType == UT_10_W95 || g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30)
    {
        CElem elem;
        elem.ReadRegVRoots(REG_WWWVROOTS, pMap);

        // check to see if pMap contains a null node (default website). If there is no default
        // node, then add one with nothing in it. This will later be merged with the pNew map - boydm
        CMapStringToString *pNullNode;
        if ( !pMap->Lookup(_T("null"),(CObject*&)pNullNode) )
        {
            // there is no node in the map that corresponds to the default website. We must create
            // one at this point and add it to the list
            pNullNode = new CMapStringToString;

            if (pNullNode)
            {
                // add the home root to the new null node
                name = _T("/");
                value.Format(_T("%s,,%x"), g_pTheApp->m_csPathWWWRoot, MD_ACCESS_SCRIPT | MD_ACCESS_READ);
                value.MakeLower();
                pNullNode->SetAt(name, value);

                // add it to the pMap
                pMap->SetAt(_T("null"), pNullNode);
            }
        }

        if (pMap->IsEmpty())
            {iisDebugOut((LOG_TYPE_TRACE, _T("UpgradeVDirs:No VDirs To Upgrade\n")));}
    }

    if ( pMap->IsEmpty() )
    {
        // we don't need to add a default website when
        // add home root to pNew, set pMap to contain null==>pNew. Done.
        name = _T("/");
        value.Format(_T("%s,,%x"), g_pTheApp->m_csPathWWWRoot, MD_ACCESS_SCRIPT | MD_ACCESS_READ);
        value.MakeLower();
        pNew->SetAt(name, value);
        pMap->SetAt(_T("null"), pNew);
    }
    else
    {
        CMapStringToString *pNullObj;
        CString csIP;
        CMapStringToString *pObj;
        POSITION pos = NULL;

        // if there is a default website in the map, add all the "standard" new virtual
        // directories to it.
        if (pMap->Lookup(_T("null"), (CObject*&)pNullObj))
        {
            // add nullNode contents into pNew
            Merge2IPNodes(pNullObj, pNew);
        }

        // add pNew to each ipNodes in the pMap
        pos = pMap->GetStartPosition();
        while (pos)
        {
            pMap->GetNextAssoc(pos, csIP, (CObject*&)pObj);
            Merge2IPNodes(pNew, pObj);
            pMap->SetAt(csIP, pObj);
        }
/*
#ifdef 0        // boydm - we don't know why it would do this.
        // delete the nullNode if it doesn't contain home root
        if (pMap->Lookup(_T("null"), (CObject*&)pNullObj)) {
            if (pNullObj->Lookup(_T("/"), value) == FALSE) {
                // delete this nullNode from pMap
                delete pNullObj;
                pMap->RemoveKey(_T("null"));
            }
        }
#endif
*/
    }

    return;
}

void CreateFTPVRMap(CMapStringToOb *pMap)
{
    CString name, value;
    CMapStringToString *pNew;

    pNew = new CMapStringToString;

    if (g_pTheApp->m_eUpgradeType == UT_10_W95 || g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30)
    {
        CElem elem;
        elem.ReadRegVRoots(REG_FTPVROOTS, pMap);
    }

    if ( pMap->IsEmpty() )
    {
        // add home root to pNew, set pMap to contain null==>pNew. Done.
        name = _T("/");
        value.Format(_T("%s,,%x"), g_pTheApp->m_csPathFTPRoot, MD_ACCESS_READ);
        value.MakeLower();
        pNew->SetAt(name, value);
        pMap->SetAt(_T("null"), pNew);
    }
    else
    {
        CMapStringToString *pNullObj;
        CString csIP;
        CMapStringToString *pObj;
        POSITION pos = NULL;

        if (pMap->Lookup(_T("null"), (CObject*&)pNullObj))
        {
            // add nullNode contents into pNew
            Merge2IPNodes(pNullObj, pNew);
        }

        // add pNew to each ipNodes in the pMap
        pos = pMap->GetStartPosition();
        while (pos)
        {
            pMap->GetNextAssoc(pos, csIP, (CObject*&)pObj);
            Merge2IPNodes(pNew, pObj);
            pMap->SetAt(csIP, pObj);
        }

        // delete the nullNode if it doesn't contain home root
        if (pMap->Lookup(_T("null"), (CObject*&)pNullObj))
        {
            if (pNullObj->Lookup(_T("/"), value) == FALSE)
            {
                // delete this nullNode from pMap
                delete pNullObj;
                pMap->RemoveKey(_T("null"));
            }
        }
    }

    return;
}


void EmptyMap(CMapStringToOb *pMap)
{
    POSITION pos = pMap->GetStartPosition();
    while (pos)
    {
        CString csKey;
        CMapStringToString *pObj;
        pMap->GetNextAssoc(pos, csKey, (CObject*&)pObj);
        delete pObj;
    }
    pMap->RemoveAll();
}


void DumpVRootList(CMapStringToOb *pMap)
{
    /*
    CMapStringToString *pGlobalObj;
    if (pMap->Lookup(_T("null"), (CObject*&)pGlobalObj))
    {
        POSITION pos = pGlobalObj->GetStartPosition();
        while (pos)
        {
            CString csValue;
            CString csName;
            pGlobalObj->GetNextAssoc(pos, csName, csValue);
            // dump out the vroots...
            iisDebugOut((LOG_TYPE_TRACE, _T("DumpVRootList: Virtual Root to create():%s=%s\n")));
         }
    }
    */

    CString csIP;
    CMapStringToString *pObj;
    //
    // loop though the virtual servers...
    //
    POSITION pos0 = pMap->GetStartPosition();
    while (pos0)
    {
        csIP.Empty();
        pMap->GetNextAssoc(pos0, csIP, (CObject*&)pObj);

        POSITION pos1 = pObj->GetStartPosition();
        while (pos1)
        {
            CString csValue;
            CString csName;
            pObj->GetNextAssoc(pos1, csName, csValue);

            // dump out the vroots...
            iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("DumpVRootList: ip=%s:VRoot to create:%s=%s\n"), csIP, csName, csValue));
        }
    }

    return;
}

void SsyncVRoots(LPCTSTR szSvcName, CMapStringToOb *pMap)
{
    CString csParam = _T("System\\CurrentControlSet\\Services\\");
    csParam += szSvcName;
    csParam += _T("\\Parameters");

    CRegKey regParam(HKEY_LOCAL_MACHINE, csParam);
    if ((HKEY)regParam)
    {
        // remove the old virtual roots key
        regParam.DeleteTree(_T("Virtual Roots"));
/*
        CMapStringToString *pGlobalObj;
        if (pMap->Lookup(_T("null"), (CObject*&)pGlobalObj)) {
            // recreate the key
            CRegKey regVRoots(_T("Virtual Roots"), (HKEY)regParam);
            if ((HKEY)regVRoots) {
                POSITION pos = pGlobalObj->GetStartPosition();
                while (pos) {
                    CString csValue;
                    CString csName;
                    pGlobalObj->GetNextAssoc(pos, csName, csValue);
                    regVRoots.SetValue(csName, csValue);
                }
            }
        }
*/
    }
}

void AddVRootsToMD(LPCTSTR szSvcName)
{
    iisDebugOut_Start(_T("AddVRootsToMD"),LOG_TYPE_TRACE);

    CMapStringToOb Map;

    if (_tcsicmp(szSvcName, _T("W3SVC")) == 0)
    {
        CreateWWWVRMap(&Map);
    }

    if (_tcsicmp(szSvcName, _T("MSFTPSVC")) == 0)
    {
        CreateFTPVRMap(&Map);
    }

    //Display Virtuall roots which we should create!!!
    DumpVRootList(&Map);

    // all ssyncvroots seems to do is delete the old vroots from the registry, if there are any
    SsyncVRoots(szSvcName, &Map);

    // This actually takes the virtual website and root map
    // built in CreateWWWVRMap and applies it to the metabase
    AddVRMapToMD(szSvcName, &Map);

    EmptyMap(&Map);

    iisDebugOut_End(_T("AddVRootsToMD"),LOG_TYPE_TRACE);
    return;
}


// This routine scans through the virtual web sites and adds them to the metabase
// boydm - I removed much of the guts of this routine and put it into AddVirtualServer above.
// This allows me to treat the null node specially in order to guarantee it goes on site 1
void AddVRMapToMD(LPCTSTR szSvcName, CMapStringToOb *pMap)
{
    UINT i = 1;  // instance number is in range of 1 - 4 billion
    CString csRoot = _T("LM/");
    csRoot += szSvcName; //  "LM/W3SVC"
    csRoot.MakeUpper();
    CMapStringToString *pObj = NULL;
    CString csIP;

    // look for the null node. If it is there, then that is the default server.
    // we must add that one first so that it is virtual server number 1
    if ( pMap->Lookup(_T("null"),(CObject*&)pObj) )
        {
        // set the ip string to null
        csIP = _T("null");

        // add the virtual server
        // make sure to specify site #1 !!!
        i = AddVirtualServer( szSvcName, 1, pObj, csRoot, csIP) + 1;

        // remove the null mapping list from the main mapping object
        if ( pMap->RemoveKey( _T("null") ) )
            {
            // clean it up from memory too
            delete pObj;
            pObj = NULL;
            }
        }

    // loop though the rest of the virtual servers and add them as well
    POSITION pos0 = pMap->GetStartPosition();
    while (pos0)
    {
        csIP.Empty();
        pMap->GetNextAssoc(pos0, csIP, (CObject*&)pObj);

        // get the next unused instance number and add from there...
        i = GetInstNumber(csRoot, i);

        // add the virtual server
        i = AddVirtualServer( szSvcName, i, pObj, csRoot, csIP) + 1;
    }
}

int GetPortNum(LPCTSTR szSvcName)
{
    CString csPath = _T("SYSTEM\\CurrentControlSet\\Control\\ServiceProvider\\ServiceTypes\\");
    csPath += szSvcName;

    DWORD dwPort = 0;
    if (_tcsicmp(szSvcName, _T("W3SVC")) == 0) {dwPort = 80;}
    if (_tcsicmp(szSvcName, _T("MSFTPSVC")) == 0) {dwPort = 21;}

    CRegKey regKey(HKEY_LOCAL_MACHINE, csPath, KEY_READ);
    if ( (HKEY)regKey )
    {
        regKey.QueryValue(_T("TcpPort"), dwPort);
    }
    return (int)dwPort;
}

// if not exist, create it; else, return immediately
void AddMDVRootTree(CString csKeyPath, CString csName, CString csValue, LPCTSTR pszIP, UINT nProgressBarTextWebInstance)
{
    CString csPath = csKeyPath;
    CMDKey cmdKey;

    csPath += _T("/Root");
    if (csName.Compare(_T("/")) != 0)
        csPath += csName;   // LM/W3SVC/N//iisadmin

    cmdKey.OpenNode(csPath);
    if ( (METADATA_HANDLE)cmdKey )
    {
        cmdKey.Close();
    }
    else
    {
        CreateMDVRootTree(csKeyPath, csName, csValue, pszIP, nProgressBarTextWebInstance);
    }
    return;
}


int SetVRootPermissions_w3svc(CString csKeyPath, LPTSTR szPath, DWORD *pdwPerm)
{
    int iReturn = TRUE;
    DWORD dwPerm;
    dwPerm = *pdwPerm;
    if (csKeyPath.Find(_T("W3SVC")) != -1)
    {
        iisDebugOut_Start1(_T("SetVRootPermissions_w3svc"), csKeyPath, LOG_TYPE_TRACE);

        // if this is www, and it is because of the above test, then we always
        // turn on the MD_ACCESS_SCRIPT flag if MD_ACCESS_EXECUTE is on. This
        // fixes a Upgrade from IIS3 problem - boydm
        if ( dwPerm & MD_ACCESS_EXECUTE )
        {
            dwPerm |= MD_ACCESS_SCRIPT;
        }

        // add MD_ACCESS_SCRIPT to wwwroot
        if (csKeyPath.Right(4) == _T("ROOT"))
        {
            dwPerm |= MD_ACCESS_SCRIPT;
        }

        // reset /iisadmin path, add more Permission
        if (csKeyPath.Right(8) == _T("IISADMIN"))
        {
            CString csPath = g_pTheApp->m_csPathInetsrv;
            csPath += _T("\\iisadmin");
            _tcscpy(szPath, csPath);
            if (g_pTheApp->m_eOS == OS_NT && g_pTheApp->m_eNTOSType != OT_NTW)
            {
                dwPerm |= MD_ACCESS_SCRIPT | MD_ACCESS_READ;
            }
            else
            {
                dwPerm |= MD_ACCESS_SCRIPT | MD_ACCESS_READ | MD_ACCESS_NO_REMOTE_READ | MD_ACCESS_NO_REMOTE_SCRIPT;
            }
        }

        *pdwPerm = dwPerm;
    }
    iisDebugOut((LOG_TYPE_TRACE, _T("SetVRootPermissions_w3svc:(%s),return=0x%x.\n"), csKeyPath, dwPerm));
    return iReturn;
}

/*
[/W3SVC/1/ROOT]
     AccessPerm                    : [IF]    (DWORD)  0x201={Read Script}
     6039                          : [IF]    (DWORD)  0x1={1}
     VrPath                        : [IF]    (STRING) "c:\inetpub\wwwroot"
     KeyType                       : [S]     (STRING) "IIsWebVirtualDir"
[/W3SVC/1/ROOT/IISADMIN]
      AccessPerm                    : [IF]    (DWORD)  0x201={Read Script}
      Authorization                 : [IF]    (DWORD)  0x4={NT}
      VrPath                        : [IF]    (STRING) "C:\WINNT\System32\inetsrv\iisadmin"
      KeyType                       : [S]     (STRING) "IIsWebVirtualDir"
      IpSec                         : [IRF]   (BINARY) 0x18 00 00 80 20 00 00 80 3c 00 00 80 44 00 00 80 01 00 00 00 4c 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 01 00 00 00 02 00 00 00 02 00 00 00 04 00 00 00 00 00 00 00 4c 00 00 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff ff ff ff 7f 00 00 01
      CustomError                   : [IF]    (MULTISZ) "400,*,FILE,C:\WINNT\help\iisHelp\common\400.htm" "401,1,FILE,C:\WINNT\help\iisHelp\common\401-1.htm" "401,2,FILE,C:\WINNT\help\iisHelp\common\401-2.htm" "401,3,FILE,C:\WINNT\help\iisHelp\common\401-3.htm" "401,4,FILE,C:\WINNT\help\iisHelp\common\401-4.htm" "401,5,FILE,C:\WINNT\help\iisHelp\common\401-5.htm" "403,1,FILE,C:\WINNT\help\iisHelp\common\403-1.htm" "403,2,FILE,C:\WINNT\help\iisHelp\common\403-2.htm" "403,3,FILE,C:\WINNT\help\iisHelp\common\403-3.htm" "403,4,FILE,C:\WINNT\help\iisHelp\common\403-4.htm" "403,5,FILE,C:\WINNT\help\iisHelp\common\403-5.htm" "403,7,FILE,C:\WINNT\help\iisHelp\common\403-7.htm" "403,8,FILE,C:\WINNT\help\iisHelp\common\403-8.htm" "403,9,FILE,C:\WINNT\help\iisHelp\common\403-9.htm" "403,10,FILE,C:\WINNT\help\iisHelp\common\403-10.htm" "403,11,FILE,C:\WINNT\help\iisHelp\common\403-11.htm" "403,12,FILE,C:\WINNT\help\iisHelp\common\403-12.htm" "404,*,FILE,C:\WINNT\help\iisHelp\common\404b.htm" "405,*,FILE,C:\WINNT\help\iisHelp\common\405.htm" "406,*,FILE,C:\WINNT\help\iisHelp\common\406.htm" "407,*,FILE,C:\WINNT\help\iisHelp\common\407.htm" "412,*,FILE,C:\WINNT\help\iisHelp\common\412.htm" "414,*,FILE,C:\WINNT\help\iisHelp\common\414.htm" "500,12,FILE,C:\WINNT\help\iisHelp\common\500-12.htm" "500,13,FILE,C:\WINNT\help\iisHelp\common\500-13.htm" "500,15,FILE,C:\WINNT\help\iisHelp\common\500-15.htm" "500,100,URL,/help/common/500-100.asp" "403,6,FILE,C:\WINNT\help\iishelp\common\htmla.htm"
[/W3SVC/1/ROOT/IISSAMPLES]
      AccessPerm                    : [IF]    (DWORD)  0x201={Read Script}
      VrPath                        : [IF]    (STRING) "c:\inetpub\iissamples"
      KeyType                       : [S]     (STRING) "IIsWebVirtualDir"
[/W3SVC/1/ROOT/IISHELP]
      AccessPerm                    : [IF]    (DWORD)  0x201={Read Script}
      VrPath                        : [IF]    (STRING) "c:\winnt\help\iishelp"
      KeyType                       : [S]     (STRING) "IIsWebVirtualDir"
      CustomError                   : [IF]    (MULTISZ) "400,*,FILE,C:\WINNT\help\iisHelp\common\400.htm" "401,1,FILE,C:\WINNT\help\iisHelp\common\401-1.htm" "401,2,FILE,C:\WINNT\help\iisHelp\common\401-2.htm" "401,3,FILE,C:\WINNT\help\iisHelp\common\401-3.htm" "401,4,FILE,C:\WINNT\help\iisHelp\common\401-4.htm" "401,5,FILE,C:\WINNT\help\iisHelp\common\401-5.htm" "403,1,FILE,C:\WINNT\help\iisHelp\common\403-1.htm" "403,2,FILE,C:\WINNT\help\iisHelp\common\403-2.htm" "403,3,FILE,C:\WINNT\help\iisHelp\common\403-3.htm" "403,4,FILE,C:\WINNT\help\iisHelp\common\403-4.htm" "403,5,FILE,C:\WINNT\help\iisHelp\common\403-5.htm" "403,6,FILE,C:\WINNT\help\iisHelp\common\403-6.htm" "403,7,FILE,C:\WINNT\help\iisHelp\common\403-7.htm" "403,8,FILE,C:\WINNT\help\iisHelp\common\403-8.htm" "403,9,FILE,C:\WINNT\help\iisHelp\common\403-9.htm" "403,10,FILE,C:\WINNT\help\iisHelp\common\403-10.htm" "403,11,FILE,C:\WINNT\help\iisHelp\common\403-11.htm" "403,12,FILE,C:\WINNT\help\iisHelp\common\403-12.htm" "405,*,FILE,C:\WINNT\help\iisHelp\common\405.htm" "406,*,FILE,C:\WINNT\help\iisHelp\common\406.htm" "407,*,FILE,C:\WINNT\help\iisHelp\common\407.htm" "412,*,FILE,C:\WINNT\help\iisHelp\common\412.htm" "414,*,FILE,C:\WINNT\help\iisHelp\common\414.htm" "500,12,FILE,C:\WINNT\help\iisHelp\common\500-12.htm" "500,13,FILE,C:\WINNT\help\iisHelp\common\500-13.htm" "500,15,FILE,C:\WINNT\help\iisHelp\common\500-15.htm" "500,100,URL,/help/common/500-100.asp" "404,*,FILE,C:\WINNT\help\iishelp\common\404.htm"
[/W3SVC/1/ROOT/SCRIPTS]
      AccessPerm                    : [IF]    (DWORD)  0x204={Execute Script}
      VrPath                        : [IF]    (STRING) "c:\inetpub\scripts"
      KeyType                       : [S]     (STRING) "IIsWebVirtualDir"
*/
void CreateMDVRootTree(CString csKeyPath, CString csName, CString csValue, LPCTSTR pszIP, UINT nProgressBarTextWebInstance)
{
    iisDebugOut((LOG_TYPE_TRACE, _T("CreateMDVRootTree():Start.%s.%s.%s.%s.\n"),csKeyPath,csName,csValue,pszIP));
    int iOverwriteAlways = TRUE;
    int iThisIsAnIISDefaultApp = FALSE;
    int iCreateAnApplicationForThis = FALSE;
    CMDKey cmdKey;
    CString csKeyPath_Copy;

    TCHAR szPath[_MAX_PATH], szUserName[_MAX_PATH];
    DWORD dwPerm, dwRegularPerm, dwSSLPerm;

    csKeyPath += _T("/Root");
    if (csName.Compare(_T("/")) != 0)
    {
        csKeyPath += csName;   // LM/W3SVC/N/Root/iisadmin
    }
    csKeyPath.MakeUpper();


    // let the user know what is going on which this vroot!
    UINT SvcId;
    SvcId = IDS_ADD_SETTINGS_FOR_WEB_2;
    if ( csKeyPath.Find(_T("MSFTPSVC")) != -1 ) {SvcId = IDS_ADD_SETTINGS_FOR_FTP_2;}

    //
    // see if we can create the node.  if we can't then return!
    //
    csKeyPath_Copy = csKeyPath;

    // Make it look good.
    if (csKeyPath.Right(8) == _T("IISADMIN"))
    {
        csKeyPath_Copy = csKeyPath.Left(csKeyPath.GetLength() - 8);
        csKeyPath_Copy += _T("IISAdmin");
    }
    if (csKeyPath.Right(6) == _T("WEBPUB"))
    {
        csKeyPath_Copy = csKeyPath.Left(csKeyPath.GetLength() - 6);
        csKeyPath_Copy += _T("Webpub");
    }

    if (csKeyPath.Right(10) == _T("IISSAMPLES"))
    {
        csKeyPath_Copy = csKeyPath.Left(csKeyPath.GetLength() - 10);
        csKeyPath_Copy += _T("IISSamples");
    }

    if (csKeyPath.Right(7) == _T("IISHELP"))
    {
        csKeyPath_Copy = csKeyPath.Left(csKeyPath.GetLength() - 7);
        csKeyPath_Copy += _T("IISHelp");
    }
    if (csKeyPath.Right(7) == _T("SCRIPTS"))
    {
        csKeyPath_Copy = csKeyPath.Left(csKeyPath.GetLength() - 7);
        csKeyPath_Copy += _T("Scripts");
    }

    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, csKeyPath_Copy);
    if ( !(METADATA_HANDLE)cmdKey )
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("CreateMDVRootTree():CreateNode %s.FAILED.\n"),csKeyPath_Copy));
        return;
    }
    cmdKey.Close();

    //
    // Get the virtual root data
    //
    memset( (PVOID)szPath, 0, sizeof(szPath));
    memset( (PVOID)szUserName, 0, sizeof(szUserName));
    SplitVRString(csValue, szPath, szUserName, &dwPerm);

    //
    // Set KeyType
    //
    if ( csKeyPath.Find(_T("W3SVC")) != -1 )
        WriteToMD_IIsWebVirtualDir(csKeyPath);
    else
        WriteToMD_IIsFtpVirtualDir(csKeyPath);

    //
    // Will return szPath and dwPerm.
    // Get the permissions
    //
    SetVRootPermissions_w3svc(csKeyPath, szPath, &dwPerm);

    //
    // Set The path of the virtual root.
    //
    // if this is the Default VRoot then, don't overwrite it if already there!!!
    //
    iOverwriteAlways = TRUE;
    if (csName.Compare(_T("/")) == 0) {iOverwriteAlways = FALSE;}
    WriteToMD_VRootPath(csKeyPath, szPath, iOverwriteAlways);

    //
    // Set regular permissions
    //
    dwRegularPerm = dwPerm & MD_NONSLL_ACCESS_MASK;
    dwSSLPerm = dwPerm & MD_SSL_ACCESS_MASK;
    // do not overwrite if the value is already there!
    WriteToMD_AccessPerm(csKeyPath, dwRegularPerm, FALSE);

    //
    // Set ssl permissions
    //
    // Do, not overwrite if the value is already there!
    //
    if (dwSSLPerm && (csKeyPath.Find(_T("W3SVC")) != -1))
    {
        WriteToMD_SSLPerm(csKeyPath, dwSSLPerm, FALSE);
    }

    //
    // iif iisadmin then set Authorization
    //
    if (csKeyPath.Right(8) == _T("IISADMIN"))
    {
        if (g_pTheApp->m_eOS == OS_NT && g_pTheApp->m_eNTOSType != OT_NTW)
        {
            WriteToMD_Authorization(csKeyPath, MD_AUTH_NT);
        }

        // bug#340576
        // removed per bug#340576
        // should look like this: LM/W3SVC/N/Root/iisadmin
        //WriteToMD_AspCodepage(csKeyPath, 65001, FALSE);

        // bug#356345
        WriteToMD_EnableParentPaths_WWW(csKeyPath, TRUE);
    }

    //
    // if /IISHELP then make sure this is off bug356345
    //
    if (csKeyPath.Right(7) == _T("IISHELP")) 
    {
        WriteToMD_EnableParentPaths_WWW(csKeyPath, FALSE);
    }

    //
    // if /IISSAMPLES then set dirbrowsing on.
    //
    if (csKeyPath.Right(10) == _T("IISSAMPLES"))
    {
        WriteToMD_DirBrowsing_WWW(csKeyPath);
    }

    // If username is something,
    // then let's get the password and save it to the metabase
    if (szUserName[0] != _T('\0'))
    {
        // do have username and path is UNC
        WriteToMD_VRUserName(csKeyPath, szUserName);

#ifndef _CHICAGO_
        CString csRoot;
        TCHAR szRootPassword[_MAX_PATH] = _T("");
        BOOL b;

        // if this is for the w3svc server...
        if (csKeyPath.Find(_T("W3SVC")) != -1)
        {
            if (!pszIP || !(*pszIP) || !(_tcsicmp(pszIP, _T("null"))))
            {
                // first, try <vroot>
                csRoot = csName;
                b = GetRootSecret(csRoot, _T("W3_ROOT_DATA"), szRootPassword);
                if (!b || !(*szRootPassword))
                {
                    // second, try <vroot>,
                    csRoot = csName + _T(",");
                    b = GetRootSecret(csRoot, _T("W3_ROOT_DATA"), szRootPassword);
                    if (!b)
                        *szRootPassword = _T('\0');
                }
            }
            else
            {
                csRoot = csName + _T(",");
                csRoot += pszIP;
                b = GetRootSecret(csRoot, _T("W3_ROOT_DATA"), szRootPassword);
                if (!b)
                    *szRootPassword = _T('\0');
            }
        }

        // if this is for the ftp server...
        if (csKeyPath.Find(_T("MSFTPSVC")) != -1)
        {
            if (!pszIP || !(*pszIP) || !(_tcsicmp(pszIP, _T("null"))))
            {
                // first, try <vroot>
                csRoot = csName;
                b = GetRootSecret(csRoot, _T("FTPD_ROOT_DATA"), szRootPassword);
                if (!b || !(*szRootPassword))
                {
                    // second, try <vroot>,
                    csRoot = csName + _T(",");
                    b = GetRootSecret(csRoot, _T("FTPD_ROOT_DATA"), szRootPassword);
                    if (!b)
                        *szRootPassword = _T('\0');
                }
            }
            else
            {
                csRoot = csName + _T(",");
                csRoot += pszIP;
                b = GetRootSecret(csRoot, _T("FTPD_ROOT_DATA"), szRootPassword);
                if (!b)
                    *szRootPassword = _T('\0');
            }
        }

        // if we have a password, then write it out
        if (*szRootPassword)
        {
            WriteToMD_VRPassword(csKeyPath, szRootPassword);
        }
#endif
    }


    //
    // If this is the W3svc service then
    // Create an Inprocess application for Certain Virtual Roots.
    //
    if (csKeyPath.Find(_T("W3SVC")) != -1)
    {
        CString csVirtualRootName;
        csVirtualRootName = csKeyPath;
        iCreateAnApplicationForThis = FALSE;
        iThisIsAnIISDefaultApp = FALSE;

        // maintain backward compatibility
        // Any vroot with execute permissions is an application
        if ((g_pTheApp->m_eInstallMode == IM_UPGRADE) && (dwPerm & MD_ACCESS_EXECUTE))
        {
            // Set this to true so that this previous iis application will
            // be created as an com+ applicaton
            iCreateAnApplicationForThis = TRUE;

            // but if this is the msadc vroot then don't set as an application
            // removed per bug 340993 make RDS vroot run oop
            //if (csKeyPath.Right(5) == _T("MSADC")) {iCreateAnApplicationForThis = FALSE;}
        }


        // on a fresh install MSADC needs to be it's owned pooled application
        // on an upgrade just leave it alone.
        if (csKeyPath.Right(5) == _T("MSADC")) {csVirtualRootName = csKeyPath.Right(5); iCreateAnApplicationForThis = TRUE; iThisIsAnIISDefaultApp = TRUE;}
        // if these are our paths then createinproc them
        if (csKeyPath.Right(4) == _T("ROOT")) {csVirtualRootName = csKeyPath.Right(4); iCreateAnApplicationForThis = TRUE; iThisIsAnIISDefaultApp = TRUE;}
        if (csKeyPath.Right(8) == _T("IISADMIN")) {csVirtualRootName = csKeyPath.Right(8);iCreateAnApplicationForThis = TRUE; iThisIsAnIISDefaultApp = TRUE;}
        if (csKeyPath.Right(6) == _T("WEBPUB")) {csVirtualRootName = csKeyPath.Right(6);iCreateAnApplicationForThis = TRUE; iThisIsAnIISDefaultApp = TRUE;}
        if (csKeyPath.Right(10) == _T("IISSAMPLES")) {csVirtualRootName = csKeyPath.Right(10);iCreateAnApplicationForThis = TRUE; iThisIsAnIISDefaultApp = TRUE;}
        if (csKeyPath.Right(7) == _T("IISHELP")) {csVirtualRootName = csKeyPath.Right(7);iCreateAnApplicationForThis = TRUE; iThisIsAnIISDefaultApp = TRUE;}
        if (TRUE == iCreateAnApplicationForThis)
        {
            // If this is an upgrade from a previous iis which has a metabase, then
            // Upgrades should leave in-process apps, in-process.
            // Including default sites because they might be running ISAPIs.
            if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
            {
                // Since this upgrade already has a metabase,
                // Leave the default applications and other user
                // applications the way they already are

                // check to see if the appID property exists...
                // if it doesn't then set the property
                if (FALSE == DoesAppIsolatedExist(csKeyPath))
                {
                    // there is no app isolated on this node.
                    iisDebugOut((LOG_TYPE_WARN, _T("No AppIsolated specified for (%s)\n"),csKeyPath));
                }
                else
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("AppIsolated exists for (%s)\n"),csKeyPath));
                }
            }
            else
            {
                if (iThisIsAnIISDefaultApp)
                {
                    // create an inprocess application which uses the OOP Pool
                    // Use The pool since these are "our" vdirs
                    CreateInProc_Wrap(csKeyPath, TRUE);
                }
                else
                {
                    // create an in process application
                    // upgraded iis 2.0/3.0 asp vdirs should
                    // be using this since they were all in-proc in iis 2.0/3.0
                    CreateInProc_Wrap(csKeyPath, FALSE);
                }
            }
        }

        /* Bug114531: no need to add scriptmap under /iisHelp
        if (csKeyPath.Right(7) == _T("IISHELP")) {
            // add script map
            ScriptMapNode ScriptMapList = {0};
            // make it a sentinel
            ScriptMapList.next = &ScriptMapList;
            ScriptMapList.prev = &ScriptMapList;

            GetScriptMapListFromMetabase(&ScriptMapList);
            WriteScriptMapListToMetabase(&ScriptMapList, (LPTSTR)(LPCTSTR)csKeyPath, MD_SCRIPTMAPFLAG_SCRIPT | MD_SCRIPTMAPFLAG_CHECK_PATH_INFO);

            FreeScriptMapList(&ScriptMapList);
        }
        */
    }

    iisDebugOut((LOG_TYPE_TRACE, _T("CreateMDVRootTree():End.%s.%s.%s.%s.\n"),csKeyPath,csName,csValue,pszIP));
}


void SplitVRString(CString csValue, LPTSTR szPath, LPTSTR szUserName, DWORD *pdwPerm)
{
    // csValue should be in format of "<path>,<username>,<perm>"
    // with one exception: IISv1.0 has format of "<Path>"
    CString csPath, csUserName, csPerm;
    int len, i;

    csValue.TrimLeft();
    csValue.TrimRight();
    csPath = _T("");
    csUserName = _T("");
    csPerm = _T("");
    *pdwPerm = 0;

    i = csValue.ReverseFind(_T(','));
    if (i != -1)
    {
        len = csValue.GetLength();
        csPerm = csValue.Right(len - i - 1);
        csValue = csValue.Left(i);

        *pdwPerm = atodw((LPCTSTR)csPerm);

        i = csValue.ReverseFind(_T(','));
        if (i != -1)
        {
            len = csValue.GetLength();
            csUserName = csValue.Right(len - i - 1);
            csPath = csValue.Left(i);
        }
    }
    else
    {
        // assume it is the format of "<Path>"
        csPath = csValue;
    }
    _tcscpy(szPath, (LPCTSTR)csPath);
    _tcscpy(szUserName, (LPCTSTR)csUserName);

    return;
}



// loop thru the metabase
// and look for the next instance number which is not used!
// return that.  "i" is at least = 1.
UINT GetInstNumber(LPCTSTR szMDPath, UINT i)
{
    TCHAR Buf[10];
    CString csInstRoot, csMDPath;
    CMDKey cmdKey;

    csInstRoot = szMDPath;
    csInstRoot += _T("/");

    _itot(i, Buf, 10);
    csMDPath = csInstRoot + Buf;
    cmdKey.OpenNode(csMDPath);
    while ( (METADATA_HANDLE)cmdKey )
    {
        cmdKey.Close();
        _itot(++i, Buf, 10);
        csMDPath = csInstRoot + Buf;
        cmdKey.OpenNode(csMDPath);
    }
    return (i);
}

BOOL ChkMdEntry_Exist(MDEntry *pMDEntry)
{
    BOOL    bReturn = FALSE;
    CMDKey  cmdKey;
    PVOID   pData = NULL;
    MDEntry MDEntryTemp;

    MDEntryTemp.szMDPath =  pMDEntry->szMDPath;

    //_tcscpy(MDEntryTemp.szMDPath,pMDEntry->szMDPath);
    MDEntryTemp.dwMDIdentifier = pMDEntry->dwMDIdentifier;
    MDEntryTemp.dwMDAttributes = pMDEntry->dwMDAttributes;
    MDEntryTemp.dwMDUserType = pMDEntry->dwMDUserType;
    MDEntryTemp.dwMDDataType = pMDEntry->dwMDDataType;
    MDEntryTemp.dwMDDataLen = pMDEntry->dwMDDataLen;
    MDEntryTemp.pbMDData = NULL;

    // if the attributes = METADATA_INHERIT
    // then let's just make sure that we check using the METADATA_NO_ATTRIBUTES deal.
    if (MDEntryTemp.dwMDAttributes == METADATA_INHERIT)
    {
        MDEntryTemp.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    }

    // Check if this is for the  binary type
    if (MDEntryTemp.dwMDDataType == BINARY_METADATA)
    {
        BOOL bFound = FALSE;
        DWORD attr, uType, dType, cbLen;
        CMDKey cmdKey;
        BUFFER bufData;
        PBYTE pData;
        int BufSize;

        cmdKey.OpenNode((LPCTSTR) MDEntryTemp.szMDPath);
        if ( (METADATA_HANDLE) cmdKey )
        {
            pData = (PBYTE)(bufData.QueryPtr());
            BufSize = bufData.QuerySize();
            cbLen = 0;
            bFound = cmdKey.GetData(MDEntryTemp.dwMDIdentifier, &attr, &uType, &dType, &cbLen, pData, BufSize);
            if (bFound)
            {
                bReturn = TRUE;
            }
            else
            {
                if (cbLen > 0)
                {
                    if ( ! (bufData.Resize(cbLen)) )
                    {
                        iisDebugOut((LOG_TYPE_ERROR, _T("ChkMdEntry_Exist():  cmdKey.GetData.  failed to resize to %d.!\n"), cbLen));
                    }
                    else
                    {
                        pData = (PBYTE)(bufData.QueryPtr());
                        BufSize = cbLen;
                        cbLen = 0;
                        //bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
                        bFound = cmdKey.GetData(MDEntryTemp.dwMDIdentifier, &attr, &uType, &dType, &cbLen, pData, BufSize);
                        if (bFound)
                        {
                            bReturn = TRUE;
                        }
                        else
                        {
                            // No the acl Does not exist!
                        }
                    }
                }
                else
                {
                    // No the acl Does not exist!
                }
            }

            cmdKey.Close();
        }
    }
    else
    {
        // Check the metabase and see if the big Key /LM/W3SVC is there
        cmdKey.OpenNode((LPCTSTR) MDEntryTemp.szMDPath);
        if ( (METADATA_HANDLE)cmdKey )
        {
            // Check to see if our little Identifier is there.
            //DWORD dwAttr = METADATA_INHERIT;
            //DWORD dwUType = IIS_MD_UT_SERVER;
            //DWORD dwDType = MULTISZ_METADATA;
            //DWORD dwLength = 0;
            DWORD dwAttr = MDEntryTemp.dwMDAttributes;
            DWORD dwUType = MDEntryTemp.dwMDUserType;
            DWORD dwDType = MDEntryTemp.dwMDDataType;
            DWORD dwLength = 0;

            // we need to start this process by getting the existing multisz data from the metabase
            // first, figure out how much memory we will need to do this
            cmdKey.GetData( MDEntryTemp.dwMDIdentifier,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,MDEntryTemp.dwMDAttributes,MDEntryTemp.dwMDUserType,MDEntryTemp.dwMDDataType);

            // unfortunatly, the above routine only returns TRUE or FALSE. And since we are purposefully
            // passing in a null ponter of 0 size in order to get the length of the data, it will always
            // return 0 whether it was because the metabase is inacessable, or there pointer was NULL,
            // which it is. So - I guess we assume it worked, allocate the buffer and attempt to read it
            // in again.
            TCHAR*      pOurBuffer;
            DWORD       cbBuffer = dwLength;

            // This GetData call is supposed to return back the size of the string we're supposed to alloc.
            // if the string is "Test", then since it's unicode the return would be ((4+1)*2) = 10.
            // if the string is " ", then it would be (1+1)*2=4
            // it should never be something as small as 2.
            /*
            if (cbBuffer <= 2)
            {
                if (dwDType == STRING_METADATA || dwDType == EXPANDSZ_METADATA)
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("ChkMdEntry_Exist[%s:%d].requested size of this property reported back=%2.  which is too small for a string.\n"), MDEntryTemp.szMDPath, MDEntryTemp.dwMDIdentifier, cbBuffer));
                }
            }
            */

            // allocate the space, if it fails, we fail
            // note that GPTR causes it to be initialized to zero
            pData = GlobalAlloc( GPTR, cbBuffer );
            if ( !pData )
                {
                iisDebugOut((LOG_TYPE_ERROR, _T("ChkMdEntry_Exist(%d). Failed to allocate memory.\n"), MDEntryTemp.dwMDIdentifier));
                // We Failed to allocate memory
                cmdKey.Close();
                goto ChkMdEntry_Exist_Exit;
                }
            pOurBuffer = (TCHAR*)pData;

            // now get the data from the metabase
            int iTemp = FALSE;
            iTemp = cmdKey.GetData( MDEntryTemp.dwMDIdentifier,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)pData,cbBuffer,MDEntryTemp.dwMDAttributes,MDEntryTemp.dwMDUserType,MDEntryTemp.dwMDDataType);
            if (iTemp)
            {
                // if we have successfully retrieved the data, then we don't need to overwrite it!
                bReturn = TRUE;
            }
            cmdKey.Close();
        }
    }

ChkMdEntry_Exist_Exit:
    if (pData){GlobalFree(pData);pData=NULL;}
    TCHAR lpReturnString[50];
    ReturnStringForMetabaseID(MDEntryTemp.dwMDIdentifier, lpReturnString);
    if (bReturn)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("ChkMdEntry_Exist[%s:%d:%s]. Exists.\n"), MDEntryTemp.szMDPath, MDEntryTemp.dwMDIdentifier, lpReturnString));
    }
    else
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("ChkMdEntry_Exist[%s:%d:%s]. Not Exists.\n"), MDEntryTemp.szMDPath, MDEntryTemp.dwMDIdentifier, lpReturnString));
    }
    return bReturn;
}


DWORD SetMDEntry_Wrap(MDEntry *pMDEntry)
{
    DWORD  dwReturn = ERROR_SUCCESS;
    int iFoundFlag = FALSE;

    CString csKeyPath = pMDEntry->szMDPath;

    ACTION_TYPE atWWWorFTPorCORE;
    if (csKeyPath.Find(_T("W3SVC")) == -1)
    {
        iFoundFlag = TRUE;
        atWWWorFTPorCORE = GetSubcompAction(_T("iis_www"), FALSE);
    }

    if (iFoundFlag != TRUE)
    {
        if (csKeyPath.Find(_T("MSFTPSVC")) == -1)
        {
            iFoundFlag = TRUE;
            atWWWorFTPorCORE = GetSubcompAction(_T("iis_ftp"), FALSE);
        }
    }

    if (iFoundFlag != TRUE)
    {
        iFoundFlag = TRUE;
        atWWWorFTPorCORE = GetSubcompAction(_T("iis_core"), FALSE);
    }

    if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
    {
        dwReturn = SetMDEntry_NoOverWrite(pMDEntry);
    }
    else
    {
        dwReturn = SetMDEntry(pMDEntry);
    }

    return dwReturn;
}

DWORD DeleteMDEntry(MDEntry *pMDEntry)
{
    CMDKey cmdKey;
    DWORD  dwReturn = ERROR_SUCCESS;

    // Check if it exists first...
    if (ChkMdEntry_Exist(pMDEntry))
    {
        cmdKey.OpenNode((LPCTSTR) pMDEntry->szMDPath);
        if ( (METADATA_HANDLE)cmdKey )
        {
            // Delete the data
            dwReturn = cmdKey.DeleteData(pMDEntry->dwMDIdentifier, pMDEntry->dwMDDataType);
            cmdKey.Close();
        }
    }

    if (FAILED(dwReturn))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("DeleteMDEntry(%d).FAILED.\n"), pMDEntry->dwMDIdentifier));
    }
    return dwReturn;
}



DWORD SetMDEntry(MDEntry *pMDEntry)
{
    CMDKey cmdKey;
    DWORD  dwReturn = ERROR_SUCCESS;

    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, (LPCTSTR)pMDEntry->szMDPath);
    if ( (METADATA_HANDLE)cmdKey )
    {
        dwReturn = ERROR_SUCCESS;
        dwReturn = cmdKey.SetData(pMDEntry->dwMDIdentifier,pMDEntry->dwMDAttributes,pMDEntry->dwMDUserType,pMDEntry->dwMDDataType,pMDEntry->dwMDDataLen,pMDEntry->pbMDData);
        // output what we set to the log file...
        if (FAILED(dwReturn))
        {
            SetErrorFlag(__FILE__, __LINE__);
            iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry:SetData(%d), FAILED. Code=0x%x.End.\n"), pMDEntry->dwMDIdentifier, dwReturn));
        }
        cmdKey.Close();
    }

    if (g_CheckIfMetabaseValueWasWritten == TRUE)
    {
        // Check if the entry now exists....
        if (!ChkMdEntry_Exist(pMDEntry))
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry(%d). Entry which we were supposed to write, does not exist! FAILURE.\n"), pMDEntry->dwMDIdentifier));
        }
    }

    return dwReturn;
}


//  -------------------------------------------
//  MDEntry look something like this:
//
//  stMDEntry.szMDPath = _T("LM/W3SVC");
//  stMDEntry.dwMDIdentifier = MD_NTAUTHENTICATION_PROVIDERS;
//  stMDEntry.dwMDAttributes = METADATA_INHERIT;
//  stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
//  stMDEntry.dwMDDataType = STRING_METADATA;
//  stMDEntry.dwMDDataLen = (csData.GetLength() + 1) * sizeof(TCHAR);
//  stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csData;
//  -------------------------------------------
DWORD SetMDEntry_NoOverWrite(MDEntry *pMDEntry)
{
    DWORD  dwReturn = ERROR_SUCCESS;
    if (ChkMdEntry_Exist(pMDEntry))
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("SetMDEntry_NoOverWrite:SetData(%d). Do not overwrite entry.\n"), pMDEntry->dwMDIdentifier));
    }
    else
    {
        dwReturn = SetMDEntry(pMDEntry);
    }
    return dwReturn;
}


int MigrateInfSectionToMD(HINF hFile, LPCTSTR szSection)
{
    iisDebugOut_Start1(_T("MigrateInfSectionToMD"),(LPTSTR) szSection, LOG_TYPE_TRACE);

    int iReturn = FALSE;
    MDEntry stMDEntry;
    LPTSTR szLine = NULL;
    DWORD dwLineLen = 0, dwRequiredSize;
    INT iType = 0;

    BOOL b = FALSE;

    INFCONTEXT Context;

    if ((g_pbData = (LPBYTE)malloc(1024)) == NULL)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateInfSectionToMD:%s.1.Failed to allocate memory.\n"), szSection));
        // failed to malloc
        goto MigrateInfSectionToMD_Exit;
    }

    b = SetupFindFirstLine_Wrapped(hFile, szSection, NULL, &Context);
    if (!b)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateInfSectionToMD:%s.FailedSetupFindFirstLine call.\n"), szSection));
        // failed the SetupFindFirstLine call
        goto MigrateInfSectionToMD_Exit;
    }

    if ( szLine = (LPTSTR)calloc(1024, sizeof(TCHAR)) )
    {
        dwLineLen = 1024;
    }
    else
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateInfSectionToMD:%s.2.Failed to allocate memory.\n"), szSection));
        // failed something
        goto MigrateInfSectionToMD_Exit;
    }

    while (b)
    {
        b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);
        if (dwRequiredSize > dwLineLen)
        {
            free(szLine);
            szLine = NULL;
            if ( szLine = (LPTSTR)calloc(dwRequiredSize, sizeof(TCHAR)) )
            {
                dwLineLen = dwRequiredSize;
            }
            else
            {
                // failed something
                iisDebugOut((LOG_TYPE_ERROR, _T("MigrateInfSectionToMD:%s.3.Failed to allocate memory.\n"), szSection));
                goto MigrateInfSectionToMD_Exit;
            }
        }

        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL) == FALSE)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("MigrateInfSectionToMD:%s.3.Failed SetupGetLineText call.\n"), szSection));
            // failed SetupGetLineText call
            goto MigrateInfSectionToMD_Exit;
        }
        iType = GetMDEntryFromInfLine(szLine, &stMDEntry);
        if ( MDENTRY_FROMINFFILE_FAILED != iType )
            {
                if (MDENTRY_FROMINFFILE_DO_DEL == iType)
                {
                    DeleteMDEntry(&stMDEntry);
                }
                else 
                    if (MDENTRY_FROMINFFILE_DO_ADD == iType)
                    {
                        SetMDEntry_Wrap(&stMDEntry);
                    }
                // We had success in setting the key
                iReturn = TRUE;
            }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("MigrateInfSectionToMD:%s.3.Failed GetMDEntryFromInfLine call.\n"), szSection));
        }

        b = SetupFindNextLine(&Context, &Context);
    }

MigrateInfSectionToMD_Exit:
    if (szLine) {free(szLine);szLine=NULL;}
    if (g_pbData){free(g_pbData);g_pbData=NULL;}
    iisDebugOut_End1(_T("MigrateInfSectionToMD"),(LPTSTR) szSection,LOG_TYPE_TRACE);
    return iReturn;
}

/*
#define METADATA_INHERIT                0x00000001
IIS_MD_UT_SERVER    1
DWORD_METADATA      1

1   0   HKLM    System\CurrentControlSet\Services\W3SVC\Parameters  MaxConnections
LM/W3SVC    1014    1   1   1   4   20
*/

void DumpMimeMap(CMapStringToString *mimeMap)
{
    POSITION pos = NULL;
    CString csName;
    CString csValue;

    pos = mimeMap->GetStartPosition();
    while (pos)
    {
        mimeMap->GetNextAssoc(pos, csName, csValue);

        // output
        iisDebugOut((LOG_TYPE_WARN, _T("DumpMimeMap:%s=%s\n"), csName, csValue));
    }
}

void InstallMimeMap()
{
    CMapStringToString mimeMap;

    if ( g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30)
    {
        CreateMimeMapFromRegistry(&mimeMap);
    }
    else
    {
        if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
        {
            ReadMimeMapFromMetabase(&mimeMap);
        }
    }

    CString csTheSection = _T("MIMEMAP");
    if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, csTheSection))
    {
        ReadMimeMapFromInfSection(&mimeMap, g_pTheApp->m_hInfHandle, csTheSection, TRUE);
    }

    // DumpMimeMap(&mimeMap);

    if (mimeMap.IsEmpty() == FALSE)
    {
        // install it into the metabase

        // first construct the MULTISZ string
        BUFFER bufData;
        DWORD cbBufLen;
        BYTE *pData;

        cbBufLen = bufData.QuerySize();
        pData = (BYTE *) (bufData.QueryPtr());
        ZeroMemory( pData, cbBufLen );

        LPTSTR p = (LPTSTR)pData;
        CString csName, csValue, csString;
        DWORD cbRequiredLen, cbIncreasedLen;
        DWORD cbDataLen = 0;

        POSITION pos = NULL;
        pos = mimeMap.GetStartPosition();
        while (pos)
        {
             mimeMap.GetNextAssoc(pos, csName, csValue);
             csString.Format(_T(".%s,%s"), csName, csValue);
             cbIncreasedLen = csString.GetLength()*sizeof(TCHAR) + 1*sizeof(TCHAR);
             cbRequiredLen = cbDataLen + cbIncreasedLen + 1 * sizeof(TCHAR);
             if (cbRequiredLen > cbBufLen)
             {
                 if (bufData.Resize(cbRequiredLen))
                 {
                     cbBufLen = bufData.QuerySize();

                     // move the pointer to the end
                     pData = (BYTE *)(bufData.QueryPtr());
                     p = (LPTSTR)(pData + cbDataLen);

//                   p = _tcsninc(p, cbDataLen / sizeof(TCHAR));
                 }
                 else
                 {
                     // insufficient buffer
                     return;
                 }
             }
             _tcscpy(p, csString);
             p += csString.GetLength() + 1;
             cbDataLen += cbIncreasedLen;
        }
        *p = _T('\0');
        p = _tcsinc(p);
        cbDataLen += sizeof(TCHAR);

        CMDKey cmdKey;
        cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, _T("LM/MimeMap"));
        if ( (METADATA_HANDLE)cmdKey )
        {
            cmdKey.SetData(MD_MIME_MAP,METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA,cbDataLen,(LPBYTE)pData );

            CString csKeyType = _T("IIsMimeMap");
            cmdKey.SetData(MD_KEY_TYPE,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA,(csKeyType.GetLength() + 1) * sizeof(TCHAR),(LPBYTE)(LPCTSTR)csKeyType );

            cmdKey.Close();
        }
    }

    CRegKey regInetinfoParam(HKEY_LOCAL_MACHINE, REG_INETINFOPARAMETERS);
    if ( (HKEY)regInetinfoParam )
    {
        regInetinfoParam.DeleteTree(_T("MimeMap"));
    }

    return;
}

void ReadMimeMapFromMetabase(CMapStringToString *pMap)
{
    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    LPTSTR p, rest, token;
    CString csName, csValue;
    PBYTE pData;
    int BufSize;

    cmdKey.OpenNode(_T("LM/MimeMap"));
    if ( (METADATA_HANDLE)cmdKey )
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_MIME_MAP, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (!bFound && (cbLen > 0))
        {
            if ( ! (bufData.Resize(cbLen)) )
            {
                cmdKey.Close();
                return;  // insufficient memory
            }
            else
            {
                pData = (PBYTE)(bufData.QueryPtr());
                BufSize = cbLen;
                cbLen = 0;
                bFound = cmdKey.GetData(MD_MIME_MAP, &attr, &uType, &dType, &cbLen, pData, BufSize);
            }
        }
        cmdKey.Close();

        if (bFound && (dType == MULTISZ_METADATA))
        {
            p = (LPTSTR)pData;
            while (*p)
            {
                rest = _tcsninc(p, _tcslen(p))+1;
                p = _tcsinc(p); // bypass the first dot
                token = _tcstok(p, _T(","));
                if (token)
                {
                    csName = token;
                    token = _tcstok(NULL, _T(","));
                    csValue = token;
                    pMap->SetAt(csName, csValue);
                }
                p = rest; // points to the next string
            }
        }
    }

    return;
}

BOOL CreateMimeMapFromRegistry(CMapStringToString *pMap)
{
    // make sure we start from an empty Map
    pMap->RemoveAll();

    CRegKey regMimeMap(HKEY_LOCAL_MACHINE, REG_MIMEMAP, KEY_READ);

    if ( (HKEY)regMimeMap )
    {
        CRegValueIter regEnum( regMimeMap );
        CString csName, csValue;

        while ( regEnum.Next( &csName, &csValue ) == ERROR_SUCCESS )
        {
            TCHAR szLine[_MAX_PATH];
            LPTSTR token;
            _tcscpy(szLine, csName);
            token = _tcstok(szLine, _T(","));
            if (token)
            {
                csValue = token;
                csValue.TrimLeft();
                csValue.TrimRight();
                // get rid of the leftside double-quotes
                if (csValue.Left(1) == _T("\""))
                {
                    csValue = csValue.Mid(1);
                }

                token = _tcstok(NULL, _T(","));
                if (token)
                    csName = token;
                else
                    csName = _T("");

                // get rid of the surrounding double-quotes
                csName.TrimLeft();
                csName.TrimRight();

               if (csName.IsEmpty() == FALSE)
               {
                    pMap->SetAt(csName, csValue);
               }
            }
        }
    }

    return (!(pMap->IsEmpty()));
}

BOOL CreateMimeMapFromInfSection(CMapStringToString *pMap, HINF hFile, LPCTSTR szSection)
{
    // make sure we start from an empty Map
    pMap->RemoveAll();
    ReadMimeMapFromInfSection(pMap, hFile, szSection, TRUE);
    return (!(pMap->IsEmpty()));
}


// mime map in inf file should look something like this:
//
// [MIMEMAP]
// "text/html,htm,,h"
// "image/gif,gif,,g"
// "image/jpeg,jpg,,:"
// "text/plain,txt,,0"
// "text/html,html,,h"
// "image/jpeg,jpeg,,:"
// "image/jpeg,jpe,,:"
// "image/bmp,bmp,,:"
// "application/octet-stream,*,,5"
// "application/pdf,pdf,,5"
// "application/octet-stream,bin,,5"
//
void ReadMimeMapFromInfSection(CMapStringToString *pMap, HINF hFile, LPCTSTR szSection, BOOL fAction)
{
    LPTSTR szLine;
    BOOL b = FALSE;
    DWORD dwLineLen = 0, dwRequiredSize;
    CString csTempString;

    INFCONTEXT Context;
    b = SetupFindFirstLine_Wrapped(hFile, szSection, NULL, &Context);
    if ( szLine = (LPTSTR)calloc(1024, sizeof(TCHAR)) )
        dwLineLen = 1024;
    else
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("ReadMimeMapFromInfSection.1.Failed to allocate memory.\n")));
        return;
    }

    while (b)
    {
        b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);
        if (dwRequiredSize > dwLineLen)
        {
            free(szLine);
            szLine = NULL;
            if ( szLine = (LPTSTR)calloc(dwRequiredSize, sizeof(TCHAR)) )
                dwLineLen = dwRequiredSize;
            else
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("ReadMimeMapFromInfSection.2.Failed to allocate memory.\n")));
                return;
            }
        }
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL))
        {
            CString csName, csValue;
            LPTSTR token;
            token = _tcstok(szLine, _T(","));
            if (token)
            {
                // "text/html,htm,,h"
                // csValue=text/html
                // ===========
                csValue = token;
                csValue.TrimLeft();
                csValue.TrimRight();
                // get rid of the leftside double-quotes
                if (csValue.Left(1) == _T("\""))
                    csValue = csValue.Mid(1);
                /*
                if (csName.Right(1) == _T("\""))
                    csName = csName.Left(csName.GetLength() - 1);
                 */

                // "text/html,htm,,h"
                // name=htm
                // ===========
                token = _tcstok(NULL, _T(","));
                if (token)
                    csName = token;
                else
                    csName = _T("");

                // get rid of the surrounding double-quotes
                csName.TrimLeft();
                csName.TrimRight();
                /*
                if (csName.Left(1) == _T("\""))
                    csName = csName.Mid(1);
                if (csName.Right(1) == _T("\""))
                    csName = csName.Left(csName.GetLength() - 1);
                */
                if (csName.IsEmpty() == FALSE)
                {
                    if (fAction)
                    {
                        // Check if this extension already exists in the list.
                        // if it does then don't overwrite it.
                        if (0 == pMap->Lookup( csName, csTempString) )
                        {
                            // otherwise add new extensions
                            pMap->SetAt(csName, csValue);
                        }
                    }
                    else
                    {
                        // remove old extensions
                        pMap->RemoveKey(csName);
                    }
                }
            }
        }

        b = SetupFindNextLine(&Context, &Context);
    }

    if (szLine) {free(szLine);szLine=NULL;}
    return;
}

void ReadMultiSZFromInfSection(CString *pcsMultiSZ, HINF hFile, LPCTSTR szSection)
{
    LPTSTR szLine;
    BOOL b = FALSE;
    DWORD dwLineLen = 0, dwRequiredSize;

    INFCONTEXT Context;
    b = SetupFindFirstLine_Wrapped(hFile, szSection, NULL, &Context);
    if ( szLine = (LPTSTR)calloc(1024, sizeof(TCHAR)) )
        dwLineLen = 1024;
    else
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("ReadMultiSZFromInfSection.1.Failed to allocate memory.\n")));
        return;
    }
    while (b)
    {
        b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);
        if (dwRequiredSize > dwLineLen)
        {
            free(szLine);
            szLine=NULL;
            if ( szLine = (LPTSTR)calloc(dwRequiredSize, sizeof(TCHAR)) )
                dwLineLen = dwRequiredSize;
            else
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("ReadMultiSZFromInfSection.2.Failed to allocate memory.\n")));
                return;
            }
        }
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL))
        {
            _tcscat(szLine, _T("|"));
            (*pcsMultiSZ) += szLine;
        }

        b = SetupFindNextLine(&Context, &Context);
    }

    if (szLine) {free(szLine);szLine=NULL;}
    if (pcsMultiSZ->IsEmpty()) {(*pcsMultiSZ) = _T("|");}
    return;
}

void SetLogPlugInOrder(LPCTSTR lpszSvc)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwReturnTemp = ERROR_SUCCESS;

    DWORD dwLogType;
    DWORD dwLogFileTruncateSize = 0x1400000;
    CString csLogPlugInOrder;
    DWORD dwLogFilePeriod;
    DWORD extField = 0;

#ifndef _CHICAGO_
    dwLogType = MD_LOG_TYPE_ENABLED;
    csLogPlugInOrder = EXTLOG_CLSID;
    dwLogFilePeriod = MD_LOGFILE_PERIOD_DAILY;
    extField = DEFAULT_EXTLOG_FIELDS;
#else   // CHICAGO
    //
    // win95
    //
    dwLogType = MD_LOG_TYPE_DISABLED;
    csLogPlugInOrder = NCSALOG_CLSID;
    dwLogFilePeriod = MD_LOGFILE_PERIOD_MONTHLY;
#endif // _CHICAGO_

    if (g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30)
    {
        CString csParam = _T("System\\CurrentControlSet\\Services");
        csParam += _T("\\");
        csParam += lpszSvc;
        csParam += _T("\\Parameters");
        CRegKey regParam(csParam, HKEY_LOCAL_MACHINE);
        if ((HKEY)regParam)
        {
            DWORD dwType, dwFormat;
            regParam.QueryValue(_T("LogFilePeriod"), dwLogFilePeriod);
            regParam.QueryValue(_T("LogFileTruncateSize"), dwLogFileTruncateSize);
            if (regParam.QueryValue(_T("LogType"), dwType) == ERROR_SUCCESS)
            {
                switch (dwType)
                {
                    case INET_LOG_TO_SQL:
                        csLogPlugInOrder = ODBCLOG_CLSID;
                        break;
                    case INET_LOG_TO_FILE:
                        if (regParam.QueryValue(_T("LogFileFormat"), dwFormat) == ERROR_SUCCESS)
                        {
                            switch (dwFormat)
                            {
                                case INET_LOG_FORMAT_NCSA:
                                    csLogPlugInOrder = NCSALOG_CLSID;
                                    break;
                                case INET_LOG_FORMAT_INTERNET_STD:
                                    csLogPlugInOrder = ASCLOG_CLSID;
                                    break;
                                default:
                                    break;
                            }
                        }
                        break;
                    case INET_LOG_DISABLED:
                        dwLogType = MD_LOG_TYPE_DISABLED;
                        break;
                    default:
                        break;
                }
            }
            //delete LogFilePeriod, LogFileFormat, LogType
            regParam.DeleteValue(_T("LogFilePeriod"));
            regParam.DeleteValue(_T("LogFileTruncateSize"));
            regParam.DeleteValue(_T("LogFileFormat"));
            regParam.DeleteValue(_T("LogType"));
        }
    }

    if ((dwLogFilePeriod >= MD_LOGFILE_PERIOD_DAILY) && (dwLogFileTruncateSize > 0x1400000) ) {dwLogFileTruncateSize = 0x1400000;}

    MDEntry stMDEntry;

    //
    // set LogType, LogPluginOrder, LogFilePeriod in the metabase
    //
    CString csKeyPath = _T("LM/");
    csKeyPath += lpszSvc;

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_LOG_TYPE;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwLogType;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_LOG_PLUGIN_ORDER;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csLogPlugInOrder.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csLogPlugInOrder;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_LOGFILE_PERIOD;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwLogFilePeriod;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_LOGFILE_TRUNCATE_SIZE;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwLogFileTruncateSize;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    if ( extField != 0 )
    {
        stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
        stMDEntry.dwMDIdentifier = MD_LOGEXT_FIELD_MASK;
        stMDEntry.dwMDAttributes = METADATA_INHERIT;
        stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
        stMDEntry.dwMDDataType = DWORD_METADATA;
        stMDEntry.dwMDDataLen = sizeof(DWORD);
        stMDEntry.pbMDData = (LPBYTE)&extField;
        dwReturnTemp = SetMDEntry_Wrap(&stMDEntry);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}
    }
    return;
}


//------------------------------------------------------------------------------------
// make sure that virtual server 1 can be accessed by local host. This involves reading in
// the existing bindings. Then, if it is all unassigned we are OK. If 127.0.0.1 is there
// we are OK. Otherwise, we need to add 127.0.0.1:80
BOOL ConfirmLocalHost(LPCTSTR lpszVirtServer)
{
    CMDKey  cmdKey;
    PVOID   pData = NULL;
    TCHAR*  pNext;
    BOOL    bReturn;
    CString csBinding;
    CString cs;

    CString csLocalHost = _T("127.0.0.1:80:");

    // open the key to the virtual server, which is what is passed in as a parameter
    cmdKey.OpenNode( lpszVirtServer );
    // test for success.
    if ( (METADATA_HANDLE)cmdKey == NULL ){return FALSE;}

    DWORD dwAttr = METADATA_INHERIT;
    DWORD dwUType = IIS_MD_UT_SERVER;
    DWORD dwDType = MULTISZ_METADATA;
    DWORD dwLength = 0;

    // we need to start this process by getting the existing multisz data from the metabase
    // first, figure out how much memory we will need to do this
    cmdKey.GetData( MD_SERVER_BINDINGS,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_INHERIT,IIS_MD_UT_SERVER,MULTISZ_METADATA);

    // unfortunatly, the above routine only returns TRUE or FALSE. And since we are purposefully
    // passing in a null ponter of 0 size in order to get the length of the data, it will always
    // return 0 whether it was because the metabase is inacessable, or there pointer was NULL,
    // which it is. So - I guess we assume it worked, allocate the buffer and attempt to read it
    // in again.
    TCHAR*      pBindings;
    DWORD       cbBuffer = dwLength;

    // add enough space to the allocated space that we can just append the string
    cbBuffer += (csLocalHost.GetLength() + 4) * sizeof(WCHAR);
    dwLength = cbBuffer;

    // allocate the space, if it fails, we fail
    // note that GPTR causes it to be initialized to zero
    pData = GlobalAlloc( GPTR, cbBuffer );
    if ( !pData )
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("ConfirmLocalHost.Failed to allocate memory.\n")));
        cmdKey.Close();
        goto cleanup;
        }
    pBindings = (TCHAR*)pData;

    // now get the data from the metabase
    bReturn = cmdKey.GetData( MD_SERVER_BINDINGS,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)pData,cbBuffer,METADATA_INHERIT,IIS_MD_UT_SERVER,MULTISZ_METADATA );

    // if we have successfully retrieved the existing bindings, then we need to scan them
    // to see if we are already covered
    if (bReturn)
        {
        // got the existing bindings, scan them now - pBindings will be pointing at the second end \0
        // when it is time to exit the loop.
        while ( *pBindings )
            {
            csBinding = pBindings;

            // if the first character of the binding is a ':' then we are all done because it is "All Unassigned"
            if ( csBinding[0] == _T(':') )
                goto cleanup;

            // if the binding is for localhost, then we are done
            if ( csBinding.Left(9) == _T("127.0.0.1") )
                goto cleanup;

            // increment pBindings to the next string
            pBindings = _tcsninc( pBindings, _tcslen(pBindings))+1;
            }
        }

    // append our new error to the end of the list. The value pErrors should be pointing
    // to the correct location to copy it in to
    _tcscpy( pBindings, csLocalHost );

    // calculate the correct data length for this thing
    // get the location of the end of the multisz
    pNext = _tcsninc( pBindings, _tcslen(pBindings))+2;
    // Get the length of the data to copy
    cbBuffer = DIFF((PBYTE)pNext - (PBYTE)pData);

    // write the new errors list back out to the metabase
    cmdKey.SetData(MD_SERVER_BINDINGS,0,IIS_MD_UT_SERVER,MULTISZ_METADATA,cbBuffer,(PUCHAR)pData);

    // close the key
cleanup:
    cmdKey.Close();

    // clean up
    if (pData){GlobalFree(pData);pData=NULL;}

    // the only time it should return FALSE is if it can't open the key
    return TRUE;
}


//------------------------------------------------------------------------------------
// Beta 3 server set the MD_NOT_DELETABLE property on the default website and the administration website.
// remove it. It should only be set now on the default website for the NTW platform. This routine scans
// all the virtual websites and attempts to delete the MD_NOT_DELETABLE property. This should only be
// called on the NTS platform during an upgrade
// pszService       string representing the service being operated on. ex:  "W3SVC"
//
// Actually, now I'm only going to bother checking instances 1 and 2. These are the only ones that would
// have this value set on them anyway and we can save a lot of time by not checking them all. - boydm
void RemoveCannotDeleteVR( LPCTSTR pszService )
    {
    UINT        iVWebsite;
    CString     csWebSite;
    CMDKey      cmdKey;
    CString     csSeviceKey;

    // build the service key
    csSeviceKey = _T("LM/");
    csSeviceKey += pszService;

    // loop through the virtual websites.
    for ( iVWebsite = 1; iVWebsite <= 2; iVWebsite++ )
        {
        // build the path to the website
        csWebSite.Format( _T("%s/%d"), csSeviceKey, iVWebsite );

        // open the key to the virtual server
        cmdKey.OpenNode( csWebSite );

        // If the opening operation fails, try the next web site
        if ( (METADATA_HANDLE)cmdKey == NULL )
            continue;

        // delete the MD_NOT_DELETABLE property
        cmdKey.DeleteData( MD_NOT_DELETABLE, DWORD_METADATA );

        // close the metadata handle to the virtual web server
        cmdKey.Close();
        }
    }


//------------------------------------------------------------------------------------
// IntegrateNewErrorsOnUpgrade_WWW
// This routine finds the new custom errors and error messages that are being integrated
// into an upgrade and adds them to the existing errors. This code should not be called
// for a fresh install. The plan is to read each new error from the appropriate INF section
// then call a helper routine to add it only if it does not already exist. The use can always
// add these things by hand, and if they have done so, we don't want to override their good work.
// Note: the "g_field" variable is a global declared at the top of this file.
//
// hFile        Handle to the INF file
// szSection    name of section containing the error to integrate - usually "UPGRADE_ERRORS"
//
void IntegrateNewErrorsOnUpgrade_WWW( IN HINF hFile, IN LPCTSTR szSection )
{
    iisDebugOut_Start(_T("IntegrateNewErrorsOnUpgrade_WWW"),LOG_TYPE_TRACE);

    DWORD dwReturn = ERROR_SUCCESS;
    LPTSTR  szLine = NULL;
    DWORD   dwRequiredSize;
    BOOL    b = FALSE;

    INFCONTEXT Context;
    if( g_pTheApp->m_eInstallMode != IM_UPGRADE )
        {
        iisDebugOut((LOG_TYPE_WARN, _T("WARNING: IntegrateNewErrorsOnUpgrade_WWW called on FRESH install")));
        dwReturn = ERROR_SUCCESS;
        goto IntegrateNewErrorsOnUpgrade_WWW_Exit;
        }

    // go to the beginning of the section in the INF file
    b = SetupFindFirstLine_Wrapped(hFile, szSection, NULL, &Context);
    if (!b)
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: Unable to find INF section %s for upgrading errors"), szSection));
        dwReturn = E_FAIL;
        goto IntegrateNewErrorsOnUpgrade_WWW_Exit;
        }

    // loop through the items in the section.
    while (b)
    {
        // get the size of the memory we need for this
        b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);

        // prepare the buffer to receive the line
        szLine = (LPTSTR)GlobalAlloc( GPTR, dwRequiredSize * sizeof(TCHAR) );
        if ( !szLine )
            {
            SetErrorFlag(__FILE__, __LINE__);
            iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: Unable to allocate buffer of %u bytes - upgrade errors"), dwRequiredSize));
            dwReturn = E_FAIL;
            goto IntegrateNewErrorsOnUpgrade_WWW_Exit;
            }

        // get the line from the inf file1
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL) == FALSE)
            {
            SetErrorFlag(__FILE__, __LINE__);
            iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: Unable to get the next INF line - upgrade errors")));
            dwReturn = E_FAIL;
            goto IntegrateNewErrorsOnUpgrade_WWW_Exit;
            }

        // split the line into its component parts
        if ( SplitLine(szLine, 5) )
            {
            // the first two g_fields are dwords. Must convert them before using them
            DWORD   dwError = _ttoi(g_field[0]);
            DWORD   dwSubCode = _ttoi(g_field[1]);

            // the last g_field is a flag for overwriting existing errors
            BOOL    fOverwrite = _ttoi(g_field[4]);

            // call the helper function that integrates the custom error
            AddCustomError(dwError, dwSubCode, g_field[2], g_field[3], fOverwrite );
            }
        else
            {
            // failed to split the line
            SetErrorFlag(__FILE__, __LINE__);
            iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: Unable to split upgrade error INF line - %s"), szLine));
            dwReturn = E_FAIL;
            }

        // find the next line in the section. If there is no next line it should return false
        b = SetupFindNextLine(&Context, &Context);

        // free the temporary buffer
        if (szLine)
        {
            GlobalFree(szLine);
            szLine = NULL;
        }
    }

IntegrateNewErrorsOnUpgrade_WWW_Exit:
    if (szLine){GlobalFree(szLine);szLine=NULL;}
    // let someone watching the debug out put window know it is done
    iisDebugOut_End(_T("IntegrateNewErrorsOnUpgrade_WWW"),LOG_TYPE_TRACE);
    return;
}




int WWW_Upgrade_RegToMetabase(HINF hInf)
{
    iisDebugOut_Start(_T("WWW_Upgrade_RegToMetabase"),LOG_TYPE_TRACE);

    int iReturn = FALSE;
    ACTION_TYPE atCORE = GetIISCoreAction(FALSE);

    // upgrade the script map

    Register_iis_www_handleScriptMap();

    // ================
    //
    // LM/W3SVC/AnonymousUseSubAuth
    //
    // fresh = ok.
    // reinstall = ok.
    // upgrade 1,2,3 = ok since we are writing to metabase for the first time.
    // upgrade 4     = ok overwrite, even though the metabase will already have this -- it will be the same value.
    // ================
    if (g_pTheApp->m_eNTOSType == OT_NTS || g_pTheApp->m_eNTOSType == OT_NTW)
    {
        WriteToMD_AnonymousUseSubAuth_WWW();
    }

    // ================
    //
    // LM/W3SVC/InProcessIsapiApps
    //
    // fresh = ok.
    // reinstall = ok.
    // upgrade 1,2,3 = ok.  no isapi apps are listed in the registry, so there is nothing to upgrade.
    // upgrade 4     = User may have added other isapi apps.
    //                  We need to make sure that
    //                  a. the ones we are installing get put there
    //                  b. that we keep the other isapi apps which the user has already installed
    // ================
    // for now, let's just ignore if iis40 upgrade
    if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
    {
        // Added for nt5
        CString csTheSection = _T("InProc_ISAPI_Apps");
        if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, csTheSection))
        {
            VerifyMD_InProcessISAPIApps_WWW(csTheSection);
        }

    }
    else
    {
        CString csTheSection = _T("InProc_ISAPI_Apps");
        if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, csTheSection))
        {
            WriteToMD_InProcessISAPIApps_WWW(csTheSection);
        }
    }
    AdvanceProgressBarTickGauge();


    // ================
    //
    // LM/W3SVC/NTAuthenticationProviders
    //
    // fresh = ok.
    // reinstall = ok overwrite, even though the metabase will already have this -- it will be the same value.
    // upgrade 1,2,3 = ok.
    // upgrade 4     = User may have added other authentication providers
    //                  We need to make sure that
    //                  a. the ones we are installing get put there
    //                  b. that we keep the other entries the user has already put there
    // ================
    if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
    {
        // Added for nt5
        VerifyMD_NTAuthenticationProviders_WWW();
    }
    else
    {
        WriteToMD_NTAuthenticationProviders_WWW(_T("Negotiate,NTLM"));
    }

    // ================
    //
    // LM/W3SVC/IpSec
    //
    // fresh = ok.
    // reinstall = ok.
    // upgrade 1,2,3 = ok, handles upgrades.
    // upgrade 4     = ok.  does nothing and leaves whatever the user already had!
    // ================
#ifndef _CHICAGO_
    if (g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30)
    {
        MigrateServiceIpSec(L"SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters",L"LM/W3SVC" );
        CRegKey regWWWParam(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\W3SVC\\Parameters"));
        if (regWWWParam)
        {
            regWWWParam.DeleteTree(_T("Deny IP List"));
            regWWWParam.DeleteTree(_T("Grant IP List"));
        }
    }
#endif //_CHICAGO_
    if ( (g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30))
    {
        CRegKey regWWWParam(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\W3SVC\\Parameters"));
        if (regWWWParam)
        {
            regWWWParam.DeleteValue(_T("AnonymousUserName"));
            regWWWParam.DeleteValue(_T("NTAuthenticationProviders"));
            regWWWParam.DeleteValue(_T("Filter Dlls"));
            regWWWParam.DeleteValue(_T("SecurePort"));
        }
    }
    AdvanceProgressBarTickGauge();


    // If we are upgrading from a K2 beta, then we do not want to mess around with the virtual roots. Just
    // use the existing ones. The only exception is that we need to make sure local host can reach on the
    // default website so that the index server documentation works.

    // ================
    //
    // LM/W3SVC/LogType
    // LM/W3SVC/LogPluginOrder
    // LM/W3SVC/LogFilePeriod
    // LM/W3SVC/LogFileTruncateSize
    //
    // fresh = ok.
    // reinstall = ok.
    // upgrade 1,2,3 = ok, handles upgrades.
    // upgrade 4     = ok.  if exists, should leave what the user had.
    //                 otherwise write in the default stuff.
    // ================
    SetLogPlugInOrder(_T("W3SVC"));
    AdvanceProgressBarTickGauge();

    // ================
    // This needs to be done before the virtual roots get moved into the metabase.
    // ================
    if (!g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
    {
#ifndef _CHICAGO_
        Upgrade_WolfPack();
#endif //_CHICAGO_
    }
    AdvanceProgressBarTickGauge();

    // ================
    // LM/W3SVC/CustomError
    // LM/W3SVC/Info/CustomErrorDesc
    // LM/W3SVC/n/Root/iisamples/exair/CustomError
    // LM/W3SVC/n/Root/iisamples/iisadmin/CustomError
    // LM/W3SVC/n/Root/iisamples/iishelp/CustomError
    //
    // fresh = ok.
    // reinstall = ok
    // upgrade 1,2,3 = ok, handles upgrades.
    // upgrade 4     = ok.  if exists, should leave what the user had.
    //                 otherwise write in the default stuff.  in otherwords -- SetDataNoOverwrite!
    // ================
    if ( g_pTheApp->m_eInstallMode == IM_UPGRADE )
    {
        // go back again and integrate and final new custom errors into the upgraded errors.
        // Only do this on an upgrade.

        CString csTheSection = _T("UPGRADE_ERRORS");
        if (GetSectionNameToDo(hInf, csTheSection))
        {
            IntegrateNewErrorsOnUpgrade_WWW( hInf, csTheSection );
        }

        if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
        {
            MoveOldHelpFilesToNewLocation();

            //iisDebugOut((LOG_TYPE_TRACE, _T("VerifyAllCustomErrorsRecursive_SlowWay.Start.")));
            //VerifyAllCustomErrorsRecursive_SlowWay(_T("LM/W3SVC"));
            //iisDebugOut((LOG_TYPE_TRACE, _T("VerifyAllCustomErrorsRecursive_SlowWay.End.")));
            HRESULT         hRes;
            CFixCustomErrors CustomErrFix;
            hRes = CustomErrFix.Update(_T("LM/W3SVC"));
            if (FAILED(hRes))
                {iisDebugOut((LOG_TYPE_WARN, _T("CustomErrFix.Update():FAILED= %x.\n"),hRes));}
        }
    }
    AdvanceProgressBarTickGauge();

#ifndef _CHICAGO_
    //
    // upgrade the cryptographic server keys.
    // either from the registry or metabase to the pstores.
    //
    UpgradeCryptoKeys_WWW();
    AdvanceProgressBarTickGauge();
#endif //_CHICAGO_

    iisDebugOut_End(_T("WWW_Upgrade_RegToMetabase"),LOG_TYPE_TRACE);
    return iReturn;
}



int FTP_Upgrade_RegToMetabase(HINF hInf)
{
    int iReturn = FALSE;
    iisDebugOut_Start(_T("FTP_Upgrade_RegToMetabase"),LOG_TYPE_TRACE);

    ACTION_TYPE atCORE = GetIISCoreAction(TRUE);

    // ================
    //
    // LM/MSFTPSVC/AnonymousUseSubAuth
    //
    // fresh = ok.
    // reinstall = ok.
    // upgrade 1,2,3 = ok since we are writing to metabase for the first time.
    // upgrade 4     = ok overwrite, even though the metabase will already have this -- it will be the same value.
    // ================
    if (g_pTheApp->m_eNTOSType == OT_NTS || g_pTheApp->m_eNTOSType == OT_NTW)
    {
        WriteToMD_AnonymousUseSubAuth_FTP();
    }
    AdvanceProgressBarTickGauge();

#ifndef _CHICAGO_
    // ================
    //
    // LM/MSFTPSVC/IpSec
    //
    // fresh = ok.
    // reinstall = ok.
    // upgrade 1,2,3 = ok, handles upgrades.
    // upgrade 4     = ok.  does nothing and leaves whatever the user already had!
    // ================
    if (g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30)
    {
        MigrateServiceIpSec(L"SYSTEM\\CurrentControlSet\\Services\\MSFTPSVC\\Parameters",L"LM/MSFTPSVC" );
        CRegKey regFTPParam(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\MSFTPSVC\\Parameters"));
        regFTPParam.DeleteTree(_T("Deny IP List"));
        regFTPParam.DeleteTree(_T("Grant IP List"));
    }
#endif //_CHICAGO_


    // ================
    //
    // LM/MSFTPSVC/MD_GREETING_MESSAGE
    //
    // fresh = ok.  do nothing.
    // reinstall = ok. do nothing.
    // upgrade 1,2,3 = ok, handles upgrades.
    // upgrade 4     = do nothing
    // ================
    if ( (g_pTheApp->m_eUpgradeType == UT_10_W95 || g_pTheApp->m_eUpgradeType == UT_351 || g_pTheApp->m_eUpgradeType == UT_10 || g_pTheApp->m_eUpgradeType == UT_20 || g_pTheApp->m_eUpgradeType == UT_30) )
    {
        CRegKey regFTPParam(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\MSFTPSVC\\Parameters"));
        if (regFTPParam)
        {
            WriteToMD_GreetingMessage_FTP();
            regFTPParam.DeleteValue(_T("GreetingMessage"));
            regFTPParam.DeleteValue(_T("AnonymousUserName"));
        }
    }
    AdvanceProgressBarTickGauge();

    // ================
    //
    // LM/MSFTPSVC/LogType
    // LM/MSFTPSVC/LogPluginOrder
    // LM/MSFTPSVC/LogFilePeriod
    // LM/MSFTPSVC/LogFileTruncateSize
    //
    // LM/MSFTPSVC/Capabilities
    //
    // fresh = ok.
    // reinstall = ok.
    // upgrade 1,2,3 = ok, handles upgrades.
    // upgrade 4     = ok.  if exists, should leave what the user had.
    //                 otherwise write in the default stuff.  in otherwords -- SetDataNoOverwrite!
    // ================
    SetLogPlugInOrder(_T("MSFTPSVC"));
    AdvanceProgressBarTickGauge();


    iisDebugOut_End(_T("FTP_Upgrade_RegToMetabase"),LOG_TYPE_TRACE);
    iReturn = TRUE;
    return iReturn;
}




// Open the metabase and loop thru all the filters which are in there,
// make sure they contain the filters we require for nt5
DWORD VerifyMD_Filters_WWW(CString csTheSection)
{
    iisDebugOut_Start(_T("VerifyMD_Filters_WWW"),LOG_TYPE_TRACE);

    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csKeyType;
    CString csOrder;

    int bFound = FALSE;
    int c = 0;
    int k = 0;

    INT     i, nArrayItems;
    BOOL    fAddComma = FALSE;
    CMDKey  cmdKey;
    BOOL    bReturn;

    CStringArray arrayName, arrayPath;
    CStringArray arrayName_New, arrayPath_New;

    // Add Required Filters to the arrayName
    c = AddRequiredFilters(csTheSection, arrayName, arrayPath);

    // set aside the number of array items
    nArrayItems = (INT)arrayName.GetSize();

    // leave if it is empty
    if ( nArrayItems == 0 ) {goto VerifyMD_Filters_WWW_Exit;}

    // zero out the order string
    csOrder.Empty();

    // open the key to the virtual server, which is what is passed in as a parameter
    cmdKey.OpenNode( _T("LM/W3SVC/Filters") );
    // test for success.
    if ( (METADATA_HANDLE)cmdKey )
    {
        DWORD dwAttr = METADATA_NO_ATTRIBUTES;
        DWORD dwUType = IIS_MD_UT_SERVER;
        DWORD dwDType = STRING_METADATA;
        DWORD dwLength = 0;

        // we need to start this process by getting the existing multisz data from the metabase
        // first, figure out how much memory we will need to do this
        cmdKey.GetData( MD_FILTER_LOAD_ORDER,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA);

        // give the buffer some head space
        // dwLength += 2;
        bReturn = FALSE;
        if (dwLength > 0)
        {
            // now get the real data from the metabase
            bReturn = cmdKey.GetData( MD_FILTER_LOAD_ORDER,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)csOrder.GetBuffer( dwLength ),dwLength,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA );
            csOrder.ReleaseBuffer();
        }

        // the data doesn't get written out here, so close the metabase key
        cmdKey.Close();

        // if reading the value from the metabase didn't work, zero out the string
        if ( !bReturn )
            {csOrder.Empty();}
    }

    // if there is something in the order string from the upgrade, then we need to start adding commas
    if ( !csOrder.IsEmpty() )
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("VerifyMD_Filters_WWW():Start. %s.\n"),csOrder));
        fAddComma = TRUE;
    }

    // Do special re-arranging for
    // sspifilt and compression filter
    ReOrderFiltersSpecial(nArrayItems, arrayName, csOrder);

    for ( i = 0; i < nArrayItems; i++ )
    {
        // if the name in the array is already in the filter order list,
        // then continue to the next one
        CString csOrderUpper;
        CString csUpperValue;

        csOrderUpper = csOrder;
        csOrderUpper.MakeUpper();
        csOrderUpper.TrimLeft();
        csOrderUpper.TrimRight();

        csUpperValue = arrayName[i];
        csUpperValue.MakeUpper();
        csUpperValue.TrimLeft();
        csUpperValue.TrimRight();

        // Always, Add this entry to the list of new filters to add!!
        // This is because ReOrderFiltersSpecial() may add Compress or sspifilt to the csOrder
       arrayName_New.Add(arrayName[i]);
       arrayPath_New.Add(arrayPath[i]);

        if ( csOrderUpper.Find( csUpperValue ) >= 0 )
        {
            // this entry is already in the csOrderlist so lets not add it again.
            continue;
        }

        // the name is not alreay in the list. Unless this is the first one to be added, insert
        // a comma to seperate the list, then add the file name
        if ( fAddComma )
        {
            csOrder += _T(',');
        }

        // Add this entry to our list!
        csOrder +=arrayName[i];

        // once we've added one, we know we always need to adde a comma from now on
        fAddComma = TRUE;
    }

    nArrayItems = (INT)arrayName_New.GetSize();

    // always write out the loadorder list.
    WriteToMD_Filters_List_Entry(csOrder);

    // leave if it is empty
    if ( nArrayItems == 0 ) {goto VerifyMD_Filters_WWW_Exit;}

    for (k=0; k<nArrayItems; k++)
    {
        WriteToMD_Filter_Entry(arrayName_New[k], arrayPath_New[k]);
    }


VerifyMD_Filters_WWW_Exit:
    iisDebugOut_End1(_T("VerifyMD_Filters_WWW"),csOrder,LOG_TYPE_TRACE);
    return dwReturn;
}


DWORD WriteToMD_Filters_List_Entry(CString csOrder)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwReturnTemp = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csKeyType;

    // Add this entry to the metabase!
    csKeyType = _T("IIsFilters");
    stMDEntry.szMDPath = _T("LM/W3SVC/Filters");
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csKeyType.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csKeyType;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    // now we have csOrder=f1,f2,f3,sspifilt
    stMDEntry.szMDPath = _T("LM/W3SVC/Filters");
    stMDEntry.dwMDIdentifier = MD_FILTER_LOAD_ORDER;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csOrder.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csOrder;

    // always overwrite, we may have added new filters
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    return dwReturn;
}


DWORD WriteToMD_Filter_Entry(CString csFilter_Name, CString csFilter_Path)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwReturnTemp = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csMDPath;
    CString csKeyType;

    csMDPath = _T("LM/W3SVC/Filters/") + (CString)csFilter_Name;

    // Set Entry for the Filter
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csMDPath;
    stMDEntry.dwMDIdentifier = MD_FILTER_IMAGE_PATH;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = ((csFilter_Path).GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)(csFilter_Path);
    // always overwrite, we may have added new filters
    dwReturnTemp = SetMDEntry_Wrap(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    // Set KeyType
    csKeyType = _T("IIsFilter");
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csMDPath;
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csKeyType.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csKeyType;
    // always overwrite, we may have added new filters
    dwReturnTemp = SetMDEntry_Wrap(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    return dwReturn;
}


DWORD WriteToMD_InProcessISAPIApps_WWW(IN LPCTSTR szSection)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    CString csISAPIPath;
    CStringArray arrayName, arrayPath;
    int nArrayItems = 0;
    int i;

    csISAPIPath = _T("");

    // Add Required Filters to the arrayName
    AddRequiredISAPI(arrayName, arrayPath, szSection);
    // set aside the number of array items
    nArrayItems = (int)arrayName.GetSize();
    // leave if it is empty
    if ( nArrayItems == 0 ) {goto WriteToMD_InProcessISAPIApps_WWW_Exit;}

    for ( i = 0; i < nArrayItems; i++ )
    {
        // Add this entry to our list!
        csISAPIPath += arrayPath[i];
        csISAPIPath +=_T("|");
    }
    // add the terminating second "|" character
    csISAPIPath +=_T("|");

    // write it to the metabase
    WriteToMD_ISAPI_Entry(csISAPIPath);

WriteToMD_InProcessISAPIApps_WWW_Exit:
    return dwReturn;
}


//
// Returns the amount of entries that we added.
//
int AddRequiredISAPI(CStringArray& arrayName,CStringArray& arrayPath, IN LPCTSTR szSection)
{
    iisDebugOut_Start(_T("AddRequiredISAPI"),LOG_TYPE_TRACE);

    int c = 0;
    CString csName = _T("");
    CString csPath = _T("");

    CStringList strList;

    CString csTheSection = szSection;
    if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, csTheSection))
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(g_pTheApp->m_hInfHandle, strList, csTheSection))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos = NULL;
            CString csEntry;
            pos = strList.GetHeadPosition();
            while (pos)
            {
                csEntry = _T("");
                csEntry = strList.GetAt(pos);
                // Split into name, and value. look for ","
                int i;
                i = csEntry.ReverseFind(_T(','));
                if (i != -1)
                {
                    int len =0;
                    len = csEntry.GetLength();
                    csPath = csEntry.Right(len - i - 1);
                    csName = csEntry.Left(i);

                    // Add it to our array...
                    iisDebugOut((LOG_TYPE_TRACE, _T("Add isapi Entry:%s:%s\n"),csName, csPath));
                    arrayName.Add(csName);
                    arrayPath.Add(csPath);
                    c++;
                }

                strList.GetNext(pos);
            }
        }
    }
    }

    iisDebugOut((LOG_TYPE_TRACE, _T("AddRequiredISAPI:End.Return=%d\n"),c));
    return c;
}


DWORD WriteToMD_ISAPI_Entry(CString csISAPIDelimitedList)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwReturnTemp = ERROR_SUCCESS;
    MDEntry stMDEntry;

    HGLOBAL hBlock = NULL;

    int nISAPILength;
    nISAPILength = csISAPIDelimitedList.GetLength() * sizeof(TCHAR);
    hBlock = GlobalAlloc(GPTR, nISAPILength + sizeof(TCHAR));
    if (!hBlock)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("WriteToMD_ISAPI_Entry.Failed to allocate memory.\n")));
        return E_FAIL;
    }

    TCHAR *p = (LPTSTR)hBlock;
    memcpy((LPVOID)hBlock, (LPVOID)(LPCTSTR)csISAPIDelimitedList, nISAPILength + sizeof(TCHAR));

    //  replace all '|' with a null
    while (*p)
    {
        if (*p == _T('|'))
        {
            *p = _T('\0');
        }
        p = _tcsinc(p);
    }

    // write the new errors list back out to the metabase
    stMDEntry.szMDPath = _T("LM/W3SVC");
    stMDEntry.dwMDIdentifier = MD_IN_PROCESS_ISAPI_APPS;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = MULTISZ_METADATA;
    stMDEntry.dwMDDataLen = nISAPILength;
    stMDEntry.pbMDData = (LPBYTE)hBlock;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    if (hBlock){GlobalFree(hBlock);hBlock=NULL;}
    return dwReturn;
}



// loop thru the isapi apps and make sure the required ones are there.
BOOL VerifyMD_InProcessISAPIApps_WWW(IN LPCTSTR szSection)
{
    CMDKey  cmdKey;
    PVOID   pData = NULL;
    BOOL    bReturn = FALSE;
    CString csOneBlobEntry;
    CString cs;
    CString csISAPIPath;
    int c = 0;

    int iISAPIPathCount = 0;
    int iISAPIPath_NewlyAdded_Count = 0;

    int i, nArrayItems;

    int iPleaseCloseTheMetabase = FALSE;

    DWORD dwAttr;
    DWORD dwUType;
    DWORD dwDType;
    DWORD dwLength;

    TCHAR*      pBlobEntry = NULL;
    DWORD       cbBuffer = 0;

    CStringArray arrayName, arrayPath;

    // open the key
    cmdKey.OpenNode(_T("LM/W3SVC"));
    // test for success.
    if ( (METADATA_HANDLE)cmdKey == NULL )
    {
        // i could not open the key
        // maybe there is nothing there.
        // this must be a fresh install.
        WriteToMD_InProcessISAPIApps_WWW(szSection);
        goto VerifyMD_InProcessISAPIApps_WWW_Exit;
    }
    iPleaseCloseTheMetabase = TRUE;

    // Add Required Filters to the arrayName
    c = AddRequiredISAPI(arrayName, arrayPath, szSection);
    // set aside the number of array items
    nArrayItems = (int)arrayName.GetSize();
    // leave if it is empty
    if ( nArrayItems == 0 ) {goto VerifyMD_InProcessISAPIApps_WWW_Exit;}

    dwAttr = METADATA_INHERIT;
    dwUType = IIS_MD_UT_SERVER;
    dwDType = MULTISZ_METADATA;
    dwLength = 0;

    // we need to start this process by getting the existing multisz data from the metabase
    // first, figure out how much memory we will need to do this
    cmdKey.GetData( MD_IN_PROCESS_ISAPI_APPS,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_INHERIT,IIS_MD_UT_SERVER,MULTISZ_METADATA);

    // unfortunatly, the above routine only returns TRUE or FALSE. And since we are purposefully
    // passing in a null ponter of 0 size in order to get the length of the data, it will always
    // return 0 whether it was because the metabase is inacessable, or there pointer was NULL,
    // which it is. So - I guess we assume it worked, allocate the buffer and attempt to read it
    // in again.
    cbBuffer = dwLength;

    // allocate the space, if it fails, we fail
    // note that GPTR causes it to be initialized to zero
    pData = GlobalAlloc( GPTR, cbBuffer );
    if ( !pData )
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("VerifyMD_InProcessISAPIApps_WWW.1.Failed to allocate memory.\n")));
        goto VerifyMD_InProcessISAPIApps_WWW_Exit;
        }
    pBlobEntry = (TCHAR*)pData;

    // now get the data from the metabase
    iISAPIPathCount = 0;
    bReturn = cmdKey.GetData( MD_IN_PROCESS_ISAPI_APPS,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)pData,cbBuffer,METADATA_INHERIT,IIS_MD_UT_SERVER,MULTISZ_METADATA );
    // loop thru this list and add it to our array of entries.
    if ( bReturn )
    {
        // got the entry, scan them now - pBlobEntry will be pointing at the second end \0
        // when it is time to exit the loop.
        csISAPIPath = _T("");
        while ( *pBlobEntry )
            {
            csOneBlobEntry = pBlobEntry;

            // append on the "|" which we'll convert to a null later
            csISAPIPath += csOneBlobEntry + _T("|");
            iISAPIPathCount++;

            // increment pBlobEntry to the next string
            pBlobEntry = _tcsninc( pBlobEntry, _tcslen(pBlobEntry))+1;
            }
    }
    // close the handle to the metabase so that we can
    // open it to write the stuff out later!
    cmdKey.Close();
    iPleaseCloseTheMetabase = FALSE;

    // now loop thru this list
    // and check if our isapi dll's are in this list.
    // if they are not, then we add them to the end.
    iISAPIPath_NewlyAdded_Count = 0;
    for ( i = 0; i < nArrayItems; i++ )
    {
        // if the name in the array is already in the filter order list,
        // then continue to the next one
        if ( csISAPIPath.Find( arrayPath[i] ) >= 0 )
            {continue;}

        // Add this entry to our list!
        csISAPIPath += arrayPath[i];
        csISAPIPath +=_T("|");

        iISAPIPath_NewlyAdded_Count++;
    }
    // add the terminating second "|" character
    csISAPIPath +=_T("|");

    // If we added any new entries to the metabase
    // the let's write out the new block of data, otherwise let's get out.
    if (iISAPIPath_NewlyAdded_Count > 0)
    {
        WriteToMD_ISAPI_Entry(csISAPIPath);
    }


VerifyMD_InProcessISAPIApps_WWW_Exit:
    // close the key
    if (TRUE == iPleaseCloseTheMetabase){cmdKey.Close();}
    if (pData){GlobalFree(pData);pData=NULL;}

    // the only time it should return FALSE is if it can't open the key
    return TRUE;
}




DWORD WriteToMD_NTAuthenticationProviders_WWW(CString csData)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    MDEntry stMDEntry;

    // Upgrade 4.0 comment --> Replace any NTLM with Negotiate,NTLM
    stMDEntry.szMDPath = _T("LM/W3SVC");
    //stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_NTAUTHENTICATION_PROVIDERS;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csData.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csData;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    return dwReturn;
}


// Open the metabase and loop thru all the entries which are in there,
// make sure they contain the entries we require for nt5
DWORD VerifyMD_NTAuthenticationProviders_WWW(void)
{
    iisDebugOut_Start(_T("VerifyMD_NTAuthenticationProviders_WWW"),LOG_TYPE_TRACE);

    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csKeyType;
    CString csOrder;
    int c = 0;
    int k = 0;

    INT     i, nArrayItems;
    BOOL    fAddComma = FALSE;
    CMDKey  cmdKey;
    BOOL    bReturn;

    int bFound_Negotiate = FALSE;
    int bFound_NTLM = FALSE;

    int j = 0;
    int iPleaseWriteOutTheEntry = FALSE;

    cmdKey.OpenNode( _T("LM/W3SVC") );
    // test for success.
    if ( (METADATA_HANDLE)cmdKey )
    {
        DWORD dwAttr = METADATA_INHERIT;
        DWORD dwUType = IIS_MD_UT_FILE;
        DWORD dwDType = STRING_METADATA;
        DWORD dwLength = 0;

        // we need to start this process by getting the existing multisz data from the metabase
        // first, figure out how much memory we will need to do this
        cmdKey.GetData( MD_NTAUTHENTICATION_PROVIDERS,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_INHERIT,IIS_MD_UT_FILE,STRING_METADATA);

        // give the buffer some head space
        // dwLength += 2;

        bReturn = FALSE;
        if (dwLength > 0)
        {
            // now get the real data from the metabase
            bReturn = cmdKey.GetData( MD_NTAUTHENTICATION_PROVIDERS,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)csOrder.GetBuffer( dwLength ),dwLength,METADATA_INHERIT,IIS_MD_UT_FILE,STRING_METADATA );
            csOrder.ReleaseBuffer();
        }

        // the data doesn't get written out here, so close the metabase key
        cmdKey.Close();

        // if reading the value from the metabase didn't work, zero out the string
        if ( !bReturn ){csOrder.Empty();}
    }

    // if there is something in the order string from the upgrade, then we need to start adding commas
    if ( !csOrder.IsEmpty() ){fAddComma = TRUE;}

    // search for negotiate.
    // if it is there then set flag.
    if ( csOrder.Find( _T("Negotiate") ) >= 0 ) {bFound_Negotiate = TRUE;}
    if ( csOrder.Find( _T("NTLM") ) >= 0 ) {bFound_NTLM = TRUE;}

    if (bFound_Negotiate && bFound_NTLM)
    {
        // The entries already exist. so exit
        goto VerifyMD_NTAuthenticationProviders_WWW_Exit;
    }

    if (bFound_NTLM)
    {
        // we found NTLM
        // check if Negotiate is in there.
        // So let's add it to the end
        if (fAddComma) {csOrder += _T(',');}
        if (!bFound_Negotiate)
        {
            // no Negotiate entry, add both NTLM and Negotiate in place of NTLM!
            // Find where NTLM exists and stick Negotiate in front of it!
            // testing,NTLM,somethingelse
            j = csOrder.Find(_T(','));
            if ( j != -1 )
            {
                CString csLeftSide;
                CString csRightSide;

                j = csOrder.Find(_T("NTLM"));
                // means more than 1 item
                csLeftSide = csOrder.Mid(0, j);
                csRightSide = csOrder.Mid(j+4);
                csOrder = csLeftSide;
                csOrder += _T("Negotiate,NTLM");
                csOrder += csRightSide;
            }
            else
            { 
                csOrder = _T("Negotiate,NTLM");
            }
            iPleaseWriteOutTheEntry = TRUE;
        }
    }
    else
    {
        // That means we didn't find NTLM
        // So let's add it to the end
        if (fAddComma) {csOrder += _T(',');}
        if (bFound_Negotiate)
        {
            iPleaseWriteOutTheEntry = TRUE;
            // negotiate already exists, so just add NTLM entry to the end of the list.
            csOrder += _T("NTLM");
        }
        else
        {
            // No NTLM and No Negotiate, add them both.
            iPleaseWriteOutTheEntry = TRUE;
            csOrder += _T("Negotiate,NTLM");
        }
    }

    if (TRUE == iPleaseWriteOutTheEntry)
    {
        dwReturn = WriteToMD_NTAuthenticationProviders_WWW(csOrder);
    }

    goto VerifyMD_NTAuthenticationProviders_WWW_Exit;

VerifyMD_NTAuthenticationProviders_WWW_Exit:
    iisDebugOut_End(_T("VerifyMD_NTAuthenticationProviders_WWW"),LOG_TYPE_TRACE);
    return dwReturn;
}


void AddSpecialCustomErrors(IN HINF hFile,IN LPCTSTR szSection,IN CString csKeyPath,IN BOOL fOverwrite)
{
    iisDebugOut((LOG_TYPE_TRACE, _T("AddSpecialCustomErrors():Start.%s:%s.\n"),szSection,csKeyPath));
    // open the .inf file and get the infsection
    // read that section and add it to the custom errors at the csKeypath.
    CStringList strList;
    CString csTheSection = szSection;

    CString csTemp;
    DWORD   dwErrorCode;
    DWORD   dwErrorSubCode;

    if (ERROR_SUCCESS == FillStrListWithListOfSections(hFile, strList, csTheSection))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos = NULL;
            CString csEntry;

            pos = strList.GetHeadPosition();
            while (pos) 
            {
                csEntry = strList.GetAt(pos);

                // at this point csEntry should look like this:
                // 500,100,URL,/iisHelp/common/500-100.asp

                // parse the line.

                // get the first error ID code
                csTemp = csEntry.Left( csEntry.Find(_T(',')) );
                csEntry = csEntry.Right( csEntry.GetLength() - (csTemp.GetLength() +1) );
                _stscanf( csTemp, _T("%d"), &dwErrorCode );

                // get the second code
                csTemp = csEntry.Left( csEntry.Find(_T(',')) );
                csEntry = csEntry.Right( csEntry.GetLength() - (csTemp.GetLength() +1) );
                if ( csTemp == _T('*') )
                    dwErrorSubCode = -1;
                else
                    _stscanf( csTemp, _T("%d"), &dwErrorSubCode );

                // Get the next whole string
                csTemp = csEntry;

                // Addthe new error code.
                AddCustomError(dwErrorCode, dwErrorSubCode, csTemp, csKeyPath, fOverwrite);

                // get the next error
                strList.GetNext(pos);
            }
        }
    }
    iisDebugOut_End1(_T("AddSpecialCustomErrors"),csKeyPath,LOG_TYPE_TRACE);
    return;
}


// given a pointer to a map for a single virtual website, this routine creates its vitual directories - BOYDM
// szSvcName            the name of the server - W3SVC or MSFTPSVC
// i                    the virtual server number
// pObj                 the map for the virtual server's directories
// szVirtServerPath     the path to the node we are creating. example:   LM/W3SVC/1
//
// returns the value of n, which is used to then increment i

// ****** warning ****** This does not necessarily start from #1 !!! ******
// will get the next open virtual server number and add from there.
UINT AddVirtualServer(LPCTSTR szSvcName, UINT i, CMapStringToString *pObj, CString& csRoot, CString& csIP)
{
    iisDebugOut((LOG_TYPE_TRACE, _T("AddVirtualServer():Start.%s.%d.%s.%s.\n"),szSvcName,i,csRoot,csIP));
    CMDKey cmdKey;
    TCHAR Buf[10];
    UINT SvcId;

    // convert the virtual server number to a string
    _itot(i, Buf, 10);

    // Default the progress text to the web server
    SvcId = IDS_ADD_SETTINGS_FOR_WEB_1;
    if (_tcsicmp(szSvcName, _T("MSFTPSVC")) == 0) {SvcId = IDS_ADD_SETTINGS_FOR_FTP_1;}
    // Display the Current Site number so the user knows what we are doing

    CString csKeyPath = csRoot;
    csKeyPath += _T("/");
    csKeyPath += Buf; //  "LM/W3SVC/n"
    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, csKeyPath);
    if ( (METADATA_HANDLE)cmdKey ) {cmdKey.Close();}
    else
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("AddVirtualServer():CreateNode %s. FAILED.\n"),csKeyPath));
        return i;
    }

    //
    // /W3SVC/1/IIsWebServer
    //
    if (csRoot.Find(_T("W3SVC")) != -1)
    {
        WriteToMD_IIsWebServerInstance_WWW(csKeyPath);
    }
    else
    {
        WriteToMD_IIsFtpServerInstance_FTP(csKeyPath);
    }

    // for W3SVC or MSFTPSVC
    //
    // /W3SVC/1/ServerBindings
    // /MSFTPSVC/1/ServerBindings
    //
    WriteToMD_ServerBindings(szSvcName, csKeyPath, csIP);

    //
    // /W3SVC/1/SecureBindings
    //
    if (csRoot.Find(_T("W3SVC")) != -1)
    {
        // if this is the web server
        WriteToMD_SecureBindings(csKeyPath, csIP);
    }

    // About Default Site and Server Size
    if (csIP.Compare(_T("null"))==0)
    {
        // for W3SVC or MSFTPSVC
        //"LM/W3SVC/N/ServerSize"
        //"LM/W3SVC/N/ServerComment"
        //
        //"LM/MSFTPSVC/N/ServerSize"
        //"LM/MSFTPSVC/N/ServerComment"
        WriteToMD_DefaultSiteAndSize(csKeyPath);

        if (csRoot.Find(_T("W3SVC")) != -1)
        {
            // Do only for wwww server!
            CString csTheSection = _T("DefaultLoadFile");
            if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, csTheSection))
            {
                VerifyMD_DefaultLoadFile_WWW(csTheSection, csKeyPath);
            }
	        // Check if the defaultload.asp file exists...
            // Add the auth for a certain file...
            CString csVrootPlusFileName;
            csVrootPlusFileName.Format(_T("%s\\%s"), g_pTheApp->m_csPathWWWRoot, _T("localstart.asp"));
            if (IsFileExist(csVrootPlusFileName))
            {
                csVrootPlusFileName = csKeyPath;
	            csVrootPlusFileName += _T("/ROOT/localstart.asp");
                WriteToMD_Authorization(csVrootPlusFileName, MD_AUTH_NT | MD_AUTH_BASIC);
            }
        }
    }

    //
    // Loop thru the Virtual Dirs
    //
    POSITION pos1 = pObj->GetStartPosition();
    TCHAR szSpecialSection[200];
    CString csFullKeyPath;
    while (pos1)
    {
        CString csValue;
        CString csName;
        pObj->GetNextAssoc(pos1, csName, csValue);
        //
        // Create Virtual Root Tree
        //
        // CreateMDVRootTree(LM/W3SVC/1, /, "<path>,<username>,<perm>", "null", nProgressBarTextWebInstance)
        // CreateMDVRootTree(LM/W3SVC/1, /IISADMIN, "<path>,<username>,<perm>", "122.255.255.255", nProgressBarTextWebInstance)
        // CreateMDVRootTree(LM/W3SVC/1, /IISSAMPLES, "<path>,<username>,<perm>", "122.255.255.255", nProgressBarTextWebInstance)
        // CreateMDVRootTree(LM/W3SVC/1, /IISHELP, "%s\\Help\\iishelp,,%x", "122.255.255.255", nProgressBarTextWebInstance)
        // CreateMDVRootTree(LM/W3SVC/1, /SCRIPTS, "<path>,<username>,<perm>", "122.255.255.255", nProgressBarTextWebInstance)
        // CreateMDVRootTree(LM/W3SVC/1, /IISADMPWD, "<path>,<username>,<perm>", "122.255.255.255", nProgressBarTextWebInstance)
        //
        // Will create:
        // /=          /W3SVC/1/ROOT
        // IISADMIN=   /W3SVC/1/ROOT/IISADMIN
        // IISSAMPLES= /W3SVC/1/ROOT/IISSAMPLES
        // IISHELP=    /W3SVC/1/ROOT/IISHELP
        // SCRIPTS=    /W3SVC/1/ROOT/SCRIPTS
        // IISADMPWD=  /W3SVC/1/ROOT/IISADMPWD
        CreateMDVRootTree(csKeyPath, csName, csValue, csIP, i);

        if (csRoot.Find(_T("W3SVC")) != -1)
        {
            if (csName == _T("/"))
                {csFullKeyPath = csKeyPath + _T("/ROOT");}
            else
                {csFullKeyPath = csKeyPath + _T("/ROOT") + csName;}

            // Add Special Custom errors for this vroot
            AddSpecialCustomErrors(g_pTheApp->m_hInfHandle, _T("CUSTOMERROR_ALL_DEFAULT_VDIRS"), csFullKeyPath, TRUE);

            // Add Special Custom errors for this certain vroot
            _stprintf(szSpecialSection, _T("CUSTOMERROR_%s"), csName);
            AddSpecialCustomErrors(g_pTheApp->m_hInfHandle, szSpecialSection, csFullKeyPath, TRUE);
        }
        
        AdvanceProgressBarTickGauge();
    }

    if (csRoot.Find(_T("W3SVC")) != -1)
    {
        // if this is for the web server
        WriteToMD_CertMapper(csKeyPath);
    }

    //AdvanceProgressBarTickGauge();

    // return the value of i so that it can be incremented
    iisDebugOut((LOG_TYPE_TRACE, _T("AddVirtualServer():End.%s.%d.%s.%s.\n"),szSvcName,i,csRoot,csIP));
    return i;
}



// The list will be filled with every instance we care to look at:
// We should now loop thru the list and make sure that we have all the required fields.
// csMDPath = like LM/W3SVC/N
int VerifyVRoots_W3SVC_n(CString csMDPath)
{
    int iReturn = FALSE;
    iisDebugOut_Start(_T("VerifyVRoots_W3SVC_n"), LOG_TYPE_TRACE);

    /*
    [/W3SVC/1]
        ServerSize                    : [IS]    (DWORD)  0x1={Medium}
        ServerComment                 : [IS]    (STRING) "Default Web Site"
        KeyType                       : [S]     (STRING) "IIsWebServer"
        ServerBindings                : [IS]    (MULTISZ) ":80:"
        SecureBindings                : [IS]    (MULTISZ) ":443:"
    */
    WriteToMD_IIsWebServerInstance_WWW(csMDPath);
    WriteToMD_DefaultSiteAndSize(csMDPath);
    if (csMDPath.CompareNoCase(_T("LM/W3SVC/1")) == 0)
    {
        // if this is the default web site then it's get's special consideration
        WriteToMD_ServerBindings(_T("W3SVC"), csMDPath, _T("null"));
        WriteToMD_SecureBindings(csMDPath, _T("null"));
    }
    else
    {
        // how do i get the csIP???
        // for other W3SVC/2 sites???

    }

    iisDebugOut_End(_T("VerifyVRoots_W3SVC_n"),LOG_TYPE_TRACE);
    return iReturn;
}


DWORD WriteToMD_Capabilities(LPCTSTR lpszSvc)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    DWORD dwCapabilities = 0;

    // Set the capability type - default to win95
    // Set odbc on if server...
    dwCapabilities = IIS_CAP1_W95;
    if (g_pTheApp->m_eNTOSType == OT_PDC_OR_BDC){dwCapabilities = IIS_CAP1_NTS; dwCapabilities |= IIS_CAP1_ODBC_LOGGING;}
    if (g_pTheApp->m_eNTOSType == OT_NTW){dwCapabilities = IIS_CAP1_NTW;}
    if (g_pTheApp->m_eNTOSType == OT_NTS){dwCapabilities = IIS_CAP1_NTS; dwCapabilities |= IIS_CAP1_ODBC_LOGGING;}

    // LM/MSFTPSVC
    // LM/W3SVC
    CString csKeyPath = _T("LM/");
    csKeyPath += lpszSvc;
    csKeyPath += _T("/Info");
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_SERVER_CAPABILITIES;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwCapabilities;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}


// loop thru the metabase
// and look for the next instance number which is not used!
// return that.  "i" is at least = 1.
int VerifyVRoots(LPCTSTR szSvcName)
{
    iisDebugOut_Start(_T("VerifyVRoots"), LOG_TYPE_TRACE);
    
    CString csRoot = _T("LM/");
    csRoot += szSvcName; //  "LM/W3SVC"

    TCHAR Buf[10];
    CString csInstRoot, csMDPath;
    CMDKey cmdKey;

    CStringList strListInstance;

    int i = 1;

    // Loop thru every instance of
    // the servers "LM/W3SVC/N"
    csInstRoot = csRoot;
    csInstRoot += _T("/");

    _itot(i, Buf, 10);
    csMDPath = csInstRoot + Buf;
    cmdKey.OpenNode(csMDPath);
    while ( (METADATA_HANDLE)cmdKey )
    {
        cmdKey.Close();
        _itot(++i, Buf, 10);
        csMDPath = csInstRoot + Buf;
        cmdKey.OpenNode(csMDPath);
        if ((METADATA_HANDLE) cmdKey)
        {
            // Add it to our list of our nodes!
            strListInstance.AddTail(csMDPath);
        }
    }

    if (strListInstance.IsEmpty() == FALSE)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("************** Loop START **************")));
        POSITION pos = NULL;
        CString csEntry;
        pos = strListInstance.GetHeadPosition();
        while (pos)
        {
            csEntry = strListInstance.GetAt(pos);
            iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("%1!s!\n"), csEntry));
            if (_tcsicmp(szSvcName, _T("W3SVC")) == 0)
            {
                VerifyVRoots_W3SVC_n(csEntry);
            }

            strListInstance.GetNext(pos);
        }
        iisDebugOut((LOG_TYPE_TRACE, _T("************** Loop END **************")));
    }

    iisDebugOut_End(_T("VerifyVRoots"),LOG_TYPE_TRACE);
    return TRUE;
}


DWORD HandleSecurityTemplates(LPCTSTR szSvcName)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwReturnTemp = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csKeyType;
    CString csKeyPath;
    UINT iComment = IDS_TEMPLATE_PUBLIC_WEB_SITE;

    DWORD dwRegularPerm;

    if (_tcsicmp(szSvcName, _T("W3SVC")) == 0)
    {
        //
        // do www regular
        //
        dwRegularPerm = MD_ACCESS_SCRIPT | MD_ACCESS_READ;
        csKeyPath = _T("LM/W3SVC/Info/Templates/Public Web Site");

        iComment = IDS_TEMPLATE_PUBLIC_WEB_SITE;
        dwReturn = WriteToMD_ServerComment(csKeyPath, iComment);
        dwReturnTemp = WriteToMD_IIsWebServerInstance_WWW(csKeyPath);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        csKeyPath = _T("LM/W3SVC/Info/Templates/Public Web Site/Root");

        dwReturnTemp = WriteToMD_AccessPerm(csKeyPath, dwRegularPerm, TRUE);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        dwReturnTemp = WriteToMD_Authorization(csKeyPath, MD_AUTH_ANONYMOUS);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        WriteToMD_IPsec_GrantByDefault(csKeyPath);

        //
        // do www secure site
        //
        dwRegularPerm = MD_ACCESS_SCRIPT | MD_ACCESS_READ;
        csKeyPath = _T("LM/W3SVC/Info/Templates/Secure Web Site");

        iComment = IDS_TEMPLATE_PUBLIC_SECURE_SITE;
        dwReturn = WriteToMD_ServerComment(csKeyPath, iComment);

        dwReturnTemp = WriteToMD_IIsWebServerInstance_WWW(csKeyPath);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        csKeyPath = _T("LM/W3SVC/Info/Templates/Secure Web Site/Root");
        dwReturnTemp = WriteToMD_AccessPerm(csKeyPath, dwRegularPerm, TRUE);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        dwReturnTemp = WriteToMD_Authorization(csKeyPath, MD_AUTH_MD5 | MD_AUTH_NT | MD_AUTH_BASIC);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        WriteToMD_IPsec_GrantByDefault(csKeyPath);

    }
    else
    {
        //
        // do ftp site
        //

        dwRegularPerm = MD_ACCESS_READ;
        csKeyPath = _T("LM/MSFTPSVC/Info/Templates/Public FTP Site");

        iComment = IDS_TEMPLATE_PUBLIC_FTP_SITE;
        dwReturn = WriteToMD_ServerComment(csKeyPath, iComment);

        dwReturnTemp = WriteToMD_IIsFtpServerInstance_FTP(csKeyPath);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        csKeyPath = _T("LM/MSFTPSVC/Info/Templates/Public FTP Site/Root");

        dwReturnTemp = WriteToMD_AccessPerm(csKeyPath, dwRegularPerm, TRUE);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        csKeyPath = _T("LM/MSFTPSVC/Info/Templates/Public FTP Site");
        dwReturnTemp = WriteToMD_AllowAnonymous_FTP(csKeyPath);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}
        dwReturnTemp = WriteToMD_AnonymousOnly_FTP(csKeyPath);
        if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

        WriteToMD_IPsec_GrantByDefault(csKeyPath);
    }

    iisDebugOut_End(_T("HandleSecurityTemplates"),LOG_TYPE_TRACE);
    return dwReturn;
}

DWORD WriteToMD_IPsec_GrantByDefault(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    // LM/MSFTPSVC
    // LM/W3SVC
    // cmdKey.SetData(MD_IP_SEC,METADATA_INHERIT | METADATA_REFERENCE,IIS_MD_UT_FILE,BINARY_METADATA,acCheck.GetStorage()->GetUsed(),(acCheck.GetStorage()->GetAlloc()? acCheck.GetStorage()->GetAlloc() : (LPBYTE)""));
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_IP_SEC;
    stMDEntry.dwMDAttributes = METADATA_INHERIT | METADATA_REFERENCE;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = BINARY_METADATA;
    stMDEntry.dwMDDataLen = 0;
    stMDEntry.pbMDData = (LPBYTE)"";

    // we know we are tryint to write nothing, so make sure
    // we don't try to retrieve nothing from it.
    //int iBeforeValue = FALSE;
    //iBeforeValue = g_CheckIfMetabaseValueWasWritten;
    //g_CheckIfMetabaseValueWasWritten = FALSE;
    dwReturn = SetMDEntry(&stMDEntry);
    // Set the flag back after calling the function
    //g_CheckIfMetabaseValueWasWritten = iBeforeValue;

    return dwReturn;
}


DWORD WriteToMD_HttpExpires(CString csData)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    MDEntry stMDEntry;

    stMDEntry.szMDPath = _T("LM/W3SVC");
    stMDEntry.dwMDIdentifier = MD_HTTP_EXPIRES;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csData.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csData;
    dwReturnTemp = SetMDEntry_Wrap(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    return dwReturn;
}




DWORD WriteToMD_AllowAnonymous_FTP(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    DWORD dwData = 0;

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_ALLOW_ANONYMOUS;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    dwData = 0x1;
    stMDEntry.pbMDData = (LPBYTE)&dwData;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}


DWORD WriteToMD_AnonymousOnly_FTP(CString csKeyPath)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    DWORD dwData = 0;

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_ANONYMOUS_ONLY;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    dwData = 0x1;
    stMDEntry.pbMDData = (LPBYTE)&dwData;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}


DWORD WriteToMD_IWamUserName_WWW(void)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    CMDKey cmdKey;
    MDEntry stMDEntry;
    MDEntry stMDEntry_Pass;

    // the username
    stMDEntry.szMDPath = _T("LM/W3SVC");
    stMDEntry.dwMDIdentifier = MD_WAM_USER_NAME;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (g_pTheApp->m_csWAMAccountName.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR) g_pTheApp->m_csWAMAccountName;

    // the password
    stMDEntry_Pass.szMDPath = _T("LM/W3SVC");
    stMDEntry_Pass.dwMDIdentifier = MD_WAM_PWD;
    stMDEntry_Pass.dwMDAttributes = METADATA_INHERIT | METADATA_SECURE;
    stMDEntry_Pass.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry_Pass.dwMDDataType = STRING_METADATA;
    stMDEntry_Pass.dwMDDataLen = (g_pTheApp->m_csWAMAccountPassword.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry_Pass.pbMDData = (LPBYTE)(LPCTSTR) g_pTheApp->m_csWAMAccountPassword;
    // make sure and delete it first
    // DeleteMDEntry(&stMDEntry_Pass);

    // --------------------------------------------------
    // always overwrite, we may have changed the password
    // important: Set th