b, iTopOld, iTopNew);
                plb->iTop = iTopNew;
            } else if (abs(iTopNew - iTopOld) > plb->cItemFullMax)
                yAmt = 32000;
            else
                yAmt = (iTopOld - iTopNew) * plb->cyChar;
        }

        dwFlags = LBGetScrollFlags(plb, dwTime);
        ScrollWindowEx(HWq(plb->spwnd), xAmt, yAmt, NULL, &rc, NULL,
                NULL, dwFlags);
        UpdateWindow(HWq(plb->spwnd));
    }

    // Note that although we turn off the caret regardless of redraw, we
    // only turn it on if redraw is true. Slimy thing to fixup many
    // caret related bugs...
    if (fCaretOn)
        // Turn the caret back on only if we turned it off. This avoids
        // annoying caret flicker.
        xxxLBSetCaret(plb, TRUE);
}


/***************************************************************************\
* xxxInsureVisible
*
* History:
\***************************************************************************/

void xxxInsureVisible(
    PLBIV plb,
    INT iSel,
    BOOL fPartial)  /* It is ok for the item to be partially visible */
{
    INT sLastVisibleItem;

    CheckLock(plb->spwnd);

    if (iSel < plb->iTop) {
        xxxNewITop(plb, iSel);
    } else {
        if (fPartial) {

            /*
             * 1 must be subtracted to get the last visible item
             * A part of the fix for Bug #3727 -- 01/14/91 -- SANKAR
             */
            sLastVisibleItem = plb->iTop + CItemInWindow(plb, TRUE) - (INT)1;
        } else {
            sLastVisibleItem = LastFullVisible(plb);
        }

        if (plb->OwnerDraw != OWNERDRAWVAR) {
            if (iSel > sLastVisibleItem) {
                if (plb->fMultiColumn) {
                    xxxNewITop(plb,
                        ((iSel / plb->itemsPerColumn) -
                        max(plb->numberOfColumns-1,0)) * plb->itemsPerColumn);
                } else {
                    xxxNewITop(plb, (INT)max(0, iSel - sLastVisibleItem + plb->iTop));
                }
            }
        } else if (iSel > sLastVisibleItem)
            xxxNewITop(plb, LBPage(plb, iSel, FALSE));
    }
}

/***************************************************************************\
* xxxLBoxCaretBlinker
*
* Timer callback function toggles Caret
* Since it is a callback, it is APIENTRY
*
* History:
\***************************************************************************/

VOID xxxLBoxCaretBlinker(
    HWND hwnd,
    UINT wMsg,
    UINT_PTR nIDEvent,
    DWORD dwTime)
{
    PWND pwnd;
    PLBIV plb;

    /*
     * Standard parameters for a timer callback function that aren't used.
     * Mentioned here to avoid compiler warnings
     */
    UNREFERENCED_PARAMETER(wMsg);
    UNREFERENCED_PARAMETER(nIDEvent);
    UNREFERENCED_PARAMETER(dwTime);

    pwnd = ValidateHwnd(hwnd);
    plb = ((PLBWND)pwnd)->pLBIV;

    /*
     * leave caret on, don't blink it off (prevents rapid blinks?)
     */
    if (ISREMOTESESSION() && plb->fCaretOn) {
        return;
    }

    /*
     * Check if the Caret is ON, if so, switch it OFF
     */
    xxxLBSetCaret(plb, !plb->fCaretOn);
    return;
}


/***************************************************************************\
* xxxLBoxCtlKeyInput
*
* If msg == LB_KEYDOWN, vKey is the number of the item to go to,
* otherwise it is the virtual key.
*
* History:
\***************************************************************************/

void xxxLBoxCtlKeyInput(
    PLBIV plb,
    UINT msg,
    UINT vKey)
{
    INT i;
    INT iNewISel;
    INT cItemPageScroll;
    PCBOX pcbox;
    BOOL fDropDownComboBox;
    BOOL fExtendedUIComboBoxClosed;
    BOOL hScrollBar = TestWF(plb->spwnd, WFHSCROLL);
    UINT wModifiers = 0;
    BOOL fSelectKey = FALSE;  /* assume it is a navigation key */
    UINT uEvent = 0;
    HWND hwnd = HWq(plb->spwnd);
    TL tlpwndParent;
    TL tlpwnd;

    CheckLock(plb->spwnd);

    pcbox = plb->pcbox;

    /*
     * Is this a dropdown style combo box/listbox ?
     */
    fDropDownComboBox = pcbox && (pcbox->CBoxStyle & SDROPPABLE);

    /*
     *Is this an extended ui combo box which is closed?
     */
    fExtendedUIComboBoxClosed = fDropDownComboBox && pcbox->fExtendedUI &&
                              !pcbox->fLBoxVisible;

    if (plb->fMouseDown || (!plb->cMac && vKey != VK_F4)) {

        /*
         * Ignore keyboard input if we are in the middle of a mouse down deal or
         * if there are no items in the listbox. Note that we let F4's go
         * through for combo boxes so that the use can pop up and down empty
         * combo boxes.
         */
        return;
    }

    /*
     * Modifiers are considered only in EXTENDED sel list boxes.
     */
    if (plb->wMultiple == EXTENDEDSEL) {

        /*
         * If multiselection listbox, are any modifiers used ?
         */
        if (GetKeyState(VK_SHIFT) < 0)
            wModifiers = SHIFTDOWN;
        if (GetKeyState(VK_CONTROL) < 0)
            wModifiers += CTLDOWN;

        /*
         * Please Note that (SHIFTDOWN + CTLDOWN) == (SHCTLDOWN)
         */
    }

    if (msg == LB_KEYDOWN) {

        /*
         * This is a listbox "go to specified item" message which means we want
         * to go to a particular item number (given by vKey) directly.  ie.  the
         * user has typed a character and we want to go to the item which
         * starts with that character.
         */
        iNewISel = (INT)vKey;
        goto TrackKeyDown;
    }

    cItemPageScroll = plb->cItemFullMax;

    if (cItemPageScroll > 1)
        cItemPageScroll--;

    if (plb->fWantKeyboardInput) {

        /*
         * Note: msg must not be LB_KEYDOWN here or we'll be in trouble...
         */
        ThreadLock(plb->spwndParent, &tlpwndParent);
        iNewISel = (INT)SendMessage(HW(plb->spwndParent), WM_VKEYTOITEM,
                MAKELONG(vKey, plb->iSelBase), (LPARAM)hwnd);
        ThreadUnlock(&tlpwndParent);

        if (iNewISel == -2) {

            /*
             * Don't move the selection...
             */
            return;
        }
        if (iNewISel != -1) {

            /*
             * Jump directly to the item provided by the app
             */
            goto TrackKeyDown;
        }

        /*
         * else do default processing of the character.
         */
    }

    switch (vKey) {
    // LATER IanJa: not language independent!!!
    // We could use VkKeyScan() to find out which is the '\' key
    // This is VK_OEM_5 '\|' for US English only.
    // Germans, Italians etc. have to type CTRL+^ (etc) for this.
    // This is documented as File Manager behaviour for 3.0, but apparently
    // not for 3.1., although functionality remains. We should still fix it,
    // although German (etc?) '\' is generated with AltGr (Ctrl-Alt) (???)
    case VERKEY_BACKSLASH:  /* '\' character for US English */

        /*
         * Check if this is CONTROL-\ ; If so Deselect all items
         */
        if ((wModifiers & CTLDOWN) && (plb->wMultiple != SINGLESEL)) {
            xxxLBSetCaret(plb, FALSE);
            xxxResetWorld(plb, plb->iSelBase, plb->iSelBase, FALSE);

            /*
             * And select the current item
             */
            SetSelected(plb, plb->iSelBase, TRUE, HILITEANDSEL);
            xxxInvertLBItem(plb, plb->iSelBase, TRUE);
            uEvent = EVENT_OBJECT_SELECTION;
            goto CaretOnAndNotify;
        }
        return;
        break;

    case VK_DIVIDE:     /* NumPad '/' character on enhanced keyboard */
    // LATER IanJa: not language independent!!!
    // We could use VkKeyScan() to find out which is the '/' key
    // This is VK_OEM_2 '/?' for US English only.
    // Germans, Italians etc. have to type CTRL+# (etc) for this.
    case VERKEY_SLASH:  /* '/' character */

        /*
         * Check if this is CONTROL-/ ; If so select all items
         */
        if ((wModifiers & CTLDOWN) && (plb->wMultiple != SINGLESEL)) {
            xxxLBSetCaret(plb, FALSE);
            xxxResetWorld(plb, -1, -1, TRUE);

            uEvent = EVENT_OBJECT_SELECTIONWITHIN;

CaretOnAndNotify:
            xxxLBSetCaret(plb, TRUE);
            LBEvent(plb, uEvent, plb->iSelBase);
            xxxNotifyOwner(plb, LBN_SELCHANGE);
        }
        return;
        break;

    case VK_F8:

        /*
         * The "Add" mode is possible only in Multiselection listboxes...  Get
         * into it via SHIFT-F8...  (Yes, sometimes these UI people are sillier
         * than your "typical dumb user"...)
         */
        if (plb->wMultiple != SINGLESEL && wModifiers == SHIFTDOWN) {

            /*
             * We have to make the caret blink! Do something...
             */
            if (plb->fAddSelMode) {

                /*
                 * Switch off the Caret blinking
                 */
                NtUserKillTimer(hwnd, IDSYS_CARET);

                /*
                 * Make sure the caret does not vanish
                 */
                xxxLBSetCaret(plb, TRUE);
            } else {

                /*
                 * Create a timer to make the caret blink
                 */
                NtUserSetTimer(hwnd, IDSYS_CARET, gpsi->dtCaretBlink,
                        xxxLBoxCaretBlinker);
            }

            /*
             * Toggle the Add mode flag
             */
            plb->fAddSelMode = (UINT)!plb->fAddSelMode;
        }
        return;
    case VK_SPACE:  /* Selection key is space */
        i = 0;
        fSelectKey = TRUE;
        break;

    case VK_PRIOR:
        if (fExtendedUIComboBoxClosed) {

            /*
             * Disable movement keys for TandyT.
             */
            return;
        }

        if (plb->OwnerDraw == OWNERDRAWVAR) {
            i = LBPage(plb, plb->iSelBase, FALSE) - plb->iSelBase;
        } else {
            i = -cItemPageScroll;
        }
        break;

    case VK_NEXT:
        if (fExtendedUIComboBoxClosed) {

            /*
             * Disable movement keys for TandyT.
             */
            return;
        }

        if (plb->OwnerDraw == OWNERDRAWVAR) {
            i = LBPage(plb, plb->iSelBase, TRUE) - plb->iSelBase;
        } else {
            i = cItemPageScroll;
        }
        break;

    case VK_HOME:
        if (fExtendedUIComboBoxClosed) {

            /*
             * Disable movement keys for TandyT.
             */
            return;
        }

        i = (INT_MIN/2)+1;  /* A very big negative number */
        break;

    case VK_END:
        if (fExtendedUIComboBoxClosed) {

            /*
             * Disable movement keys for TandyT.
             */
            return;
        }

        i = (INT_MAX/2)-1;  /* A very big positive number */
        break;

    case VK_LEFT:
        if (plb->fMultiColumn) {
            if (plb->fRightAlign ^ (!!TestWF(plb->spwnd, WEFLAYOUTRTL))) {
                goto ReallyRight;
            }
ReallyLeft:
            if (plb->iSelBase / plb->itemsPerColumn == 0) {
                i = 0;
            } else {
                i = -plb->itemsPerColumn;
            }
            break;
        }

        if (hScrollBar) {
            goto HandleHScrolling;
        } else {

            /*
             * Fall through and handle this as if the up arrow was pressed.
             */

            vKey = VK_UP;
        }

        /*
         * Fall through
         */

    case VK_UP:
        if (fExtendedUIComboBoxClosed)
            // Disable movement keys for TandyT.
            return;

        i = -1;
        break;

    case VK_RIGHT:
        if (plb->fMultiColumn) {
            if (plb->fRightAlign ^ (!!TestWF(plb->spwnd, WEFLAYOUTRTL))) {
                goto ReallyLeft;
            }
ReallyRight:
            if (plb->iSelBase / plb->itemsPerColumn == plb->cMac / plb->itemsPerColumn) {
                i = 0;
            } else {
                i = plb->itemsPerColumn;
            }
            break;
        }
        if (hScrollBar) {
HandleHScrolling:
            PostMessage(hwnd, WM_HSCROLL,
                    (vKey == VK_RIGHT ? SB_LINEDOWN : SB_LINEUP), 0L);
            return;
        } else {

            /*
             * Fall through and handle this as if the down arrow was
             * pressed.
             */
            vKey = VK_DOWN;
        }

        /*
         * Fall through
         */

    case VK_DOWN:
        if (fExtendedUIComboBoxClosed) {

            /*
             * If the combo box is closed, down arrow should open it.
             */
            if (!pcbox->fLBoxVisible) {

                /*
                 * If the listbox isn't visible, just show it
                 */
                ThreadLock(pcbox->spwnd, &tlpwnd);
                xxxCBShowListBoxWindow(pcbox, TRUE);
                ThreadUnlock(&tlpwnd);
            }
            return;
        }
        i = 1;
        break;

    case VK_ESCAPE:
    case VK_RETURN:
        if (!fDropDownComboBox || !pcbox->fLBoxVisible)
            return;

        // |  If this is a dropped listbox for a combobox and the ENTER  |
        // |  key is pressed, close up the listbox, so FALLTHRU          |
        // V                                                             V

    case VK_F4:
        if (fDropDownComboBox && !pcbox->fExtendedUI) {

            /*
             * If we are a dropdown combo box/listbox we want to process
             * this key.  BUT for TandtT, we don't do anything on VK_F4 if we
             * are in extended ui mode.
             */
            ThreadLock(pcbox->spwnd, &tlpwnd);
            if (!pcbox->fLBoxVisible) {

                /*
                 * If the listbox isn't visible, just show it
                 */
                xxxCBShowListBoxWindow(pcbox, (vKey != VK_ESCAPE));
            } else {

                /*
                 * Ok, the listbox is visible.  So hide the listbox window.
                 */
                xxxCBHideListBoxWindow(pcbox, TRUE, (vKey != VK_ESCAPE));
            }
            ThreadUnlock(&tlpwnd);
        }

        /*
         * Fall through to the return
         */

    default:
        return;
    }

    /*
     * Find out what the new selection should be
     */
    iNewISel = IncrementISel(plb, plb->iSelBase, i);


    if (plb->wMultiple == SINGLESEL) {
        if (plb->iSel == iNewISel) {

            /*
             * If we are single selection and the keystroke is moving us to an
             * item which is already selected, we don't have to do anything...
             */
            return;
        }

        uEvent = EVENT_OBJECT_SELECTION;

        plb->iTypeSearch = 0;
        if ((vKey == VK_UP || vKey == VK_DOWN) &&
                !IsSelected(plb, plb->iSelBase, HILITEONLY)) {

            /*
             * If the caret is on an unselected item and the user just hits the
             * up or down arrow key (ie. with no shift or ctrl modifications),
             * then we will just select the item the cursor is at. This is
             * needed for proper behavior in combo boxes but do we always want
             * to run this code??? Note that this is only used in single
             * selection list boxes since it doesn't make sense in the
             * multiselection case. Note that an LB_KEYDOWN message must not be
             * checked here because the vKey will be an item number not a
             * VK_and we will goof. Thus, trackkeydown label is below this to
             * fix a bug caused by it being above this...
             */
            iNewISel = (plb->iSelBase == -1) ? 0 : plb->iSelBase;
        }
    }

TrackKeyDown:

    xxxSetISelBase(plb, iNewISel);

    xxxLBSetCaret(plb, FALSE);

    if (wModifiers & SHIFTDOWN) {
        // Check if iMouseDown is un-initialised
        if (plb->iMouseDown == -1)
            plb->iMouseDown = iNewISel;
        if (plb->iLastMouseMove == -1)
            plb->iLastMouseMove = iNewISel;

        // Check if we are in ADD mode
        if (plb->fAddSelMode) {
            /* Preserve all the pre-existing selections except the
             * ones connected with the last anchor point; If the last
             * Preserve all the previous selections
            */
            /* Deselect only the selection connected with the last
             * anchor point; If the last anchor point is associated
             * with de-selection, then do not do it
            */

            if (!plb->fNewItemState)
                plb->iLastMouseMove = plb->iMouseDown;

            /* We haven't done anything here because, LBBlockHilite()
             * will take care of wiping out the selection between
             * Anchor point and iLastMouseMove and select the block
             * between anchor point and current cursor location
            */
        } else {
            /* We are not in ADD mode */
            /* Remove all selections except between the anchor point
             * and last mouse move because it will be taken care of in
             * LBBlockHilite
            */
            xxxResetWorld(plb, plb->iMouseDown, plb->iLastMouseMove, FALSE);
        }

        uEvent = EVENT_OBJECT_SELECTIONWITHIN;

        /* LBBlockHilite takes care to deselect the block between
         * the anchor point and iLastMouseMove and select the block
         * between the anchor point and the current cursor location
        */
        /* Toggle all items to the same selection state as the item
         * item at the anchor point) from the anchor point to the
         * current cursor location.
        */
        plb->fNewItemState = IsSelected(plb, plb->iMouseDown, SELONLY);
        xxxLBBlockHilite(plb, iNewISel, TRUE);

        plb->iLastMouseMove = iNewISel;
        /* Preserve the existing anchor point */
    } else {
        /* Check if this is in ADD mode */
        if ((plb->fAddSelMode) || (plb->wMultiple == MULTIPLESEL)) {
            /* Preserve all pre-exisiting selections */
            if (fSelectKey) {
                /* Toggle the selection state of the current item */
                plb->fNewItemState = !IsSelected(plb, iNewISel, SELONLY);
                SetSelected(plb, iNewISel, plb->fNewItemState, HILITEANDSEL);

                xxxInvertLBItem(plb, iNewISel, plb->fNewItemState);

                /* Set the anchor point at the current location */
                plb->iLastMouseMove = plb->iMouseDown = iNewISel;
                uEvent = (plb->fNewItemState ? EVENT_OBJECT_SELECTIONADD :
                        EVENT_OBJECT_SELECTIONREMOVE);
            }
        } else {
            /* We are NOT in ADD mode */
            /* Remove all existing selections except iNewISel, to
             * avoid flickering.
            */
            xxxResetWorld(plb, iNewISel, iNewISel, FALSE);

            /* Select the current item */
            SetSelected(plb, iNewISel, TRUE, HILITEANDSEL);
            xxxInvertLBItem(plb, iNewISel, TRUE);

            /* Set the anchor point at the current location */
            plb->iLastMouseMove = plb->iMouseDown = iNewISel;
            uEvent = EVENT_OBJECT_SELECTION;
        }
    }

    /*
     * Move the cursor to the new location
     */
    xxxInsureVisible(plb, iNewISel, FALSE);
    xxxLBShowHideScrollBars(plb);

    xxxLBSetCaret(plb, TRUE);

    if (uEvent) {
        LBEvent(plb, uEvent, iNewISel);
    }

    /*
     * Should we notify our parent?
     */
    if (plb->fNotify) {
        if (fDropDownComboBox && pcbox->fLBoxVisible) {

            /*
             * If we are in a drop down combo box/listbox and the listbox is
             * visible, we need to set the fKeyboardSelInListBox bit so that the
             * combo box code knows not to hide the listbox since the selchange
             * message is caused by the user keyboarding through...
             */
            pcbox->fKeyboardSelInListBox = TRUE;
            plb->iLastSelection = iNewISel;
        }
        xxxNotifyOwner(plb, LBN_SELCHANGE);
    }
}


/***************************************************************************\
* Compare
*
* Is lpstr1 equal/prefix/less-than/greater-than lsprst2 (case-insensitive) ?
*
* LATER IanJa: this assume a longer string is never a prefix of a longer one.
* Also assumes that removing 1 or more characters from the end of a string will
* give a string tahs sort before the original.  These assumptions are not valid
* for all languages.  We nedd better support from NLS. (Consider French
* accents, Spanish c/ch, ligatures, German sharp-s/SS, etc.)
*
* History:
\***************************************************************************/

INT Compare(
    LPCWSTR pwsz1,
    LPCWSTR pwsz2,
    DWORD dwLocaleId)
{
    UINT len1 = wcslen(pwsz1);
    UINT len2 = wcslen(pwsz2);
    INT result;

    /*
     * CompareStringW returns:
     *    1 = pwsz1  <  pwsz2
     *    2 = pwsz1  == pwsz2
     *    3 = pwsz1  >  pwsz2
     */
    result = CompareStringW((LCID)dwLocaleId, NORM_IGNORECASE,
            pwsz1, min(len1,len2), pwsz2, min(len1, len2));

    if (result == CSTR_LESS_THAN) {
       return LT;
    } else if (result == CSTR_EQUAL) {
        if (len1 == len2) {
            return EQ;
        } else if (len1 < len2) {
            /*
             * LATER IanJa: should not assume shorter string is a prefix
             * Spanish "c" and "ch", ligatures, German sharp-s/SS etc.
             */
            return PREFIX;
        }
    }
    return GT;
}

/***************************************************************************\
* xxxFindString
*
* Scans for a string in the listbox prefixed by or equal to lpstr.
* For OWNERDRAW listboxes without strings and without the sort style, we
* try to match the long app supplied values.
*
* History:
* 16-Apr-1992 beng      The NODATA case
\***************************************************************************/

INT xxxFindString(
    PLBIV plb,
    LPWSTR lpstr,
    INT sStart,
    INT code,
    BOOL fWrap)
{
    /*
     * Search for a prefix match (case-insensitive equal/prefix)
     * sStart == -1 means start from beginning, else start looking at sStart+1
     * assumes cMac > 0.
     */
    INT sInd;  /* index of string */
    INT sStop;          /* index to stop searching at */
    lpLBItem pRg;
    TL tlpwndParent;
    INT sortResult;

/*
 * Owner-Draw version of pRg
 */
#define pODRg ((lpLBODItem)pRg)
    COMPAREITEMSTRUCT cis;
    LPWSTR listboxString;

    CheckLock(plb->spwnd);

    if (plb->fHasStrings && (!lpstr || !*lpstr))
        return LB_ERR;

    if (!plb->fHasData) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "FindString called on NODATA lb");
        return LB_ERR;
    }

    if ((sInd = sStart + 1) >= plb->cMac)
        sInd = (fWrap ? 0 : plb->cMac - 1);

    sStop = (fWrap ? sInd : 0);

    /*
     * If at end and no wrap, stop right away
     */
    if (((sStart >= plb->cMac - 1) && !fWrap) || (plb->cMac < 1)) {
        return LB_ERR;
    }

    /*
     * Apps could pass in an invalid sStart like -2 and we would blow up.
     * Win 3.1 would not so we need to fixup sInd to be zero
     */
    if (sInd < 0)
        sInd = 0;

    pRg = (lpLBItem)(plb->rgpch);

    do {
        if (plb->fHasStrings) {

            /*
             * Searching for string matches.
             */
            listboxString = (LPWSTR)((LPBYTE)plb->hStrings + pRg[sInd].offsz);

            if (code == PREFIX &&
                listboxString &&
                *lpstr != TEXT('[') &&
                *listboxString == TEXT('[')) {

                /*
                 * If we are looking for a prefix string and the first items
                 * in this string are [- then we ignore them.  This is so
                 * that in a directory listbox, the user can goto drives
                 * by selecting the drive letter.
                 */
                listboxString++;
                if (*listboxString == TEXT('-'))
                    listboxString++;
            }

            if (Compare(lpstr, listboxString, plb->dwLocaleId) <= code) {
               goto FoundIt;
            }

        } else {
            if (plb->fSort) {

                /*
                 * Send compare item messages to the parent for sorting
                 */
                cis.CtlType = ODT_LISTBOX;
                cis.CtlID = PtrToUlong(plb->spwnd->spmenu);
                cis.hwndItem = HWq(plb->spwnd);
                cis.itemID1 = (UINT)-1;
                cis.itemData1 = (ULONG_PTR)lpstr;
                cis.itemID2 = (UINT)sInd;
                cis.itemData2 = pODRg[sInd].itemData;
                cis.dwLocaleId = plb->dwLocaleId;

                ThreadLock(plb->spwndParent, &tlpwndParent);
                sortResult = (INT)SendMessage(HW(plb->spwndParent), WM_COMPAREITEM,
                        cis.CtlID, (LPARAM)&cis);
                ThreadUnlock(&tlpwndParent);


                if (sortResult == -1) {
                   sortResult = LT;
                } else if (sortResult == 1) {
                   sortResult = GT;
                } else {
                   sortResult = EQ;
                }

                if (sortResult <= code) {
                    goto FoundIt;
                }
            } else {

                /*
                 * Searching for app supplied long data matches.
                 */
                if ((ULONG_PTR)lpstr == pODRg[sInd].itemData)
                    goto FoundIt;
            }
        }

        /*
         * Wrap round to beginning of list
         */
        if (++sInd == plb->cMac)
            sInd = 0;
    } while (sInd != sStop);

    sInd = -1;

FoundIt:
    return sInd;
}


/***************************************************************************\
* xxxLBoxCtlCharInput
*
* History:
\***************************************************************************/

void xxxLBoxCtlCharInput(
    PLBIV plb,
    UINT  inputChar,
    BOOL  fAnsi)
{
    INT iSel;
    BOOL fControl;
    TL tlpwndParent;

    CheckLock(plb->spwnd);

    if (plb->cMac == 0 || plb->fMouseDown) {

        /*
         * Get out if we are in the middle of mouse routines or if we have no
         * items in the listbox, we just return without doing anything.
         */
        return;
    }

    fControl = (GetKeyState(VK_CONTROL) < 0);

    switch (inputChar) {
    case VK_ESCAPE:
        plb->iTypeSearch = 0;
        if (plb->pszTypeSearch)
            plb->pszTypeSearch[0] = 0;
        break;

    case VK_BACK:
        if (plb->iTypeSearch) {
            plb->pszTypeSearch[plb->iTypeSearch--] = 0;
            if (plb->fSort) {
                iSel = -1;
                goto TypeSearch;
            }
        }
        break;

    case VK_SPACE:
        if (plb->fAddSelMode || plb->wMultiple == MULTIPLESEL)
            break;
        /* Otherwise, for single/extended selection listboxes not in add
         * selection mode, let the  space go thru as a type search character
         * FALL THRU
         */

    default:

        /*
         * Move selection to first item beginning with the character the
         * user typed.  We don't want do this if we are using owner draw.
         */

        if (fAnsi && IS_DBCS_ENABLED() && IsDBCSLeadByteEx(THREAD_CODEPAGE(), (BYTE)inputChar)) {
            WCHAR wch;
            LPWSTR lpwstr = &wch;

            inputChar = DbcsCombine(HWq(plb->spwnd), (BYTE)inputChar);
            RIPMSG1(RIP_VERBOSE, "xxxLBoxCtlCharInput: combined DBCS. 0x%04x", inputChar);

            if (inputChar == 0) {
                RIPMSG1(RIP_WARNING, "xxxLBoxCtlCharInput: cannot combine two DBCS. LB=0x%02x",
                        inputChar);
                break;
            }
            // If it is DBCS, let's ignore the ctrl status.
            fControl = FALSE;

            // Convert DBCS to UNICODE.
            // Note: Leading byte is in the low byte, trailing byte is in high byte.
            // Let's assume Little Endian CPUs only, so inputChar can directly be
            // input for MBSToWCSEx as an ANSI string.
            if (MBToWCSEx(THREAD_CODEPAGE(), (LPCSTR)&inputChar, 2, &lpwstr, 1, FALSE) == 0) {
                RIPMSG1(RIP_WARNING, "xxxLBoxCtlCharInput: cannot convert 0x%04x to UNICODE.",
                        inputChar);
                break;
            }
            inputChar = wch;
        }

        if (plb->fHasStrings) {
            // Incremental Type Search processing
            //
            // update szTypeSearch string and then move to the first item from
            // the current selection whose prefix matches szTypeSearch
            //
            // the szTypeSearch will continue to grow until a "long enough"
            // gap between key entries is encountered -- at which point any
            // more searching will start over

            /*
             * Undo CONTROL-char to char
             */
            if (fControl && inputChar < 0x20)
                inputChar += 0x40;

            if (plb->iTypeSearch == MAX_TYPESEARCH) {
                NtUserMessageBeep(0);
                break;
            }
            iSel = -1;

            if (plb->pszTypeSearch == NULL)
                plb->pszTypeSearch = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(WCHAR) * (MAX_TYPESEARCH + 1));

            if (plb->pszTypeSearch == NULL) {
                NtUserMessageBeep(0);
                break;
            }

            plb->pszTypeSearch[plb->iTypeSearch++] = (WCHAR) inputChar;
            plb->pszTypeSearch[plb->iTypeSearch]   = 0;

TypeSearch:
            if (plb->fSort) {
                // Set timer to determine when to kill incremental searching
                NtUserSetTimer(HWq(plb->spwnd), IDSYS_LBSEARCH,
                               gpsi->dtLBSearch, NULL);
            } else {
                // If this is not a sorted listbox, no incremental search.
                plb->iTypeSearch = 0;
                iSel = plb->iSelBase;
            }


            /*
             * Search for the item beginning with the given character starting
             * at iSel+1.  We will wrap the search to the beginning of the
             * listbox if we don't find the item.   If SHIFT is down and we are
             * a multiselection lb, then the item's state will be set to
             * plb->fNewItemState according to the current mode.
             */
            iSel = xxxFindString(plb, plb->pszTypeSearch, iSel, PREFIX, TRUE);
            if (iSel == -1) {
                // no match found -- check for prefix match
                // (i.e. "p" find FIRST item that starts with 'p',
                //       "pp" find NEXT item that starts with 'p')
                if(plb->iTypeSearch)
                {
                    plb->iTypeSearch--;
                    if ((plb->iTypeSearch == 1) && (plb->pszTypeSearch[0] == plb->pszTypeSearch[1]))
                    {
                        plb->pszTypeSearch[1] = 0;
                        iSel = xxxFindString(plb, plb->pszTypeSearch, plb->iSelBase, PREFIX, TRUE);
                    }
                }
            }
            // if match is found -- select it
            if (iSel != -1)
            {
CtlKeyInput:
                xxxLBoxCtlKeyInput(plb, LB_KEYDOWN, iSel);

            }
        } else {
            if (plb->spwndParent != NULL) {
                ThreadLock(plb->spwndParent, &tlpwndParent);
                iSel = (INT)SendMessageWorker(plb->spwndParent, WM_CHARTOITEM,
                        MAKELONG(inputChar, plb->iSelBase), (LPARAM)HWq(plb->spwnd), fAnsi);
                ThreadUnlock(&tlpwndParent);
            } else
                iSel = -1;

            if (iSel != -1 && iSel != -2)
                goto CtlKeyInput;

        }
        break;
    }
}


/***************************************************************************\
* LBoxGetSelItems
*
* effects: For multiselection listboxes, this returns the total number of
* selection items in the listbox if fCountOnly is true.  or it fills an array
* (lParam) with the items numbers of the first wParam selected items.
*
* History:
\***************************************************************************/

int LBoxGetSelItems(
    PLBIV plb,
    BOOL fCountOnly,
    int wParam,
    LPINT lParam)
{
    int i;
    int itemsselected = 0;

    if (plb->wMultiple == SINGLESEL)
        return LB_ERR;

    for (i = 0; i < plb->cMac; i++) {
        if (IsSelected(plb, i, SELONLY)) {
            if (!fCountOnly) {
                if (itemsselected < wParam)
                    *lParam++ = i;
                else {

                    /*
                     * That's all the items we can fit in the array.
                     */
                    return itemsselected;
                }
            }
            itemsselected++;
        }
    }

    return itemsselected;
}


/***************************************************************************\
* xxxLBSetRedraw
*
* Handle WM_SETREDRAW message
*
* History:
\***************************************************************************/

void xxxLBSetRedraw(
    PLBIV plb,
    BOOL fRedraw)
{
    CheckLock(plb->spwnd);

    if (fRedraw)
        fRedraw = TRUE;

    if (plb->fRedraw != (UINT)fRedraw) {
        plb->fRedraw = !!fRedraw;

        if (fRedraw) {
            xxxLBSetCaret(plb, TRUE);
            xxxLBShowHideScrollBars(plb);

            if (plb->fDeferUpdate) {
                plb->fDeferUpdate = FALSE;
                RedrawWindow(HWq(plb->spwnd), NULL, NULL,
                        RDW_INVALIDATE | RDW_ERASE |
                        RDW_FRAME | RDW_ALLCHILDREN);
            }
        }
    }
}

/***************************************************************************\
* xxxLBSelRange
*
* Selects the range of items between i and j, inclusive.
*
* History:
\***************************************************************************/

void xxxLBSelRange(
    PLBIV plb,
    int iStart,
    int iEnd,
    BOOL fnewstate)
{
    DWORD temp;
    RECT rc;

    CheckLock(plb->spwnd);

    if (iStart > iEnd) {
        temp = iEnd;
        iEnd = iStart;
        iStart = temp;
    }

    /*
     * We don't want to loop through items that don't exist.
     */
    iEnd = min(plb->cMac, iEnd);
    iStart = max(iStart, 0);
    if (iStart > iEnd)
        return;


    /*
     * iEnd could be equal to MAXINT which is why we test temp and iEnd
     * as DWORDs.
     */
    for (temp = iStart; temp <= (DWORD)iEnd; temp++) {

        if (IsSelected(plb, temp, SELONLY) != fnewstate) {
            SetSelected(plb, temp, fnewstate, HILITEANDSEL);
            LBGetItemRect(plb, temp, &rc);

            xxxLBInvalidateRect(plb, (LPRECT)&rc, FALSE);
        }

    }
    UserAssert(plb->wMultiple);
    LBEvent(plb, EVENT_OBJECT_SELECTIONWITHIN, iStart);
}


/***************************************************************************\
* xxxLBSetCurSel
*
* History:
\***************************************************************************/

int xxxLBSetCurSel(
    PLBIV plb,
    int iSel)
{
    CheckLock(plb->spwnd);

    if (!(plb->wMultiple || iSel < -1 || iSel >= plb->cMac)) {
        xxxLBSetCaret(plb, FALSE);
        if (plb->iSel != -1) {

            /*
             * This prevents scrolling when iSel == -1
             */
            if (iSel != -1)
                xxxInsureVisible(plb, iSel, FALSE);

            /*
             * Turn off old selection
             */
            xxxInvertLBItem(plb, plb->iSel, FALSE);
        }

        if (iSel != -1) {
            xxxInsureVisible(plb, iSel, FALSE);
            plb->iSelBase = plb->iSel = iSel;

            /*
             * Highlight new selection
             */
            xxxInvertLBItem(plb, plb->iSel, TRUE);
        } else {
            plb->iSel = -1;
            if (plb->cMac)
                plb->iSelBase = min(plb->iSelBase, plb->cMac-1);
            else
                plb->iSelBase = 0;
        }

        /*
         * Send both focus and selection events
         *
         * We need to send this event even if the listbox isn't visible. See
         * bug #88548. Also see 355612.
         */
        if (_IsWindowVisible(plb->spwnd) || (GetFocus() == HWq(plb->spwnd))) {
            LBEvent(plb, EVENT_OBJECT_FOCUS, plb->iSelBase);
            LBEvent(plb, EVENT_OBJECT_SELECTION, plb->iSel);
        }

        xxxLBSetCaret(plb, TRUE);
        return plb->iSel;
    }

    return LB_ERR;
}


/***************************************************************************\
* LBSetItemData
*
* Makes the item at index contain the data given.
*
* History:
* 16-Apr-1992 beng      The NODATA listbox case
\***************************************************************************/

int LBSetItemData(
    PLBIV plb,
    int index,
    LONG_PTR data)
{
    LPSTR lpItemText;

    /*
     * v-ronaar: fix bug #25865, don't allow negative indices!
     */
    if ((index != -1) && ((UINT) index >= (UINT) plb->cMac)) {
        RIPERR1(ERROR_INVALID_INDEX, RIP_WARNING, "LBSetItemData with invalid index %x", index);
        return LB_ERR;
    }

    /*
     * No-data listboxes just ignore all LB_SETITEMDATA calls
     */
    if (!plb->fHasData) {
        return TRUE;
    }

    lpItemText = (LPSTR)plb->rgpch;

    if (index == -1) {

        /*
         * index == -1 means set the data to all the items
         */
        if (plb->fHasStrings) {
            for (index = 0; index < plb->cMac; index++) {

                ((lpLBItem)lpItemText)->itemData = data;
                lpItemText += sizeof(LBItem);
            }
        } else {
            for (index = 0; index < plb->cMac; index++) {

                ((lpLBODItem)lpItemText)->itemData = data;
                lpItemText += sizeof(LBODItem);
            }
        }
        return TRUE;
    }

    if (plb->fHasStrings) {

        lpItemText = (LPSTR)(lpItemText + (index * sizeof(LBItem)));
        ((lpLBItem)lpItemText)->itemData = data;
    } else {

        lpItemText = (LPSTR)(lpItemText + (index * sizeof(LBODItem)));
        ((lpLBODItem)lpItemText)->itemData = data;
    }
    return TRUE;
}

/***************************************************************************\
* xxxCheckRedraw
*
* History:
\***************************************************************************/

void xxxCheckRedraw(
    PLBIV plb,
    BOOL fConditional,
    INT sItem)
{
    CheckLock(plb->spwnd);

    if (fConditional && plb->cMac &&
            (sItem > (plb->iTop + CItemInWindow(plb, TRUE))))
        return;

    /*
     * Don't do anything if the parent is not visible.
     */
    xxxLBInvalidateRect(plb, (LPRECT)NULL, TRUE);
}


/***************************************************************************\
* xxxCaretDestroy
*
* History:
\***************************************************************************/

void xxxCaretDestroy(
    PLBIV plb)
{
    CheckLock(plb->spwnd);

    /*
     * We're losing the focus.  Act like up clicks are happening so we release
     * capture, set the current selection, notify the parent, etc.
     */
    if (plb->fCaptured)

        /*
         * If we have the capture and we lost the focus, that means we already
         * changed the selection and we have to notify also the parent about
         * this. So we need to add also the LBUP_SUCCESS flag in this case.
         */

        xxxLBButtonUp(plb, LBUP_RELEASECAPTURE | LBUP_NOTIFY |
            (plb->fMouseDown ? LBUP_SUCCESS : 0));

    if (plb->fAddSelMode) {

        /*
         * Switch off the Caret blinking
         */
        NtUserKillTimer(HWq(plb->spwnd), IDSYS_CARET);

        /*
         * Make sure the caret goes away
         */
        xxxLBSetCaret(plb, FALSE);
        plb->fAddSelMode = FALSE;
    }

    plb->fCaret = FALSE;
}


/***************************************************************************\
* xxxLbSetSel
*
* History:
\***************************************************************************/

LONG xxxLBSetSel(
    PLBIV plb,
    BOOL fSelect,  /* New state to set selection to */
    INT iSel)
{
    INT sItem;
    RECT rc;
    UINT uEvent = 0;

    CheckLock(plb->spwnd);

    /*
    * Bug 17656. WinZip's accelerator key for 'DeSelect All' sends a LB_SETSEL
    * message with lparam = 0x0000ffff instead of 0xffffffff(-1). If iSel
    * is equal to  0x0000ffff and there are less than 0xffff elements in the
    * list we set iSel equal to 0xffffffff.
    */
    if ((iSel == (UINT)0xffff) && (iSel >= plb->cMac)) {
        iSel = -1;
        RIPMSG0(RIP_WARNING, "Sign extending iSel=0xffff to 0xffffffff");
    }


    if ((plb->wMultiple == SINGLESEL) || (iSel != -1 && iSel >= plb->cMac)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING,
                "xxxLBSetSel:Invalid iSel or SINGLESEL listbox");
        return LB_ERR;
    }

    xxxLBSetCaret(plb, FALSE);

    if (iSel == -1/*(INT)0xffff*/) {

        /*
         * Set/clear selection from all items if -1
         */
        for (sItem = 0; sItem < plb->cMac; sItem++) {
            if (IsSelected(plb, sItem, SELONLY) != fSelect) {
                SetSelected(plb, sItem, fSelect, HILITEANDSEL);
                if (LBGetItemRect(plb, sItem, &rc)) {
                    xxxLBInvalidateRect(plb, &rc, FALSE);
                }
            }
        }
        xxxLBSetCaret(plb, TRUE);
        uEvent = EVENT_OBJECT_SELECTIONWITHIN;
    } else {
        if (fSelect) {

            /*
             * Check if the item if fully hidden and scroll it into view if it
             * is.  Note that we don't want to scroll partially visible items
             * into full view because this breaks the shell...
             */
            xxxInsureVisible(plb, iSel, TRUE);
            plb->iSelBase = plb->iSel = iSel;

            plb->iMouseDown = plb->iLastMouseMove = iSel;
            uEvent = EVENT_OBJECT_FOCUS;
        } else {
            uEvent = EVENT_OBJECT_SELECTIONREMOVE;
        }
        SetSelected(plb, iSel, fSelect, HILITEANDSEL);

        /*
         * Note that we set the caret on bit directly so that we avoid flicker
         * when drawing this item.  ie.  We turn on the caret, redraw the item and
         * turn it back on again.
         */
        if (!fSelect && plb->iSelBase != iSel) {
            xxxLBSetCaret(plb, TRUE);
        } else if (plb->fCaret) {
            plb->fCaretOn = TRUE;
        }

        if (LBGetItemRect(plb, iSel, &rc)) {
            xxxLBInvalidateRect(plb, &rc, FALSE);
        }
    }

    /*
     * We need to send this event even if the listbox isn't visible. See
     * bug #88548. Also see 355612.
     */
    if (_IsWindowVisible(plb->spwnd) || (GetFocus() == HWq(plb->spwnd))) {
        if (uEvent == EVENT_OBJECT_FOCUS) {
            LBEvent(plb, uEvent, plb->iSelBase);
            uEvent = EVENT_OBJECT_SELECTION;
        }
        LBEvent(plb, uEvent, iSel);
    }

    return 0;
}


/***************************************************************************\
* xxxLBoxDrawItem
*
* This fills the draw item struct with some constant data for the given
* item.  The caller will only have to modify a small part of this data
* for specific needs.
*
* History:
* 16-Apr-1992 beng      The NODATA case
\***************************************************************************/

void xxxLBoxDrawItem(
    PLBIV plb,
    INT item,
    UINT itemAction,
    UINT itemState,
    LPRECT lprect)
{
    DRAWITEMSTRUCT dis;
    TL tlpwndParent;

    CheckLock(plb->spwnd);

    /*
     * Fill the DRAWITEMSTRUCT with the unchanging constants
     */

    dis.CtlType = ODT_LISTBOX;
    dis.CtlID = PtrToUlong(plb->spwnd->spmenu);

    /*
     * Use -1 if an invalid item number is being used.  This is so that the app
     * can detect if it should draw the caret (which indicates the lb has the
     * focus) in an empty listbox
     */
    dis.itemID = (UINT)(item < plb->cMac ? item : -1);
    dis.itemAction = itemAction;
    dis.hwndItem = HWq(plb->spwnd);
    dis.hDC = plb->hdc;
    dis.itemState = itemState |
            (UINT)(TestWF(plb->spwnd, WFDISABLED) ? ODS_DISABLED : 0);

    if (TestWF(plb->spwnd, WEFPUIFOCUSHIDDEN)) {
        dis.itemState |= ODS_NOFOCUSRECT;
    }
    if (TestWF(plb->spwnd, WEFPUIACCELHIDDEN)) {
        dis.itemState |= ODS_NOACCEL;
    }

    /*
     * Set the app supplied data
     */
    if (!plb->cMac || !plb->fHasData) {

        /*
         * If no strings or no items, just use 0 for data.  This is so that we
         * can display a caret when there are no items in the listbox.
         *
         * Lazy-eval listboxes of course have no data to pass - only itemID.
         */
        dis.itemData = 0L;
    } else {
        dis.itemData = LBGetItemData(plb, item);
    }

    CopyRect(&dis.rcItem, lprect);

    /*
     * Set the window origin to the horizontal scroll position.  This is so that
     * text can always be drawn at 0,0 and the view region will only start at
     * the horizontal scroll offset. We pass this as wParam
     */
    /*
     * Note:  Only pass the itemID in wParam for 3.1 or newer apps.  We break
     * ccMail otherwise.
     */

    ThreadLock(plb->spwndParent, &tlpwndParent);
    SendMessage(HW(plb->spwndParent), WM_DRAWITEM,
            TestWF(plb->spwndParent, WFWIN31COMPAT) ? dis.CtlID : 0,
            (LPARAM)&dis);
    ThreadUnlock(&tlpwndParent);
}


/***************************************************************************\
* xxxLBBlockHilite
*
*       In Extended selection mode for multiselection listboxes, when
*   mouse is draged to a new position, the range being marked should be
*   properly sized(parts of which will be highlighted/dehighlighted).
*   NOTE: This routine assumes that iSelFromPt and LasMouseMove are not
*          equal because only in that case this needs to be called;
*   NOTE: This routine calculates the region whose display attribute is to
*          be changed in an optimised way. Instead of de-highlighting the
*          the old range completely and highlight the new range, it omits
*          the regions that overlap and repaints only the non-pverlapping
*          area.
*   fKeyBoard = TRUE if this is called for Keyboard interface
*                FALSE if called from Mouse interface routines
*
* History:
\***************************************************************************/

void xxxLBBlockHilite(
    PLBIV plb,
    INT iSelFromPt,
    BOOL fKeyBoard)
{
    INT sCurPosOffset;
    INT sLastPosOffset;
    INT sHiliteOrSel;
    BOOL fUseSelStatus;
    BOOL DeHiliteStatus;

    CheckLock(plb->spwnd);

    if (fKeyBoard) {

        /*
         * Set both Hilite and Selection states
         */
        sHiliteOrSel = HILITEANDSEL;

        /*
         * Do not use the Selection state while de-hiliting
         */
        fUseSelStatus = FALSE;
        DeHiliteStatus = FALSE;
    } else {

        /*
         * Set/Reset only the Hilite state
         */
        sHiliteOrSel = HILITEONLY;

        /*
         * Use the selection state for de-hilighting
         */
        fUseSelStatus = TRUE;
        DeHiliteStatus = plb->fNewItemState;
    }



    /*
     * The idea of the routine is to :
     *          1.  De-hilite the old range (iMouseDown to iLastMouseDown)  and
     *          2.  Hilite the new range (iMouseDwon to iSelFromPt)
     */

    /*
     * Offset of current mouse position from the anchor point
     */
    sCurPosOffset = plb->iMouseDown - iSelFromPt;

    /*
     * Offset of last mouse position from the anchor point
     */
    sLastPosOffset = plb->iMouseDown - plb->iLastMouseMove;

    /*
     * Check if both current position and last position lie on the same
     * side of the anchor point.
     */
    if ((sCurPosOffset * sLastPosOffset) >= 0) {

        /*
         * Yes they are on the same side; So, highlight/dehighlight only
         * the difference.
         */
        if (abs(sCurPosOffset) > abs(sLastPosOffset)) {
            xxxAlterHilite(plb, plb->iLastMouseMove, iSelFromPt,
                    plb->fNewItemState, sHiliteOrSel, FALSE);
        } else {
            xxxAlterHilite(plb, iSelFromPt, plb->iLastMouseMove, DeHiliteStatus,
                    sHiliteOrSel, fUseSelStatus);
        }
    } else {
        xxxAlterHilite(plb, plb->iMouseDown, plb->iLastMouseMove,
                DeHiliteStatus, sHiliteOrSel, fUseSelStatus);
        xxxAlterHilite(plb, plb->iMouseDown, iSelFromPt,
                plb->fNewItemState, sHiliteOrSel, FALSE);
    }
}


/***************************************************************************\
* xxxAlterHilite
*
* Changes the hilite state of (i..j] (ie. excludes i, includes j in case
* you've forgotten this notation) to fHilite. It inverts this changes
* the hilite state.
*
*  OpFlags:  HILITEONLY      Only change the display state of the items
*            SELONLY         Only Change the selection state of the items
*            HILITEANDSELECT Do both.
*  fHilite:
*            HILITE/TRUE
*            DEHILITE/FALSE
*  fSelStatus:
*            if TRUE, use the selection state of the item to hilite/dehilite
*            if FALSE, use the fHilite parameter to hilite/dehilite
*
* History:
\***************************************************************************/

void xxxAlterHilite(
    PLBIV plb,
    INT i,
    INT j,
    BOOL fHilite,
    INT OpFlags,
    BOOL fSelStatus)
{
    INT low;
    INT high;
    INT sLastInWindow;
    BOOL fCaretOn;
    BOOL fSelected;

    CheckLock(plb->spwnd);

    sLastInWindow = plb->iTop + CItemInWindow(plb, TRUE);
    sLastInWindow = min(sLastInWindow, plb->cMac - 1);
    high = max(i, j) + 1;

    if (fCaretOn = plb->fCaretOn) {
        xxxLBSetCaret(plb, FALSE);
    }

    for (low = min(i, j); low < high; low++) {
        if (low != i) {
            if (OpFlags & HILITEONLY) {
                if (fSelStatus) {
                    fSelected = IsSelected(plb, low, SELONLY);
                } else {
                    fSelected = fHilite;
                }
                if (IsSelected(plb, low, HILITEONLY) != fSelected) {
                    if (plb->iTop <= low && low <= sLastInWindow) {

                        /*
                         * Invert the item only if it is visible
                         */
                        xxxInvertLBItem(plb, low, fSelected);
                    }
                    SetSelected(plb, low, fSelected, HILITEONLY);
                }
            }

            if (OpFlags & SELONLY) {
                SetSelected(plb, low, fHilite, SELONLY);
            }
        }
    }

    if (fCaretOn) {
        xxxLBSetCaret(plb, TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\lboxrare.c ===
/**************************** Module Header ********************************\
* Module Name: lboxrare.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Infrequently Used List Box Routines
*
* History:
* ??-???-???? ianja    Ported from Win 3.0 sources
* 14-Feb-1991 mikeke   Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

extern LOOKASIDE ListboxLookaside;

/***************************************************************************\
* LBSetCItemFullMax
*
* History:
* 03-04-92 JimA             Ported from Win 3.1 sources.
\***************************************************************************/

void LBSetCItemFullMax(
    PLBIV plb)
{
    if (plb->OwnerDraw != OWNERDRAWVAR) {
        plb->cItemFullMax = CItemInWindow(plb, FALSE);
    } else if (plb->cMac < 2) {
        plb->cItemFullMax = 1;
    } else {
        int     height;
        RECT    rect;
        int     i;
        int     j = 0;

        _GetClientRect(plb->spwnd, &rect);
        height = rect.bottom;

        plb->cItemFullMax = 0;
        for (i = plb->cMac - 1; i >= 0; i--, j++) {
            height -= LBGetVariableHeightItemHeight(plb, i);

            if (height < 0) {
                plb->cItemFullMax = j;
                break;
            }
        }
        if (!plb->cItemFullMax)
            plb->cItemFullMax = j;
    }
}

/***************************************************************************\
* xxxCreateLBox
*
* History:
* 16-Apr-1992 beng      Added LBS_NODATA
\***************************************************************************/

LONG xxxLBCreate(
    PLBIV plb, PWND pwnd, LPCREATESTRUCT lpcs)
{
    UINT style;
    MEASUREITEMSTRUCT measureItemStruct;
    TL tlpwndParent;
    HDC hdc;

    /*
     * Once we make it here, nobody can change the ownerdraw style bits
     * by calling SetWindowLong. The window style must match the flags in plb
     *
     */
    plb->fInitialized = TRUE;

    style = pwnd->style;

    /*
     * Compatibility hack.
     */
    if (pwnd->spwndParent == NULL)
        Lock(&(plb->spwndParent), _GetDesktopWindow());
    else
        Lock(&(plb->spwndParent), REBASEPWND(pwnd, spwndParent));

    /*
     * Break out the style bits
     */
    plb->fRedraw = ((style & LBS_NOREDRAW) == 0);
    plb->fDeferUpdate = FALSE;
    plb->fNotify = (UINT)((style & LBS_NOTIFY) != 0);
    plb->fVertBar = ((style & WS_VSCROLL) != 0);
    plb->fHorzBar = ((style & WS_HSCROLL) != 0);

    if (!TestWF(pwnd, WFWIN40COMPAT)) {
        // for 3.x apps, if either scroll bar was specified, the app got BOTH
        if (plb->fVertBar || plb->fHorzBar)
            plb->fVertBar = plb->fHorzBar = TRUE;
    }

    plb->fRtoLReading = (TestWF(pwnd, WEFRTLREADING) != 0);
    plb->fRightAlign  = (TestWF(pwnd, WEFRIGHT) != 0);
    plb->fDisableNoScroll = ((style & LBS_DISABLENOSCROLL) != 0);

    plb->fSmoothScroll = TRUE;

    /*
     * LBS_NOSEL gets priority over any other selection style.  Next highest
     * priority goes to LBS_EXTENDEDSEL. Then LBS_MULTIPLESEL.
     */
    if (TestWF(pwnd, WFWIN40COMPAT) && (style & LBS_NOSEL)) {
        plb->wMultiple = SINGLESEL;
        plb->fNoSel = TRUE;
    } else if (style & LBS_EXTENDEDSEL) {
        plb->wMultiple = EXTENDEDSEL;
    } else {
        plb->wMultiple = (UINT)((style & LBS_MULTIPLESEL) ? MULTIPLESEL : SINGLESEL);
    }

    plb->fNoIntegralHeight = ((style & LBS_NOINTEGRALHEIGHT) != 0);
    plb->fWantKeyboardInput = ((style & LBS_WANTKEYBOARDINPUT) != 0);
    plb->fUseTabStops = ((style & LBS_USETABSTOPS) != 0);
    if (plb->fUseTabStops) {

        /*
         * Set tab stops every <default> dialog units.
         */
        LBSetTabStops(plb, 0, NULL);
    }
    plb->fMultiColumn = ((style & LBS_MULTICOLUMN) != 0);
    plb->fHasStrings = TRUE;
    plb->iLastSelection = -1;
    plb->iMouseDown = -1;  /* Anchor point for multi selection */
    plb->iLastMouseMove = -1;

    /*
     * Get ownerdraw style bits
     */
    if ((style & LBS_OWNERDRAWFIXED)) {
        plb->OwnerDraw = OWNERDRAWFIXED;
    } else if ((style & LBS_OWNERDRAWVARIABLE) && !plb->fMultiColumn) {
        plb->OwnerDraw = OWNERDRAWVAR;

        /*
         * Integral height makes no sense with var height owner draw
         */
        plb->fNoIntegralHeight = TRUE;
    }

    if (plb->OwnerDraw && !(style & LBS_HASSTRINGS)) {

        /*
         * If owner draw, do they want the listbox to maintain strings?
         */
        plb->fHasStrings = FALSE;
    }

    /*
     * If user specifies sort and not hasstrings, then we will send
     * WM_COMPAREITEM messages to the parent.
     */
    plb->fSort = ((style & LBS_SORT) != 0);

    /*
     * "No data" lazy-eval listbox mandates certain other style settings
     */
    plb->fHasData = TRUE;

    if (style & LBS_NODATA) {
        if (plb->OwnerDraw != OWNERDRAWFIXED || plb->fSort || plb->fHasStrings) {
            RIPERR0(ERROR_INVALID_FLAGS, RIP_WARNING,
                 "NODATA listbox must be OWNERDRAWFIXED, w/o SORT or HASSTRINGS");
        } else {
            plb->fHasData = FALSE;
        }
    }

    plb->dwLocaleId = GetThreadLocale();

    /*
     * Check if this is part of a combo box
     */
    if ((style & LBS_COMBOBOX) != 0) {

        /*
         * Get the pcbox structure contained in the parent window's extra data
         * pointer.  Check cbwndExtra to ensure compatibility with SQL windows.
         */
        if (plb->spwndParent->cbwndExtra != 0)
            plb->pcbox = ((PCOMBOWND)(plb->spwndParent))->pcbox;
    }

    /*
     * No need to set these to 0 since that was done for us when we Alloced
     * the PLBIV.
     */

    /*
     * plb->rgpch       = (PBYTE)0;
     */

    /*
     * plb->iSelBase    = plb->iTop = 0;
     */

    /*
     * plb->fMouseDown  = FALSE;
     */

    /*
     * plb->fCaret      = FALSE;
     */

    /*
     * plb->fCaretOn    = FALSE;
     */

    /*
     * plb->maxWidth    = 0;
     */

    plb->iSel = -1;

    plb->hdc        = NULL;

    /*
     * Set the keyboard state so that when the user keyboard clicks he selects
     * an item.
     */
    plb->fNewItemState = TRUE;

    InitHStrings(plb);

    if (plb->fHasStrings && plb->hStrings == NULL) {
        return -1L;
    }

    hdc = NtUserGetDC(HWq(pwnd));
    plb->cxChar = GdiGetCharDimensions(hdc, NULL, &plb->cyChar);
    NtUserReleaseDC(HWq(pwnd), hdc);

    if (plb->cxChar == 0) {
        RIPMSG0(RIP_WARNING, "xxxLBCreate: GdiGetCharDimensions failed");
        plb->cxChar = gpsi->cxSysFontChar;
        plb->cyChar = gpsi->cySysFontChar;
    }

    if (plb->OwnerDraw == OWNERDRAWFIXED) {

        /*
         * Query for item height only if we are fixed height owner draw.  Note
         * that we don't care about an item's width for listboxes.
         */
        measureItemStruct.CtlType = ODT_LISTBOX;
        measureItemStruct.CtlID = PtrToUlong(pwnd->spmenu);

        /*
         * System font height is default height
         */
        measureItemStruct.itemHeight = plb->cyChar;
        measureItemStruct.itemWidth = 0;
        measureItemStruct.itemData = 0;

        /*
         * IanJa: #ifndef WIN16 (32-bit Windows), plb->id gets extended
         * to LONG wParam automatically by the compiler
         */
        ThreadLock(plb->spwndParent, &tlpwndParent);
        SendMessage(HW(plb->spwndParent), WM_MEASUREITEM,
                measureItemStruct.CtlID,
                (LPARAM)&measureItemStruct);
        ThreadUnlock(&tlpwndParent);

        /*
         * Use default height if given 0.  This prevents any possible future
         * div-by-zero errors.
         */
        if (measureItemStruct.itemHeight)
            plb->cyChar = measureItemStruct.itemHeight;


        if (plb->fMultiColumn) {

            /*
             * Get default column width from measure items struct if we are a
             * multicolumn listbox.
             */
            plb->cxColumn = measureItemStruct.itemWidth;
        }
    } else if (plb->OwnerDraw == OWNERDRAWVAR)
        plb->cyChar = 0;


    if (plb->fMultiColumn) {

        /*
         * Set these default values till we get the WM_SIZE message and we
         * calculate them properly.  This is because some people create a
         * 0 width/height listbox and size it later.  We don't want to have
         * problems with invalid values in these fields
         */
        if (plb->cxColumn <= 0)
            plb->cxColumn = 15 * plb->cxChar;
        plb->numberOfColumns = plb->itemsPerColumn = 1;
    }

    LBSetCItemFullMax(plb);

    // Don't do this for 4.0 apps.  It'll make everyone's lives easier and
    // fix the anomaly that a combo & list created the same width end up
    // different when all is done.
    // B#1520

    if (!TestWF(pwnd, WFWIN40COMPAT)) {
        plb->fIgnoreSizeMsg = TRUE;
        NtUserMoveWindow(HWq(pwnd),
             lpcs->x - SYSMET(CXBORDER),
             lpcs->y - SYSMET(CYBORDER),
             lpcs->cx + SYSMET(CXEDGE),
             lpcs->cy + SYSMET(CYEDGE),
             FALSE);
        plb->fIgnoreSizeMsg = FALSE;
    }

    if (!plb->fNoIntegralHeight) {

        /*
         * Send a message to ourselves to resize the listbox to an integral
         * height.  We need to do it this way because at create time we are all
         * mucked up with window rects etc...
         * IanJa: #ifndef WIN16 (32-bit Windows), wParam 0 gets extended
         * to wParam 0L automatically by the compiler.
         */
        PostMessage(HWq(pwnd), WM_SIZE, 0, 0L);
    }

    return 1L;
}

/***************************************************************************\
* xxxLBoxDoDeleteItems
*
* Send DELETEITEM message for all the items in the ownerdraw listbox.
*
* History:
* 16-Apr-1992 beng          Nodata case
\***************************************************************************/

void xxxLBoxDoDeleteItems(
    PLBIV plb)
{
    INT sItem;

    CheckLock(plb->spwnd);

    /*
     * Send WM_DELETEITEM message for ownerdraw listboxes which are
     * being deleted.  (NODATA listboxes don't send such, though.)
     */
    if (plb->OwnerDraw && plb->cMac && plb->fHasData) {
        for (sItem = plb->cMac - 1; sItem >= 0; sItem--) {
            xxxLBoxDeleteItem(plb, sItem);
        }
    }
}


/***************************************************************************\
* xxxDestroyLBox
*
* History:
\***************************************************************************/

void xxxDestroyLBox(
    PLBIV pLBIV,
    PWND pwnd)
{
    PWND pwndParent;

    CheckLock(pwnd);

    if (pLBIV != NULL) {
        CheckLock(pLBIV->spwnd);

        /*
         * If ownerdraw, send deleteitem messages to parent
         */
        xxxLBoxDoDeleteItems(pLBIV);

        if (pLBIV->rgpch != NULL) {
            UserLocalFree(pLBIV->rgpch);
            pLBIV->rgpch = NULL;
        }

        if (pLBIV->hStrings != NULL) {
            UserLocalFree(pLBIV->hStrings);
            pLBIV->hStrings = NULL;
        }

        if (pLBIV->iTabPixelPositions != NULL) {
            UserLocalFree((HANDLE)pLBIV->iTabPixelPositions);
            pLBIV->iTabPixelPositions = NULL;
        }

        Unlock(&pLBIV->spwnd);
        Unlock(&pLBIV->spwndParent);

        if (pLBIV->pszTypeSearch) {
            UserLocalFree(pLBIV->pszTypeSearch);
        }

        FreeLookasideEntry(&ListboxLookaside, pLBIV);
    }

    /*
     * Set the window's fnid status so that we can ignore rogue messages
     */
    NtUserSetWindowFNID(HWq(pwnd), FNID_CLEANEDUP_BIT);

    /*
     * If we're part of a combo box, let it know we're gone
     */
    pwndParent = REBASEPWND(pwnd, spwndParent);
    if (pwndParent && GETFNID(pwndParent) == FNID_COMBOBOX) {
        ComboBoxWndProcWorker(pwndParent, WM_PARENTNOTIFY,
                MAKELONG(WM_DESTROY, PTR_TO_ID(pwnd->spmenu)), (LPARAM)HWq(pwnd), FALSE);
    }
}


/***************************************************************************\
* xxxLBSetFont
*
* History:
\***************************************************************************/

void xxxLBSetFont(
    PLBIV plb,
    HANDLE hFont,
    BOOL fRedraw)
{
    HDC     hdc;
    HANDLE  hOldFont = NULL;
    int     iHeight;

    CheckLock(plb->spwnd);

    plb->hFont = hFont;

    hdc = NtUserGetDC(HWq(plb->spwnd));

    if (hFont) {
        hOldFont = SelectObject(hdc, hFont);
        if (!hOldFont) {
            plb->hFont = NULL;
        }
    }

    plb->cxChar = GdiGetCharDimensions(hdc, NULL, &iHeight);
    if (plb->cxChar == 0) {
        RIPMSG0(RIP_WARNING, "xxxLBSetFont: GdiGetCharDimensions failed");
        plb->cxChar = gpsi->cxSysFontChar;
        iHeight = gpsi->cySysFontChar;
    }


    if (!plb->OwnerDraw && (plb->cyChar != iHeight)) {

        /*
         * We don't want to mess up the cyChar height for owner draw listboxes
         * so don't do this.
         */
        plb->cyChar = iHeight;

        /*
         * Only resize the listbox for 4.0 dudes, or combo dropdowns.
         * Macromedia Director 4.0 GP-faults otherwise.
         */
        if (!plb->fNoIntegralHeight &&
                (plb->pcbox || TestWF(plb->spwnd, WFWIN40COMPAT))) {
            xxxLBSize(plb,
                plb->spwnd->rcClient.right  - plb->spwnd->rcClient.left,
                plb->spwnd->rcClient.bottom - plb->spwnd->rcClient.top);
        }
    }

    if (hOldFont) {
        SelectObject(hdc, hOldFont);
    }

    /*
     * IanJa: was ReleaseDC(hwnd, hdc);
     */
    NtUserReleaseDC(HWq(plb->spwnd), hdc);

    if (plb->fMultiColumn) {
        LBCalcItemRowsAndColumns(plb);
    }

    LBSetCItemFullMax(plb);

    if (fRedraw)
        xxxCheckRedraw(plb, FALSE, 0);
}


/***************************************************************************\
* xxxLBSize
*
* History:
\***************************************************************************/

void xxxLBSize(
    PLBIV plb,
    INT cx,
    INT cy)
{
    RECT rc;
    int iTopOld;
    BOOL fSizedSave;

    CheckLock(plb->spwnd);

    if (!plb->fNoIntegralHeight) {
        int cBdrs = GetWindowBorders(plb->spwnd->style, plb->spwnd->ExStyle, TRUE, TRUE);

        CopyInflateRect(&rc, KPRECT_TO_PRECT(&plb->spwnd->rcWindow), 0, -cBdrs * SYSMET(CYBORDER));

        // Size the listbox to fit an integral # of items in its client
        if ((rc.bottom - rc.top) % plb->cyChar) {
            int iItems = (rc.bottom - rc.top);

            // B#2285 - If its a 3.1 app its SetWindowPos needs
            // to be window based dimensions not Client !
            // this crunches Money into using a scroll bar

            if ( ! TestWF( plb->spwnd, WFWIN40COMPAT ) )
                iItems += (cBdrs * SYSMET(CYEDGE)); // so add it back in

            iItems /= plb->cyChar;

            NtUserSetWindowPos(HWq(plb->spwnd), HWND_TOP, 0, 0, rc.right - rc.left,
                    iItems * plb->cyChar + (SYSMET(CYEDGE) * cBdrs),
                    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);

            /*
             * Changing the size causes us to recurse.  Upon return
             * the state is where it should be and nothing further
             * needs to be done.
             */
            return;
        }
    }

    if (plb->fMultiColumn) {

        /*
         * Compute the number of DISPLAYABLE rows and columns in the listbox
         */
        LBCalcItemRowsAndColumns(plb);
    } else {

        /*
         * Adjust the current horizontal position to eliminate as much
         * empty space as possible from the right side of the items.
         */
        _GetClientRect(plb->spwnd, &rc);
        if ((plb->maxWidth - plb->xOrigin) < (rc.right - rc.left))
            plb->xOrigin = max(0, plb->maxWidth - (rc.right - rc.left));
    }

    LBSetCItemFullMax(plb);

    /*
     * Adjust the top item in the listbox to eliminate as much empty space
     * after the last item as possible
     * (fix for bugs #8490 & #3836)
     */
    iTopOld = plb->iTop;
    fSizedSave = plb->fSized;
    plb->fSized = FALSE;
    xxxNewITop(plb, plb->iTop);

    /*
     * If changing the top item index caused a resize, there is no
     * more work to be done here.
     */
    if (plb->fSized)
        return;
    plb->fSized = fSizedSave;

    if (IsLBoxVisible(plb)) {
        /*
         * This code no longer blows because it's fixed right!!!  We could
         * optimize the fMultiColumn case with some more code to figure out
         * if we really need to invalidate the whole thing but note that some
         * 3.0 apps depend on this extra invalidation (AMIPRO 2.0, bug 14620)
         *
         * For 3.1 apps, we blow off the invalidaterect in the case where
         * cx and cy are 0 because this happens during the processing of
         * the posted WM_SIZE message when we are created which would otherwise
         * cause us to flash.
         */
        if ((plb->fMultiColumn && !(cx == 0 && cy == 0)) ||
                plb->iTop != iTopOld)
            NtUserInvalidateRect(HWq(plb->spwnd), NULL, TRUE);
        else if (plb->iSelBase >= 0) {

            /*
             * Invalidate the item with the caret so that if the listbox
             * grows horizontally, we redraw it properly.
             */
            LBGetItemRect(plb, plb->iSelBase, &rc);
            NtUserInvalidateRect(HWq(plb->spwnd), &rc, FALSE);
        }
    } else if (!plb->fRedraw)
        plb->fDeferUpdate = TRUE;

    /*
     * Send "fake" scroll bar messages to update the scroll positions since we
     * changed size.
     */
    if (TestWF(plb->spwnd, WFVSCROLL)) {
        xxxLBoxCtlScroll(plb, SB_ENDSCROLL, 0);
    }

    /*
     * We count on this to call LBShowHideScrollBars except when plb->cMac == 0!
     */
    xxxLBoxCtlHScroll(plb, SB_ENDSCROLL, 0);

    /*
     * Show/hide scroll bars depending on how much stuff is visible...
     *
     * Note:  Now we only call this guy when cMac == 0, because it is
     * called inside the LBoxCtlHScroll with SB_ENDSCROLL otherwise.
     */
    if (plb->cMac == 0)
        xxxLBShowHideScrollBars(plb);
}


/***************************************************************************\
* LBSetTabStops
*
* Sets the tab stops for this listbox. Returns TRUE if successful else FALSE.
*
* History:
\***************************************************************************/

BOOL LBSetTabStops(
    PLBIV plb,
    INT count,
    LPINT lptabstops)
{
    PINT ptabs;

    if (!plb->fUseTabStops) {
        RIPERR0(ERROR_LB_WITHOUT_TABSTOPS, RIP_VERBOSE, "");
        return FALSE;
    }

    if (count) {
        /*
         * Allocate memory for the tab stops.  The first byte in the
         * plb->iTabPixelPositions array will contain a count of the number
         * of tab stop positions we have.
         */
        ptabs = (LPINT)UserLocalAlloc(HEAP_ZERO_MEMORY, (count + 1) * sizeof(int));
        if (ptabs == NULL)
            return FALSE;

        if (plb->iTabPixelPositions != NULL)
            UserLocalFree(plb->iTabPixelPositions);
        plb->iTabPixelPositions = ptabs;

        /*
         * Set the count of tab stops
         */
        *ptabs++ = count;

        for (; count > 0; count--) {

            /*
             * Convert the dialog unit tabstops into pixel position tab stops.
             */
            *ptabs++ = MultDiv(*lptabstops, plb->cxChar, 4);
            lptabstops++;
        }
    } else {

        /*
         * Set default 8 system font ave char width tabs.  So free the memory
         * associated with the tab stop list.
         */
        if (plb->iTabPixelPositions != NULL) {
            UserLocalFree((HANDLE)plb->iTabPixelPositions);
            plb->iTabPixelPositions = NULL;
        }
    }

    return TRUE;
}


/***************************************************************************\
* InitHStrings
*
* History:
\***************************************************************************/

void InitHStrings(
    PLBIV plb)
{
    if (plb->fHasStrings) {
        plb->ichAlloc = 0;
        plb->cchStrings = 0;
        plb->hStrings = UserLocalAlloc(0, 0L);
    }
}


/***************************************************************************\
* LBDropObjectHandler
*
* Handles a WM_DROPITEM message on this listbox
*
* History:
\***************************************************************************/

void LBDropObjectHandler(
    PLBIV plb,
    PDROPSTRUCT pds)
{
    LONG mouseSel;

    if (ISelFromPt(plb, pds->ptDrop, &mouseSel)) {

        /*
         * User dropped in empty space at bottom of listbox
         */
        pds->dwControlData = (DWORD)-1L;
    } else {
        pds->dwControlData = mouseSel;
    }
}


/***************************************************************************\
* LBGetSetItemHeightHandler()
*
* Sets/Gets the height associated with each item.  For non ownerdraw
* and fixed height ownerdraw, the item number is ignored.
*
* History:
\***************************************************************************/

int LBGetSetItemHeightHandler(
    PLBIV plb,
    UINT message,
    int item,
    UINT height)
{
    if (message == LB_GETITEMHEIGHT) {
        /*
         * All items are same height for non ownerdraw and for fixed height
         * ownerdraw.
         */
        if (plb->OwnerDraw != OWNERDRAWVAR)
            return plb->cyChar;

        if (plb->cMac && item >= plb->cMac) {
            RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
            return LB_ERR;
        }

        return (int)LBGetVariableHeightItemHeight(plb, (INT)item);
    }

    if (!height || height > 255) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"height\" (%ld) to LBGetSetItemHeightHandler",
                height);

        return LB_ERR;
    }

    if (plb->OwnerDraw != OWNERDRAWVAR)
        plb->cyChar = height;
    else {
        if (item < 0 || item >= plb->cMac) {
            RIPERR1(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "Invalid parameter \"item\" (%ld) to LBGetSetItemHeightHandler",
                    item);

            return LB_ERR;
        }

        LBSetVariableHeightItemHeight(plb, (INT)item, (INT)height);
    }

    if (plb->fMultiColumn)
        LBCalcItemRowsAndColumns(plb);

    LBSetCItemFullMax(plb);

    return(0);
}

/*****************************************************************************\
*
* LBEvent()
*
* This is for item focus & selection events in listboxes.
*
\*****************************************************************************/
void LBEvent(PLBIV plb, UINT uEvent, int iItem)
{
    switch (uEvent) {
        case EVENT_OBJECT_SELECTIONREMOVE:
            if (plb->wMultiple != SINGLESEL) {
                break;
            }
            iItem = -1;
            //
            // FALL THRU
            //

        case EVENT_OBJECT_SELECTIONADD:
            if (plb->wMultiple == MULTIPLESEL) {
                uEvent = EVENT_OBJECT_SELECTION;
            }
            break;

        case EVENT_OBJECT_SELECTIONWITHIN:
            iItem = -1;
            break;
    }

    NotifyWinEvent(uEvent, HW(plb->spwnd), OBJID_CLIENT, iItem+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\lboxvar.c ===
/**************************** Module Header ********************************\
* Module Name: lboxvar.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* List Box variable height owner draw routines
*
* History:
* ??-???-???? ianja    Ported from Win 3.0 sources
* 14-Feb-1991 mikeke   Added Revalidation code (None)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* LBGetVariableHeightItemHeight
*
* Returns the height of the given item number. Assumes variable
* height owner draw.
*
* History:
\***************************************************************************/

INT LBGetVariableHeightItemHeight(
    PLBIV plb,
    INT itemNumber)
{
    BYTE itemHeight;
    int offsetHeight;

    if (plb->cMac) {
        if (plb->fHasStrings)
            offsetHeight = plb->cMac * sizeof(LBItem);
        else
            offsetHeight = plb->cMac * sizeof(LBODItem);

        if (plb->wMultiple)
            offsetHeight += plb->cMac;

        offsetHeight += itemNumber;

        itemHeight = *(plb->rgpch+(UINT)offsetHeight);

        return (INT)itemHeight;

    }

    /*
     *Default, we return the height of the system font.  This is so we can draw
     * the focus rect even though there are no items in the listbox.
     */
    return gpsi->cySysFontChar;
}


/***************************************************************************\
* LBSetVariableHeightItemHeight
*
* Sets the height of the given item number. Assumes variable height
* owner draw, a valid item number and valid height.
*
*
* History:
\***************************************************************************/

void LBSetVariableHeightItemHeight(
    PLBIV plb,
    INT itemNumber,
    INT itemHeight)
{
    int offsetHeight;

    if (plb->fHasStrings)
        offsetHeight = plb->cMac * sizeof(LBItem);
    else
        offsetHeight = plb->cMac * sizeof(LBODItem);

    if (plb->wMultiple)
        offsetHeight += plb->cMac;

    offsetHeight += itemNumber;

    *(plb->rgpch + (UINT)offsetHeight) = (BYTE)itemHeight;

}


/***************************************************************************\
* CItemInWindowVarOwnerDraw
*
* Returns the number of items which can fit in a variable height OWNERDRAW
* list box. If fDirection, then we return the number of items which
* fit starting at sTop and going forward (for page down), otherwise, we are
* going backwards (for page up). (Assumes var height ownerdraw) If fPartial,
* then include the partially visible item at the bottom of the listbox.
*
* History:
\***************************************************************************/

INT CItemInWindowVarOwnerDraw(
    PLBIV plb,
    BOOL fPartial)
{
    RECT rect;
    INT sItem;
    INT clientbottom;

    _GetClientRect(plb->spwnd, (LPRECT)&rect);
    clientbottom = rect.bottom;

    /*
     * Find the number of var height ownerdraw items which are visible starting
     * from plb->iTop.
     */
    for (sItem = plb->iTop; sItem < plb->cMac; sItem++) {

        /*
         * Find out if the item is visible or not
         */
        if (!LBGetItemRect(plb, sItem, (LPRECT)&rect)) {

            /*
             * This is the first item which is completely invisible, so return
             * how many items are visible.
             */
            return (sItem - plb->iTop);
        }

        if (!fPartial && rect.bottom > clientbottom) {

            /*
             * If we only want fully visible items, then if this item is
             * visible, we check if the bottom of the item is below the client
             * rect, so we return how many are fully visible.
             */
            return (sItem - plb->iTop - 1);
        }
    }

    /*
     * All the items are visible
     */
    return (plb->cMac - plb->iTop);
}


/***************************************************************************\
* LBPage
*
* For variable height ownerdraw listboxes, calaculates the new iTop we must
* move to when paging (page up/down) through variable height listboxes.
*
* History:
\***************************************************************************/

INT LBPage(
    PLBIV plb,
    INT startItem,
    BOOL fPageForwardDirection)
{
    INT     i;
    INT height;
    RECT    rc;

    if (plb->cMac == 1)
        return(0);

    _GetClientRect(plb->spwnd, &rc);
    height = rc.bottom;
    i = startItem;

    if (fPageForwardDirection) {
        while ((height >= 0) && (i < plb->cMac))
            height -= LBGetVariableHeightItemHeight(plb, i++);

        return((height >= 0) ? plb->cMac - 1 : max(i - 2, startItem + 1));
    } else {
        while ((height >= 0) && (i >= 0))
            height -= LBGetVariableHeightItemHeight(plb, i--);

        return((height >= 0) ? 0 : min(i + 2, startItem - 1));
    }

}


/***************************************************************************\
* LBCalcVarITopScrollAmt
*
* Changing the top most item in the listbox from iTopOld to iTopNew we
* want to calculate the number of pixels to scroll so that we minimize the
* number of items we will redraw.
*
* History:
\***************************************************************************/

INT LBCalcVarITopScrollAmt(
    PLBIV plb,
    INT iTopOld,
    INT iTopNew)
{
    RECT rc;
    RECT rcClient;

    _GetClientRect(plb->spwnd, (LPRECT)&rcClient);

    /*
     * Just optimize redrawing when move +/- 1 item.  We will redraw all items
     * if moving more than 1 item ahead or back.  This is good enough for now.
     */
    if (iTopOld + 1 == iTopNew) {

        /*
         * We are scrolling the current iTop up off the top off the listbox so
         * return a negative number.
         */
        LBGetItemRect(plb, iTopOld, (LPRECT)&rc);
        return (rcClient.top - rc.bottom);
    }

    if (iTopOld - 1 == iTopNew) {

        /*
         * We are scrolling the current iTop down and the previous item is
         * becoming the new iTop so return a positive number.
         */
        LBGetItemRect(plb, iTopNew, (LPRECT)&rc);
        return -rc.top;
    }

    return rcClient.bottom - rcClient.top;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\makefile.inc ===
$(DYNLINK_LIB) : $(DYNLINK_LIBP)

$(O)\$(TARGETNAME).def: ..\$(TARGETNAME).def
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

$(O)\dispcb.c: ..\dispcb.tpl ..\..\inc\$(ALT_PROJECT)\$(O)\cb.lst
    listmung ..\..\inc\$(ALT_PROJECT)\$(O)\cb.lst ..\dispcb.tpl >$@

$(O)\strid.rc $(O)\strid.h $(O)\msg00001.bin: ..\strid.mc
    mc -v -U -r $(O) -h $(O) ..\strid.mc

..\csenda.c: ..\ntcftxt.h
..\csendw.c: ..\ntcftxt.h
..\crecv.c:  ..\..\inc\ntcb.h ..\..\inc\$(ALT_PROJECT)\$(O)\cb.lst ..\..\inc\messages.h
..\clmsg.c: ..\..\inc\messages.h
..\clienta.c: ..\cltxt.h
..\clientw.c: ..\cltxt.h
..\csrstubs.c: ..\..\inc\csrmsg.h
..\ntstubs.c: ..\..\inc\messages.h
..\precomp.h: ..\usercli.h ..\..\inc\user.h ..\..\inc\ntuser.h $(WINDOWS_INC_PATH)\winuserp.h \
              ..\..\inc\$(ALT_PROJECT)\$(O)\cscall.h $(WINCORE_PATH)\w32inc\winuserk.h
..\res.rc: ..\rcscale\truetype.bmp  \
           ..\rc96dpi\truetype.bmp  \
           ..\rc120dpi\truetype.bmp  \
           ..\cursicon\windows.ico  \
           ..\cursicon\warning.ico  \
           ..\cursicon\question.ico  \
           ..\cursicon\error.ico  \
           ..\cursicon\info.ico  \
           ..\cursicon\app.ico  \
           ..\cursicon\help.bmp  \
           ..\cursicon\arrow.cur  \
           ..\cursicon\ibeam.cur  \
           ..\cursicon\wait.cur  \
           ..\cursicon\cross.cur \
           ..\cursicon\uparrow.cur  \
           ..\cursicon\sizenwse.cur  \
           ..\cursicon\sizenesw.cur  \
           ..\cursicon\sizewe.cur  \
           ..\cursicon\sizens.cur  \
           ..\cursicon\sizeall.cur  \
           ..\cursicon\nodrop.cur  \
           ..\cursicon\appstart.cur  \
           ..\cursicon\help.cur  \
           ..\cursicon\nwpen.cur  \
           $(O)\strid.rc  \
           ..\cursicon\autorun.cur \
           ..\cursicon\icon.cur



$(DYNLINK_LIBP) $(DYNLINK_LIBP:.lib=.exp): $(O)\$(TARGETNAMEP).def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(DYNLINK_LIBP) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\$(TARGETNAMEP).def
$(LIBRARY_OBJS)
<<NOKEEP

!IF "$(PRECOMPILED_INCLUDE)" != ""
$(O)\clienta.obj $(O)\csenda.obj :
    nmake PRECOMPILED_INCLUDE= $(O)\$(@F)
!ENDIF

C_DEFINES=$(C_DEFINES) -DPRIVATE=
$(O)\$(TARGETNAMEP).def: $(O)\$(TARGETNAME).def
    $(C_PREPROCESSOR) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\menuc.c ===
/****************************** Module Header ******************************\
* Module Name: menuc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains
*
* History:
* 01-11-93  DavidPe     Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


FUNCLOG3(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, CheckMenuItem, HMENU, hMenu, UINT, uIDCheckItem, UINT, uCheck)
DWORD CheckMenuItem(
    HMENU hMenu,
    UINT uIDCheckItem,
    UINT uCheck)
{
    PMENU pMenu;
    PITEM pItem;

    pMenu = VALIDATEHMENU(hMenu);
    if (pMenu == NULL) {
        return (DWORD)-1;
    }

    /*
     * Get a pointer the the menu item
     */
    if ((pItem = MNLookUpItem(pMenu, uIDCheckItem, (BOOL) (uCheck & MF_BYPOSITION), NULL)) == NULL)
        return (DWORD)-1;

    /*
     * If the item is already in the state we're
     * trying to set, just return.
     */
    if ((pItem->fState & MFS_CHECKED) == (uCheck & MFS_CHECKED)) {
        return pItem->fState & MF_CHECKED;
    }

    return NtUserCheckMenuItem(hMenu, uIDCheckItem, uCheck);
}


FUNCLOG3(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, GetMenuDefaultItem, HMENU, hMenu, UINT, fByPosition, UINT, uFlags)
UINT GetMenuDefaultItem(HMENU hMenu, UINT fByPosition, UINT uFlags)
{
    PMENU pMenu;

    pMenu = VALIDATEHMENU(hMenu);
    if (pMenu == NULL) {
        return (DWORD)-1;
    }

    return _GetMenuDefaultItem(pMenu, (BOOL)fByPosition, uFlags);
}

/***************************************************************************\
* SetMenuItemInfoStruct
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
void SetMenuItemInfoStruct(HMENU hMenu, UINT wFlags, UINT_PTR wIDNew, LPWSTR pwszNew, LPMENUITEMINFO pmii)
{
    PMENU pMenu;
    PITEM pItem;

    UserAssert(sizeof(MENUITEMINFOW) == sizeof(MENUITEMINFOA));

    RtlZeroMemory(pmii, sizeof(*pmii));

    pmii->fMask = MIIM_STATE | MIIM_ID | MIIM_FTYPE;

    /*
     * For compatibility, setting the bitmap drops the string and
     *  viceversa; new apps that want to have sting and bitmaps
     *  must use the MENUITEMINFO APIs
     */
    if (wFlags & MFT_BITMAP) {
        pmii->fMask |= MIIM_BITMAP | MIIM_STRING;
        pmii->hbmpItem = (HBITMAP)pwszNew;
        pmii->dwTypeData  = 0;
    } else if (!(wFlags & MFT_NONSTRING)) {
        pmii->fMask |= MIIM_BITMAP | MIIM_STRING;
        pmii->dwTypeData  = pwszNew;
        pmii->hbmpItem = NULL;
    }

    if (wFlags & MF_POPUP) {
        pmii->fMask |= MIIM_SUBMENU;
        pmii->hSubMenu = (HMENU)wIDNew;
    }

    if (wFlags & MF_OWNERDRAW) {
        pmii->fMask |= MIIM_DATA;
        pmii->dwItemData = (ULONG_PTR) pwszNew;
    }

    pmii->fState = wFlags & MFS_OLDAPI_MASK;
    pmii->fType  = wFlags & MFT_OLDAPI_MASK;
    pMenu = VALIDATEHMENU(hMenu);
    if (pMenu && pMenu->cItems) {
        pItem = &((PITEM)REBASEALWAYS(pMenu, rgItems))[0];
        if (pItem && TestMFT(pItem, MFT_RIGHTORDER)) {
            pmii->fType |= MFT_RIGHTORDER;
        }
    }
    pmii->wID    = (UINT)wIDNew;
}
/***************************************************************************\
* SetMenuItemInfo
*
* History:
*  07-22-96 GerardoB - Added header
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetMenuInfo, HMENU, hMenu, LPCMENUINFO, lpmi)
BOOL SetMenuInfo(HMENU hMenu, LPCMENUINFO lpmi)
{
    if (!ValidateMENUINFO(lpmi, MENUAPI_SET)) {
        return FALSE;
    }

    return NtUserThunkedMenuInfo(hMenu, (LPCMENUINFO)lpmi);
}
/***************************************************************************\
* ChangeMenu
*
* Stub routine for compatibility with version < 3.0
*
* History:
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, ChangeMenuW, HMENU, hMenu, UINT, cmd, LPCWSTR, lpNewItem, UINT, IdItem, UINT, flags)
BOOL ChangeMenuW(
    HMENU hMenu,
    UINT cmd,
    LPCWSTR lpNewItem,
    UINT IdItem,
    UINT flags)
{
    /*
     * These next two statements take care of sleazyness needed for
     * compatability with old changemenu.
     */
    if ((flags & MF_SEPARATOR) && cmd == MFMWFP_OFFMENU && !(flags & MF_CHANGE))
        flags |= MF_APPEND;

    if (lpNewItem == NULL)
        flags |= MF_SEPARATOR;



    /*
     * MUST be MF_BYPOSITION for Win2.x compatability.
     */
    if (flags & MF_REMOVE)
        return(NtUserRemoveMenu(hMenu, cmd,
                (DWORD)((flags & ~MF_REMOVE) | MF_BYPOSITION)));

    if (flags & MF_DELETE)
        return(NtUserDeleteMenu(hMenu, cmd, (DWORD)(flags & ~MF_DELETE)));

    if (flags & MF_CHANGE)
        return(ModifyMenuW(hMenu, cmd, (DWORD)((flags & ~MF_CHANGE) &
                (0x07F | MF_HELP | MF_BYPOSITION | MF_BYCOMMAND |
                MF_SEPARATOR)), IdItem, lpNewItem));

    if (flags & MF_APPEND)
        return(AppendMenuW(hMenu, (UINT)(flags & ~MF_APPEND),
            IdItem, lpNewItem));

    /*
     * Default is insert
     */
    return(InsertMenuW(hMenu, cmd, (DWORD)(flags & ~MF_INSERT),
            IdItem, lpNewItem));
}


FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, ChangeMenuA, HMENU, hMenu, UINT, cmd, LPCSTR, lpNewItem, UINT, IdItem, UINT, flags)
BOOL ChangeMenuA(
    HMENU hMenu,
    UINT cmd,
    LPCSTR lpNewItem,
    UINT IdItem,
    UINT flags)
{
    /*
     * These next two statements take care of sleazyness needed for
     * compatability with old changemenu.
     */
    if ((flags & MF_SEPARATOR) && cmd == MFMWFP_OFFMENU && !(flags & MF_CHANGE))
        flags |= MF_APPEND;

    if (lpNewItem == NULL)
        flags |= MF_SEPARATOR;



    /*
     * MUST be MF_BYPOSITION for Win2.x compatability.
     */
    if (flags & MF_REMOVE)
        return(NtUserRemoveMenu(hMenu, cmd,
                (DWORD)((flags & ~MF_REMOVE) | MF_BYPOSITION)));

    if (flags & MF_DELETE)
        return(NtUserDeleteMenu(hMenu, cmd, (DWORD)(flags & ~MF_DELETE)));

    if (flags & MF_CHANGE)
        return(ModifyMenuA(hMenu, cmd, (DWORD)((flags & ~MF_CHANGE) &
                (0x07F | MF_HELP | MF_BYPOSITION | MF_BYCOMMAND |
                MF_SEPARATOR)), IdItem, lpNewItem));

    if (flags & MF_APPEND)
        return(AppendMenuA(hMenu, (UINT)(flags & ~MF_APPEND),
            IdItem, lpNewItem));

    /*
     * Default is insert
     */
    return(InsertMenuA(hMenu, cmd, (DWORD)(flags & ~MF_INSERT),
            IdItem, lpNewItem));
}

LONG GetMenuCheckMarkDimensions()
{
    return((DWORD)MAKELONG(SYSMET(CXMENUCHECK), SYSMET(CYMENUCHECK)));
}

/***************************************************************************\
* GetMenuContextHelpId
*
* Return the help id of a menu.
*
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, WINUSERAPI DWORD, WINAPI, GetMenuContextHelpId, HMENU, hMenu)
WINUSERAPI DWORD WINAPI GetMenuContextHelpId(
    HMENU hMenu)
{
    PMENU pMenu;

    pMenu = VALIDATEHMENU(hMenu);

    if (pMenu == NULL)
        return 0;

    return pMenu->dwContextHelpId;
}

BOOL TrackPopupMenu(
    HMENU hMenu,
    UINT fuFlags,
    int x,
    int y,
    int nReserved,
    HWND hwnd,
    CONST RECT *prcRect)
{
    UNREFERENCED_PARAMETER(nReserved);
    UNREFERENCED_PARAMETER(prcRect);

    return NtUserTrackPopupMenuEx(hMenu, fuFlags, x, y, hwnd, NULL);
}

/***************************************************************************\
* GetSysMenuHandle
*
* Returns a handle to the system menu of the given window. NULL if
* the window doesn't have a system menu.
*
* History:
\***************************************************************************/

PMENU xxxGetSysMenuHandle(
    PWND pwnd)
{
    PMENU pMenu;

    if (TestWF(pwnd, WFSYSMENU)) {
        pMenu = pwnd->spmenuSys;

        /*
         * If the window doesn't have a System Menu, use the default one.
         */
        if (pMenu == NULL) {

            /*
             * Change owner so this app can access this menu.
             */
            pMenu = (PMENU)NtUserCallHwndLock(HWq(pwnd), SFI_XXXGETSYSMENUHANDLE);
        }
    } else {
        pMenu = NULL;
    }

    return pMenu;
}

BOOL WINAPI SetMenuItemBitmaps
(
    HMENU hMenu,
    UINT nPosition,
    UINT uFlags,
    HBITMAP hbmpUnchecked,
    HBITMAP hbmpChecked
)
{
    MENUITEMINFO    mii;
    mii.cbSize          = sizeof(MENUITEMINFO);
    mii.fMask           = MIIM_CHECKMARKS;
    mii.hbmpChecked     = hbmpChecked;
    mii.hbmpUnchecked   = hbmpUnchecked;

    return(SetMenuItemInfo(hMenu, nPosition, (BOOL) (uFlags & MF_BYPOSITION), &mii));
}


FUNCLOG5(LOG_GENERAL, int, WINAPI, DrawMenuBarTemp, HWND, hwnd, HDC, hdc, LPCRECT, lprc, HMENU, hMenu, HFONT, hFont)
int WINAPI DrawMenuBarTemp(
    HWND hwnd,
    HDC hdc,
    LPCRECT lprc,
    HMENU hMenu,
    HFONT hFont)
{
    HDC hdcr;

    if (IsMetaFile(hdc))
        return -1;

    hdcr = GdiConvertAndCheckDC(hdc);
    if (hdcr == (HDC)0)
        return -1;

    if (!hMenu)
        return -1;

    return NtUserDrawMenuBarTemp(
            hwnd,
            hdc,
            lprc,
            hMenu,
            hFont);
}

/***************************************************************************\
*
*  CheckMenuRadioItem() -
*
*  Checks one menu item in a range, unchecking the others.  This can be
*  done either MF_BYCOMMAND or MF_BYPOSITION.  It works similarly to
*  CheckRadioButton().
*
*  The return value is TRUE if the given item was checked, FALSE if not.
*
* History
* 04/04/97 GerardoB     Moved to the client side
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, CheckMenuRadioItem, HMENU, hMenu, UINT, wIDFirst, UINT, wIDLast, UINT, wIDCheck, UINT, flags)
BOOL CheckMenuRadioItem(HMENU hMenu, UINT wIDFirst, UINT wIDLast,
        UINT wIDCheck, UINT flags)
{
    BOOL    fByPosition = (BOOL) (flags & MF_BYPOSITION);
    PMENU   pMenu, pMenuItemIsOn;
    PITEM   pItem;
    UINT    wIDCur;
    BOOL    fChecked = FALSE;
    BOOL    fFirst  = TRUE;
    MENUITEMINFO mii;

    pMenu = VALIDATEHMENU(hMenu);
    if (pMenu == NULL) {
        return FALSE;
    }

    mii.cbSize = sizeof(mii);
    /*
     * Make sure we won't loop for ever
     */
    wIDLast = min(wIDLast, (UINT)0xFFFFFFFE);

    for (wIDCur = wIDFirst; wIDCur <= wIDLast; wIDCur++) {
        pItem = MNLookUpItem(pMenu, wIDCur, fByPosition, &pMenuItemIsOn);
        /*
         * Continue searching if it didn't find the item or it's a separator
         */
        if ((pItem == NULL) || TestMFT(pItem, MFT_SEPARATOR)) {
            continue;
        }
        /*
         * If this is the first one, rememeber what menu it's on because
         *  all items are supposed to be in the same menu.
         */
        if (fFirst) {
            pMenu = pMenuItemIsOn;
            hMenu = PtoHq(pMenu);
            fFirst = FALSE;
        }
        /*
         * If this item is on a different menu, don't touch it
         */
        if (pMenu != pMenuItemIsOn) {
            continue;
        }
        /*
         * Set the new check state. Avoid the trip to the kernel if possible
         */
        if (wIDCur == wIDCheck) {
            /*
             * Check it.
             */
            if (!TestMFT(pItem, MFT_RADIOCHECK) || !TestMFS(pItem, MFS_CHECKED)) {
                mii.fMask = MIIM_FTYPE | MIIM_STATE;
                mii.fType = (pItem->fType & MFT_MASK) | MFT_RADIOCHECK;
                mii.fState = (pItem->fState & MFS_MASK) | MFS_CHECKED;
                NtUserThunkedMenuItemInfo(hMenu, wIDCheck, fByPosition, FALSE, &mii, NULL);
            }
            fChecked = TRUE;
        } else {
            /*
             * Uncheck it
             * NOTE:  don't remove MFT_RADIOCHECK type
             */
            if (TestMFS(pItem, MFS_CHECKED)) {
                mii.fMask = MIIM_STATE;
                mii.fState = (pItem->fState & MFS_MASK) & ~MFS_CHECKED;
                NtUserThunkedMenuItemInfo(hMenu, wIDCur, fByPosition, FALSE, &mii, NULL);
            }
        }
    } /* for */

    if (fFirst) {
        /*
         * No item was ever found.
         */
        RIPERR0(ERROR_MENU_ITEM_NOT_FOUND, RIP_VERBOSE, "CheckMenuRadioItem, no items found\n");

    }
    return(fChecked);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\mmcl.c ===
/****************************** Module Header ******************************\
* Module Name: mmcl.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
* 
* Multimonitor APIs in the client.
* 
* History:
* 29-Mar-1997 adams     Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

HMONITOR
MonitorFromPoint(
    IN POINT pt,
    IN DWORD dwFlags)
{
    PMONITOR    pMonitor;

    if (dwFlags > MONITOR_DEFAULTTONEAREST) {
        RIPERR1(ERROR_INVALID_FLAGS,
                RIP_WARNING,
                "Invalid flags to MonitorFromPoint, %x", dwFlags);

        return NULL;
    }

    pMonitor = _MonitorFromPoint(pt, dwFlags);

    try {
        return PtoH(pMonitor);
    } except(W32ExceptionHandler(TRUE, RIP_WARNING)) {
        return NULL;
    }
}



HMONITOR
MonitorFromRect(
    IN LPCRECT lprc,
    IN DWORD dwFlags)
{
    PMONITOR    pMonitor;

    if (dwFlags > MONITOR_DEFAULTTONEAREST) {
        RIPERR1(ERROR_INVALID_FLAGS,
                RIP_WARNING,
                "Invalid flags to MonitorFromRect, %x", dwFlags);

        return NULL;
    }

    pMonitor = _MonitorFromRect(lprc, dwFlags);

    try {
        return PtoH(pMonitor);
    } except(W32ExceptionHandler(TRUE, RIP_WARNING)) {
        return NULL;
    }
}



HMONITOR
MonitorFromWindow(
    IN HWND hwnd,
    IN DWORD dwFlags)
{
    PMONITOR    pMonitor;
    PWND        pwnd;

    if (dwFlags > MONITOR_DEFAULTTONEAREST) {
        RIPERR1(ERROR_INVALID_FLAGS,
                RIP_WARNING,
                "Invalid flags to MonitorFromWindow, %x", dwFlags);

        return NULL;
    }

    if (hwnd) {
        pwnd = ValidateHwnd(hwnd);
        if (!pwnd) {
            return NULL;
        }
    } else {
        pwnd = NULL;
    }

    pMonitor = _MonitorFromWindow(pwnd, dwFlags);

    try {
        return PtoH(pMonitor);
    } except(W32ExceptionHandler(TRUE, RIP_WARNING)) {
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\mdiwin.c ===
/****************************************************************************\
*
*  MDIWIN.C -
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      MDI Child Windows Support
*
* History
* 11-14-90 MikeHar     Ported from windows
* 14-Feb-1991 mikeke   Added Revalidation code
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define TITLE_EXTRA 5
#define MAX_TITLE_LEN 160


/***************************************************************************\
* xxxSetFrameTitle
*
* if lpch == 1, we redraw the whole frame. If 2, we don't do any redraw. Any
* other value, and we redraw just the caption of the frame.
*
* History:
* 11-14-90 MikeHar Ported from windows
* 04-16-91 MikeHar Win31 Merge
\***************************************************************************/

void xxxSetFrameTitle(
    PWND pwndFrame,
    PWND pwndMDI,
    LPWSTR lpch)
{
    PWND pwnd;
    PMDI pmdi;
    WCHAR sz[MAX_TITLE_LEN];
    HWND  hwndFrame = HW(pwndFrame);

    CheckLock(pwndFrame);
    CheckLock(pwndMDI);

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwndMDI)->pmdi;

    if (IS_PTR(lpch) || lpch == NULL) {
        if (HTITLE(pmdi)) {
            UserLocalFree(HTITLE(pmdi));
        }
        HTITLE(pmdi) = TextAlloc(lpch);
    }

    if (HTITLE(pmdi)) {
        LARGE_UNICODE_STRING str;
        int cch;

        RtlInitLargeUnicodeString(&str, HTITLE(pmdi), (UINT)-1);
        TextCopy(&str, sz, sizeof(sz)/sizeof(WCHAR));

        if (MAXED(pmdi) && (pwnd = ValidateHwnd(MAXED(pmdi))) && pwnd->strName.Length) {

            cch = MAX_TITLE_LEN - ((str.Length / sizeof(WCHAR)) + TITLE_EXTRA);
            if (cch > 0) {
                wcscat(sz, TEXT(" - ["));
                wcsncat(sz, REBASE(pwnd, strName.Buffer), cch - 1);
                wcscat(sz, TEXT("]"));
            }
        }
    } else {
        sz[0] = 0;
    }

    _DefSetText(hwndFrame, sz, FALSE);

    if (lpch == (LPWSTR)1L)
        NtUserRedrawFrameAndHook(hwndFrame);

    else if (lpch != (LPWSTR)2L) {
        if (!NtUserRedrawTitle(hwndFrame, DC_TEXT))
            NtUserRedrawFrame(hwndFrame);
    }
}


/***************************************************************************\
* TranslateMDISysAccel
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, TranslateMDISysAccel, HWND, hwnd, LPMSG, lpMsg)
BOOL TranslateMDISysAccel(
    HWND hwnd,
    LPMSG lpMsg)
{
    PWND pwnd;
    PMDI pmdi;
    int event;

    /*
     * Is this a message we care about?
     */
    if (lpMsg->message != WM_KEYDOWN && lpMsg->message != WM_SYSKEYDOWN) {
        return FALSE;
    }

    /*
     * This is called within a message loop. If the window gets destroyed,
     * there still may be other messages in the queue that get returned
     * after the window is destroyed. The app will call TranslateAccelerator()
     * on every one of these, causing RIPs.... Make it nice so it just
     * returns FALSE.
     */
    if ((pwnd = ValidateHwndNoRip(hwnd)) == NULL) {
        RIPERR0(ERROR_INVALID_WINDOW_HANDLE, RIP_VERBOSE, "");
        return FALSE;
    }

    CheckLock(pwnd);

    /*
     * Make sure this is really an MDIClient window. Harvard Graphics 2.0
     * calls this function with a different window class and caused us
     * to get an access violation.
     */
    if (GETFNID(pwnd) != FNID_MDICLIENT) {
        RIPMSG0(RIP_WARNING, "Window not of MDIClient class");
        return FALSE;
    }

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwnd)->pmdi;

    if (!ACTIVE(pmdi))
        return FALSE;

    if (!IsWindowEnabled(ACTIVE(pmdi)))
        return FALSE;

    switch (lpMsg->wParam) {
    case VK_F4:
        event = SC_CLOSE;
        break;
    case VK_F6:
    case VK_TAB:
        if (GetKeyState(VK_SHIFT) < 0)
            event = SC_PREVWINDOW;
        else
            event = SC_NEXTWINDOW;
        break;
    default:
        return FALSE;
    }

    /*
     * All of these have the control key down
     */
    if (GetKeyState(VK_CONTROL) >= 0)
        return FALSE;

    if (GetKeyState(VK_MENU) < 0)
        return FALSE;

    SendMessage(ACTIVE(pmdi), WM_SYSCOMMAND, event, MAKELONG(lpMsg->wParam, 0));

    return TRUE;
}

/***************************************************************************\
*
*  CalcClientScrolling()
*
\***************************************************************************/

#define SBJ_HORZ  HAS_SBHORZ
#define SBJ_VERT  HAS_SBVERT
#define SBJ_BOTH  (SBJ_HORZ | SBJ_VERT)

void ByteOutsetRect(LPRECT lprc)
{
    int FAR *pi;
    int i;

    for (i = 0, pi = (int FAR *) lprc; i < 4; i++, pi++) {
        if (*pi > 0)
            *pi += 7;
        else if (*pi < 0)
            *pi -= 7;

        *pi /= 8;
    }
}

void CalcClientScrolling(HWND hwnd, UINT sbj, BOOL fIgnoreMin)
{
    PWND pwnd;
    RECT rcScroll;
    RECT rcClient;
    RECT rcRange;
    RECT rcT;
    PWND pwndT;
    BOOL fVert;
    BOOL fHorz;
    BYTE fHadVert, fHadHorz;
    BOOL fCheckVert;
    BOOL fCheckHorz;
    BOOL fNeedScrolls;
    SCROLLINFO si;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return;
    }
    CheckLock(pwnd);

    UserAssert(GETFNID(pwnd) != FNID_DESKTOP);

    // do nothing if the parent is iconic.  This way, we don't add invisible
    // scrollbars which will paint and unpaint when restoring...
    if (TestWF(pwnd, WFMINIMIZED))
        return;

    fVert = FALSE;
    fHorz = FALSE;
    fNeedScrolls=FALSE;

    fCheckHorz = (sbj & SBJ_HORZ);
    fCheckVert = (sbj & SBJ_VERT);

    // find client area without scroll bars
    CopyRect(&rcClient, KPRECT_TO_PRECT(&pwnd->rcClient));

    fHadVert = TestWF(pwnd, WFVSCROLL);
    if (fCheckVert && fHadVert)
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            rcClient.left -= SYSMET(CXVSCROLL);
        } else {
            rcClient.right += SYSMET(CXVSCROLL);
        }

    fHadHorz = TestWF(pwnd, WFHSCROLL);
    if (fCheckHorz && fHadHorz)
        rcClient.bottom += SYSMET(CYHSCROLL);

    // find the rectangle that bounds all visible child windows
    SetRectEmpty(&rcScroll);

    for (pwndT = REBASEPWND(pwnd, spwndChild); pwndT;
            pwndT = REBASEPWND(pwndT, spwndNext)) {
        if (fIgnoreMin && TestWF(pwndT, WFMINIMIZED))
            continue;

        if (TestWF(pwndT,WFVISIBLE)) {
            if (TestWF(pwndT, WFMAXIMIZED)) {
                fNeedScrolls = FALSE;
                break;
            }

            /*
             * add this window to the area that has to be visible
             */
            UnionRect(&rcScroll, &rcScroll, KPRECT_TO_PRECT(&pwndT->rcWindow));

            /*
             * add scroll bars if its not contained in the
             * client area
             */
            UnionRect(&rcT, &rcClient, KPRECT_TO_PRECT(&pwndT->rcWindow));
            if (!EqualRect(&rcClient, &rcT)) {
                fNeedScrolls = TRUE;
            }
        }
    }

    SetRectEmpty(&rcRange);

    // offset rectangles such that rcClient's top & left are both 0
    // making rcClient's right & bottom be the page size
    _ScreenToClient(pwnd, (LPPOINT)&rcScroll.left);
    _ScreenToClient(pwnd, (LPPOINT)&rcScroll.right);

    /*
     * Swap the left and right if pwnd is a mirrored window.
     */
    if (TestWF(pwnd, WEFLAYOUTRTL)) {
       int  nSaveLeft;

       nSaveLeft = rcScroll.left;
       rcScroll.left  = rcScroll.right;
       rcScroll.right = nSaveLeft;
    }

    OffsetRect(&rcClient, -rcClient.left, -rcClient.top);

    if (!fNeedScrolls)
        rcClient.bottom = rcClient.right = 0;
    else do
    {
            /*
             * the range is the union of the parent client with all of its
             * children
             */
        CopyRect(&rcT, &rcRange);
        UnionRect(&rcRange, &rcScroll, &rcClient);

        if (fCheckVert) {
            // subtract off space for the vertical scroll if we need it
            if (((rcRange.bottom - rcRange.top) > rcClient.bottom) && !fVert) {
                fVert = TRUE;
                rcClient.right -= SYSMET(CXVSCROLL);
            }
        }

        if (fCheckHorz) {
            // subtract off space for the horizontal scroll if we need it
            if (((rcRange.right - rcRange.left) > rcClient.right) && !fHorz) {
                fHorz = TRUE;
                rcClient.bottom -= SYSMET(CYHSCROLL);
            }
        }
    }
    while (!EqualRect(&rcRange, &rcT));

    if (fNeedScrolls) {
        // HACK of death beginning
        if (rcRange.right == rcClient.right)
            rcRange.right -= 8;

        if (rcRange.bottom == rcClient.bottom)
            rcRange.bottom -= 8;
        // HACK of death ending
    }

    if (fCheckVert) {

        /*
         * check to see if we are changing the presence of the vertical
         * scrollbar
         */
        if ((rcRange.bottom - rcRange.top) <= rcClient.bottom) {
            ClearWindowState(pwnd, WFVSCROLL);
        } else {
            SetWindowState(pwnd, WFVSCROLL);
       }
    }

    if (fCheckHorz) {

        /*
         * same for horizontal scroll
         */
        if ((rcRange.right - rcRange.left) <= rcClient.right) {
            ClearWindowState(pwnd, WFHSCROLL);
        } else {
            SetWindowState(pwnd, WFHSCROLL);
        }
    }

    if (fNeedScrolls) {
        ByteOutsetRect(&rcClient);
        ByteOutsetRect(&rcRange);
    }

    si.cbSize   = sizeof(SCROLLINFO);
    si.fMask    = SIF_ALL;
    si.nPos     = 0;

    si.nMin     = rcRange.left;
    si.nMax     = rcRange.right;
    si.nPage    = rcClient.right;

    SetScrollInfo(hwnd, SB_HORZ, &si, FALSE);

    si.nMin     = rcRange.top;
    si.nMax     = rcRange.bottom;
    si.nPage    = rcClient.bottom;

    SetScrollInfo(hwnd, SB_VERT, &si, FALSE);

    if ((fHadVert != TestWF(pwnd, WFVSCROLL)) ||
        (fHadHorz != TestWF(pwnd, WFHSCROLL)))
    NtUserRedrawFrame(hwnd);
}


/***************************************************************************\
* ScrollChildren
*
*  Handles WM_VSCROLL and WM_HSCROLL messages
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

void ScrollMDIChildren(
    HWND hwnd,
    int nCtl,
    UINT wCmd,
    int iThumbPos)
{
    SCROLLINFO  si;
    int wInc;
    int wNewPos;
    //SHORT sPos;
    int          x, y;

    wInc = (((nCtl == SB_VERT) ? SYSMET(CYSIZE) : SYSMET(CXSIZE)) + 7) / 8;

    si.cbSize   = sizeof(SCROLLINFO);
    si.fMask    = SIF_ALL;
    GetScrollInfo(hwnd, nCtl, &si);

    si.nPage--;
    si.nMax -= si.nPage;

    switch (wCmd) {
    case SB_BOTTOM:
        wNewPos = si.nMax;
        break;
    case SB_TOP:
        wNewPos = si.nMin;
        break;
    case SB_LINEDOWN:
        wNewPos = si.nPos + wInc;
        break;
    case SB_LINEUP:
        wNewPos = si.nPos - wInc;
        break;
    case SB_PAGEDOWN:
        wNewPos = si.nPos + si.nPage;
        break;
    case SB_PAGEUP:
        wNewPos = si.nPos - si.nPage;
        break;
    case SB_THUMBPOSITION:

        wNewPos = iThumbPos;
        break;
    case SB_ENDSCROLL:
        CalcClientScrolling(hwnd, (nCtl == SB_VERT) ? SBJ_VERT : SBJ_HORZ, FALSE);

    /*
     ** FALL THRU **
     */
    default:
        return;
    }

    if (wNewPos < si.nMin)
        wNewPos = si.nMin;
    else if (wNewPos > si.nMax)
        wNewPos = si.nMax;

    SetScrollPos(hwnd, nCtl, wNewPos, TRUE);

    // the "* 8" is because we need to scroll in bytes.  The scrollbar
    // increments for MDI are bytes (this is due to the fact that we need to
    // not upset the brush origin of the app workspace brush that is used to
    // fill the MDI background)

    x = (si.nPos - wNewPos) * 8;

    if (nCtl == SB_VERT) {
        y = x;
        x = 0;
    } else
        // x is already set properly for this case
        y = 0;

    NtUserScrollWindowEx(hwnd, x, y, NULL, NULL, NULL, NULL,
           SW_SCROLLWINDOW | SW_INVALIDATE | SW_ERASE | SW_SCROLLCHILDREN);
}



FUNCLOGVOID3(LOG_GENERAL, DUMMYCALLINGTYPE, ScrollChildren, HWND, hwnd, UINT, wMsg, DWORD, wParam)
VOID ScrollChildren(
    HWND hwnd,
    UINT wMsg,
    DWORD wParam)
{
    ScrollMDIChildren(hwnd,
                      wMsg == WM_VSCROLL ? SB_VERT : SB_HORZ,
                      LOWORD(wParam),
                      (short)(HIWORD(wParam)));
}


/***************************************************************************\
* RecalculateScrollRanges
*
* History:
* 11-14-90 MikeHar Ported from windows
* 04-16-91 MikeHar Win31 Merge
\***************************************************************************/

void RecalculateScrollRanges(
    PWND pwndParent,
    BOOL fIgnoreMin)
{
    PMDI pmdi = ((PMDIWND)pwndParent)->pmdi;

    if (!(SCROLL(pmdi) & (CALCSCROLL | SCROLLCOUNT))) {
        if (PostMessage(HWq(pwndParent), MM_CALCSCROLL, fIgnoreMin, 0L)) {
            SCROLL(pmdi) |= CALCSCROLL;
        }
    }
}


/***************************************************************************\
* GetCascadeWindowPos
*
* History:
* 11-14-90 MikeHar Ported from windows
* 01-12-94 FritzS  Ported from Chicago
\***************************************************************************/

void GetCascadeWindowPos(
    LPCRECT prcClient,  /* area to arrange to */
    int     iWindow,    /* index of this window */
    LPRECT  lprc)       /* resulting rectangle */
{
    int cStack;
    int xStep, yStep;
    int dxClient, dyClient;

    /*
     * Compute the width and breadth of the situation.
     */
    dxClient = prcClient->right - prcClient->left;
    UserAssert(dxClient >= 0);
    dyClient = prcClient->bottom - prcClient->top;
    UserAssert(dyClient >= 0);

    /*
     * Compute the width and breadth of the window steps.
     */
    xStep = SYSMET(CXSIZEFRAME) + SYSMET(CXSIZE);
    yStep = SYSMET(CYSIZEFRAME) + SYSMET(CYSIZE);

    /*
     * How many windows per stack?
     */
    cStack = dyClient / (3 * yStep);

    lprc->right = dxClient - (cStack * xStep);
    lprc->bottom = dyClient - (cStack * yStep);

    /*
     * HACK!: Mod by cStack+1 and make sure no div-by-zero
     * exception happens.
     */
    if (++cStack <= 0) {
        cStack = 1;
    }

    lprc->left = prcClient->left + (iWindow % cStack) * xStep;
    lprc->top = prcClient->top + (iWindow % cStack) * yStep;
}


/***************************************************************************\
* MDICheckCascadeRect
*
* History:
* 11-14-90 MikeHar Ported from windows
* 04-16-91 MikeHar Win31 Merge
\***************************************************************************/

void MDICheckCascadeRect(
    PWND pwndClient,
    LPRECT lprc)
{
    PMDI pmdi;
    RECT rc, rcClient;
    int         iWindow;

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwndClient)->pmdi;

    iWindow = ITILELEVEL(pmdi);

    GetRect(pwndClient, &rcClient, GRECT_CLIENT | GRECT_CLIENTCOORDS);
    GetCascadeWindowPos(&rcClient, iWindow, &rc);

    if ((lprc->right == CW_USEDEFAULT || lprc->right == CW2_USEDEFAULT) ||
            !(lprc->right)) {
        lprc->right = rc.right;
    }

    if ((lprc->bottom == CW_USEDEFAULT || lprc->bottom == CW2_USEDEFAULT) ||
            !(lprc->bottom)) {
        lprc->bottom = rc.bottom;
    }

    if (lprc->left == CW_USEDEFAULT || lprc->left == CW2_USEDEFAULT) {
        lprc->left = rc.left;
        lprc->top = rc.top;
    }
}


/***************************************************************************\
* UnMaximizeChildWindows
*
* effects: Helper routine used by TileChildWindows and CascadeChildWindows to
* restore any maximized windows of the given parent. Returns TRUE if a
* maximized window was restored.
*
* History:
* 4-16-91 MikeHar       Win31 Merge
\***************************************************************************/

BOOL UnmaximizeChildWindows(
    HWND hwndParent)
{
    HWND hwndMove;
    PWND pwndMove;
    BOOL fFoundOne = FALSE;
    BOOL fAsync;
    UINT chwnd;
    HWND *phwndList;
    HWND *phwnd;
    HWND hwndChild = GetWindow(hwndParent, GW_CHILD);

    /*
     * Get the hwnd list.  It is returned in a block of memory
     * allocated with LocalAlloc.
     */
    if (hwndChild == NULL ||
            (chwnd = BuildHwndList(NULL, GetWindow(hwndParent, GW_CHILD),
                                   FALSE, 0, &phwndList)) == 0) {
        return FALSE;
    }

    fAsync = (hwndParent == GetDesktopWindow());

    for (phwnd = phwndList; chwnd > 0; chwnd--, phwnd++) {
        if ((hwndMove = *phwnd) == NULL)
            continue;

        if ((pwndMove = ValidateHwnd(hwndMove)) == NULL)
            continue;

// Not in Chicago -- FritzS
//        if (pwndMove->spwndOwner != NULL)
//            continue;

        if (TestWF(pwndMove, WFMAXIMIZED) && TestWF(pwndMove, WFVISIBLE)) {
            //
            // If we haven't done it yet, lock the screen to prevent sending
            // paints for a cleaner update.
            //
            if (!fFoundOne && fAsync)
                NtUserLockWindowUpdate(hwndParent);

            fFoundOne = TRUE;

            if (fAsync)
                NtUserShowWindowAsync(hwndMove, SW_SHOWNOACTIVATE);
            else
                NtUserShowWindow(hwndMove, SW_SHOWNORMAL);
        }
    }

    UserLocalFree(phwndList);

    if (fFoundOne && fAsync) {

        HWND hwndActive = NtUserGetForegroundWindow();
        if (hwndActive != NULL) {

            /*
             * Hack! Since the above showwindows cause zorder changes, we want
             * the active window to be in front.  This makes sure...
             */
            NtUserSetWindowPos(hwndActive, HWND_TOP, 0, 0, 0, 0,
                SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_ASYNCWINDOWPOS);

        }
        NtUserLockWindowUpdate(NULL);
        RedrawWindow(hwndParent, NULL, NULL,
                RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_ERASE | RDW_FRAME);
    }

    return fFoundOne;
}


/***************************************************************************\
*
* ARRANGEWINDOWSDATA: passed to EnumDisplayMonitors enumeration functions.
*
\***************************************************************************/

typedef struct tagARRANGEWINDOWSDATA {
    PWND    pwndParent;
    UINT    flags;
    LPRECT  lprcParent;
    int     chwnd;
    int     chwndReal;
    HWND *  phwnd;
    PWND    pwndDesktop;
    HDWP    hdwp;
    UINT    uGRCFlags;
    int     fVerifyParent;
} ARRANGEWINDOWSDATA, *PARRANGEWINDOWSDATA;



/***************************************************************************\
* ArrangeWindows
*
* Called from CascadeWindows and TileWindows, it performs what
* is common to both functions, and calls out to the enumeration
* function to do the work of window arrangement.
*
* History:
* 10-Jul-1997 adams     Created.
\***************************************************************************/

WORD ArrangeWindows(
    HWND            hwndParent,
    UINT            flags,
    CONST RECT *    lpRect,
    UINT            chwnd,
    CONST HWND *    ahwnd,
    MONITORENUMPROC lpfnEnum)
{
    ARRANGEWINDOWSDATA  awd;
    HWND *              phwnd = NULL;

    /*
     * Get parent window
     */
    awd.pwndDesktop = _GetDesktopWindow();
    if (!hwndParent) {
        hwndParent = HW(awd.pwndDesktop);
        awd.pwndParent = awd.pwndDesktop;
    } else {
        awd.pwndParent = ValidateHwnd(hwndParent);
        if (awd.pwndParent == NULL) {
            return 0;
        }
    }

    UnmaximizeChildWindows(hwndParent);

    /*
     * If the rect passed in contains the desktop window,
     * arrange the windows on the desktop
     */
    if ( lpRect &&
         awd.pwndParent == awd.pwndDesktop   &&
         lpRect->left   <= awd.pwndDesktop->rcClient.left   &&
         lpRect->top    <= awd.pwndDesktop->rcClient.top    &&
         lpRect->right  >= awd.pwndDesktop->rcClient.right  &&
         lpRect->bottom >= awd.pwndDesktop->rcClient.bottom ) {

        lpRect = NULL;
    }

    /*
     * Arrange iconic windows if appropriate, and determine flags
     * for getting the client rectangle if no rect is given.
     */
    if (lpRect == NULL) {
        if (    (   awd.pwndParent != awd.pwndDesktop ||
                    !(SYSMET(ARRANGE) & ARW_HIDE)) &&
                NtUserArrangeIconicWindows(hwndParent) != 0) {

            awd.uGRCFlags = GRC_SCROLLS | GRC_MINWNDS;
        } else {
            awd.uGRCFlags = GRC_SCROLLS;
        }
    }

    /*
     * Get window list
     */
    if (ahwnd == NULL) {
        HWND hwndChild;
        PWND pwndChild;

        pwndChild = REBASEPWND(awd.pwndParent, spwndChild);
        hwndChild = HW(pwndChild);
        if (    hwndChild == NULL ||
                (chwnd = BuildHwndList(NULL, hwndChild, FALSE, 0, &phwnd)) == 0) {
            return 0;
        }
    }

    /*
     * Arrange windows
     */
    awd.hdwp = NtUserBeginDeferWindowPos(chwnd);
    if (awd.hdwp == NULL)
        goto Done;

    awd.flags = flags;
    awd.lprcParent = (LPRECT) lpRect;
    awd.chwnd = chwnd;
    awd.chwndReal = 0;
    awd.phwnd = ahwnd ? (HWND *) ahwnd : phwnd;
    awd.fVerifyParent = (ahwnd != NULL);

    /*
     * If the parent is the desktop and a rectangle is not provided,
     * arrange the windows on each monitor. Otherwise, arrange the
     * windows once by calling the enumeration function directly.
     */
    if (awd.pwndParent == awd.pwndDesktop && lpRect == NULL) {
            NtUserEnumDisplayMonitors(NULL, NULL, lpfnEnum, (LPARAM) &awd);
    } else {
        (*lpfnEnum)(NULL, NULL, NULL, (LPARAM) &awd);
    }

    /* Make this arrangement asynchronous so we don't hang */
    if (awd.hdwp != NULL) {
        NtUserEndDeferWindowPosEx(awd.hdwp, TRUE);
    }

Done:
    if (phwnd) {
        UserLocalFree(phwnd);
    }

    return (awd.hdwp != NULL) ? awd.chwndReal : 0;
}



/***************************************************************************\
* GetParentArrangeRect
*
* Returns the rect passed in pawd if provided, otherwise gets the client
* rect of the parent window.
*
* History:
* 10-Jul-1997 adams     Created.
\***************************************************************************/

void
GetParentArrangeRect(PARRANGEWINDOWSDATA pawd, PMONITOR pMonitor, LPRECT lprc)
{
    UINT    uGRCFlags;

    if (pawd->lprcParent) {
        *lprc = *pawd->lprcParent;
    } else {
        uGRCFlags = pawd->uGRCFlags;

        /*
         * If icons are shown on the desktop, then they are always
         * shown on the primary monitor. So remove the GRC_MINWNDS
         * flag for monitors other than the primary.
         */
        if (pMonitor && pMonitor != GetPrimaryMonitor()) {
            uGRCFlags &= ~GRC_MINWNDS;
        }

        GetRealClientRect(
                pawd->pwndParent, lprc, uGRCFlags, pMonitor);
    }
}



/***************************************************************************\
* ValidatePositionableWindow
*
* Validates and returns a window if it is positionable, and sets
* the appropriate sizing flags.
*
* History:
* 10-Jul-1997 adams     Created.
\***************************************************************************/

PWND
ValidatePositionableWindow(
        HWND        hwndChild,
        PWND        pwndParent,
        PWND        pwndDesktop,
        DWORD       dwMDIFlags,
        PMONITOR    pMonitor,
        DWORD *     pdwSWPFlags)
{
    PWND    pwndChild;

    pwndChild = ValidateHwnd(hwndChild);
    if (pwndChild) {
        if (pwndParent && REBASEPWND(pwndChild, spwndParent) != pwndParent) {
            RIPMSG0(RIP_WARNING, "Cascade/Tile Windows: Windows in list must have same parent");
        } else if (
                /*
                 * mikesch - removed the maximized check since the call
                 * to restore maximized windows in unmaximizechildwindows occurs
                 * asynchronously now.
                 */
                TestWF(pwndChild, WFVISIBLE) &&
                TestWF(pwndChild, WFCPRESENT) &&
                !TestWF(pwndChild, WFMINIMIZED) &&
                !TestWF(pwndChild, WEFTOPMOST) &&
                (!(dwMDIFlags & MDITILE_SKIPDISABLED) || !TestWF(pwndChild, WFDISABLED)) &&
                !TestWF(pwndChild, WEFTOOLWINDOW) &&
                ((pMonitor) ?
                    (pMonitor == _MonitorFromWindow(pwndChild, MONITOR_DEFAULTTONULL)) :
                    (pwndParent != pwndDesktop || _MonitorFromWindow(pwndChild, MONITOR_DEFAULTTONULL)))) {

                    if (pdwSWPFlags) {
                        *pdwSWPFlags = SWP_NOACTIVATE | SWP_NOCOPYBITS;
                        if (!TestWF(pwndChild, WFSIZEBOX)) {
                            *pdwSWPFlags |= SWP_NOSIZE;
                        }
                        if (!(dwMDIFlags & MDITILE_ZORDER)) {
                            *pdwSWPFlags |= SWP_NOZORDER;
                        }
                    }
            return pwndChild;
        }
    }

    return NULL;
}



/***************************************************************************\
* CascadeWindowsEnum
*
* Cascades windows on the monitor.
*
* History:
* 10-Jul-1997 adams     Created.
\***************************************************************************/

BOOL CALLBACK
CascadeWindowsEnum(
        HMONITOR    hmonitor,
        HDC         hdc,
        LPRECT      lprc,
        LPARAM      lparam)
{
    PARRANGEWINDOWSDATA pawd = (PARRANGEWINDOWSDATA)lparam;
    PMONITOR    pMonitor = hmonitor ? VALIDATEHMONITOR(hmonitor) : NULL;
    RECT        rcParent;
    int         i;
    int         chwndReal = 0;
    RECT        rc;
    HWND        * phwnd, * phwndCopy;
    BOOL        fRet = TRUE;

    UNREFERENCED_PARAMETER(hdc);
    UNREFERENCED_PARAMETER(lprc);

    /*
     * Get the parent rectangle if none is given.
     */
    GetParentArrangeRect(pawd, pMonitor, &rcParent);

    /*
     * New for NT5: MDITILE_ZORDER (for the SHELL guys)
     * Sort pawd->phwnd by z-order
     */
    if (pawd->flags & MDITILE_ZORDER) {
        PWND pwndChild;
        HWND * phwndFullList, * phwndNext, * phwndSort, * phwndSearch;
        int chwndFullList, chwndSort, chwndSearch;
        /*
         * Make a copy to leave their array alone (it's supposed to be const)
         */
        phwndCopy = UserLocalAlloc(0, pawd->chwnd * sizeof(HWND));
        if (phwndCopy == NULL) {
            return FALSE;
        }
        RtlCopyMemory(phwndCopy, pawd->phwnd, pawd->chwnd * sizeof(HWND));
        /*
         * Get the sibblings Z-Ordered list.
         */
        pwndChild = REBASEPWND(pawd->pwndParent, spwndChild);
        if (pwndChild == NULL) {
            fRet = FALSE;
            goto CleanUp;
        }
        chwndFullList = BuildHwndList(NULL, HWq(pwndChild), FALSE, 0, &phwndFullList);
        if (chwndFullList == 0) {
            fRet = FALSE;
            goto CleanUp;
        }
        /*
         * Loop through the Z-Ordered list looking for the windows in the array
         */
        for (phwndNext = phwndFullList, chwndSort = pawd->chwnd, phwndSort = phwndCopy;
                (chwndFullList > 0) && (chwndSort > 1);
                chwndFullList--, phwndNext++) {

            for (chwndSearch = chwndSort, phwndSearch = phwndSort;
                    chwndSearch > 0;
                    chwndSearch--, phwndSearch++) {
                /*
                 * If it found a window, move it after the last sorted window.
                 */
                if (*phwndNext == *phwndSearch) {
                    HWND hwndFirst = *phwndSort;
                    *phwndSort = *phwndSearch;
                    *phwndSearch = hwndFirst;
                    phwndSort++;
                    chwndSort--;
                    break;
                }
            }
        }
        UserLocalFree(phwndFullList);
    } else { /* if (pawd->flags & MDITILE_ZORDER) */
        phwndCopy = pawd->phwnd;
    }

    /*
     * Arrange the windows in the list, preserving z-order.
     */
    for (i = pawd->chwnd, phwnd = phwndCopy + i - 1; --i >= 0; phwnd--) {
        HWND    hwndChild;
        PWND    pwndChild = NULL;
        DWORD   dwSWPFlags;

        hwndChild = *phwnd;
        pwndChild = ValidatePositionableWindow(
                hwndChild,
                pawd->fVerifyParent ? pawd->pwndParent : NULL,
                pawd->pwndDesktop,
                pawd->flags,
                pMonitor,
                &dwSWPFlags);

        if (!pwndChild)
            continue;

        GetCascadeWindowPos(&rcParent, chwndReal, &rc);

        pawd->hdwp = NtUserDeferWindowPos(
                pawd->hdwp,
                hwndChild,
                HWND_TOP,
                rc.left,
                rc.top,
                rc.right,
                rc.bottom,
                dwSWPFlags);

        chwndReal++;
        pawd->chwndReal++;
    }

CleanUp:
    if (pawd->flags & MDITILE_ZORDER) {
        UserLocalFree(phwndCopy);
    }

    return fRet && (pawd->hdwp != NULL);
}



/***************************************************************************\
*
*  CascadeWindows()
*
*  Cascades a list of children within a parent, according to the flags and
*  the rectangle passed in.
*
\***************************************************************************/
WORD CascadeWindows(
    HWND hwndParent,
    UINT flags,
    CONST RECT *lpRect,
    UINT chwnd,
    CONST HWND *ahwnd)
{
    return ArrangeWindows(hwndParent, flags, lpRect, chwnd, ahwnd, CascadeWindowsEnum);
}

BOOL CALLBACK
TileWindowsEnum(
        HMONITOR    hmonitor,
        HDC         hdc,
        LPRECT      lprc,
        LPARAM      lparam)
{
    PARRANGEWINDOWSDATA pawd = (PARRANGEWINDOWSDATA)lparam;
    PMONITOR    pMonitor = hmonitor ? VALIDATEHMONITOR(hmonitor) : NULL;
    RECT        rcParent;
    int         ihwnd;
    int         chwndReal;
    int         square;
    int         iCol, iRow;
    int         cCol, cRow;
    int         cRem;
    int         dx, dy;
    int         xRes, yRes;

    UNREFERENCED_PARAMETER(hdc);
    UNREFERENCED_PARAMETER(lprc);

    /*
     * Get the parent rectangle if none is given.
     */
    GetParentArrangeRect(pawd, pMonitor, &rcParent);

    /*
     * Now, figure out how many REAL windows we have.
     */
    chwndReal = 0;
    for (ihwnd = pawd->chwnd; --ihwnd >= 0;) {
        if (ValidatePositionableWindow(
                pawd->phwnd[ihwnd],
                pawd->fVerifyParent ? pawd->pwndParent : NULL,
                pawd->pwndDesktop,
                pawd->flags,
                pMonitor,
                NULL)) {

            chwndReal++;
        }
    }

    if (chwndReal == 0)
        return TRUE;

    xRes = rcParent.right - rcParent.left;
    yRes = rcParent.bottom - rcParent.top;
    if (xRes <= 0 || yRes <= 0)
        return TRUE;

    /*
     * Compute nearest least square
     */
    for (square = 2; square * square <= chwndReal; square++) {
        ;
    }

    if (pawd->flags & MDITILE_HORIZONTAL) {
        cCol = square - 1;
        cRow = chwndReal / cCol;
        cRem = chwndReal % cCol;
    } else {
        cRow = square - 1;
        cCol = chwndReal / cRow;
        cRem = chwndReal % cRow;
    }

    chwndReal = 0;
    ihwnd = -1;
    for (iCol = 0; iCol < cCol; iCol++) {
        /*
         * Add one extra row to handle the remainders.
         */
        if (cCol - iCol <= cRem) {
            cRow++;
        }

        for (iRow = 0; iRow < cRow; iRow++) {
            HWND    hwndChild;
            PWND    pwndChild;
            DWORD   dwSWPFlags;

            dx = xRes / cCol;
            dy = yRes / cRow;

NextWindow:
            /*
             * Skip bogus and nonpositionable windows
             */
            ihwnd++;
            if (ihwnd >= pawd->chwnd)
                return TRUE;

            hwndChild = pawd->phwnd[ihwnd];
            pwndChild = ValidatePositionableWindow(
                    hwndChild,
                    pawd->fVerifyParent ? pawd->pwndParent : NULL,
                    pawd->pwndDesktop,
                    pawd->flags,
                    pMonitor,
                    &dwSWPFlags);

            if (!pwndChild)
                goto NextWindow;

            /*
             * Move, size the window
             */
            pawd->hdwp = NtUserDeferWindowPos(
                    pawd->hdwp,
                    hwndChild,
                    HWND_TOP,
                    rcParent.left + iCol*dx,
                    rcParent.top + iRow*dy,
                    dx,
                    dy,
                    dwSWPFlags);

            if (pawd->hdwp == NULL)
                return FALSE;

            chwndReal++;
            pawd->chwndReal++;
        }

        if (cCol - iCol <= cRem) {
            cRow--;
            cRem--;
        }
    }

    return TRUE;
}



/***************************************************************************\
*
*  TileWindows()
*
*  Tiles a list of children within a parent, according to the flags and
*  the rectangle passed in.
*
\***************************************************************************/
WORD TileWindows(
    HWND        hwndParent,
    UINT        flags,
    CONST RECT *lpRect,
    UINT        chwnd,
    CONST HWND *ahwnd)
{
    return ArrangeWindows(hwndParent, flags, lpRect, chwnd, ahwnd, TileWindowsEnum);
}



/***************************************************************************\
* xxxMDIActivate
*
* History:
* 11-14-90 MikeHar Ported from windows
*  4-16-91 MikeHar Win31 Merge
\***************************************************************************/

void xxxMDIActivate(
    PWND pwnd,
    PWND pwndActivate)
{
    HWND hwndOld;
    PWND pwndOld;

    PMDI pmdi;
    BOOL fShowActivate;
    UINT nID;
    TL tlpwnd;
    TL tlpwndOld;
    PWND pwndT;
    HWND hwnd = HWq(pwnd);
    HWND hwndActivate = HW(pwndActivate);

    CheckLock(pwnd);
    CheckLock(pwndActivate);

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwnd)->pmdi;

    if (ACTIVE(pmdi) == hwndActivate)
        return;

    if ((pwndActivate != NULL) && (TestWF(pwndActivate, WFDISABLED))) {
        /*
         * Don't even try activating disabled or invisible windows.
         */
        return;
    }

    pwndT = REBASEPWND(pwnd, spwndParent);
    fShowActivate = (HW(pwndT) ==
            NtUserQueryWindow(hwnd, WindowActiveWindow));

    hwndOld = ACTIVE(pmdi);
    if (hwndOld && (pwndOld = ValidateHwnd(hwndOld)) == NULL) {
        hwndOld = NULL;
    }
    ThreadLock(pwndOld, &tlpwndOld);

    if (hwndOld) {

        /*
         * Attempt to deactivate the MDI child window.
         * The MDI child window can fail deactivation by returning FALSE.
         * But this only applies if the MDI frame is the active window
         * and the app is a 3.1 app or later
         */
        if (!SendMessage(hwndOld, WM_NCACTIVATE, FALSE, 0L) && fShowActivate) {
            if (TestWF(pwndOld, WFWIN31COMPAT))
                goto UnlockOld;
        }

        if (!TestWF(pwndOld, WFWIN31COMPAT) && TestWF(pwndOld, WFFRAMEON)) {

            /*
             * Error: Quicken for Windows is sort of bogus.  They try to fail
             * the WM_NCACTIVATE of their newly created window by not passing
             * it to DefWindowProc.  Bug 6412.  WM_NCACTIVATE sets/unsets the
             * WFFRAMEON bit if passed to DWP so we can double check things
             * here.
             */
            goto UnlockOld;
        }

        SendMessage(hwndOld, WM_MDIACTIVATE, (WPARAM)hwndOld, (LPARAM)hwndActivate);

        /*
         * Uncheck the old window menu entry.
         */
        if (WINDOW(pmdi))
            CheckMenuItem(WINDOW(pmdi), PtrToUlong(pwndOld->spmenu),
                MF_BYCOMMAND | MF_UNCHECKED);
    }

    //
    // Handle switching to a new (or NO) maximized window.  If NO window is
    // to become maximized, because we're activating NULL or the window to
    // become active doesn't have a WS_MAXIMIZEBOX, restore the old one to
    // it's normal size to clean up the MDI maximized menubar mess
    //
    if (MAXED(pmdi) && MAXED(pmdi) != hwndActivate) {
        HWND hwndMax;
        int  iShowCode;

        // The MAXBOX check is a new thing for 4.0 dudes; it breaks 3.x apps.
        // See comment in the WM_MDIMAXIMIZE handling.

        if (pwndActivate && (TestWF(pwndActivate, WFMAXBOX) || !TestWF(pwndActivate, WFWIN40COMPAT))) {
            hwndMax = hwndActivate;
            iShowCode = SW_SHOWMAXIMIZED;
            Lock(&ACTIVE(pmdi), hwndMax);
        } else {
            hwndMax = MAXED(pmdi);
            iShowCode = SW_SHOWNORMAL;
        }

        // overload WFFULLSCREEN bit -- useless for child windows anyways
        // use it to indicate to min/max code to not animate size change.

        // NO -- no bit overloading.  FritzS
        NtUserCallHwndParam(hwndMax, WFNOANIMATE, SFI_SETWINDOWSTATE);
        NtUserShowWindow(hwndMax, iShowCode);
        NtUserCallHwndParam(hwndMax, WFNOANIMATE, SFI_CLEARWINDOWSTATE);
    }

    Lock(&ACTIVE(pmdi), hwndActivate);

    /*
     * We may be removing the activation entirely...
     */
    if (!pwndActivate) {
        if (fShowActivate)
            NtUserSetFocus(hwnd);
        goto UnlockOld;
    }

    if (WINDOW(pmdi)) {

        /*
         * Check the new window menu entry.
         */
        nID = GetWindowID(ACTIVE(pmdi));
        if (nID - FIRST(pmdi) < (MAXITEMS - 1)) {
            CheckMenuItem(WINDOW(pmdi), nID, MF_BYCOMMAND | MFS_CHECKED);
        } else {
            /*
             * the item is not in the menu at all!  Swap it with number 9.
             */
            PWND pwndOther = FindPwndChild(pwnd, (UINT)(FIRST(pmdi) + MAXITEMS - 2));

            SetWindowLongPtr(HW(pwndOther), GWLP_ID, PtrToLong(pwndActivate->spmenu));
            SetWindowLongPtr(hwndActivate, GWLP_ID, FIRST(pmdi) + MAXITEMS - 2);

            ModifyMenuItem(pwndActivate);
        }
    }

    /*
     * Bring the window to the top.
     */
    NtUserSetWindowPos(ACTIVE(pmdi), NULL, 0, 0, 0, 0,
        SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

    /*
     * Update the Caption bar.  Don't muck with styles for 3.1.
     */
    if (fShowActivate) {
        SendMessage(ACTIVE(pmdi), WM_NCACTIVATE, TRUE, 0L);

        ThreadLock(pwnd, &tlpwnd);

        if (hwnd == NtUserQueryWindow(hwnd, WindowFocusWindow))
            SendMessage(hwnd, WM_SETFOCUS, (WPARAM)hwnd, 0);
        else
            NtUserSetFocus(hwnd);

        ThreadUnlock(&tlpwnd);
    }

    /*
     * Notify the new active window of his activation.
     */
    SendMessage(ACTIVE(pmdi), WM_MDIACTIVATE, (WPARAM)hwndOld,
                (LPARAM)hwndActivate);

UnlockOld:
    ThreadUnlock(&tlpwndOld);
}


/***************************************************************************\
* xxxMDINext
*
* History:
* 11-14-90 MikeHar Ported from windows
*  4-16-91 MikeHar Win31 Merge
\***************************************************************************/

void xxxMDINext(
    PWND pwndMDI,
    PWND pwnd,
    BOOL fPrevWindow)
{
    PMDI pmdi;
    PWND pwndNextGuy;
    HDWP hdwp;
    BOOL fHack = FALSE;

    CheckLock(pwndMDI);
    CheckLock(pwnd);

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwndMDI)->pmdi;

    pwndNextGuy = pwnd;

    while (TRUE) {
        if (fPrevWindow)
            pwndNextGuy = _GetWindow(pwndNextGuy, GW_HWNDPREV);
        else
            pwndNextGuy = REBASEPWND(pwndNextGuy, spwndNext);

        if (!pwndNextGuy) {
            if (fPrevWindow) {
                pwndNextGuy = _GetWindow(pwnd, GW_HWNDLAST);
            } else {
                pwndNextGuy =  REBASEPWND(pwndMDI, spwndChild);
            }
        }

        if (pwndNextGuy == pwnd)
            return;


        //
        // Ignore hidden and disabled windows.
        //
        if (TestWF(pwndNextGuy, WFVISIBLE) && !TestWF(pwndNextGuy, WFDISABLED))
            break;
    }

    if (MAXED(pmdi)) {
        NtUserSetVisible(HWq(pwndMDI), SV_UNSET | SV_CLRFTRUEVIS);
        fHack = TRUE;
    }

    hdwp = NtUserBeginDeferWindowPos(2);

    /*
     * activate the new window (first, in case of maximized windows)
     */
    hdwp = NtUserDeferWindowPos(hdwp, HW(pwndNextGuy), HWND_TOP, 0, 0, 0, 0,
        SWP_NOMOVE | SWP_NOSIZE);

// LATER 30-Mar-1992 mikeke
// this used to be _GetWindow(pwndMDI->spwndChild, GW_HWNDLAST)
// instead of HWND_BOTTOM
   if (hdwp && !fPrevWindow && (pwnd != pwndNextGuy))
       hdwp = NtUserDeferWindowPos(hdwp, HW(pwnd),
            HWND_BOTTOM, 0, 0, 0, 0,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    NtUserEndDeferWindowPosEx(hdwp, FALSE);

    if (fHack) {
        NtUserShowWindow(HWq(pwndMDI), SW_SHOW);
    }
}



FUNCLOG10(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, CreateMDIWindowA, LPCSTR, pClassName, LPCSTR, pWindowName, DWORD, dwStyle, int, x, int, y, int, nWidth, int, nHeight, HWND, hwndParent, HINSTANCE, hModule, LPARAM, lParam)
HWND
CreateMDIWindowA(
    LPCSTR pClassName,
    LPCSTR pWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hwndParent,
    HINSTANCE hModule,
    LPARAM lParam)
{
    return CreateWindowExA(WS_EX_MDICHILD, pClassName, pWindowName,
                                 dwStyle, x, y, nWidth, nHeight,
                                 hwndParent, NULL, hModule, (LPVOID)lParam);
}



FUNCLOG10(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, CreateMDIWindowW, LPCWSTR, pClassName, LPCWSTR, pWindowName, DWORD, dwStyle, int, x, int, y, int, nWidth, int, nHeight, HWND, hwndParent, HINSTANCE, hModule, LPARAM, lParam)
HWND
CreateMDIWindowW(
    LPCWSTR pClassName,
    LPCWSTR pWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hwndParent,
    HINSTANCE hModule,
    LPARAM lParam)
{
    return CreateWindowExW(WS_EX_MDICHILD, pClassName, pWindowName,
                                 dwStyle, x, y, nWidth, nHeight,
                                 hwndParent, NULL, hModule, (LPVOID)lParam);
}


/***************************************************************************\
* xxxMDIDestroy
*
* History:
* 11-14-90 MikeHar Ported from windows
*  4-16-91 MikeHar Win31 Merge
\***************************************************************************/

void xxxMDIDestroy(
    PWND pwnd,
    HWND hwndVictim)
{
    PWND pwndVictim;
    TL tlpwndParent;
    PMDI pmdi;
    PWND pwndParent;
    HWND hwnd;

    CheckLock(pwnd);

    if ((pwndVictim = ValidateHwnd(hwndVictim)) == NULL) {
        return;
    }
    CheckLock(pwndVictim);

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwnd)->pmdi;

#ifdef NEVER
// don't do this validation - because it sometimes doesn't work! If an
// app passed in idFirstChild (through CLIENTCREATESTRUCT) as -1, this
// code fails because it treats the id comparisons as unsigned compares.
// Change them to signed compares and it still doesn't work. That is because
// when ShiftMenuIDs() is called, you'll shift mdi windows out of the signed
// comparison range and this check won't allow them to be destroyed. This
// is straight win3.1 code.
//
    /*
     * Validate that this is one of the mdi children we are keeping track
     * of. If it isn't don't destroy it because it'll get mdi id tracking
     * code all messed up.
     */
    if (((UINT)pwndVictim->spmenu) < FIRST(pmdi) ||
            ((UINT)pwndVictim->spmenu) >= (UINT)(FIRST(pmdi) + CKIDS(pmdi)) ||
            pwndVictim->spwndOwner != NULL) {
        RIPERR0(ERROR_NON_MDICHILD_WINDOW, RIP_VERBOSE, "");
        return;
    }
#endif

    ShiftMenuIDs(pwnd, pwndVictim);

    /*
     * First Activate another window.
     */
    if (SAMEWOWHANDLE(hwndVictim, ACTIVE(pmdi))) {
        xxxMDINext(pwnd, pwndVictim, FALSE);

        /*
         * Destroying only child?
         */
        if (SAMEWOWHANDLE(hwndVictim, ACTIVE(pmdi))) {
            NtUserShowWindow(hwndVictim, SW_HIDE);

            /*
             * If the window is maximized, we need to remove his sys menu
             * now otherwise it may get deleted twice.  Once when the child
             * is destroyed and once when the frame is destroyed.
             */
            if (MAXED(pmdi)) {
                pwndParent = REBASEPWND(pwnd, spwndParent);
                MDIRemoveSysMenu(PtoH(REBASE(pwndParent,spmenu)), MAXED(pmdi));
                Unlock(&MAXED(pmdi));
                ThreadLock(pwndParent, &tlpwndParent);
                xxxSetFrameTitle(pwndParent, pwnd, (LPWSTR)1L);

                /*
                 * Redraw frame so menu bar shows the removed sys menu stuff
                 */
                if (TestWF(pwndParent, WFVISIBLE))
                    NtUserRedrawFrame(HWq(pwndParent));
                ThreadUnlock(&tlpwndParent);
            }
            xxxMDIActivate(pwnd, NULL);
        }
    }

    /*
     * Don't ever let this go negative or we'll get caught in long loops.
     */
    CKIDS(pmdi)--;
    if ((int)CKIDS(pmdi) < 0)
        CKIDS(pmdi) = 0;

    hwnd = HWq(pwnd);
    SendMessage(hwnd, WM_MDIREFRESHMENU, 0L, 0L);

    /*
     * Destroy the window.
     */
    NtUserDestroyWindow(hwndVictim);


    /*
     * During the DestroyWindow the parent may also have been deleted
     * Remove revalidate if we get client side locking
     */
    if (ValidateHwnd(hwnd) == NULL)
       return;

    /*
     * Deleting a window can change the scroll ranges.
     */
    RecalculateScrollRanges(pwnd, FALSE);
}

/***************************************************************************\
* MDIClientWndProc
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

LRESULT MDIClientWndProcWorker(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    HWND hwnd = HWq(pwnd);
    HWND hwndT;
    PWND pwndT;
    TL tlpwndT;
    PMDI pmdi;
    PWND pwndParent;

    CheckLock(pwnd);

    VALIDATECLASSANDSIZE(pwnd, FNID_MDICLIENT);

    /*
     * Get the pmdi for the given window now since we will use it a lot in
     * various handlers. This was stored using SetWindowLong(hwnd,4,pmdi) when
     * we initially created the MDI client window.
     */
    pmdi = ((PMDIWND)pwnd)->pmdi;

    if (pmdi == NULL) {
        switch (message) {
        case WM_MDICREATE:
        case WM_MDIMAXIMIZE:
        case WM_PARENTNOTIFY:
        case WM_CREATE:
            /*
             * These messages are safe to call, even when pmdi has not already
             * been initialized.
             */
            break;

        default:
            /*
             * Any message that is not listed above is not safe to call when
             * pmdi has not been initialized.  Instead, just directly call DWP.
             */
            goto CallDWP;
        }
    }

    switch (message) {
    case WM_NCACTIVATE:

        /*
         * We are changing app activation.  Fix the active child's caption.
         */
        if (ACTIVE(pmdi) != NULL) {
            SendMessage(ACTIVE(pmdi), WM_NCACTIVATE, wParam, lParam);
        }
        goto CallDWP;

    case WM_MDIGETACTIVE:
        if (lParam != 0) {
            *((LPBOOL)lParam) = (MAXED(pmdi) != NULL);
        }

        return (LRESULT)ACTIVE(pmdi);

    case WM_MDIACTIVATE:
        hwndT = (HWND)wParam;
        if ((pwndT = ValidateHwnd(hwndT)) == NULL)
            return 0;

        if (SAMEWOWHANDLE(hwndT, ACTIVE(pmdi)))
              break;

        NtUserSetWindowPos(hwndT, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
        break;

    case WM_MDICASCADE:
        pmdi->wScroll |= SCROLLSUPPRESS;
        NtUserShowScrollBar(hwnd, SB_BOTH, FALSE);

        /*
         * Unmaximize any maximized window.
         */
#ifdef NEVER  // Not in Chicago -- FritzS
        if (MAXED(pmdi) != NULL) {
            NtUserShowWindow(MAXED(pmdi), SW_SHOWNORMAL);
        }
#endif
        /*
         * Save success/failure code to return to app
         */
        message = (UINT)CascadeWindows(hwnd, (UINT)wParam, NULL, 0, NULL);
        pmdi->wScroll &= ~SCROLLCOUNT;
        return (LONG)message;
        break;

    case WM_VSCROLL:
    case WM_HSCROLL:
        pmdi->wScroll |= SCROLLSUPPRESS;
        ScrollMDIChildren(hwnd, (message == WM_VSCROLL) ? SB_VERT : SB_HORZ,
              LOWORD(wParam), (short)(HIWORD(wParam)));
        pmdi->wScroll &= ~SCROLLCOUNT;
        break;

    case WM_MDICREATE:
        {
        LPMDICREATESTRUCTA lpMCSA = (LPMDICREATESTRUCTA)lParam;
        LPMDICREATESTRUCTW lpMCSW = (LPMDICREATESTRUCTW)lParam;
        DWORD exStyle = WS_EX_MDICHILD;

        /*
         * inherit the right.to.leftness of the parent.
         */
        exStyle |= (pwnd->ExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR));

        if (fAnsi) {
            hwndT = CreateWindowExA(exStyle, lpMCSA->szClass, lpMCSA->szTitle,
                lpMCSA->style, lpMCSA->x, lpMCSA->y, lpMCSA->cx, lpMCSA->cy,
                hwnd, NULL, lpMCSA->hOwner, (LPSTR)lpMCSA->lParam);
        } else {
            hwndT = CreateWindowExW(exStyle, lpMCSW->szClass, lpMCSW->szTitle,
                lpMCSW->style, lpMCSW->x, lpMCSW->y, lpMCSW->cx, lpMCSW->cy,
                hwnd, NULL, lpMCSW->hOwner, (LPWSTR)lpMCSW->lParam);
        }

        return((LRESULT)hwndT);

        }

    case WM_MDIDESTROY:
        xxxMDIDestroy(pwnd, (HWND)wParam);
        break;

    case WM_MDIMAXIMIZE:
        hwndT = (HWND)wParam;
        if ((pwndT = ValidateHwnd(hwndT)) == NULL)
            return 0;

        // Only maximize children with a MAXBOX.  However, this introduces
        // backwards-compatibility issues with VB apps (see#12211)
        // So, we do this only for WIN40COMPAT apps and beyond.
        //
        if ((TestWF(pwndT, WFMAXBOX)) || !(TestWF(pwndT, WFWIN40COMPAT))) {
            NtUserShowWindow(hwndT, SW_SHOWMAXIMIZED);
        }
        break;

    case WM_MDIRESTORE:
        hwndT = (HWND)wParam;
        if ((pwndT = ValidateHwnd(hwndT)) == NULL)
            return 0;

        NtUserShowWindow(hwndT, SW_SHOWNORMAL);
        break;

    case WM_MDITILE:
        pmdi->wScroll |= SCROLLSUPPRESS;
        NtUserShowScrollBar(hwnd, SB_BOTH, FALSE);

        /*
         * Unmaximize any maximized window.
         */
#ifdef NEVER  //Not in Chicago
        if (MAXED(pmdi) != NULL) {
            NtUserShowWindow(MAXED(pmdi), SW_SHOWNORMAL);
        }
#endif
        /*
         * Save success/failure code to return to app
         */
        message = (UINT)TileWindows(hwnd, (UINT)wParam, NULL, 0, NULL);
        pmdi->wScroll &= ~SCROLLCOUNT;
        return (LONG)message;
        break;

    case WM_MDIICONARRANGE:
        pmdi->wScroll |= SCROLLSUPPRESS;
        NtUserArrangeIconicWindows(hwnd);
        pmdi->wScroll &= ~SCROLLCOUNT;
        RecalculateScrollRanges(pwnd, TRUE);
        break;

    case WM_MDINEXT:
        if (wParam) {
            hwndT = (HWND)wParam;
        } else {
            hwndT = ACTIVE(pmdi);
        }

        if ((pwndT = ValidateHwnd(hwndT)) == NULL) {
            return 0;
        }

        /*
         * If lParam is 1, do a prev window instead of a next window
         */
        ThreadLockAlways(pwndT, &tlpwndT);
        xxxMDINext(pwnd, pwndT, (lParam == 0 ? 0 : 1));
        ThreadUnlock(&tlpwndT);
        break;

    case WM_MDIREFRESHMENU:
            return (LRESULT)MDISetMenu(pwnd, TRUE, NULL, NULL);

    case WM_MDISETMENU:
            return (LRESULT)MDISetMenu(pwnd, FALSE, (HMENU)wParam, (HMENU)lParam);

    case WM_PARENTNOTIFY:
        if (wParam == WM_LBUTTONDOWN) {
            HWND hwndChild;
            POINT pt;

            if ((pwndT = ValidateHwnd(hwnd)) == NULL) {
                return 0;
            }

            /*
             * Activate this child and bring it to the top.
             */
            pt.x = (int)MAKEPOINTS(lParam).x;
            pt.y = (int)MAKEPOINTS(lParam).y;

            /*
             * Since pt is relative to the client MDI window,
             * then the points should be mirrored if the MDI
             * client window is mirrored so that Scrren Coord
             * calculations are done properly in NtUserChildWindowFromPointEx.
             * [samera]
             */
            if (TestWF(pwndT, WEFLAYOUTRTL)) {
                pt.x = (pwndT->rcClient.right-pwndT->rcClient.left)-pt.x;
            }

            hwndChild = NtUserChildWindowFromPointEx(hwnd, pt,
                CWP_SKIPDISABLED | CWP_SKIPINVISIBLE);

            if ((hwndChild) && (hwndChild != hwnd)) {

                if (hwndChild != ACTIVE(pmdi)) {
                    NtUserSetWindowPos(hwndChild, HWND_TOP, 0, 0, 0, 0,
                                 SWP_NOMOVE | SWP_NOSIZE);
                }
            }
        }
        break;

    case WM_SETFOCUS:
        if (ACTIVE(pmdi) != NULL && !IsIconic(ACTIVE(pmdi))) {
            NtUserSetFocus(ACTIVE(pmdi));
        }
        break;

    case WM_SIZE:
        if (ACTIVE(pmdi) && (pwndT = ValidateHwnd(ACTIVE(pmdi))) &&
            TestWF(pwndT, WFMAXIMIZED)) {

            RECT rc;

            rc.top = rc.left = 0;
            rc.right = (int)MAKEPOINTS(lParam).x;
            rc.bottom = (int)MAKEPOINTS(lParam).y;
            RealAdjustWindowRectEx(&rc, pwndT->style, FALSE,
                    pwndT->ExStyle);
            NtUserMoveWindow(ACTIVE(pmdi), rc.left, rc.top,
                    rc.right - rc.left, rc.bottom - rc.top, TRUE);
        } else {
            RecalculateScrollRanges(pwnd, FALSE);
        }
        goto CallDWP;

    case MM_CALCSCROLL: {

        if (SCROLL(pmdi) & SCROLLCOUNT)
            break;

        {
            WORD sbj = pmdi->wScroll & (HAS_SBVERT | HAS_SBHORZ);

            if (sbj)
            {
                CalcClientScrolling(hwnd, sbj, (BOOL) wParam);

                SCROLL(pmdi) &= ~CALCSCROLL;
            }
        }
        break;
    }

    case WM_CREATE: {
        LPCLIENTCREATESTRUCT pccs = ((LPCREATESTRUCT)lParam)->lpCreateParams;

        /*
         * Try to allocate space for the pmdi
         */
        if ((pmdi = (PMDI)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(MDI)))) {
            NtUserSetWindowLongPtr(hwnd, GWLP_MDIDATA, (LONG_PTR)pmdi, FALSE);
        } else {
            NtUserSetWindowFNID(hwnd, FNID_CLEANEDUP_BIT);
            break;
        }

        pwndParent = REBASEPWND(pwnd, spwndParent);
        ACTIVE(pmdi) = NULL;
        MAXED(pmdi)  = NULL;
        CKIDS(pmdi)  = 0;
        WINDOW(pmdi) = pccs->hWindowMenu;

        FIRST(pmdi)  = pccs->idFirstChild;
        SCROLL(pmdi) = 0;
        HTITLE(pmdi) = TextAlloc(REBASE(pwndParent, strName.Buffer));

        _DefSetText(HW(pwndParent), NULL, FALSE);

        ThreadLock(pwndParent, &tlpwndT);
        xxxSetFrameTitle(pwndParent, pwnd, (LPWSTR)2L);
        ThreadUnlock(&tlpwndT);

        if (TestWF(pwnd, WFVSCROLL))
            SCROLL(pmdi) |= HAS_SBVERT;
        if (TestWF(pwnd, WFHSCROLL))
            SCROLL(pmdi) |= HAS_SBHORZ;
        if (SCROLL(pmdi)) {
            ClearWindowState(pwnd, WFVSCROLL | WFHSCROLL);
        }

        /*
         * Set this dude's system menu.
         */
        NtUserGetSystemMenu(HW(pwndParent), FALSE);

        /*
         * make sure we have the correct window client area if scrolls are
         * removed...  hack to take care of small progman bug
         */
        if (SCROLL(pmdi)) {
            NtUserUpdateClientRect(hwnd);
        }
        break;
    }

    case WM_DESTROY:
    case WM_FINALDESTROY:
        if (MAXED(pmdi)) {
            PWND pwndParent;
            PMENU pmenu;

            pwndParent = REBASEPWND(pwnd, spwndParent);
            pmenu = REBASE(pwndParent, spmenu);
            MDIRemoveSysMenu(PtoH(pmenu), MAXED(pmdi));
        }

        /*
         * delete the title
         */
        if (HTITLE(pmdi)) {
            UserLocalFree(HTITLE(pmdi));
            HTITLE(pmdi) = NULL;
        }

        /*
         * Delete the menu items of the child windows in the frame.
         * Chances are, this is called by destroying the frame, but
         * one never knows, does one?
         *
         * Increase CKIDS by 1 after checking to delete the separator
         */
        if (IsMenu(WINDOW(pmdi)) && CKIDS(pmdi)++) {
            UINT iPosition;

            if (CKIDS(pmdi) > MAXITEMS + 1)
                CKIDS(pmdi) = MAXITEMS + 1;

            iPosition = GetMenuItemCount(WINDOW(pmdi));
            while (CKIDS(pmdi)--) {
                NtUserDeleteMenu(WINDOW(pmdi), --iPosition, MF_BYPOSITION);
            }
        }

        /*
         * Unlock those objects that are used by the MDI structure.
         */
        Unlock(&MAXED(pmdi));
        Unlock(&ACTIVE(pmdi));
        Unlock(&WINDOW(pmdi));

        /*
         * Free the MDI structure
         */
        UserLocalFree(pmdi);
        NtUserSetWindowFNID(hwnd, FNID_CLEANEDUP_BIT);

        break;

    default:
CallDWP:
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
    }
    return 0L;
}

/***************************************************************************\
*
\***************************************************************************/

LRESULT WINAPI MDIClientWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return 0;
    }

    return MDIClientWndProcWorker(pwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI MDIClientWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return 0;
    }

    return MDIClientWndProcWorker(pwnd, message, wParam, lParam, FALSE);
}


/***************************************************************************\
* DefFrameProc
*
* History:
* 11-14-90 MikeHar      Ported from windows
\***************************************************************************/

LRESULT DefFrameProcWorker(
    HWND hwnd,
    HWND hwndMDI,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fAnsi)
{
    PWND pwnd;
    PWND pwndMDI;
    PMDI pmdi;
    TL tlpwndT;
    HWND hwndT;
    PWND pwndT;
    PMDINEXTMENU pmnm;
    WINDOWPLACEMENT wp;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }
    CheckLock(pwnd);

    if (hwndMDI == NULL) {
        goto CallDWP;
    }

    if ((pwndMDI = ValidateHwnd(hwndMDI)) == NULL) {
        return (0L);
    }
    CheckLock(pwndMDI);

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwndMDI)->pmdi;

    switch (wMsg) {

    /*
     * If there is a maximized child window, add it's window text...
     */
    case WM_SETTEXT: {
        LPWSTR lpwsz = NULL;

        if (fAnsi && lParam) {
            if (!MBToWCS((LPSTR)lParam, -1, &lpwsz, -1, TRUE))
                return 0;
            lParam = (LPARAM)lpwsz;
        }
        xxxSetFrameTitle(pwnd, pwndMDI, (LPWSTR)lParam);

        if (lpwsz)
            UserLocalFree(lpwsz);
        break;
    }
    case WM_NCACTIVATE:
        SendMessage(hwndMDI, WM_NCACTIVATE, wParam, lParam);
        goto CallDWP;

    case WM_COMMAND:
        if ((UINT)LOWORD(wParam) == (FIRST(pmdi) + MAXITEMS -1)) {

            /*
             * selected the More...  item
             */
            if (fAnsi) {
                wParam = DialogBoxParamA(hmodUser,
                                         MAKEINTRESOURCEA(IDD_MDI_ACTIVATE),
                                         hwnd,
                                         MDIActivateDlgProcA,
                                         (LPARAM)pwndMDI);
            } else {
                wParam = DialogBoxParamW(hmodUser,
                                         MAKEINTRESOURCEW(IDD_MDI_ACTIVATE),
                                         hwnd,
                                         MDIActivateDlgProcW,
                                         (LPARAM)pwndMDI);
            }
            if ((int)wParam >= 0) {
                wParam += FIRST(pmdi);
                goto ActivateTheChild;
            }
        } else if (((UINT)LOWORD(wParam) >= FIRST(pmdi)) &&
                ((UINT)LOWORD(wParam) < FIRST(pmdi) + CKIDS(pmdi))) {
ActivateTheChild:
            pwndT = FindPwndChild(pwndMDI, (UINT)LOWORD(wParam));
            ThreadLock(pwndT, &tlpwndT);

            SendMessage(hwndMDI, WM_MDIACTIVATE, (WPARAM)HW(pwndT), 0L);

            /*
             * if minimized, restore it.
             */
            if (pwndT != NULL && TestWF(pwndT, WFMINIMIZED))
                    //
                    // Fix for B#1510.  Don't restore directly.  Send child
                    // a restore message.
                    //
                SendMessage(HWq(pwndT), WM_SYSCOMMAND, (WPARAM)SC_RESTORE, 0L);
            ThreadUnlock(&tlpwndT);
            break;
        }

        switch (wParam & 0xFFF0) {

        /*
         * System menu commands on a maxed mdi child
         */
        case SC_SIZE:
        case SC_MOVE:
        case SC_RESTORE:
        case SC_CLOSE:
        case SC_NEXTWINDOW:
        case SC_PREVWINDOW:
        case SC_MINIMIZE:
        case SC_MAXIMIZE:
            hwndT = MAXED(pmdi);
            if (hwndT != NULL) {
                PWND pwndT = ValidateHwnd(hwndT);
                if (pwndT == NULL)
                    break;
                if ((wParam & 0xFFF0) == SC_CLOSE) {
                    /*
                     * Since the window is maxed, we've cleared WFSYSMENU (see
                     *  MDIAddSysMenu). We need to set it back here so GetSysMenuHandle
                     *  will do the right thing for _MNCanClose.
                     */
                    BOOL fCanClose;
                    UserAssert(!TestWF(pwndT, WFSYSMENU) && (pwndT->spmenuSys != NULL));
                    SetWindowState(pwndT, WFSYSMENU);
                    fCanClose = xxxMNCanClose(pwndT);
                    ClearWindowState(pwndT, WFSYSMENU);
                    if (!fCanClose) {
                        break;
                    }
                } else if (((wParam & 0xFFF0) == SC_MINIMIZE) && !TestWF(pwndT, WFMINBOX)) {
                    break;
                }

                return SendMessage(hwndT, WM_SYSCOMMAND, wParam, lParam);
            }
        }
        goto CallDWP;

    case WM_SIZE:
        if (wParam != SIZEICONIC) {
            NtUserMoveWindow(hwndMDI, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
        } else {
            wp.length = sizeof(WINDOWPLACEMENT);
            if (GetWindowPlacement(hwnd, &wp)) {
                RECT rcT;
                int  clB;

               /*
                * If frame is iconic, size mdi win to be size of restored
                * frame's client area.  Thus mdi children etc created in here
                * use the proper mdiclient size.
                */
               clB = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, TRUE);

               CopyInflateRect(&rcT, &wp.rcNormalPosition,
                        -clB*SYSMET(CXBORDER), -clB*SYSMET(CYBORDER));

               if (TestWF(pwnd, WFBORDERMASK) == LOBYTE(WFCAPTION))
                       rcT.top += SYSMET(CYCAPTION);
               rcT.top += SYSMET(CYMENU);

               NtUserMoveWindow(hwndMDI, 0, 0, rcT.right-rcT.left,
                       rcT.bottom-rcT.top, TRUE);
            }
        }
        goto CallDWP;

    case WM_SETFOCUS:
        NtUserSetFocus(hwndMDI);
        break;

    case WM_NEXTMENU:
        if (TestWF(pwnd, WFSYSMENU) && !TestWF(pwnd, WFMINIMIZED) &&
            ACTIVE(pmdi) && !MAXED(pmdi))
        {
            PMENU pmenuIn;
            /*
             * Go to child system menu by wrapping to the left from
             * the first popup in the menu bar or to the right from
             * the frame sysmenu.
             */
            pmnm = (PMDINEXTMENU)lParam;
            pmenuIn = RevalidateHmenu(pmnm->hmenuIn);

            if (pmenuIn && ((wParam == VK_LEFT && pmenuIn == REBASE(pwnd, spmenu)) ||
                    (wParam == VK_RIGHT && pmnm->hmenuIn ==
                    NtUserGetSystemMenu(hwnd, FALSE)))) {

                HMENU hmenu;
                PWND pwndActive;

                //
                // Make sure the window is still valid
                //
                if ((pwndActive = ValidateHwnd(ACTIVE(pmdi))) == NULL) {
                    return 0;
                }

                //
                // Make sure the child's system menu items are updated
                // (i.e. the ones are enabled/disabled)
                //
                if (!TestWF(pwndActive,WFMAXIMIZED)) {
                    NtUserSetSysMenu(ACTIVE(pmdi));
                }

                hmenu = NtUserGetSystemMenu(ACTIVE(pmdi), FALSE);
                pmnm->hmenuNext = hmenu;
                pmnm->hwndNext = ACTIVE(pmdi);

                return TRUE;
            }
        }

        /*
         * default behaviour
         */
        return 0L;

    case WM_MENUCHAR:
        if (!TestWF(pwnd, WFMINIMIZED) && LOWORD(wParam) == TEXT('-')) {
            if (MAXED(pmdi))
                return MAKELONG(0, 2);
            else if (ACTIVE(pmdi)) {
              PostMessage(ACTIVE(pmdi), WM_SYSCOMMAND,
                    SC_KEYMENU, MAKELONG(TEXT('-'), 0));
              return MAKELONG(0, 1);
          }
        }

        /*
         ** FALL THRU **
         */

    default:
CallDWP:
        return DefWindowProcWorker(pwnd, wMsg, wParam, lParam, fAnsi);
    }

    return 0L;
}



FUNCLOG5(LOG_GENERAL, LRESULT, WINAPI, DefFrameProcW, HWND, hwnd, HWND, hwndMDIClient, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI DefFrameProcW(
    HWND hwnd,
    HWND hwndMDIClient,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return DefFrameProcWorker(hwnd, hwndMDIClient, message, wParam, lParam,
                              FALSE);
}


FUNCLOG5(LOG_GENERAL, LRESULT, WINAPI, DefFrameProcA, HWND, hwnd, HWND, hwndMDIClient, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI DefFrameProcA(
    HWND hwnd,
    HWND hwndMDIClient,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return DefFrameProcWorker(hwnd, hwndMDIClient, message, wParam,
                              lParam, TRUE);
}


/***************************************************************************\
* ChildMinMaxInfo
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

void ChildMinMaxInfo(
    PWND pwnd,
    PMINMAXINFO pmmi)
{
    PWND pwndParent = REBASEPWND(pwnd, spwndParent);
    RECT rc;

    UserAssert(GETFNID(pwnd) != FNID_DESKTOP);

    CopyRect(&rc, KPRECT_TO_PRECT(&pwndParent->rcClient));
    _ScreenToClient(pwndParent, (LPPOINT)&rc.left);
    _ScreenToClient(pwndParent, (LPPOINT)&rc.right);

    /*
     * Swap the left and right if pwnd is a mirrored window.
     */
    if (TestWF(pwnd, WEFLAYOUTRTL)) {
       int nSaveLeft;

       nSaveLeft = rc.left;
       rc.left   = rc.right;
       rc.right  = nSaveLeft;
    }

    RealAdjustWindowRectEx(&rc, pwnd->style, FALSE, pwnd->ExStyle);

    /*
     * Position...
     */
    pmmi->ptMaxPosition.x = rc.left;
    pmmi->ptMaxPosition.y = rc.top;
    pmmi->ptMaxSize.x = rc.right - rc.left;
    pmmi->ptMaxSize.y = rc.bottom - rc.top;
}


/***************************************************************************\
* xxxChildResize
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

void xxxChildResize(
    PWND pwnd,
    UINT wMode)
{
    PWND pwndT;
    PWND pwndMDI = REBASEPWND(pwnd, spwndParent);
    PWND pwndFrame = REBASEPWND(pwndMDI, spwndParent);
    HWND hwndOldActive;
    PMDI pmdi;
    HWND hwndActive;
    TL tlpwndMDI;
    TL tlpwndFrame;
    TL tlpwndT;
    PMENU pmenu;
    HWND hwnd = HWq(pwnd);

    CheckLock(pwnd);

    NtUserSetSysMenu(hwnd);

    ThreadLock(pwndMDI, &tlpwndMDI);
    ThreadLock(pwndFrame, &tlpwndFrame);

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwndMDI)->pmdi;
    pmenu = REBASE(pwndFrame, spmenu);

    if (MAXED(pmdi) == hwnd && wMode != SIZEFULLSCREEN) {
        /*
         * Restoring the current maximized window...
         * Remove the system menu from the Frame window.
         */
        if (!(SCROLL(pmdi) & OTHERMAXING)) {
            Unlock(&MAXED(pmdi));
            MDIRemoveSysMenu(PtoH(pmenu), hwnd);
            Unlock(&MAXED(pmdi));
            xxxSetFrameTitle(pwndFrame, pwndMDI, (LPWSTR)1L);
        }
    }

    if (wMode == SIZEFULLSCREEN) {

        /*
         * Already maximized?
         */
        if (hwnd == MAXED(pmdi))
            goto Exit;

        /*
         * Maximizing this window...
         */

        pmdi->wScroll |= OTHERMAXING | SCROLLCOUNT;

        if (hwndOldActive = MAXED(pmdi)) {
            SendMessage(hwndOldActive, WM_SETREDRAW, FALSE, 0L);
            MDIRemoveSysMenu(PtoH(pmenu), hwndOldActive);
            NtUserMinMaximize(hwndOldActive, SW_MDIRESTORE, FALSE);
            SendMessage(hwndOldActive, WM_SETREDRAW, TRUE, 0L);
        }

        Lock(&MAXED(pmdi), hwnd);

        /*
         * Add the system menu to the Frame window.
         */
        MDIAddSysMenu(PtoH(pmenu), hwnd);
        xxxSetFrameTitle(pwndFrame, pwndMDI, (LPWSTR)1L);

        pmdi->wScroll &= ~(OTHERMAXING | SCROLLCOUNT);
    }

    if (wMode == SIZEICONIC) {
        for (pwndT = REBASEPWND(pwndMDI, spwndChild); pwndT;
                pwndT = REBASEPWND(pwndT, spwndNext)) {
            if (!pwndT->spwndOwner && TestWF(pwndT, WFVISIBLE))
                break;
        }

        hwndActive = NtUserQueryWindow(hwnd, WindowActiveWindow);
        if ((pwndT != NULL) && (hwndActive != NULL) &&
                IsChild(hwndActive, HWq(pwndMDI))) {
            ThreadLockAlways(pwndT, &tlpwndT);
            SendMessage(HWq(pwndT), WM_CHILDACTIVATE, 0, 0L);
            ThreadUnlock(&tlpwndT);
        }
    }

    if (!(SCROLL(pmdi) & SCROLLCOUNT))
        RecalculateScrollRanges(pwndMDI, FALSE);

Exit:
    ThreadUnlock(&tlpwndFrame);
    ThreadUnlock(&tlpwndMDI);
}


/***************************************************************************\
* DefMDIChildProc
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

LRESULT DefMDIChildProcWorker(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fAnsi)
{
    PWND pwnd;
    PWND pwndParent;
    PMDI pmdi;
    PMDINEXTMENU pmnm;
    HWND hwndT;
    PWND pwndT;
    TL tlpwndT;
    TL tlpwndParent;
    LRESULT lRet;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    CheckLock(pwnd);

    /*
     * Check to see if this is a real mdi child window
     */
    pwndParent = REBASEPWND(pwnd, spwndParent);
    if (!pwndParent || GETFNID(pwndParent) != FNID_MDICLIENT) {
        RIPERR0(ERROR_NON_MDICHILD_WINDOW, RIP_VERBOSE, "");
        return DefWindowProcWorker(pwnd, wMsg, wParam, lParam, fAnsi);
    }

    /*
     * Get a pointer to the MDI structure, if it still exists
     */
    pmdi = ((PMDIWND)pwndParent)->pmdi;
    if ((ULONG_PTR)pmdi == (ULONG_PTR)-1) {
        goto CallDWP;
    }

    switch (wMsg) {
    case WM_SETFOCUS:
        if (DIFFWOWHANDLE(hwnd, ACTIVE(pmdi))) {
            ThreadLockAlways(pwndParent, &tlpwndParent);
            xxxMDIActivate(pwndParent, pwnd);
            ThreadUnlock(&tlpwndParent);
        }
        goto CallDWP;

    case WM_NEXTMENU:

        /*
         * wrap to the frame menu bar, either left to the system menu,
         * or right to the frame menu bar.
         */
        pmnm = (PMDINEXTMENU)lParam;
        pwndT = REBASEPWND(pwndParent, spwndParent);
        pmnm->hwndNext = HW(pwndT);
        pmnm->hmenuNext = (wParam == VK_LEFT) ?
                NtUserGetSystemMenu(pmnm->hwndNext, FALSE) :
                GetMenu(pmnm->hwndNext);
        return TRUE;
#if 0
             hWnd->hwndParent->hwndParent
        return (LONG)(((wParam == VK_LEFT) ?
                NtUserGetSystemMenu(HW(pwndT), FALSE):
                pwndT->spmenu)
          );
// return MAKELONG(NtUserGetSystemMenu(ACTIVE(pwndMDI), FALSE),
// ACTIVE(pwndMDI));
#endif
    case WM_CLOSE:
        hwndT = GetParent(hwnd);
        if (hwndT != NULL) {
            SendMessage(hwndT, WM_MDIDESTROY, (WPARAM)hwnd, 0L);
        }
        break;

    case WM_MENUCHAR:
        PostMessage(GetParent(GetParent(hwnd)), WM_SYSCOMMAND,
                (DWORD)SC_KEYMENU, (LONG)LOWORD(wParam));
        return 0x10000;

    case WM_SETTEXT:
        DefWindowProcWorker(pwnd, wMsg, wParam, lParam, fAnsi);
        if (WINDOW(pmdi))
            ModifyMenuItem(pwnd);

        if (TestWF(pwnd, WFMAXIMIZED)) {

            /*
             * Add the child's window text to the frame since it is
             * maximized.  But just redraw the caption so pass a 3L.
             */
            pwndT = REBASEPWND(pwndParent, spwndParent);
            ThreadLock(pwndT, &tlpwndT);
            ThreadLock(pwndParent, &tlpwndParent);
            xxxSetFrameTitle(pwndT, pwndParent, (LPWSTR)3L);
            ThreadUnlock(&tlpwndParent);
            ThreadUnlock(&tlpwndT);
        }
        break;

    case WM_GETMINMAXINFO:
        ChildMinMaxInfo(pwnd, (PMINMAXINFO)lParam);
        break;

    case WM_SIZE:
        xxxChildResize(pwnd, (UINT)wParam);
        goto CallDWP;

    case WM_MOVE:
        if (!TestWF(pwnd, WFMAXIMIZED))
            RecalculateScrollRanges(pwndParent, FALSE);
        goto CallDWP;

    case WM_CHILDACTIVATE:
        ThreadLock(pwndParent, &tlpwndParent);
        xxxMDIActivate(pwndParent, pwnd);
        ThreadUnlock(&tlpwndParent);
        break;

    case WM_SYSCOMMAND:
        switch (wParam & 0xFFF0) {
        case SC_NEXTWINDOW:
        case SC_PREVWINDOW:
            hwndT = GetParent(hwnd);
            SendMessage(hwndT, WM_MDINEXT, (WPARAM)hwnd,
                    (DWORD)((wParam & 0xFFF0) == SC_PREVWINDOW));
            break;

        case SC_SIZE:
        case SC_MOVE:
            if (SAMEWOWHANDLE(hwnd, MAXED(pmdi))) {

                /*
                 * If a maxed child gets a size or move message, blow it
                 * off.
                 */
                break;
            } else
                goto CallDWP;

        case SC_MAXIMIZE:
            if (SAMEWOWHANDLE(hwnd, MAXED(pmdi))) {

                /*
                 * If a maxed child gets a maximize message, forward it
                 * to the frame.  Useful if the maximized child has a
                 * size box so that clicking on it then maximizes the
                 * parent.
                 */
                pwndT = REBASEPWND(pwndParent, spwndParent);
                ThreadLock(pwndT, &tlpwndT);
                lRet = SendMessage(HW(pwndT),
                        WM_SYSCOMMAND, SC_MAXIMIZE, lParam);
                ThreadUnlock(&tlpwndT);
                return lRet;
            }

            /*
             * else fall through
             */

        default:
            goto CallDWP;
        }
        break;

    default:
CallDWP:
        return DefWindowProcWorker(pwnd, wMsg, wParam, lParam, fAnsi);
    }

    return 0L;
}


/***************************************************************************\
* DefMDIChildProc
*
* Translates the message, calls DefMDIChildProc on server side.
*
* 04-11-91 ScottLu Created.
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, LRESULT, WINAPI, DefMDIChildProcW, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI DefMDIChildProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return DefMDIChildProcWorker(hwnd, message, wParam, lParam, FALSE);
}


FUNCLOG4(LOG_GENERAL, LRESULT, WINAPI, DefMDIChildProcA, HWND, hwnd, UINT, message, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI DefMDIChildProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return DefMDIChildProcWorker(hwnd, message, wParam, lParam, TRUE);
}

BOOL MDICompleteChildCreation(HWND hwndChild, HMENU hSysMenu, BOOL fVisible, BOOL fDisabled) {
    PWND pwndChild;
    PWND  pwndClient;
    HWND  hwndClient;
    BOOL  fHasOwnSysMenu;
    PMDI pmdi;

    pwndChild = ValidateHwnd(hwndChild);
    pwndClient = REBASEPWND(pwndChild,spwndParent);
    hwndClient = HWq(pwndClient);

    fHasOwnSysMenu = (pwndChild->spmenuSys) ? TRUE : FALSE;

    pmdi = ((PMDIWND)(pwndClient))->pmdi;

    CKIDS(pmdi)++;
    ITILELEVEL(pmdi)++;
    if (ITILELEVEL(pmdi) > 0x7ffe)
        ITILELEVEL(pmdi) = 0;

    // Update "Window" menu if this new window should be on it
    if (fVisible && !fDisabled && (CKIDS(pmdi) <= MAXITEMS))
        SendMessage(hwndClient, WM_MDIREFRESHMENU, 0, 0L);

    //
    // Add the MDI System Menu.  Catch the case of not being able to add a
    // system menu (EG, guy doesn't have WS_SYSMENU style), and delete the
    // menu to avoid buildup in USER's heap.
    //
    if (hSysMenu && (fHasOwnSysMenu || !NtUserSetSystemMenu(hwndChild, hSysMenu)))
        NtUserDestroyMenu(hSysMenu);

    if (fVisible)
    {
        if (!TestWF(pwndChild, WFMINIMIZED) || !ACTIVE(pmdi))
        {
            NtUserSetWindowPos(hwndChild, HWND_TOP, 0, 0, 0, 0,
                    SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

            if (TestWF(pwndChild, WFMAXIMIZED) && !fHasOwnSysMenu)
            {
                PWND pwndParent = REBASEPWND(pwndClient, spwndParent);
                PMENU pmenu = REBASE(pwndParent, spmenu);
                MDIAddSysMenu(PtoH(pmenu), hwndChild);
                NtUserRedrawFrame(HW(pwndParent));
            }
        }
        else
        {
            NtUserShowWindow(hwndChild, SW_SHOWMINNOACTIVE);
        }
    }


    return TRUE;
}


BOOL
CreateMDIChild(
        PSHORTCREATE        psc,
        LPMDICREATESTRUCT   pmcs,
        DWORD               dwExpWinVerAndFlags,
        HMENU *             phSysMenu,
        PWND                pwndParent)
{
    BOOL fVisible;
    RECT rcT;
    HMENU hSysMenu = NULL;
    HWND hwndPrevMaxed;
    PMDI pmdi;

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)(pwndParent))->pmdi;

    pmcs->style = psc->style;

    // Mask off ignored style bits and add required ones.
    psc->style |= (WS_CHILD | WS_CLIPSIBLINGS);
    if (!(pwndParent->style & MDIS_ALLCHILDSTYLES))
    {
        psc->style &= WS_MDIALLOWED;
        psc->style |= (WS_MDISTYLE | WS_VISIBLE);
    }
    else if (psc->style & WS_POPUP)
    {
        RIPMSG0(RIP_ERROR, "CreateWindowEx: WS_POPUP not allowed on MDI children");
        if (LOWORD(dwExpWinVerAndFlags) >= VER40)
            return FALSE;
    }

    fVisible = ((psc->style & WS_VISIBLE) != 0L);

    //
    // Save ORIGINAL parameters in MDICREATESTRUCT.  This is for
    // compatibility with old WM_MDICREATE.
    //
    pmcs->x   = rcT.left   = psc->x;
    pmcs->y   = rcT.top    = psc->y;
    pmcs->cx  = rcT.right  = psc->cx;
    pmcs->cy  = rcT.bottom = psc->cy;

    MDICheckCascadeRect(pwndParent, &rcT);

    //
    // Setup creation coords
    //
    psc->x       = rcT.left;
    psc->y       = rcT.top;
    psc->cx      = rcT.right;
    psc->cy      = rcT.bottom;

    // Load the system menu
    if (psc->style & WS_SYSMENU) {
#ifdef LAME_BUTTON
        hSysMenu = xxxLoadSysMenu(CHILDSYSMENU, NULL);
#else
        hSysMenu = xxxLoadSysMenu(CHILDSYSMENU);
#endif // LAME_BUTTON

        if (hSysMenu == NULL) {
            return FALSE;
        }
    }


    // The window got created ok: now restore the current maximized window
    // so we can maximize ourself in its place.
    hwndPrevMaxed = MAXED(pmdi);
    if (fVisible && IsWindow(hwndPrevMaxed))
    {
        if (psc->style & WS_MAXIMIZE)
            SendMessage(hwndPrevMaxed, WM_SETREDRAW, (WPARAM)FALSE, 0L);

        // we could nuke the hwndPrevMaxed during the SendMessage32
        // so recheck just in case, B#11122, [t-arthb]

        if ( IsWindow(hwndPrevMaxed) )
        {
            NtUserMinMaximize(hwndPrevMaxed, SW_SHOWNORMAL, TRUE);

            if ( psc->style & WS_MAXIMIZE )
               SendMessage(hwndPrevMaxed, WM_SETREDRAW, (WPARAM)TRUE, 0L);
        }

    }

    // Set the proper Child Window ID for this MDI child.
    psc->hMenu = (HMENU)UIntToPtr( (FIRST(pmdi) + CKIDS(pmdi)) );

    *phSysMenu = hSysMenu;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\menuddc.c ===
/****************************** Module Header ******************************\
* Module Name: menudd.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu drag and drop - client
*
* History:
* 10/29/96  GerardoB    Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop

/*
 * OLE's GUID initialization
 */
#include "initguid.h"

/*
 * Macro to cast OLE's IDropTarget pointer to internal pointer
 */
#define PMNIDT(pdt) ((PMNIDROPTARGET)pdt)

/*
 * The mndt* functions implement the IDropTarget interface
 */
/**************************************************************************\
* mndtAddRef
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
ULONG mndtAddRef(LPDROPTARGET pdt)
{
    return ++(PMNIDT(pdt)->dwRefCount);
}

/**************************************************************************\
* mndtQueryInterface
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
HRESULT mndtQueryInterface(LPDROPTARGET pdt, REFIID riid, PVOID * ppvObj)
{
    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IDropTarget)) {
        mndtAddRef(pdt);
        *ppvObj = pdt;
        return NOERROR;
    } else {
        return E_NOINTERFACE;
    }
}


/**************************************************************************\
* mndtRelease
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
ULONG mndtRelease(LPDROPTARGET pdt)
{
    if (--(PMNIDT(pdt)->dwRefCount) != 0) {
        return PMNIDT(pdt)->dwRefCount;
    }

    LocalFree(pdt);
    return NOERROR;
}

/**************************************************************************\
* mndtDragOver
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
HRESULT mndtDragOver(LPDROPTARGET pdt, DWORD grfKeyState, POINTL ptl, LPDWORD pdwEffect)
{
    MNDRAGOVERINFO mndoi;
    MENUGETOBJECTINFO mngoi;

    /*
     * Get the dragover info for the selection corresponding to this point
     */
    if (!NtUserMNDragOver((POINT *)&ptl, &mndoi)) {
        RIPMSG0(RIP_WARNING, "mndtDragOver: NtUserDragOver failed");
        *pdwEffect = DROPEFFECT_NONE;
        return NOERROR;
    }

    /*
     * If not switching items or crossing gap boundaries, pass the
     *  the drag over.
     */
    if (!(mndoi.dwFlags & MNGOF_CROSSBOUNDARY)) {
        if (PMNIDT(pdt)->pidt != NULL) {
            return PMNIDT(pdt)->pidt->lpVtbl->DragOver(PMNIDT(pdt)->pidt, grfKeyState, ptl, pdwEffect);
        }
    } else {
        /*
         *  DragLeave and Release the current item, if any
         */
        if (PMNIDT(pdt)->pidt != NULL) {
            PMNIDT(pdt)->pidt->lpVtbl->DragLeave(PMNIDT(pdt)->pidt);
            PMNIDT(pdt)->pidt->lpVtbl->Release(PMNIDT(pdt)->pidt);
            PMNIDT(pdt)->pidt = NULL;
        }

        /*
         * If an item is selected, Get the interface for it
         */
        if (mndoi.uItemIndex != MFMWFP_NOITEM) {
            mngoi.hmenu = mndoi.hmenu;
            mngoi.dwFlags = mndoi.dwFlags & MNGOF_GAP;
            mngoi.uPos = mndoi.uItemIndex;
            mngoi.riid = (PVOID)&IID_IDropTarget;
            mngoi.pvObj = NULL;

            if (MNGO_NOERROR == SendMessage(mndoi.hwndNotify, WM_MENUGETOBJECT, 0, (LPARAM)&mngoi)) {
                PMNIDT(pdt)->pidt = mngoi.pvObj;
            }
        }

        /*
         * If we got a new interface, AddRef and DragEnter it
         */
        if (PMNIDT(pdt)->pidt != NULL) {
            PMNIDT(pdt)->pidt->lpVtbl->AddRef(PMNIDT(pdt)->pidt);
            return PMNIDT(pdt)->pidt->lpVtbl->DragEnter(PMNIDT(pdt)->pidt, PMNIDT(pdt)->pido, grfKeyState, ptl, pdwEffect);
        }
    } /* if (!(mndoi.dwFlags & MNGOF_CROSSBOUNDARY)) */

    *pdwEffect = DROPEFFECT_NONE;
    return NOERROR;
}
/**************************************************************************\
* mndtDragEnter
*
* 10/28/96 GerardoB     Created
\**************************************************************************/

HRESULT mndtDragEnter(LPDROPTARGET pdt, LPDATAOBJECT pdo, DWORD grfKeyState, POINTL ptl, LPDWORD pdwEffect)
{
    /*
     * Save the IDataObject
     */
    PMNIDT(pdt)->pido = pdo;

    /*
     * DragEnter is the same as a DragOver; only that we will never fail it
     */
    mndtDragOver(pdt, grfKeyState, ptl, pdwEffect);

    return NOERROR;
}
/**************************************************************************\
* mndtDragLeave
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
HRESULT mndtDragLeave(LPDROPTARGET pdt)
{
    /*
     * Let the kernel mode clean up
     */
    NtUserMNDragLeave();

    /*
     *  DragLeave and Release the current item, if any
     */
    if (PMNIDT(pdt)->pidt != NULL) {
        PMNIDT(pdt)->pidt->lpVtbl->DragLeave(PMNIDT(pdt)->pidt);
        PMNIDT(pdt)->pidt->lpVtbl->Release(PMNIDT(pdt)->pidt);
        PMNIDT(pdt)->pidt = NULL;
    }

    return NOERROR;
}

/**************************************************************************\
* mndtDrop
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
HRESULT mndtDrop(LPDROPTARGET pdt, LPDATAOBJECT pdo, DWORD grfKeyState, POINTL ptl, LPDWORD pdwEffect)
{
    HRESULT hres;

    /*
     * If we got a target, pass the drop and release it.
     */
    if (PMNIDT(pdt)->pidt != NULL) {
        hres = PMNIDT(pdt)->pidt->lpVtbl->Drop(PMNIDT(pdt)->pidt, pdo, grfKeyState, ptl, pdwEffect);
        PMNIDT(pdt)->pidt->lpVtbl->Release(PMNIDT(pdt)->pidt);
        PMNIDT(pdt)->pidt = NULL;
    } else {
        *pdwEffect = DROPEFFECT_NONE;
        hres = NOERROR;
    }

    /*
     * Clean up
     */
    mndtDragLeave(pdt);

    return hres;
}

/**************************************************************************\
* Drop target VTable
*
\**************************************************************************/
IDropTargetVtbl idtVtbl = {
    mndtQueryInterface,
    mndtAddRef,
    mndtRelease,
    mndtDragEnter,
    mndtDragOver,
    mndtDragLeave,
    mndtDrop
};
/**************************************************************************\
* __ClientRegisterDragDrop
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
DWORD __ClientRegisterDragDrop(HWND * phwnd)
{
    HRESULT hres = STATUS_UNSUCCESSFUL;
    PMNIDROPTARGET pmnidt;

    /*
     * Allocate the IDropTarget interface struct & additional data
     */
    pmnidt = (PMNIDROPTARGET)LocalAlloc(LPTR, sizeof(MNIDROPTARGET));
    if (pmnidt == NULL) {
        RIPMSG0(RIP_WARNING, "__ClientRegisterDragDrop allocation Failed");
        hres = STATUS_UNSUCCESSFUL;
        goto BackToKernel;
    }

    /*
     * Initialize it
     */
    pmnidt->idt.lpVtbl = &idtVtbl;

    /*
     * Call RegisterDragDrop
     */
    hres = (*(REGISTERDDPROC)gpfnOLERegisterDD)(*phwnd, (LPDROPTARGET)pmnidt);
    if (!SUCCEEDED(hres)) {
        RIPMSG1(RIP_WARNING, "__ClientRegisterDragDrop Failed:%#lx", hres);
    }

BackToKernel:
    return UserCallbackReturn(NULL, 0, hres);
}
/**************************************************************************\
* __ClientRevokeDragDrop
*
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
DWORD __ClientRevokeDragDrop(HWND * phwnd)
{
    HRESULT hres;

    /*
     * Call RevokeDragDrop
     */
    hres = (*(REVOKEDDPROC)gpfnOLERevokeDD)(*phwnd);
    if (!SUCCEEDED(hres)) {
        RIPMSG1(RIP_WARNING, "__ClientRevokeDragDrop Failed:%#lx", hres);
    }

    return UserCallbackReturn(NULL, 0, hres);
}
/**************************************************************************\
* LoadOLEOnce
*
*
* 10/31/96 GerardoB     Created
\**************************************************************************/
NTSTATUS LoadOLEOnce (void) {

    NTSTATUS Status = STATUS_SUCCESS;
    OLEINITIALIZEPROC pfnOLEOleInitialize;

    /*
     * These are the functions that we'll call.
     */
    GETPROCINFO gpi [] = {
        {&((FARPROC)pfnOLEOleInitialize), (LPCSTR)"OleInitialize"},
        {&gpfnOLEOleUninitialize, (LPCSTR)"OleUninitialize"},
        {&gpfnOLERegisterDD, (LPCSTR)"RegisterDragDrop"},
        {&gpfnOLERevokeDD, (LPCSTR)"RevokeDragDrop"},
        {NULL, NULL}
    };

    GETPROCINFO * pgpi = gpi;

    /*
     * We should come here only once
     */
    UserAssert(ghinstOLE == NULL);

    /*
     * Load it
     */
    ghinstOLE = LoadLibrary(L"OLE32.DLL");
    if (ghinstOLE == NULL) {
        RIPMSG1(RIP_WARNING, "LoadOLEOnce: Failed to load OLE32.DLL: %#lx", GetLastError());
        goto OLEWontLoad;
    }

    /*
     * Get the address of all procs
     */
    while (pgpi->ppfn != NULL) {
        *(pgpi->ppfn) = GetProcAddress(ghinstOLE, pgpi->lpsz);
        if (*(pgpi->ppfn) == NULL) {
            RIPMSG2(RIP_WARNING, "LoadOLEOnce: GetProcAddress failed: '%s': %#lx",
                    pgpi->lpsz, GetLastError());
            break;
        }
        pgpi++;
    }

    /*
     * If it got all procs, call OleInitialize
     */
    if (pgpi->ppfn == NULL) {
        Status = (*pfnOLEOleInitialize)(NULL);
        if (SUCCEEDED(Status)) {
            goto BackToKernel;
        } else {
            RIPMSG1(RIP_WARNING, "LoadOLEOnce: OleInitialize failed:%#lx", Status);
        }
    }

    /*
     * Something failed; NULL out all function pointers
     *   free the library and mark hinstOLE so we won't comeback here
     */
    pgpi = gpi;
    while (pgpi->ppfn != NULL) {
        *(pgpi->ppfn) = NULL;
        pgpi++;
    }
    FreeLibrary(ghinstOLE);

OLEWontLoad:
    ghinstOLE = OLEWONTLOAD;
    Status = STATUS_UNSUCCESSFUL;

BackToKernel:
    return Status;
}
/**************************************************************************\
* __ClientLoadOLE
*
*
* 10/31/96 GerardoB     Created
\**************************************************************************/
DWORD __ClientLoadOLE (PVOID p) {

    NTSTATUS Status;

    UNREFERENCED_PARAMETER(p);

    if (ghinstOLE == NULL) {
        Status = LoadOLEOnce();
    } else if (ghinstOLE == OLEWONTLOAD) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        UserAssert(gpfnOLERegisterDD != NULL);
        UserAssert(gpfnOLERevokeDD != NULL);
        Status = STATUS_SUCCESS;
    }

    return UserCallbackReturn(NULL, 0, Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\mdimenu.c ===
//depot/Lab06_N/Windows/Core/ntuser/client/mdimenu.c#1 - branch change 13 (text)
/***************************************************************************\
*
*  MDIMENU.C -
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*      MDI "Window" Menu Support
*
* History
* 11-14-90 MikeHar     Ported from windows
* 14-Feb-1991 mikeke   Added Revalidation code
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* FindPwndChild
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

PWND FindPwndChild(
    PWND pwndMDI,
    UINT wChildID)
{
    PWND pwndT;

    for (pwndT = REBASEPWND(pwndMDI, spwndChild);
            pwndT && (pwndT->spwndOwner || PtrToUlong(pwndT->spmenu) != wChildID);
            pwndT = REBASEPWND(pwndT, spwndNext))
        ;

    return pwndT;
}


/***************************************************************************\
* MakeMenuItem
*
* History:
* 11-14-90 MikeHar Ported from windows
*  4-16-91 Win31 Merge
\***************************************************************************/

int MakeMenuItem(
    LPWSTR lpOut,
    PWND pwnd)
{
    PMDI pmdi;
    DWORD rgParm;
    int cch = 0;
    WCHAR string[160];
    LPWSTR lpstr;
    int i = 0;
    int max = sizeof(string) / sizeof(WCHAR) - 1;

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)(REBASEPWND(pwnd, spwndParent)))->pmdi;

    *lpOut = 0;

    rgParm = PtrToUlong(pwnd->spmenu) - (DWORD)FIRST(pmdi) + 1;

    if (pwnd->strName.Length) {
        lpstr = REBASEALWAYS(pwnd, strName.Buffer);

        /*
         * Search for an & in the title string and duplicate it so that we don't
         * get bogus accelerators.
         */
        while (*lpstr && i < max) {
            string[i] = *lpstr;
            i++;
            if (*lpstr == TEXT('&')) {
                if (i == max) {
                    /*
                     * We're at the end of the string and we need to double this
                     * ampersand. If we do that, we're going to overflow the
                     * buffer below when we NULL-terminate it. We also don't
                     * want to leave a single ampersand - as it'll be mistakenl
                     * used as an accelerator - so move back one character so
                     * that when we NULL-terminate we'll be wiping out the
                     * original ampersand. Bug #35673.
                     */
                    --i;
                    break;
                }
                string[i++] = TEXT('&');
            }

            lpstr++;
        }

        string[i] = 0;
        cch = wsprintfW(lpOut, L"&%d %ws", rgParm, string);

    } else {

        /*
         * Handle the case of MDI children without any window title text.
         */
        cch = wsprintfW(lpOut, L"&%d ", rgParm);
    }

    return cch;
}

/***************************************************************************\
* ModifyMenuItem
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

void ModifyMenuItem(
    PWND pwnd)
{
    PMDI pmdi;
    WCHAR sz[200];
    MENUITEMINFO    mii;
    PWND pwndParent;
    PMENU pmenu;

    /*
     * Get a pointer to the MDI structure
     */
    pwndParent = REBASEPWND(pwnd, spwndParent);
    pmdi = ((PMDIWND)pwndParent)->pmdi;

    if (PtrToUlong(pwnd->spmenu) > FIRST(pmdi) + (UINT)8)
        return;

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_STRING;
    mii.dwTypeData = sz;

    /*
     * Parent is MDI Client.
     */
    MakeMenuItem(sz, pwnd);

    /*
     * Changing the active child?  Check it.
     */
    if (HWq(pwnd) == ACTIVE(pmdi)) {
        mii.fMask |= MIIM_STATE;
        mii.fState = MFS_CHECKED;
    }

    pwndParent = REBASEPWND(pwndParent, spwndParent);

    if (pwndParent->spmenu) {

        /*
         * Bug# 21566. If spmenu is NULL we used to fail
         * because REBASEALWAYS is trying to get the kernel
         * address of NULL based on pwndParent
         */
        pmenu = REBASEALWAYS(pwndParent, spmenu);
        /*
         * Internal call to SetMenuItemInfo
         */
        ThunkedMenuItemInfo(PtoH(pmenu), PtrToUlong(pwnd->spmenu), FALSE, FALSE, &mii, FALSE);
    }
}

/***************************************************************************\
* MDIAddSysMenu
*
* Insert the MDI child's system menu onto the existing Menu.
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

BOOL MDIAddSysMenu(
    HMENU hMenuFrame,
    HWND hwndChild)
{
    PWND pwndChild;
    MENUITEMINFO    mii;
    PMENU pMenuChild;


// LATER -- look at passing pwndChild in -- FritzS

    UserAssert(IsWindow(hwndChild));
    pwndChild = ValidateHwnd(hwndChild);
    if (!hMenuFrame || !pwndChild || !pwndChild->spmenuSys) {
        return FALSE;
    }

    /*
     * We don't need the pMenuChild pointer but the handle. However, if you
     * do PtoH(_GetSubMenu()), you end up calling the function twice
     */
    pMenuChild = _GetSubMenu (REBASEALWAYS(pwndChild, spmenuSys), 0);
    if (!pMenuChild) {
        return FALSE;
    }

// Add MDI system button as first menu item
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_SUBMENU | MIIM_DATA | MIIM_BITMAP;  // Add MIIM_DATA because of hack described below
    mii.hSubMenu = PtoH(pMenuChild);
// Fritzs -- this won't work.
//    mii.dwTypeData = (LPSTR) MAKELONG(MENUHBM_SYSTEM, GetWindowSmIcon(hwndChild));
    mii.hbmpItem = HBMMENU_SYSTEM;
// FritzS -- so, we sneak the icon into ItemData
    mii.dwItemData = (ULONG_PTR)hwndChild;

    if (!InternalInsertMenuItem(hMenuFrame, 0, TRUE, &mii))
        return FALSE;

    // TimeLine 6.1 gets confused by the extra Min/Close buttons,
    // don't add them if WFOLDUI

    mii.fMask = MIIM_ID | MIIM_FTYPE | MIIM_BITMAP;
    mii.fType = MFT_RIGHTJUSTIFY;

    pwndChild = ValidateHwnd(hwndChild);
    if (!pwndChild) {
        NtUserRemoveMenu(hMenuFrame, 0, MF_BYPOSITION);
        return FALSE;
    }


    if (!TestWF(pwndChild, WFOLDUI))
    {
        // Add Minimize button as last menu item
        mii.hbmpItem = (TestWF(pwndChild, WFMINBOX) ? HBMMENU_MBAR_MINIMIZE : HBMMENU_MBAR_MINIMIZE_D);
        mii.wID = SC_MINIMIZE;

        if (!InternalInsertMenuItem(hMenuFrame, MFMWFP_NOITEM, TRUE, &mii))
        {
            NtUserRemoveMenu(hMenuFrame, 0, MF_BYPOSITION);
            return FALSE;
        }
        mii.fType &= ~MFT_RIGHTJUSTIFY;
    }

    // Add Restore button as last menu item
    mii.hbmpItem = HBMMENU_MBAR_RESTORE;
    mii.wID = SC_RESTORE;

    if (!InternalInsertMenuItem(hMenuFrame, MFMWFP_NOITEM, TRUE, &mii)) {
        // BOGUS -- we gotta remove the MINIMIZE button too
        NtUserRemoveMenu(hMenuFrame, 0, MF_BYPOSITION);
        return FALSE;
    }

    pwndChild = ValidateHwnd(hwndChild);
    if (!pwndChild) {
        NtUserRemoveMenu(hMenuFrame, 0, MF_BYPOSITION);
        return FALSE;
    }

    if (!TestWF(pwndChild, WFOLDUI))
    {
        // Add Close button as last menu item
        mii.hbmpItem = (xxxMNCanClose(pwndChild) ? HBMMENU_MBAR_CLOSE : HBMMENU_MBAR_CLOSE_D);
        mii.wID = SC_CLOSE;

        if (!InternalInsertMenuItem(hMenuFrame, MFMWFP_NOITEM, TRUE, &mii))
        {
            // BOGUS -- we gotta remove the MINIMIZE and RESTORE buttons too
            NtUserRemoveMenu(hMenuFrame, 0, MF_BYPOSITION);
            return FALSE;
        }
    }

    /*
     * Set the menu items to proper state since we just maximized it.  Note
     * setsysmenu doesn't work if we've cleared the sysmenu bit so do it now...
     */
    NtUserSetSysMenu(hwndChild);

    /*
     * This is so that if the user brings up the child sysmenu, it's sure
     * to be that in the frame menu bar...
     */
    ClearWindowState(pwndChild, WFSYSMENU);

    /*
     * Make sure that the child's frame is redrawn to reflect the removed
     * system menu.
     */
    MDIRedrawFrame(hwndChild, TRUE);

    return TRUE;
}

/***************************************************************************\
* MDIRemoveSysMenu
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

BOOL MDIRemoveSysMenu(
    HMENU hMenuFrame,
    HWND hwndChild)
{
    int iLastItem;
    UINT    iLastCmd;
    PWND pwndChild;

// LATER -- look at passing pwndChild in -- FritzS

    if (hMenuFrame == NULL)
        return FALSE;

    pwndChild = ValidateHwnd(hwndChild);

    if (pwndChild == NULL)
        return FALSE;

    iLastItem = GetMenuItemCount(hMenuFrame) - 1;
    iLastCmd = TestWF(pwndChild, WFOLDUI) ? SC_RESTORE : SC_CLOSE;

    if ((UINT) GetMenuItemID(hMenuFrame, iLastItem) != iLastCmd)
        return FALSE;

    /*
     * Enable the sysmenu in the child window.
     */
    SetWindowState(pwndChild, WFSYSMENU);

    /*
     * Take the child sysmenu popup out of the frame menu.
     */
    NtUserRemoveMenu(hMenuFrame, 0, MF_BYPOSITION);

    /*
     * Delete the restore button from the menu bar.
     */
    NtUserDeleteMenu(hMenuFrame, iLastItem - 1, MF_BYPOSITION);

    pwndChild = ValidateHwnd(hwndChild);
    if (pwndChild == NULL)
        return FALSE;

    if (!TestWF(pwndChild, WFOLDUI)) {
        NtUserDeleteMenu(hMenuFrame, iLastItem - 2, MF_BYPOSITION);
        NtUserDeleteMenu(hMenuFrame, iLastItem - 3, MF_BYPOSITION);
    }

    /*
     * Make sure that the child's frame is redrawn to reflect the added
     * system menu.
     */
    MDIRedrawFrame(hwndChild, FALSE);

    return TRUE;
}

/***************************************************************************\
* AppendToWindowsMenu
*
* Add the title of the MDI child window 'hwndChild' to the bottom of the
* "Window" menu (or add the "More Windows ..." item) if there's room.
*
*   MDI Child #                    Add
*  -------------          --------------------
*   < MAXITEMS             Child # and Title
*   = MAXITEMS             "More Windows ..."
*   > MAXITEMS             nothing
*
* History:
* 17-Mar-1992 mikeke   from win31
\***************************************************************************/

BOOL FAR PASCAL AppendToWindowsMenu(
    PWND pwndMDI,
    PWND pwndChild)
{
    PMDI pmdi;
    WCHAR szMenuItem[165];
    int item;
    MENUITEMINFO    mii;

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwndMDI)->pmdi;

    item = PtrToUlong(pwndChild->spmenu) - FIRST(pmdi);

    if (WINDOW(pmdi) && (item < MAXITEMS)) {
        mii.cbSize = sizeof(MENUITEMINFO);
        if (!item) {

            /*
             * Add separator before first item
             */
            mii.fMask = MIIM_FTYPE;
            mii.fType = MFT_SEPARATOR;
            if (!InternalInsertMenuItem(WINDOW(pmdi), MFMWFP_NOITEM, TRUE, &mii))
                return FALSE;
        }

        if (item == (MAXITEMS - 1))
            LoadString(hmodUser, STR_MOREWINDOWS, szMenuItem,
                       sizeof(szMenuItem) / sizeof(WCHAR));
        else
            MakeMenuItem(szMenuItem, pwndChild);

        mii.fMask = MIIM_ID | MIIM_STRING;
        mii.wID = PtrToUlong(pwndChild->spmenu);
        mii.dwTypeData = szMenuItem;
        mii.cch = (UINT)-1;
        if (!InternalInsertMenuItem(WINDOW(pmdi), MFMWFP_NOITEM, TRUE, &mii))
            return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* SwitchWindowsMenus
*
* Switch the "Window" menu in the frame menu bar 'hMenu' from
* 'hOldWindow' to 'hNewWindow'
*
* History:
* 17-Mar-1992 mikeke    from win31
\***************************************************************************/

BOOL SwitchWindowsMenus(
    HMENU hmenu,
    HMENU hOldWindow,
    HMENU hNewWindow)
{
    int i;
    HMENU hsubMenu;
    WCHAR szMenuName[128];
    MENUITEMINFO    mii;

    if (hOldWindow == hNewWindow)
        return TRUE;

    mii.cbSize = sizeof(MENUITEMINFO);

    /*
     * Determine position of old "Window" menu
     */
    for (i = 0; hsubMenu = GetSubMenu(hmenu, i); i++) {
        if (hsubMenu == hOldWindow)
        {
            // Extract the name of the old menu to use it for the new menu
            mii.fMask = MIIM_STRING;
            mii.dwTypeData = szMenuName;
            mii.cch = sizeof(szMenuName)/sizeof(WCHAR);
            GetMenuItemInfoInternalW(hmenu, i, TRUE, &mii);
            // Out with the old, in with the new
            if (!NtUserRemoveMenu(hmenu, i, MF_BYPOSITION))
                return(FALSE);

            mii.fMask |= MIIM_SUBMENU;
            mii.hSubMenu = hNewWindow;
            return(InternalInsertMenuItem(hmenu, i, TRUE, &mii));
        }
    }

    return(FALSE);
}

/***************************************************************************\
* ShiftMenuIDs
*
* Shift the id's of the MDI child windows of the MDI client window 'hWnd'
* down by 1 (id--) starting with the child window 'hwndVictim' -- moving
* 'hwndVictim' to the end of the list
*
* History:
* 17-Mar-1992 mikeke   from win31
\***************************************************************************/

void ShiftMenuIDs(
    PWND pwnd,
    PWND pwndVictim)
{
    PMDI pmdi;
    PWND pwndChild;
    PWND pwndParent;
    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwnd)->pmdi;

    pwndParent = REBASEPWND(pwndVictim, spwndParent);
    pwndChild = REBASEPWND(pwndParent, spwndChild);

    while (pwndChild) {
        if (!pwndChild->spwndOwner && (pwndChild->spmenu > pwndVictim->spmenu)) {
            SetWindowLongPtr(HWq(pwndChild), GWLP_ID, PtrToUlong(pwndChild->spmenu) - 1);
        }
        pwndChild = REBASEPWND(pwndChild, spwndNext);
    }

    SetWindowLongPtr(HWq(pwndVictim), GWLP_ID, FIRST(pmdi) + CKIDS(pmdi) - 1);
}

/***************************************************************************\
* MDISetMenu
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

HMENU MDISetMenu(
    PWND pwndMDI,
    BOOL fRefresh,
    HMENU hNewSys,
    HMENU hNewWindow)
{
    int i;
    int iFirst;
    int item;
    PMDI pmdi;
    PWND pwndParent;
    HMENU hOldSys;
    HMENU hOldWindow;
    PWND pwndChild;

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwndMDI)->pmdi;

    /*
     * Save the old values
     */
    pwndParent = REBASEPWND(pwndMDI, spwndParent);
    hOldSys = GetMenu(HW(pwndParent));
    hOldWindow = WINDOW(pmdi);

    if (fRefresh) {
        hNewSys = hOldSys;
        hNewWindow = hOldWindow;
    }

    /*
     * Change the Frame Menu.
     */
    if (hNewSys && (hNewSys != hOldSys)) {
        if (MAXED(pmdi))
            MDIRemoveSysMenu(hOldSys, MAXED(pmdi));

        NtUserSetMenu(HW(pwndParent), hNewSys, FALSE);

        if (MAXED(pmdi))
            MDIAddSysMenu(hNewSys, MAXED(pmdi));
    } else
        hNewSys = hOldSys;

    /*
     * Now update the Window menu.
     */
    if (fRefresh || (hOldWindow != hNewWindow)) {
        iFirst = FIRST(pmdi);

        if (hOldWindow) {
            int cItems = GetMenuItemCount(hOldWindow);

            for (i = cItems - 1; i >= 0; i--) {
                if (GetMenuState(hOldWindow, i, MF_BYPOSITION) & MF_SEPARATOR)
                   break;
            }
            if ((i >= 0) && (GetMenuItemID(hOldWindow, i + 1) == (UINT)iFirst)) {
                int idTrim = i;

                for (i = idTrim; i < cItems; i++)
                    NtUserDeleteMenu(hOldWindow, idTrim, MF_BYPOSITION);
            }
        }

        Lock(&WINDOW(pmdi), hNewWindow);

        if (hNewWindow != NULL) {

           /*
            * Add the list of child windows to the new window
            */
           for (i = 0, item = 0; ((UINT)i < CKIDS(pmdi)) && (item < MAXITEMS);
                    i++) {
               pwndChild = FindPwndChild(pwndMDI, iFirst + item);
               if (pwndChild != NULL) {
                   if ((!TestWF(pwndChild, WFVISIBLE) &&
                          (LOWORD(pwndMDI->style) & 0x0001)) ||
                          TestWF(pwndChild, WFDISABLED)) {
                       ShiftMenuIDs(pwndMDI, pwndChild);
                   } else {
                       AppendToWindowsMenu(pwndMDI, pwndChild);
                       item++;
                   }
               }
           }

           /*
            * Add checkmark by the active child's menu item
            */
           if (ACTIVE(pmdi))
               CheckMenuItem(hNewWindow, (WORD)GetWindowID(ACTIVE(pmdi)),
                       MF_BYCOMMAND | MF_CHECKED);
        }

        /*
         * Out with the old, in with the new
         */
        SwitchWindowsMenus(hNewSys, hOldWindow, hNewWindow);
    }
    return hOldSys;
}

/***************************************************************************\
* xxxInitActivateDlg
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

void xxxInitActivateDlg(
    HWND hwnd,
    PWND pwndMDI)
{
    PMDI pmdi;
    UINT wKid;
    HWND hwndT;
    PWND pwndT;
    WCHAR szTitle[CCHTITLEMAX];
    TL tlpwndT;
    SIZE Size;
    HDC hDC;
    DWORD width = 0;

    CheckLock(pwndMDI);

    /*
     * Get a pointer to the MDI structure
     */
    pmdi = ((PMDIWND)pwndMDI)->pmdi;

    hDC = NtUserGetDC(hwnd);

    /*
     * Insert the list of titles.
     * Note the wKid-th item in the listbox has ID wKid+FIRST(pwnd), so that
     * the listbox is in creation order (like the menu).  This is also
     * helpful when we go to select one...
     */

    for (wKid = 0; wKid < CKIDS(pmdi); wKid++) {
        pwndT = FindPwndChild(pwndMDI, (UINT)(wKid + FIRST(pmdi)));

        if (pwndT && TestWF(pwndT, WFVISIBLE) && !TestWF(pwndT, WFDISABLED)) {
            ThreadLockAlways(pwndT, &tlpwndT);
            GetWindowText(HWq(pwndT), szTitle, CCHTITLEMAX);
            SendDlgItemMessage(hwnd, 100, LB_ADDSTRING, 0, (LPARAM)szTitle);
            GetTextExtentPoint(hDC, szTitle, lstrlen(szTitle), &Size);
            if (Size.cx > (LONG)width) {
                width = Size.cx;
            }
            ThreadUnlock(&tlpwndT);
        }
    }

    /*
     * Select the currently active window.
     */
    SendDlgItemMessage(hwnd, 100, LB_SETTOPINDEX, MAXITEMS - 1, 0L);
    SendDlgItemMessage(hwnd, 100, LB_SETCURSEL, MAXITEMS - 1, 0L);

    /*
     * Set the horizontal extent of the list box to the longest window title.
     */
    SendDlgItemMessage(hwnd, 100, LB_SETHORIZONTALEXTENT, width, 0L);
    NtUserReleaseDC(hwnd, hDC);

    /*
     * Set the focus to the listbox.
     */
    hwndT = GetDlgItem(hwnd, 100);
    NtUserSetFocus(hwndT);
}

/***************************************************************************\
* MDIActivateDlgSize
*
* The minimum allowed size and the previous one are saved as properties
* of the parent window.
*
* History:
* Oct 97 MCostea Created
\***************************************************************************/

VOID MDIActivateDlgSize(HWND hwnd, int width, int height)
{
    PMDIACTIVATEPOS pPos;
    PWND pwnd, pwndList, pwndButtonLeft, pwndButtonRight;
    HDWP hdwp;
    int  deltaX, deltaY;

    pPos = (PMDIACTIVATEPOS)GetProp(GetParent(hwnd), MAKEINTATOM(atomMDIActivateProp));
    if (pPos == NULL) {
        return;
    }

    /*
     * Retrieve the children
     */
    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return;
    }
    pwndList = REBASEPWND(pwnd, spwndChild);
    pwndButtonLeft  = REBASEPWND(pwndList, spwndNext);
    pwndButtonRight = REBASEPWND(pwndButtonLeft, spwndNext);

    UserAssert(GETFNID(pwndList) == FNID_LISTBOX);
    UserAssert(GETFNID(pwndButtonLeft) == FNID_BUTTON);
    UserAssert(GETFNID(pwndButtonRight) == FNID_BUTTON);
    UserAssert(pwndButtonRight->rcWindow.left > pwndButtonLeft->rcWindow.left);

    deltaX = width - pPos->cx;
    deltaY = height - pPos->cy;

    pPos->cx = width;
    pPos->cy = height;

    /*
     * Move/resize the child windows accordingly
     */
    hdwp = NtUserBeginDeferWindowPos(3);

    if (hdwp)
    {
        hdwp = NtUserDeferWindowPos( hdwp,
                               PtoH(pwndList),
                               NULL,
                               0,
                               0,
                               deltaX + pwndList->rcWindow.right - pwndList->rcWindow.left,
                               deltaY + pwndList->rcWindow.bottom - pwndList->rcWindow.top,
                               SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE );

        if (hdwp)
        {
            hdwp = NtUserDeferWindowPos(hdwp,
                               PtoH(pwndButtonLeft),
                               NULL,
                               pwndButtonLeft->rcWindow.left - pwnd->rcClient.left,
                               deltaY + pwndButtonLeft->rcWindow.top - pwnd->rcClient.top,
                               0,
                               0,
                               SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );


            if (hdwp)
            {
                hdwp = NtUserDeferWindowPos( hdwp,
                               PtoH(pwndButtonRight),
                               NULL,
                               pwndButtonRight->rcWindow.left - pwnd->rcClient.left,
                               deltaY + pwndButtonRight->rcWindow.top - pwnd->rcClient.top,
                               0,
                               0,
                               SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
            }

        }
        if (hdwp) {
            NtUserEndDeferWindowPosEx(hdwp, FALSE);
        }
    }
}

/***************************************************************************\
* MDIActivateDlgInit
*
* The minimum allowed size and the previous one are saved as properties
* of the parent window.
*
* History:
* Oct 97 MCostea Created
\***************************************************************************/

VOID MDIActivateDlgInit(HWND hwnd, LPARAM lParam)
{
    PMDIACTIVATEPOS pPos;
    HWND  hwndParent;
    RECT  rc;

    xxxInitActivateDlg(hwnd, (PWND)lParam);

    hwndParent = GetParent(hwnd);
    /*
     * Preserve the previous size of the dialog, if any
     */
    if (atomMDIActivateProp == 0) {

        atomMDIActivateProp = AddAtomW(MDIACTIVATE_PROP_NAME);
        UserAssert(atomMDIActivateProp);
    }

    GetWindowRect(hwnd, &rc);

    pPos = (PMDIACTIVATEPOS)GetProp(hwndParent, MAKEINTATOM(atomMDIActivateProp));
    /*
     * If the dialog was used before, retrieve it's size
     */
    if (pPos != NULL) {

        int cxBorder, cyBorder, cx, cy;

        /*
         * The stored size and the ones in WM_SIZE are client window coordinates
         * Need to adjust them for NtUserSetWindowPos and WM_INITDIALOG
         */
        cxBorder = rc.right - rc.left;
        cyBorder = rc.bottom - rc.top;
        GetClientRect(hwnd, &rc);
        cxBorder -= rc.right - rc.left;
        cyBorder -= rc.bottom - rc.top;

        NtUserSetWindowPos(hwnd, NULL, 0, 0,
                           pPos->cx + cxBorder,
                           pPos->cy + cyBorder,
                           SWP_NOMOVE | SWP_NOZORDER | SWP_NOOWNERZORDER
                           | SWP_NOSENDCHANGING | SWP_NOREDRAW);
        cx = pPos->cx;
        cy = pPos->cy;
        pPos->cx = pPos->cxMin - cxBorder;
        pPos->cy = pPos->cyMin - cyBorder;
        MDIActivateDlgSize(hwnd, cx, cy);

    } else {
        /*
         *
         */
        pPos = UserLocalAlloc(0, sizeof(MDIACTIVATEPOS));
        if (pPos == NULL) {
            return;
        }
        pPos->cxMin = rc.right - rc.left;
        pPos->cyMin = rc.bottom - rc.top;

        GetClientRect(hwnd, &rc);
        pPos->cx = rc.right - rc.left;
        pPos->cy = rc.bottom - rc.top;
        SetProp(hwndParent, MAKEINTATOM(atomMDIActivateProp), (HANDLE)pPos);
    }
}

/***************************************************************************\
* MDIActivateDlgProc
*
* History:
* 11-14-90 MikeHar Ported from windows
\***************************************************************************/

INT_PTR MDIActivateDlgProcWorker(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int i;

    switch (wMsg) {

    case WM_INITDIALOG:
        /*
         * NOTE: Code above uses DialogBoxParam, passing pwndMDI in the low
         * word of the parameter...
         */
        MDIActivateDlgInit(hwnd, lParam);
        return FALSE;

    case WM_COMMAND:
        i = -2;

        switch (LOWORD(wParam)) {

        /*
         * Listbox doubleclicks act like OK...
         */
        case 100:
            if (HIWORD(wParam) != LBN_DBLCLK)
                break;

        /*
         ** FALL THRU **
         */
        case IDOK:
            i = (UINT)SendDlgItemMessage(hwnd, 100, LB_GETCURSEL, 0, 0L);

        /*
         ** FALL THRU **
         */
        case IDCANCEL:
            EndDialog(hwnd, i);
            break;
        default:
            return FALSE;
        }
        break;

    case WM_SIZE:
        MDIActivateDlgSize(hwnd, LOWORD(lParam), HIWORD(lParam));
        return FALSE;

    case WM_GETMINMAXINFO:
        {
            PMDIACTIVATEPOS pPos;

            if (pPos = (PMDIACTIVATEPOS)GetProp(GetParent(hwnd), MAKEINTATOM(atomMDIActivateProp))) {
                 ((LPMINMAXINFO)lParam)->ptMinTrackSize.x = pPos->cxMin;
                 ((LPMINMAXINFO)lParam)->ptMinTrackSize.y = pPos->cyMin;
            }
            return FALSE;
        }

    default:
        return FALSE;
    }
    return TRUE;
}

INT_PTR WINAPI MDIActivateDlgProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return MDIActivateDlgProcWorker(hwnd, message, wParam, lParam);
}

INT_PTR WINAPI MDIActivateDlgProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return MDIActivateDlgProcWorker(hwnd, message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\mngrayc.c ===
/****************************** Module Header ******************************\
* Module Name: mngray.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the DrawState API
*
* History:
* 01-05-94  FritzS  Ported from Chicago
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define PATOR               0x00FA0089L
#define SRCSTENCIL          0x00B8074AL
#define SRCINVSTENCIL       0x00E20746L

#define BC_INVERT             0x00000001

void BltColor(HDC hdc, HBRUSH hbr, HDC hdcSrce,int xO, int yO,
       int cx, int cy, int xO1, int yO1, UINT uBltFlags);
/***************************************************************************\
*
*  BitBltSysBmp()
*
*  From Chicago -- client *only* for now.
\***************************************************************************/
BOOL FAR BitBltSysBmp(HDC hdc, int x, int y, UINT i)
{
    POEMBITMAPINFO pOem = gpsi->oembmi + i;

    return(NtUserBitBltSysBmp(hdc, x, y, pOem->cx, pOem->cy, pOem->x, pOem->y, SRCCOPY));
}


/***************************************************************************\
*
*  DrawState()
*
*  Generic state drawing routine.  Does simple drawing into same DC if
*  normal state;  uses offscreen bitmap otherwise.
*
*  We do drawing for these simple types ourselves:
*      (1) Text
*          lData is string pointer.
*          wData is string length
*      (2) Icon
*          LOWORD(lData) is hIcon
*      (3) Bitmap
*          LOWORD(lData) is hBitmap
*      (4) Glyph (internal)
*          LOWORD(lData) is OBI_ value, one of
*              OBI_CHECKMARK
*              OBI_BULLET
*              OBI_MENUARROW
*          right now
*
*  Other types are required to draw via the callback function, and are
*  allowed to stick whatever they want in lData and wData.
*
*  We apply the following effects onto the image:
*      (1) Normal      (nothing)
*      (2) Default     (drop shadow)
*      (3) Union       (gray string dither)
*      (4) Disabled    (embossed)
*
*  Note that we do NOT stretch anything.  We just clip.
*
*
*   FritzS note -- this is client-side *only*.  Similar code is in server\mngray.c
*
*
\***************************************************************************/

FUNCLOG10(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DrawStateW, HDC, hdcDraw, HBRUSH, hbrFore, DRAWSTATEPROC, qfnCallBack, LPARAM, lData, WPARAM, wData, int, x, int, y, int, cx, int, cy, UINT, uFlags)
BOOL DrawStateW(
    HDC             hdcDraw,
    HBRUSH          hbrFore,
    DRAWSTATEPROC   qfnCallBack,
    LPARAM          lData,
    WPARAM          wData,
    int             x,
    int             y,
    int             cx,
    int             cy,
    UINT            uFlags)
{
    HFONT   hFont;
    HFONT   hFontSave = NULL;
    HDC     hdcT;
    HBITMAP hbmpT;
    BOOL    fResult = FALSE;
    DWORD   dwPSMFlags;
    POINT   ptOrg;
    int     oldAlign;
    DWORD   dwLayout = GDI_ERROR;

    if (ghdcGray == NULL)
        return FALSE;

    RtlEnterCriticalSection(&gcsHdc);

    /*
     * These require monochrome conversion
     *
     * Enforce monochrome: embossed doesn't look great with 2 color displays
     */
    if ((uFlags & DSS_DISABLED) &&
        (gpsi->BitCount == 1 || SYSMET(SLOWMACHINE))) {

        uFlags &= ~DSS_DISABLED;
        uFlags |= DSS_UNION;
    }

    if (uFlags & (DSS_DISABLED | DSS_DEFAULT | DSS_UNION))
        uFlags |= DSS_MONO;

    /*
     * Get drawing sizes etc. AND VALIDATE.
     */
    switch (uFlags & DST_TYPEMASK) {

        case DST_GLYPH:

            /*
             * LOWORD(lData) is OBI_ value.
             */
            if (LOWORD(lData) >= (WORD)OBI_COUNT) {
                goto CDS_Leave;
            }

            if (!cx) {
                cx = gpsi->oembmi[LOWORD(lData)].cx;
            }

            if (!cy) {
                cy = gpsi->oembmi[LOWORD(lData)].cy;
            }

            break;

        case DST_BITMAP:

            /*
             * LOWORD(lData) is hbmp.
             */
            if (GetObjectType((HGDIOBJ)lData) != OBJ_BITMAP) {
                goto CDS_Leave;
            }

            if (!cx || !cy) {

                BITMAP bmp;

                GetObjectW((HGDIOBJ)lData, sizeof(BITMAP), &bmp);

                if (!cx)
                    cx = bmp.bmWidth;

                if (!cy)
                    cy = bmp.bmHeight;
            }
            break;

        case DST_ICON:

            /*
             * lData is hicon.
             */
            if (!cx || !cy) {

                int cx1 = 0;
                int cy1 = 0;

                NtUserGetIconSize((HICON)lData, 0, &cx1, &cy1);

                if (!cx)
                    cx = cx1;

                if (!cy)
                    cy = cy1 / 2; // icons are double height in NT
            }
            break;

        case DST_TEXT:

            /*
             * lData is LPSTR
             * NOTE THAT WE DO NOT VALIDATE lData, DUE TO COMPATIBILITY
             * WITH GRAYSTRING().  THIS _SHOULD_ FAULT IF YOU PASS IN NULL.
             *
             * wData is cch.
             */
            if (!wData)
                wData = wcslen((LPWSTR)lData);

            if (!cx || !cy) {

                SIZE size;

                /*
                 * Make sure we use right dc w/ right font.
                 */
                GetTextExtentPointW(hdcDraw, (LPWSTR)lData, (INT)wData, &size);

                if (!cx)
                    cx = size.cx;

                if (!cy)
                    cy = size.cy;

            }

            /*
             * Now, pretend we're complex if qfnCallBack is supplied AND
             * we're supporting GrayString().
             */
#if 0 // This will get turned on if/when we change GrayString to tie
      // into DrawState.
      //
      // FritzS
            if ((uFlags & DST_GRAYSTRING) && SELECTOROF(qfnCallBack)) {
                uFlags &= ~DST_TYPEMASK;
                uFlags |= DST_COMPLEX;
            }
#endif
            break;

        case DST_PREFIXTEXT:

            if (lData == 0) {
                RIPMSG0(RIP_ERROR, "DrawState: NULL DST_PREFIXTEXT string");
                goto CDS_Leave;
            }

            if (!wData)
                wData = wcslen((LPWSTR)lData);

            if (!cx || !cy) {

                SIZE size;

                PSMGetTextExtent(hdcDraw, (LPWSTR)lData, (int)wData, &size);

                if (!cx)
                    cx = size.cx;

                if (!cy)
                    cy = size.cy;
            }

            /*
             * Add on height for prefix
             */
            cy += (2 * SYSMET(CYBORDER));
            break;

        case DST_COMPLEX:
#if 0
            if (!SELECTOROF(qfnCallBack)) {
                DebugErr(DBF_ERROR, "DrawState: invalid callback for DST_COMPLEX");
                goto CDS_Leave;
            }
#endif
            break;

        default:
            RIPMSG0(RIP_ERROR, "DrawState: invalid DST_ type");
            goto CDS_Leave;
    }

    /*
     * Optimize:  nothing to draw
     * Have to call callback if GRAYSTRING for compatibility.
     */
    if ((!cx || !cy)
//        && !(uFlags & DST_GRAYSTRING)
    ) {
        fResult = TRUE;
        goto CDS_Leave;
    }

    /*
     * Setup drawing dc
     */
    if (uFlags & DSS_MONO) {

        hdcT = ghdcGray;
        /*
         * First turn off mirroring on hdcGray if any.
         */
        SetLayoutWidth(hdcT, -1, 0);
        /*
         * Set the ghdcGray layout to be equal to the screen hdcDraw layout.
         */
        dwLayout = GetLayout(hdcDraw);
        if (dwLayout != GDI_ERROR) {
            SetLayoutWidth(hdcT, cx, dwLayout);
        }

        /*
         * Is our scratch bitmap big enough?  We need potentially
         * cx+1 by cy pixels for default etc.
         */
        if ((gcxGray < cx + 1) || (gcyGray < cy)) {

            if (hbmpT = CreateBitmap(max(gcxGray, cx + 1), max(gcyGray, cy), 1, 1, 0L)) {

                HBITMAP hbmGray;

                hbmGray = SelectObject(ghdcGray, hbmpT);
                DeleteObject(hbmGray);

                gcxGray = max(gcxGray, cx + 1);
                gcyGray = max(gcyGray, cy);

            } else {
                cx = gcxGray - 1;
                cy = gcyGray;
            }
        }

        PatBlt(ghdcGray, 0, 0, gcxGray, gcyGray, WHITENESS);
        SetTextCharacterExtra(ghdcGray, GetTextCharacterExtra(hdcDraw));

        oldAlign = GetTextAlign(hdcT);
        SetTextAlign(hdcT, (oldAlign & ~(TA_RTLREADING |TA_CENTER |TA_RIGHT))
                     | (GetTextAlign(hdcDraw) & (TA_RTLREADING |TA_CENTER |TA_RIGHT)));

        /*
         * Setup font
         */
        if ((uFlags & DST_TYPEMASK) <= DST_TEXTMAX) {

            if (GetCurrentObject(hdcDraw, OBJ_FONT) != ghFontSys) {
                hFont = SelectObject(hdcDraw, ghFontSys);
                SelectObject(hdcDraw, hFont);
                hFontSave = SelectObject(ghdcGray, hFont);
            }
        }

    } else {

        hdcT = hdcDraw;

        /*
         * Adjust viewport
         */
        GetViewportOrgEx(hdcT, &ptOrg);
        SetViewportOrgEx(hdcT, ptOrg.x + x, ptOrg.y + y, NULL);
    }

    /*
     * Now, draw original image
     */
    fResult = TRUE;

    switch (uFlags & DST_TYPEMASK) {

        case DST_GLYPH:
            /*
             * Blt w/ current brush in hdcT
             */
            BitBltSysBmp(hdcT, 0, 0, LOWORD(lData));
            break;

        case DST_BITMAP:
            /*
             * Draw the bitmap.  If mono, it'll use the colors set up
             * in the dc.
             */
//            RtlEnterCriticalSection(&gcsHdcBits2);
            UserAssert(GetBkColor(ghdcBits2) == RGB(255, 255, 255));
            UserAssert(GetTextColor(ghdcBits2) == RGB(0, 0, 0));

            hbmpT = SelectObject(ghdcBits2, (HBITMAP)lData);
            BitBlt(hdcT, 0, 0, cx, cy, ghdcBits2, 0, 0, SRCCOPY);
            SelectObject(ghdcBits2, hbmpT);
//            RtlLeaveCriticalSection(&gcsHdcBits2);
            break;

        case DST_ICON:
            /*
             * Draw the icon.
             */
            DrawIconEx(hdcT, 0, 0, (HICON)lData, 0, 0, 0, NULL, DI_NORMAL);
            break;

        case DST_PREFIXTEXT:
            if (uFlags & DSS_HIDEPREFIX) {
                dwPSMFlags = DT_HIDEPREFIX;
            } else if (uFlags & DSS_PREFIXONLY) {
                dwPSMFlags = DT_PREFIXONLY;
            } else {
                dwPSMFlags = 0;
            }
            PSMTextOut(hdcT, 0, 0, (LPWSTR)lData, (int)wData, dwPSMFlags);
            break;

        case DST_TEXT:
            fResult = TextOutW(hdcT, 0, 0, (LPWSTR)lData, (int)wData);
            break;

        default:

            fResult = (qfnCallBack)(hdcT, lData, wData, cx, cy);

            /*
             * The callbacks could have altered the attributes of ghdcGray
             */
            if (hdcT == ghdcGray) {
                SetBkColor(ghdcGray, RGB(255, 255, 255));
                SetTextColor(ghdcGray, RGB(0, 0, 0));
                SelectObject(ghdcGray, GetStockObject(BLACK_BRUSH));
                SetBkMode(ghdcGray, OPAQUE);
            }
            break;
    }

    /*
     * Clean up
     */
    if (uFlags & DSS_MONO) {
        /*
         * Reset font
         */
        if (hFontSave)
            SelectObject(hdcT, hFontSave);
        SetTextAlign(hdcT, oldAlign);
    } else {
        /*
         * Reset DC.
         */
        SetViewportOrgEx(hdcT, ptOrg.x, ptOrg.y, NULL);
        goto CDS_Leave;
    }

    /*
     * UNION state
     * Dither over image
     * We want white pixels to stay white, in either dest or pattern.
     */
    if (uFlags & DSS_UNION) {

        POLYPATBLT PolyData;

        PolyData.x         = 0;
        PolyData.y         = 0;
        PolyData.cx        = cx;
        PolyData.cy        = cy;
        PolyData.BrClr.hbr = gpsi->hbrGray;

        PolyPatBlt(ghdcGray, PATOR, &PolyData, 1, PPB_BRUSH);
    }

    /*
     * DISABLED state
     * Emboss
     * Draw over-1/down-1 in hilight color, and in same position in shadow.
     *
     * DEFAULT state
     * Drop shadow
     * Draw over-1/down-1 in shadow color, and in same position in foreground
     * Draw offset down in shadow color,
     */
    if (uFlags & DSS_DISABLED) {

        BltColor(hdcDraw,
                 SYSHBR(3DHILIGHT),
                 ghdcGray,
                 x + 1,
                 y + 1,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);

        BltColor(hdcDraw,
                 SYSHBR(3DSHADOW),
                 ghdcGray,
                 x,
                 y,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);

    } else if (uFlags & DSS_DEFAULT) {

        BltColor(hdcDraw,
                 SYSHBR(3DSHADOW),
                 ghdcGray,
                 x+1,
                 y+1,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);

        goto DrawNormal;

    } else {

DrawNormal:

        BltColor(hdcDraw, hbrFore, ghdcGray, x, y, cx, cy, 0, 0, BC_INVERT);
    }

CDS_Leave:

    if (uFlags & DSS_MONO) {
        /*
         * Set the ghdcGray layout to 0, it is a public DC.
         */
        if (dwLayout != GDI_ERROR) {
            SetLayoutWidth(hdcT, -1, 0);
        }
    }
    RtlLeaveCriticalSection(&gcsHdc);

    return fResult;
}


FUNCLOG10(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DrawStateA, HDC, hDC, HBRUSH, hBrush, DRAWSTATEPROC, func, LPARAM, lParam, WPARAM, wParam, int, x, int, y, int, cx, int, cy, UINT, wFlags)
BOOL DrawStateA(HDC hDC, HBRUSH hBrush, DRAWSTATEPROC func,
    LPARAM lParam, WPARAM wParam, int x, int y, int cx, int cy, UINT wFlags)
{

    LPARAM lpwstr = lParam;
    BOOL bRet;
    BOOL bFree;

    if (((wFlags & DST_TYPEMASK) == DST_TEXT) ||
        ((wFlags & DST_TYPEMASK) == DST_PREFIXTEXT)) {

        bFree = TRUE;

        if ((wParam = MBToWCS((LPSTR)lParam, wParam ? (int)wParam : USER_AWCONV_COUNTSTRINGSZ, &(LPWSTR)lpwstr, -1, TRUE)) == 0)
            return FALSE;
    } else {
        bFree = FALSE;
    }

    bRet = DrawStateW(hDC, hBrush, func, lpwstr, wParam, x, y, cx, cy, wFlags);

    if (bFree) {
        UserLocalFree((HANDLE)lpwstr);
    }
    return bRet;
}

/***************************************************************************\
* BltColor
*
* History:
\***************************************************************************/

void BltColor(
    HDC hdc,
    HBRUSH hbr,
    HDC hdcSrce,
    int xO,
    int yO,
    int cx,
    int cy,
    int xO1,
    int yO1,
    UINT uBltFlags
)
{
    HBRUSH hbrSave;
    HBRUSH hbrNew = NULL;
    DWORD  textColorSave;
    DWORD  bkColorSave;

    if (hbr == (HBRUSH)NULL) {
        LOGBRUSH lb;

        lb.lbStyle = BS_SOLID;
        lb.lbColor = GetSysColor(COLOR_WINDOWTEXT);
        hbrNew = hbr = CreateBrushIndirect(&lb);
    }

    /*
     * Set the Text and Background colors so that bltColor handles the
     * background of buttons (and other bitmaps) properly.
     * Save the HDC's old Text and Background colors.  This causes problems with
     * Omega (and probably other apps) when calling GrayString which uses this
     * routine...
     */
    textColorSave = SetTextColor(hdc, 0x00000000L);
    bkColorSave = SetBkColor(hdc, 0x00FFFFFFL);

    hbrSave = SelectObject(hdc, hbr);

    BitBlt(hdc, xO, yO, cx, cy, hdcSrce,
        xO1, yO1, ((uBltFlags & BC_INVERT) ? 0xB8074AL : 0xE20746L));
        //xO1, yO1, (fInvert ? 0xB80000 : 0xE20000));

    SelectObject(hdc, hbrSave);

    /*
     * Restore saved colors
     */
    SetTextColor(hdc, textColorSave);
    SetBkColor(hdc, bkColorSave);

    if (hbrNew) {
        DeleteObject(hbrNew);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\monitor.c ===
/****************************** Module Header ******************************\
* Module Name: monitor.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager client side DDESPY monitoring functions.
*
* Created: 11/20/91 Sanford Staab
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


//
// Other monitor events are initiated directly from SetLastDDEMLError()
// and DoCallback().
//

/***************************************************************************\
* MonitorStringHandle
*
* Description:
* Launches a string handle monitor event. This function should be
* invoked via the MONHSZ() macro so as not to slow down things much
* when no DDESpy is running.
*
* History:
* 11-26-91 sanfords Created.
\***************************************************************************/
VOID MonitorStringHandle(
PCL_INSTANCE_INFO pcii,
HSZ hsz, // local atom
DWORD fsAction)
{
    WCHAR szT[256];
    PEVENT_PACKET pep;
    DWORD cchString;

    CheckDDECritIn;

    UserAssert(pcii->MonitorFlags & MF_HSZ_INFO);

    if (!(cchString = GetAtomName(LATOM_FROM_HSZ(hsz), szT,
            sizeof(szT) / sizeof(WCHAR)))) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        return ;
    }
    cchString++;
    pep = (PEVENT_PACKET)DDEMLAlloc(sizeof(EVENT_PACKET) - sizeof(DWORD) +
            sizeof(MONHSZSTRUCT) + cchString * sizeof(WCHAR));
    if (pep == NULL) {
        SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
        return ;
    }

    pep->EventType =    MF_HSZ_INFO;
    pep->fSense =       TRUE;
    pep->cbEventData =  (WORD)(sizeof(MONHSZSTRUCT) + cchString * sizeof(WCHAR));

#define phszs ((MONHSZSTRUCT *)&pep->Data)
    phszs->cb =      sizeof(MONHSZSTRUCT);
    phszs->fsAction = fsAction;
    phszs->dwTime =  NtGetTickCount();
    phszs->hsz = hsz;
    phszs->hTask = (HANDLE)LongToHandle( pcii->tid );
    // phszs->wReserved = 0; // zero init.
    wcscpy(phszs->str, szT);

    LeaveDDECrit;
    Event(pep);
    EnterDDECrit;
#undef phszs
}




/***************************************************************************\
* MonitorLink
*
* Description:
* Launches a link monitor event. This function should be
* invoked via the MONLINK() macro so as not to slow down things much
* when no DDESpy is running.
*
* History:
* 11-26-91 sanfords Created.
\***************************************************************************/
VOID MonitorLink(
PCL_INSTANCE_INFO pcii,
BOOL fEstablished,
BOOL fNoData,
LATOM aService,
LATOM aTopic,
GATOM aItem,
WORD wFmt,
BOOL fServer,
HCONV hConvServer,
HCONV hConvClient)
{
    PEVENT_PACKET pep;

    CheckDDECritIn;

    UserAssert(pcii->MonitorFlags & MF_LINKS);

    pep = (PEVENT_PACKET)DDEMLAlloc(sizeof(EVENT_PACKET) - sizeof(DWORD) +
            sizeof(MONLINKSTRUCT));
    if (pep == NULL) {
        SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
        return ;
    }

    pep->EventType =    MF_LINKS;
    pep->fSense =       TRUE;
    pep->cbEventData =  sizeof(MONLINKSTRUCT);

#define pls ((MONLINKSTRUCT *)&pep->Data)
    pls->cb =           sizeof(MONLINKSTRUCT);
    pls->dwTime =       NtGetTickCount();
    pls->hTask =        (HANDLE)LongToHandle( pcii->tid );
    pls->fEstablished = fEstablished;
    pls->fNoData =      fNoData;

    // use global atoms here - these need to be changed to local atoms before
    // the callbacks to the ddespy apps.

    pls->hszSvc =       (HSZ)LocalToGlobalAtom(aService);
    pls->hszTopic =     (HSZ)LocalToGlobalAtom(aTopic);
    IncGlobalAtomCount(aItem);
    pls->hszItem =      (HSZ)aItem;

    pls->wFmt =         wFmt;
    pls->fServer =      fServer;
    pls->hConvServer =  hConvServer;
    pls->hConvClient =  hConvClient;

    LeaveDDECrit;
    Event(pep);
    EnterDDECrit;

    GlobalDeleteAtom((ATOM)(ULONG_PTR)pls->hszSvc);
    GlobalDeleteAtom((ATOM)(ULONG_PTR)pls->hszTopic);
    GlobalDeleteAtom(aItem);
#undef pls
}




/***************************************************************************\
* MonitorConv
*
* Description:
* Launches a conversation monitor event. This function should be
* invoked via the MONCONV() macro so as not to slow down things much
* when no DDESpy is running.
*
* History:
* 11-26-91 sanfords Created.
* 5-8-92   sanfords Since the hConv's mean nothing outside this process,
*                   the hConv fields now hold hwnds.  This lets DDESPY
*                   tie together connect and disconnect events from each
*                   side.
\***************************************************************************/
VOID MonitorConv(
PCONV_INFO pcoi,
BOOL fConnect)
{
    PEVENT_PACKET pep;

    CheckDDECritIn;

    UserAssert(pcoi->pcii->MonitorFlags & MF_CONV);

    pep = (PEVENT_PACKET)DDEMLAlloc(sizeof(EVENT_PACKET) - sizeof(DWORD) +
            sizeof(MONCONVSTRUCT));
    if (pep == NULL) {
        SetLastDDEMLError(pcoi->pcii, DMLERR_MEMORY_ERROR);
        return ;
    }

    pep->EventType =    MF_CONV;
    pep->fSense =       TRUE;
    pep->cbEventData =  sizeof(MONCONVSTRUCT);

#define pcs ((MONCONVSTRUCT *)&pep->Data)
    pcs->cb =           sizeof(MONCONVSTRUCT);
    pcs->fConnect =     fConnect;
    pcs->dwTime =       NtGetTickCount();
    pcs->hTask =        (HANDLE)LongToHandle( pcoi->pcii->tid );
    pcs->hszSvc =       (HSZ)LocalToGlobalAtom(pcoi->laService);
    pcs->hszTopic =     (HSZ)LocalToGlobalAtom(pcoi->laTopic);
    if (pcoi->state & ST_CLIENT) {
        pcs->hConvClient =  (HCONV)pcoi->hwndConv;
        pcs->hConvServer =  (HCONV)pcoi->hwndPartner;
    } else {
        pcs->hConvClient =  (HCONV)pcoi->hwndPartner;
        pcs->hConvServer =  (HCONV)pcoi->hwndConv;
    }

    LeaveDDECrit;
    Event(pep);
    EnterDDECrit;

    GlobalDeleteAtom((ATOM)(ULONG_PTR)pcs->hszSvc);
    GlobalDeleteAtom((ATOM)(ULONG_PTR)pcs->hszTopic);
#undef pcs
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\msgbox.c ===
/****************************** Module Header ******************************\
* Module Name: msgbox.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the MessageBox API and related functions.
*
* History:
* 10-23-90 DarrinM     Created.
* 02-08-91 IanJa       HWND revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

//
// Dimension constants  --  D.U. == dialog units
//
#define DU_OUTERMARGIN    7
#define DU_INNERMARGIN    10

#define DU_BTNGAP         4   // D.U. of space between buttons
#define DU_BTNHEIGHT      14  // D.U. of button height
// This is used only in kernel\inctlpan.c, so move it there
//
// #define DU_BTNWIDTH       50  // D.U. of button width, minimum
//

LPBYTE MB_UpdateDlgHdr(LPDLGTEMPLATE lpDlgTmp, long lStyle, long lExtendedStyle, BYTE bItemCount,
           int iX, int iY, int iCX, int iCY, LPWSTR lpszCaption, int iCaptionLen);
LPBYTE MB_UpdateDlgItem(LPDLGITEMTEMPLATE lpDlgItem, int iCtrlId, long lStyle, long lExtendedStyle,
           int iX, int iY, int iCX, int iCY, LPWSTR lpszText, UINT wTextLen,
           int iControlClass);
UINT   MB_GetIconOrdNum(UINT rgBits);
LPBYTE MB_AddPushButtons(
    LPDLGITEMTEMPLATE lpDlgTmp,
    LPMSGBOXDATA      lpmb,
    UINT wLEdge,
    UINT wBEdge);
UINT MB_FindDlgTemplateSize( LPMSGBOXDATA lpmb );
int MessageBoxWorker(LPMSGBOXDATA pMsgBoxParams);
VOID EndTaskModalDialog(HWND hwndDlg);
VOID StartTaskModalDialog(HWND hwndDlg);

#ifdef _JANUS_

#include "strid.h"
#include <imagehlp.h>

// constant strings
CONST WCHAR szEMIKey[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Error Message Instrument\\";
CONST WCHAR szEMIEnable[] = L"EnableLogging";
CONST WCHAR szEMISeverity[] = L"LogSeverity";
CONST WCHAR szDMREnable[] = L"EnableDefaultReply";
CONST WCHAR szEventKey[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\EventLog\\Application\\Error Instrument\\";
CONST WCHAR szEventMsgFile[] = L"EventMessageFile";
CONST WCHAR szEventType[] = L"TypesSupported";

#define TITLE_SIZE          64
#define DATETIME_SIZE       32

#define EMI_SEVERITY_ALL          0
#define EMI_SEVERITY_USER         1
#define EMI_SEVERITY_INFORMATION  2
#define EMI_SEVERITY_QUESTION     3
#define EMI_SEVERITY_WARNING      4
#define EMI_SEVERITY_ERROR        5
#define EMI_SEVERITY_MAX_VALUE    5

// element of error message
PVOID gpReturnAddr = 0;
HANDLE gdwEMIThreadID = 0;
typedef struct _ERROR_ELEMENT {
    WCHAR       ProcessName[MAX_PATH];
    WCHAR       WindowTitle[TITLE_SIZE];
    DWORD       dwStyle;
    DWORD       dwErrorCode;
    WCHAR       CallerModuleName[MAX_PATH];
    PVOID       BaseAddr;
    DWORD       dwImageSize;
    PVOID       ReturnAddr;
    LPWSTR      lpszCaption;
    LPWSTR      lpszText;
} ERROR_ELEMENT, *LPERROR_ELEMENT;

BOOL ErrorMessageInst(LPMSGBOXDATA pMsgBoxParams);
BOOL InitInstrument(LPDWORD lpEMIControl);

// eventlog stuff
HANDLE gEventSource;
NTSTATUS CreateLogSource();
BOOL LogMessageBox(LPERROR_ELEMENT lpErrEle);

#define EMIGETRETURNADDRESS()                                    \
{                                                                \
    if (gfEMIEnable) {                                           \
        if (InterlockedCompareExchangePointer(&gdwEMIThreadID,   \
                                              GETTHREADID(),     \
                                              0)                 \
             == 0) {                                             \
            gpReturnAddr = (PVOID) 1; \
        }                                                        \
    }                                                            \
}

// _ReturnAddress();
#else
#define EMIGETRETURNADDRESS()
#endif //_JANUS_



#define MB_MASKSHIFT    4

CONST WCHAR szEmpty[] = L"";
WCHAR szERROR[10];
ATOM atomBwlProp;
ATOM atomMsgBoxCallback;

/***************************************************************************\
* SendHelpMessage
*
*
\***************************************************************************/
VOID
SendHelpMessage(
    HWND   hwnd,
    int    iType,
    int    iCtrlId,
    HANDLE hItemHandle,
    DWORD  dwContextId,
    MSGBOXCALLBACK lpfnCallback)
{
    HELPINFO    HelpInfo;
    long        lValue;

    HelpInfo.cbSize = sizeof(HELPINFO);
    HelpInfo.iContextType = iType;
    HelpInfo.iCtrlId = iCtrlId;
    HelpInfo.hItemHandle = hItemHandle;
    HelpInfo.dwContextId = dwContextId;

    lValue = NtUserGetMessagePos();
    HelpInfo.MousePos.x = GET_X_LPARAM(lValue);
    HelpInfo.MousePos.y = GET_Y_LPARAM(lValue);

    // Check if there is an app supplied callback.
    if (lpfnCallback != NULL) {
        if (IsWOWProc(lpfnCallback)) {
            (*pfnWowMsgBoxIndirectCallback)(PtrToUlong(lpfnCallback), &HelpInfo);
        } else {
            (*lpfnCallback)(&HelpInfo);
        }
    } else {
        SendMessage(hwnd, WM_HELP, 0, (LPARAM)&HelpInfo);
    }
}


/***************************************************************************\
* ServiceMessageBox
*
*
\***************************************************************************/

CONST int aidReturn[] = { 0, 0, IDABORT, IDCANCEL, IDIGNORE, IDNO, IDOK, IDRETRY, IDYES };

int ServiceMessageBox(
    LPCWSTR pText,
    LPCWSTR pCaption,
    UINT wType,
    DWORD dwTimeout)
{
    NTSTATUS Status;
    ULONG_PTR Parameters[4];
    ULONG Response = ResponseNotHandled;
    UNICODE_STRING Text, Caption;

    /*
     * For Terminal Services we must decided the session in which this message
     * box should be displayed.  We do this by looking at the impersonation token
     * and use the session on which the client is running.
     */
    if (ISTS()) {
        HANDLE      TokenHandle;
        NTSTATUS    Status;
        ULONG       ClientSessionId;
        ULONG       ProcessSessionId;
        ULONG       ReturnLength;
        BOOLEAN     bResult;

        /*
         * Obtain access to the impersonation token if it's present.
         */
        Status = NtOpenThreadToken (
            GetCurrentThread(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            TRUE,
            &TokenHandle
            );
        if (NT_SUCCESS(Status)) {
            /*
             * Query the Session ID out of the Token
             */
            Status = NtQueryInformationToken (
                TokenHandle,
                TokenSessionId,
                (PVOID)&ClientSessionId,
                sizeof(ClientSessionId),
                &ReturnLength
                );
            CloseHandle(TokenHandle);
            if (NT_SUCCESS(Status)) {
                /*
                 * Get the process session Id.  Use the Kernel32 API first because
                 * the PEB is writable in case someone is hacking it.
                 */
                if (!ProcessIdToSessionId(GetCurrentProcessId(), &ProcessSessionId)) {
                    ProcessSessionId = NtCurrentPeb()->SessionId;
                }

                if (ClientSessionId != ProcessSessionId) {
                    /*
                     * This message box was intended for session other than the
                     * one on which this process is running.  Forward it to the
                     * right session with WinStationSendMessage().
                     */
                    /*
                     * Handle case where Caption or Title is NULL
                     */
                    if (pCaption == NULL) {
                        pCaption = szEmpty;
                    }
                    if (pText == NULL) {
                        pText = szEmpty;
                    }

                    /*
                     * MessageBoxTimeout assumes the timeout value is in milliseconds,
                     * but WinStationSendMessageW uses seconds.
                     */
                    if (dwTimeout != INFINITE) {
                        dwTimeout /= 1000;
                    }
                    bResult = WinStationSendMessageW(SERVERNAME_CURRENT,
                                                     ClientSessionId,
                                                     (LPWSTR)pCaption,
                                                     wcslen(pCaption) * sizeof(WCHAR),
                                                     (LPWSTR)pText,
                                                     wcslen(pText) * sizeof(WCHAR),
                                                     wType,
                                                     dwTimeout,
                                                     &Response,
                                                     FALSE         // always wait
                                                    );
                    if (bResult != TRUE) {
                        Response = aidReturn[ResponseNotHandled];
                    } else {
                        if (Response == IDTIMEOUT || Response == IDERROR) {
                            Response = aidReturn[ResponseNotHandled];
                        }
                    }

                    return (int)Response;
                }
            }
        }
    }

    /*
     * MessageBox is for this session, go call CSR.
     */
    RtlInitUnicodeString(&Text, pText);
    RtlInitUnicodeString(&Caption, pCaption);
    Parameters[0] = (ULONG_PTR)&Text;
    Parameters[1] = (ULONG_PTR)&Caption;
    Parameters[2] = wType;
    Parameters[3] = dwTimeout;

    /*
     * Compatibility: Pass the override bit to make sure this box always shows
     */
    Status = NtRaiseHardError(STATUS_SERVICE_NOTIFICATION | HARDERROR_OVERRIDE_ERRORMODE,
                              ARRAY_SIZE(Parameters),
                              3,
                              Parameters,
                              OptionOk,
                              &Response);

    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");
    }

    return aidReturn[Response];
}


/***************************************************************************\
* MessageBox (API)
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/
int MessageBoxA(
    HWND hwndOwner,
    LPCSTR lpszText,
    LPCSTR lpszCaption,
    UINT wStyle)
{
    EMIGETRETURNADDRESS();
    return MessageBoxExA(hwndOwner, lpszText, lpszCaption, wStyle, 0);
}


int MessageBoxW(
    HWND hwndOwner,
    LPCWSTR lpszText,
    LPCWSTR lpszCaption,
    UINT wStyle)
{
    EMIGETRETURNADDRESS();
    return MessageBoxExW(hwndOwner, lpszText, lpszCaption, wStyle, 0);
}


/***************************************************************************\
* MessageBoxEx (API)
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/
int MessageBoxExA(
    HWND hwndOwner,
    LPCSTR lpszText,
    LPCSTR lpszCaption,
    UINT wStyle,
    WORD wLanguageId)
{
    return MessageBoxTimeoutA(hwndOwner,
                              lpszText,
                              lpszCaption,
                              wStyle,
                              wLanguageId,
                              INFINITE);
}


int MessageBoxExW(
    HWND hwndOwner,
    LPCWSTR lpszText,
    LPCWSTR lpszCaption,
    UINT wStyle,
    WORD wLanguageId)
{
    return MessageBoxTimeoutW(hwndOwner,
                              lpszText,
                              lpszCaption,
                              wStyle,
                              wLanguageId,
                              INFINITE);
}

/***************************************************************************\
* MessageBoxTimeout (API)
*
* History:
* 04-28-2001 JasonSch   Wrote it.
\***************************************************************************/
int MessageBoxTimeoutW(
    HWND hwndOwner,
    LPCWSTR lpszText,
    LPCWSTR lpszCaption,
    UINT wStyle,
    WORD wLanguageId,
    DWORD dwTimeout)
{
    MSGBOXDATA  MsgBoxParams;

#if DBG
    /*
     * MB_USERICON is valid for MessageBoxIndirect only.
     * MessageBoxWorker validates the other style bits
     */
    if (wStyle & MB_USERICON) {
        RIPMSG0(RIP_WARNING, "MessageBoxExW: Invalid flag: MB_USERICON");
    }
#endif

    RtlZeroMemory(&MsgBoxParams, sizeof(MsgBoxParams));
    MsgBoxParams.cbSize           = sizeof(MSGBOXPARAMS);
    MsgBoxParams.hwndOwner        = hwndOwner;
    MsgBoxParams.hInstance        = NULL;
    MsgBoxParams.lpszText         = lpszText;
    MsgBoxParams.lpszCaption      = lpszCaption;
    MsgBoxParams.dwStyle          = wStyle;
    MsgBoxParams.wLanguageId      = wLanguageId;
    MsgBoxParams.dwTimeout        = dwTimeout;

    EMIGETRETURNADDRESS();
    return MessageBoxWorker(&MsgBoxParams);
}

int MessageBoxTimeoutA(
    HWND hwndOwner,
    LPCSTR lpszText,
    LPCSTR lpszCaption,
    UINT wStyle,
    WORD wLanguageId,
    DWORD dwTimeout)
{
    int retval;
    LPWSTR lpwszText = NULL;
    LPWSTR lpwszCaption = NULL;

    if (lpszText) {
        if (!MBToWCS(lpszText, -1, &lpwszText, -1, TRUE))
            return 0;
    }

    if (lpszCaption) {
        if (!MBToWCS(lpszCaption, -1, &lpwszCaption, -1, TRUE)) {
            UserLocalFree(lpwszText);
            return 0;
        }
    }

    EMIGETRETURNADDRESS();
    retval = MessageBoxTimeoutW(hwndOwner,
                                lpwszText,
                                lpwszCaption,
                                wStyle,
                                wLanguageId,
                                dwTimeout);

    UserLocalFree(lpwszText);
    if (lpwszCaption) {
        UserLocalFree(lpwszCaption);
    }

    return retval;
}

#define MessageBoxIndirectInit(MsgBoxParams, lpmbp)                             \
    do {                                                                        \
        if (lpmbp->cbSize != sizeof(MSGBOXPARAMS)) {                            \
            RIPMSG1(RIP_WARNING,                                                \
                    "MessageBoxIndirect: Invalid cbSize 0x%x",                  \
                    lpmbp->cbSize);                                             \
        }                                                                       \
                                                                                \
        RtlZeroMemory(&MsgBoxParams, sizeof(MSGBOXDATA));                       \
        RtlCopyMemory(&MsgBoxParams, lpmbp, sizeof(MSGBOXPARAMS));              \
    } while (FALSE);

/**************************************************************************\
* MessageBoxIndirect (API)
*
* 09-30-1994 FritzS      Created.
\**************************************************************************/
int MessageBoxIndirectA(
    CONST MSGBOXPARAMSA *lpmbp)
{
    int retval;
    MSGBOXDATA  MsgBoxParams;
    LPWSTR lpwszText = NULL;
    LPWSTR lpwszCaption = NULL;

    MessageBoxIndirectInit(MsgBoxParams, lpmbp);

    if (IS_PTR(MsgBoxParams.lpszText)) {
        if (!MBToWCS((LPSTR)MsgBoxParams.lpszText, -1, &lpwszText, -1, TRUE)) {
            return 0;
        }
        MsgBoxParams.lpszText = lpwszText;
    }
    if (IS_PTR(MsgBoxParams.lpszCaption)) {
        if (!MBToWCS((LPSTR)MsgBoxParams.lpszCaption, -1, &lpwszCaption, -1, TRUE)) {
            UserLocalFree(lpwszText);
            return 0;
        }
        MsgBoxParams.lpszCaption = lpwszCaption;
    }

    EMIGETRETURNADDRESS();
    retval = MessageBoxWorker(&MsgBoxParams);

    if (lpwszText) {
        UserLocalFree(lpwszText);
    }
    if (lpwszCaption) {
        UserLocalFree(lpwszCaption);
    }

    return retval;
}

int MessageBoxIndirectW(
    CONST MSGBOXPARAMSW *lpmbp)
{
    MSGBOXDATA  MsgBoxParams;

    MessageBoxIndirectInit(MsgBoxParams, lpmbp);

    EMIGETRETURNADDRESS();
    return MessageBoxWorker(&MsgBoxParams);
}

/***************************************************************************\
* MessageBoxWorker (API)
*
* History:
* 03-10-93 JohnL      Created
\***************************************************************************/

int MessageBoxWorker(
    LPMSGBOXDATA pMsgBoxParams)
{
    DWORD  dwStyle = pMsgBoxParams->dwStyle;
    UINT   wBtnCnt;
    UINT   wDefButton;
    UINT   i;
    UINT   wBtnBeg;
    WCHAR  szErrorBuf[64];
    LPWSTR apstrButton[4];
    int    aidButton[4];
    BOOL   fCancel = FALSE;
    int    retValue;
    PMBSTRING pMBString;

#if DBG
    if (dwStyle & ~MB_VALID) {
        RIPMSG2(RIP_WARNING, "MessageBoxWorker: Invalid flags, %#lx & ~%#lx != 0",
              dwStyle, MB_VALID);
    }
#endif

    /*
     * dwTimeout == 0 means wait forever. This is mostly for compat reasons.
     */
    if (pMsgBoxParams->dwTimeout == 0) {
        pMsgBoxParams->dwTimeout = INFINITE;
    }

    /*
     * Be sure that MBStrings are already loaded.
     */
    UserAssert(gpsi->MBStrings[0].szName[0] != TEXT('\0'));

#ifdef _JANUS_
    /*
     * Error message instrument start here
     * Check EMI enable
     */

    if (gfEMIEnable) {
        if (!ErrorMessageInst(pMsgBoxParams))
            RIPMSG0(RIP_WARNING, "MessageBoxWorker: Fail to instrument error msg");
    };

    /*
     * Default Message Return: on unattended systems the default button
     * can be returned automatically without putting up the message box
     */

    if (gfDMREnable) {
        /*
         * validate the style and default button as in the main code path
         */

        /*
         * Validate the "type" of message box requested.
         */
        if ((dwStyle & MB_TYPEMASK) > MB_LASTVALIDTYPE) {
            RIPERR0(ERROR_INVALID_MSGBOX_STYLE, RIP_VERBOSE, "");
            return 0;
        }

        wBtnCnt = mpTypeCcmd[dwStyle & MB_TYPEMASK] +
                                ((dwStyle & MB_HELP) ? 1 : 0);

        /*
         * Set the default button value
         */
        wDefButton = (dwStyle & (UINT)MB_DEFMASK) / (UINT)(MB_DEFMASK & (MB_DEFMASK >> 3));

        if (wDefButton >= wBtnCnt)   /* Check if valid */
            wDefButton = 0;          /* Set the first button if error */

        /*
         * return the default button
         */

        wBtnBeg = mpTypeIich[dwStyle & (UINT)MB_TYPEMASK];
        pMBString = &gpsi->MBStrings[ SEBbuttons[wBtnBeg + wDefButton] ];
        return pMBString->uID;
    }
#endif // _JANUS_

    /*
     * If lpszCaption is NULL, then use "Error!" string as the caption
     * string.
     * LATER: IanJa localize according to wLanguageId
     */
    if (pMsgBoxParams->lpszCaption == NULL) {
        /*
         * Load the default error string if we haven't done it yet
         */
        if (*szERROR == 0) {
            LoadStringW(hmodUser, STR_ERROR, szERROR, ARRAY_SIZE(szERROR));
        }
        if (pMsgBoxParams->wLanguageId == 0) {
            pMsgBoxParams->lpszCaption = szERROR;
        } else {
            LoadStringOrError(hmodUser,
                                 STR_ERROR,
                                 szErrorBuf,
                                 sizeof(szErrorBuf)/sizeof(WCHAR),
                                 pMsgBoxParams->wLanguageId);

            /*
             *  If it didn't find the string, use the default language
             */
            if (*szErrorBuf) {
               pMsgBoxParams->lpszCaption = szErrorBuf;
            } else {
               pMsgBoxParams->lpszCaption = szERROR;

               RIPMSG1(RIP_WARNING, "MessageBoxWorker: STR_ERROR string resource for language %#lx not found",
                      pMsgBoxParams->wLanguageId);
            }
        }
    }

    /*
     * MB_SERVICE_NOTIFICATION had to be redefined because
     * Win95 defined MB_TOPMOST using the same value.
     * So for old apps, we map it to the new value
     */

    if ((dwStyle & MB_TOPMOST) && !Is400Compat(GetClientInfo()->dwExpWinVer)) {
        dwStyle &= ~MB_TOPMOST;
        dwStyle |= MB_SERVICE_NOTIFICATION;
        pMsgBoxParams->dwStyle = dwStyle;

        RIPMSG1(RIP_WARNING, "MessageBoxWorker: MB_SERVICE_NOTIFICATION flag mapped. New dwStyle:%#lx", dwStyle);
    }

    /*
     * For backward compatiblity, use MB_SERVICE_NOTIFICATION if
     * it's going to the default desktop.
     */
    if (dwStyle & (MB_DEFAULT_DESKTOP_ONLY | MB_SERVICE_NOTIFICATION)) {

        /*
         * Allow services to put up popups without getting
         * access to the current desktop.
         */
        if (pMsgBoxParams->hwndOwner != NULL) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
            return 0;
        }

        return ServiceMessageBox(pMsgBoxParams->lpszText,
                                 pMsgBoxParams->lpszCaption,
                                 dwStyle & ~MB_SERVICE_NOTIFICATION,
                                 pMsgBoxParams->dwTimeout);
    }

    /*
     * Make sure we have a valid window handle.
     */
    if (pMsgBoxParams->hwndOwner && !IsWindow(pMsgBoxParams->hwndOwner)) {
        RIPERR0(ERROR_INVALID_WINDOW_HANDLE, RIP_VERBOSE, "");
        return 0;
    }

    /*
     * Validate the "type" of message box requested.
     */
    if ((dwStyle & MB_TYPEMASK) > MB_LASTVALIDTYPE) {
        RIPERR0(ERROR_INVALID_MSGBOX_STYLE, RIP_VERBOSE, "");
        return 0;
    }

    wBtnCnt = mpTypeCcmd[dwStyle & MB_TYPEMASK] +
                            ((dwStyle & MB_HELP) ? 1 : 0);

    /*
     * Set the default button value
     */
    wDefButton = (dwStyle & (UINT)MB_DEFMASK) / (UINT)(MB_DEFMASK & (MB_DEFMASK >> 3));

    if (wDefButton >= wBtnCnt)   /* Check if valid */
        wDefButton = 0;          /* Set the first button if error */

    /*
     * Calculate the strings to use in the message box
     */
    wBtnBeg = mpTypeIich[dwStyle & (UINT)MB_TYPEMASK];
    for (i=0; i<wBtnCnt; i++) {

        pMBString = &gpsi->MBStrings[SEBbuttons[wBtnBeg + i]];
        /*
         * Pick up the string for the button.
         */
        if (pMsgBoxParams->wLanguageId == 0) {
            apstrButton[i] = KPWSTR_TO_PWSTR(pMBString->szName);
        } else {
            WCHAR szButtonBuf[64];
            // LATER is it possible to have button text greater than 64 chars

           /*
            *  BUG: gpsi->wMaxBtnSize might be too short for the length of this string...
            */
            LoadStringOrError(hmodUser,
                    pMBString->uStr,
                    szButtonBuf,
                    ARRAY_SIZE(szButtonBuf),
                    pMsgBoxParams->wLanguageId);

            /*
             *  If it didn't find the string, use the default language.
             */
            if (*szButtonBuf) {
               apstrButton[i] = TextAlloc(szButtonBuf);
            } else {
               apstrButton[i] = TextAlloc(KPWSTR_TO_PWSTR(pMBString->szName));

               RIPMSG2(RIP_WARNING, "MessageBoxWorker: string resource %#lx for language %#lx not found",
                      pMBString->uStr,
                      pMsgBoxParams->wLanguageId);
            }
        }
        aidButton[i] = pMBString->uID;
        if (aidButton[i] == IDCANCEL) {
            fCancel = TRUE;
        }
    }

    /*
     * Hackery: There are some apps that use MessageBox as initial error
     * indicators, such as mplay32, and we want this messagebox to be
     * visible regardless of waht was specified in the StartupInfo->wShowWindow
     * field.  ccMail for instance starts all of its embedded objects hidden
     * but on win 3.1 the error message would show because they don't have
     * the startup info.
     */
    NtUserModifyUserStartupInfoFlags(STARTF_USESHOWWINDOW, 0);

    pMsgBoxParams->pidButton      = aidButton;
    pMsgBoxParams->ppszButtonText = apstrButton;
    pMsgBoxParams->DefButton      = wDefButton;
    pMsgBoxParams->cButtons       = wBtnCnt;
    pMsgBoxParams->CancelId      = ((dwStyle & MB_TYPEMASK) == 0) ? IDOK : (fCancel ? IDCANCEL : 0);
    retValue = SoftModalMessageBox(pMsgBoxParams);

    if (pMsgBoxParams->wLanguageId != 0) {
        for (i=0; i<wBtnCnt; i++)
           UserLocalFree(apstrButton[i]);
    }

    return retValue;
}

#define MAX_RES_STRING  256

/***************************************************************************\
*
*  SoftModalMessageBox()
*
\***************************************************************************/
int  SoftModalMessageBox(LPMSGBOXDATA lpmb)
{
    LPBYTE              lpDlgTmp;
    int                 cyIcon, cxIcon;
    int                 cxButtons;
    int                 cxMBMax;
    int                 cxText, cyText, xText;
    int                 cxBox, cyBox;
    int                 cxFoo, cxCaption;
    int                 xMB, yMB;
    HDC                 hdc;
    DWORD               wIconOrdNum;
    DWORD               wCaptionLen;
    DWORD               wTextLen;
    WORD                OrdNum[2];  // Must be an array or WORDs
    RECT                rc;
    RECT                rcWork;
    HCURSOR             hcurOld;
    DWORD               dwStyleMsg, dwStyleText;
    DWORD               dwExStyleMsg = 0;
    DWORD               dwStyleDlg;
    HWND                hwndOwner;
    LPWSTR              lpsz;
    int                 iRetVal     = 0;
    HICON               hIcon;
    HGLOBAL             hTemplate   = NULL;
    HGLOBAL             hCaption    = NULL;
    HGLOBAL             hText       = NULL;
    HINSTANCE           hInstMsg    = lpmb->hInstance;
    SIZE                size;
    HFONT               hFontOld    = NULL;
    int                 cntMBox;
    PMONITOR            pMonitor;

    ConnectIfNecessary(0);

    dwStyleMsg = lpmb->dwStyle;

    if (dwStyleMsg & MB_RIGHT) {
        dwExStyleMsg |= WS_EX_RIGHT;
    }

    if (!IS_PTR(lpmb->lpszCaption)) {

        // won't ever be NULL because MessageBox sticks "Error!" in in that case
        if (hInstMsg && (hCaption = LocalAlloc(LPTR, MAX_RES_STRING * sizeof(WCHAR)))) {
            lpsz = (LPWSTR) hCaption;
            LoadString(hInstMsg, PTR_TO_ID(lpmb->lpszCaption), lpsz, MAX_RES_STRING);
        } else
            lpsz = NULL;

        lpmb->lpszCaption = lpsz ? lpsz : szEmpty;
    }

    if (!IS_PTR(lpmb->lpszText)) {
        // NULL not allowed
        if (hInstMsg && (hText = LocalAlloc(LPTR, MAX_RES_STRING * sizeof(WCHAR)))) {
            lpsz = (LPWSTR) hText;
            LoadString(hInstMsg, PTR_TO_ID(lpmb->lpszText), lpsz, MAX_RES_STRING);
        } else
            lpsz = NULL;

        lpmb->lpszText = lpsz ? lpsz : szEmpty;
    }

    //
    // Mirroring of MessageBox'es is only enabled if :-
    //
    // * MB_RTLREADING style has been specified in the MessageBox styles OR
    // * The first two code points of the MessageBox text are Right-To-Left
    //   marks (RLMs = U+200f).
    // The feature of enable RTL mirroring if two consecutive RLMs are found
    // in the MB text is to acheive a no-code-change for localization of
    // of MessageBoxes for BiDi Apps.  [samera]
    //
    if ((dwStyleMsg & MB_RTLREADING) ||
            (lpmb->lpszText != NULL && (lpmb->lpszText[0] == UNICODE_RLM) &&
            (lpmb->lpszText[1] == UNICODE_RLM))) {
        //
        // Set Mirroring so that MessageBox and its child controls
        // get mirrored. Otherwise, the message box and its child controls
        // are Left-To-Right.
        //
        dwExStyleMsg |= WS_EX_LAYOUTRTL;

        //
        // And turn off any conflicting flags.
        //
        dwExStyleMsg &= ~WS_EX_RIGHT;
        if (dwStyleMsg & MB_RTLREADING) {
            dwStyleMsg &= ~MB_RTLREADING;
            dwStyleMsg ^= MB_RIGHT;
        }
    }

    if ((dwStyleMsg & MB_ICONMASK) == MB_USERICON)
        hIcon = LoadIcon(hInstMsg, lpmb->lpszIcon);
    else
        hIcon = NULL;

    // For compatibility reasons, we still allow the message box to come up.
    hwndOwner = lpmb->hwndOwner;

    // For PowerBuilder4.0, we must make their messageboxes owned popups. Or, else
    // they get WM_ACTIVATEAPP and they install multiple keyboard hooks and get into
    // infinite loop later.
    // Bug #15896 -- WIN95B -- 2/17/95 -- SANKAR --
    if (!hwndOwner)
      {
        WCHAR pwszLibFileName[MAX_PATH];
        static WCHAR szPB040[] = L"PB040";  // Module name of PowerBuilder4.0
        WCHAR *pw1;

        //Is this a win3.1 or older app?
        if (!Is400Compat(GETAPPVER())) {
            if (GetModuleFileName(NULL, pwszLibFileName, sizeof(pwszLibFileName)/sizeof(WCHAR)) == 0) goto getthedc;
            pw1 = pwszLibFileName + wcslen(pwszLibFileName) - 1;
            while (pw1 > pwszLibFileName) {
                if (*pw1 == TEXT('.')) *pw1-- = 0;
                else if (*pw1 == TEXT(':')) {pw1++; break;}
                else if (*pw1 == TEXT('\\')) {pw1++; break;}
                else pw1--;
            }
            // Is this the PowerBuilder 4.0 module?
            if (!_wcsicmp(pw1, szPB040))
                hwndOwner = NtUserGetForegroundWindow(); // Make the MsgBox owned.
          }
      }
getthedc:
    // Check if we're out of cache DCs until robustness...
    if (!(hdc = NtUserGetDCEx(NULL, NULL, DCX_WINDOW | DCX_CACHE))) {

        /*
         * The above call might fail for TIF_RESTRICTED processes
         * so check for the DC from the owner window
         */
        if (!(hdc = NtUserGetDCEx(hwndOwner, NULL, DCX_WINDOW | DCX_CACHE)))
            goto SMB_Exit;
    }

    // Figure out the types and dimensions of buttons

    cxButtons = (lpmb->cButtons * gpsi->wMaxBtnSize) + ((lpmb->cButtons - 1) * XPixFromXDU(DU_BTNGAP, gpsi->cxMsgFontChar));

    // Ditto for the icon, if there is one.  If not, cxIcon & cyIcon are 0.

    if (wIconOrdNum = MB_GetIconOrdNum(dwStyleMsg)) {
        cxIcon = SYSMET(CXICON) + XPixFromXDU(DU_INNERMARGIN, gpsi->cxMsgFontChar);
        cyIcon = SYSMET(CYICON);
    } else
        cxIcon = cyIcon = 0;

    hFontOld = SelectObject(hdc, KHFONT_TO_HFONT(gpsi->hCaptionFont));

    // Find the max between the caption text and the buttons
    wCaptionLen = wcslen(lpmb->lpszCaption);
    GetTextExtentPoint(hdc, lpmb->lpszCaption, wCaptionLen, &size);
    cxCaption = size.cx + 2*SYSMET(CXSIZE);

    //
    // The max width of the message box is 5/8 of the work area for most
    // countries.  We will then try 6/8 and 7/8 if it won't fit.  Then
    // we will use whole screen.
    //
    pMonitor = GetDialogMonitor(hwndOwner, MONITOR_DEFAULTTOPRIMARY);
    CopyRect(&rcWork, KPRECT_TO_PRECT(&pMonitor->rcWork));
    cxMBMax = MultDiv(rcWork.right - rcWork.left, 5, 8);

    cxFoo = 2*XPixFromXDU(DU_OUTERMARGIN, gpsi->cxMsgFontChar);

    SelectObject(hdc, KHFONT_TO_HFONT(gpsi->hMsgFont));

    //
    // If the text doesn't fit in 5/8, try 7/8 of the screen
    //
ReSize:
    //
    // The message box is as big as needed to hold the caption/text/buttons,
    // but not bigger than the maximum width.
    //

    cxBox = cxMBMax - 2*SYSMET(CXFIXEDFRAME);

    // Ask DrawText for the right cx and cy
    rc.left     = 0;
    rc.top      = 0;
    rc.right    = cxBox - cxFoo - cxIcon;
    rc.bottom   = rcWork.bottom - rcWork.top;
    cyText = DrawTextExW(hdc, (LPWSTR)lpmb->lpszText, -1, &rc,
                DT_CALCRECT | DT_WORDBREAK | DT_EXPANDTABS |
                DT_NOPREFIX | DT_EXTERNALLEADING | DT_EDITCONTROL, NULL);
    //
    // Make sure we have enough width to hold the buttons, in addition to
    // the icon+text.  Always force the buttons.  If they don't fit, it's
    // because the working area is small.
    //
    //
    // The buttons are centered underneath the icon/text.
    //
    cxText = rc.right - rc.left + cxIcon + cxFoo;
    cxBox = min(cxBox, max(cxText, cxCaption));
    cxBox = max(cxBox, cxButtons + cxFoo);
    cxText = cxBox - cxFoo - cxIcon;

    //
    // Now we know the text width for sure.  Really calculate how high the
    // text will be.
    //
    rc.left     = 0;
    rc.top      = 0;
    rc.right    = cxText;
    rc.bottom   = rcWork.bottom - rcWork.top;
    cyText      = DrawTextExW(hdc, (LPWSTR)lpmb->lpszText, -1, &rc, DT_CALCRECT | DT_WORDBREAK
        | DT_EXPANDTABS | DT_NOPREFIX | DT_EXTERNALLEADING | DT_EDITCONTROL, NULL);

    // Find the window size.
    cxBox += 2*SYSMET(CXFIXEDFRAME);
    cyBox = 2*SYSMET(CYFIXEDFRAME) + SYSMET(CYCAPTION) + YPixFromYDU(2*DU_OUTERMARGIN +
        DU_INNERMARGIN + DU_BTNHEIGHT, gpsi->cyMsgFontChar);

    cyBox += max(cyIcon, cyText);

    //
    // If the message box doesn't fit on the working area, we'll try wider
    // sizes successively:  6/8 of work then 7/8 of screen.
    //
    if (cyBox > rcWork.bottom - rcWork.top)
    {
        int cxTemp;

        cxTemp = MultDiv(rcWork.right - rcWork.left, 6, 8);

        if (cxMBMax == MultDiv(rcWork.right - rcWork.left, 5, 8))
        {
            cxMBMax = cxTemp;
            goto ReSize;
        }
        else if (cxMBMax == cxTemp)
        {
            // then let's try with rcMonitor
            CopyRect(&rcWork, KPRECT_TO_PRECT(&pMonitor->rcMonitor));
            cxMBMax = MultDiv(rcWork.right - rcWork.left, 7, 8);
            goto ReSize;
        }
    }

    if (hFontOld)
        SelectFont(hdc, hFontOld);
    NtUserReleaseDC(NULL, hdc);

    // Find the window position
    cntMBox = GetClientInfo()->pDeskInfo->cntMBox;

    xMB = (rcWork.left + rcWork.right - cxBox) / 2 + (cntMBox * SYSMET(CXSIZE));
    xMB = max(xMB, rcWork.left);
    yMB = (rcWork.top + rcWork.bottom - cyBox) / 2 + (cntMBox * SYSMET(CYSIZE));
    yMB = max(yMB, rcWork.top);

    // Bottom, right justify if we're going off the screen--but leave a
    // little gap

    if (xMB + cxBox > rcWork.right)
        xMB = rcWork.right - SYSMET(CXEDGE) - cxBox;

    //
    // Pin to the working area.  If it won't fit, then pin to the screen
    // height.  Bottom justify it at least if too big even for that, so
    // that the buttons are visible.
    //
    if (yMB + cyBox > rcWork.bottom) {
        yMB = rcWork.bottom - SYSMET(CYEDGE) - cyBox;
        if (yMB < rcWork.top) {
            yMB = pMonitor->rcMonitor.bottom - SYSMET(CYEDGE) - cyBox;
        }
    }

    wTextLen = wcslen(lpmb->lpszText);

    // Find out the memory required for the Dlg template and try to alloc it
    hTemplate = LocalAlloc(LMEM_ZEROINIT, MB_FindDlgTemplateSize(lpmb));

    if (!hTemplate)
        goto SMB_Exit;

    lpDlgTmp = (LPBYTE) hTemplate;

    //
    // Setup the dialog style for the message box
    //
    dwStyleDlg = WS_POPUPWINDOW | WS_CAPTION | DS_ABSALIGN | DS_NOIDLEMSG |
                 DS_SETFONT | DS_3DLOOK;

    if ((dwStyleMsg & MB_MODEMASK) == MB_SYSTEMMODAL)
        dwStyleDlg |= DS_SYSMODAL | DS_SETFOREGROUND;
    else
        dwStyleDlg |= DS_MODALFRAME | WS_SYSMENU;

    if (dwStyleMsg & MB_SETFOREGROUND)
        dwStyleDlg |= DS_SETFOREGROUND;

    // Add the Header of the Dlg Template
    // BOGUS !!!  don't ADD bools
    lpDlgTmp = MB_UpdateDlgHdr((LPDLGTEMPLATE) lpDlgTmp, dwStyleDlg, dwExStyleMsg,
        (BYTE) (lpmb->cButtons + (wIconOrdNum != 0) + (lpmb->lpszText != NULL)),
        xMB, yMB, cxBox, cyBox, (LPWSTR)lpmb->lpszCaption, wCaptionLen);

    //
    // Center the buttons
    //

    cxFoo = (cxBox - 2*SYSMET(CXFIXEDFRAME) - cxButtons) / 2;

    lpDlgTmp = MB_AddPushButtons((LPDLGITEMTEMPLATE)lpDlgTmp, lpmb, cxFoo,
        cyBox - SYSMET(CYCAPTION) - (2 * SYSMET(CYFIXEDFRAME)) -
        YPixFromYDU(DU_OUTERMARGIN, gpsi->cyMsgFontChar));

    // Add Icon, if any, to the Dlg template
    //
    // The icon is always top justified.  If the text is shorter than the
    // height of the icon, we center it.  Otherwise the text will start at
    // the top.
    //
    if (wIconOrdNum) {
        OrdNum[0] = 0xFFFF;  // To indicate that an Ordinal number follows
        OrdNum[1] = (WORD) wIconOrdNum;

        lpDlgTmp = MB_UpdateDlgItem((LPDLGITEMTEMPLATE)lpDlgTmp, IDUSERICON,        // Control Id
            SS_ICON | WS_GROUP | WS_CHILD | WS_VISIBLE, 0,
            XPixFromXDU(DU_OUTERMARGIN, gpsi->cxMsgFontChar),   // X co-ordinate
            YPixFromYDU(DU_OUTERMARGIN, gpsi->cyMsgFontChar),   // Y co-ordinate
            0,  0,          // For Icons, CX and CY are ignored, can be zero
            OrdNum,         // Ordinal number of Icon
            ARRAY_SIZE(OrdNum), // Length of OrdNum
            STATICCODE);
    }

    // Add the Text of the Message to the Dlg Template
    if (lpmb->lpszText) {
        //
        // Center the text if shorter than the icon.
        //
        if (cyText >= cyIcon)
            cxFoo = 0;
        else
            cxFoo = (cyIcon - cyText) / 2;

        dwStyleText = SS_NOPREFIX | WS_GROUP | WS_CHILD | WS_VISIBLE | SS_EDITCONTROL;
        if (dwStyleMsg & MB_RIGHT) {
            dwStyleText |= SS_RIGHT;
            xText = cxBox - (SYSMET(CXSIZE) + cxText);
        } else {
            dwStyleText |= SS_LEFT;
            xText = cxIcon + XPixFromXDU(DU_INNERMARGIN, gpsi->cxMsgFontChar);
        }

        MB_UpdateDlgItem((LPDLGITEMTEMPLATE)lpDlgTmp, -1, dwStyleText, dwExStyleMsg, xText,
            YPixFromYDU(DU_OUTERMARGIN, gpsi->cyMsgFontChar) + cxFoo,
            cxText, cyText,
            (LPWSTR)lpmb->lpszText, wTextLen, STATICCODE);
    }

    // The dialog template is ready

    //
    // Set the normal cursor
    //
    hcurOld = NtUserSetCursor(LoadCursor(NULL, IDC_ARROW));

    lpmb->lpszIcon = (LPWSTR) hIcon;

    if (!(lpmb->dwStyle & MB_USERICON))
    {
        int wBeep = (LOWORD(lpmb->dwStyle & MB_ICONMASK)) >> MB_MASKSHIFT;
        if (wBeep < USER_SOUND_MAX) {
            NtUserCallOneParam(wBeep, SFI_PLAYEVENTSOUND);
        }
    }

    iRetVal = (int)InternalDialogBox(hmodUser, hTemplate, hwndOwner,
        MB_DlgProc, (LPARAM) lpmb, FALSE);

    //
    // Fix up return value
    if (iRetVal == -1)
        iRetVal = 0;                /* Messagebox should also return error */

     //
     // If the messagebox contains only OK button, then its ID is changed as
     // IDCANCEL in MB_DlgProc; So, we must change it back to IDOK irrespective
     // of whether ESC is pressed or Carriage return is pressed;
     //
    if (((dwStyleMsg & MB_TYPEMASK) == MB_OK) && iRetVal)
        iRetVal = IDOK;


    //
    // Restore the previous cursor
    //
    if (hcurOld)
        NtUserSetCursor(hcurOld);

SMB_Exit:
    if (hTemplate)
        UserLocalFree(hTemplate);

    if (hCaption) {
        UserLocalFree(hCaption);
    }

    if (hText) {
        UserLocalFree(hText);
    }

    return iRetVal;
}

/***************************************************************************\
* MB_CopyToClipboard
*
* Called in response to WM_COPY, it will save the title, message and button's
* texts to the clipboard in CF_UNICODETEXT format.
*
*   ---------------------------
*   Caption
*   ---------------------------
*   Text
*   ---------------------------
*   Button1   ...   ButtonN
*   ---------------------------
*
*
* History:
* 08-03-97 MCostea      Created
\***************************************************************************/
VOID
MB_CopyToClipboard(
    HWND hwndDlg)
{
    LPCWSTR lpszRead;
    LPWSTR  lpszAll, lpszWrite;
    HANDLE  hData;
    static  WCHAR   szLine[] = L"---------------------------\r\n";
    UINT    cBufSize, i, cWrote;
    LPMSGBOXDATA lpmb;

    if (!(lpmb = (LPMSGBOXDATA)GetWindowLongPtr(hwndDlg, GWLP_USERDATA)))
        return;

    if (!OpenClipboard(hwndDlg))
        return;

    /*
     * Calculate the buffer size:
     *      - the message text can be all \n, that will become \r\n
     *      - there are a few extra \r\n (that's why 8)
     */
    cBufSize =  (lpmb->lpszCaption ? wcslen(lpmb->lpszCaption) : 0) +
                (lpmb->lpszText ? 2*wcslen(lpmb->lpszText) : 0) +
                4*sizeof(szLine) +
                lpmb->cButtons * gpsi->wMaxBtnSize +
                8;

    cBufSize *= sizeof(WCHAR);

    if (!(hData = UserGlobalAlloc(LHND, (LONG)(cBufSize))) ) {
        goto CloseClip;
    }

    USERGLOBALLOCK(hData, lpszAll);
    UserAssert(lpszAll);

    cWrote = wsprintf(lpszAll, L"%s%s\r\n%s",
                                szLine,
                                lpmb->lpszCaption ? lpmb->lpszCaption : L"",
                                szLine);

    lpszWrite = lpszAll + cWrote;
    lpszRead = lpmb->lpszText;
    /*
     * Change \n to \r\n in the text
     */
    for (i = 0; *lpszRead; i++) {

        if (*lpszRead == L'\n')
            *lpszWrite++ = L'\r';

        *lpszWrite++ = *lpszRead++;
    }

    cWrote = wsprintf(lpszWrite, L"\r\n%s", szLine);
    lpszWrite += cWrote;

    /*
     * Remove & from the button texts
     */
    for (i = 0; i<lpmb->cButtons; i++) {

        lpszRead = lpmb->ppszButtonText[i];
        while (*lpszRead) {
            if (*lpszRead != L'&') {
                *lpszWrite++ = *lpszRead;
            }
            lpszRead++;
        }
        *lpszWrite++ = L' ';
        *lpszWrite++ = L' ';
        *lpszWrite++ = L' ';
    }
    wsprintf(lpszWrite, L"\r\n%s\0", szLine);

    USERGLOBALUNLOCK(hData);

    NtUserEmptyClipboard();
    /*
     * If we just called EmptyClipboard in the context of a 16 bit
     * app then we also have to tell WOW to nix its 16 handle copy of
     * clipboard data.  WOW does its own clipboard caching because
     * some 16 bit apps use clipboard data even after the clipboard
     * has been emptied.  See the note in the server code.
     *
     * Note: this is another place (besides client\editec.c) where
     * EmptyClipboard is called* for a 16 bit app not going through WOW.
     * If we added others we might want to move this into EmptyClipboard
     * and have two versions.
     */
    if (GetClientInfo()->CI_flags & CI_16BIT) {
        pfnWowEmptyClipBoard();
    }

    SetClipboardData(CF_UNICODETEXT, hData);

CloseClip:
    NtUserCloseClipboard();

}

/***************************************************************************\
* MB_UpdateDlgHdr
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/

LPBYTE MB_UpdateDlgHdr(
    LPDLGTEMPLATE lpDlgTmp,
    long lStyle,
    long lExtendedStyle,
    BYTE bItemCount,
    int iX,
    int iY,
    int iCX,
    int iCY,
    LPWSTR lpszCaption,
    int cchCaptionLen)
{
    LPTSTR lpStr;
    RECT rc;

    /*
     * Adjust the rectangle dimensions.
     */
    rc.left     = iX + SYSMET(CXFIXEDFRAME);
    rc.top      = iY + SYSMET(CYFIXEDFRAME);
    rc.right    = iX + iCX - SYSMET(CXFIXEDFRAME);
    rc.bottom   = iY + iCY - SYSMET(CYFIXEDFRAME);


    /*
     * Adjust for the caption.
     */
    rc.top += SYSMET(CYCAPTION);

    lpDlgTmp->style = lStyle;
    lpDlgTmp->dwExtendedStyle = lExtendedStyle;
    lpDlgTmp->cdit = bItemCount;
    lpDlgTmp->x  = XDUFromXPix(rc.left, gpsi->cxMsgFontChar);
    lpDlgTmp->y  = YDUFromYPix(rc.top, gpsi->cyMsgFontChar);
    lpDlgTmp->cx = XDUFromXPix(rc.right - rc.left, gpsi->cxMsgFontChar);
    lpDlgTmp->cy = YDUFromYPix(rc.bottom - rc.top, gpsi->cyMsgFontChar);

    /*
     * Move pointer to variable length fields.  No menu resource for
     * message box, a zero window class (means dialog box class).
     */
    lpStr = (LPWSTR)(lpDlgTmp + 1);
    *lpStr++ = 0;                           // Menu
    lpStr = (LPWSTR)NextWordBoundary(lpStr);
    *lpStr++ = 0;                           // Class
    lpStr = (LPWSTR)NextWordBoundary(lpStr);

    /*
     * NOTE: iCaptionLen may be less than the length of the Caption string;
     * So, DO NOT USE lstrcpy();
     */
    RtlCopyMemory(lpStr, lpszCaption, cchCaptionLen*sizeof(WCHAR));
    lpStr += cchCaptionLen;
    *lpStr++ = TEXT('\0');                // Null terminate the caption str

    /*
     * Font height of 0x7FFF means use the message box font
     */
    *lpStr++ = 0x7FFF;

    return NextDWordBoundary(lpStr);
}

/***************************************************************************\
* MB_AddPushButtons
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/

LPBYTE MB_AddPushButtons(
    LPDLGITEMTEMPLATE  lpDlgTmp,
    LPMSGBOXDATA       lpmb,
    UINT               wLEdge,
    UINT               wBEdge)
{
    UINT   wYValue;
    UINT   i;
    UINT   wHeight;
    UINT   wCount = lpmb->cButtons;

    wHeight = YPixFromYDU(DU_BTNHEIGHT, gpsi->cyMsgFontChar);

    wYValue = wBEdge - wHeight;         // Y co-ordinate for push buttons

    for (i = 0; i < wCount; i++) {

        lpDlgTmp = (LPDLGITEMTEMPLATE)MB_UpdateDlgItem(
                lpDlgTmp,                       /* Ptr to template */
                lpmb->pidButton[i],             /* Control Id */
                WS_TABSTOP | WS_CHILD | WS_VISIBLE | (i == 0 ? WS_GROUP : 0) |
                ((UINT)i == lpmb->DefButton ? BS_DEFPUSHBUTTON : BS_PUSHBUTTON),
                0,
                wLEdge,                         /* X co-ordinate */
                wYValue,                        /* Y co-ordinate */
                gpsi->wMaxBtnSize,              /* CX */
                wHeight,                        /* CY */
                lpmb->ppszButtonText[i],        /* String for button */
                (UINT)wcslen(lpmb->ppszButtonText[i]),/* Length */
                BUTTONCODE);

        /*
         * Get the X co-ordinate for the next Push button
         */
        wLEdge += gpsi->wMaxBtnSize + XPixFromXDU(DU_BTNGAP, gpsi->cxMsgFontChar);
    }

    return (LPBYTE)lpDlgTmp;
}

/***************************************************************************\
* MB_UpdateDlgItem
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/

LPBYTE MB_UpdateDlgItem(
    LPDLGITEMTEMPLATE lpDlgItem,
    int iCtrlId,
    long lStyle,
    long lExtendedStyle,
    int iX,
    int iY,
    int iCX,
    int iCY,
    LPWSTR lpszText,
    UINT cchTextLen,
    int iControlClass)
{
    LPWSTR lpStr;
    BOOL fIsOrdNum;


    lpDlgItem->x        = XDUFromXPix(iX, gpsi->cxMsgFontChar);
    lpDlgItem->y        = YDUFromYPix(iY, gpsi->cyMsgFontChar);
    lpDlgItem->cx       = XDUFromXPix(iCX,gpsi->cxMsgFontChar);
    lpDlgItem->cy       = YDUFromYPix(iCY,gpsi->cyMsgFontChar);
    lpDlgItem->id       = (WORD)iCtrlId;
    lpDlgItem->style    = lStyle;
    lpDlgItem->dwExtendedStyle = lExtendedStyle;

    /*
     * We have to avoid the following nasty rounding off problem:
     * (e.g) If iCX=192 and cxSysFontChar=9, then cx becomes 85; When the
     * static text is drawn, from 85 dlg units we get 191 pixels; So, the text
     * is truncated;
     * So, to avoid this, check if this is a static text and if so,
     * add one more dialog unit to cx and cy;
     * --Fix for Bug #4481 --SANKAR-- 09-29-89--
     */

    /*
     * Also, make sure we only do this to static text items.  davidds
     */

    /*
     * Now static text uses SS_NOPREFIX = 0x80;
     * So, test the lStyle field only with 0x0F instead of 0xFF;
     * Fix for Bugs #5933 and 5935 --SANKAR-- 11-28-89
     */
    if (iControlClass == STATICCODE &&
         (((lStyle & 0x0F) == SS_LEFT) || ((lStyle & 0x0F) == SS_RIGHT))) {

        /*
         * This is static text
         */
        lpDlgItem->cx++;
        lpDlgItem->cy++;
    }

    /*
     * Move ptr to the variable fields
     */
    lpStr = (LPWSTR)(lpDlgItem + 1);

    /*
     * Store the Control Class value
     */
    *lpStr++ = 0xFFFF;
    *lpStr++ = (BYTE)iControlClass;
    lpStr = (LPWSTR)NextWordBoundary(lpStr);        // WORD-align lpszText

    /*
     * Check if the String contains Ordinal number or not
     */
    fIsOrdNum = ((*lpszText == 0xFFFF) && (cchTextLen == sizeof(DWORD)/sizeof(WCHAR)));

    /*
     * NOTE: cchTextLen may be less than the length of lpszText.  So,
     * DO NOT USE lstrcpy() for the copy.
     */
    RtlCopyMemory(lpStr, lpszText, cchTextLen*sizeof(WCHAR));
    lpStr = lpStr + cchTextLen;
    if (!fIsOrdNum) {
        *lpStr = TEXT('\0');    // NULL terminate the string
        lpStr = (LPWSTR)NextWordBoundary(lpStr + 1);
    }

    *lpStr++ = 0;           // sizeof control data (there is none)

    return NextDWordBoundary(lpStr);
}


/***************************************************************************\
* MB_FindDlgTemplateSize
*
* This routine computes the amount of memory that will be needed for the
* messagebox's dialog template structure.  The dialog template has several
* required and optional records.  The dialog manager expects each record to
* be DWORD aligned so any necessary padding is also accounted for.
*
* (header - required)
* DLGTEMPLATE (header) + 1 menu byte + 1 pad + 1 class byte + 1 pad
* szCaption + 0 term + DWORD alignment
*
* (static icon control - optional)
* DLGITEMTEMPLATE + 1 class byte + 1 pad + (0xFF00 + icon ordinal # [szText]) +
* UINT alignment + 1 control data length byte (0) + DWORD alignment
*
* (pushbutton controls - variable, but at least one required)
* DLGITEMTEMPLATE + 1 class byte + 1 pad + length of button text +
* UINT alignment + 1 control data length byte (0) + DWORD alignment
*
* (static text control - optional)
* DLGITEMTEMPLATE + 1 class byte + 1 pad + length of text +
* UINT alignment + 1 control data length byte (0) + DWORD alignment
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/
UINT
MB_FindDlgTemplateSize(
    LPMSGBOXDATA lpmb)
{
    ULONG_PTR cbLen;
    UINT cbT;
    UINT i;
    UINT wCount;

    wCount = lpmb->cButtons;

    /*
     * Start with dialog header's size.
     */
    cbLen = (ULONG_PTR)NextWordBoundary(sizeof(DLGTEMPLATE) + sizeof(WCHAR));
    cbLen = (ULONG_PTR)NextWordBoundary(cbLen + sizeof(WCHAR));
    cbLen += wcslen(lpmb->lpszCaption) * sizeof(WCHAR) + sizeof(WCHAR);
    cbLen += sizeof(WORD);                   // Font height
    cbLen = (ULONG_PTR)NextDWordBoundary(cbLen);

    /*
     * Check if an Icon is present.
     */
    if (lpmb->dwStyle & MB_ICONMASK)
        cbLen += (ULONG_PTR)NextDWordBoundary(sizeof(DLGITEMTEMPLATE) + 7 * sizeof(WCHAR));

    /*
     * Find the number of buttons in the msg box.
     */
    for (i = 0; i < wCount; i++) {
        cbLen = (ULONG_PTR)NextWordBoundary(cbLen + sizeof(DLGITEMTEMPLATE) +
                (2 * sizeof(WCHAR)));
        cbT = (wcslen(lpmb->ppszButtonText[i]) + 1) * sizeof(WCHAR);
        cbLen = (ULONG_PTR)NextWordBoundary(cbLen + cbT);
        cbLen += sizeof(WCHAR);
        cbLen = (ULONG_PTR)NextDWordBoundary(cbLen);
    }

    /*
     * Add in the space required for the text message (if there is one).
     */
    if (lpmb->lpszText != NULL) {
        cbLen = (ULONG_PTR)NextWordBoundary(cbLen + sizeof(DLGITEMTEMPLATE) +
                (2 * sizeof(WCHAR)));
        cbT = (wcslen(lpmb->lpszText) + 1) * sizeof(WCHAR);
        cbLen = (ULONG_PTR)NextWordBoundary(cbLen + cbT);
        cbLen += sizeof(WCHAR);
        cbLen = (ULONG_PTR)NextDWordBoundary(cbLen);
    }

    return (UINT)cbLen;
}

/***************************************************************************\
* MB_GetIconOrdNum
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/

UINT MB_GetIconOrdNum(
    UINT rgBits)
{
    switch (rgBits & MB_ICONMASK) {
    case MB_USERICON:
    case MB_ICONHAND:
        return PtrToUlong(IDI_HAND);

    case MB_ICONQUESTION:
        return PtrToUlong(IDI_QUESTION);

    case MB_ICONEXCLAMATION:
        return PtrToUlong(IDI_EXCLAMATION);

    case MB_ICONASTERISK:
        return PtrToUlong(IDI_ASTERISK);
    }

    return 0;
}

/***************************************************************************\
* MB_GetString
*
* History:
*  1-24-95 JerrySh      Created.
\***************************************************************************/
LPWSTR MB_GetString(
    UINT wBtn)
{
    if (wBtn < MAX_SEB_STYLES)
        return GETGPSIMBPSTR(wBtn);

    RIPMSG1(RIP_ERROR, "Invalid wBtn: %d", wBtn);

    return NULL;
}

/***************************************************************************\
* MB_DlgProc
*
* Returns: TRUE  - message processed
*          FALSE - message not processed
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/
INT_PTR MB_DlgProc(
    HWND hwndDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndT;
    int iCount;
    LPMSGBOXDATA lpmb;
    HWND hwndOwner;
    PVOID lpfnCallback;
    PWND pwnd;
    BOOL bTimedOut = FALSE;

    switch (wMsg) {
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORSTATIC:
        if ((pwnd = ValidateHwnd(hwndDlg)) == NULL)
            return 0L;
        return DefWindowProcWorker(pwnd, WM_CTLCOLORMSGBOX,
                                   wParam, lParam, FALSE);

    case WM_TIMER:
        if (!bTimedOut) {
            bTimedOut = TRUE;
            EndTaskModalDialog(hwndDlg);
            EndDialog(hwndDlg, IDTIMEOUT);
        }
        break;

    case WM_NCDESTROY:
        if ((lpmb = (LPMSGBOXDATA)GetWindowLongPtr(hwndDlg, GWLP_USERDATA))) {
            if (lpmb->dwTimeout != INFINITE) {
                NtUserKillTimer(hwndDlg, 0);
                lpmb->dwTimeout = INFINITE;
            }
        }
        if ((pwnd = ValidateHwnd(hwndDlg)) == NULL) {
            return 0L;
        }
        return DefWindowProcWorker(pwnd, wMsg,
                                   wParam, lParam, FALSE);


    case WM_INITDIALOG:

        lpmb = (LPMSGBOXDATA)lParam;
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (ULONG_PTR)lParam);

        NtUserCallHwnd(hwndDlg, SFI_SETMSGBOX);

        /*
         * Create the message box atoms, if we haven't done it yet
         */
        if (atomBwlProp == 0) {
            atomBwlProp = AddAtomW(WINDOWLIST_PROP_NAME);
            atomMsgBoxCallback = AddAtomW(MSGBOX_CALLBACK);

            if (atomBwlProp == 0 || atomMsgBoxCallback == 0) {
                RIPMSG0(RIP_WARNING, "MB_DlgProc: AddAtomW failed.  Out of memory?");
            }
        }

        if (lpmb->dwStyle & MB_HELP) {
            NtUserSetWindowContextHelpId(hwndDlg, lpmb->dwContextHelpId);
            //See if there is an app supplied callback.
            if (!gfServerProcess && lpmb->lpfnMsgBoxCallback)
                SetProp(hwndDlg, MAKEINTATOM(atomMsgBoxCallback),
                            lpmb->lpfnMsgBoxCallback);
        }

        if (lpmb->dwStyle & MB_TOPMOST)
            NtUserSetWindowPos(hwndDlg, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

        if (lpmb->dwStyle & MB_USERICON) {
            SendDlgItemMessage(hwndDlg, IDUSERICON, STM_SETICON, (WPARAM)(lpmb->lpszIcon), 0);
            iCount = ALERT_SYSTEM_WARNING;
        } else {
            /*
             * Generate an alert notification
             */
            switch (lpmb->dwStyle & MB_ICONMASK) {
            case MB_ICONWARNING:
                iCount = ALERT_SYSTEM_WARNING;
                break;

            case MB_ICONQUESTION:
                iCount = ALERT_SYSTEM_QUERY;
                break;

            case MB_ICONERROR:
                iCount = ALERT_SYSTEM_ERROR;
                break;

            case MB_ICONINFORMATION:
            default:
                iCount = ALERT_SYSTEM_INFORMATIONAL;
                break;
            }
        }

        NotifyWinEvent(EVENT_SYSTEM_ALERT, hwndDlg, OBJID_ALERT, iCount);

#ifdef LATER
// darrinm - 06/17/91
// SYSMODAL dialogs are history for now.

        /*
         * Check if the Dialog box is a Sys Modal Dialog Box
         */
        if (GetWindowLong(hwndDlg, GWL_STYLE) & DS_SYSMODAL, FALSE)
            SetSysModalWindow(hwndDlg);
#endif

        if ((lpmb->hwndOwner == NULL) &&
                ((lpmb->dwStyle & MB_MODEMASK) == MB_TASKMODAL)) {
            StartTaskModalDialog(hwndDlg);
        }

        /*
         * Set focus on the default button
         */
        hwndT = GetWindow(hwndDlg, GW_CHILD);
        iCount = lpmb->DefButton;
        while (iCount--)
            hwndT = GetWindow(hwndT, GW_HWNDNEXT);

        NtUserSetFocus(hwndT);

        //
        // Need the dialog's HWND later, but we reuse hwndDlg.
        //
        hwndT = hwndDlg;

        //
        // If this dialogbox does not contain a IDCANCEL button, then
        // remove the CLOSE command from the system menu.
        // Bug #4445, --SANKAR-- 09-13-89 --
        //
        if (lpmb->CancelId == 0)
        {
            HMENU hMenu;
            if (hMenu = NtUserGetSystemMenu(hwndDlg, FALSE))
                NtUserDeleteMenu(hMenu, SC_CLOSE, (UINT)MF_BYCOMMAND);
        }

        if ((lpmb->dwStyle & MB_TYPEMASK) == MB_OK)
        {
            //
            // Make the ID of OK button to be CANCEL, because we want
            // the ESC to terminate the dialogbox; GetDlgItem32() will
            // not fail, because this is MB_OK messagebox!
            //

            hwndDlg = GetDlgItem(hwndDlg, IDOK);

            if (hwndDlg != NULL) {
            //    hwndDlg->hMenu = (HMENU)IDCANCEL;
                SetWindowLongPtr(hwndDlg, GWLP_ID, IDCANCEL);
            } else {
                RIPMSG0(RIP_WARNING, "MB_DlgProc- IDOK control not found");
            }
        }

        if (lpmb->dwTimeout != INFINITE) {
            if (NtUserSetTimer(hwndT, 0, lpmb->dwTimeout, NULL) == 0) {
                /*
                 * Couldn't create the timer, so "clear" out the timeout value
                 * for future reference.
                 */
                lpmb->dwTimeout = INFINITE;
            }
        }

        /*
         * We have changed the input focus
         */
        return FALSE;

    case WM_HELP:
        // When user hits an F1 key, it results in this message.
        // It is possible that this MsgBox has a callback instead of a
        // parent. So, we must behave as if the user hit the HELP button.

        goto  MB_GenerateHelp;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
        case IDCANCEL:
           //
           // Check if a control exists with the given ID; This
           // check is needed because DlgManager returns IDCANCEL
           // blindly when ESC is pressed even if a button with
           // IDCANCEL is not present.
           // Bug #4445 --SANKAR--09-13-1989--
           //
           if (!GetDlgItem(hwndDlg, LOWORD(wParam)))
              return FALSE;


           // else FALL THRO....This is intentional.
        case IDABORT:
        case IDIGNORE:
        case IDNO:
        case IDRETRY:
        case IDYES:
        case IDTRYAGAIN:
        case IDCONTINUE:
           EndTaskModalDialog(hwndDlg);
           EndDialog(hwndDlg, LOWORD(wParam));
             break;
        case IDHELP:
MB_GenerateHelp:
                // Generate the WM_HELP message and send it to owner or callback
           hwndOwner = NULL;

           // Check if there is an app supplied callback for this MsgBox
           if (!(lpfnCallback = (PVOID)GetProp(hwndDlg,
                                  MAKEINTATOM(atomMsgBoxCallback)))) {
               // If not, see if we need to inform the parent.
               hwndOwner = GetWindow(hwndDlg, GW_OWNER);
#ifdef LATER
               // Chicagoism
               if (hwndOwner && hwndOwner == GetDesktopWindow())
                   hwndOwner = NULL;
#endif
           }

                // See if we need to generate the Help message or call back.
           if (hwndOwner || lpfnCallback) {
               if (lpfnCallback && gfServerProcess) {
                   break;
               }
               SendHelpMessage(hwndOwner, HELPINFO_WINDOW, IDHELP,
                   hwndDlg, NtUserGetWindowContextHelpId(hwndDlg), lpfnCallback);
           }
           break;

        default:
            return FALSE;
            break;
        }
        break;

    case WM_COPY:
        MB_CopyToClipboard(hwndDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


/***************************************************************************\
* StartTaskModalDialog
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/
VOID
StartTaskModalDialog(
    HWND hwndDlg)
{
    int cHwnd;
    HWND *phwnd;
    HWND *phwndList, *phwndEnd;
    HWND hwnd;
    PWND pwnd;

    /*
     * Get the hwnd list.  It is returned in a block of memory
     * allocated with LocalAlloc.
     */
    if ((cHwnd = BuildHwndList(NULL, NULL, FALSE, GetCurrentThreadId(), &phwndList)) == 0) {
        return;
    }
    /*
     * If atomBwlProp couldn't be added in WM_INITDIALOG processing, SetProp will fail
     * and we need to free the hwndList as EndTaskModalDialog will not be able to do that
     * MCostea 226543
     */
    if (!SetProp(hwndDlg, MAKEINTATOM(atomBwlProp), (HANDLE)phwndList)) {
        UserLocalFree(phwndList);
        return;
    }

    phwndEnd = phwndList + cHwnd;
    for (phwnd = phwndList; phwnd < phwndEnd; phwnd++) {
        if ((hwnd = *phwnd) == NULL || (pwnd = RevalidateHwnd(hwnd)) == NULL)
            continue;

        /*
         * if the window belongs to the current task and is enabled, disable
         * it.  All other windows are NULL'd out, to prevent their being
         * enabled later
         */
        if (!TestWF(pwnd, WFDISABLED) && DIFFWOWHANDLE(hwnd, hwndDlg)) {
            NtUserEnableWindow(hwnd, FALSE);
        } else {
            *phwnd = NULL;
        }
    }
}


/***************************************************************************\
* EndTaskModalDialog
*
* History:
* 11-20-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/
VOID
EndTaskModalDialog(
    HWND hwndDlg)
{
    HWND *phwnd;
    HWND *phwndList;
    HWND hwnd;

    phwndList = (HWND *)GetProp(hwndDlg, MAKEINTATOM(atomBwlProp));

    if (phwndList == NULL)
        return;

    RemoveProp(hwndDlg, MAKEINTATOM(atomBwlProp));

    for (phwnd = phwndList; *phwnd != (HWND)1; phwnd++) {
        if ((hwnd = *phwnd) != NULL) {
            NtUserEnableWindow(hwnd, TRUE);
        }
    }

    UserLocalFree(phwndList);
}

#ifdef _JANUS_
/***************************************************************************\
* ErrorMessageInst
*
* Instrument routine for recording error msg
*
* Returns: TRUE  - Instrument error msg Success
*          FALSE - Fail
*
* History:
*   8-5-98 Chienho      Created
\***************************************************************************/

BOOL ErrorMessageInst(
     LPMSGBOXDATA pMsgBoxParams)
{
    ERROR_ELEMENT ErrEle;
    WCHAR *pwcs;
    PVOID ImageBase;
    PIMAGE_NT_HEADERS NtHeaders;
    BOOL rc;
    WCHAR szUnknown[32];

    /*
     * Check if the MessageBox style is within the logged severity level
     */
    switch (pMsgBoxParams->dwStyle & MB_ICONMASK) {
    case MB_ICONHAND:
        /*
         * when EMI is enabled, we at least log error messages
         */
        break;
    case MB_ICONEXCLAMATION:
        if (gdwEMIControl > EMI_SEVERITY_WARNING) {
            rc = TRUE;
            goto End;
        }
        break;
    case MB_ICONQUESTION:
        if (gdwEMIControl > EMI_SEVERITY_QUESTION) {
            rc = TRUE;
            goto End;
        }
        break;
    case MB_ICONASTERISK:
        if (gdwEMIControl > EMI_SEVERITY_INFORMATION) {
            rc = TRUE;
            goto End;
        }
        break;
    case MB_USERICON:
        if (gdwEMIControl > EMI_SEVERITY_USER) {
            rc = TRUE;
            goto End;
        }
        break;
    default:
        if (gdwEMIControl > EMI_SEVERITY_ALL) {
            rc = TRUE;
            goto End;
        }
        break;
    }

    if (gdwEMIThreadID != GETTHREADID()) {
        rc = FALSE;
        goto End;
    }
    RtlZeroMemory(&ErrEle, sizeof(ErrEle));

    /*
     * get last error first, check with FormatMessage???
     */
    ErrEle.dwErrorCode = GetLastError();

    /*
     * get return address
     */

    ErrEle.ReturnAddr = gpReturnAddr;

    /*
     * get the process image name
     */
    GetCurrentProcessName(ErrEle.ProcessName, sizeof(ErrEle.ProcessName));

    /*
     * Load the "unknown" string
     */
    LoadString(hmodUser, STR_UNKNOWN, szUnknown, ARRAYSIZE(szUnknown));

    /*
     * get the window title
     */
    GetWindowTextW(pMsgBoxParams->hwndOwner, ErrEle.WindowTitle, TITLE_SIZE);
    if (!(*(ErrEle.WindowTitle))) {
        lstrcpy(ErrEle.WindowTitle, szUnknown);
    }

    /*
     * get messagebox data
     */
    ErrEle.lpszText = (LPWSTR)pMsgBoxParams->lpszText;
    ErrEle.lpszCaption = (LPWSTR)pMsgBoxParams->lpszCaption;
    ErrEle.dwStyle = pMsgBoxParams->dwStyle;

    /*
     * resolve the module name of caller
     */
    if (!RtlPcToFileHeader((PVOID)ErrEle.ReturnAddr, &ImageBase)) {
        RIPMSG0(RIP_WARNING, "ErrorMessageInst: Can't find Caller");
        ErrEle.BaseAddr = (PVOID)-1;
        ErrEle.dwImageSize = -1;
        lstrcpy(ErrEle.CallerModuleName, szUnknown);
    } else {
        ErrEle.BaseAddr = ImageBase;
        if (GetModuleFileName((HMODULE)ImageBase, ErrEle.CallerModuleName, MAX_PATH)) {
            pwcs = wcsrchr(ErrEle.CallerModuleName, TEXT('\\'));
            if (pwcs) {
                pwcs++;
                lstrcpy(ErrEle.CallerModuleName, pwcs);
            }
        } else {
            lstrcpy(ErrEle.CallerModuleName, szUnknown);
        }
        NtHeaders = RtlImageNtHeader(ImageBase);
        if (NtHeaders == NULL) {
            ErrEle.dwImageSize = -1;
        } else {
            ErrEle.dwImageSize = NtHeaders->OptionalHeader.SizeOfImage;
        }
    }
    /*
     * Register the event if we haven't done so already.
     * Since RegisterEventSource is supported by a service, we must not hold
     * any locks while making this call. Hence we might have several threads
     * registering the event simultaneously.
     */

    if (!gEventSource) {
        gEventSource = RegisterEventSourceW(NULL, L"Error Instrument");
        if (!gEventSource) {
            ErrEle.dwErrorCode = GetLastError();
            rc = FALSE;
        }
    }

    /*
     * report event
     */
    if (gEventSource) {
       rc = LogMessageBox(&ErrEle);
    }

    /*
     * allow to process another event log again
     */

    InterlockedExchangePointer(&gdwEMIThreadID, 0);

End:
    return rc;
}

/***************************************************************************\
* InitInstrument
*
* Returns: TRUE  - Initialization Success
*          FALSE - Initialization Fail
*
\***************************************************************************/
BOOL InitInstrument(
    LPDWORD lpEMIControl)
{
    NTSTATUS Status;
    HKEY hKeyEMI = NULL;
    UNICODE_STRING UnicodeStringEMIKey;
    UNICODE_STRING UnicodeStringEnable;
    UNICODE_STRING UnicodeStringStyle;
    OBJECT_ATTRIBUTES ObjA;
    DWORD EMIEnable = 0; //means disable
    DWORD EMISeverity;
    struct {
        KEY_VALUE_PARTIAL_INFORMATION;
        LARGE_INTEGER;
    } EMIValueInfo;
    DWORD dwDisposition;

    RtlInitUnicodeString(&UnicodeStringEMIKey, szEMIKey);
    InitializeObjectAttributes(&ObjA, &UnicodeStringEMIKey, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = NtOpenKey(&hKeyEMI, KEY_READ, &ObjA);
    if (!NT_SUCCESS(Status)) {
        /*
         * Key doesn't exist, assume disable
         */
        return FALSE;
    }

    /*
     * read the logging enable and setting
     */
    RtlInitUnicodeString(&UnicodeStringEnable, szEMIEnable);
    Status = NtQueryValueKey(hKeyEMI,
                     &UnicodeStringEnable,
                     KeyValuePartialInformation,
                     &EMIValueInfo,
                     sizeof(EMIValueInfo),
                     &dwDisposition);

    if (NT_SUCCESS(Status)) {

        RtlCopyMemory(&EMIEnable, &EMIValueInfo.Data, sizeof(EMIEnable));

        RtlInitUnicodeString(&UnicodeStringStyle, szEMISeverity);
        Status = NtQueryValueKey(hKeyEMI,
                         &UnicodeStringStyle,
                         KeyValuePartialInformation,
                         &EMIValueInfo,
                         sizeof(EMIValueInfo),
                         &dwDisposition);

        if (NT_SUCCESS(Status)) {
            RtlCopyMemory(&EMISeverity, &EMIValueInfo.Data, sizeof(EMISeverity));
            /*
             * Validate data
             */
            if (EMISeverity > EMI_SEVERITY_MAX_VALUE) {
                EMISeverity = EMI_SEVERITY_MAX_VALUE;
            }
        } else {
            /*
             * default severity for instrument
             */
            EMISeverity = EMI_SEVERITY_WARNING;
        }
        *lpEMIControl = EMISeverity;
    }

    /*
     * read default message reply enable
     */
    RtlInitUnicodeString(&UnicodeStringEnable, szDMREnable);
    Status = NtQueryValueKey(hKeyEMI,
                     &UnicodeStringEnable,
                     KeyValuePartialInformation,
                     &EMIValueInfo,
                     sizeof(EMIValueInfo),
                     &dwDisposition);

    if (NT_SUCCESS(Status)) {
        RtlCopyMemory(&gfDMREnable, &EMIValueInfo.Data, sizeof(gfDMREnable));
    }

    NtClose(hKeyEMI);

    if (EMIEnable) {

          /*
           * add eventlog file
           */
          if (NT_SUCCESS(CreateLogSource())) {
              return TRUE;
          }
    }
    return FALSE;
}

/***************************************************************************\
* CreateLogSource
*
* Create the event source for eventlog
* Return : NTSTATUS
*
\***************************************************************************/
NTSTATUS CreateLogSource()
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeStringEventKey;
    OBJECT_ATTRIBUTES ObjA;
    HKEY hKeyEvent = NULL;
    UNICODE_STRING UnicodeString;
    DWORD dwDisposition;


    RtlInitUnicodeString(&UnicodeStringEventKey, szEventKey);
    InitializeObjectAttributes(&ObjA, &UnicodeStringEventKey, OBJ_CASE_INSENSITIVE, NULL, NULL);

    if (NT_SUCCESS(Status = NtOpenKey(&hKeyEvent, KEY_READ, &ObjA))) {

        struct {
            KEY_VALUE_PARTIAL_INFORMATION KeyInfo;
            WCHAR awchMsgFileName[256];
        } MsgFile;

        RtlInitUnicodeString(&UnicodeString, szEventMsgFile);

        Status = NtQueryValueKey(hKeyEvent,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 &MsgFile,
                                 sizeof MsgFile,
                                 &dwDisposition);
        if (NT_SUCCESS(Status)) {
            Status = lstrcmpi((LPWSTR)MsgFile.KeyInfo.Data, L"%SystemRoot%\\System32\\user32.dll");
        }
        NtClose(hKeyEvent);
    }

    return Status;
}

/***************************************************************************\
* LogMessageBox
*
* Output error message record into eventlog
*
\***************************************************************************/
BOOL LogMessageBox(
    LPERROR_ELEMENT lpErrEle)
{

    LPWSTR      lps[8];
    DWORD       dwData[2];
    WCHAR       BaseAddress[19];
    WCHAR       ImageSize[19];
    WCHAR       ReturnAddress[19];
    PTOKEN_USER pTokenUser = NULL;
    PSID        pSid = NULL;
    BOOL        rc;

    lps[0] = lpErrEle->ProcessName;
    lps[1] = lpErrEle->WindowTitle;
    lps[2] = lpErrEle->lpszCaption;
    lps[3] = lpErrEle->lpszText;
    lps[4] = lpErrEle->CallerModuleName;
    wsprintf(BaseAddress, L"%-#16p", lpErrEle->BaseAddr);
    lps[5] = BaseAddress;
    wsprintf(ImageSize, L"%-#16lX", lpErrEle->dwImageSize);
    lps[6] = ImageSize;
    wsprintf(ReturnAddress, L"%-#16p", lpErrEle->ReturnAddr);
    lps[7] = ReturnAddress;

    dwData[0] = lpErrEle->dwStyle;
    dwData[1] = lpErrEle->dwErrorCode;

    if (GetUserSid(&pTokenUser))
        pSid = pTokenUser->User.Sid;

    UserAssert(gEventSource != NULL);
    rc = ReportEventW(gEventSource, EVENTLOG_INFORMATION_TYPE, 0,
                      STATUS_LOG_ERROR_MSG, pSid, sizeof(lps) / sizeof(*lps),
                      sizeof(dwData), lps, dwData);

    if (pTokenUser) {

        VirtualFree(pTokenUser, 0, MEM_RELEASE);
    }

    return rc;
}
#endif //_JANUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\precomp.h ===
/*
 * Core NT headers
 */
#define NONTOSPINTERLOCK
#include <ntosp.h>

#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrdll.h>
#include <ntcsrsrv.h>

/*
 * Standard C runtime headers
 */
#include <limits.h>
#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

/*
 * NtUser global headers
 */

/*
 * NtUser Client specific headers
 */
#include "usercli.h"

#include <ntsdexts.h>
#include <windowsx.h>
#include <newres.h>
#include <asdf.h>

#include <winsta.h>


/*
 * For UNLEN #define
 */
#include <lmcons.h>

#include <sxstypes.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\ntcftxt.h ===
/***************************** Module Header ******************************\
* Module Name: ntcftxt.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Kernel call forward stubs with text arguments
*
* Each function will be created with two flavors Ansi and Unicode
*
* 06-Jan-1992 IanJa      Moved from cf.h
* 18-Mar-1995 JimA       Ported from cftxt.h
\**************************************************************************/

#ifdef UNICODE
#define IS_ANSI FALSE
#ifndef _UNICODE
#define _UNICODE
#endif
#else
#define IS_ANSI TRUE
#undef _UNICODE
#endif
#include <tchar.h>
#include "ntsend.h"

HWND TEXT_FN(InternalFindWindowEx)(
    HWND    hwndParent,
    HWND    hwndChild,
    LPCTSTR pClassName,
    LPCTSTR pWindowName,
    DWORD   dwFlag)
{
    IN_STRING strClass;
    IN_STRING strWindow;

    /*
     * Make sure cleanup will work successfully
     */
    strClass.fAllocated = FALSE;
    strWindow.fAllocated = FALSE;

    BEGINCALL()

        FIRSTCOPYLPTSTRIDOPT(&strClass, pClassName);
        COPYLPTSTROPT(&strWindow, pWindowName);

        retval = (ULONG_PTR)NtUserFindWindowEx(
                hwndParent,
                hwndChild,
                strClass.pstr,
                strWindow.pstr,
                dwFlag);

    ERRORTRAP(0);
    CLEANUPLPTSTR(strClass);
    CLEANUPLPTSTR(strWindow);
    ENDCALL(HWND);

}

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, HWND, WINUSERAPI, FindWindowExW, HWND, hwndParent, HWND, hwndChild, LPCTSTR, pClassName, LPCTSTR, pWindowName)    
#else
FUNCLOG4(LOG_GENERAL, HWND, WINUSERAPI, FindWindowExA, HWND, hwndParent, HWND, hwndChild, LPCTSTR, pClassName, LPCTSTR, pWindowName)
#endif // UNICODE
HWND FindWindowEx(
    HWND    hwndParent,
    HWND    hwndChild,
    LPCTSTR pClassName,
    LPCTSTR pWindowName)
{
    return TEXT_FN(InternalFindWindowEx)(hwndParent, hwndChild, pClassName, pWindowName, FW_BOTH);
}

#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, FindWindowW, LPCTSTR, pClassName, LPCTSTR, pWindowName)
#else
FUNCLOG2(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, FindWindowA, LPCTSTR, pClassName, LPCTSTR, pWindowName)
#endif // UNICODE

HWND FindWindow(
    LPCTSTR pClassName,
    LPCTSTR pWindowName)
{
    return TEXT_FN(InternalFindWindowEx)(NULL, NULL, pClassName, pWindowName, FW_BOTH);
}

extern WNDPROC mpPfnAddress[];

BOOL GetClassInfo(
    HINSTANCE hmod OPTIONAL,
    LPCTSTR pszClassName,
    LPWNDCLASS pwc)
{
    IN_STRING strClassName;
    LPWSTR pszMenuName;
    WNDCLASSEXW WndClass;

    /*
     * Make sure cleanup will work successfully
     */
    strClassName.fAllocated = FALSE;

    BEGINCALL_CLASSV()

        FIRSTCOPYLPTSTRID(&strClassName, lpClassNameVer);

        retval = (DWORD)NtUserGetClassInfo(
                hmod,
                strClassName.pstr,
                &WndClass,
                &pszMenuName,
                IS_ANSI);

        if (retval) {

            /*
             * Move the info from the WNDCLASSEX to the WNDCLASS structure
             * On 64-bit plaforms we'll have 32 bits of padding between style and
             * lpfnWndProc in WNDCLASS, so start the copy from the first 64-bit
             * aligned field and hand copy the rest.
             */
            RtlCopyMemory(&(pwc->lpfnWndProc), &(WndClass.lpfnWndProc), sizeof(WNDCLASS) - FIELD_OFFSET(WNDCLASS, lpfnWndProc));
            pwc->style = WndClass.style;

            /*
             * Update these pointers so they point to something real.
             * pszMenuName is actually just the pointer the app originally
             * passed to us.
             */
            pwc->lpszMenuName = (LPTSTR)pszMenuName;
            pwc->lpszClassName = pszClassName;
        }

    ERRORTRAP(0);
    CLEANUPLPTSTR(strClassName);
    ENDCALL(BOOL);
}

BOOL GetClassInfoEx(
    HINSTANCE hmod OPTIONAL,
    LPCTSTR pszClassName,
    LPWNDCLASSEX pwc)
{
    IN_STRING strClassName;
    LPWSTR pszMenuName;

    /*
     * Make sure cleanup will work successfully
     */
    strClassName.fAllocated = FALSE;

    BEGINCALL_CLASSV()

        FIRSTCOPYLPTSTRID(&strClassName, lpClassNameVer);

        retval = (DWORD)NtUserGetClassInfo(
                hmod,
                strClassName.pstr,
                (LPWNDCLASSEXW)pwc,
                &pszMenuName,
                IS_ANSI);

        if (retval) {

            /*
             * Update these pointers so they point to something real.
             * pszMenuName is actually just the pointer the app originally
             * passed to us.
             */
            pwc->lpszMenuName = (LPTSTR)pszMenuName;
            pwc->lpszClassName = pszClassName;
        }

    ERRORTRAP(0);
    CLEANUPLPTSTR(strClassName);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetClipboardFormatNameW, UINT, wFormat, LPTSTR, pFormatName, int, chMaxCount)
#else
FUNCLOG3(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetClipboardFormatNameA, UINT, wFormat, LPTSTR, pFormatName, int, chMaxCount)
#endif // UNICODE
int GetClipboardFormatName(
    UINT wFormat,
    LPTSTR pFormatName,
    int chMaxCount)
{
    LPWSTR lpszReserve;

    BEGINCALL()

#ifdef UNICODE
        lpszReserve = pFormatName;
#else
        lpszReserve = LocalAlloc(LMEM_FIXED, chMaxCount * sizeof(WCHAR));
        if (!lpszReserve) {
            return 0;
        }
#endif

        retval = (DWORD)NtUserGetClipboardFormatName(
                wFormat,
                lpszReserve,
                chMaxCount);

#ifndef UNICODE
        if (retval) {
            /*
             * Do not copy out more than the requested byte count 'chMaxCount'.
             * Set retval to reflect the number of ANSI bytes.
             */
            retval = WCSToMB(lpszReserve, (UINT)retval,
                    &pFormatName, chMaxCount-1, FALSE);
            pFormatName[retval] = '\0';
        }
        LocalFree(lpszReserve);
#endif

    ERRORTRAP(0);
    ENDCALL(int);
}

#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetKeyNameTextW, LONG, lParam, LPTSTR, pString, int, cchSize)
#else
FUNCLOG3(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetKeyNameTextA, LONG, lParam, LPTSTR, pString, int, cchSize)
#endif // UNICODE
int GetKeyNameText(
    LONG lParam,
    LPTSTR pString,
    int cchSize)
{
    LPWSTR lpszReserve;

    BEGINCALL()

#ifdef UNICODE
        lpszReserve = pString;
#else
        lpszReserve = LocalAlloc(LMEM_FIXED, cchSize * sizeof(WCHAR));
        if (!lpszReserve) {
            return 0;
        }
#endif

        retval = (DWORD)NtUserGetKeyNameText(
                lParam,
                lpszReserve,
                cchSize);

#ifndef UNICODE
        if (retval) {
            /*
             * Do not copy out more than the requested byte count 'nSize'.
             * Set retval to reflect the number of ANSI bytes.
             */
            retval = WCSToMB(lpszReserve, (UINT)retval,
                    &pString, cchSize-1, FALSE);
        }
        LocalFree(lpszReserve);
        ((LPSTR)pString)[retval] = '\0';
#endif

    ERRORTRAP(0);
    ENDCALL(int);
}

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, GetMessageW, LPMSG, pmsg, HWND, hwnd, UINT, wMsgFilterMin, UINT, wMsgFilterMax)
#else
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, GetMessageA, LPMSG, pmsg, HWND, hwnd, UINT, wMsgFilterMin, UINT, wMsgFilterMax)
#endif // UNICODE
BOOL APIENTRY GetMessage(
    LPMSG pmsg,
    HWND hwnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax)
{
    BEGINCALL()

        /*
         * Prevent apps from setting hi 16 bits so we can use them internally.
         */
        if ((wMsgFilterMin | wMsgFilterMax) & RESERVED_MSG_BITS) {
            /*
             *  Backward compatability with Win9x where someone is setting
             *  wMsgFilterMax to -1 to get all the messages
             */
            if(wMsgFilterMax == (UINT)(-1) && !(wMsgFilterMin & RESERVED_MSG_BITS)) {
                wMsgFilterMax = 0;
            }
            else {
                MSGERRORCODE(ERROR_INVALID_PARAMETER);
            }    
        }

#ifndef UNICODE
        /*
         * If we have pushed message for DBCS messaging, we should pass this one
         * to Apps at first...
         */
        GET_DBCS_MESSAGE_IF_EXIST(GetMessage, pmsg, wMsgFilterMin, wMsgFilterMax, TRUE);
#endif

        retval = (DWORD)NtUserGetMessage(
                pmsg,
                hwnd,
                wMsgFilterMin,
                wMsgFilterMax);

#ifndef UNICODE
        // May have a bit more work to do if this MSG is for an ANSI app

        // !!! LATER if the unichar translates into multiple ANSI chars
        // !!! then what??? Divide into two messages??  WM_SYSDEADCHAR??

        if (RtlWCSMessageWParamCharToMB(pmsg->message, &(pmsg->wParam))) {
            WPARAM dwAnsi = pmsg->wParam;
            /*
             * Build DBCS-ware wParam. (for EM_SETPASSWORDCHAR...)
             */
            BUILD_DBCS_MESSAGE_TO_CLIENTA_FROM_SERVER(pmsg, dwAnsi, TRUE, TRUE);
        } else {
            retval = 0;
        }
ExitGetMessage:
#else
        /*
         * Only LOWORD of WPARAM is valid for WM_CHAR (Unicode)....
         * (Mask off DBCS messaging information.)
         */
        BUILD_DBCS_MESSAGE_TO_CLIENTW_FROM_SERVER(pmsg->message,pmsg->wParam);
#endif // UNICODE

#if DBG && defined(GENERIC_INPUT)
    // TEST PURPOSE ONLY
    if (pmsg->message == WM_INPUT) {
        TAGMSG3(DBGTAG_PNP, "GetMessage: WM_INPUT, hwnd=%p, wp=%04x, lp=%08x", pmsg->hwnd, pmsg->wParam, pmsg->lParam);
    }
#endif // GENERIC_INPUT

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetKeyboardLayoutNameW, LPTSTR, pwszKL)
#else
FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetKeyboardLayoutNameA, LPTSTR, pwszKL)
#endif // UNICODE
BOOL GetKeyboardLayoutName(
    LPTSTR pwszKL)
{
#ifdef UNICODE
    UNICODE_STRING str;
    PUNICODE_STRING pstr = &str;
#else
    PUNICODE_STRING pstr = &NtCurrentTeb()->StaticUnicodeString;
#endif

    BEGINCALL()

#ifdef UNICODE
        str.MaximumLength = KL_NAMELENGTH * sizeof(WCHAR);
        str.Buffer = pwszKL;
#endif

        retval = (DWORD)NtUserGetKeyboardLayoutName(pstr);

#ifndef UNICODE
        if (retval) {
            /*
             * Non-zero retval means some text to copy out.  Do not copy out
             * more than the requested byte count 'chMaxCount'.
             */
            WCSToMB(pstr->Buffer, -1, &pwszKL, KL_NAMELENGTH, FALSE);
        }
#endif

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, MapVirtualKeyW, UINT, wCode, UINT, wMapType)
#else
FUNCLOG2(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, MapVirtualKeyA, UINT, wCode, UINT, wMapType)
#endif // UNICODE

UINT MapVirtualKey(
    UINT wCode,
    UINT wMapType)
{
    BEGINCALL()

        retval = (DWORD)NtUserMapVirtualKeyEx(
                wCode,
                wMapType,
                0,
                FALSE);

#ifndef UNICODE
        if ((wMapType == 2) && (retval != 0)) {
            WCHAR wch = LOWORD(retval);
            retval &= ~0xFFFF;
            RtlUnicodeToMultiByteN((LPSTR)&(retval), sizeof(CHAR),
                    NULL, &wch, sizeof(WCHAR));
        }
#endif

    ERRORTRAP(0);
    ENDCALL(UINT);
}

/**************************************************************************\
* MapVirtualKeyEx
*
* 21-Feb-1995 GregoryW    Created
\**************************************************************************/

#ifndef UNICODE
static HKL  hMVKCachedHKL = 0;
static UINT uMVKCachedCP  = 0;
#endif

#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, MapVirtualKeyExW, UINT, wCode, UINT, wMapType, HKL, hkl)
#else
FUNCLOG3(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, MapVirtualKeyExA, UINT, wCode, UINT, wMapType, HKL, hkl)
#endif // UNICODE

UINT MapVirtualKeyEx(
    UINT wCode,
    UINT wMapType,
    HKL hkl)
{
    BEGINCALL()

        retval = (DWORD)NtUserMapVirtualKeyEx(
                wCode,
                wMapType,
                (ULONG_PTR)hkl,
                TRUE);

#ifndef UNICODE
        if ((wMapType == 2) && (retval != 0)) {
            WCHAR wch = LOWORD(retval);

            if (hkl != hMVKCachedHKL) {
                DWORD dwCodePage;
                if (!GetLocaleInfoW(
                         HandleToUlong(hkl) & 0xffff,
                         LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                         (LPWSTR)&dwCodePage,
                         sizeof(dwCodePage) / sizeof(WCHAR)
                         )) {
                    MSGERROR();
                }
                uMVKCachedCP = dwCodePage;
                hMVKCachedHKL = hkl;
            }
            /*
             * Clear low word which contains Unicode character returned from server.
             * This preserves the high word which is used to indicate dead key status.
             */
            retval = retval & 0xffff0000;
            if (!WideCharToMultiByte(
                     uMVKCachedCP,
                     0,
                     &wch,
                     1,
                     (LPSTR)&(retval),
                     1,
                     NULL,
                     NULL)) {
                MSGERROR();
            }
        }
#endif

    ERRORTRAP(0);
    ENDCALL(UINT);
}

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, PostMessageW , HWND, hwnd, UINT, wMsg, WPARAM, wParam, LPARAM, lParam)
#else
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, PostMessageA , HWND, hwnd, UINT, wMsg, WPARAM, wParam, LPARAM, lParam)
#endif // UNICODE
BOOL APIENTRY PostMessage(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    BEGINCALL()

        switch (wMsg) {
        case WM_DROPFILES:
            if (GetWindowProcess(hwnd) != GETPROCESSID()) {
                /*
                 * We first send a WM_COPYGLOBALDATA message to get the data into the proper
                 * context.
                 */
                HGLOBAL hg;

                hg = (HGLOBAL)SendMessage(hwnd, WM_COPYGLOBALDATA,
                        GlobalSize((HGLOBAL)wParam), wParam);
                if (!hg) {
                    MSGERROR();
                }
                wParam = (WPARAM)hg;
            }
            break;

        case LB_DIR:
        case CB_DIR:
            /*
             * Make sure this bit is set so the client side string gets
             * successfully copied over.
             */
            wParam |= DDL_POSTMSGS;
            break;
        }

#ifndef UNICODE
        /*
         * Setup DBCS Messaging for WM_CHAR...
         */
        BUILD_DBCS_MESSAGE_TO_SERVER_FROM_CLIENTA(wMsg,wParam,TRUE);

        RtlMBMessageWParamCharToWCS(wMsg, &wParam);
#endif
        retval = (DWORD)NtUserPostMessage(
                hwnd,
                wMsg,
                wParam,
                lParam);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, PostThreadMessageW, DWORD, idThread, UINT, msg, WPARAM, wParam, LPARAM, lParam)
#else
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, PostThreadMessageA, DWORD, idThread, UINT, msg, WPARAM, wParam, LPARAM, lParam)
#endif // UNICODE
BOOL APIENTRY PostThreadMessage(
    DWORD idThread,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    BEGINCALL()

#ifndef UNICODE
#ifdef FE_SB // PostThreadMessage()
        /*
         * The server always expects the characters to be unicode so
         * if this was generated from an ANSI routine convert it to Unicode
         */
        BUILD_DBCS_MESSAGE_TO_SERVER_FROM_CLIENTA(msg,wParam,TRUE);
#endif // FE_SB

        RtlMBMessageWParamCharToWCS(msg, &wParam);
#endif

        retval = (DWORD)NtUserPostThreadMessage(
                idThread,
                msg,
                wParam,
                lParam);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}


/**************************************************************************\
* StringDuplicate
*
* 03-25-96 GerardoB         Added Header.
\**************************************************************************/
#define StringDuplicate TEXT_FN(StringDuplicate)
LPTSTR StringDuplicate(LPCTSTR ptszDup) {
    LPTSTR ptsz;
    ULONG cb;

    cb = (_tcslen(ptszDup) + 1) * sizeof(TCHAR);
    ptsz = (LPTSTR)LocalAlloc(NONZEROLPTR, cb);
    if (ptsz != NULL) {
        RtlCopyMemory(ptsz, ptszDup, cb);
    }
    return ptsz;
}
/**************************************************************************\
* InitClsMenuName
*
* 03-22-96 GerardoB         Created.
\**************************************************************************/
#define InitClsMenuName TEXT_FN(InitClsMenuName)
BOOL InitClsMenuName (PCLSMENUNAME pcmn, LPCTSTR lpszMenuName, PIN_STRING pstrMenuName)
{
    /*
     * We check the high-word because this may be a resource-ID.
     */
    if (IS_PTR(lpszMenuName)) {
#ifdef UNICODE
        if ((pcmn->pwszClientUnicodeMenuName = StringDuplicate(lpszMenuName)) == NULL) {
            return FALSE;
        }

        if (!WCSToMB(lpszMenuName, -1, &(pcmn->pszClientAnsiMenuName), -1, TRUE)) {
            pcmn->pszClientAnsiMenuName = NULL;
        }
#else
        if ((pcmn->pszClientAnsiMenuName = StringDuplicate(lpszMenuName)) == NULL) {
            return FALSE;
        }

        if (!MBToWCS(lpszMenuName, -1, &(pcmn->pwszClientUnicodeMenuName), -1, TRUE)) {
            pcmn->pwszClientUnicodeMenuName = NULL;
        }
#endif // UNICODE
    } else {
        /* Copy the ID */
        pcmn->pszClientAnsiMenuName = (LPSTR)lpszMenuName;
        pcmn->pwszClientUnicodeMenuName = (LPWSTR)lpszMenuName;
    }

    COPYLPTSTRID(pstrMenuName, lpszMenuName);
    pcmn->pusMenuName = pstrMenuName->pstr;

    return TRUE;

    goto errorexit; /* Keep the compiler happy */
errorexit: /* Used by COPYLPTSTRID */
   return FALSE;
}

/**************************************************************************\
* SetClassLong
*
* 03-22-96 GerardoB      Moved from client\cltxt.h & client\ntstubs.c
\**************************************************************************/
#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, ULONG_PTR, APIENTRY, SetClassLongPtrW, HWND, hwnd, int, nIndex, LONG_PTR, dwNewLong)
#else
FUNCLOG3(LOG_GENERAL, ULONG_PTR, APIENTRY, SetClassLongPtrA, HWND, hwnd, int, nIndex, LONG_PTR, dwNewLong)
#endif // UNICODE
ULONG_PTR APIENTRY SetClassLongPtr(HWND hwnd, int nIndex, LONG_PTR dwNewLong)
{
    CLSMENUNAME cmn;
    IN_STRING strMenuName;

    switch (nIndex) {
        case GCLP_MENUNAME:
            if (!InitClsMenuName(&cmn, (LPCTSTR) dwNewLong, &strMenuName)) {
                RIPERR0(ERROR_INVALID_HANDLE, RIP_WARNING, "SetClassLong: InitClsMenuName failed");
                return 0;
            }
            dwNewLong = (ULONG_PTR) &cmn;
            break;

        case GCLP_HBRBACKGROUND:
            if ((DWORD)dwNewLong > COLOR_ENDCOLORS) {
                /*
                 * Let gdi validate the brush.  If it's invalid, then
                 * gdi will log a warning.  No need to rip twice so we'll
                 * just set the last-error.
                 */
                if (GdiValidateHandle((HBRUSH)dwNewLong) == FALSE) {
                    RIPERR0(ERROR_INVALID_HANDLE, RIP_VERBOSE, "");
                    return 0;
                }
            }
            break;
    }

    BEGINCALL()

    retval = (ULONG_PTR)NtUserSetClassLongPtr(hwnd, nIndex, dwNewLong, IS_ANSI);

    ERRORTRAP(0);

    /* Clean up */
    switch (nIndex) {
        case GCLP_MENUNAME:
            CLEANUPLPTSTR(strMenuName); /* Initialized by InitClsMenuName */
            /*
             * We free either the old strings (returned by the kernel),
             *  or the new ones if the kernel call failed
             */
            if (IS_PTR(cmn.pszClientAnsiMenuName)) {
                LocalFree(KPVOID_TO_PVOID(cmn.pszClientAnsiMenuName));
            }
            if (IS_PTR(cmn.pwszClientUnicodeMenuName)) {
                LocalFree(KPVOID_TO_PVOID(cmn.pwszClientUnicodeMenuName));
            }

            break;
    }

    ENDCALL(ULONG_PTR);

}

#ifdef _WIN64
DWORD  APIENTRY SetClassLong(HWND hwnd, int nIndex, LONG dwNewLong)
{
    BEGINCALL()

    retval = (DWORD)NtUserSetClassLong(hwnd, nIndex, dwNewLong, IS_ANSI);

    ERRORTRAP(0);
    ENDCALL(DWORD);
}
#endif
/**************************************************************************\
* RegisterClassExWOW
*
* 03-22-96 GerardoB      Added Header
\**************************************************************************/
ATOM TEXT_FN(RegisterClassExWOW)(
    WNDCLASSEX *lpWndClass,
    LPDWORD pdwWOWstuff,
    WORD fnid,
    DWORD dwFlags)
{
    WNDCLASSEX WndClass;
    IN_STRING strClassName;
    IN_STRING strClassNameVer;
    IN_STRING strMenuName;
    DWORD dwExpWinVer;
    CLSMENUNAME cmn;
    TCHAR ClassNameVer[MAX_ATOM_LEN];
    LPTSTR lpClassNameVer; 

    strClassName.fAllocated = 0;
    strClassNameVer.fAllocated = 0;
    strMenuName.fAllocated  = 0;

    /*
     * Skip validation for our classes
     */
    if (fnid !=0) {
        /*
         * This is a hack to bypass validation for DDE classes
         * specifically, allow them to use hmodUser.
         */
         if (fnid == FNID_DDE_BIT) {
             fnid = 0;
         }
         dwExpWinVer = VER40;
    } else {
        if (lpWndClass->cbSize != sizeof(WNDCLASSEX)) {
            RIPMSG0(RIP_WARNING, "RegisterClass: Invalid cbSize");
        }

        if (lpWndClass->cbClsExtra < 0 ||
                lpWndClass->cbWndExtra < 0) {
            RIPMSG0(RIP_WARNING, "RegisterClass: invalid cb*Extra");
            goto BadParameter;
        }

        /*
         * Validate hInstance
         * Don't allow 4.0 apps to use hmodUser
         */
         if ((lpWndClass->hInstance == hmodUser)
                && (GetClientInfo()->dwExpWinVer >= VER40)) {
             RIPMSG0(RIP_WARNING, "RegisterClass: Cannot use USER's hInstance");
             goto BadParameter;
         } else if (lpWndClass->hInstance == NULL) {
            /*
             * For 32 bit apps we need to fix up the hInstance because Win 95 does
             * this in their thunk MapHInstLS
             */

            lpWndClass->hInstance = GetModuleHandle(NULL);
            RIPMSG1(RIP_VERBOSE, "RegisterClass: fixing up NULL hmodule to %#p",
                    lpWndClass->hInstance);
        }

        dwExpWinVer = GETEXPWINVER(lpWndClass->hInstance);


        /*
         * Check for valid style bits and strip if appropriate
         */
        if (lpWndClass->style & ~CS_VALID40) {

            if (dwExpWinVer > VER31) {
                RIPMSG0(RIP_WARNING, "RegisterClass: Invalid class style");
                goto BadParameter;
            }

            /*
             * Old application - strip bogus bits and pass through
             */
            RIPMSG0(RIP_WARNING, "RegisterClass: Invalid class style, stripping bad styles");
            lpWndClass->style &= CS_VALID40;
        }

        /*
         * Validate hbrBackground
         */
        if (lpWndClass->hbrBackground > (HBRUSH)COLOR_MAX
                && !GdiValidateHandle(lpWndClass->hbrBackground)) {

            RIPMSG1(RIP_WARNING, "RegisterClass: Invalid class brush:%#p", lpWndClass->hbrBackground);
            if (dwExpWinVer > VER30) {
                goto BadParameter;
            }

            lpWndClass->hbrBackground = NULL;
        }

    } /* if (fnid !=0) */


    if (!InitClsMenuName(&cmn, lpWndClass->lpszMenuName, &strMenuName)) {
        return FALSE;
    }

    BEGINCALL()
        WndClass = *lpWndClass;

#ifndef UNICODE
        dwFlags |= CSF_ANSIPROC;
#endif // UNICODE

        if (dwExpWinVer > VER31) {
            dwFlags |= CSF_WIN40COMPAT;
        }
        
        if(GetClientInfo()->dwTIFlags & TIF_16BIT) {
          /*
           * No Fusion redirection for 16BIT apps
           */
           if(!(GetAppCompatFlags2(VERMAX) & GACF2_FORCEFUSION)) {
              dwFlags &= ~CW_FLAGS_VERSIONCLASS;
           }
        }
                 
        if (dwFlags & CSF_VERSIONCLASS) {
            lpClassNameVer = (LPTSTR)ClassNameToVersion((LPCWSTR)lpWndClass->lpszClassName, (LPWSTR)ClassNameVer, NULL, IS_ANSI);

            if (lpClassNameVer == NULL) {
                RIPMSG0(RIP_WARNING, "RegisterClass: Couldn't resolve class name");
                MSGERROR();
            }
        } else {
            lpClassNameVer = (LPTSTR)lpWndClass->lpszClassName;
        }

        COPYLPTSTRID(&strClassName, (LPTSTR)lpWndClass->lpszClassName);
        COPYLPTSTRID(&strClassNameVer, (LPTSTR)lpClassNameVer);

        retval = NtUserRegisterClassExWOW(
                &WndClass,
                strClassName.pstr,
                strClassNameVer.pstr,
                &cmn,
                fnid,
                dwFlags,
                pdwWOWstuff);

        /*
         * Return the atom associated with this class or if earlier
         * than Win 3.1 convert it to a strict BOOL (some apps check)
         */
        if (GETEXPWINVER(lpWndClass->hInstance) < VER31)
            retval = !!retval;

    ERRORTRAP(0);
    CLEANUPLPTSTR(strMenuName);     /* Initialized by InitClsMenuName */
    CLEANUPLPTSTR(strClassName);
    CLEANUPLPTSTR(strClassNameVer);

    if (!retval) {
        if (IS_PTR(cmn.pszClientAnsiMenuName)) {
            LocalFree(KPVOID_TO_PVOID(cmn.pszClientAnsiMenuName));
        }
        if (IS_PTR(cmn.pwszClientUnicodeMenuName)) {
            LocalFree(KPVOID_TO_PVOID(cmn.pwszClientUnicodeMenuName));
        }
    }
    ENDCALL(BOOL);

BadParameter:
    RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "RegisterClass: Invalid Parameter");
    return FALSE;

}

#ifdef UNICODE
FUNCLOG1(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, RegisterWindowMessageW , LPCTSTR, pString)
#else
FUNCLOG1(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, RegisterWindowMessageA , LPCTSTR, pString)
#endif // UNICODE
UINT RegisterWindowMessage(
    LPCTSTR pString)
{
    IN_STRING str;

    /*
     * Make sure cleanup will work successfully
     */
    str.fAllocated = FALSE;

    BEGINCALL()

        FIRSTCOPYLPTSTR(&str, (LPTSTR)pString);

        retval = (DWORD)NtUserRegisterWindowMessage(
                str.pstr);

    ERRORTRAP(0);
    CLEANUPLPTSTR(str);
    ENDCALL(UINT);
}

#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, HANDLE, DUMMYCALLINGTYPE, RemovePropW , HWND, hwnd, LPCTSTR, pString)
#else
FUNCLOG2(LOG_GENERAL, HANDLE, DUMMYCALLINGTYPE, RemovePropA , HWND, hwnd, LPCTSTR, pString)
#endif // UNICODE

HANDLE RemoveProp(
    HWND hwnd,
    LPCTSTR pString)
{
    ATOM atomProp;
    DWORD dwProp;

    BEGINCALL()

        if (IS_PTR(pString)) {
            atomProp = GlobalFindAtom(pString);
            if (atomProp == 0)
                MSGERROR();
            dwProp = MAKELONG(atomProp, TRUE);
        } else
            dwProp = MAKELONG(PTR_TO_ID(pString), FALSE);

        retval = (ULONG_PTR)NtUserRemoveProp(
                hwnd,
                dwProp);

        if (retval != 0 && IS_PTR(pString))
            GlobalDeleteAtom(atomProp);

    ERRORTRAP(0);
    ENDCALL(HANDLE);
}

#ifdef UNICODE
FUNCLOG6(LOG_GENERAL, BOOL, APIENTRY, SendMessageCallbackW, HWND, hwnd, UINT, wMsg, WPARAM, wParam, LPARAM, lParam, SENDASYNCPROC, lpResultCallBack, ULONG_PTR, dwData)
#else
FUNCLOG6(LOG_GENERAL, BOOL, APIENTRY, SendMessageCallbackA, HWND, hwnd, UINT, wMsg, WPARAM, wParam, LPARAM, lParam, SENDASYNCPROC, lpResultCallBack, ULONG_PTR, dwData)
#endif // UNICODE
BOOL APIENTRY SendMessageCallback(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam,
    SENDASYNCPROC lpResultCallBack,
    ULONG_PTR dwData)
{
    SNDMSGCALLBACK smcb;
    
    BEGINCALL()

        smcb.dwData = dwData;
        smcb.lpResultCallBack = lpResultCallBack;
        
        retval = (DWORD)CsSendMessage(hwnd, wMsg, wParam, lParam,
            (ULONG_PTR)&smcb, FNID_SENDMESSAGECALLBACK, IS_ANSI);
    ERRORTRAP(0);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, SendNotifyMessageW , HWND, hwnd, UINT, wMsg, WPARAM, wParam, LPARAM, lParam)
#else
FUNCLOG4(LOG_GENERAL, BOOL, APIENTRY, SendNotifyMessageA , HWND, hwnd, UINT, wMsg, WPARAM, wParam, LPARAM, lParam)
#endif // UNICODE

BOOL APIENTRY SendNotifyMessage(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    BEGINCALL()

        retval = (DWORD)CsSendMessage(hwnd, wMsg, wParam, lParam,
                0L, FNID_SENDNOTIFYMESSAGE, IS_ANSI);
    ERRORTRAP(0);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetPropW , HWND, hwnd, LPCTSTR, pString, HANDLE, hData)
#else
FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetPropA , HWND, hwnd, LPCTSTR, pString, HANDLE, hData)
#endif // UNICODE

BOOL SetProp(
    HWND hwnd,
    LPCTSTR pString,
    HANDLE hData)
{
    ATOM atomProp;
    DWORD dwProp;

    BEGINCALL()

        if (IS_PTR(pString)) {
            atomProp = GlobalAddAtom(pString);
            if (atomProp == 0)
                MSGERROR();
            dwProp = MAKELONG(atomProp, TRUE);
        } else
            dwProp = MAKELONG(PTR_TO_ID(pString), FALSE);

        retval = (DWORD)NtUserSetProp(
                hwnd,
                dwProp,
                hData);

        /*
         * If it failed, get rid of the atom
         */
        if (retval == FALSE && IS_PTR(pString))
            GlobalDeleteAtom(atomProp);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, UnregisterClassW, LPCTSTR, pszClassName, HINSTANCE, hModule)
#else
FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, UnregisterClassA, LPCTSTR, pszClassName, HINSTANCE, hModule)
#endif // UNICODE
BOOL UnregisterClass(
    LPCTSTR pszClassName,
    HINSTANCE hModule)
{
    IN_STRING strClassName;
    CLSMENUNAME cmn;

    /*
     * Make sure cleanup will work successfully
     */
    strClassName.fAllocated = FALSE;

    BEGINCALL_CLASSV()

        FIRSTCOPYLPTSTRID(&strClassName, lpClassNameVer);

        retval = (DWORD)NtUserUnregisterClass(
                strClassName.pstr,
                hModule,
                &cmn);


        /*
         * Check explicity for TRUE so we don't get a !FALSE when
         * converttogui fails and the NtUser returns a status code intead of bool.
         */
        if (retval == TRUE) {
            /*
             * Free the menu strings if they are not resource IDs
             */
            if (IS_PTR(cmn.pszClientAnsiMenuName)) {
                LocalFree(KPVOID_TO_PVOID(cmn.pszClientAnsiMenuName));
            }
            if (IS_PTR(cmn.pwszClientUnicodeMenuName)) {
                LocalFree(KPVOID_TO_PVOID(cmn.pwszClientUnicodeMenuName));
            }
        }

    ERRORTRAP(0);
    CLEANUPLPTSTR(strClassName);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG1(LOG_GENERAL, SHORT, DUMMYCALLINGTYPE, VkKeyScanW , TCHAR, cChar)
#else
FUNCLOG1(LOG_GENERAL, SHORT, DUMMYCALLINGTYPE, VkKeyScanA , TCHAR, cChar)
#endif // UNICODE

SHORT VkKeyScan(
    TCHAR cChar)
{
    WCHAR wChar;

    BEGINCALL()

#ifdef UNICODE
        wChar = cChar;
#else
#ifdef FE_SB // VkKeyScan()
        /*
         * Return 0xFFFFFFFF for DBCS LeadByte character.
         */
        if (IsDBCSLeadByte(cChar)) {
            MSGERROR();
        }
#endif // FE_SB

        RtlMultiByteToUnicodeN((LPWSTR)&(wChar), sizeof(WCHAR), NULL, &cChar, sizeof(CHAR));
#endif // UNICODE

        retval = (DWORD)NtUserVkKeyScanEx(
                wChar,
                0,
                FALSE);

    ERRORTRAP(-1);
    ENDCALL(SHORT);
}

#ifndef UNICODE
static HKL  hVKSCachedHKL = 0;
static UINT uVKSCachedCP  = 0;
#endif
#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, SHORT, DUMMYCALLINGTYPE, VkKeyScanExW, TCHAR, cChar, HKL, hkl)
#else
FUNCLOG2(LOG_GENERAL, SHORT, DUMMYCALLINGTYPE, VkKeyScanExA, TCHAR, cChar, HKL, hkl)
#endif // UNICODE
SHORT VkKeyScanEx(
    TCHAR cChar,
    HKL hkl)
{
    WCHAR wChar;
    BEGINCALL()

#ifdef UNICODE
        wChar = cChar;
#else
        if (hkl != hVKSCachedHKL) {
            DWORD dwCodePage;
            if (!GetLocaleInfoW(
                     HandleToUlong(hkl) & 0xffff,
                     LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                     (LPWSTR)&dwCodePage,
                     sizeof(dwCodePage) / sizeof(WCHAR)
                     )) {
                MSGERROR();
            }
            uVKSCachedCP = dwCodePage;
            hVKSCachedHKL = hkl;
        }

#ifdef FE_SB // VkKeyScanEx()
        /*
         * Return 0xFFFFFFFF for DBCS LeadByte character.
         */
        if (IsDBCSLeadByteEx(uVKSCachedCP,cChar)) {
            MSGERROR();
        }
#endif // FE_SB

        if (!MultiByteToWideChar(
                 uVKSCachedCP,
                 0,
                 &cChar,
                 sizeof(CHAR),
                 &wChar,
                 sizeof(WCHAR))) {
            MSGERROR();
        }
#endif // UNICODE

        retval = (DWORD)NtUserVkKeyScanEx(
                wChar,
                (ULONG_PTR)hkl,
                TRUE);

    ERRORTRAP(-1);
    ENDCALL(SHORT);
}

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnumDisplayDevicesW, LPCTSTR, lpszDevice, DWORD, iDevNum, PDISPLAY_DEVICE, lpDisplayDevice, DWORD, dwFlags)
#else
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnumDisplayDevicesA, LPCTSTR, lpszDevice, DWORD, iDevNum, PDISPLAY_DEVICE, lpDisplayDevice, DWORD, dwFlags)
#endif // UNICODE
BOOL
EnumDisplayDevices(
    LPCTSTR lpszDevice,
    DWORD iDevNum,
    PDISPLAY_DEVICE lpDisplayDevice,
    DWORD dwFlags)
{
    UNICODE_STRING  UnicodeString;
    PUNICODE_STRING pUnicodeString = NULL;
    NTSTATUS Status;
    DISPLAY_DEVICEW tmpDisplayDevice;

    //
    // Clear out things to make sure the caller passes in appropriate
    // parameters
    //

    ZeroMemory(((PUCHAR)lpDisplayDevice) + sizeof(DWORD),
               lpDisplayDevice->cb - sizeof(DWORD));

    tmpDisplayDevice.cb = sizeof(DISPLAY_DEVICEW);

    if (lpszDevice) {

#ifdef UNICODE

        RtlInitUnicodeString(&UnicodeString, lpszDevice);

#else

        ANSI_STRING     AnsiString;

        UnicodeString = NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString, (LPSTR)lpszDevice);

        if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeString,
                                                     &AnsiString,
                                                     FALSE))) {
            return FALSE;
        }

#endif

        pUnicodeString = &UnicodeString;
    }

    Status = NtUserEnumDisplayDevices(
                pUnicodeString,
                iDevNum,
                &tmpDisplayDevice,
                dwFlags);

    if (NT_SUCCESS(Status))
    {
#ifndef UNICODE
        LPSTR psz;

        if (lpDisplayDevice->cb >= FIELD_OFFSET(DISPLAY_DEVICE, DeviceString)) {
            psz = (LPSTR)&(lpDisplayDevice->DeviceName[0]);
            WCSToMB(&(tmpDisplayDevice.DeviceName[0]), -1, &psz, 32, FALSE);
        }

        if (lpDisplayDevice->cb >= FIELD_OFFSET(DISPLAY_DEVICE, StateFlags)) {
            psz = (LPSTR)&(lpDisplayDevice->DeviceString[0]);
            WCSToMB(&(tmpDisplayDevice.DeviceString[0]), -1, &psz, 128, FALSE);
        }

        if (lpDisplayDevice->cb >= FIELD_OFFSET(DISPLAY_DEVICE, DeviceID)) {
            lpDisplayDevice->StateFlags = tmpDisplayDevice.StateFlags;
        }

        if (lpDisplayDevice->cb >= FIELD_OFFSET(DISPLAY_DEVICE, DeviceKey)) {
            psz = (LPSTR)&(lpDisplayDevice->DeviceID[0]);
            WCSToMB(&(tmpDisplayDevice.DeviceID[0]), -1, &psz, 128, FALSE);
        }
        if (lpDisplayDevice->cb >= sizeof(DISPLAY_DEVICE)) {
            psz = (LPSTR)&(lpDisplayDevice->DeviceKey[0]);
            WCSToMB(&(tmpDisplayDevice.DeviceKey[0]), -1, &psz, 128, FALSE);
        }
#else

        //
        // Copy the contents of the tmpDisplayDevice back to the
        // user supplied buffer.  Make sure not to overwrite the original
        // size field.
        //

        RtlMoveMemory((PUCHAR)lpDisplayDevice + sizeof(DWORD),
                      ((PUCHAR)&tmpDisplayDevice + sizeof(DWORD)),
                      lpDisplayDevice->cb - sizeof(DWORD));

#endif

        return TRUE;
    }

    return FALSE;
}

#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnumDisplaySettingsW , LPCTSTR, lpszDeviceName, DWORD, iModeNum, LPDEVMODE, lpDevMode)
#else
FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnumDisplaySettingsA, LPCTSTR, lpszDeviceName, DWORD, iModeNum, LPDEVMODE, lpDevMode)
#endif // UNICODE
BOOL EnumDisplaySettings(
    LPCTSTR   lpszDeviceName,
    DWORD     iModeNum,
    LPDEVMODE lpDevMode)
{

    //
    // Work-around Win95 problem which does not require the caller
    // to initialize these two fields.
    //

    lpDevMode->dmDriverExtra = 0;
    lpDevMode->dmSize = FIELD_OFFSET(DEVMODE, dmICMMethod);

    return EnumDisplaySettingsEx(lpszDeviceName, iModeNum, lpDevMode, 0);
}

#ifdef UNICODE
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnumDisplaySettingsExW, LPCTSTR, lpszDeviceName, DWORD, iModeNum, LPDEVMODE, lpDevMode, DWORD, dwFlags)
#else
FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnumDisplaySettingsExA, LPCTSTR, lpszDeviceName, DWORD, iModeNum, LPDEVMODE, lpDevMode, DWORD, dwFlags)
#endif // UNICODE
BOOL EnumDisplaySettingsEx(
    LPCTSTR   lpszDeviceName,
    DWORD     iModeNum,
    LPDEVMODE lpDevMode,
    DWORD     dwFlags)
{
    UNICODE_STRING  UnicodeString;
    PUNICODE_STRING pUnicodeString = NULL;
    LPDEVMODEW      lpDevModeReserve;
    BOOL            retval = FALSE;
    WORD            size = lpDevMode->dmSize;

    if (lpszDeviceName) {

#ifdef UNICODE

        RtlInitUnicodeString(&UnicodeString, lpszDeviceName);

#else

        ANSI_STRING     AnsiString;

        UnicodeString = NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString, (LPSTR)lpszDeviceName);

        if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeString,
                                                     &AnsiString,
                                                     FALSE))) {
            return FALSE;
        }

#endif

        pUnicodeString = &UnicodeString;
    }

    /*
     * Currently -2 is reserved (undocumented function of the NT api.
     * remove the check is win95 implements this.
     * -> -1 returns the content of the registry at the time of the call
     *
     *
     * if (iModeNum == (DWORD) -2)
     * {
     *     return FALSE;
     * }
     *
     *
     * -1 should return the current DEVMODE for the device.
     * This is handled in the kernel part of the function, so we pass it on.
     *
     *
     *
     * We will always request a full DEVMODE from the kernel.
     * So allocate the space needed
     *
     */
    lpDevModeReserve = UserLocalAlloc(HEAP_ZERO_MEMORY,
                                      sizeof(DEVMODEW) + lpDevMode->dmDriverExtra);

    if (lpDevModeReserve) {

        lpDevModeReserve->dmSize = sizeof(DEVMODEW);
        lpDevModeReserve->dmDriverExtra = lpDevMode->dmDriverExtra;

        /*
         * Get the information
         */
        retval = (NT_SUCCESS(NtUserEnumDisplaySettings(pUnicodeString,
                                                       iModeNum,
                                                       lpDevModeReserve,
                                                       dwFlags)));
        if (retval) {

#ifndef UNICODE
            LPSTR psz;
#endif

            /*
             * return only the amount of information requested.
             * For ANSI, this requires a conversion.
             */

            /*
             * First, copy the driver extra information
             */

            if (lpDevMode->dmDriverExtra &&
                lpDevModeReserve->dmDriverExtra) {

                RtlMoveMemory(((PUCHAR)lpDevMode) + size,
                              lpDevModeReserve + 1,
                              min(lpDevMode->dmDriverExtra,
                                  lpDevModeReserve->dmDriverExtra));
            }

#ifndef UNICODE
            psz = (LPSTR)&(lpDevMode->dmDeviceName[0]);

            retval = WCSToMB(lpDevModeReserve->dmDeviceName,
                             -1,
                             &psz,
                             32,
                             FALSE);

            RtlMoveMemory(&lpDevMode->dmSpecVersion,
                          &lpDevModeReserve->dmSpecVersion,
                          min(size, FIELD_OFFSET(DEVMODE,dmFormName)) -
                              FIELD_OFFSET(DEVMODE,dmSpecVersion));

            lpDevMode->dmSize = size;

            if (size >= FIELD_OFFSET(DEVMODE,dmFormName)) {

                psz = (LPSTR)&(lpDevMode->dmFormName[0]);

                retval = WCSToMB(lpDevModeReserve->dmFormName, -1, &psz, 32, FALSE);
            }

            if (size > FIELD_OFFSET(DEVMODE,dmBitsPerPel)) {

                RtlMoveMemory(&lpDevMode->dmBitsPerPel,
                              &lpDevModeReserve->dmBitsPerPel,
                              lpDevMode->dmSize +
                                  lpDevMode->dmDriverExtra -
                                  FIELD_OFFSET(DEVMODE,dmBitsPerPel));
            }

#else
            RtlMoveMemory(lpDevMode, lpDevModeReserve, size);

            lpDevMode->dmSize = size;

#endif

            if (size != lpDevMode->dmSize) {
                RIPMSG0(RIP_WARNING, "EnumDisplaySettings : Error in dmSize");
            }

            /*
             * Don't return invalid field flags to the application
             * Add any other new ones here.
             *
             * We assume apps at least have up to dmDisplayFrenquency for
             * now ...
             */

            if (size < FIELD_OFFSET(DEVMODE,dmPanningWidth))
                lpDevMode->dmFields &= ~DM_PANNINGWIDTH;

            if (size < FIELD_OFFSET(DEVMODE,dmPanningHeight))
                lpDevMode->dmFields &= ~DM_PANNINGHEIGHT;
        }

        LocalFree(lpDevModeReserve);
    }

    return retval;
}


#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, LONG, DUMMYCALLINGTYPE, ChangeDisplaySettingsW, LPDEVMODE, lpDevMode, DWORD, dwFlags)
#else
FUNCLOG2(LOG_GENERAL, LONG, DUMMYCALLINGTYPE, ChangeDisplaySettingsA, LPDEVMODE, lpDevMode, DWORD, dwFlags)
#endif // UNICODE
LONG ChangeDisplaySettings(
    LPDEVMODE lpDevMode,
    DWORD     dwFlags)
{

    /*
     * Compatibility
     */
    if (lpDevMode)
        lpDevMode->dmDriverExtra = 0;

    return ChangeDisplaySettingsEx(NULL, lpDevMode, NULL, dwFlags, NULL);
}

#ifdef UNICODE
FUNCLOG5(LOG_GENERAL, LONG, DUMMYCALLINGTYPE, ChangeDisplaySettingsExW, LPCTSTR, lpszDeviceName, LPDEVMODE, lpDevMode, HWND, hwnd, DWORD, dwFlags, LPVOID, lParam)
#else
FUNCLOG5(LOG_GENERAL, LONG, DUMMYCALLINGTYPE, ChangeDisplaySettingsExA, LPCTSTR, lpszDeviceName, LPDEVMODE, lpDevMode, HWND, hwnd, DWORD, dwFlags, LPVOID, lParam)
#endif // UNICODE
LONG ChangeDisplaySettingsEx(
    LPCTSTR   lpszDeviceName,
    LPDEVMODE lpDevMode,
    HWND      hwnd,
    DWORD     dwFlags,
    LPVOID    lParam)
{
#ifndef UNICODE
    ANSI_STRING     AnsiString;
#endif

    UNICODE_STRING  UnicodeString;
    PUNICODE_STRING pUnicodeString = NULL;
    LONG            status = DISP_CHANGE_FAILED;
    LPDEVMODEW      lpDevModeW;

    if (lpszDeviceName) {

#ifdef UNICODE

        RtlInitUnicodeString(&UnicodeString, lpszDeviceName);

#else

        UnicodeString = NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString, (LPSTR)lpszDeviceName);

        if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeString,
                                                     &AnsiString,
                                                     FALSE))) {
            return FALSE;
        }

#endif

        pUnicodeString = &UnicodeString;
    }

#ifdef UNICODE

    lpDevModeW = lpDevMode;

#else

    lpDevModeW = NULL;

    if (lpDevMode) {

        lpDevModeW = GdiConvertToDevmodeW(lpDevMode);

        if (lpDevModeW == NULL) {

            return FALSE;
        }
    }

#endif

    status = NtUserChangeDisplaySettings(pUnicodeString,
                                         lpDevModeW,
                                         hwnd,
                                         dwFlags,
                                         lParam);

#ifndef UNICODE
    if (lpDevMode) {
        LocalFree(lpDevModeW);
    }
#endif

    return status;
}


#ifdef UNICODE
FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, CallMsgFilterW , LPMSG, pmsg, int, nCode)
#else
FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, CallMsgFilterA , LPMSG, pmsg, int, nCode)
#endif // UNICODE
BOOL CallMsgFilter(
    LPMSG pmsg,
    int   nCode)
{
    PCLIENTINFO pci;
    MSG         msg;

    BEGINCALLCONNECT()

        /*
         * If we're not hooked, don't bother going to the server
         */
        pci = GetClientInfo();
        if (!IsHooked(pci, (WH_MSGFILTER | WH_SYSMSGFILTER))) {
            return FALSE;
        }

        /*
         * Don't allow apps to use the hiword of the message parameter.
         */
        if (pmsg->message & RESERVED_MSG_BITS) {
            MSGERRORCODE(ERROR_INVALID_PARAMETER);
        }
        msg = *pmsg;

#ifndef UNICODE
        switch (pmsg->message) {
#ifdef FE_SB // CallMsgFilter()
        case WM_CHAR:
        case EM_SETPASSWORDCHAR:
#ifndef LATER
             /*
              * we should not return "TRUE" everytime for DBCS leadbyte character...
              * but should convert DBCS character to Unicode correctly.. How I can do ??
              * then ,finally, we just take what we did in NT 3.51, it means do nothing..
              */
#else
             /*
              * Build DBCS-aware message.
              */
             BUILD_DBCS_MESSAGE_TO_SERVER_FROM_CLIENTA(pmsg->message,pmsg->wParam,TRUE);
             /*
              * Fall through.....
              */
#endif // LATER
#else
        case WM_CHAR:
        case EM_SETPASSWORDCHAR:
#endif // FE_SB
        case WM_CHARTOITEM:
        case WM_DEADCHAR:
        case WM_SYSCHAR:
        case WM_SYSDEADCHAR:
        case WM_MENUCHAR:
#ifdef FE_IME // CallMsgFilter()
        case WM_IME_CHAR:
        case WM_IME_COMPOSITION:
#endif // FE_IME

            RtlMBMessageWParamCharToWCS( msg.message, &(msg.wParam));
            break;
        }
#endif //!UNICODE

        retval = (DWORD)NtUserCallMsgFilter(
                &msg,
                nCode);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG7(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DrawCaptionTempW, HWND, hwnd, HDC, hdc, LPCRECT, lprc, HFONT, hFont, HICON, hicon, LPCTSTR, lpText, UINT, flags)
#else
FUNCLOG7(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DrawCaptionTempA, HWND, hwnd, HDC, hdc, LPCRECT, lprc, HFONT, hFont, HICON, hicon, LPCTSTR, lpText, UINT, flags)
#endif // UNICODE
BOOL DrawCaptionTemp(
    HWND hwnd,
    HDC hdc,
    LPCRECT lprc,
    HFONT hFont,
    HICON hicon,
    LPCTSTR lpText,
    UINT flags)
{
    HDC hdcr;
    IN_STRING strText;

    /*
     * Make sure cleanup will work successfully
     */
    strText.fAllocated = FALSE;

    BEGINCALL()

        if (IsMetaFile(hdc)) return FALSE;

        hdcr = GdiConvertAndCheckDC(hdc);
        if (hdcr == (HDC)0)
            return FALSE;

        FIRSTCOPYLPTSTRIDOPT(&strText, lpText);

        retval = (DWORD)NtUserDrawCaptionTemp(
                hwnd,
                hdc,
                lprc,
                hFont,
                hicon,
                strText.pstr,
                flags);

    ERRORTRAP(0);
    CLEANUPLPTSTR(strText);
    ENDCALL(BOOL);
}

#ifdef UNICODE
FUNCLOG3(LOG_GENERAL, UINT, WINUSERAPI, RealGetWindowClassW, HWND, hwnd, LPTSTR, ptszClassName, UINT, cchClassNameMax)
#else
FUNCLOG3(LOG_GENERAL, UINT, WINUSERAPI, RealGetWindowClassA, HWND, hwnd, LPTSTR, ptszClassName, UINT, cchClassNameMax)
#endif // UNICODE

WINUSERAPI UINT WINAPI
RealGetWindowClass(
    HWND hwnd,
    LPTSTR ptszClassName,
    UINT cchClassNameMax)
{
    UNICODE_STRING strClassName;
    int retval;

    strClassName.MaximumLength = (USHORT)(cchClassNameMax * sizeof(WCHAR));

#ifndef UNICODE
    strClassName.Buffer = LocalAlloc(LMEM_FIXED, strClassName.MaximumLength);
    if (!strClassName.Buffer) {
        return 0;
    }
#else
    strClassName.Buffer = ptszClassName;
#endif

    retval = NtUserGetClassName(hwnd, TRUE, &strClassName);

#ifndef UNICODE
    if (retval || (cchClassNameMax == 1)) {
        /*
         * Copy the result
         */
        retval = WCSToMB(strClassName.Buffer, retval,
                &ptszClassName, cchClassNameMax-1, FALSE);
        ptszClassName[retval] = '\0';
    }
    LocalFree(strClassName.Buffer);
#endif

  return retval;
}

WINUSERAPI BOOL WINAPI GetAltTabInfo(
    HWND hwnd,
    int iItem,
    PALTTABINFO pati,
    LPTSTR pszItemText,
    UINT cchItemText OPTIONAL)
{
    BEGINCALL()

    retval = (DWORD)NtUserGetAltTabInfo(hwnd,  iItem, pati,
            (LPWSTR)pszItemText, cchItemText, IS_ANSI);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\queuec.c ===
/****************************** Module Header ******************************\
* Module Name: queuec.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the low-level code for working with the Q structure.
*
* History:
* 11-Mar-1993 JerrySh   Pulled functions from user\server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* SetMessageQueue
*
* Dummy API for binary win32s compatibility.
*
* 12-1-92 sanfords created
\***************************************************************************/

FUNCLOG1(LOG_GENERAL,BOOL , WINAPI, SetMessageQueue, int, cMessagesMax)
BOOL
WINAPI
SetMessageQueue(
    int cMessagesMax)
{
    UNREFERENCED_PARAMETER(cMessagesMax);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\oemxlate.c ===
/**************************** Module Header ********************************\
* Module Name: oemxlate.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* ANSI/UNICODE(U+00--) to/from OEM translation routines for CP 437
*
* The goal of this module is to translate strings from ANSI/U+00-- to Oem
* character set or the opposite. If there is no equivalent character
* we use the followings rules:
*
*  1) we put a similar character (e.g. character without accent)
*  2) In OemToChar, graphics vertical, horizontal, and junction characters
*     are usually translated to '|', '-', and '+' characters, as appropriate,
*     unless the ANSI set is expanded to include such graphics.
*  3) Otherwise we put underscore "_".
*
* History:
* IanJa 4/10/91  from Win3.1 \\pucus\win31ro!drivers\keyboard\xlat*.*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* CharToOemA
*
* CharToOemA(pSrc, pDst) - Translates the ANSI string at pSrc into
* the OEM string at pDst.  pSrc == pDst is legal.
* Always returns TRUE
*
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, CharToOemA, LPCSTR, pSrc, LPSTR, pDst)
BOOL WINAPI CharToOemA(
    LPCSTR pSrc,
    LPSTR pDst)
{
    UserAssert(gpsi);

    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    }

    do {
        *pDst++ = gpsi->acAnsiToOem[(UCHAR)*pSrc];
    } while (*pSrc++);

    return TRUE;
}

/***************************************************************************\
* CharToOemBuffA
*
* CharToOemBuffA(pSrc, pDst, nLength) - Translates nLength characters from
* the ANSI string at pSrc into OEM characters in the buffer at pDst.
* pSrc == pDst is legal.
*
* History:
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, CharToOemBuffA, LPCSTR, pSrc, LPSTR, pDst, DWORD, nLength)
BOOL WINAPI CharToOemBuffA(
    LPCSTR pSrc,
    LPSTR pDst,
    DWORD nLength)
{
    UserAssert(gpsi);

    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    }

    while (nLength--) {
        *pDst++ = gpsi->acAnsiToOem[(UCHAR)*pSrc++];
    }

    return TRUE;
}


/***************************************************************************\
* OemToCharA
*
* OemToCharA(pSrc, pDst) - Translates the OEM string at pSrc into
* the ANSI string at pDst.  pSrc == pDst is legal.
*
* Always returns TRUE
*
* History:
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, OemToCharA, LPCSTR, pSrc, LPSTR, pDst)
BOOL WINAPI OemToCharA(
    LPCSTR pSrc,
    LPSTR pDst)
{
    UserAssert(gpsi);

    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    }

    do {
        *pDst++ = gpsi->acOemToAnsi[(UCHAR)*pSrc];
    } while (*pSrc++);

    return TRUE;
}


/***************************************************************************\
* OemToCharBuffA
*
* OemToCharBuffA(pSrc, pDst, nLength) - Translates nLength OEM characters from
* the buffer at pSrc into ANSI characters in the buffer at pDst.
* pSrc == pDst is legal.
*
* Always returns TRUE
*
* History:
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, OemToCharBuffA, LPCSTR, pSrc, LPSTR, pDst, DWORD, nLength)
BOOL WINAPI OemToCharBuffA(
    LPCSTR pSrc,
    LPSTR pDst,
    DWORD nLength)
{
    UserAssert(gpsi);

    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    }

    while (nLength--) {
        *pDst++ = gpsi->acOemToAnsi[(UCHAR)*pSrc++];
    }

    return TRUE;
}


/***************************************************************************\
* CharToOemW
*
* CharToOemW(pSrc, pDst) - Translates the Unicode string at pSrc into
* the OEM string at pDst.  pSrc == pDst is legal.
*
* History:
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, CharToOemW, LPCWSTR, pSrc, LPSTR, pDst)
BOOL WINAPI CharToOemW(
    LPCWSTR pSrc,
    LPSTR pDst)
{
    int cch;
    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    } else if (pSrc == (LPCWSTR)pDst) {
        /*
         * WideCharToMultiByte() requires pSrc != pDst: fail this call.
         * LATER: Is this really true?
         */
        return FALSE;
    }

    cch = wcslen(pSrc) + 1;

    WideCharToMultiByte(
            CP_OEMCP,           // Unicode -> OEM
            0,                  // gives best visual match
            (LPWSTR)pSrc, cch,  // source & length
            pDst,               // dest
            cch * 2,            // max poss.length (DBCS may * 2)
            "_",                // default char
            NULL);              // (don't care whether defaulted)

    return TRUE;
}

/***************************************************************************\
* CharToOemBuffW
*
* CharToOemBuffW(pSrc, pDst, nLength) - Translates nLength characters from
* the Unicode string at pSrc into OEM characters in the buffer at pDst.
* pSrc == pDst is legal.
*
* History:
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, CharToOemBuffW, LPCWSTR, pSrc, LPSTR, pDst, DWORD, nLength)
BOOL WINAPI CharToOemBuffW(
    LPCWSTR pSrc,
    LPSTR pDst,
    DWORD nLength)
{
    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    } else if (pSrc == (LPCWSTR)pDst) {
        /*
         * WideCharToMultiByte() requires pSrc != pDst: fail this call.
         * LATER: Is this really true?
         */
        return FALSE;
    }

    WideCharToMultiByte(
            CP_OEMCP,                   // Unicode -> OEM
            0,                          // gives best visual match
            (LPWSTR)pSrc, (int)nLength, // source & length
            pDst,                       // dest
            (int)nLength * 2,           // max poss. length (DBCS may * 2)
            "_",                        // default char
            NULL);                      // (don't care whether defaulted)

    return TRUE;
}

/***************************************************************************\
* OemToCharW
*
* OemToCharW(pSrc, pDst) - Translates the OEM string at pSrc into
* the Unicode string at pDst.  pSrc == pDst is not legal.
*
* History:
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, OemToCharW, LPCSTR, pSrc, LPWSTR, pDst)
BOOL WINAPI OemToCharW(
    LPCSTR pSrc,
    LPWSTR pDst)
{
    int cch;
    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    } else if (pSrc == (LPCSTR)pDst) {
        /*
         * MultiByteToWideChar() requires pSrc != pDst: fail this call.
         * LATER: Is this really true?
         */
        return FALSE;
    }

    cch = strlen(pSrc) + 1;

    MultiByteToWideChar(
            CP_OEMCP,                          // Unicode -> OEM
            MB_PRECOMPOSED | MB_USEGLYPHCHARS, // visual map to precomposed
            (LPSTR)pSrc, cch,                  // source & length
            pDst,                              // destination
            cch);                              // max poss. precomposed length

    return TRUE;
}

/***************************************************************************\
* OemToCharBuffW
*
* OemToCharBuffW(pSrc, pDst, nLength) - Translates nLength OEM characters from
* the buffer at pSrc into Unicode characters in the buffer at pDst.
* pSrc == pDst is not legal.
*
* History:
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, OemToCharBuffW, LPCSTR, pSrc, LPWSTR, pDst, DWORD, nLength)
BOOL WINAPI OemToCharBuffW(
    LPCSTR pSrc,
    LPWSTR pDst,
    DWORD nLength)
{
    if (pSrc == NULL || pDst == NULL) {
        return FALSE;
    } else if (pSrc == (LPCSTR)pDst) {
        /*
         * MultiByteToWideChar() requires pSrc != pDst: fail this call.
         * LATER: Is this really true?
         */
        return FALSE;
    }

    if (MultiByteToWideChar(
            CP_OEMCP,                          // Unicode -> OEM
            MB_PRECOMPOSED | MB_USEGLYPHCHARS, // visual map to precomposed
            (LPSTR)pSrc, nLength,              // source & length
            pDst,                              // destination
            nLength)) {                          // max poss. precomposed length
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* OemKeyScan (API)
*
* Converts an OEM character into a scancode plus shift state, returning
* scancode in low byte, shift state in high byte.
*
* Returns -1 on error.
*
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, DWORD, WINAPI, OemKeyScan, WORD, wOemChar)
DWORD WINAPI OemKeyScan(
    WORD wOemChar)
{
    WCHAR wchOem;
    SHORT sVk;
    UINT dwRet;

#ifdef FE_SB // OemKeyScan()
    /*
     * Return 0xFFFFFFFF for DBCS LeadByte character.
     */
    if (IsDBCSLeadByte(LOBYTE(wOemChar))) {
        return 0xFFFFFFFF;
    }
#endif // FE_SB

    if (!OemToCharBuffW((LPCSTR)&wOemChar, &wchOem, 1)) {
        return 0xFFFFFFFF;
    }

    sVk = VkKeyScanW(wchOem);
    if ((dwRet = MapVirtualKeyW(LOBYTE(sVk), 0)) == 0) {
        return 0xFFFFFFFF;
    }
    return dwRet | ((sVk & 0xFF00) << 8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\perf.c ===
/**************************************************************************\
* Module Name: perf.c
*
* performance timing calls
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 12-Jun-1991 mikeke
*
\**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "usercli.h"
#include <string.h>

#include "ntcsrdll.h"
#include "csuser.h"

/**************************************************************************\
\**************************************************************************/

typedef CSR_QLPC_API_MSG *PCSRMSG;

typedef PDWORD (* PINSTUBFUNC)(PDWORD, PDWORD, PDWORD, PDWORD);
typedef void (* POUTSTUBFUNC)(PDWORD, PDWORD);

PDWORD Copy4(PDWORD psrc,PDWORD pdst,PDWORD pparam,PDWORD pmax);
PDWORD Copy5(PDWORD psrc,PDWORD pdst,PDWORD pparam,PDWORD pmax);
PDWORD CopySTR(PDWORD psrc,PDWORD pdst,PDWORD pparam,PDWORD pmax);

#if !defined(_MIPS_) && !defined(_PPC_)
void OutCopy4(
    PDWORD psrc,
    PDWORD pdst)
{
    pdst[0] = psrc[0];
    pdst[1] = psrc[1];
    pdst[2] = psrc[2];
    pdst[3] = psrc[3];
}

PDWORD Copy4(
    PDWORD psrc,
    PDWORD pdst,
    PDWORD pparam,
    PDWORD pmax)
{
    if (pdst + 5 <= pmax) {
        pdst[0] = psrc[0];
        pdst[1] = psrc[1];
        pdst[2] = psrc[2];
        pdst[3] = psrc[3];
        return pdst + 4;
    }
    return 0;
    pparam;
}

PDWORD Copy5(
    PDWORD psrc,
    PDWORD pdst,
    PDWORD pparam,
    PDWORD pmax)
{
    if (pdst + 5 <= pmax) {
        pdst[0] = psrc[0];
        pdst[1] = psrc[1];
        pdst[2] = psrc[2];
        pdst[3] = psrc[3];
        pdst[4] = psrc[4];
        return pdst + 5;
    }
    return 0;
    pparam;
}

PDWORD Copy6(
    PDWORD psrc,
    PDWORD pdst,
    PDWORD pparam,
    PDWORD pmax)
{
    if (pdst + 6 <= pmax) {
        pdst[0] = psrc[0];
        pdst[1] = psrc[1];
        pdst[2] = psrc[2];
        pdst[3] = psrc[3];
        pdst[4] = psrc[4];
        pdst[5] = psrc[5];
        return pdst + 6;
    }
    return 0;
    pparam;
}

PDWORD CopySTR(
    PDWORD psrc,
    PDWORD pdst,
    PDWORD pparam,
    PDWORD pmax)
{
    PBYTE length = (PBYTE)psrc;

    while (*length)
        length++;

    length = (length - (PBYTE)psrc + (PBYTE)pdst);
    length = (PBYTE)(((DWORD)length +3 ) & ~3);

    if (length <= (PBYTE)pmax) {
        while ((PBYTE)pdst != (PBYTE)length) {
            *pdst = *psrc;
            pdst++;
            psrc++;
        }
        return (PDWORD)length;
    }
    return 0;
    pparam;
}
#endif

/**************************************************************************\
\**************************************************************************/

PDWORD AIDoClientInStuff(
    PDWORD psrc,
    PDWORD pbase,
    PDWORD ptemplate,
    PDWORD pmax);

VOID AIDoClientOutStuff(
    PDWORD psrc,
    PDWORD pbase,
    PDWORD ptemplate);

PDWORD DoClientInStuff(
    PDWORD psrc,
    PDWORD pbase,
    PDWORD ptemplate,
    PDWORD pmax)
{
    PDWORD pparam;
    PDWORD param;
    PDWORD pdst;

    if (ptemplate[0]) {
        pdst = ((PINSTUBFUNC)ptemplate[0])(psrc, pbase, NULL, pmax);
        if (!pdst) {
            return 0;
        }
        ptemplate++;

        while (ptemplate[0]) {
            pparam = (PDWORD)((PBYTE)pbase + ptemplate[1]);
            param = (PDWORD)*pparam;
            *pparam = (PBYTE)pdst - (PBYTE)pbase;
            pdst = ((PINSTUBFUNC)ptemplate[0])(param, pdst, pparam, pmax);
            if (!pdst) {
                return 0;
            }
            ptemplate += 2;
        }
    }
}

VOID DoClientOutStuff(
    PDWORD psrc,
    PDWORD pdst,
    PDWORD ptemplate)
{
    PDWORD pparam;

    while (ptemplate[0]) {
        pparam = (PDWORD)((PBYTE)psrc + ptemplate[1]);
        ((POUTSTUBFUNC)ptemplate[0])(
            (PDWORD)((PBYTE)psrc + *pparam),
            *(PDWORD *)((PBYTE)pdst + ptemplate[1])
        );
        ptemplate += 2;
    }
}

/**************************************************************************\
\**************************************************************************/

DWORD MakeCSCall(
    DWORD findex,
    PDWORD psrc,
    PDWORD pInTemplate,
    PDWORD pOutTemplate
    )
{
    PCSR_QLPC_TEB pteb = (PCSR_QLPC_TEB)NtCurrentTeb()->CsrQlpcTeb;
    PCSR_QLPC_STACK pstack;
    PCSRMSG pmsg;
    ULONG retval;
    PDWORD pbase;
    PDWORD pdst;
    PDWORD plast;
    PDWORD pmax;

    //
    // connect to the server
    //

    if (pteb == NULL) {
        pteb = CsrClientThreadConnect();
        if (pteb == NULL) {
            return 0;
        }
    }

    pstack = pteb->MessageStack;
    if (pstack->BatchCount) {
        CsrClientSendMessage();
        pbase = (PDWORD)((PBYTE)pstack + pstack->Base);
    } else {
        pbase = (PDWORD)((PBYTE)pstack + pstack->Current);
    }
    pmax = (PDWORD)((PBYTE)pstack + pstack->Limit);
    pmsg = (PCSRMSG)(pbase+1);

    //
    // is there enough space left on the stack?
    //

    pdst = (PDWORD)(pmsg + 1);
    if (pdst <= pmax) {

        //
        // copy the data to shared memory
        //

        if (pInTemplate) {
            plast = DoClientInStuff(psrc, pdst, pInTemplate, pmax);
        } else {
            plast = pdst;
        }

        if (plast) {

            //
            // Make the call
            //

            pmsg->Length = (PBYTE)plast - (PBYTE)pmsg;
            pmsg->ApiNumber = findex;
            *pbase = pstack->Base;
            pstack->Base = pstack->Current+4;
            pstack->Current = (PBYTE)pdst - (PBYTE)pstack;
            pstack->BatchCount = 1;

            retval = CsrClientSendMessage();

            pstack->Current = pstack->Base - 4;
            pstack->Base = *pbase;

            //
            // Do any post call copies
            //

            if (pOutTemplate) {
                DoClientOutStuff(pdst, psrc, pOutTemplate);
            }

            return retval;
        }
    }

    //
    // an error occured
    //

    return 0;
}

/**************************************************************************\
\**************************************************************************/

#if defined(_MIPS_) || defined(_PPC_)
DWORD AIMakeCSCall(
    DWORD findex,
    PDWORD psrc,
    PDWORD pInTemplate,
    PDWORD pOutTemplate
    )
{
    PCSR_QLPC_TEB pteb = (PCSR_QLPC_TEB)NtCurrentTeb()->CsrQlpcTeb;
    PCSR_QLPC_STACK pstack;
    PCSRMSG pmsg;
    ULONG retval;
    PDWORD pbase;
    PDWORD pdst;
    PDWORD plast;
    PDWORD pmax;

    //
    // connect to the server
    //

    if (pteb == NULL) {
        pteb = CsrClientThreadConnect();
        if (pteb == NULL) {
            return 0;
        }
    }

    pstack = pteb->MessageStack;
    if (pstack->BatchCount) {
        CsrClientSendMessage();
        pbase = (PDWORD)((PBYTE)pstack + pstack->Base);
    } else {
        pbase = (PDWORD)((PBYTE)pstack + pstack->Current);
    }
    pmax = (PDWORD)((PBYTE)pstack + pstack->Limit);
    pmsg = (PCSRMSG)(pbase+1);

    //
    // is there enough space left on the stack?
    //

    if ((PDWORD)((PBYTE)pmsg + sizeof(PCSRMSG)) <= pmax) {

        //
        // copy the data to shared memory
        //

        pdst = (PDWORD)(pmsg + 1);
        if (pInTemplate) {
            plast = AIDoClientInStuff(psrc, pdst, pInTemplate, pmax);
        } else {
            plast = pdst;
        }

        if (plast) {

            //
            // Make the call
            //

            pmsg->Length = (PBYTE)plast - (PBYTE)pmsg;
            pmsg->ApiNumber = findex;
            *pbase = pstack->Base;
            pstack->Base = pstack->Current+4;
            pstack->Current = (PBYTE)pdst - (PBYTE)pstack;
            pstack->BatchCount = 1;

            retval = CsrClientSendMessage();

            pstack->Current = pstack->Base - 4;
            pstack->Base = *pbase;

            //
            // Do any post call copies
            //

            if (pOutTemplate) {
                AIDoClientOutStuff(pdst, psrc, pOutTemplate);
            }

            return retval;
        }
    }

    //
    // an error occured
    //

    return 0;
}
#endif

/**************************************************************************\
\**************************************************************************/

#ifdef LATER
typedef struct _TESTMSG {
    int a;
    int b;
    RECT *lprc;
    int c;
    LPSTR lpstr;
    RECT rc;
} TESTMSG;

PDWORD CSInTestCall(
    PDWORD psrc,
    PDWORD pdst,
    PDWORD pmax)
{
    PDWORD pvar;
    TESTMSG *pmsg;
    TESTMSG *pparam;

    if (pmax > pdst + sizeof(TESTMSG)) {
        pmsg = (TESTMSG *)pdst;
        pparam = (TESTMSG *)psrc;
        pvar = (PDWORD)(pmsg + 1);

        pmsg->a = pparam->a;
        pmsg->b = pparam->b;
        pmsg->c = pparam->c;

        pmsg->lprc = (RECT *)(((PBYTE)&(pmsg->rc)) - (PBYTE)pmsg);
        pmsg->rc = *(pparam->lprc);

        pmsg->lpstr = (LPSTR)((PBYTE)pvar - (PBYTE)pmsg);
        pvar = CopySTR((PDWORD)pparam->lpstr, pvar, NULL, pmax);

        if (pvar) {
            return (PDWORD)pvar;
        }
    }
    return 0;
}

typedef struct _TESTMSG {
    HWND hwnd;
    int a;
    int b;
    int c;
    int d;
    int e;
} TESTMSG;

PDWORD CSInTestCall(
    PDWORD psrc,
    PDWORD pdst,
    PDWORD pmax)
{
    TESTMSG *pmsg;
    TESTMSG *pparam;

    if (pmax > pdst + sizeof(TESTMSG)) {
        pmsg = (TESTMSG *)pdst;
        pparam = (TESTMSG *)psrc;

        pmsg->hwnd = pparam->hwnd;
        pmsg->a = pparam->a;
        pmsg->b = pparam->b;
        pmsg->c = pparam->c;
        pmsg->d = pparam->d;
        pmsg->e = pparam->e;
        return (PDWORD)(pmsg + 1);
    }
    return 0;
}
#endif

/**************************************************************************\
\**************************************************************************/

typedef PDWORD (* PCSINFUNC)(PDWORD, PDWORD, PDWORD);
typedef PDWORD (* PCSOUTFUNC)(PDWORD, PDWORD);


DWORD CSMakeCall(
    DWORD findex,
    PDWORD psrc,
    PCSINFUNC pInFunc,
    PCSOUTFUNC pOutFunc
    )
{
    PCSR_QLPC_TEB pteb = (PCSR_QLPC_TEB)NtCurrentTeb()->CsrQlpcTeb;
    PCSR_QLPC_STACK pstack;
    PCSRMSG pmsg;
    ULONG retval;
    PDWORD pbase;
    PDWORD pdst;
    PDWORD plast;
    PDWORD pmax;

    //
    // connect to the server
    //

    if (pteb == NULL) {
        pteb = CsrClientThreadConnect();
        if (pteb == NULL) {
            return 0;
        }
    }

    pstack = pteb->MessageStack;
    if (pstack->BatchCount) {
        CsrClientSendMessage();
        pbase = (PDWORD)((PBYTE)pstack + pstack->Base);
    } else {
        pbase = (PDWORD)((PBYTE)pstack + pstack->Current);
    }
    pmax = (PDWORD)((PBYTE)pstack + pstack->Limit);
    pmsg = (PCSRMSG)(pbase+1);

    //
    // is there enough space left on the stack?
    //

    pdst = (PDWORD)(pmsg + 1);
    if (pdst <= pmax) {

        //
        // copy the data to shared memory
        //

        if (pInFunc) {
            plast = pInFunc(psrc, pdst, pmax);
        } else {
            plast = pdst;
        }

        if (plast) {

            //
            // Make the call
            //

            pmsg->Length = (PBYTE)plast - (PBYTE)pmsg;
            pmsg->ApiNumber = findex;
            *pbase = pstack->Base;
            pstack->Base = pstack->Current+4;
            pstack->Current = (PBYTE)pdst - (PBYTE)pstack;
            pstack->BatchCount = 1;

            retval = CsrClientSendMessage();

            pstack->Current = pstack->Base - 4;
            pstack->Base = *pbase;

            //
            // Do any post call copies
            //

            if (pOutFunc) {
                pOutFunc(pdst, psrc);
            }

            return retval;
        }
    }

    //
    // an error occured
    //

    return 0;
}

/**************************************************************************\
\**************************************************************************/

// DWORD CTestCall(int a, int b, LPRECT lprc, int c, LPSTR lpstr)

#if 0
DWORD CTestCall(HWND hwnd, int a, int b, int c, int d, int e)
{
    return CSMakeCall(
        CSR_MAKE_API_NUMBER(4,FI_CTESTCALL),
        (PDWORD)&hwnd,
        CSInTestCall,
        NULL);
}
#endif

/**************************************************************************\
\**************************************************************************/

/**************************************************************************\
\**************************************************************************/

/**************************************************************************\
\**************************************************************************/

#ifdef LATER
DWORD InTestCall[] = {
    (DWORD)Copy5,
    (DWORD)Copy4,
    8,
    (DWORD)CopySTR,
    16,
    0
};
#endif

DWORD InTestCall[] = {
    (DWORD)Copy6,
    0
};

DWORD ITestCall(HWND hwnd, int a, int b, int c, int d, int e)
{
   return MakeCSCall(
       CSR_MAKE_API_NUMBER(4,FI_CTESTCALL),
       (PDWORD)&hwnd,
       InTestCall,
       NULL
   );
}

DWORD AITestCall(HWND hwnd, int a, int b, int c, int d, int e)
{
#if defined(_MIPS_) || defined(_PPC_)
   return AIMakeCSCall(
#else
   return MakeCSCall(
#endif
       CSR_MAKE_API_NUMBER(4,FI_CTESTCALL),
       (PDWORD)&hwnd,
       InTestCall,
       NULL
   );
}

/**************************************************************************\
\**************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\ntstubs.c ===
/**************************************************************************\
* Module Name: ntstubs.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* client side API stubs
*
* History:
* 03-19-95 JimA             Created.
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define CLIENTSIDE 1

#include <dbt.h>

#include "ntsend.h"
#include "cfgmgr32.h"
#include "csrhlpr.h"

extern BOOL GetRemoteKeyboardLayout(PWCHAR);

WINUSERAPI
BOOL
WINAPI
SetSysColors(
    int cElements,
    CONST INT * lpaElements,
    CONST COLORREF * lpaRgbValues)
{

    return NtUserSetSysColors(cElements,
                              lpaElements,
                              lpaRgbValues,
                              SSCF_NOTIFY | SSCF_FORCESOLIDCOLOR | SSCF_SETMAGICCOLORS);
}


HWND WOWFindWindow(
    LPCSTR pClassName,
    LPCSTR pWindowName)
{
    return InternalFindWindowExA(NULL, NULL, pClassName, pWindowName, FW_16BIT);
}

#ifdef IMM_PER_LOGON
void UpdatePerUserImmEnabling(void)
{
    BOOL fRet = (BOOL)NtUserCallNoParam(SFI_UPDATEPERUSERIMMENABLING);

    if (fRet) {
        if (IS_IME_ENABLED()) {
            /*
             * hen ImmEnable flag is update and it gets enabled during
             * the last logon, we need to load Imm32.dll.
             */
            HMODULE hModule = GetModuleHandleW(L"imm32.dll");
            if (hModule == NULL) {
                LoadLibraryW(L"imm32.dll");
            }
        }
    }
}
#endif


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, UpdatePerUserSystemParameters, HANDLE, hToken, DWORD, dwFlags)
BOOL UpdatePerUserSystemParameters(
    HANDLE  hToken,
    DWORD    dwFlags)
{
    WCHAR pwszKLID[KL_NAMELENGTH];

    BEGINCALL()
#ifdef IMM_PER_LOGON
        /*
         * Update the per user portion of the system metrics.
         * Continues even if this update fails.
         */
        UpdatePerUserImmEnabling();
#endif

        if ((dwFlags & UPUSP_USERLOGGEDON) || (dwFlags & (UPUSP_POLICYCHANGE | UPUSP_REMOTESETTINGS)) == 0) {
            /*
             * Initialize IME hotkeys before loading keyboard
             * layouts.
             */
            CliImmInitializeHotKeys(ISHK_INITIALIZE, NULL);
            /*
             * Load initial keyboard layout.
             */
            if (!GetRemoteKeyboardLayout(pwszKLID)) {
                GetActiveKeyboardName(pwszKLID);
            }

            LoadKeyboardLayoutWorker(NULL, pwszKLID, KLF_ACTIVATE | KLF_RESET | KLF_SUBSTITUTE_OK, TRUE);

            /*
             * Now load the remaining preload keyboard layouts.
             */
            LoadPreloadKeyboardLayouts();
        }
        /*
         * Only if not just a policy change.
         */
        if (dwFlags != UPUSP_POLICYCHANGE) {
            /*
             * FLush any MUI cach to be able to load strings latter for the new UIlangID.
             */
            LdrFlushAlternateResourceModules();
        }

        retval = (DWORD)NtUserUpdatePerUserSystemParameters(hToken, dwFlags);

        /*
         * Cause the wallpaper to be changed.
         */
        SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, 0, 0);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

DWORD Event(
    PEVENT_PACKET pep)
{
    BEGINCALL()

        CheckDDECritOut;

        retval = (DWORD)NtUserEvent(
                pep);

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

LONG GetClassWOWWords(
    HINSTANCE hInstance,
    LPCTSTR pString)
{
    IN_STRING strClassName;
    PCLS pcls;

    /*
     * Make sure cleanup will work successfully
     */
    strClassName.fAllocated = FALSE;

    BEGINCALL()

        FIRSTCOPYLPSTRW(&strClassName, pString);

        pcls = NtUserGetWOWClass(hInstance, strClassName.pstr);

        if (pcls == NULL) {
            MSGERRORCODE(ERROR_CLASS_DOES_NOT_EXIST);
        }

        pcls = (PCLS)((KPBYTE)pcls - GetClientInfo()->ulClientDelta);
        retval = _GetClassData(pcls, NULL, GCLP_WOWWORDS, TRUE);

    ERRORTRAP(0);
    CLEANUPLPSTRW(strClassName);
    ENDCALL(LONG);
}

/***************************************************************************\
* InitTask
*
* Initialize a WOW task.  This is the first call a WOW thread makes to user.
* NtUserInitTask returns NTSTATUS because if the thread fails to convert
* to a GUI thread, STATUS_INVALID_SYSTEM_SERVICE is returned.
*
* 11-03-95 JimA         Modified to use NTSTATUS.
\***************************************************************************/

BOOL InitTask(
    UINT wVersion,
    DWORD dwAppCompatFlags,
    DWORD dwUserWOWCompatFlags,
    LPCSTR pszModName,
    LPCSTR pszBaseFileName,
    DWORD hTaskWow,
    DWORD dwHotkey,
    DWORD idTask,
    DWORD dwX,
    DWORD dwY,
    DWORD dwXSize,
    DWORD dwYSize)
{
    IN_STRING strModName;
    IN_STRING strBaseFileName;
    NTSTATUS Status;

    /*
     * Make sure cleanup will work successfully
     */
    strModName.fAllocated = FALSE;
    strBaseFileName.fAllocated = FALSE;

    BEGINCALL()

        FIRSTCOPYLPSTRW(&strModName, pszModName);
        COPYLPSTRW(&strBaseFileName, pszBaseFileName);

        Status = NtUserInitTask(
                wVersion,
                dwAppCompatFlags,
                dwUserWOWCompatFlags,
                strModName.pstr,
                strBaseFileName.pstr,
                hTaskWow,
                dwHotkey,
                idTask,
                dwX,
                dwY,
                dwXSize,
                dwYSize);
        retval = (Status == STATUS_SUCCESS);

        CLEANUPLPSTRW(strModName);
        CLEANUPLPSTRW(strBaseFileName);

    ERRORTRAP(FALSE);
    ENDCALL(BOOL);
}

HANDLE ConvertMemHandle(
    HANDLE hData,
    UINT cbNULL)
{
    UINT cbData;
    LPBYTE lpData;

    BEGINCALL()

        if (GlobalFlags(hData) == GMEM_INVALID_HANDLE) {
            RIPMSG0(RIP_WARNING, "ConvertMemHandle hMem is not valid\n");
            MSGERROR();
            }

        if (!(cbData = (UINT)GlobalSize(hData)))
            MSGERROR();

        USERGLOBALLOCK(hData, lpData);
        if (lpData == NULL) {
            MSGERROR();
        }

        /*
         * Make sure text formats are NULL terminated.
         */
        switch (cbNULL) {
        case 2:
            lpData[cbData - 2] = 0;
            // FALL THROUGH
        case 1:
            lpData[cbData - 1] = 0;
        }

        retval = (ULONG_PTR)NtUserConvertMemHandle(lpData, cbData);

        USERGLOBALUNLOCK(hData);

    ERRORTRAP(NULL);
    ENDCALL(HANDLE);
}

HANDLE CreateLocalMemHandle(
    HANDLE hMem)
{
    UINT cbData;
    NTSTATUS Status;

    BEGINCALL()

        Status = NtUserCreateLocalMemHandle(hMem, NULL, 0, &cbData);
        if (Status != STATUS_BUFFER_TOO_SMALL) {
            RIPMSG0(RIP_WARNING, "__CreateLocalMemHandle server returned failure\n");
            MSGERROR();
        }

        if (!(retval = (ULONG_PTR)GlobalAlloc(GMEM_FIXED, cbData)))
            MSGERROR();

        Status = NtUserCreateLocalMemHandle(hMem, (LPBYTE)retval, cbData, NULL);
        if (!NT_SUCCESS(Status)) {
            RIPMSG0(RIP_WARNING, "__CreateLocalMemHandle server returned failure\n");
            UserGlobalFree((HANDLE)retval);
            MSGERROR();
        }

    ERRORTRAP(0);
    ENDCALL(HANDLE);
}

HHOOK _SetWindowsHookEx(
    HANDLE hmod,
    LPTSTR pszLib,
    DWORD idThread,
    int nFilterType,
    PROC pfnFilterProc,
    DWORD dwFlags)
{
    IN_STRING strLib;

    /*
     * Make sure cleanup will work successfully
     */
    strLib.fAllocated = FALSE;

    BEGINCALL()

        FIRSTCOPYLPWSTROPT(&strLib, pszLib);

        retval = (ULONG_PTR)NtUserSetWindowsHookEx(
                hmod,
                strLib.pstr,
                idThread,
                nFilterType,
                pfnFilterProc,
                dwFlags);

    ERRORTRAP(0);
    CLEANUPLPWSTR(strLib);
    ENDCALL(HHOOK);
}

/***************************************************************************\
* SetWinEventHook
*
* History:
* 1996-09-23 IanJa Created
\***************************************************************************/
WINUSERAPI
HWINEVENTHOOK
WINAPI
SetWinEventHook(
    DWORD        eventMin,
    DWORD        eventMax,
    HMODULE      hmodWinEventProc,   // Must pass this if global!
    WINEVENTPROC lpfnWinEventProc,
    DWORD        idProcess,          // Can be zero; all processes
    DWORD        idThread,           // Can be zero; all threads
    DWORD        dwFlags)
{
    UNICODE_STRING str;
    PUNICODE_STRING pstr;
    WCHAR awchLib[MAX_PATH];

    BEGINCALL()

        if ((dwFlags & WINEVENT_INCONTEXT) && (hmodWinEventProc != NULL)) {
            /*
             * If we're passing an hmod, we need to grab the file name of the
             * module while we're still on the client since module handles
             * are NOT global.
             */
            USHORT cb;
            cb = (USHORT)(sizeof(WCHAR) * GetModuleFileNameW(hmodWinEventProc, awchLib, sizeof(awchLib)/sizeof(WCHAR)));
            if (cb == 0) {
                /*
                 * hmod is bogus - return NULL.
                 */
                return NULL;
            }
            str.Buffer = awchLib;
            str.Length = cb - sizeof(UNICODE_NULL);
            str.MaximumLength = cb;
            pstr = &str;
        } else {
            pstr = NULL;
        }

        retval = (ULONG_PTR)NtUserSetWinEventHook(
                eventMin,
                eventMax,
                hmodWinEventProc,
                pstr,
                lpfnWinEventProc,
                idProcess,
                idThread,
                dwFlags);

    ERRORTRAP(0);
    ENDCALL(HWINEVENTHOOK);
};


FUNCLOGVOID4(LOG_GENERAL, WINAPI, NotifyWinEvent, DWORD, dwEvent, HWND, hwnd, LONG, idObject, LONG, idChild)
WINUSERAPI
VOID
WINAPI
NotifyWinEvent(
    DWORD dwEvent,
    HWND  hwnd,
    LONG  idObject,
    LONG  idChild)
{
    BEGINCALLVOID()

    if (FEVENTHOOKED(dwEvent)) {
        NtUserNotifyWinEvent(dwEvent, hwnd, idObject, idChild);
    }

    ERRORTRAPVOID();
    ENDCALLVOID();
}

/***************************************************************************\
* RegisterUserApiHook
*
* History:
* 03-Mar-2000 JerrySh   Created.
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, RegisterUserApiHook, HINSTANCE, hmod, INITUSERAPIHOOK, pfnUserApiHook)
BOOL RegisterUserApiHook(
    HINSTANCE hmod,
    INITUSERAPIHOOK pfnUserApiHook)
{
    WCHAR pwszLibFileName[MAX_PATH];
    ULONG_PTR offPfnProc;
    IN_STRING strLib;

    /*
     * If we're passing an hmod, we need to grab the file name of the
     * module while we're still on the client since module handles
     * are NOT global.
     */
    if (!GetModuleFileNameW(hmod, pwszLibFileName, ARRAY_SIZE(pwszLibFileName))) {
        return FALSE;
    }

    /*
     * Libraries are loaded at different linear addresses in different
     * process contexts.  For this reason, we need to convert the window
     * proc address into an offset while setting the hook, and then convert
     * it back to a real per-process function pointer when calling a
     * hook.  Do this by subtracting the 'hmod' (which is a pointer to the
     * linear and contiguous .exe header) from the function index.
     */
    offPfnProc = (ULONG_PTR)pfnUserApiHook - (ULONG_PTR)hmod;

    /*
     * Make sure cleanup will work successfully
     */
    strLib.fAllocated = FALSE;

    BEGINCALL()

        COPYLPWSTR(&strLib, pwszLibFileName);

        retval = (ULONG_PTR)NtUserRegisterUserApiHook(
                strLib.pstr,
                offPfnProc);

    ERRORTRAP(0);
    CLEANUPLPWSTR(strLib);
    ENDCALL(BOOL);
}


#ifdef MESSAGE_PUMP_HOOK

/***************************************************************************\
* ResetMessagePumpHook
*
* ResetMessagePumpHook() resets the MessagePumpHook function pointers
* to the internal "real" implementations.
*
* History:
* 12-13-2000    JStall      Created
\***************************************************************************/

void ResetMessagePumpHook(MESSAGEPUMPHOOK * pwmh)
{
    pwmh->cbSize                = sizeof(MESSAGEPUMPHOOK);
    pwmh->pfnInternalGetMessage = NtUserRealInternalGetMessage;
    pwmh->pfnWaitMessageEx      = NtUserRealWaitMessageEx;
    pwmh->pfnGetQueueStatus     = RealGetQueueStatus;
    pwmh->pfnMsgWaitForMultipleObjectsEx
                                = RealMsgWaitForMultipleObjectsEx;
}


/***************************************************************************\
* RegisterMessagePumpHook
*
* RegisterMessagePumpHook() sets up MPH's on the current thread.  If this is
* the first thread to be initialized in the process, the process-wide
* initialization is also performed.  If a thread has already been
* initialized with MPH's, its "ref-count" is incremented on the existing
* MPH's.
*
* NOTE: Unlike UserApiHook's, we make a callback while holding a critical
* section.  This is because it is infinitely easier to synchronize this
* inside USER32.DLL rather than allowing re-entrancy in the DLL.  It is
* designed after DllMain(), where the loader also has a lock that is
* sychronized.
*
* NOTE: Under the current implementation of MPH's, only one set of MPH's
* per process can be installed.  Each process may have a different set of
* WMH's.
*
* History:
* 12-13-2000    JStall      Created
\***************************************************************************/

BOOL RegisterMessagePumpHook(
    INITMESSAGEPUMPHOOK pfnInitMPH)
{
    BOOL fInit = FALSE;

    BEGINCALL()
    retval = FALSE;

    RtlEnterCriticalSection(&gcsMPH);

    if (pfnInitMPH == NULL) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "Need valid pfnInitMPH");
        goto errorexit;
    }

    if (gcLoadMPH == 0) {
        MESSAGEPUMPHOOK mphTemp;

        /*
         * First time we are initializing.
         */
        UserAssertMsg0(gpfnInitMPH == NULL, "MPH callback should not already be initialized");
        gpfnInitMPH = pfnInitMPH;

        ResetMessagePumpHook(&mphTemp);
        if (!(gpfnInitMPH)(UIAH_INITIALIZE, &mphTemp) || (mphTemp.cbSize == 0)) {
            goto errorexit;
        }

        CopyMemory(&gmph, &mphTemp, mphTemp.cbSize);
        fInit = TRUE;
    } else {
        if(gpfnInitMPH == pfnInitMPH) {
            /*
             * Initializing a second time with the same callback.
             */
            fInit = TRUE;
        }
    }

    if (fInit) {
        /*
         * Initialize MPH's on this thread.
         */
        if (NtUserCallNoParam(SFI__DOINITMESSAGEPUMPHOOK)) {
            if (gcLoadMPH++ == 0) {
                InterlockedExchange(&gfMessagePumpHook, TRUE);
            }
            retval = TRUE;
        }
    }

    ERRORTRAP(0);
    RtlLeaveCriticalSection(&gcsMPH);
    ENDCALL(BOOL);
}


/***************************************************************************\
* UnregisterMessagePumpHook
*
* UnregisterMessagePumpHook() decrements the count of WMH's on the current
* thread.  When this count reaches 0, WMH's are uninstalled from the
* current thread.  When the global WMH count reaches 0, WMH's are uninstalled
* from the entire process.
*
* NOTE: See RegisterMessagePumpHook() about use of the critical section.
*
* History:
* 12-13-2000    JStall      Created
\***************************************************************************/

BOOL UnregisterMessagePumpHook()
{
    BEGINCALL()
    RtlEnterCriticalSection(&gcsMPH);

    if (gcLoadMPH <= 0) {
        RIPMSG0(RIP_ERROR, "UninitMessagePumpHook: Called without matching Init()");
        goto errorexit;
    }

    /*
     * Uninitialize this thread's WMH.  When the reference count reaches 0, the
     * thread will no longer be hooked.
     */
    if (!NtUserCallNoParam(SFI__DOUNINITMESSAGEPUMPHOOK)) {
        goto errorexit;
    }

    if (--gcLoadMPH == 0) {
        /*
         * Final unload: make callback and reset
         */

        InterlockedExchange(&gfMessagePumpHook, FALSE);

        (gpfnInitMPH)(UIAH_UNINITIALIZE, NULL);

        ResetMessagePumpHook(&gmph);
        gpfnInitMPH = NULL;
    }
    retval = TRUE;

    ERRORTRAP(0);
    RtlLeaveCriticalSection(&gcsMPH);
    ENDCALL(BOOL);
}

#endif // MESSAGE_PUMP_HOOK



/***************************************************************************\
* ThunkedMenuItemInfo
*
* History:
*  07-22-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
BOOL ThunkedMenuItemInfo(
    HMENU hMenu,
    UINT nPosition,
    BOOL fByPosition,
    BOOL fInsert,
    LPMENUITEMINFOW lpmii,
    BOOL fAnsi)
{
    MENUITEMINFOW mii;
    IN_STRING strItem;

    /*
     * Make sure cleanup will work successfully
     */
    strItem.fAllocated = FALSE;

    BEGINCALL()

        /*
         *  Make a local copy so we can make changes
         */
        mii = *(LPMENUITEMINFO)(lpmii);

        strItem.pstr = NULL;
        if (mii.fMask & MIIM_BITMAP) {
            if (((HBITMAP)LOWORD(HandleToUlong(mii.hbmpItem)) < HBMMENU_MAX) && IS_PTR(mii.hbmpItem)) {
                /*
                 *  Looks like the user was trying to insert one of the
                 *  HBMMENU_* bitmaps, but stuffed some data in the HIWORD.
                 *  We know the HIWORD data is invalid because the LOWORD
                  *  handle is below the GDI minimum.
                 */
                RIPMSG1(RIP_WARNING, "Invalid HIWORD data (0x%04X) for HBMMENU_* bitmap.", HIWORD(HandleToUlong(mii.hbmpItem)));
                mii.hbmpItem = (HBITMAP)LOWORD(HandleToUlong(mii.hbmpItem));
            } else if (!IS_PTR(mii.hbmpItem) && (mii.hbmpItem >= HBMMENU_MAX)) {
            /*
             * The app is passing a 16-bit GDI handle.  GDI handles this on the
             * client-side, but not on the kernel side.  So convert it to 32-bits.
             * This fixes bug 201493 in Macromedia Director.
             */
                HBITMAP hbmNew = GdiFixUpHandle(mii.hbmpItem);
                if (hbmNew) {
                    RIPMSG2(RIP_WARNING, "Menu bitmap change, fix 16-bit bitmap handle %lx to %lx\n", mii.hbmpItem, hbmNew);
                    mii.hbmpItem = hbmNew;
                }
            }
        }

        if (mii.fMask & MIIM_STRING){
            if (fAnsi) {
                FIRSTCOPYLPSTROPTW(&strItem, mii.dwTypeData);
            } else {
                FIRSTCOPYLPWSTROPT(&strItem, mii.dwTypeData);
            }
        }

        retval = (DWORD)NtUserThunkedMenuItemInfo(
                hMenu,
                nPosition,
                fByPosition,
                fInsert,
                &mii,
                strItem.pstr);

    ERRORTRAP(FALSE);
    CLEANUPLPSTRW(strItem);
    ENDCALL(BOOL);
}

/***************************************************************************\
* DrawCaption
*
* History:
*   16-April-2001  Mohamed  Hooked API and created this wrapper.
\***************************************************************************/
FUNCLOG4(
    LOG_GENERAL,
    BOOL,
    DUMMYCALLINGTYPE,
    DrawCaption,
    HWND,
    hwnd,
    HDC,
    hdc,
    CONST RECT*,
    lprc,
    UINT,
    flags)

BOOL DrawCaption(
    HWND        hwnd,
    HDC         hdc,
    CONST RECT *lprc,
    UINT        flags)
{
    BOOL bRet;

    BEGIN_USERAPIHOOK()
        bRet = guah.pfnDrawCaption(hwnd, hdc, lprc, flags);
    END_USERAPIHOOK()

    return bRet;
}

BOOL RealDrawCaption(
    HWND        hwnd,
    HDC         hdc,
    CONST RECT *lprc,
    UINT        flags)
{
    HDC hdcr;
    BEGINCALL()

        if (IsMetaFile(hdc))
            return FALSE;

        hdcr = GdiConvertAndCheckDC(hdc);
        if (hdcr == (HDC)0)
            return FALSE;

        retval = (DWORD)NtUserDrawCaption(hwnd, hdcr, lprc, flags);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}


FUNCLOG1(LOG_GENERAL, SHORT, DUMMYCALLINGTYPE, GetAsyncKeyState, int, vKey)
SHORT GetAsyncKeyState(
    int vKey)
{
    BEGINCALLCONNECT()

        /*
         * Asynchronous key state reports the PHYSICAL mouse button,
         * regardless of whether the buttons have been swapped or not.
         */
        if (((vKey == VK_RBUTTON) || (vKey == VK_LBUTTON)) && SYSMET(SWAPBUTTON)) {
            vKey ^= (VK_RBUTTON ^ VK_LBUTTON);
        }

        /*
         * If this is one of the common keys, see if we can pull it out
         * of the cache.
         */
        if ((UINT)vKey < CVKASYNCKEYCACHE) {
            PCLIENTINFO pci = GetClientInfo();
            if ((pci->dwAsyncKeyCache == gpsi->dwAsyncKeyCache) &&
                !TestKeyRecentDownBit(pci->afAsyncKeyStateRecentDown, vKey)) {

                if (TestKeyDownBit(pci->afAsyncKeyState, vKey))
                    retval = 0x8000;
                else
                    retval = 0;

                return (SHORT)retval;
            }
        }

        retval = (DWORD)NtUserGetAsyncKeyState(
                vKey);

    ERRORTRAP(0);
    ENDCALL(SHORT);
}


FUNCLOG1(LOG_GENERAL, SHORT, DUMMYCALLINGTYPE, GetKeyState, int, vKey)
SHORT GetKeyState(
    int vKey)
{
    BEGINCALLCONNECT()

        /*
         * If this is one of the common keys, see if we can pull it out
         * of the cache.
         */
        if ((UINT)vKey < CVKKEYCACHE) {
            PCLIENTINFO pci = GetClientInfo();
            if (pci->dwKeyCache == gpsi->dwKeyCache) {
                retval = 0;
                if (TestKeyToggleBit(pci->afKeyState, vKey))
                    retval |= 0x0001;
                if (TestKeyDownBit(pci->afKeyState, vKey)) {
                  /*
                   * Used to be retval |= 0x8000.Fix for bug 28820; Ctrl-Enter
                   * accelerator doesn't work on Nestscape Navigator Mail 2.0
                   */
                    retval |= 0xff80;  // This is what 3.1 returned!!!!
                }

                return (SHORT)retval;
            }
        }

        retval = (DWORD)NtUserGetKeyState(
                vKey);

    ERRORTRAP(0);
    ENDCALL(SHORT);
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, OpenClipboard, HWND, hwnd)
BOOL OpenClipboard(
    HWND hwnd)
{
    BOOL fEmptyClient;

    BEGINCALL()

        retval = (DWORD)NtUserOpenClipboard(hwnd, &fEmptyClient);

        if (fEmptyClient)
            ClientEmptyClipboard();

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

BOOL _PeekMessage(
    LPMSG pmsg,
    HWND hwnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg,
    BOOL bAnsi)
{
    BEGINCALL()

        if (bAnsi) {
            //
            // If we have pushed message for DBCS messaging, we should pass this one
            // to Apps at first...
            //
            GET_DBCS_MESSAGE_IF_EXIST(
                PeekMessage,pmsg,wMsgFilterMin,wMsgFilterMax,((wRemoveMsg & PM_REMOVE) ? TRUE:FALSE));
        }

        retval = (DWORD)NtUserPeekMessage(
                pmsg,
                hwnd,
                wMsgFilterMin,
                wMsgFilterMax,
                wRemoveMsg);

        if (retval) {
            // May have a bit more work to do if this MSG is for an ANSI app

            if (bAnsi) {
                if (RtlWCSMessageWParamCharToMB(pmsg->message, &(pmsg->wParam))) {
                    WPARAM dwAnsi = pmsg->wParam;
                    //
                    // Build DBCS-ware wParam. (for EM_SETPASSWORDCHAR...)
                    //
                    BUILD_DBCS_MESSAGE_TO_CLIENTA_FROM_SERVER(
                        pmsg,dwAnsi,TRUE,((wRemoveMsg & PM_REMOVE) ? TRUE:FALSE));
                } else {
                    retval = 0;
                }
            } else {
               //
               // Only LOWORD of WPARAM is valid for WM_CHAR....
               // (Mask off DBCS messaging information.)
               //
               BUILD_DBCS_MESSAGE_TO_CLIENTW_FROM_SERVER(pmsg->message,pmsg->wParam);
            }
        }

ExitPeekMessage:

    ERRORTRAP(0);
    ENDCALL(BOOL);
}


LONG_PTR _SetWindowLongPtr(
    HWND hwnd,
    int nIndex,
    LONG_PTR dwNewLong,
    BOOL bAnsi)
{
    PWND pwnd;
    LONG_PTR dwOldLong;
    DWORD dwCPDType = 0;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    if (TestWF(pwnd, WFDIALOGWINDOW)) {
        switch (nIndex) {
        case DWLP_DLGPROC:    // See similar case GWL_WNDPROC

            /*
             * Hide the window proc from other processes
             */
            if (!TestWindowProcess(pwnd)) {
                RIPERR1(ERROR_ACCESS_DENIED,
                        RIP_WARNING,
                        "Access denied to hwnd (%#lx) in _SetWindowLong",
                        hwnd);

                return 0;
            }

            /*
             * Get the old window proc address
             */
            dwOldLong = (LONG_PTR)PDLG(pwnd)->lpfnDlg;

            /*
             * We always store the actual address in the wndproc; We only
             * give the CallProc handles to the application
             */
            UserAssert(!ISCPDTAG(dwOldLong));

            /*
             * May need to return a CallProc handle if there is an
             * Ansi/Unicode tranistion
             */

            if (bAnsi != ((PDLG(pwnd)->flags & DLGF_ANSI) ? TRUE : FALSE)) {
                dwCPDType |= bAnsi ? CPD_ANSI_TO_UNICODE : CPD_UNICODE_TO_ANSI;
            }

            /*
             * If we detected a transition create a CallProc handle for
             * this type of transition and this wndproc (dwOldLong)
             */
            if (dwCPDType) {
                ULONG_PTR cpd;

                cpd = GetCPD(pwnd, dwCPDType | CPD_DIALOG, dwOldLong);

                if (cpd) {
                    dwOldLong = cpd;
                } else {
                    RIPMSG0(RIP_WARNING, "SetWindowLong (DWL_DLGPROC) unable to alloc CPD returning handle\n");
                }
            }

            /*
             * Convert a possible CallProc Handle into a real address.
             * The app may have kept the CallProc Handle from some
             * previous mixed GetClassinfo or SetWindowLong.
             *
             * WARNING bAnsi is modified here to represent real type of
             * proc rather than if SetWindowLongA or W was called
             */
            if (ISCPDTAG(dwNewLong)) {
                PCALLPROCDATA pCPD;
                if (pCPD = HMValidateHandleNoRip((HANDLE)dwNewLong, TYPE_CALLPROC)) {
                    dwNewLong = KERNEL_ULONG_PTR_TO_ULONG_PTR(pCPD->pfnClientPrevious);
                    bAnsi = pCPD->wType & CPD_UNICODE_TO_ANSI;
                }
            }

            /*
             * If an app 'unsubclasses' a server-side window proc we need to
             * restore everything so SendMessage and friends know that it's
             * a server-side proc again.  Need to check against client side
             * stub addresses.
             */
            PDLG(pwnd)->lpfnDlg = (DLGPROC)dwNewLong;
            if (bAnsi) {
                PDLG(pwnd)->flags |= DLGF_ANSI;
            } else {
                PDLG(pwnd)->flags &= ~DLGF_ANSI;
            }

            return dwOldLong;

        case DWLP_USER:
#ifdef BUILD_WOW6432
            // kernel has special handling of DWLP_USER
            nIndex = sizeof(KERNEL_LRESULT) + sizeof(KERNEL_PVOID);
#endif
        case DWLP_MSGRESULT:
            break;

        default:
            if (nIndex >= 0 && nIndex < DLGWINDOWEXTRA) {
                RIPERR0(ERROR_PRIVATE_DIALOG_INDEX, RIP_VERBOSE, "");
                return 0;
            }
        }
    }

    BEGINCALL()

    /*
     * If this is a listbox window and the listbox structure has
     * already been initialized, don't allow the app to override the
     * owner draw styles. We need to do this since Windows only
     * used the styles in creating the structure, but we also use
     * them to determine if strings need to be thunked.
     *
     */

    if (nIndex == GWL_STYLE &&
        GETFNID(pwnd) == FNID_LISTBOX &&
        ((PLBWND)pwnd)->pLBIV != NULL &&
        (!TestWindowProcess(pwnd) || ((PLBWND)pwnd)->pLBIV->fInitialized)) {

#if DBG
        LONG_PTR dwDebugLong = dwNewLong;
#endif

        dwNewLong &= ~(LBS_OWNERDRAWFIXED |
                       LBS_OWNERDRAWVARIABLE |
                       LBS_HASSTRINGS);

        dwNewLong |= pwnd->style & (LBS_OWNERDRAWFIXED |
                                    LBS_OWNERDRAWVARIABLE |
                                    LBS_HASSTRINGS);

#if DBG
        if (dwDebugLong != dwNewLong) {
           RIPMSG0(RIP_WARNING, "SetWindowLong can't change LBS_OWNERDRAW* or LBS_HASSTRINGS.");
        }
#endif
    }


        retval = (ULONG_PTR)NtUserSetWindowLongPtr(
                hwnd,
                nIndex,
                dwNewLong,
                bAnsi);

    ERRORTRAP(0);
    ENDCALL(LONG_PTR);
}

#ifdef _WIN64
LONG _SetWindowLong(
    HWND hwnd,
    int nIndex,
    LONG dwNewLong,
    BOOL bAnsi)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    if (TestWF(pwnd, WFDIALOGWINDOW)) {
        switch (nIndex) {
        case DWLP_DLGPROC:    // See similar case GWLP_WNDPROC
            RIPERR1(ERROR_INVALID_INDEX, RIP_WARNING, "SetWindowLong: invalid index %d", nIndex);
            return 0;

        case DWLP_MSGRESULT:
        case DWLP_USER:
            break;

        default:
            if (nIndex >= 0 && nIndex < DLGWINDOWEXTRA) {
                RIPERR0(ERROR_PRIVATE_DIALOG_INDEX, RIP_VERBOSE, "");
                return 0;
            }
        }
    }

    BEGINCALL()

    /*
     * If this is a listbox window and the listbox structure has
     * already been initialized, don't allow the app to override the
     * owner draw styles. We need to do this since Windows only
     * used the styles in creating the structure, but we also use
     * them to determine if strings need to be thunked.
     *
     */

    if (nIndex == GWL_STYLE &&
        GETFNID(pwnd) == FNID_LISTBOX &&
        ((PLBWND)pwnd)->pLBIV != NULL &&
        (!TestWindowProcess(pwnd) || ((PLBWND)pwnd)->pLBIV->fInitialized)) {

#if DBG
        LONG dwDebugLong = dwNewLong;
#endif

        dwNewLong &= ~(LBS_OWNERDRAWFIXED |
                       LBS_OWNERDRAWVARIABLE |
                       LBS_HASSTRINGS);

        dwNewLong |= pwnd->style & (LBS_OWNERDRAWFIXED |
                                    LBS_OWNERDRAWVARIABLE |
                                    LBS_HASSTRINGS);

#if DBG
        if (dwDebugLong != dwNewLong) {
           RIPMSG0(RIP_WARNING, "SetWindowLong can't change LBS_OWNERDRAW* or LBS_HASSTRINGS.");
        }
#endif
    }


        retval = (DWORD)NtUserSetWindowLong(
                hwnd,
                nIndex,
                dwNewLong,
                bAnsi);

    ERRORTRAP(0);
    ENDCALL(LONG);
}
#endif

BOOL TranslateMessageEx(
    CONST MSG *pmsg,
    UINT flags)
{
    BEGINCALL()

        /*
         * Don't bother going over to the kernel if this isn't
         * key message.
         */
        switch (pmsg->message) {
        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_SYSKEYDOWN:
        case WM_SYSKEYUP:
            break;
        default:
            if (pmsg->message & RESERVED_MSG_BITS) {
                RIPERR1(ERROR_INVALID_PARAMETER,
                        RIP_WARNING,
                        "Invalid parameter \"pmsg->message\" (%ld) to TranslateMessageEx",
                        pmsg->message);
            }
            MSGERROR();
        }

        retval = (DWORD)NtUserTranslateMessage(
                pmsg,
                flags);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

BOOL TranslateMessage(
    CONST MSG *pmsg)
{
    //
    // IME special key handling
    //
    if ( LOWORD(pmsg->wParam) == VK_PROCESSKEY ) {
        BOOL fResult;
        //
        // This vkey should be processed by IME
        //
        fResult = fpImmTranslateMessage( pmsg->hwnd,
                                       pmsg->message,
                                       pmsg->wParam,
                                       pmsg->lParam );
        if ( fResult )
            return fResult;
    }
    return(TranslateMessageEx(pmsg, 0));
}


FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetWindowRgn, HWND, hwnd, HRGN, hrgn, BOOL, bRedraw)
BOOL SetWindowRgn(
    HWND hwnd,
    HRGN hrgn,
    BOOL bRedraw)
{
    BOOL ret;

    BEGIN_USERAPIHOOK()
        ret = guah.pfnSetWindowRgn(hwnd, hrgn, bRedraw);
    END_USERAPIHOOK()

    return ret;
}


BOOL RealSetWindowRgn(
    HWND hwnd,
    HRGN hrgn,
    BOOL bRedraw)
{
    BEGINCALL()

        retval = (DWORD)NtUserSetWindowRgn(
                hwnd,
                hrgn,
                bRedraw);

        if (retval) {
            DeleteObject(hrgn);
        }

    ERRORTRAP(0);
    ENDCALL(BOOL);
}


FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, InternalGetWindowText, HWND, hwnd, LPWSTR, pString, int, cchMaxCount)
BOOL InternalGetWindowText(
    HWND hwnd,
    LPWSTR pString,
    int cchMaxCount)
{
    BEGINCALL()

        retval = (DWORD)NtUserInternalGetWindowText(
                hwnd,
                pString,
                cchMaxCount);

        if (!retval) {
            *pString = (WCHAR)0;
        }

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

int ToUnicode(
    UINT wVirtKey,
    UINT wScanCode,
    CONST BYTE *pKeyState,
    LPWSTR pwszBuff,
    int cchBuff,
    UINT wFlags)
{
    BEGINCALL()

        retval = (DWORD)NtUserToUnicodeEx(
                wVirtKey,
                wScanCode,
                pKeyState,
                pwszBuff,
                cchBuff,
                wFlags,
                (HKL)NULL);

        if (!retval) {
            *pwszBuff = L'\0';
        }

    ERRORTRAP(0);
    ENDCALL(int);
}

int ToUnicodeEx(
    UINT wVirtKey,
    UINT wScanCode,
    CONST BYTE *pKeyState,
    LPWSTR pwszBuff,
    int cchBuff,
    UINT wFlags,
    HKL hkl)
{
    BEGINCALL()

    retval = (DWORD)NtUserToUnicodeEx(
            wVirtKey,
            wScanCode,
            pKeyState,
            pwszBuff,
            cchBuff,
            wFlags,
            hkl);

    if (!retval) {
        *pwszBuff = L'\0';
    }

    ERRORTRAP(0);
    ENDCALL(int);
}

#if DBG

FUNCLOGVOID2(LOG_GENERAL, DUMMYCALLINGTYPE, DbgWin32HeapFail, DWORD, dwFlags, BOOL, bFail)
VOID DbgWin32HeapFail(
    DWORD dwFlags,
    BOOL  bFail)
{
    if ((dwFlags | WHF_VALID) != WHF_VALID) {
        RIPMSG1(RIP_WARNING, "Invalid flags for DbgWin32HeapFail %x", dwFlags);
        return;
    }

    if (dwFlags & WHF_CSRSS) {
        // Tell csr about it
        CsrWin32HeapFail(dwFlags, bFail);
    }

    NtUserDbgWin32HeapFail(dwFlags, bFail);
}


FUNCLOG3(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, DbgWin32HeapStat, PDBGHEAPSTAT, phs, DWORD, dwLen, DWORD, dwFlags)
DWORD DbgWin32HeapStat(
    PDBGHEAPSTAT    phs,
    DWORD   dwLen,
    DWORD   dwFlags)
{
    if ((dwFlags | WHF_VALID) != WHF_VALID) {
        RIPMSG1(RIP_WARNING, "Invalid flags for DbgWin32HeapFail %x", dwFlags);
        return 0;
    }

    if (dwFlags & WHF_CSRSS) {
        return CsrWin32HeapStat(phs, dwLen);
    } else if (dwFlags & WHF_DESKTOP) {
        return NtUserDbgWin32HeapStat(phs, dwLen);
    }
    return 0;
}

#endif // DBG


FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetWindowStationUser, HWINSTA, hwinsta, PLUID, pluidUser, PSID, psidUser, DWORD, cbsidUser)
BOOL SetWindowStationUser(
    HWINSTA hwinsta,
    PLUID   pluidUser,
    PSID    psidUser,
    DWORD   cbsidUser)
{
    LUID luidNone = { 0, 0 };


    BEGINCALL()

        retval = (DWORD)NtUserSetWindowStationUser(hwinsta,
                                                   pluidUser,
                                                   psidUser,
                                                   cbsidUser);

        /*
         * Load global atoms if the logon succeeded
         */
        if (retval) {

            if (!RtlEqualLuid(pluidUser,&luidNone)) {
                /*
                 * Reset console and load Nls data.
                 */
                Logon(TRUE);
            } else {
                /*
                 * Flush NLS cache.
                 */
                Logon(FALSE);
            }

            retval = TRUE;
        }
    ERRORTRAP(0);
    ENDCALL(BOOL);
}


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetSystemCursor, HCURSOR, hcur, DWORD, id)
BOOL SetSystemCursor(
    HCURSOR hcur,
    DWORD   id)
{
    BEGINCALL()

        if (hcur == NULL) {
            hcur = (HANDLE)LoadIcoCur(NULL,
                                      MAKEINTRESOURCE(id),
                                      RT_CURSOR,
                                      0,
                                      0,
                                      LR_DEFAULTSIZE);

            if (hcur == NULL)
                MSGERROR();
        }

        retval = (DWORD)NtUserSetSystemCursor(hcur, id);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

HCURSOR FindExistingCursorIcon(
    LPWSTR      pszModName,
    LPCWSTR     pszResName,
    PCURSORFIND pcfSearch)
{
    IN_STRING strModName;
    IN_STRING strResName;

    /*
     * Make sure cleanup will work successfully
     */
    strModName.fAllocated = FALSE;
    strResName.fAllocated = FALSE;

    BEGINCALL()

        if (pszModName == NULL)
            pszModName = szUSER32;

        COPYLPWSTR(&strModName, pszModName);
        COPYLPWSTRID(&strResName, pszResName);

        retval = (ULONG_PTR)NtUserFindExistingCursorIcon(strModName.pstr,
                                                     strResName.pstr,
                                                     pcfSearch);

    ERRORTRAP(0);

    CLEANUPLPWSTR(strModName);
    CLEANUPLPWSTR(strResName);

    ENDCALL(HCURSOR);
}



BOOL _SetCursorIconData(
    HCURSOR     hCursor,
    PCURSORDATA pcur)
{
    IN_STRING  strModName;
    IN_STRING  strResName;

    /*
     * Make sure cleanup will work successfully
     */
    strModName.fAllocated = FALSE;
    strResName.fAllocated = FALSE;

    BEGINCALL()

        COPYLPWSTROPT(&strModName, KPWSTR_TO_PWSTR(pcur->lpModName));
        COPYLPWSTRIDOPT(&strResName, KPWSTR_TO_PWSTR(pcur->lpName));

        retval = (DWORD)NtUserSetCursorIconData(hCursor,
                                                strModName.pstr,
                                                strResName.pstr,
                                                pcur);

    ERRORTRAP(0);

    CLEANUPLPWSTR(strModName);
    CLEANUPLPWSTR(strResName);

    ENDCALL(BOOL);
}



BOOL _DefSetText(
    HWND hwnd,
    LPCWSTR lpszText,
    BOOL bAnsi)
{
    LARGE_STRING str;

    BEGINCALL()

        if (lpszText) {
            if (bAnsi)
                RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&str,
                        (LPSTR)lpszText, (UINT)-1);
            else
                RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&str,
                        lpszText, (UINT)-1);
        }

        retval = (DWORD)NtUserDefSetText(
                hwnd,
                lpszText ? &str : NULL);

    ERRORTRAP(0);
    ENDCALL(BOOL);
}

HWND _CreateWindowEx(
    DWORD dwExStyle,
    LPCTSTR pClassName,
    LPCTSTR pWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hwndParent,
    HMENU hmenu,
    HANDLE hModule,
    LPVOID pParam,
    DWORD dwFlags)
{
    LARGE_IN_STRING strClassName;
    LARGE_STRING strWindowName;
    PLARGE_STRING pstrClassName;
    PLARGE_STRING pstrWindowName;
    DWORD dwExpWinVerAndFlags;

    /*
     * Make sure cleanup will work successfully
     */
    strClassName.fAllocated = FALSE;

    /*
     * To be compatible with Chicago, we test the validity of
     * the ExStyle bits and fail if any invalid bits are found.
     * And for backward compatibilty with NT apps, we only fail for
     * new apps (post NT 3.1).
     */

// BOGUS

    if (dwExStyle & 0x00000800L) {
        dwExStyle |= WS_EX_TOOLWINDOW;
        dwExStyle &= 0xfffff7ffL;
    }

    dwExpWinVerAndFlags = (DWORD)(WORD)GETEXPWINVER(hModule);
    if ((dwExStyle & ~WS_EX_ALLVALID) && Is400Compat(dwExpWinVerAndFlags)) {
        RIPMSG0(RIP_ERROR, "Invalid 5.1 ExStyle\n");
        return NULL;
    }
    {

    BOOL fMDIchild = FALSE;
    MDICREATESTRUCT mdics;
    HMENU hSysMenu;

    BEGINCALL()

        if ((fMDIchild = (BOOL)(dwExStyle & WS_EX_MDICHILD))) {
            SHORTCREATE sc;
            PWND pwndParent;

            pwndParent = ValidateHwnd(hwndParent);

            if ((pwndParent == NULL) || (GETFNID(pwndParent) != FNID_MDICLIENT)) {
                RIPMSG0(RIP_ERROR, "Invalid parent for MDI child window\n");
                MSGERROR();
            }

            mdics.lParam  = (LPARAM)pParam;
            pParam = &mdics;
            mdics.x = sc.x = x;
            mdics.y = sc.y = y;
            mdics.cx = sc.cx = nWidth;
            mdics.cy = sc.cy = nHeight;
            mdics.style = sc.style = dwStyle;
            mdics.hOwner = hModule;
            mdics.szClass = pClassName;
            mdics.szTitle = pWindowName;

            if (!CreateMDIChild(&sc, &mdics, dwExpWinVerAndFlags, &hSysMenu, pwndParent))
                MSGERROR();

            x = sc.x;
            y = sc.y;
            nWidth = sc.cx;
            nHeight = sc.cy;
            dwStyle = sc.style;
            hmenu = sc.hMenu;
        }

        /*
         * Set up class and window name.  If the window name is an
         * ordinal, make it look like a string so the callback thunk
         * will be able to ensure it is in the correct format.
         */
        pstrWindowName = NULL;
        if (dwFlags & CW_FLAGS_ANSI) {
            dwExStyle = dwExStyle | WS_EX_ANSICREATOR;

            if (IS_PTR(pClassName)) {
                RtlCaptureLargeAnsiString(&strClassName,
                        (PCHAR)pClassName, TRUE);
                pstrClassName = (PLARGE_STRING)strClassName.pstr;
            } else
                pstrClassName = (PLARGE_STRING)pClassName;

            if (pWindowName != NULL) {
                if (*(PBYTE)pWindowName == 0xff) {
                    strWindowName.bAnsi = TRUE;
                    strWindowName.Buffer = (PVOID)pWindowName;
                    strWindowName.Length = 3;
                    strWindowName.MaximumLength = 3;
                } else
                    RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&strWindowName,
                            (LPSTR)pWindowName, (UINT)-1);
                pstrWindowName = &strWindowName;
            }
        } else {
            if (IS_PTR(pClassName)) {
                RtlInitLargeUnicodeString(
                        (PLARGE_UNICODE_STRING)&strClassName.strCapture,
                        pClassName, (UINT)-1);
                pstrClassName = (PLARGE_STRING)&strClassName.strCapture;
            } else
                pstrClassName = (PLARGE_STRING)pClassName;

            if (pWindowName != NULL) {
                if (pWindowName != NULL &&
                     *(PWORD)pWindowName == 0xffff) {
                    strWindowName.bAnsi = FALSE;
                    strWindowName.Buffer = (PVOID)pWindowName;
                    strWindowName.Length = 4;
                    strWindowName.MaximumLength = 4;
                } else
                    RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&strWindowName,
                            pWindowName, (UINT)-1);
                pstrWindowName = &strWindowName;
            }
        }

        dwExpWinVerAndFlags |= (dwFlags & (CW_FLAGS_DIFFHMOD | CW_FLAGS_VERSIONCLASS));

        retval = (ULONG_PTR)VerNtUserCreateWindowEx(
                dwExStyle,
                pstrClassName,
                pstrWindowName,
                dwStyle,
                x,
                y,
                nWidth,
                nHeight,
                hwndParent,
                hmenu,
                hModule,
                pParam,
                dwExpWinVerAndFlags);

    // If this is an MDI child, we need to do some more to complete the
    // process of creating an MDI child.
    if (retval && fMDIchild) {
        MDICompleteChildCreation((HWND)retval, hSysMenu, ((dwStyle & WS_VISIBLE) != 0L), (BOOL)((dwStyle & WS_DISABLED)!= 0L));
    }


    ERRORTRAP(0);
    CLEANUPLPSTRW(strClassName);
    ENDCALL(HWND);
    }

}

HKL _LoadKeyboardLayoutEx(
    HANDLE hFile,
    UINT offTable,
    PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    HKL hkl,
    LPCTSTR pwszKL,
    UINT KbdInputLocale,
    UINT Flags)
{
    IN_STRING strKL;

    /*
     * Make sure cleanup will work successfully
     */
    strKL.fAllocated = FALSE;

    BEGINCALL()

        FIRSTCOPYLPWSTR(&strKL, pwszKL);

        retval = (ULONG_PTR)NtUserLoadKeyboardLayoutEx(
                hFile,
                offTable,
                pKbdTableMulti,
                hkl,
                strKL.pstr,
                KbdInputLocale,
                Flags);

    ERRORTRAP(0);
    CLEANUPLPWSTR(strKL);
    ENDCALL(HKL);
}


FUNCLOGVOID5(LOG_GENERAL, DUMMYCALLINGTYPE, mouse_event, DWORD, dwFlags, DWORD, dx, DWORD, dy, DWORD, dwData, ULONG_PTR, dwExtraInfo)
VOID mouse_event(
    DWORD dwFlags,
    DWORD dx,
    DWORD dy,
    DWORD dwData,
    ULONG_PTR dwExtraInfo)
{
    INPUT ms;

    BEGINCALLVOID()

        ms.type           = INPUT_MOUSE;
        ms.mi.dwFlags     = dwFlags;
        ms.mi.dx          = dx;
        ms.mi.dy          = dy;
        ms.mi.mouseData   = dwData;
        ms.mi.time        = 0;
        ms.mi.dwExtraInfo = dwExtraInfo;

        NtUserSendInput(1, &ms, sizeof(INPUT));

    ENDCALLVOID()
}


FUNCLOGVOID4(LOG_GENERAL, DUMMYCALLINGTYPE, keybd_event, BYTE, bVk, BYTE, bScan, DWORD, dwFlags, ULONG_PTR, dwExtraInfo)
VOID keybd_event(
    BYTE  bVk,
    BYTE  bScan,
    DWORD dwFlags,
    ULONG_PTR dwExtraInfo)
{
    INPUT kbd;

    BEGINCALLVOID()

        kbd.type           = INPUT_KEYBOARD;
        kbd.ki.dwFlags     = dwFlags;
        kbd.ki.wVk         = bVk;
        kbd.ki.wScan       = bScan;
        kbd.ki.time        = 0;
        kbd.ki.dwExtraInfo = dwExtraInfo;

        NtUserSendInput(1, &kbd, sizeof(INPUT));

    ENDCALLVOID()
}

/*
 * Message thunks
 */
MESSAGECALL(fnINWPARAMDBCSCHAR)
{
    BEGINCALL()

        /*
         * The server always expects the characters to be unicode so
         * if this was generated from an ANSI routine convert it to Unicode
         */
        if (bAnsi) {

            /*
             * Setup for DBCS Messaging..
             */
            BUILD_DBCS_MESSAGE_TO_SERVER_FROM_CLIENTA(msg,wParam,TRUE);

            /*
             * Convert DBCS/SBCS to Unicode...
             */
            RtlMBMessageWParamCharToWCS(msg, &wParam);
        }

        retval = (DWORD)NtUserMessageCall(
                hwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

MESSAGECALL(fnCOPYGLOBALDATA)
{
    PBYTE pData;
    BEGINCALL()

        if (wParam == 0) {
            MSGERROR();
        }

        USERGLOBALLOCK((HGLOBAL)lParam, pData);
        if (pData == NULL) {
            MSGERROR();
        }
        retval = NtUserMessageCall(
                hwnd,
                msg,
                wParam,
                (LPARAM)pData,
                xParam,
                xpfnProc,
                bAnsi);
        USERGLOBALUNLOCK((HGLOBAL)lParam);
        UserGlobalFree((HGLOBAL)lParam);
    ERRORTRAP(0);
    ENDCALL(ULONG_PTR);
}

MESSAGECALL(fnINPAINTCLIPBRD)
{
    LPPAINTSTRUCT lpps;

    BEGINCALL()

        USERGLOBALLOCK((HGLOBAL)lParam, lpps);
        if (lpps) {
            retval = (DWORD)NtUserMessageCall(
                    hwnd,
                    msg,
                    wParam,
                    (LPARAM)lpps,
                    xParam,
                    xpfnProc,
                    bAnsi);
            USERGLOBALUNLOCK((HGLOBAL)lParam);
        } else {
            RIPMSG1(RIP_WARNING, "MESSAGECALL(fnINPAINTCLIPBRD): USERGLOBALLOCK failed on %p!", lParam);
            MSGERROR();
        }

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

MESSAGECALL(fnINSIZECLIPBRD)
{
    LPRECT lprc;
    BEGINCALL()

        USERGLOBALLOCK((HGLOBAL)lParam, lprc);
        if (lprc) {
            retval = (DWORD)NtUserMessageCall(
                    hwnd,
                    msg,
                    wParam,
                    (LPARAM)lprc,
                    xParam,
                    xpfnProc,
                bAnsi);
            USERGLOBALUNLOCK((HGLOBAL)lParam);
        } else {
            RIPMSG1(RIP_WARNING, "MESSAGECALL(fnINSIZECLIPBRD): USERGLOBALLOCK failed on %p!", lParam);
            MSGERROR();
        }

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

MESSAGECALL(fnINDEVICECHANGE)
{
    struct _DEV_BROADCAST_HEADER *pHdr;
    PDEV_BROADCAST_PORT_W pPortW = NULL;
    PDEV_BROADCAST_PORT_A pPortA;
    PDEV_BROADCAST_DEVICEINTERFACE_W pInterfaceW = NULL;
    PDEV_BROADCAST_DEVICEINTERFACE_A pInterfaceA;
    PDEV_BROADCAST_HANDLE pHandleW = NULL;
    PDEV_BROADCAST_HANDLE pHandleA;

    LPWSTR lpStr;
    int iStr, iSize;

    BEGINCALL()

        if (!(wParam &0x8000) || !lParam || !bAnsi)
            goto shipit;

        pHdr = (struct _DEV_BROADCAST_HEADER *)lParam;
        switch (pHdr->dbcd_devicetype) {
        case DBT_DEVTYP_PORT:
            pPortA = (PDEV_BROADCAST_PORT_A)lParam;
            iStr = strlen(pPortA->dbcp_name);
            iSize = FIELD_OFFSET(DEV_BROADCAST_PORT_W, dbcp_name) + sizeof(WCHAR)*(iStr+1);
            pPortW = UserLocalAlloc(0, iSize);
            if (pPortW == NULL)
                return 0;
            RtlCopyMemory(pPortW, pPortA, sizeof(DEV_BROADCAST_PORT_A));
            lpStr = pPortW->dbcp_name;
            if (iStr) {
                MBToWCS(pPortA->dbcp_name, -1, &lpStr, iStr, FALSE);
                lpStr[iStr] = 0;
            } else {
                lpStr[0] = 0;
            }
            pPortW->dbcp_size = iSize;
            lParam = (LPARAM)pPortW;
            bAnsi = FALSE;
            break;

        case DBT_DEVTYP_DEVICEINTERFACE:
            pInterfaceA = (PDEV_BROADCAST_DEVICEINTERFACE_A)lParam;
            iStr = strlen(pInterfaceA->dbcc_name);
            iSize = FIELD_OFFSET(DEV_BROADCAST_DEVICEINTERFACE_W, dbcc_name) + sizeof(WCHAR)*(iStr+1);
            pInterfaceW = UserLocalAlloc(0, iSize);
            if (pInterfaceW == NULL)
                return 0;
            RtlCopyMemory(pInterfaceW, pInterfaceA, sizeof(DEV_BROADCAST_DEVICEINTERFACE_A));
            lpStr = pInterfaceW->dbcc_name;
            if (iStr) {
                MBToWCS(pInterfaceA->dbcc_name, -1, &lpStr, iStr, FALSE);
                lpStr[iStr] = 0;
            } else {
                lpStr[0] = 0;
            }
            pInterfaceW->dbcc_size = iSize;
            lParam = (LPARAM)pInterfaceW;
            bAnsi = FALSE;
            break;

        case DBT_DEVTYP_HANDLE:
            pHandleA = (PDEV_BROADCAST_HANDLE)lParam;
            bAnsi = FALSE;
            if ((wParam != DBT_CUSTOMEVENT) || (pHandleA->dbch_nameoffset < 0)) break;
            iStr = strlen(pHandleA->dbch_data+pHandleA->dbch_nameoffset);
        /*
         * Calculate size of new structure with UNICODE string instead of Ansi string
         */

            iSize = FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_data)+ pHandleA->dbch_nameoffset + sizeof(WCHAR)*(iStr+1);
            /*
             * Just in case there were an odd number of bytes in the non-text data
             */
            if (iSize & 1) iSize++;
            pHandleW = UserLocalAlloc(0, iSize);
            if (pHandleW == NULL)
                return 0;
            RtlCopyMemory(pHandleW, pHandleA, FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_data)+ pHandleA->dbch_nameoffset);

            /*
             * Make sure this is even for the UNICODE string.
             */

            if (pHandleW->dbch_nameoffset & 1) pHandleW->dbch_nameoffset++;

            lpStr = (LPWSTR)(pHandleW->dbch_data+pHandleW->dbch_nameoffset);
            if (iStr) {
                MBToWCS(pHandleA->dbch_data+pHandleA->dbch_nameoffset, -1,
                        &lpStr, iStr, FALSE);
            }
                lpStr[iStr] = 0;
            pHandleW->dbch_size = iSize;
            lParam = (LPARAM)pHandleW;

            break;
        }

shipit:
        retval = (DWORD)NtUserMessageCall(
                hwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);

    if (pPortW) UserLocalFree(pPortW);
    if (pInterfaceW) UserLocalFree(pInterfaceW);
    if (pHandleW) UserLocalFree(pHandleW);

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

MESSAGECALL(fnIMECONTROL)
{
    PVOID pvData = NULL;
    LPARAM lData = lParam;

    BEGINCALL()

        /*
         * The server always expects the characters to be unicode so
         * if this was generated from an ANSI routine convert it to Unicode
         */
        if (bAnsi) {
            switch (wParam) {
                case IMC_GETCOMPOSITIONFONT:
                case IMC_GETSOFTKBDFONT:
                case IMC_SETCOMPOSITIONFONT:
                    pvData = UserLocalAlloc(0, sizeof(LOGFONTW));
                    if (pvData == NULL)
                        MSGERROR();

                    if (wParam == IMC_SETCOMPOSITIONFONT) {
                        // Later, we do A/W conversion based on thread hkl/CP.
                        CopyLogFontAtoW((PLOGFONTW)pvData, (PLOGFONTA)lParam);
                    }

                    lData = (LPARAM)pvData;
                    break;

                case IMC_SETSOFTKBDDATA:
                    {
                        PSOFTKBDDATA pSoftKbdData;
                        PWORD pCodeA;
                        PWSTR pCodeW;
                        CHAR  ch[3];
                        DWORD cbSize;
                        UINT  uCount, i;

                        uCount = ((PSOFTKBDDATA)lParam)->uCount;

                        cbSize = FIELD_OFFSET(SOFTKBDDATA, wCode[0])
                               + uCount * sizeof(WORD) * 256;

                        pvData = UserLocalAlloc(0, cbSize);
                        if (pvData == NULL)
                            MSGERROR();

                        pSoftKbdData = (PSOFTKBDDATA)pvData;

                        pSoftKbdData->uCount = uCount;

                        ch[2] = (CHAR)'\0';

                        pCodeA = &((PSOFTKBDDATA)lParam)->wCode[0][0];
                        pCodeW = &pSoftKbdData->wCode[0][0];

                        i = uCount * 256;

                        while (i--) {
                            if (HIBYTE(*pCodeA)) {
                                ch[0] = (CHAR)HIBYTE(*pCodeA);
                                ch[1] = (CHAR)LOBYTE(*pCodeA);
                            } else {
                                ch[0] = (CHAR)LOBYTE(*pCodeA);
                                ch[1] = (CHAR)'\0';
                            }
                            MBToWCSEx(THREAD_CODEPAGE(), (LPSTR)&ch, -1, &pCodeW, 1, FALSE);
                            pCodeA++; pCodeW++;
                        }

                        lData = (LPARAM)pvData;
                    }
                    break;

                default:
                    break;
            }
        }

        retval = (DWORD)NtUserMessageCall(
                hwnd,
                msg,
                wParam,
                lData,
                xParam,
                xpfnProc,
                bAnsi);

        if (bAnsi) {
            switch (wParam) {
                case IMC_GETCOMPOSITIONFONT:
                case IMC_GETSOFTKBDFONT:
                    CopyLogFontWtoA((PLOGFONTA)lParam, (PLOGFONTW)pvData);
                    break;

                default:
                    break;
            }
        }

        if (pvData != NULL)
            UserLocalFree(pvData);

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

DWORD CalcCharacterPositionAtoW(
    DWORD dwCharPosA,
    LPSTR lpszCharStr,
    DWORD dwCodePage)
{
    DWORD dwCharPosW = 0;

    while (dwCharPosA != 0) {
        if (IsDBCSLeadByteEx(dwCodePage, *lpszCharStr)) {
            if (dwCharPosA >= 2) {
                dwCharPosA -= 2;
            }
            else {
                dwCharPosA--;
            }
            lpszCharStr += 2;
        }
        else {
            dwCharPosA--;
            lpszCharStr++;
        }
        dwCharPosW++;
    }

    return dwCharPosW;
}

int UnicodeToMultiByteSize(DWORD dwCodePage, LPCWSTR pwstr)
{
    char dummy[2], *lpszDummy = dummy;
    return WCSToMBEx((WORD)dwCodePage, pwstr, 1, &lpszDummy, sizeof(WCHAR), FALSE);
}

DWORD CalcCharacterPositionWtoA(
    DWORD dwCharPosW,
    LPWSTR lpwszCharStr,
    DWORD  dwCodePage)
{
    DWORD dwCharPosA = 0;
    ULONG MultiByteSize;

    while (dwCharPosW != 0) {
        MultiByteSize = UnicodeToMultiByteSize(dwCodePage, lpwszCharStr);
        if (MultiByteSize == 2) {
            dwCharPosA += 2;
        }
        else {
            dwCharPosA++;
        }
        dwCharPosW--;
        lpwszCharStr++;
    }

    return dwCharPosA;
}

#ifdef LATER
DWORD WINAPI ImmGetReconvertTotalSize(DWORD dwSize, REQ_CALLER eCaller, BOOL bAnsiTarget)
{
    if (dwSize < sizeof(RECONVERTSTRING)) {
        return 0;
    }
    if (bAnsiTarget) {
        dwSize -= sizeof(RECONVERTSTRING);
        if (eCaller == FROM_IME) {
            dwSize /= 2;
        } else {
            dwSize *= 2;
        }
        dwSize += sizeof(RECONVERTSTRING);
    }
    return dwSize;
}


FUNCLOG4(LOG_GENERAL, DWORD, WINAPI, ImmReconversionWorker, LPRECONVERTSTRING, lpRecTo, LPRECONVERTSTRING, lpRecFrom, BOOL, bToAnsi, DWORD, dwCodePage)
DWORD WINAPI ImmReconversionWorker(
        LPRECONVERTSTRING lpRecTo,
        LPRECONVERTSTRING lpRecFrom,
        BOOL bToAnsi,
        DWORD dwCodePage)
{
    INT i;
    DWORD dwSize = 0;

    UserAssert(lpRecTo);
    UserAssert(lpRecFrom);

    if (lpRecFrom->dwVersion != 0 || lpRecTo->dwVersion != 0) {
        RIPMSG0(RIP_WARNING, "ImmReconversionWorker: dwVersion in lpRecTo or lpRecFrom is incorrect.");
        return 0;
    }
    // Note:
    // In any IME related structures, use the following principal.
    // 1) xxxStrOffset is an actual offset, i.e. byte count.
    // 2) xxxStrLen is a number of characters, i.e. TCHAR count.
    //
    // CalcCharacterPositionXtoY() takes TCHAR count so that we
    // need to adjust xxxStrOffset if it's being converted. But you
    // should be careful, because the actual position of the string
    // is always at something like (LPBYTE)lpStruc + lpStruc->dwStrOffset.
    //
    if (bToAnsi) {
        // Convert W to A
        lpRecTo->dwStrOffset = sizeof *lpRecTo;
        i = WideCharToMultiByte(dwCodePage,
                                (DWORD)0,
                                (LPWSTR)((LPSTR)lpRecFrom + lpRecFrom->dwStrOffset), // src
                                (INT)lpRecFrom->dwStrLen,
                                (LPSTR)lpRecTo + lpRecTo->dwStrOffset,  // dest
                                (INT)lpRecFrom->dwStrLen * DBCS_CHARSIZE,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpRecTo->dwCompStrOffset =
            CalcCharacterPositionWtoA(lpRecFrom->dwCompStrOffset / sizeof(WCHAR),
                                      (LPWSTR)((LPBYTE)lpRecFrom + lpRecFrom->dwStrOffset),
                                      dwCodePage)
                            * sizeof(CHAR);

        lpRecTo->dwCompStrLen =
            (CalcCharacterPositionWtoA(lpRecFrom->dwCompStrOffset / sizeof(WCHAR) +
                                      lpRecFrom->dwCompStrLen,
                                      (LPWSTR)((LPBYTE)lpRecFrom + lpRecFrom->dwStrOffset),
                                      dwCodePage)
                            * sizeof(CHAR))
            - lpRecTo->dwCompStrOffset;

        lpRecTo->dwTargetStrOffset =
            CalcCharacterPositionWtoA(lpRecFrom->dwTargetStrOffset / sizeof(WCHAR),
                                      (LPWSTR)((LPBYTE)lpRecFrom +
                                                lpRecFrom->dwStrOffset),
                                      dwCodePage)
                            * sizeof(CHAR);

        lpRecTo->dwTargetStrLen =
            (CalcCharacterPositionWtoA(lpRecFrom->dwTargetStrOffset / sizeof(WCHAR) +
                                      lpRecFrom->dwTargetStrLen,
                                      (LPWSTR)((LPBYTE)lpRecFrom + lpRecFrom->dwStrOffset),
                                       dwCodePage)
                            * sizeof(CHAR))
            - lpRecTo->dwTargetStrOffset;

        ((LPSTR)lpRecTo)[lpRecTo->dwStrOffset + i] = '\0';
        lpRecTo->dwStrLen = i * sizeof(CHAR);

        dwSize = sizeof(RECONVERTSTRING) + ((i + 1) * sizeof(CHAR));

    } else {

        // AtoW
        lpRecTo->dwStrOffset = sizeof *lpRecTo;
        i = MultiByteToWideChar(dwCodePage,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,  // src
                                (INT)lpRecFrom->dwStrLen,
                                (LPWSTR)((LPSTR)lpRecTo + lpRecTo->dwStrOffset), // dest
                                (INT)lpRecFrom->dwStrLen);

        lpRecTo->dwCompStrOffset =
            CalcCharacterPositionAtoW(lpRecFrom->dwCompStrOffset,
                                      (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,
                                      dwCodePage) * sizeof(WCHAR);

        lpRecTo->dwCompStrLen =
            ((CalcCharacterPositionAtoW(lpRecFrom->dwCompStrOffset +
                                       lpRecFrom->dwCompStrLen,
                                       (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,
                                        dwCodePage)  * sizeof(WCHAR))
            - lpRecTo->dwCompStrOffset) / sizeof(WCHAR);

        lpRecTo->dwTargetStrOffset =
            CalcCharacterPositionAtoW(lpRecFrom->dwTargetStrOffset,
                                      (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,
                                      dwCodePage) * sizeof(WCHAR);

        lpRecTo->dwTargetStrLen =
            ((CalcCharacterPositionAtoW(lpRecFrom->dwTargetStrOffset +
                                       lpRecFrom->dwTargetStrLen,
                                       (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,
                                       dwCodePage)  * sizeof(WCHAR))
            - lpRecTo->dwTargetStrOffset) / sizeof(WCHAR);

        lpRecTo->dwStrLen = i;  // Length is TCHAR count.
        if (lpRecTo->dwSize >= (DWORD)(lpRecTo->dwStrOffset + (i + 1)* sizeof(WCHAR))) {
            LPWSTR lpW = (LPWSTR)((LPSTR)lpRecTo + lpRecTo->dwStrOffset);
            lpW[i] = L'\0';
        }
        dwSize = sizeof(RECONVERTSTRING) + ((i + 1) * sizeof(WCHAR));
    }
    return dwSize;
}

#define GETCOMPOSITIONSTRING(hImc, index, buf, buflen) \
            (bAnsi ? fpImmGetCompositionStringA : fpImmGetCompositionStringW)((hImc), (index), (buf), (buflen))

MESSAGECALL(fnIMEREQUEST)
{
    PVOID pvData = NULL;
    LPARAM lData = lParam;

    BEGINCALL()

        if (!IS_IME_ENABLED()) {
            // If IME is not enabled, save time.
            MSGERROR();
        }

        /*
         * The server always expects the characters to be unicode so
         * if this was generated from an ANSI routine convert it to Unicode
         */
        if (wParam == IMR_QUERYCHARPOSITION) {
            //
            // Store the UNICODE character count in PrivateIMECHARPOSITION.
            //
            // No need to save the original dwCharPos, since dwCharPositionA/W are not
            // overwritten in the kernel.
            //
            if (bAnsi) {
                ((LPIMECHARPOSITION)lParam)->dwCharPos = ((LPPrivateIMECHARPOSITION)lParam)->dwCharPositionW;
            }
        }
        else if (bAnsi) {
            switch (wParam) {
            case IMR_COMPOSITIONFONT:
                pvData = UserLocalAlloc(0, sizeof(LOGFONTW));
                if (pvData == NULL)
                    MSGERROR();
                lData = (LPARAM)pvData;
                break;

            case IMR_CONFIRMRECONVERTSTRING:
            case IMR_RECONVERTSTRING:
            case IMR_DOCUMENTFEED:
                if ((LPVOID)lParam != NULL) {
                    // IME wants not only the buffer size but the real reconversion information
                    DWORD dwSize = ImmGetReconvertTotalSize(((LPRECONVERTSTRING)lParam)->dwSize, FROM_IME, FALSE);
                    LPRECONVERTSTRING lpReconv;

                    pvData = UserLocalAlloc(0, dwSize + sizeof(WCHAR));
                    if (pvData == NULL) {
                        RIPMSG0(RIP_WARNING, "fnIMEREQUEST: failed to allocate a buffer for reconversion.");
                        MSGERROR();
                    }
                    lpReconv = (LPRECONVERTSTRING)pvData;
                    // setup the information in the allocated structure
                    lpReconv->dwVersion = 0;
                    lpReconv->dwSize = dwSize;

                    //
                    // if it's confirmation message, we need to translate the contents
                    //
                    if (wParam == IMR_CONFIRMRECONVERTSTRING) {
                        ImmReconversionWorker(lpReconv, (LPRECONVERTSTRING)lParam, FALSE, CP_ACP);
                    }
                }
                break;

            default:
                break;
            }
        }

        retval = (DWORD)NtUserMessageCall(
                hwnd,
                msg,
                wParam,
                lData,
                xParam,
                xpfnProc,
                bAnsi);

        if (bAnsi) {
            switch (wParam) {
            case IMR_COMPOSITIONFONT:
                if (retval) {
                    CopyLogFontWtoA((PLOGFONTA)lParam, (PLOGFONTW)pvData);
                }
                break;

            case IMR_QUERYCHARPOSITION:
                ((LPIMECHARPOSITION)lParam)->dwCharPos = ((LPPrivateIMECHARPOSITION)lParam)->dwCharPositionA;
                break;

            case IMR_RECONVERTSTRING:
            case IMR_DOCUMENTFEED:
                //
                // Note: by definition, we don't need back-conversion for IMR_CONFIRMRECONVERTSTRING
                //
                if (retval) {
                    // IME wants the buffer size
                    retval = ImmGetReconvertTotalSize((DWORD)retval, FROM_APP, FALSE);
                    if (retval < sizeof(RECONVERTSTRING)) {
                        RIPMSG2(RIP_WARNING, "WM_IME_REQUEST(%x): return value from application %d is invalid.", wParam, retval);
                        retval = 0;
                    } else if (lParam) {
                        // We need to perform the A/W conversion of the contents
                        if (!ImmReconversionWorker((LPRECONVERTSTRING)lParam, (LPRECONVERTSTRING)pvData, TRUE, CP_ACP)) {
                            MSGERROR();
                        }
                    }
                }
                break;
            }
        }


    ERRORTRAP(0);

    if (pvData != NULL)
        UserLocalFree(pvData);

    ENDCALL(DWORD);
}
#endif

MESSAGECALL(fnEMGETSEL)
{
    PWND pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    BEGINCALL()

        retval = (DWORD)NtUserMessageCall(
                hwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);

        //
        // temp for our beta...
        //
        // !!! THIS CODE SHOULD BE IN KERNEL MODE !!!
        //
        // to reduce user <-> kernel mode transition...
        //
        if (bAnsi != ((TestWF(pwnd, WFANSIPROC)) ? TRUE : FALSE)) {
            ULONG  cchTextLength;
            LONG   lOriginalLengthW;
            LONG   lOriginalLengthL;
            LONG   wParamLocal;
            LONG   lParamLocal;

            if (wParam) {
                lOriginalLengthW = *(LONG *)wParam;
            } else {
                lOriginalLengthW = (LONG)(LOWORD(retval));
            }

            if (lParam) {
                lOriginalLengthL = *(LONG *)lParam;
            } else {
                lOriginalLengthL = (LONG)(HIWORD(retval));
            }

            cchTextLength = (DWORD)NtUserMessageCall(
                           hwnd,
                           WM_GETTEXTLENGTH,
                           (WPARAM)0,
                           (LPARAM)0,
                           xParam,
                           xpfnProc,
                           bAnsi);

            if (cchTextLength) {
                PVOID pvString;
                ULONG cbTextLength;

                cchTextLength++;
                if (!bAnsi) {
                    cbTextLength = cchTextLength * sizeof(WCHAR);
                } else {
                    cbTextLength = cchTextLength;
                }

                pvString = UserLocalAlloc(0,cbTextLength);

                if (pvString) {

                    retval = (DWORD)NtUserMessageCall(
                            hwnd,
                            WM_GETTEXT,
                            cchTextLength,
                            (LPARAM)pvString,
                            xParam,
                            xpfnProc,
                            bAnsi);

                    if (retval) {
                        if (bAnsi) {
                            /*
                             * ansiString/unicodeLenght -> ansiLength
                             */
                            CalcAnsiStringLengthA(pvString, lOriginalLengthW, &wParamLocal)
                            CalcAnsiStringLengthA(pvString, lOriginalLengthL, &lParamLocal);
                        } else {
                            /*
                             * unicodeString/ansiLenght -> unicodeLength
                             */
                            CalcUnicodeStringLengthW(pvString, lOriginalLengthW, &wParamLocal);
                            CalcUnicodeStringLengthW(pvString, lOriginalLengthL, &lParamLocal);
                        }

                        retval = (DWORD)(((lParamLocal) << 16) | ((wParamLocal) & 0x0000FFFF));

                        if (wParam) {
                            *(LONG *)wParam = wParamLocal;
                        }

                        if (lParam) {
                            *(LONG *)lParam = lParamLocal;
                        }

                    } else {
                        UserLocalFree(pvString);
                        MSGERROR();
                    }

                    UserLocalFree(pvString);

                } else
                    MSGERROR();
            } else
                MSGERROR();
        }

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

MESSAGECALL(fnEMSETSEL)
{
    PWND pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    BEGINCALL()

        //
        // temp for our beta...
        //
        // !!! THIS CODE SHOULD BE IN KERNEL MODE !!!
        //
        // to reduce user <-> kernel mode transition...
        //
        if (bAnsi != ((TestWF(pwnd, WFANSIPROC)) ? TRUE : FALSE)) {
            if (((LONG)wParam <= 0) && ((LONG)lParam <=0)) {
                //
                // if (wParam == 0 or wParam == -1)
                //               and
                //    (lParam == 0 or lParam == -1)
                //
                // In this case, we don't need to convert the value...
                //
            } else {
                ULONG  cchTextLength;
                LONG   lOriginalLengthW = (LONG)wParam;
                LONG   lOriginalLengthL = (LONG)lParam;

                cchTextLength = (DWORD)NtUserMessageCall(
                               hwnd,
                               WM_GETTEXTLENGTH,
                               (WPARAM)0,
                               (LPARAM)0,
                               xParam,
                               xpfnProc,
                               bAnsi);

                if (cchTextLength) {
                    PVOID pvString;
                    ULONG cbTextLength;

                    cchTextLength++;
                    if (!bAnsi) {
                        cbTextLength = cchTextLength * sizeof(WCHAR);
                    } else {
                        cbTextLength = cchTextLength;
                    }

                    pvString = UserLocalAlloc(0,cbTextLength);

                    if (pvString) {

                        retval = (DWORD)NtUserMessageCall(
                                hwnd,
                                WM_GETTEXT,
                                cchTextLength,
                                (LPARAM)pvString,
                                xParam,
                                xpfnProc,
                                bAnsi);

                        if (retval) {
                            if ((LONG)retval < lOriginalLengthW) {
                                lOriginalLengthW = (LONG)retval;
                            }
                            if ((LONG)retval < lOriginalLengthL) {
                                lOriginalLengthL = (LONG)retval;
                            }
                            if (bAnsi) {
                                if (lOriginalLengthW > 0) {
                                    CalcUnicodeStringLengthA(pvString, lOriginalLengthW, &wParam);
                                }
                                if(lOriginalLengthL > 0) {
                                    CalcUnicodeStringLengthA(pvString, lOriginalLengthL, &lParam);
                                }
                            } else {
                                if (lOriginalLengthW > 0) {
                                    CalcAnsiStringLengthW(pvString, lOriginalLengthW, &wParam);
                                }
                                if(lOriginalLengthL > 0) {
                                    CalcAnsiStringLengthW(pvString, lOriginalLengthL, &lParam);
                                }
                            }
                        } else {
                            UserLocalFree(pvString);
                            MSGERROR();
                        }

                        UserLocalFree(pvString);

                    } else
                        MSGERROR();
                } else
                    MSGERROR();
            }
        }

        retval = (DWORD)NtUserMessageCall(
                hwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

MESSAGECALL(fnCBGETEDITSEL)
{
    PWND pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    BEGINCALL()

        retval = (DWORD)NtUserMessageCall(
                hwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);

        //
        // temp for our beta...
        //
        // !!! THIS CODE SHOULD BE IN KERNEL MODE !!!
        //
        // to reduce user <-> kernel mode transition...
        //
        if (bAnsi != ((TestWF(pwnd, WFANSIPROC)) ? TRUE : FALSE)) {
            ULONG  cchTextLength;
            LONG   lOriginalLengthW = *(LONG *)wParam;
            LONG   lOriginalLengthL = *(LONG *)lParam;
            LONG   wParamLocal;
            LONG   lParamLocal;

            if (wParam) {
                lOriginalLengthW = *(LONG *)wParam;
            } else {
                lOriginalLengthW = (LONG)(LOWORD(retval));
            }

            if (lParam) {
                lOriginalLengthL = *(LONG *)lParam;
            } else {
                lOriginalLengthL = (LONG)(HIWORD(retval));
            }

            cchTextLength = (DWORD)NtUserMessageCall(
                           hwnd,
                           WM_GETTEXTLENGTH,
                           (WPARAM)0,
                           (LPARAM)0,
                           xParam,
                           xpfnProc,
                           bAnsi);

            if (cchTextLength) {
                PVOID pvString;
                ULONG cbTextLength;

                cchTextLength++;
                if (!bAnsi) {
                    cbTextLength = cchTextLength * sizeof(WCHAR);
                } else {
                    cbTextLength = cchTextLength;
                }

                pvString = UserLocalAlloc(0,cbTextLength);

                if (pvString) {

                    retval = (DWORD)NtUserMessageCall(
                            hwnd,
                            WM_GETTEXT,
                            cchTextLength,
                            (LPARAM)pvString,
                            xParam,
                            xpfnProc,
                            bAnsi);

                    if (retval) {
                        if (bAnsi) {
                            /*
                             * ansiString/unicodeLenght -> ansiLength
                             */
                            CalcAnsiStringLengthA(pvString, lOriginalLengthW, &wParamLocal);
                            CalcAnsiStringLengthA(pvString, lOriginalLengthL, &lParamLocal);
                        } else {
                            /*
                             * unicodeString/ansiLenght -> unicodeLength
                             */
                            CalcUnicodeStringLengthW(pvString, lOriginalLengthW, &wParamLocal);
                            CalcUnicodeStringLengthW(pvString, lOriginalLengthL, &lParamLocal);
                        }

                        retval = (DWORD)(((lParamLocal) << 16) | ((wParamLocal) & 0x0000FFFF));

                        if (wParam) {
                            *(LONG *)wParam = wParamLocal;
                        }

                        if (lParam) {
                            *(LONG *)lParam = lParamLocal;
                        }

                    } else {
                        UserLocalFree(pvString);
                        MSGERROR();
                    }

                    UserLocalFree(pvString);

                } else
                    MSGERROR();
            } else
                MSGERROR();
        }

    ERRORTRAP(0);
    ENDCALL(DWORD);
}

LONG BroadcastSystemMessageWorker(
    DWORD dwFlags,
    LPDWORD lpdwRecipients,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    PBSMINFO pBSMInfo,
    BOOL fAnsi)
{
    DWORD  dwRecipients;

    /*
     * Prevent apps from setting hi 16 bits so we can use them internally.
     */
    if (message & RESERVED_MSG_BITS) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "invalid message (%x) for BroadcastSystemMessage\n", message);
        return(0);
    }

    if (dwFlags & ~BSF_VALID) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "invalid dwFlags (%x) for BroadcastSystemMessage\n", dwFlags);
        return(0);
    }

    if ((dwFlags & (BSF_RETURNHDESK | BSF_LUID)) && (pBSMInfo == NULL)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "invalid BSF_RETURNHDESK or BSF_LUID is set and pBSMInfo is NULL for BroadcastSystemMessageEx\n");
        return(0);
    }

    if ((pBSMInfo != NULL) && (pBSMInfo->cbSize != sizeof(BSMINFO))) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "invalid pBSMInfo->cbSize (%x) for BroadcastSystemMessageEx\n", pBSMInfo->cbSize);
        return(0);
    }
    //
    // Check if the message number is in the private message range.
    // If so, do not send it to Win4.0 windows.
    // (This is required because apps like SimCity broadcast a message
    // that has the value 0x500 and that confuses MsgSrvr's
    // MSGSRVR_NOTIFY handler.
    //
    if ((message >= WM_USER) && (message < 0xC000))
    {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "invalid message (%x) for BroadcastSystemMessage\n", message);
        return(0L);
    }

    if (dwFlags & BSF_FORCEIFHUNG)
        dwFlags |= BSF_NOHANG;

    //
    // If BSF_QUERY or message has a pointer, it can not be posted.
    //
    if (dwFlags & BSF_QUERY)
    {
#if DBG
        if (dwFlags & BSF_ASYNC)
        {
            RIPMSG0(RIP_ERROR, "BroadcastSystemMessage: Can't post queries\n");
        }
#endif

        dwFlags &= ~BSF_ASYNC;          // Strip the BSF_ASYNC flags.
    }

    if (dwFlags & BSF_ASYNC) {
        if (TESTSYNCONLYMESSAGE(message, wParam)) {
            RIPERR0(ERROR_MESSAGE_SYNC_ONLY, RIP_WARNING, "BroadcastSystemMessage: Can't post messages with pointers\n");
            dwFlags &= ~BSF_ASYNC;          // Strip the BSF_ASYNC flags.
        }
    }


    // Let us find out who the intended recipients are.
    if (lpdwRecipients != NULL)
        dwRecipients = *lpdwRecipients;
    else
        dwRecipients = BSM_ALLCOMPONENTS;

    // if they want all components, add the corresponding bits
    if ((dwRecipients & BSM_COMPONENTS) == BSM_ALLCOMPONENTS)
        dwRecipients |= (BSM_VXDS | BSM_NETDRIVER | BSM_INSTALLABLEDRIVERS |
                             BSM_APPLICATIONS);


    if (dwRecipients & ~BSM_VALID) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "invalid dwRecipients (%x) for BroadcastSystemMessage\n", dwRecipients);
        return(0);
    }

    //
    // Check if this is a WM_USERCHANGED message; If so, we want to reload
    // the per-user settings before anyone else sees this message.
    //
    // LATER -- FritzS
//    if (uiMessage == WM_USERCHANGED)
//        ReloadPerUserSettings();


    // Does this need to be sent to all apps?
    if (dwRecipients & BSM_APPLICATIONS)
    {
        BROADCASTSYSTEMMSGPARAMS bsmParams;
        LONG   lret;

        bsmParams.dwFlags = dwFlags;
        bsmParams.dwRecipients = dwRecipients;
        bsmParams.hwnd  = NULL;
        bsmParams.hdesk = NULL;
        if (dwFlags & BSF_LUID) {
            bsmParams.luid = pBSMInfo->luid;
        }

        lret = (LONG)CsSendMessage(GetDesktopWindow(), message, wParam, lParam,
            (ULONG_PTR)&bsmParams, FNID_SENDMESSAGEBSM, fAnsi);
        //
        // If the query was denied, then return who denied it.
        //
        if ((lret == 0) && (dwFlags & BSF_QUERY) && (pBSMInfo != NULL))
        {
            pBSMInfo->hwnd = bsmParams.hwnd;
            pBSMInfo->hdesk = bsmParams.hdesk;
        }
        return lret;
    }

    return -1;
}

HDEVNOTIFY
RegisterDeviceNotificationWorker(
    IN HANDLE hRecipient,
    IN LPVOID NotificationFilter,
    IN DWORD Flags,
    IN BOOL IsAnsi
    )
{
    HINSTANCE   hLib = NULL;
    FARPROC     fpRegisterNotification = NULL;
    PVOID       Context = NULL;
    HDEVNOTIFY  notifyHandle = NULL;
    CONFIGRET   Status = CR_SUCCESS;

    extern
    CONFIGRET
    CMP_RegisterNotification(IN  HANDLE   hRecipient,
                             IN  LPBYTE   NotificationFilter,
                             IN  DWORD    Flags,
                             OUT PVOID   *Context
                             );

    UNREFERENCED_PARAMETER(IsAnsi);

    try {
        //
        // load the config manager client dll and retrieve entry pts
        //
        hLib = LoadLibrary(TEXT("SETUPAPI.DLL"));
        if (hLib == NULL) {
            goto Clean0;  // use last error set by LoadLibrary
        }

        fpRegisterNotification = GetProcAddress(hLib, "CMP_RegisterNotification");
        if (fpRegisterNotification == NULL) {
            goto Clean0;    // use last error set by GetProcAddress
        }

        Status = (CONFIGRET)(fpRegisterNotification)(hRecipient,
                                        NotificationFilter,
                                        Flags,
                                        &Context);

        Clean0:
            ;

    } except(W32ExceptionHandler(FALSE, RIP_WARNING)) {
    }

    if (hLib != NULL) {
        FreeLibrary(hLib);
    }

    if (Status != CR_SUCCESS) {

        //
        //Something went wrong, map the CR errors to a
        //W32 style error code
        //
        switch (Status) {
            case CR_INVALID_POINTER:
                SetLastError (ERROR_INVALID_PARAMETER);
                break;
            case CR_INVALID_DATA:
                SetLastError (ERROR_INVALID_DATA);
                break;
            case CR_OUT_OF_MEMORY:
                SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                break;
            case CR_FAILURE:
            default:
                SetLastError (ERROR_SERVICE_SPECIFIC_ERROR);
                break;

        }
    }

    if ((Context != NULL) && ((ULONG_PTR)Context != -1)) {
        notifyHandle = (HDEVNOTIFY)Context;
    }

    return notifyHandle;
}


BOOL
UnregisterDeviceNotification(
    IN HDEVNOTIFY Handle
    )
{
    BOOL        status = TRUE;
    HINSTANCE   hLib = NULL;
    FARPROC     fpUnregisterNotification = NULL;
    CONFIGRET   crStatus = CR_SUCCESS;

    extern
    CONFIGRET
    CMP_UnregisterNotification(IN ULONG Context);

    try {
        //
        // load the config manager client dll and retrieve entry pts
        //
        hLib = LoadLibrary(TEXT("SETUPAPI.DLL"));
        if (hLib == NULL) {
            status = FALSE;
            goto Clean0;  // use last error set by LoadLibrary
        }

        fpUnregisterNotification = GetProcAddress(hLib, "CMP_UnregisterNotification");
        if (fpUnregisterNotification == NULL) {
            status = FALSE;
            goto Clean0;    // use last error set by GetProcAddress
        }

        crStatus = (CONFIGRET)(fpUnregisterNotification)((ULONG_PTR)Handle);

        if (crStatus != CR_SUCCESS) {
            status = FALSE;
            //
            //Something went wrong, map the CR errors to a
            //W32 style error code
            //
            switch (crStatus) {
                case CR_INVALID_POINTER:
                    SetLastError (ERROR_INVALID_PARAMETER);
                    break;
                case CR_INVALID_DATA:
                    SetLastError (ERROR_INVALID_DATA);
                    break;
                case CR_FAILURE:
                default:
                    SetLastError (ERROR_SERVICE_SPECIFIC_ERROR);
                    break;
            }
        }

        Clean0:
            ;

    } except(W32ExceptionHandler(FALSE, RIP_WARNING)) {
        status = FALSE;
    }

    if (hLib != NULL) {
        FreeLibrary(hLib);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\reason.c ===
/****************************** Module Header ******************************\
* Module Name: reason.c
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* This module contains the (private) APIs for the shutdown reason stuff.
*
* History:
* ??-??-???? HughLeat     Wrote it as part of msgina.dll
* 11-15-2000 JasonSch     Moved from msgina.dll to its new, temporary home in
*                         user32.dll. Ultimately this code should live in
*                         advapi32.dll, but that's contingent upon LoadString
*                         being moved to ntdll.dll.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <regstr.h>

REASON_INITIALISER g_rgReasonInits[] = {
    { UCLEANUI | SHTDN_REASON_MAJOR_HARDWARE | SHTDN_REASON_MINOR_MAINTENANCE,          IDS_REASON_UNPLANNED_HARDWARE_MAINTENANCE_TITLE,        IDS_REASON_HARDWARE_MAINTENANCE_DESCRIPTION },
    { PCLEANUI | SHTDN_REASON_MAJOR_HARDWARE | SHTDN_REASON_MINOR_MAINTENANCE,          IDS_REASON_PLANNED_HARDWARE_MAINTENANCE_TITLE,          IDS_REASON_HARDWARE_MAINTENANCE_DESCRIPTION },
    { UCLEANUI | SHTDN_REASON_MAJOR_HARDWARE | SHTDN_REASON_MINOR_INSTALLATION,         IDS_REASON_UNPLANNED_HARDWARE_INSTALLATION_TITLE,       IDS_REASON_HARDWARE_INSTALLATION_DESCRIPTION },
    { PCLEANUI | SHTDN_REASON_MAJOR_HARDWARE | SHTDN_REASON_MINOR_INSTALLATION,         IDS_REASON_PLANNED_HARDWARE_INSTALLATION_TITLE,         IDS_REASON_HARDWARE_INSTALLATION_DESCRIPTION },
    
    { UCLEANUI | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_UPGRADE,       IDS_REASON_UNPLANNED_OPERATINGSYSTEM_UPGRADE_TITLE,     IDS_REASON_OPERATINGSYSTEM_UPGRADE_DESCRIPTION },
    { PCLEANUI | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_UPGRADE,       IDS_REASON_PLANNED_OPERATINGSYSTEM_UPGRADE_TITLE,       IDS_REASON_OPERATINGSYSTEM_UPGRADE_DESCRIPTION },
    { UCLEANUI | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG,      IDS_REASON_UNPLANNED_OPERATINGSYSTEM_RECONFIG_TITLE,    IDS_REASON_OPERATINGSYSTEM_RECONFIG_DESCRIPTION },
    { PCLEANUI | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG,      IDS_REASON_PLANNED_OPERATINGSYSTEM_RECONFIG_TITLE,      IDS_REASON_OPERATINGSYSTEM_RECONFIG_DESCRIPTION },

    { UCLEANUI | SHTDN_REASON_MAJOR_APPLICATION | SHTDN_REASON_MINOR_HUNG,              IDS_REASON_APPLICATION_HUNG_TITLE,                      IDS_REASON_APPLICATION_HUNG_DESCRIPTION },
    { UCLEANUI | SHTDN_REASON_MAJOR_APPLICATION | SHTDN_REASON_MINOR_UNSTABLE,          IDS_REASON_APPLICATION_UNSTABLE_TITLE,                  IDS_REASON_APPLICATION_UNSTABLE_DESCRIPTION },
    { UCLEANUI | SHTDN_REASON_MAJOR_APPLICATION | SHTDN_REASON_MINOR_MAINTENANCE,       IDS_REASON_APPLICATION_MAINTENANCE_TITLE,               IDS_REASON_APPLICATION_MAINTENANCE_DESCRIPTION },
    { PCLEANUI | SHTDN_REASON_MAJOR_APPLICATION | SHTDN_REASON_MINOR_MAINTENANCE,       IDS_REASON_APPLICATION_PM_TITLE,                        IDS_REASON_APPLICATION_PM_DESCRIPTION },

    { UCLEANUI | SHTDN_REASON_FLAG_COMMENT_REQUIRED | SHTDN_REASON_MAJOR_OTHER | SHTDN_REASON_MINOR_OTHER,          IDS_REASON_UNPLANNED_OTHER_TITLE,                       IDS_REASON_OTHER_DESCRIPTION },
    { PCLEANUI | SHTDN_REASON_FLAG_COMMENT_REQUIRED | SHTDN_REASON_MAJOR_OTHER | SHTDN_REASON_MINOR_OTHER,          IDS_REASON_PLANNED_OTHER_TITLE,                         IDS_REASON_OTHER_DESCRIPTION },

    { UDIRTYUI | SHTDN_REASON_MAJOR_SYSTEM | SHTDN_REASON_MINOR_BLUESCREEN,             IDS_REASON_SYSTEMFAILURE_BLUESCREEN_TITLE,              IDS_REASON_SYSTEMFAILURE_BLUESCREEN_DESCRIPTION },
    { UDIRTYUI | SHTDN_REASON_MAJOR_POWER | SHTDN_REASON_MINOR_CORDUNPLUGGED,           IDS_REASON_POWERFAILURE_CORDUNPLUGGED_TITLE,            IDS_REASON_POWERFAILURE_CORDUNPLUGGED_DESCRIPTION },
    { UDIRTYUI | SHTDN_REASON_MAJOR_POWER | SHTDN_REASON_MINOR_ENVIRONMENT,             IDS_REASON_POWERFAILURE_ENVIRONMENT_TITLE,              IDS_REASON_POWERFAILURE_ENVIRONMENT_DESCRIPTION },
    { UDIRTYUI | SHTDN_REASON_MAJOR_OTHER | SHTDN_REASON_MINOR_HUNG,                    IDS_REASON_OTHERFAILURE_HUNG_TITLE,                     IDS_REASON_OTHERFAILURE_HUNG_DESCRIPTION },
    { UDIRTYUI | SHTDN_REASON_FLAG_COMMENT_REQUIRED | SHTDN_REASON_MAJOR_OTHER | SHTDN_REASON_MINOR_OTHER,          IDS_REASON_OTHERFAILURE_TITLE,                       IDS_REASON_OTHER_DESCRIPTION },

};

BOOL ReasonCodeNeedsComment(DWORD dwCode)
{
    return (dwCode & SHTDN_REASON_FLAG_COMMENT_REQUIRED) != 0;
}

BOOL ReasonCodeNeedsBugID(DWORD dwCode)
{
    return (dwCode & SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED) != 0;
}

/*
 * Here is the regular expression used to parse the user defined reason codes
 * in the registry:
 *
 *  S -> 's' | 'S'          { Set For Clean  UI }
 *  D -> 'd' | 'D'          { Set For  Dirty UI }
 *  P -> 'p' | 'P'          { Set Planned  }
 *  C -> 'c' | 'C'          { Set Comment Required }
 *  B -> 'b' | 'B'          { Set Problem Id Required in Dirty Mode }
 *
 *  WS -> ( ' ' | '\t' | '\n' )*
 *
 *  Delim -> ';' | ',' | ':'
 *  Flag -> S | D | P | C | B
 *  Flags -> ( WS . Flag . WS )*
 *  
 *  Digit -> '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | ''8' | '9'
 *  Num -> WS . Digit* . WS
 *  Maj -> Num          { Set Major Code }
 *  Min -> Num          { Set Minor Code }
 *    
 *  ValidSentence -> Flags . Delim . Maj . Delim . Min . Delim |
 *            Flags . Delim . Maj . Delim . Min |
 *            Flags . Delim . Maj |
 *            Flags
 *
 *  All initial states are false for each flag and 0 for minor and major reason
 *  codes.
 *  If neither S nor D are specified (which makes it inaccessible) then both
 * are specified.
 */  
BOOL
ParseReasonCode(
    PWCHAR lpString,
    LPDWORD lpdwCode)
{
    WCHAR c;
    UINT major = 0, minor = 0;

    *lpdwCode = SHTDN_REASON_FLAG_USER_DEFINED;

    // Read the flags part.
    c = *lpString;
    while( c != 0 && c != L';' && c != L':' && c != L',' ) {
        switch( c ) {
        case L'P' : case L'p' :
            *lpdwCode |= SHTDN_REASON_FLAG_PLANNED;
            break;
        case L'C' : case L'c' :
            *lpdwCode |= SHTDN_REASON_FLAG_COMMENT_REQUIRED;
            break;
        case L'S' : case L's' :
            *lpdwCode |= SHTDN_REASON_FLAG_CLEAN_UI;
            break;
        case L'D' : case L'd' :
            *lpdwCode |= SHTDN_REASON_FLAG_DIRTY_UI;
            break;
        case L'B' : case L'b' :
            *lpdwCode |= SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED;
            break;
        case L' ' : case L'\t' : case L'\n' :
            break;
        default : return FALSE;
        }
        c = *++lpString;
    }

    // If neither CLEAN_UI nor DIRTY_UI are set, set both.  Otherwise this
    // reason is useless.
    if ((*lpdwCode & ( SHTDN_REASON_FLAG_CLEAN_UI | SHTDN_REASON_FLAG_DIRTY_UI)) == 0) {
        *lpdwCode |= (SHTDN_REASON_FLAG_CLEAN_UI | SHTDN_REASON_FLAG_DIRTY_UI);
    }

    if (c == 0) {
        // Major Reason = NONE
        // Minor Reason = NONE
        return TRUE;
    }

    c = *++lpString; // Skip delimiter.
    // Eat WS and padded 0s
    while(c == L' ' || c == L'\t' || c == L'\n' || c == L'0') {
        c = *++lpString;
    }

    // Parse major reason
    while(c != 0 && c != L';' && c != L':' && c != L',' && c != L' ' && c != L'\t' && c != L'\n') {
        if (c < L'0' || c > L'9') {
            return FALSE;
        }
        major = major * 10 + c - L'0';
        c = *++lpString;
    }

    if (major > 0xff) {
        return FALSE;
    }
    *lpdwCode |= major << 16;

    // Eat WS 
    while(c == L' ' || c == L'\t' || c == L'\n') {
        c = *++lpString;
    }

    if (c == 0) {
        // Minor Reason = NONE
        return TRUE;
    }

    // Should have a delimiter
    if (c != L';' && c != L':' && c != L',') {
        return FALSE;
    }

    c = *++lpString; // Skip delimiter.
    // Eat WS and padded 0s
    while(c == L' ' || c == L'\t' || c == L'\n' || c == L'0') {
        c = *++lpString;
    }

    // Parse minor reason
    while(c != 0 && c != L';' && c != L':' && c != L',' && c != L' ' && c != L'\t' && c != L'\n') {
        if (c < L'0' || c > L'9') {
            return FALSE;
        }
        minor = minor * 10 + c - L'0';
        c = *++lpString;
    }

    if (minor > 0xffff) {
        return FALSE;
    }
    *lpdwCode |= minor;

    // Skip white stuff to the end
    while(c == L' ' || c == L'\t' || c == L'\n' || c == L';' || c == L':' || c == L',') {
        c = *++lpString;
    }
    
    // This char had better be the null char
    return (c == 0);
}

int
__cdecl
CompareReasons(
    CONST VOID *A,
    CONST VOID *B)
{
    REASON *a = *(REASON **)A;
    REASON *b = *(REASON **)B;

    // Shift the planned bit out and put it back in the bottom.
    // Ignore all ui bits.
    DWORD dwA = ((a->dwCode & SHTDN_REASON_VALID_BIT_MASK ) << 1) + !!(a->dwCode & SHTDN_REASON_FLAG_PLANNED);
    DWORD dwB = ((b->dwCode & SHTDN_REASON_VALID_BIT_MASK ) << 1) + !!(b->dwCode & SHTDN_REASON_FLAG_PLANNED);

    if (dwA < dwB) {
        return -1;
    } else if (dwA == dwB) {
        return 0;
    } else {
        return 1;
    }
}

BOOL
SortReasonArray(
    REASONDATA *pdata)
{
    qsort(pdata->rgReasons, pdata->cReasons, sizeof(REASON *), CompareReasons);
    return TRUE;
}

BOOL
AppendReason(
    REASONDATA *pdata,
    REASON *reason)
{
    int i;

    // Insert the new reason into the list.
    if (pdata->cReasons < pdata->cReasonCapacity) {
        pdata->rgReasons[pdata->cReasons++] = reason;
    } else {
        // Need to expand the list.
        REASON **temp_list = (REASON **)UserLocalAlloc(0, sizeof(REASON *) * pdata->cReasonCapacity * 2);
        if (temp_list == NULL) {
            return FALSE;
        }

        for (i = 0; i < pdata->cReasons; ++i) {
            temp_list[i] = pdata->rgReasons[i];
        }
        temp_list[pdata->cReasons++] = reason;
        pdata->cReasonCapacity *= 2;

        if (pdata->rgReasons ) {
            UserLocalFree(pdata->rgReasons);
        }
        pdata->rgReasons = temp_list;
    }

    return TRUE;
}

BOOL
LoadReasonStrings(
    int idStringName,
    int idStringDesc,
    REASON *reason)
{
    BOOL fSuccess = TRUE;

    fSuccess &= (LoadStringW(hmodUser, idStringName, reason->szName, ARRAYSIZE(reason->szName)) != 0);
    fSuccess &= (LoadStringW(hmodUser, idStringDesc, reason->szDesc, ARRAYSIZE(reason->szDesc)) != 0);

    return fSuccess;
}

BOOL
BuildPredefinedReasonArray(
    REASONDATA *pdata,
    BOOL forCleanUI,
    BOOL forDirtyUI)
{
    int i;
    DWORD code; 

    if (!forCleanUI && !forDirtyUI) {
        return TRUE;
    }

    for (i = 0; i < ARRAYSIZE(g_rgReasonInits); ++i) {
        REASON *temp_reason = NULL;

        code = g_rgReasonInits[ i ].dwCode;
        if ((forCleanUI && (code & SHTDN_REASON_FLAG_CLEAN_UI)) ||
            (forDirtyUI && (code & SHTDN_REASON_FLAG_DIRTY_UI))) {

            temp_reason = (REASON *)UserLocalAlloc(0, sizeof(REASON));
            if (temp_reason == NULL) {
                return FALSE;
            }

            temp_reason->dwCode = g_rgReasonInits[i].dwCode;
            if (!LoadReasonStrings(g_rgReasonInits[i].dwNameId, g_rgReasonInits[i].dwDescId, temp_reason)) {
                UserLocalFree(temp_reason);
                return FALSE;
            }
    
            if (!AppendReason(pdata, temp_reason)) {
                UserLocalFree(temp_reason);
                return FALSE;
            }
        }
    }

    return TRUE;
}

BOOL
BuildUserDefinedReasonArray(
    REASONDATA *pdata,
    HKEY hReliabilityKey,
    BOOL forCleanUI,
    BOOL forDirtyUI
    )
{
    UINT i;
    HKEY hKey = NULL;
    DWORD num_values;
    DWORD max_value_len;
    DWORD rc;

    if (!forCleanUI && !forDirtyUI) {
        return TRUE;
    }

    // Open the user defined key.
    rc = RegCreateKeyEx(hReliabilityKey,
                               TEXT("UserDefined"),
                               0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                               NULL, &hKey, NULL);
    if (rc != ERROR_SUCCESS) {
        goto fail;
    }

    rc = RegQueryInfoKeyW(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &num_values, NULL, &max_value_len, NULL, NULL);
    if (rc != ERROR_SUCCESS) {
        goto fail;
    }

    // Read the user defined reasons.
    for (i = 0; i < num_values; ++i) {
        WCHAR name_buffer[ 256 ]; // No value or key can have a longer name.
        DWORD name_buffer_len = 256;
        DWORD type;
        WCHAR data[MAX_REASON_NAME_LEN + MAX_REASON_DESC_LEN + 3]; // Space for name, desc and three null chars.
        WCHAR *buf = data;
        DWORD data_len = (MAX_REASON_NAME_LEN + MAX_REASON_DESC_LEN + 3) * sizeof(WCHAR);
        DWORD code;
        REASON *temp_reason = NULL;

        rc = RegEnumValueW(hKey, i, name_buffer, &name_buffer_len, NULL, &type, (LPBYTE)data, &data_len);
        if (rc != ERROR_SUCCESS && rc != ERROR_MORE_DATA) {
            continue;
        }
        if (type != REG_MULTI_SZ) {
            continue; // Not a multi_string - ignore it.
        }

        // Parse the code.
        if (!ParseReasonCode(name_buffer, &code)) {
            continue;
        }
        if ((forCleanUI && (code & SHTDN_REASON_FLAG_CLEAN_UI) != 0) ||
           (forDirtyUI && (code & SHTDN_REASON_FLAG_DIRTY_UI) != 0)) {
            if (rc == ERROR_MORE_DATA) { // Multi string too long.
                // Allocate a buffer of the right size.
                buf = (WCHAR *)UserLocalAlloc(0, data_len);
                if (buf == 0) {
                    goto fail;
                }

                rc = (DWORD)RegEnumValueW(hKey, i, name_buffer, &name_buffer_len, NULL, &type, (LPBYTE)buf, &data_len);
                if (rc != ERROR_SUCCESS) {
                    UserLocalFree(buf);
                    continue;
                }
            }

            // Allocate a new reason
            temp_reason = (REASON *)UserLocalAlloc(LPTR, sizeof(REASON));
            if (temp_reason == NULL) {
                if (buf != data) {
                    UserLocalFree(buf);
                }
                goto fail;
            }

            // Copy the stuff over.
            temp_reason->dwCode = code;
            lstrcpynW(temp_reason->szName, buf, MAX_REASON_NAME_LEN);
            temp_reason->szName[MAX_REASON_NAME_LEN] = 0;
            lstrcpynW(temp_reason->szDesc, buf + wcslen(buf) + 1, MAX_REASON_DESC_LEN);
            temp_reason->szDesc[MAX_REASON_DESC_LEN] = 0;

            if (buf != data) {
                UserLocalFree(buf);
            }

            if (!AppendReason(pdata, temp_reason)) {
                UserLocalFree(temp_reason);
                goto fail;
            }
        }
    }

    RegCloseKey(hKey);
    return TRUE;

fail :
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    return FALSE;
}

BOOL
BuildReasonArray(
    REASONDATA *pdata,
    BOOL forCleanUI,
    BOOL forDirtyUI)
{
    HKEY hReliabilityKey;
    DWORD ignore_predefined_reasons = FALSE;
    DWORD value_size = sizeof(DWORD);
    DWORD rc;
    HANDLE hEventLog = RegisterEventSourceW(NULL, L"USER32");

    if (hEventLog == NULL) {
        return FALSE;
    }

    pdata->rgReasons = (REASON **)UserLocalAlloc(0, sizeof(REASON *) * ARRAYSIZE(g_rgReasonInits));
    if (pdata->rgReasons == NULL) {
        return FALSE;
    }
    pdata->cReasonCapacity = ARRAYSIZE(g_rgReasonInits);
    pdata->cReasons = 0;
    
    // Open the reliability key.
    rc = RegCreateKeyExW(HKEY_LOCAL_MACHINE, 
                        REGSTR_PATH_RELIABILITY, 
                        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, 
                        &hReliabilityKey, NULL);

    if (rc == ERROR_SUCCESS) {
        rc = RegQueryValueEx(hReliabilityKey, REGSTR_VAL_SHUTDOWN_IGNORE_PREDEFINED, NULL, NULL, (UCHAR *)&ignore_predefined_reasons, &value_size);
        if (rc != ERROR_SUCCESS) {
            ignore_predefined_reasons = FALSE;
        }
        
        if (!BuildUserDefinedReasonArray(pdata, hReliabilityKey, forCleanUI, forDirtyUI) || pdata->cReasons == 0) {
            ignore_predefined_reasons = FALSE;
        }

        RegCloseKey(hReliabilityKey);
    }

    if (!ignore_predefined_reasons) {
        if (!BuildPredefinedReasonArray(pdata, forCleanUI, forDirtyUI)) {
            return FALSE;
        }
    }

    return SortReasonArray(pdata);
}

VOID
DestroyReasons(
    REASONDATA *pdata)
{
    int i;

    if (pdata->rgReasons != 0) {
        for (i = 0; i < pdata->cReasons; ++i) {
            UserLocalFree( pdata->rgReasons[i]);
        }
        UserLocalFree(pdata->rgReasons);
        pdata->rgReasons = 0;
    }
}

/*
 * Get the title from the reason code.
 * Returns FALSE on error, TRUE otherwise.
 *
 * If the reason code cannot be found, then it fills the title with a default
 * string.
 */
BOOL
GetReasonTitleFromReasonCode(
    DWORD code,
    WCHAR *lpTitle,
    DWORD dwTitleLen)
{
    REASONDATA data;
    int i;

    if (lpTitle == NULL || dwTitleLen == 0) {
        return FALSE;
    }

    // Load the reasons.
    if (BuildReasonArray(&data, TRUE, TRUE) == FALSE) {
        return FALSE;
    }

    // Try to find the reason.
    for (i = 0; i < data.cReasons; ++i) {
        if ((code & SHTDN_REASON_VALID_BIT_MASK) ==
            (data.rgReasons[i]->dwCode & SHTDN_REASON_VALID_BIT_MASK)) {
            lstrcpynW(lpTitle, data.rgReasons[i]->szName, dwTitleLen);
            DestroyReasons(&data);
            return TRUE;
        }
    }

    // Reason not found.  Load the default string and return that.
    DestroyReasons(&data);

    return (LoadStringW(hmodUser, IDS_REASON_DEFAULT_TITLE, lpTitle, dwTitleLen) != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\reader.c ===
/****************************** Module Header ******************************\
* Module Name: reader.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Implements support reader-mode routines for auto-scrolling and panning.
*
* History:
* 31-Jan-1997   vadimg    created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define TIMERID 1

__inline FReader2Dim(PREADERINFO prdr)
{
    return ((prdr->dwFlags & (RDRMODE_HORZ | RDRMODE_VERT)) ==
            (RDRMODE_HORZ | RDRMODE_VERT));
}
__inline FReaderVert(PREADERINFO prdr)
{
    return (prdr->dwFlags & RDRMODE_VERT);
}
__inline FReaderHorz(PREADERINFO prdr)
{
    return (prdr->dwFlags & RDRMODE_HORZ);
}
__inline FReaderDiag(PREADERINFO prdr)
{
    return (prdr->dwFlags & RDRMODE_DIAG);
}

/***************************************************************************\
* ReaderSetCursor
*
\***************************************************************************/

void ReaderSetCursor(PREADERINFO prdr, UINT uCursor)
{
    if (prdr->uCursor != uCursor) {
        NtUserSetCursor(LoadCursor(NULL, MAKEINTRESOURCE(uCursor)));
        prdr->uCursor = uCursor;
    }
}

/***************************************************************************\
* ReaderMouseMove
*
* Calculate dx and dy based on the flags passed in.  Provide visual
* feedback for the reader mode by setting the correct cursor.
*
* 2-Feb-1997   vadimg   created
\***************************************************************************/

void ReaderMouseMove(PWND pwnd, PREADERINFO prdr, LPARAM lParam)
{
    int dx = 0, dy = 0;
    LPRECT prc = KPRECT_TO_PRECT(&pwnd->rcWindow);
    UINT uCursor;
    POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};

    _ClientToScreen(pwnd, &pt);

    if (FReaderVert(prdr)) {
        if (pt.y < prc->top) {
            dy = pt.y - prc->top;
        } else if (pt.y > prc->bottom) {
            dy = pt.y - prc->bottom;
        }
    }

    if (FReaderHorz(prdr)) {
        if (pt.x < prc->left) {
            dx = pt.x - prc->left;
        } else if (pt.x > prc->right) {
            dx = pt.x - prc->right;
        }
    }

    if (FReader2Dim(prdr)) {
        if (dx == 0 && dy == 0) {
            ReaderSetCursor(prdr, OCR_RDR2DIM);
            goto Exit;
        }
        if (!FReaderDiag(prdr)) {
            if (prdr->dy != 0) {
                if (abs(dx) > abs(prdr->dy)) {
                    dy = 0;
                } else {
                    dx = 0;
                }
            } else if (prdr->dx != 0) {
                if (abs(dy) > abs(prdr->dx)) {
                    dx = 0;
                } else {
                    dy = 0;
                }
            } else if (dy != 0) {
                dx = 0;
            }
        }
    } else if (FReaderVert(prdr) && dy == 0) {
        ReaderSetCursor(prdr, OCR_RDRVERT);
        goto Exit;
    } else if (FReaderHorz(prdr) && dx == 0) {
        ReaderSetCursor(prdr, OCR_RDRHORZ);
        goto Exit;
    }

    if (dx == 0) {
        uCursor = (dy > 0) ? OCR_RDRSOUTH : OCR_RDRNORTH;
    } else if (dx > 0) {
        if (dy == 0) {
            uCursor = OCR_RDREAST;
        } else {
            uCursor = (dy > 0) ? OCR_RDRSOUTHEAST : OCR_RDRNORTHEAST;
        }
    } else if (dx < 0) {
        if (dy == 0) {
            uCursor = OCR_RDRWEST;
        } else {
            uCursor = (dy > 0) ? OCR_RDRSOUTHWEST : OCR_RDRNORTHWEST;
        }
    }

    ReaderSetCursor(prdr, uCursor);

Exit:
    prdr->dx = dx;
    prdr->dy = dy;
}

/***************************************************************************\
* ReaderFeedback
*
* 2-Feb-1997   vadimg   created
\***************************************************************************/

void ReaderFeedback(PWND pwnd, PREADERINFO prdr)
{
    if (prdr->dx == 0 && prdr->dy == 0)
        return;

    if (prdr->pfnReaderModeProc(prdr->lParam, RDRCODE_SCROLL,
            prdr->dx, prdr->dy) == 0) {
        NtUserDestroyWindow(PtoH(pwnd));
    }
}

/***************************************************************************\
* ReaderWndProc
*
* 31-Jan-1997   vadimg   created
\***************************************************************************/

LRESULT CALLBACK ReaderWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HDC hdc, hdcMem;
    HPEN hpen, hpenOld;
    HBRUSH hbrOld;
    HRGN hrgn;
    RECT rc;
    POINT pt;
    int nBitmap, cx, cy;
    PREADERINFO prdr;
    PWND pwnd;
    LPCREATESTRUCT pcs;
    PREADERMODE prdrm;
    BITMAP bmp;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return 0;

    prdr = ((PREADERWND)pwnd)->prdr;

    switch (msg) {
    case WM_TIMER:
        ReaderFeedback(pwnd, prdr);
        return 0;

    case WM_MOUSEWHEEL:
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_XBUTTONUP:
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_XBUTTONDOWN:
    case WM_KEYDOWN:
        ReleaseCapture();
        return 0;

    case WM_MOUSEMOVE:
        ReaderMouseMove(pwnd, prdr, lParam);
        return 0;

    case WM_MBUTTONUP:
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        GetClientRect(hwnd, &rc);
        if (!PtInRect(&rc, pt)) {
            ReleaseCapture();
        }
        return 0;

    case WM_CAPTURECHANGED:
        NtUserDestroyWindow(hwnd);
        return 0;

    case WM_NCDESTROY:
        NtUserKillTimer(hwnd, TIMERID);

        prdr->pfnReaderModeProc(prdr->lParam, RDRCODE_END, 0, 0);

        if (prdr->hbm != NULL) {
            DeleteObject(prdr->hbm);
        }
        UserLocalFree(prdr);
        return 0;

    case WM_CREATE:
        if ((prdr = UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(READERINFO))) == NULL)
            return -1;

        pcs = (LPCREATESTRUCT)lParam;
        prdrm = (PREADERMODE)pcs->lpCreateParams;
        RtlCopyMemory(prdr, prdrm, sizeof(READERMODE));
        SetWindowLongPtr(hwnd, 0, (LONG_PTR)prdr);

        if (prdr->pfnReaderModeProc == NULL) {
            return -1;
        }

        if (FReader2Dim(prdr)) {
            nBitmap = OBM_RDR2DIM;
        } else if (FReaderVert(prdr)) {
            nBitmap = OBM_RDRVERT;
        } else if (FReaderHorz(prdr)) {
            nBitmap = OBM_RDRHORZ;
        } else {
            return -1;
        }

        SetWindowLong(hwnd, GWL_EXSTYLE, WS_EX_TOOLWINDOW);
        SetWindowLong(hwnd, GWL_STYLE, WS_POPUP | WS_CLIPSIBLINGS);

        prdr->hbm = LoadBitmap(hmodUser, MAKEINTRESOURCE(nBitmap));
        if (prdr->hbm == NULL ||
                GetObject(prdr->hbm, sizeof(BITMAP), &bmp) == 0) {
            return -1;
        }

        if (prdr->pfnReaderModeProc(prdr->lParam, RDRCODE_START, 0, 0) == 0) {
            return -1;
        }

        prdr->dxBmp = bmp.bmWidth;
        prdr->dyBmp = bmp.bmHeight;

        cx = bmp.bmWidth + 1;
        cy = bmp.bmHeight + 1;

        GetCursorPos(&pt);
        pt.x -= cx/2;
        pt.y -= cy/2;

        if ((hrgn = CreateEllipticRgn(0, 0, cx, cy)) != NULL) {
            SetWindowRgn(hwnd, hrgn, FALSE);
        }

        NtUserSetWindowPos(hwnd, HWND_TOPMOST, pt.x, pt.y, cx, cy,
                SWP_SHOWWINDOW | SWP_NOACTIVATE);

        NtUserSetCapture(hwnd);
        NtUserSetFocus(hwnd);
        NtUserSetTimer(hwnd, TIMERID, 10, NULL);
        return 0;

    case WM_ERASEBKGND:
        hdc = (HDC)wParam;

        if ((hdcMem = CreateCompatibleDC(hdc)) == NULL)
            return FALSE;

        SelectObject(hdcMem, prdr->hbm);
        hpen = CreatePen(PS_SOLID, 1, RGB(0, 0, 0));
        hpenOld = (HPEN)SelectObject(hdc, hpen);
        hbrOld = (HBRUSH)SelectObject(hdc, GetStockObject(NULL_BRUSH));

        BitBlt(hdc, 0, 0, prdr->dxBmp, prdr->dyBmp, hdcMem, 0, 0, SRCCOPY);
        Ellipse(hdc, 0, 0, prdr->dxBmp, prdr->dyBmp);

        SelectObject(hdc, hpenOld);
        SelectObject(hdc, hbrOld);

        DeleteObject(hpen);
        DeleteObject(hdcMem);
        return TRUE;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

/***************************************************************************\
* ReaderProcInternal
*
\***************************************************************************/

LONG ReaderProcInternal(LPARAM lParam, int nCode, int dx, int dy)
{
    DWORD dwDelay;
    UINT uMsg, uCode;
    int n, nAbs;

    if (nCode != RDRCODE_SCROLL)
        return TRUE;

    if (dy != 0) {
        uCode = SB_LINEUP;
        uMsg = WM_VSCROLL;
        n = dy;
    } else {
        uCode = SB_LINELEFT;
        uMsg = WM_HSCROLL;
        n = dx;
    }

    nAbs = abs(n);
    if (nAbs >= 120) {
        uCode += 2;
        dwDelay = 0;
    } else {
        dwDelay = 1000 - (nAbs / 2) * 15;
    }

    if (n > 0) {
        uCode += 1;
    }

    SendMessage((HWND)lParam, uMsg, MAKELONG(uCode, dwDelay), 0);
    UpdateWindow((HWND)lParam);
    return TRUE;
}

/***************************************************************************\
* EnterReaderMode
*
\***************************************************************************/

#define READERCLASS L"User32_ReaderMode"
ATOM gatomReaderMode = 0;

BOOL EnterReaderMode(PREADERMODE prdrm)
{
    WNDCLASSEX wce;

    if (GetCapture() != NULL)
        return FALSE;

    if (gatomReaderMode == 0) {
        wce.cbSize = sizeof(wce);
        wce.style = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;
        wce.lpfnWndProc = ReaderWndProc;
        wce.cbClsExtra = 0;
        wce.cbWndExtra = sizeof(PREADERINFO);
        wce.hInstance = hmodUser;
        wce.hIcon = NULL;
        wce.hCursor = LoadCursor(NULL, IDC_ARROW);
        wce.hbrBackground = GetStockObject(WHITE_BRUSH);
        wce.lpszMenuName = NULL;
        wce.lpszClassName = READERCLASS;
        wce.hIconSm = NULL;

        if ((gatomReaderMode = RegisterClassExWOWW(&wce, NULL, FNID_DDE_BIT, 0)) == 0) {
            RIPMSG0(RIP_WARNING, "EnterReaderMode: failed to register ReaderMode");
            return 0;
        }
    }

    return (_CreateWindowEx(0, READERCLASS, NULL, 0, 0, 0, 0, 0,
            NULL, NULL, hmodUser, (PVOID)prdrm, 0) != NULL);
}

/***************************************************************************\
* FScrollEnabled
*
\***************************************************************************/

BOOL FScrollEnabled(PWND pwnd, BOOL fVert)
{
    PSBINFO pw;
    int nFlags;

    if (!TestWF(pwnd, fVert ? WFVPRESENT : WFHPRESENT))
        return FALSE;

    if ((pw = (PSBINFO)REBASEALWAYS(pwnd, pSBInfo)) == NULL)
        return FALSE;

    nFlags = fVert ? (pw->WSBflags >> 2) : pw->WSBflags;

    if ((nFlags & SB_DISABLE_MASK) == SB_DISABLE_MASK)
        return FALSE;

    return TRUE;
}

/***************************************************************************\
* EnterReaderModeHelper
*
\***************************************************************************/

BOOL EnterReaderModeHelper(HWND hwnd)
{
    PWND pwnd = ValidateHwnd(hwnd);
    READERMODE rdrm;

    rdrm.cbSize = sizeof(READERMODE);
    rdrm.pfnReaderModeProc = ReaderProcInternal;
    rdrm.lParam = (LPARAM)hwnd;
    rdrm.dwFlags = 0;

    if (FScrollEnabled(pwnd, TRUE)) {
        rdrm.dwFlags |= RDRMODE_VERT;
    }
    if (FScrollEnabled(pwnd, FALSE)) {
        rdrm.dwFlags |= RDRMODE_HORZ;
    }

    return EnterReaderMode(&rdrm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\rtlinit.c ===
/****************************** Module Header ******************************\
* Module Name: rtlinit.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the init code for the USERRTL.DLL.  When the DLL is
* dynlinked its initialization procedure (UserRtlDllInitialize) is called by
* the loader.
*
* History:
* 14-Jan-1991 mikeke
\***************************************************************************/

#define MOVE_TO_RTL

#include "precomp.h"
#pragma hdrstop
#include "ntimage.h"


/**************************************************************************\
* RtlCaptureAnsiString
*
* Converts a NULL-terminated ANSI string into a counted
* unicode string.
*
* 03-22-95 JimA         Created.
\**************************************************************************/

BOOL RtlCaptureAnsiString(
    PIN_STRING pstr,
    LPCSTR psz,
    BOOL fForceAlloc)
{
    int cbSrc;
    int cbDst;

    pstr->fAllocated = FALSE;
    if (psz) {
        cbSrc = strlen(psz) + 1;
        if (cbSrc > MAXUSHORT) {
            RIPMSG0(RIP_WARNING, "String too long for standard string");
            return FALSE;
        }

        /*
         * If the allocation is forced or if the string is
         * too long to fit in the TEB, allocate a buffer.
         * Otherwise, store the result in the TEB.
         */
        if (fForceAlloc ||
                cbSrc > (STATIC_UNICODE_BUFFER_LENGTH / sizeof(WCHAR))) {
            pstr->strCapture.Buffer = RtlAllocateHeap(pUserHeap,
                    0, cbSrc * sizeof(WCHAR));
            if (pstr->strCapture.Buffer == NULL)
                return FALSE;
            pstr->fAllocated = TRUE;
            pstr->pstr = &pstr->strCapture;
            pstr->strCapture.MaximumLength = (USHORT)(cbSrc * sizeof(WCHAR));
        } else {
            pstr->pstr = &NtCurrentTeb()->StaticUnicodeString;
        }

        /*
         * Convert the string to Unicode
         */
        if (RtlMultiByteToUnicodeN(pstr->pstr->Buffer,
                (ULONG)pstr->pstr->MaximumLength, &cbDst,
                (LPSTR)psz, cbSrc)) {
            RIPMSG0(RIP_WARNING, "Unicode conversion failed");
            if (pstr->fAllocated) {
                RtlFreeHeap(pUserHeap, 0, pstr->strCapture.Buffer);
                pstr->fAllocated = FALSE;
            }
            return FALSE;
        }
        pstr->pstr->Length = (USHORT)cbDst - sizeof(WCHAR);
    } else {
        pstr->pstr = &pstr->strCapture;
        pstr->strCapture.Length = pstr->strCapture.MaximumLength = 0;
        pstr->strCapture.Buffer = NULL;
    }
    return TRUE;
}

/**************************************************************************\
* RtlCaptureLargeAnsiString
*
* Captures a large ANSI string in the same manner as
* RtlCaptureAnsiString.
*
* 03-22-95 JimA         Created.
\**************************************************************************/

BOOL RtlCaptureLargeAnsiString(
    PLARGE_IN_STRING plstr,
    LPCSTR psz,
    BOOL fForceAlloc)
{
    int cchSrc;
    UINT uLength;

    plstr->fAllocated = FALSE;
    plstr->strCapture.bAnsi = FALSE;
    plstr->pstr = &plstr->strCapture;

    if (psz) {
        cchSrc = strlen(psz) + 1;

        /*
         * If the allocation is forced or if the string is
         * too long to fit in the TEB, allocate a buffer.
         * Otherwise, store the result in the TEB.
         */
        if (fForceAlloc || cchSrc > STATIC_UNICODE_BUFFER_LENGTH) {
            plstr->strCapture.Buffer = RtlAllocateHeap(pUserHeap,
                    0, cchSrc * sizeof(WCHAR));
            if (plstr->strCapture.Buffer == NULL)
                return FALSE;
            plstr->fAllocated = TRUE;
            plstr->strCapture.MaximumLength = cchSrc * sizeof(WCHAR);
        } else {
            plstr->strCapture.Buffer = NtCurrentTeb()->StaticUnicodeBuffer;
            plstr->strCapture.MaximumLength =
                    (UINT)(STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR));
        }

        /*
         * Convert the string to Unicode
         */
        if (RtlMultiByteToUnicodeN(KPWSTR_TO_PWSTR(plstr->pstr->Buffer),
                plstr->pstr->MaximumLength, &uLength,
                (LPSTR)psz, cchSrc)) {
            RIPMSG0(RIP_WARNING, "Unicode conversion failed");
            if (plstr->fAllocated) {
                RtlFreeHeap(pUserHeap, 0, KPWSTR_TO_PWSTR(plstr->strCapture.Buffer));
                plstr->fAllocated = FALSE;
            }
            return FALSE;
        }
        plstr->pstr->Length = uLength - sizeof(WCHAR);
    } else {
        plstr->strCapture.Length = plstr->strCapture.MaximumLength = 0;
        plstr->strCapture.Buffer = NULL;
    }
    return TRUE;
}

//++
//
// PVOID
// AllocateFromZone(
//     IN PZONE_HEADER Zone
//     )
//
// Routine Description:
//
//     This routine removes an entry from the zone and returns a pointer to it.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage from which the
//         entry is to be allocated.
//
// Return Value:
//
//     The function value is a pointer to the storage allocated from the zone.
//
/***************************************************************************\
\***************************************************************************/

#define AllocateFromZone(Zone) \
    (PVOID)((Zone)->FreeList.Next); \
    if ( (Zone)->FreeList.Next ) (Zone)->FreeList.Next = (Zone)->FreeList.Next->Next


//++
//
// PVOID
// FreeToZone(
//     IN PZONE_HEADER Zone,
//     IN PVOID Block
//     )
//
// Routine Description:
//
//     This routine places the specified block of storage back onto the free
//     list in the specified zone.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage to which the
//         entry is to be inserted.
//
//     Block - Pointer to the block of storage to be freed back to the zone.
//
// Return Value:
//
//     Pointer to previous block of storage that was at the head of the free
//         list.  NULL implies the zone went from no available free blocks to
//         at least one free block.
//
/***************************************************************************\
\***************************************************************************/

#define FreeToZone(Zone,Block)                                    \
    ( ((PSINGLE_LIST_ENTRY)(Block))->Next = (Zone)->FreeList.Next,  \
      (Zone)->FreeList.Next = ((PSINGLE_LIST_ENTRY)(Block)),        \
      ((PSINGLE_LIST_ENTRY)(Block))->Next                           \
    )

/***************************************************************************\
* InitLookaside
*
* Initializes the lookaside list. This improves control locality
* by keeping control entries in a single page
*
* 05-04-95 JimA         Created.
\***************************************************************************/

NTSTATUS
InitLookaside(
    PLOOKASIDE pla,
    DWORD cbEntry,
    DWORD cEntries)
{
    ULONG i;
    PCH p;
    ULONG BlockSize;
    PZONE_HEADER Zone;
    PVOID InitialSegment;
    ULONG InitialSegmentSize;

    InitialSegmentSize = (cEntries * cbEntry) + sizeof(ZONE_SEGMENT_HEADER);

    p = (PCH)UserLocalAlloc(0, InitialSegmentSize);

    if ( !p ) {
        return STATUS_NO_MEMORY;
        }

    RtlEnterCriticalSection(&gcsLookaside);

    //
    // If the lookaside list has already been initialized, we're done.
    //

    if (pla->LookasideBase != NULL && pla->EntrySize == cbEntry) {
        RtlLeaveCriticalSection(&gcsLookaside);
        UserLocalFree(p);
        return STATUS_SUCCESS;
    }

    pla->LookasideBase = (PVOID)p;
    pla->LookasideBounds = (PVOID)(p + InitialSegmentSize);
    pla->EntrySize = cbEntry;

    //
    // Using the ExZone-like code, slice up the page into QMSG's
    //

    Zone = &pla->LookasideZone;
    BlockSize = cbEntry;
    InitialSegment = pla->LookasideBase;

    Zone->BlockSize = BlockSize;

    Zone->SegmentList.Next = &((PZONE_SEGMENT_HEADER) InitialSegment)->SegmentList;
    ((PZONE_SEGMENT_HEADER) InitialSegment)->SegmentList.Next = NULL;
    ((PZONE_SEGMENT_HEADER) InitialSegment)->Reserved = NULL;

    Zone->FreeList.Next = NULL;

    p = (PCH)InitialSegment + sizeof(ZONE_SEGMENT_HEADER);

    for (i = sizeof(ZONE_SEGMENT_HEADER);
         i <= InitialSegmentSize - BlockSize;
         i += BlockSize
        ) {
        ((PSINGLE_LIST_ENTRY)p)->Next = Zone->FreeList.Next;
        Zone->FreeList.Next = (PSINGLE_LIST_ENTRY)p;
        p += BlockSize;
    }
    Zone->TotalSegmentSize = i;

    RtlLeaveCriticalSection(&gcsLookaside);

    return STATUS_SUCCESS;

}

/***************************************************************************\
* AllocLookasideEntry
*
* Allocates an entry from the lookaside list.
*
* 05-04-95 JimA         Created.
\***************************************************************************/

PVOID AllocLookasideEntry(
    PLOOKASIDE pla)
{
    PVOID pEntry;

    //
    // Attempt to get an entry from the zone. If this fails, then
    // LocalAlloc the entry
    //

    RtlEnterCriticalSection(&gcsLookaside);
    pEntry = AllocateFromZone(&pla->LookasideZone);
    RtlLeaveCriticalSection(&gcsLookaside);

    if ( !pEntry ) {

        /*
         * Allocate a local structure.
         */
#if DBG
        pla->AllocSlowCalls++;
#endif // DBG
        if ((pEntry = UserLocalAlloc(0, pla->EntrySize)) == NULL)
            return NULL;
        }
    RtlZeroMemory(pEntry, pla->EntrySize);
#if DBG
    pla->AllocCalls++;

    if (pla->AllocCalls - pla->DelCalls > pla->AllocHiWater ) {
        pla->AllocHiWater = pla->AllocCalls - pla->DelCalls;
        }
#endif // DBG

    return pEntry;
}

/***************************************************************************\
* FreeLookasideEntry
*
* Returns a qmsg to the lookaside buffer or free the memory.
*
* 05-04-95 JimA         Created.
\***************************************************************************/

void FreeLookasideEntry(
    PLOOKASIDE pla,
    PVOID pEntry)
{
#if DBG
    pla->DelCalls++;
#endif // DBG

    //
    // If the pEntry was from zone, then free to zone
    //
    if ( (PVOID)pEntry >= pla->LookasideBase && (PVOID)pEntry < pla->LookasideBounds ) {
        RtlEnterCriticalSection(&gcsLookaside);
        FreeToZone(&pla->LookasideZone,pEntry);
        RtlLeaveCriticalSection(&gcsLookaside);
    } else {
#if DBG
        pla->DelSlowCalls++;
#endif // DBG
        UserLocalFree(pEntry);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\random.c ===
/****************************** Module Header ******************************\
* Module Name: random.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This file contains global function pointers that are called trough to get
* to either a client or a server function depending on which side we are on
*
* History:
* 10-Nov-1993 MikeKe    Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
*
*
* History:
* 10-Nov-1993 MikeKe    Created
\***************************************************************************/

HBRUSH                      ghbrWhite = NULL;
HBRUSH                      ghbrBlack = NULL;

/***************************************************************************\
* GetSysColorBrush
*
* Retrieves the system-color-brush.
*
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, HBRUSH, WINAPI, GetSysColorBrush, int, nIndex)
HBRUSH WINAPI GetSysColorBrush(
    int nIndex)
{
    if ((nIndex < 0) || (nIndex >= COLOR_MAX))
        return NULL;

    return SYSHBRUSH(nIndex);
}

/***************************************************************************\
* SetSysColorTemp
*
* Sets the global system colors all at once.  Also remembers the old colors
* so they can be reset.
*
* Sets/Resets the color and brush arrays for user USER drawing.
* lpRGBs and lpBrushes are pointers to arrays paralleling the argbSystem and
* gpsi->hbrSystem arrays.  wCnt is a sanity check so that this does the "right"
* thing in a future windows version.  The current argbSystem and hbrSystem
* arrays are saved off, and a handle to those saved arrays is returned.
*
* To reset the arrays, pass in NULL for lpRGBs, NULL for lpBrushes, and the
* handle (from the first set) for wCnt.
*
* History:
* 18-Sep-1995   JohnC   Gave this miserable function a life
\***************************************************************************/

LPCOLORREF gpOriginalRGBs = NULL;
UINT       gcOriginalRGBs = 0;

WINUSERAPI HANDLE WINAPI SetSysColorsTemp(
    CONST COLORREF *lpRGBs,
    CONST HBRUSH   *lpBrushes,
    UINT_PTR       cBrushes)      // Count of brushes or handle
{
    UINT cbRGBSize;
    UINT i;
    UINT abElements[COLOR_MAX];

    /*
     * See if we are resetting the colors back to a saved state
     */
    if (lpRGBs == NULL) {

        /*
         * When restoring cBrushes is really a handle to the old global
         * handle.  Make sure that is true.  Also lpBrushes is unused
         */
        UNREFERENCED_PARAMETER(lpBrushes);
        UserAssert(lpBrushes == NULL);
        UserAssert(cBrushes == (ULONG_PTR)gpOriginalRGBs);

        if (gpOriginalRGBs == NULL) {
            RIPMSG0(RIP_ERROR, "SetSysColorsTemp: Can not restore if not saved");
            return NULL;
        }

        /*
         * reset the global Colors
         */
        UserAssert((sizeof(abElements)/sizeof(abElements[0])) >= gcOriginalRGBs);
        for (i = 0; i < gcOriginalRGBs; i++)
            abElements[i] = i;

        NtUserSetSysColors(gcOriginalRGBs, abElements, gpOriginalRGBs, 0);

        UserLocalFree(gpOriginalRGBs);

        gpOriginalRGBs = NULL;
        gcOriginalRGBs = 0;

        return (HANDLE)TRUE;
    }

    /*
     * Make sure we aren't trying to set too many colors
     * If we allow more then COLOR_MAX change the abElements array
     */
    if (cBrushes > COLOR_MAX) {
        RIPMSG1(RIP_ERROR, "SetSysColorsTemp: trying to set too many colors %lX", cBrushes);
        return NULL;
    }

    /*
     * If we have already a saved state then don't let them save it again
     */
    if (gpOriginalRGBs != NULL) {
        RIPMSG0(RIP_ERROR, "SetSysColorsTemp: temp colors already set");
        return NULL;
    }

    /*
     * If we are here then we must be setting the new temp colors
     *
     * First save the old colors
     */
    cbRGBSize = sizeof(COLORREF) * (UINT)cBrushes;

    UserAssert(sizeof(COLORREF) == sizeof(int));
    gpOriginalRGBs = UserLocalAlloc(HEAP_ZERO_MEMORY, cbRGBSize);

    if (gpOriginalRGBs == NULL) {
        RIPMSG0(RIP_WARNING, "SetSysColorsTemp: unable to alloc temp colors buffer");
        return NULL;
    }

    RtlCopyMemory(gpOriginalRGBs, gpsi->argbSystem, cbRGBSize);

    /*
     * Now set the new colors.
     */
    UserAssert( (sizeof(abElements)/sizeof(abElements[0])) >= cBrushes);

    for (i = 0; i < cBrushes; i++)
        abElements[i] = i;

    NtUserSetSysColors((UINT)cBrushes, abElements, lpRGBs, 0);

    gcOriginalRGBs = (UINT)cBrushes;

    return gpOriginalRGBs;
}

/***************************************************************************\
* TextAlloc
*
* History:
* 25-Oct-1990   MikeHar     Wrote.
* 09-Nov-1990   DarrinM     Fixed.
* 13-Jan-1992   GregoryW    Neutralized.
\***************************************************************************/

LPWSTR TextAlloc(
    LPCWSTR lpszSrc)
{
    LPWSTR pszT;
    DWORD  cbString;

    if (lpszSrc == NULL)
        return NULL;

    cbString = (wcslen(lpszSrc) + 1) * sizeof(WCHAR);

    if (pszT = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cbString)) {

        RtlCopyMemory(pszT, lpszSrc, cbString);
    }

    return pszT;
}

#if DBG
/***************************************************************************\
* CheckCurrentDesktop
*
* Ensure that the pointer is valid for the current desktop.
*
* History:
* 10-Apr-1995   JimA    Created.
\***************************************************************************/

VOID CheckCurrentDesktop(
    PVOID p)
{
    UserAssert(p >= GetClientInfo()->pDeskInfo->pvDesktopBase &&
               p < GetClientInfo()->pDeskInfo->pvDesktopLimit);
}
#endif


/***************************************************************************\
* SetLastErrorEx
*
* Sets the last error, ignoring dwtype.
\***************************************************************************/

FUNCLOGVOID2(LOG_GENERAL, WINAPI, SetLastErrorEx, DWORD, dwErrCode, DWORD, dwType)
VOID WINAPI SetLastErrorEx(
    DWORD dwErrCode,
    DWORD dwType
    )
{
    UNREFERENCED_PARAMETER(dwType);

    SetLastError(dwErrCode);
}

#if defined(_X86_)
/***************************************************************************\
* InitializeWin32EntryTable
*
* Initializes a Win32 entry table so our test apps will know which entry
* points to avoid. This should be removed before we ship.
\***************************************************************************/

static CONST PROC FunctionsToSkip[] = {
    NtUserWaitMessage,
    NtUserLockWorkStation,
};


FUNCLOG1(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, InitializeWin32EntryTable, PBOOLEAN, pbEntryTable)
UINT InitializeWin32EntryTable(
    PBOOLEAN pbEntryTable)
{
#if DBG
    // We'll only define this on free systems for now. Checked systems
    // will hit too many asserts.
    UNREFERENCED_PARAMETER(pbEntryTable);
    return 0;
#else
    UINT i;
    PBYTE pb;

    if (pbEntryTable) {
        for (i = 0; i < ARRAY_SIZE(FunctionsToSkip); i++) {
            pb = (PBYTE)FunctionsToSkip[i];
            pbEntryTable[*((WORD *)(pb+1)) - 0x1000] = TRUE;
        }

    }

    return gDispatchTableValues;
#endif
}
#endif
/***************************************************************************\
* GetLastInputInfo
*
* Retrieves information about the last input event
*
* 05/30/07  GerardoB    Created
\***************************************************************************/
BOOL GetLastInputInfo (PLASTINPUTINFO plii)
{
    VALIDATIONFNNAME(GetLastInputInfo);

    if (plii->cbSize != sizeof(LASTINPUTINFO)) {
        VALIDATIONFAIL(plii->cbSize);
    }

    plii->dwTime = gpsi->dwLastRITEventTickCount;

    return TRUE;
    VALIDATIONERROR(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\register.c ===
/****************************** Module Header ******************************\
* Module Name: register.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager - server registration module
*
* Created: 4/15/94 sanfords
*       to allow interoperability between DDEML16 and DDEML32
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * interoperable DDEML service registration is accomplished via the
 * two messages UM_REGISTER and UM_UNREGISTER. (WM_USER range)
 * wParam=gaApp,
 * lParam=src hwndListen, (for instance specific HSZ generation.)
 * These messages are sent and the sender is responsible for freeing
 * the gaApp.
 */


/*
 * Broadcast-sends the given message to all top-level windows of szClass
 * except to hwndSkip.
 */
VOID SendRegisterMessageToClass(
ATOM atomClass,
UINT msg,
GATOM ga,
HWND hwndFrom,
BOOL fPost)
{
    HWND hwnd;
    PWND pwnd;
    PCLS pcls;

    hwnd = GetWindow(GetDesktopWindow(), GW_CHILD);
    while (hwnd != NULL) {
        pwnd=ValidateHwndNoRip(hwnd);
        if (pwnd) {
            pcls = (PCLS)REBASEALWAYS(pwnd, pcls);
            if (pcls->atomClassName == atomClass) {
                IncGlobalAtomCount(ga); // receiver frees
                if (fPost) {
                    PostMessage(hwnd, msg, (WPARAM)ga, (LPARAM)hwndFrom);
                } else {
                    SendMessage(hwnd, msg, (WPARAM)ga, (LPARAM)hwndFrom);
                }
            }
        }
        hwnd = GetWindow(hwnd, GW_HWNDNEXT);
    }
}


/*
 * Broadcast-sends a UM_REGISTER or UM_UNREGISTER message to all DDEML16
 * and DDEML32 listening windows in the system except hwndListen.
 *
 * We post Registration messages to prevent DdeConnectList recursion
 * and send Unregistration messages to avoid invalid source window
 * errors.
 */
VOID RegisterService(
BOOL fRegister,
GATOM gaApp,
HWND hwndListen)
{
    CheckDDECritOut;

    /*
     * Send notification to each DDEML32 listening window.
     */
    SendRegisterMessageToClass(gpsi->atomSysClass[ICLS_DDEMLMOTHER], fRegister ? UM_REGISTER : UM_UNREGISTER,
            gaApp, hwndListen, (GetAppCompatFlags2(VERMAX) & GACF2_DDENOASYNCREG) ? FALSE: fRegister);
    /*
     * Send notification to each DDEML16 listening window.
     */
    SendRegisterMessageToClass(gpsi->atomSysClass[ICLS_DDEML16BIT], fRegister ? UM_REGISTER : UM_UNREGISTER,
            gaApp, hwndListen, (GetAppCompatFlags2(VERMAX) & GACF2_DDENOASYNCREG) ? FALSE : fRegister);
}




LRESULT ProcessRegistrationMessage(
HWND hwnd,
UINT msg,
WPARAM wParam,
LPARAM lParam)
{
    PCL_INSTANCE_INFO pcii;
    LRESULT lRet = 0;

    CheckDDECritOut;

    /*
     * wParam = GATOM of app
     * lParam = hwndListen of source - may be a WOW DDEML source unthunked.
     */
    lParam = (LPARAM)HMValidateHandleNoRip((HWND)lParam, TYPE_WINDOW);
    lParam = (LPARAM)PtoH((PVOID)lParam);

    if (lParam == 0) {
        return(0);
    }

    EnterDDECrit;

    pcii = (PCL_INSTANCE_INFO)GetWindowLongPtr(hwnd, GWLP_INSTANCE_INFO);
    if (pcii != NULL &&
            !((msg == UM_REGISTER) && (pcii->afCmd & CBF_SKIP_REGISTRATIONS)) &&
            !((msg == UM_UNREGISTER) && (pcii->afCmd & CBF_SKIP_UNREGISTRATIONS))) {

        LATOM la, lais;

        la = GlobalToLocalAtom((GATOM)wParam);
        lais = MakeInstSpecificAtom(la, (HWND)lParam);

        DoCallback(pcii,
                (WORD)((msg == UM_REGISTER) ? XTYP_REGISTER : XTYP_UNREGISTER),
                0,
                (HCONV)0L,
                (HSZ)NORMAL_HSZ_FROM_LATOM(la),
                INST_SPECIFIC_HSZ_FROM_LATOM(lais),
                (HDDEDATA)0L,
                0L,
                0L);

        DeleteAtom(la);
        DeleteAtom(lais);
        lRet = 1;
    }

    GlobalDeleteAtom((ATOM)wParam);  // receiver frees
    LeaveDDECrit;
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\sbapi.c ===
/**************************** Module Header ********************************\
* Module Name:
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Scroll bar public APIs
*
* History:
*   08-16-95 FritzS
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


WINUSERAPI
BOOL
WINAPI
EnableScrollBar(
    IN HWND hWnd,
    IN UINT wSBflags,
    IN UINT wArrows)
{
    BOOL ret;

    BEGIN_USERAPIHOOK()
        ret = guah.pfnEnableScrollBar(hWnd, wSBflags, wArrows);
    END_USERAPIHOOK()

    return ret;
}


BOOL RealEnableScrollBar(
    IN HWND hWnd,
    IN UINT wSBflags,
    IN UINT wArrows)
{
    return NtUserEnableScrollBar(hWnd, wSBflags, wArrows);
}



/***************************************************************************\
* SetScrollPos
*
* History:
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, int, DUMMYCALLINGTYPE, SetScrollPos, HWND, hwnd, int, code, int, pos, BOOL, fRedraw)
int SetScrollPos(
    HWND hwnd,
    int code,
    int pos,
    BOOL fRedraw)
{
    SCROLLINFO si;

    si.fMask = SIF_POS | SIF_RETURNOLDPOS;
    si.nPos = pos;
    si.cbSize = sizeof(SCROLLINFO);

    return((int) SetScrollInfo(hwnd, code, &si, fRedraw));
}


/***************************************************************************\
* SetScrollRange
*
* History:
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/


FUNCLOG5(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, SetScrollRange, HWND, hwnd, int, code, int, posMin, int, posMax, BOOL, fRedraw)
BOOL SetScrollRange(
    HWND hwnd,
    int code,
    int posMin,
    int posMax,
    BOOL fRedraw)
{
    SCROLLINFO si;

    /*
     * Validate the window handle first, because the further call
     * to NtUserSetScrollInfo will return the position of the scrollbar
     * and not FALSE if the hwnd is invalid
     */
    if ( ValidateHwnd((hwnd)) == NULL)
        return FALSE;

    /*
     * Check if the 'Range'(Max - Min) can be represented by an integer;
     * If not, it is an error;
     * Fix for Bug #1089 -- SANKAR -- 20th Sep, 1989 --.
     */
    if ((unsigned int)(posMax - posMin) > MAXLONG) {
        RIPERR0(ERROR_INVALID_SCROLLBAR_RANGE, RIP_VERBOSE, "");
        return FALSE;
    }

    si.fMask  = SIF_RANGE;
    si.nMin   = posMin;
    si.nMax   = posMax;
    si.cbSize = sizeof(SCROLLINFO);

    SetScrollInfo(hwnd, code, &si, fRedraw);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\rtlres.c ===
/****************************** Module Header ******************************\
*
* Module Name: rtlres.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Resource Loading Routines
*
* History:
* 05-Apr-1991 ScottLu   Fixed up, resource code is now shared between client
*                       and server, added a few new resource loading routines.
* 24-Sep-1990 MikeKe    From win30
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

HICON IconFromBestImage(
    ICONFILEHEADER *pifh,
    LPNEWHEADER     lpnhSrc,
    int             cxDesired,
    int             cyDesired,
    UINT            LR_flags);

/***************************************************************************\
* LoadStringOrError
*
* NOTE: Passing a NULL value for lpch returns the string length. (WRONG!)
*
* Warning: The return count does not include the terminating NULL WCHAR;
*
* History:
* 05-Apr-1991 ScottLu   Fixed - code is now shared between client and server
* 24-Sep-1990 MikeKe    From Win30
\***************************************************************************/

int LoadStringOrError(
    HANDLE    hModule,
    UINT      wID,
    LPWSTR    lpBuffer,            // Unicode buffer
    int       cchBufferMax,        // cch in Unicode buffer
    WORD      wLangId)
{
    HANDLE hResInfo;
    HANDLE hStringSeg;
    LPTSTR lpsz;
    int    cch;

    /*
     * Make sure the parms are valid.
     */
    if (lpBuffer == NULL) {
        RIPMSG0(RIP_WARNING, "LoadStringOrError: lpBuffer == NULL");
        return 0;
    }


    cch = 0;

    /*
     * String Tables are broken up into 16 string segments.  Find the segment
     * containing the string we are interested in.
     */
    if (hResInfo = FINDRESOURCEEXW(hModule, (LPTSTR)ULongToPtr( ((LONG)(((USHORT)wID >> 4) + 1)) ), RT_STRING, wLangId)) {

        /*
         * Load that segment.
         */
        hStringSeg = LOADRESOURCE(hModule, hResInfo);

        /*
         * Lock the resource.
         */
        if (lpsz = (LPTSTR)LOCKRESOURCE(hStringSeg, hModule)) {

            /*
             * Move past the other strings in this segment.
             * (16 strings in a segment -> & 0x0F)
             */
            wID &= 0x0F;
            while (TRUE) {
                cch = *((UTCHAR *)lpsz++);      // PASCAL like string count
                                                // first UTCHAR is count if TCHARs
                if (wID-- == 0) break;
                lpsz += cch;                    // Step to start if next string
            }

            /*
             * chhBufferMax == 0 means return a pointer to the read-only resource buffer.
             */
            if (cchBufferMax == 0) {
                *(LPTSTR *)lpBuffer = lpsz;
            } else {

                /*
                 * Account for the NULL
                 */
                cchBufferMax--;

                /*
                 * Don't copy more than the max allowed.
                 */
                if (cch > cchBufferMax)
                    cch = cchBufferMax;

                /*
                 * Copy the string into the buffer.
                 */
                RtlCopyMemory(lpBuffer, lpsz, cch*sizeof(WCHAR));
            }

            /*
             * Unlock resource, but don't free it - better performance this
             * way.
             */
            UNLOCKRESOURCE(hStringSeg, hModule);
        }
    }

    /*
     * Append a NULL.
     */
    if (cchBufferMax != 0) {
        lpBuffer[cch] = 0;
    }

    return cch;
}


/***************************************************************************\
* RtlLoadObjectFromDIBFile
*
* Loads a resource object from file.
*
* 05-Sep-1995 ChrisWil      Created.
\***************************************************************************/

#define BITMAPFILEHEADER_SIZE 14
#define MINHEADERS_SIZE       (BITMAPFILEHEADER_SIZE + sizeof(BITMAPCOREHEADER))

HANDLE RtlLoadObjectFromDIBFile(
    LPCWSTR lpszName,
    LPWSTR  type,
    DWORD   cxDesired,
    DWORD   cyDesired,
    UINT    LR_flags)
{
    FILEINFO fi = { NULL, NULL, NULL };
    HANDLE   hFile;
    HANDLE   hFileMap = NULL;
    HANDLE   hObj     = NULL;
    TCHAR    szFile[MAX_PATH];
    TCHAR    szFile2[MAX_PATH];
    LPWSTR   pszFileDummy;

    if (LR_flags & LR_ENVSUBST) {

        /*
         * Do any %% string substitutions.  We need this feature to handle
         * loading custom cursors and icons from the registry which uses
         * %SystemRoot% in the paths.  It also makes the shell's job
         * easier.
         */
        ExpandEnvironmentStrings(lpszName, szFile2, MAX_PATH);

    } else {

        lstrcpy(szFile2, lpszName);
    }

    if (SearchPath(NULL,         // use default search locations
                   szFile2,      // file name to search for
                   NULL,         // already have file name extension
                   MAX_PATH,     // how big is that buffer, anyway?
                   szFile,       // stick fully qualified path name here
                   &pszFileDummy) == 0) {
        RIPERR0(ERROR_FILE_NOT_FOUND, RIP_VERBOSE, "");
        return NULL;
    }

    /*
     * Open File for reading.
     */
    hFile = CreateFileW(szFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        goto Done;

    /*
     * Create file-mapping for the file in question.
     */
    hFileMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (hFileMap == NULL)
        goto CloseDone;

    /*
     * Map the file into view.
     */
    fi.pFileMap = MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0);

    if (fi.pFileMap == NULL)
        goto CloseDone;

    fi.pFileEnd = fi.pFileMap + GetFileSize(hFile, NULL);
    fi.pFilePtr = fi.pFileMap;
    fi.pszName  = szFile;

    try {
        switch(PTR_TO_ID(type)) {
        case PTR_TO_ID(RT_BITMAP): {

            LPBITMAPFILEHEADER pBFH;
            UPBITMAPINFOHEADER upBIH;
            LPBYTE             lpBits;
            DWORD              cx;
            DWORD              cy;
            WORD               planes;
            WORD               bpp;
            DWORD              cbSizeImage = 0;
            DWORD              cbSizeFile;
            DWORD              cbSizeBits;

            /*
             * Set the BitmapFileHeader and BitmapInfoHeader pointers.
             */
            pBFH  = (LPBITMAPFILEHEADER)fi.pFileMap;
            upBIH = (UPBITMAPINFOHEADER)(fi.pFileMap + BITMAPFILEHEADER_SIZE);

            /*
             * Are we dealing with a bitmap file.
             */
            if (pBFH->bfType != BFT_BITMAP)
                break;

            /*
             * We need to check the filesize against the potential size of
             * the image.  Bad-Bitmaps would otherwise be able to slam us
             * if they lied about the size (and/or) the file is truncated.
             */
            if (upBIH->biSize == sizeof(BITMAPCOREHEADER)) {

                cx     = ((UPBITMAPCOREHEADER)upBIH)->bcWidth;
                cy     = ((UPBITMAPCOREHEADER)upBIH)->bcHeight;
                bpp    = ((UPBITMAPCOREHEADER)upBIH)->bcBitCount;
                planes = ((UPBITMAPCOREHEADER)upBIH)->bcPlanes;

            } else {

                cx     = upBIH->biWidth;
                cy     = upBIH->biHeight;
                bpp    = upBIH->biBitCount;
                planes = upBIH->biPlanes;

                if (upBIH->biSizeImage >= sizeof(BITMAPINFOHEADER)) {
                    cbSizeImage = upBIH->biSizeImage;
                }
            }

            cbSizeFile = (DWORD)(fi.pFileEnd - fi.pFileMap);
            cbSizeBits = BitmapSize(cx, cy, planes, bpp);

            if ((!cbSizeImage && ((cbSizeFile - MINHEADERS_SIZE) < cbSizeBits)) ||
            (cbSizeImage && ((cbSizeFile - MINHEADERS_SIZE) < cbSizeImage))) {

                break;
            }

            /*
             * Get the bits-offset in the file.
             */
            if ((pBFH->bfOffBits >= (sizeof(BITMAPFILEHEADER) + sizeof(BITMAPCOREHEADER))) &&
                (pBFH->bfOffBits <= (cbSizeFile - cbSizeImage))) {

                lpBits = ((LPBYTE)upBIH) + pBFH->bfOffBits - sizeof(BITMAPFILEHEADER);

            } else {

                lpBits = NULL;
            }

            /*
             * Convert the dib-on-file to a bitmap-handle.  This can
             * convert both CORE and INFO formats.
             */
            hObj = ConvertDIBBitmap(upBIH,
                                    cxDesired,
                                    cyDesired,
                                    LR_flags,
                                    NULL,
                                    &lpBits);  // use these bits!
        }
        break;

        case PTR_TO_ID(RT_CURSOR):
        case PTR_TO_ID(RT_ICON):
        {
            RTAG           *prtag;
            ICONFILEHEADER *pifh;

            /*
             * Is this a RIFF file?
             */
            prtag = (RTAG *)fi.pFileMap;

            if (prtag->ckID != FOURCC_RIFF) {

                NEWHEADER nh;

                pifh = (ICONFILEHEADER *)fi.pFileMap;

                /*
                 * BUG?: looks like we can load icons as cursors and cursors
                 * as icons.  Does this work?  Is this desired? (SAS)
                 */
                if ((pifh->iReserved != 0) ||
                    ((pifh->iResourceType != IMAGE_ICON) &&
                        (pifh->iResourceType != IMAGE_CURSOR)) ||
                    (pifh->cresIcons < 1))

                    break;

                nh.ResType  = ((type == RT_ICON) ? IMAGE_ICON : IMAGE_CURSOR);
                nh.ResCount = pifh->cresIcons;
                nh.Reserved = 0;

                /*
                 * Get the size of the it and meanwhile seek the file pointer
                 * to point at the DIB we want.  Files that have more than one
                 * icon/cursor are treated like a group.  In other words,
                 * each image is treated like an individual element in the res
                 * dir.  So we need to pick the best fit one...
                 */
                hObj = IconFromBestImage(pifh,
                                     &nh,
                                     cxDesired,
                                     cyDesired,
                                     LR_flags);
            } else {

                BOOL fAni;

                hObj = LoadCursorIconFromFileMap(&fi,
                                                 &type,
                                                 cxDesired,
                                                 cyDesired,
                                                 LR_flags,
                                                 &fAni);
                }
            }
        break;

        default:
            UserAssert(FALSE);
            break;
        } // switch
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        hObj = NULL;
    }
CloseDone:

    if (fi.pFileMap != NULL)
        UnmapViewOfFile(fi.pFileMap);

    if (hFileMap)
        CloseHandle(hFileMap);

    if (hFile && (hFile != INVALID_HANDLE_VALUE))
        CloseHandle(hFile);

Done:
#if DBG
    if (hObj == NULL) {
        RIPMSG1(RIP_WARNING,
                "RtlLoadObjectFromDIBFile: Couldn't read resource from %ws",
                lpszName);
    }
#endif

    return hObj;
}

/***************************************************************************\
* IconFromBestImage
*
* Creates HICON from best fitting image in the given file.
*
\***************************************************************************/

HICON IconFromBestImage(
    ICONFILEHEADER  *pifh,
    LPNEWHEADER      lpnhSrc,
    int              cxDesired,
    int              cyDesired,
    UINT             LR_flags)
{
    UINT             iImage;
    UINT             iImageBest;
    LPNEWHEADER      lpnhDst;
    LPRESDIR         lprd;
    LPBYTE           lpRes;
    DWORD            cbDIB;
    HICON            hIcon = NULL;
    IMAGEFILEHEADER *pimh;

    if (lpnhSrc->ResCount > 1) {

        /*
         * First, alloc dummy group resource.
         */
        lpnhDst = (LPNEWHEADER)UserLocalAlloc(0,
                sizeof(NEWHEADER) + (lpnhSrc->ResCount * sizeof(RESDIR)));

        if (lpnhDst == NULL)
            goto Done;

        *lpnhDst = *lpnhSrc;
        lprd = (LPRESDIR)(lpnhDst + 1);

        /*
         * Build up an image directory from the file's image header info.
         */

        for (pimh = pifh->imh, iImage=0;
             iImage < lpnhDst->ResCount;
             iImage++, lprd++, pimh++) {

            /*
             * Fill in RESDIR
             */
            lprd->Icon.Width  = pimh->cx;
            lprd->Icon.Height = pimh->cy;
            lprd->Icon.reserved = 0;
            lprd->BytesInRes = pimh->cbDIB;
            lprd->idIcon = (WORD)iImage; // Make fake ID:  the index of the image.

            if (lpnhDst->ResType == IMAGE_ICON) {
                /*
                 * 10/18/2000 - dwaynen
                 *
                 * For icons, this is really an ICONDIRENTRY (which has 
                 * wPlanes and wBitCount fields that overlap xHotSpot and
                 * yHotSpot!
                 */
                lprd->Icon.ColorCount = pimh->nColors;
                lprd->Planes     = pimh->xHotSpot;
                lprd->BitCount   = pimh->yHotSpot;
            } else {
                /*
                 * 10/18/2000 - dwaynen
                 *
                 * Hopefully, cursors will only have one image.  Otherwise,
                 * our selection logic is gonna be screwed up because we don't
                 * store the color bit depth!  I suppose we could dig out the
                 * actual bitmap header and find the info there.  Consider doing
                 * this if we ever want to support multi-resource cursors.
                 */
                lprd->Icon.ColorCount = 0;
                lprd->Planes     = 0;
                lprd->BitCount   = 0;
            }
        }

        /*
         * Find the best image in the group
         */
        iImageBest = LookupIconIdFromDirectoryEx((PBYTE)lpnhDst,
                                                 (lpnhDst->ResType == IMAGE_ICON),
                                                 cxDesired,
                                                 cyDesired,
                                                 LR_flags);
        /*
         * Get rid of fake group resource
         */
        UserLocalFree(lpnhDst);

    } else {
        iImageBest = 0;
    }

    /*
     * Point to selected image.
     */
    pimh  = &pifh->imh[iImageBest];
    cbDIB = pimh->cbDIB;

    /*
     * If we're creating a cursor, we have to whack in HOTSPOT in front
     * Regardless of which type we are making, we need to make sure
     * the resource is aligned.  Thus we always copy.
     */
    if (lpnhSrc->ResType == IMAGE_CURSOR)
        cbDIB += sizeof(POINTS);

    lpRes = (LPBYTE)UserLocalAlloc(0, cbDIB);
    if (lpRes == NULL)
        goto Done;

    if (lpnhSrc->ResType == IMAGE_CURSOR)
        lpRes += sizeof(POINTS);

    RtlCopyMemory(lpRes,
                  ((LPBYTE)pifh) + pimh->offsetDIB,
                  pimh->cbDIB);

    if (lpnhSrc->ResType == IMAGE_CURSOR) {

        lpRes -= sizeof(POINTS);
        ((LPPOINTS)lpRes)->x = pimh->xHotSpot;
        ((LPPOINTS)lpRes)->y = pimh->yHotSpot;
    }

    hIcon = CreateIconFromResourceEx(lpRes,
                                     cbDIB,
                                     (lpnhSrc->ResType == IMAGE_ICON),
                                     0x00030000, // was WIN32VER40
                                     cxDesired,
                                     cyDesired,
                                     LR_flags);

    UserLocalFree(lpRes);

Done:

    return hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!include $(WINCORE_PATH)\core.inc

MAJORCOMP=user
MINORCOMP=client

TARGETNAME=user32
TARGETNAMEP=user32p
TARGETTYPE=DYNLINK
DLLDEF=$(O)\$(TARGETNAME).def
DLLENTRY=UserClientDllInitialize

DELAYLOAD=advapi32.dll;msimg32.dll;powrprof.dll;winsta.dll
DLOAD_ERROR_HANDLER=kernel32

TARGETPATH=$(_OBJ_DIR)
PASS1_PUBLISH=\
    {$(DYNLINK_LIB)=$(SDK_LIB_DEST)\$(DYNLINK_LIBDIR)} \
    {$(DYNLINK_LIBP)=$(WINDOWS_LIB_DEST)\$(DYNLINK_LIBPDIR)}

TARGETLIBS=$(SDK_LIB_PATH)\kernl32p.lib     \
           $(WINDOWS_LIB_PATH)\gdi32p.lib   \
           $(SDK_LIB_PATH)\advapi32.lib     \
           $(SDK_LIB_PATH)\msimg32.lib      \
           $(SDK_LIB_PATH)\powrprof.lib     \
           $(SDK_LIB_PATH)\winsta.lib       \
           $(SDK_LIB_PATH)\uuid.lib


USE_NTDLL=1

LINKLIBS=$(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\w32umode.lib     \
         $(NTUSER_PATH)\rtl\client\$(ALT_PROJECT)\$(O)\userrtl.lib    \
         $(WINCORE_PATH)\rtl\client\$(O)\w32crtl.lib

COMMONTARGETS=$(DYNLINK_LIBP)

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -D_USER32_ -DUNICODE -DSURROGATE

LINKER_FLAGS=$(LINKER_FLAGS) /WX

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

NTTARGETFILE1=$(COMMONTARGETS)
NTTARGETFILE0=$(O)\dispcb.c             \
              $(O)\$(TARGETNAME).def

INCLUDES=..;                            \
         ..\..\inc;                     \
         ..\..\inc\$(ALT_PROJECT)\$(O); \
         $(WINCORE_PATH)\w32inc;        \
         $(WINCORE_PATH)\w32inc\$(O);   \
         $(NTGDI_PATH)\inc;             \
         $(BASE_INC_PATH);              \
         $(SHELL_INC_PATH)

NT_UP=0


DLLORDER=..\$(TARGETNAME).prf

SOURCES=..\res.rc     \
        ..\immhotky.c \
        ..\acons.c    \
        ..\btnctl.c   \
        ..\callback.c \
        ..\classc.c   \
        ..\cldib.c    \
        ..\clenum.c   \
        ..\clglobal.c \
        ..\clhook.c   \
        ..\client.c   \
        ..\clientw.c  \
        ..\clinit.c   \
        ..\clmenu.c   \
        ..\clmsg.c    \
        ..\clrect.c   \
        ..\clres.c    \
        ..\combo.c    \
        ..\combodir.c \
        ..\comboini.c \
        ..\connect.c  \
        ..\crecv.c    \
        ..\csendw.c   \
        ..\csrstubs.c \
        ..\drawtext.c \
        ..\ddemlcli.c \
        ..\ddemlwp.c  \
        ..\ddetrack.c \
        $(O)\dispcb.c \
        ..\dlgbegin.c \
        ..\dlgend.c   \
        ..\dlgmgr.c   \
        ..\dlgmgr2.c  \
        ..\dlgmgrc.c  \
        ..\dmmnem.c   \
        ..\draw.c     \
        ..\edecrare.c \
        ..\editec.c   \
        ..\editml.c   \
        ..\editsl.c   \
        ..\edmlrare.c \
        ..\edmlonce.c \
        ..\edslrare.c \
        ..\extract.c  \
        ..\fntsweep.c \
        ..\getsetc.c  \
        ..\handles.c  \
        ..\hdata.c    \
        ..\help.c     \
        ..\hsz.c      \
        ..\instance.c \
        ..\keybrdc.c  \
        ..\lb1.c      \
        ..\lboxctl1.c \
        ..\lboxctl2.c \
        ..\lboxctl3.c \
        ..\lboxmult.c \
        ..\lboxrare.c \
        ..\lboxvar.c  \
        ..\mdimenu.c  \
        ..\mdiwin.c   \
        ..\menuc.c    \
        ..\menuddc.c  \
        ..\mmcl.c     \
        ..\mngrayc.c  \
        ..\monitor.c  \
        ..\msgbox.c   \
        ..\ntstubs.c  \
        ..\oemxlate.c \
        ..\queuec.c   \
        ..\random.c   \
        ..\reader.c   \
        ..\reason.c   \
        ..\register.c \
        ..\rtlinit.c  \
        ..\rtlres.c   \
        ..\sbapi.c    \
        ..\statctl.c  \
        ..\stdptcl.c  \
        ..\strings.c  \
        ..\util.c     \
        ..\winable.c  \
        ..\winmgrc.c  \
        ..\wow.c      \
        ..\wsprintf.c \
        ..\wstrings.c \
        ..\xact.c     \
        ..\clienta.c  \
        ..\csenda.c   \
        ..\fareast.c  \
        ..\imectl.c

UMTYPE=windows

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc $(WINCORE_PATH)\core.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\statctl.c ===
/****************************************************************************\
*
*  STATIC.C
*
*  Copyright (c) 1985 - 1999, Microsoft Corporation
*
*  Static Dialog Controls Routines
*
*  13-Nov-1990 mikeke   from win3
*  29-Jan-1991 IanJa    StaticPaint -> xxxStaticPaint; partial revalidation
*  01-Nov-1994 ChrisWil merged in Daytona/Chicago w/Ani-Icons.
*
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Local Routines.
 */
VOID   xxxNextAniIconStep(PSTAT);
HANDLE xxxSetStaticImage(PSTAT,HANDLE,BOOL);
VOID xxxStaticLoadImage(PSTAT,LPWSTR);


/*
 * Type table.  This is used for validation of the
 * image-types.  For the PPC release we won't support
 * the metafile format, but others are OK.
 */
#define IMAGE_STMMAX    IMAGE_ENHMETAFILE+1

static BYTE rgbType[IMAGE_STMMAX] = {
    SS_BITMAP,       // IMAGE_BITMAP
    SS_ICON,         // IMAGE_CURSOR
    SS_ICON,         // IMAGE_ICON
    SS_ENHMETAFILE   // IMAGE_ENHMETAFILE
};


/*
 * LOBYTE of SS_ style is index into this array
 */
#define STK_OWNER       0x00
#define STK_IMAGE       0x01
#define STK_TEXT        0x02
#define STK_GRAPHIC     0x03
#define STK_TYPE        0x03

#define STK_ERASE       0x04
#define STK_USEFONT     0x08
#define STK_USETEXT     0x10

BYTE rgstk[] = {
    STK_TEXT | STK_ERASE | STK_USEFONT | STK_USETEXT,       // SS_LEFT
    STK_TEXT | STK_ERASE | STK_USEFONT | STK_USETEXT,       // SS_CENTER
    STK_TEXT | STK_ERASE | STK_USEFONT | STK_USETEXT,       // SS_RIGHT
    STK_IMAGE,                                              // SS_ICON
    STK_GRAPHIC,                                            // SS_BLACKRECT
    STK_GRAPHIC,                                            // SS_GRAYRECT
    STK_GRAPHIC,                                            // SS_WHITERECT
    STK_GRAPHIC,                                            // SS_BLACKFRAME
    STK_GRAPHIC,                                            // SS_GRAYFRAME
    STK_GRAPHIC,                                            // SS_WHITEFRAME
    STK_OWNER,                                              // SS_USERITEM
    STK_TEXT | STK_USEFONT | STK_USETEXT,                   // SS_SIMPLE
    STK_TEXT | STK_ERASE | STK_USEFONT | STK_USETEXT,       // SS_LEFTNOWORDWRAP
    STK_OWNER | STK_USEFONT | STK_USETEXT,                  // SS_OWNERDRAW
    STK_IMAGE,                                              // SS_BITMAP
    STK_IMAGE | STK_ERASE,                                  // SS_ENHMETAFILE
    STK_GRAPHIC,                                            // SS_ETCHEDHORZ
    STK_GRAPHIC,                                            // SS_ETCHEDVERT
    STK_GRAPHIC                                             // SS_ETCHEDFRAME
};

LOOKASIDE StaticLookaside;

/*
 * Common macros for image handling.
 */
#define IsValidImage(imageType, realType, max) \
    ((imageType < max) && (rgbType[imageType] == realType))


/***************************************************************************\
*
*  SetStaticImage()
*
*  Sets bitmap/icon of static guy, either in response to a STM_SETxxxx
*  message, or at create time.
*
\***************************************************************************/

HANDLE xxxSetStaticImage(
    PSTAT  pstat,
    HANDLE hImage,
    BOOL   fDeleteIt)
{
    UINT   bType;
    RECT   rc;
    RECT   rcWindow;
    HANDLE hImageOld;
    DWORD  dwRate;
    UINT   cicur;
    BOOL   fAnimated = FALSE;
    PWND   pwnd = pstat->spwnd;
    HWND   hwnd = HWq(pwnd);

    CheckLock(pwnd);

    bType = TestWF(pwnd, SFTYPEMASK);

    /*
     * If this is an old-ani-icon, then delete its timer.
     */
    if ((bType == SS_ICON) && pstat->cicur > 1) {
        /*
         *  Old cursor was an animated cursor, so kill
         *  the timer that is used to animate it.
         */
        NtUserKillTimer(hwnd, IDSYS_STANIMATE);
    }

    /*
     * Initialize the old-image return value.
     */
    hImageOld = pstat->hImage;

    rc.right = rc.bottom = 0;

    if (hImage != NULL) {

        switch (bType) {

            case SS_ENHMETAFILE: {
                /*
                 * We do NOT resize the window.
                 */
                rc.right  = pwnd->rcClient.right  - pwnd->rcClient.left;
                rc.bottom = pwnd->rcClient.bottom - pwnd->rcClient.top;
                break;
            }

            case SS_BITMAP: {

                    BITMAP bmp;

                    if (GetObject(hImage, sizeof(BITMAP), &bmp)) {
                        rc.right  = bmp.bmWidth;
                        rc.bottom = bmp.bmHeight;
                    }
                }
                break;

            case SS_ICON: {

                    NtUserGetIconSize(hImage, 0, &rc.right, &rc.bottom);
                    rc.bottom /= 2;

                    pstat->cicur = 0;
                    pstat->iicur = 0;

                    // Perhaps we can do something like shell\cpl\main\mouseptr.c
                    // here, and make GetCursorFrameInfo obsolete.
                    if (GetCursorFrameInfo(hImage, NULL, 0, &dwRate, &cicur)) {
                        fAnimated = (cicur > 1);
                        pstat->cicur = cicur;
                    }
                }
                break;
        }
    }

    pstat->hImage = hImage;
    pstat->fDeleteIt = fDeleteIt;


    /*
     *  Resize static to fit.
     *  Do NOT do this for SS_CENTERIMAGE or SS_REALSIZECONTROL
     */
    if (!TestWF(pwnd, SFCENTERIMAGE) && !TestWF(pwnd, SFREALSIZECONTROL))
    {
        /*
         *  Get current window rect in parent's client coordinates.
         */
        GetRect(pwnd, &rcWindow, GRECT_WINDOW | GRECT_PARENTCOORDS);

        /*
         * Get new window dimensions
         */
        rc.left = 0;
        rc.top = 0;

        if (rc.right && rc.bottom) {
            _AdjustWindowRectEx(&rc, pwnd->style, FALSE, pwnd->ExStyle);
            rc.right  -= rc.left;
            rc.bottom -= rc.top;
        }

        NtUserSetWindowPos(
                hwnd,
                HWND_TOP,
                0,
                0,
                rc.right,
                rc.bottom,
                SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
    }

    if (TestWF(pwnd, WFVISIBLE)) {
        NtUserInvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }


    /*
     * If this is an aimated-icon, then start the timer for
     * the animation sequence.
     */
    if(fAnimated) {
        // Perhaps we can do something like shell\cpl\main\mouseptr.c
        // here, and make GetCursorFrameInfo obsolete.
        GetCursorFrameInfo(pstat->hImage, NULL, pstat->iicur, &dwRate, &cicur);
        dwRate = max(200, dwRate * 100 / 6);
        NtUserSetTimer(hwnd, IDSYS_STANIMATE, dwRate, NULL);
    }

    return hImageOld;
}


/***************************************************************************\
*
*  StaticLoadImage()
*
*  Loads the icon or bitmap from the app's resource file if a name was
*  specified in the dialog template.  We assume that the name is the name
*  of the resource to load.
*
\***************************************************************************/

VOID xxxStaticLoadImage(
    PSTAT  pstat,
    LPWSTR lpszName)
{
    HANDLE hImage = NULL;
    PWND   pwnd = pstat->spwnd;

    CheckLock(pwnd);

    if (lpszName && *lpszName) {

        /*
         * Only try to load the icon/bitmap if the string is non null.
         */
        if (*(BYTE FAR *)lpszName == 0xFF)
            lpszName = MAKEINTRESOURCE(((LPWORD)lpszName)[1]);

        /*
         * Load the image.  If it can't be found in the app, try the
         * display driver.
         */
        if (lpszName) {

            switch (TestWF(pwnd, SFTYPEMASK)) {
            case SS_BITMAP:

                /*
                 * If the window is not owned by the server, first call
                 * back out to the client.
                 */
                if (!gfServerProcess && pwnd->hModule)
                    hImage = LoadBitmap(KHANDLE_TO_HANDLE(pwnd->hModule), lpszName);

                /*
                 * If the above didn't load it, try loading it from the
                 * display driver (hmod == NULL).
                 */
                if (hImage == NULL)
                    hImage = LoadBitmap(NULL, lpszName);
                break;

            case SS_ICON:
                if (TestWF(pwnd, SFREALSIZEIMAGE)) {
                    if (!gfServerProcess && pwnd->hModule) {
                        hImage = LoadImage(KHANDLE_TO_HANDLE(pwnd->hModule), lpszName, IMAGE_ICON, 0, 0, 0);
                    }
                } else {
                    /*
                     * If the window is not owned by the server, first call
                     * back out to the client.  Try loading both icons/cursor
                     * types.
                     */
                    if (!gfServerProcess && pwnd->hModule) {

                        hImage = LoadIcon(KHANDLE_TO_HANDLE(pwnd->hModule), lpszName);

                        /*
                         * We will also try to load a cursor-format if the
                         * window is a 4.0 compatible.  Icons/Cursors are really
                         * the same.  We don't do this for 3.x apps for the
                         * usual compatibility reasons.
                         */
                        if ((hImage == NULL) && TestWF(pwnd, WFWIN40COMPAT)) {
                            hImage = LoadCursor(KHANDLE_TO_HANDLE(pwnd->hModule), lpszName);
                        }
                    }

                    /*
                     * If the above didn't load it, try loading it from the
                     * display driver (hmod == NULL).
                     */
                    if (hImage == NULL) {
                        hImage = LoadIcon(NULL, lpszName);
                    }
                }

                break;
            }

            /*
             * Set the image if it was loaded.
             */
            if (hImage)
                xxxSetStaticImage(pstat, hImage, TRUE);

        }
    }
}


/***************************************************************************\
* StaticCallback()
*
* Draws text statics, called by DrawState.
*
* History:
\***************************************************************************/

BOOL CALLBACK StaticCallback(
    HDC  hdc,
    LPARAM lData,
    WPARAM wData,
    int  cx,
    int  cy)
{
    PWND   pwnd = (PWND)lData;
    UINT   style;
    LPWSTR lpszName;
    RECT   rc;
    BYTE   bType;

    UNREFERENCED_PARAMETER(wData);

    bType = TestWF(pwnd, SFTYPEMASK);
    UserAssert(rgstk[bType] & STK_USETEXT);

    if (pwnd->strName.Length) {
        lpszName = REBASE(pwnd, strName.Buffer);

        style = DT_NOCLIP | DT_EXPANDTABS;

        if (bType != LOBYTE(SS_LEFTNOWORDWRAP)) {
            style |= DT_WORDBREAK;
            style |= (UINT)(bType - LOBYTE(SS_LEFT));

            if (TestWF(pwnd, SFEDITCONTROL))
                style |= DT_EDITCONTROL;
        }

        switch (TestWF(pwnd, SFELLIPSISMASK)) {
        case HIBYTE(LOWORD(SS_ENDELLIPSIS)):
            style |= DT_END_ELLIPSIS | DT_SINGLELINE;
            break;

        case HIBYTE(LOWORD(SS_PATHELLIPSIS)):
            style |= DT_PATH_ELLIPSIS | DT_SINGLELINE;
            break;

        case HIBYTE(LOWORD(SS_WORDELLIPSIS)):
            style |= DT_WORD_ELLIPSIS | DT_SINGLELINE;
            break;
        }

        if (TestWF(pwnd, SFNOPREFIX))
            style |= DT_NOPREFIX;

        if (TestWF(pwnd, SFCENTERIMAGE))
            style |= DT_VCENTER | DT_SINGLELINE;

        rc.left     = 0;
        rc.top      = 0;
        rc.right    = cx;
        rc.bottom   = cy;

        if (TestWF(pwnd, WEFPUIACCELHIDDEN)) {
            style |= DT_HIDEPREFIX;
        } else if (((PSTATWND)pwnd)->pstat->fPaintKbdCuesOnly) {
            style |= DT_PREFIXONLY;
        }

        DrawTextExW(hdc, lpszName, -1, &rc, (DWORD)style, NULL);

    }

    return(TRUE);
}


/***************************************************************************\
* xxxStaticPaint
*
* History:
\***************************************************************************/

void xxxStaticPaint(
    PSTAT pstat,
    HDC   hdc,
    BOOL  fClip)
{
    PWND   pwndParent;
    RECT   rc;
    UINT   cmd;
    BYTE   bType;
    BOOL   fFont;
    HBRUSH hbrControl;
    UINT   oldAlign;
    DWORD  dwOldLayout=0;

    HANDLE hfontOld = NULL;
    PWND pwnd = pstat->spwnd;
    HWND hwnd = HWq(pwnd);

    CheckLock(pwnd);

    if (TestWF(pwnd, WEFRTLREADING))
    {
        oldAlign = GetTextAlign(hdc);
        SetTextAlign(hdc, oldAlign | TA_RTLREADING);
    }

    bType = TestWF(pwnd, SFTYPEMASK);
    _GetClientRect(pwnd, &rc);

    if (fClip) {
        IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
    }

    fFont = (rgstk[bType] & STK_USEFONT) && (pstat->hFont != NULL);

    if (fFont) {
        hfontOld = SelectObject(hdc, pstat->hFont);
    }


    /*
     * Send WM_CTLCOLORSTATIC to all statics (even frames) for 1.03
     * compatibility.
     */
    SetBkMode(hdc, OPAQUE);
    hbrControl = GetControlBrush(hwnd, hdc, WM_CTLCOLORSTATIC);


    /*
     * Do we erase the background?  We don't for SS_OWNERDRAW
     * and STK_GRAPHIC kind of things.
     */
    pwndParent = REBASEPWND(pwnd, spwndParent);
    if ((rgstk[bType] & STK_ERASE) && !pstat->fPaintKbdCuesOnly) {
        PaintRect(HW(pwndParent), hwnd, hdc, hbrControl, &rc);
    }

    switch (LOBYTE(bType)) {
    case SS_ICON:

        if (pstat->hImage) {

            int     cx;
            int     cy;
            POINT   pt;

            if (TestWF(pwnd,WEFLAYOUTRTL)) {
                dwOldLayout = SetLayoutWidth(hdc, -1, 0);
            }
            /*
             * Perform the correct rect-setup.
             */
            if (TestWF(pwnd,SFCENTERIMAGE)) {

                NtUserGetIconSize(pstat->hImage, pstat->iicur, &cx, &cy);
                cy >>= 1;

                rc.left   = (rc.right  - cx) / 2;
                rc.right  = (rc.left   + cx);
                rc.top    = (rc.bottom - cy) / 2;
                rc.bottom = (rc.top    + cy);

            } else {

                cx = rc.right  - rc.left;
                cy = rc.bottom - rc.top;
            }


            /*
             * Output the icon.  If it's animated, we indicate
             * the step-frame to output.
             */
            if (GETFNID(pwndParent) == FNID_DESKTOP) {
                SetBrushOrgEx(hdc, 0, 0, &pt);
            } else {
                SetBrushOrgEx(
                        hdc,
                        pwndParent->rcClient.left - pwnd->rcClient.left,
                        pwndParent->rcClient.top - pwnd->rcClient.top,
                        &pt);
            }

            DrawIconEx(hdc, rc.left, rc.top, pstat->hImage, cx, cy,
                       pstat->iicur, hbrControl, DI_NORMAL);

            SetBrushOrgEx(hdc, pt.x, pt.y, NULL);
            if (TestWF(pwnd,WEFLAYOUTRTL)) {
                SetLayoutWidth(hdc, -1, dwOldLayout);
            }
        } else {

            /*
             * Empty!  Need to erase.
             */
            PaintRect(HW(pwndParent), hwnd, hdc, hbrControl, &rc);
        }
        break;

    case SS_BITMAP:

        if (pstat->hImage) {

            BITMAP  bmp;
            HBITMAP hbmpT;
            RECT    rcTmp;
            BOOL    fErase;


            /*
             * Get the bitmap information.  If this fails, then we
             * can assume somethings wrong with its format...don't
             * draw in this case.
             */
            if (GetObject(pstat->hImage, sizeof(BITMAP), &bmp)) {

                if (TestWF(pwnd, SFCENTERIMAGE)) {

                    fErase = ((bmp.bmWidth  < rc.right) ||
                              (bmp.bmHeight < rc.bottom));

                    rc.left   = (rc.right  - bmp.bmWidth)  >> 1;
                    rc.right  = (rc.left   + bmp.bmWidth);
                    rc.top    = (rc.bottom - bmp.bmHeight) >> 1;
                    rc.bottom = (rc.top    + bmp.bmHeight);

                } else {

                    fErase = FALSE;
                }

                /*
                 * Select in the bitmap and blt it to the client-surface.
                 */
                RtlEnterCriticalSection(&gcsHdc);
                hbmpT = SelectObject(ghdcBits2, pstat->hImage);
                StretchBlt(hdc, rc.left, rc.top, rc.right-rc.left,
                           rc.bottom-rc.top, ghdcBits2, 0, 0, bmp.bmWidth,
                           bmp.bmHeight, SRCCOPY|NOMIRRORBITMAP);

                /*
                 * Only need to erase the background if the image is
                 * centered and it's smaller than the client-area.
                 */
                if (fErase) {

                    HBRUSH hbr;

                    if (hbr = CreateSolidBrush(GetPixel(ghdcBits2, 0, 0))) {

                        POLYPATBLT PolyData;

                        ExcludeClipRect(hdc, rc.left, rc.top,
                                        rc.right, rc.bottom);

                        _GetClientRect(pwnd, &rcTmp);

                        PolyData.x  = 0;
                        PolyData.y  = 0;
                        PolyData.cx = rcTmp.right;
                        PolyData.cy = rcTmp.bottom;
                        PolyData.BrClr.hbr = hbr;

                        PolyPatBlt(hdc,PATCOPY,&PolyData,1,PPB_BRUSH);

                        DeleteObject(hbr);
                    }
                }

                if (hbmpT) {
                    SelectObject(ghdcBits2, hbmpT);
                }
                RtlLeaveCriticalSection(&gcsHdc);
            }
        }
        break;

    case SS_ENHMETAFILE:

        if (pstat->hImage) {

            RECT rcl;

            rcl.left   = rc.left;
            rcl.top    = rc.top;
            rcl.right  = rc.right;
            rcl.bottom = rc.bottom;

            PlayEnhMetaFile(hdc, pstat->hImage, &rcl);
        }
        break;

    case SS_OWNERDRAW: {

            DRAWITEMSTRUCT dis;

            dis.CtlType    = ODT_STATIC;
            dis.CtlID      = PtrToUlong(pwnd->spmenu);
            dis.itemAction = ODA_DRAWENTIRE;
            dis.itemState  = (TestWF(pwnd, WFDISABLED) ? ODS_DISABLED : 0);
            dis.hwndItem   = hwnd;
            dis.hDC        = hdc;
            dis.itemData   = 0L;
            dis.rcItem     = rc;

            if (TestWF(pwnd, WEFPUIACCELHIDDEN)) {
                dis.itemState |= ODS_NOACCEL;
            }

            /*
             * Send a WM_DRAWITEM message to the parent.
             */
            SendMessage(HW(pwndParent), WM_DRAWITEM, (WPARAM)dis.CtlID, (LPARAM)&dis);
        }
        break;

    case SS_LEFT:
    case SS_CENTER:
    case SS_RIGHT:
    case SS_LEFTNOWORDWRAP:

        if (pwnd->strName.Length) {

            UINT dstFlags;

            dstFlags = DST_COMPLEX;

            if (TestWF(pwnd, WFDISABLED)) {
#ifdef LATER
                if (SYSMET(SLOWMACHINE) &&
                   (GetBkColor(hdc)  != SYSRGB(GRAYTEXT))) {

                    SetTextColor(hdc, SYSRGB(GRAYTEXT));
                }
                else
#endif
                    dstFlags |= DSS_DISABLED;
            }

            DrawState(hdc, SYSHBR(WINDOWTEXT),
                StaticCallback, (LPARAM)pwnd, (WPARAM)TRUE,
                rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
                dstFlags);
        }
        break;

    case SS_SIMPLE: {

            LPWSTR lpName;
            UINT cchName;


            /*
             * The "Simple" bType assumes everything, including the following:
             *  1. The Text exists and fits on one line.
             *  2. The Static item is always enabled.
             *  3. The Static item is never changed to be a shorter string.
             *  4. The Parent never responds to the CTLCOLOR message
             */
            if (pwnd->strName.Length) {
                lpName = REBASE(pwnd, strName.Buffer);
                cchName = pwnd->strName.Length / sizeof(WCHAR);
            } else {
                lpName = (LPWSTR)szNull;
                cchName = 0;
            }

            if (TestWF(pwnd,SFNOPREFIX)) {
                ExtTextOut(hdc, rc.left, rc.top, ETO_OPAQUE | ETO_CLIPPED,
                                &rc, lpName, cchName, 0L);
            } else {
                /*
                 * Use OPAQUE for speed.
                 */
                DWORD dwFlags;
                if (TestWF(pwnd, WEFPUIACCELHIDDEN)) {
                    dwFlags = DT_HIDEPREFIX;
                } else if (pstat->fPaintKbdCuesOnly) {
                    dwFlags = DT_PREFIXONLY;
                } else {
                    dwFlags = 0;
                }

                PSMTextOut(hdc, rc.left, rc.top,
                        lpName, cchName, dwFlags);
            }
        }
        break;

    case SS_BLACKFRAME:
        cmd = (COLOR_3DDKSHADOW << 3);
        goto StatFrame;

    case SS_GRAYFRAME:
        cmd = (COLOR_3DSHADOW << 3);
        goto StatFrame;

    case SS_WHITEFRAME:
        cmd = (COLOR_3DHILIGHT << 3);
StatFrame:
        DrawFrame(hdc, &rc, 1, cmd);
        break;

    case SS_BLACKRECT:
        hbrControl = SYSHBR(3DDKSHADOW);
        goto StatRect;

    case SS_GRAYRECT:
        hbrControl = SYSHBR(3DSHADOW);
        goto StatRect;

    case SS_WHITERECT:
        hbrControl = SYSHBR(3DHILIGHT);
StatRect:
        PaintRect(HW(pwndParent), hwnd, hdc, hbrControl, &rc);
        break;

    case SS_ETCHEDFRAME:
        DrawEdge(hdc, &rc, EDGE_ETCHED, BF_RECT);
        break;
    }

    if (hfontOld) {
        SelectObject(hdc, hfontOld);
    }

    if (TestWF(pwnd, WEFRTLREADING)) {
        SetTextAlign(hdc, oldAlign);
    }

}


/***************************************************************************\
*
*  StaticRepaint()
*
\***************************************************************************/

void StaticRepaint(
    PSTAT pstat)
{
    PWND pwnd = pstat->spwnd;

    if (IsVisible(pwnd)) {

        HDC hdc;
        HWND hwnd = HWq(pwnd);

        if (hdc = NtUserGetDC(hwnd)) {
            xxxStaticPaint(pstat, hdc, TRUE);
            NtUserReleaseDC(hwnd, hdc);
        }
    }
}


/***************************************************************************\
*
*  StaticNotifyParent()
*
*  Sends WM_COMMAND notification messages.
*
\***************************************************************************/

// LATER mikeke why do we have multiple versions of notifyparent?

LRESULT FAR PASCAL StaticNotifyParent(
    PWND pwnd,
    PWND pwndParent,
    int  nCode)
{
    LRESULT lret;
    TL   tlpwndParent;

    UserAssert(pwnd);

    if (!pwndParent) {
        pwndParent = REBASEPWND(pwnd, spwndParent);
    }

    ThreadLock(pwndParent, &tlpwndParent);
    lret = SendMessage(HW(pwndParent), WM_COMMAND,
                       MAKELONG(PTR_TO_ID(pwnd->spmenu), nCode), (LPARAM)HWq(pwnd));
    ThreadUnlock(&tlpwndParent);

    return lret;
}

/***************************************************************************\
* StaticWndProc
*
* History:
\***************************************************************************/

LRESULT APIENTRY StaticWndProcWorker(
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD fAnsi)
{
    HWND        hwnd = HWq(pwnd);
    BYTE        bType;
    PSTAT       pstat;
    static BOOL fInit = TRUE;

    CheckLock(pwnd);

    VALIDATECLASSANDSIZE(pwnd, FNID_STATIC);
    INITCONTROLLOOKASIDE(&StaticLookaside, STAT, spwnd, 8);

    /*
     * If the control is not interested in this message,
     * pass it to DefWindowProc.
     */
    if (!FWINDOWMSG(message, FNID_STATIC))
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);

    /*
     * Get the pstat for the given window now since we will use it a lot in
     * various handlers. This was stored using SetWindowLong(hwnd,0,pstat) when
     * we initially created the static control.
     */
    pstat = ((PSTATWND)pwnd)->pstat;

    /*
     * Get the control's type
     */
    bType = TestWF(pwnd, SFTYPEMASK);

    switch (message) {
    case STM_GETICON:
        wParam = IMAGE_ICON;

    case STM_GETIMAGE:
        if (IsValidImage(wParam, bType, IMAGE_STMMAX)) {
            return (LRESULT)pstat->hImage;
        }
        break;

    case STM_SETICON:
        lParam = (LPARAM)wParam;
        wParam = IMAGE_ICON;

    case STM_SETIMAGE:
        if (IsValidImage(wParam, bType, IMAGE_STMMAX)) {
            return (LRESULT)xxxSetStaticImage(pstat, (HANDLE)lParam, FALSE);
        }
        break;

    case WM_ERASEBKGND:

        /*
         * The control will be erased in xxxStaticPaint().
         */
        return TRUE;

    case WM_PRINTCLIENT:
        xxxStaticPaint(pstat, (HDC)wParam, FALSE);
        break;

    case WM_PAINT:
        {
            HDC         hdc;
            PAINTSTRUCT ps;

            if ((hdc = (HDC)wParam) == NULL) {
                hdc = NtUserBeginPaint(hwnd, &ps);
            }

            if (IsVisible(pwnd)) {
                xxxStaticPaint(pstat, hdc, !wParam);
            }

            /*
             * If hwnd was destroyed, BeginPaint was automatically undone.
             */
            if (!wParam) {
                NtUserEndPaint(hwnd, &ps);
            }
        }
        break;

    case WM_CREATE:

        if ((rgstk[bType] & STK_TYPE) == STK_IMAGE) {
            /*
             *  Pull the name from LPCREATESTRUCT like Win95 does
             */
            LPWSTR  lpszName;
            LPSTR   lpszAnsiName;
            struct {
                WORD tag;
                BYTE ordLo;
                BYTE ordHi;
            } dwUnicodeOrdinal;

            if (fAnsi) {
                /*
                 *  Convert the ANSI string to unicode if it exists
                 */
                lpszAnsiName = (LPSTR)((LPCREATESTRUCT)lParam)->lpszName;
                if (lpszAnsiName) {
                    if (lpszAnsiName[0] == (CHAR)0xff) {
                        /*
                         * Convert ANSI ordinal to UNICODE ordinal
                         */
                        dwUnicodeOrdinal.tag = 0xFFFF;
                        dwUnicodeOrdinal.ordLo = lpszAnsiName[1];
                        dwUnicodeOrdinal.ordHi = lpszAnsiName[2];
                        lpszName = (LPWSTR)&dwUnicodeOrdinal;
                    } else {
                        MBToWCSEx(0, lpszAnsiName, -1, &lpszName, -1, TRUE);
                    }
                } else {
                    lpszName = NULL;
                }
            } else {
                lpszName = (LPWSTR)(((LPCREATESTRUCT)lParam)->lpszName);
            }

            /*
             *  Load the image
             */
            xxxStaticLoadImage(pstat, lpszName);

            if (fAnsi &&
                    lpszName &&
                    lpszName != (LPWSTR)&dwUnicodeOrdinal) {
                /*
                 *  Free the converted ANSI string
                 */
                LocalFree(lpszName);
            }
        } else if (bType == SS_ETCHEDHORZ || bType == SS_ETCHEDVERT) {

            /*
             * Resize static window to fit edge.  Horizontal dudes
             * make bottom one edge from top, vertical dudes make
             * right edge one edge from left.
             */

            RECT    rcClient;

            _GetClientRect(pwnd, &rcClient);
            if (bType == SS_ETCHEDHORZ)
                rcClient.bottom = SYSMET(CYEDGE);
            else
                rcClient.right = SYSMET(CXEDGE);

            NtUserSetWindowPos(hwnd, HWND_TOP, 0, 0, rcClient.right,
                rcClient.bottom, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
        break;

    case WM_DESTROY:
        if (((rgstk[bType] & STK_TYPE) == STK_IMAGE) &&
            (pstat->hImage != NULL)                  &&
            (pstat->fDeleteIt)) {

            if (bType == SS_BITMAP) {
                DeleteObject(pstat->hImage);
            } else if (bType == SS_ICON) {
                if (pstat->cicur > 1) {
                    /*
                     *  Kill the animated cursor timer
                     */
                    NtUserKillTimer(hwnd, IDSYS_STANIMATE);
                }
                NtUserDestroyCursor((HCURSOR)(pstat->hImage), CURSOR_CALLFROMCLIENT);
            }
        }
        break;

    case WM_NCCREATE:
        if (TestWF(pwnd,WEFRIGHT)) {
            NtUserAlterWindowStyle(hwnd, SS_TYPEMASK, SS_RIGHT);
        }

        if (TestWF(pwnd, SFSUNKEN) ||
            ((bType == LOBYTE(SS_ETCHEDHORZ)) || (bType == LOBYTE(SS_ETCHEDVERT)))) {
            SetWindowState(pwnd, WEFSTATICEDGE);
        }
        goto CallDWP;

    case WM_NCDESTROY:
    case WM_FINALDESTROY:
        if (pstat) {
            Unlock(&pstat->spwnd);
            FreeLookasideEntry(&StaticLookaside, pstat);
        }
        NtUserSetWindowFNID(hwnd, FNID_CLEANEDUP_BIT);
        break;

    case WM_NCHITTEST:
        return (TestWF(pwnd, SFNOTIFY) ? HTCLIENT : HTTRANSPARENT);

    case WM_LBUTTONDOWN:
    case WM_NCLBUTTONDOWN:
        if (TestWF(pwnd, SFNOTIFY)) {

            /*
             * It is acceptable for an app to destroy a static label
             * in response to a STN_CLICKED notification.
             */
            StaticNotifyParent(pwnd, NULL, STN_CLICKED);
        }
        break;

    case WM_LBUTTONDBLCLK:
    case WM_NCLBUTTONDBLCLK:
        if (TestWF(pwnd, SFNOTIFY)) {

            /*
             * It is acceptable for an app to destroy a static label in
             * response to a STN_DBLCLK notification.
             */
            StaticNotifyParent(pwnd, NULL, STN_DBLCLK);
        }
        break;

    case WM_SETTEXT:
        /*
         *  No more hack to set icon/bitmap via WM_SETTEXT!
         */
        if (rgstk[bType] & STK_USETEXT) {
            if (_DefSetText(hwnd, (LPWSTR)lParam, fAnsi)) {
                StaticRepaint(pstat);
                return TRUE;
            }
        }
        break;

    case WM_ENABLE:
        StaticRepaint(pstat);
        if (TestWF(pwnd, SFNOTIFY)) {
            StaticNotifyParent(pwnd, NULL, (wParam ? STN_ENABLE : STN_DISABLE));
        }
        break;

    case WM_GETDLGCODE:
        return (LONG)DLGC_STATIC;

    case WM_SETFONT:

        /*
         * wParam - handle to the font
         * lParam - if true, redraw else don't
         */
        if (rgstk[bType] & STK_USEFONT) {

            pstat->hFont = (HANDLE)wParam;

            if (lParam && TestWF(pwnd, WFVISIBLE)) {
                NtUserInvalidateRect(hwnd, NULL, TRUE);
                UpdateWindow(hwnd);
            }
        }
        break;

    case WM_GETFONT:
        if (rgstk[bType] & STK_USEFONT) {
            return (LRESULT)pstat->hFont;
        }
        break;

    case WM_TIMER:
        if (wParam == IDSYS_STANIMATE) {
            xxxNextAniIconStep(pstat);
        }
        break;

    /*
     *  case WM_GETTEXT:
     *  No more hack to get icon/bitmap via WM_GETTEXT!
     */

    case WM_INPUTLANGCHANGEREQUEST:
        if (IS_IME_ENABLED() || IS_MIDEAST_ENABLED()) {
            /*
             * #115190
             * If the window is one of controls on top of dialogbox,
             * let the parent dialog handle it.
             */
            if (TestwndChild(pwnd) && pwnd->spwndParent) {
                PWND pwndParent = REBASEALWAYS(pwnd, spwndParent);
                if (pwndParent) {
                    PCLS pclsParent = REBASEALWAYS(pwndParent, pcls);

                    UserAssert(pclsParent != NULL);
                    if (pclsParent->atomClassName == gpsi->atomSysClass[ICLS_DIALOG]) {
                        return SendMessageWorker(pwndParent, message, wParam, lParam, FALSE);
                    }
                }
            }
        }
        goto CallDWP;

    case WM_UPDATEUISTATE:
        {
            /*
             * DWP will change the UIState bits accordingly
             */
            DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);

            if (HIWORD(wParam) & UISF_HIDEACCEL) {
                /*
                 * Change in AccelHidden state: need to repaint
                 */
                if (ISSSTEXTOROD(bType)) {
                    pstat->fPaintKbdCuesOnly = TRUE;
                    StaticRepaint(pstat);
                    pstat->fPaintKbdCuesOnly = FALSE;
                }
            }
        }
        break;

    default:
CallDWP:
        return DefWindowProcWorker(pwnd, message, wParam, lParam, fAnsi);
    }

    return 0L;
}


LRESULT WINAPI StaticWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    return StaticWndProcWorker(pwnd, message, wParam, lParam, TRUE);
}

LRESULT WINAPI StaticWndProcW(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
        return (0L);
    }

    return StaticWndProcWorker(pwnd, message, wParam, lParam, FALSE);
}

/***************************************************************************\
* Next Animated Icon Step
*
* Advances to the next step in an animaged icon.
*
*
\***************************************************************************/

VOID xxxNextAniIconStep(
    PSTAT pstat)
{
    DWORD dwRate;
    PWND pwnd = pstat->spwnd;
    HWND hwnd = HWq(pwnd);

    /*
     * Stop the timer for the next animation step.
     */
    NtUserKillTimer(hwnd, IDSYS_STANIMATE);

    if (++(pstat->iicur) >= pstat->cicur) {
        pstat->iicur = 0;
    }

    // Perhaps we can do something like shell\cpl\main\mouseptr.c
    // here, and make GetCursorFrameInfo obsolete.
    GetCursorFrameInfo(pstat->hImage, NULL, pstat->iicur, &dwRate, &pstat->cicur);
    dwRate = max(200, dwRate * 100 / 6);

    NtUserInvalidateRect(hwnd, NULL, FALSE);
    UpdateWindow(hwnd);

    NtUserSetTimer(hwnd, IDSYS_STANIMATE, dwRate, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\util.c ===
/****************************** Module Header ******************************\
* Module Name: util.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager general utility functions
*
* Created: 11/3/91 Sanford Staab
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* AddLink
*
* Description:
* Adds an advise link to the conversation's info.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL
AddLink(
    PCONV_INFO pcoi,
    GATOM gaItem,
    WORD wFmt,
    WORD wType)
{
    PADVISE_LINK aLinkNew;
    int cLinks;
    LATOM la;
    PCL_INSTANCE_INFO pcii;

    /*
     * if the link already exists, update its flags, otherwise create a
     * new one.
     */

    aLinkNew = pcoi->aLinks;
    cLinks = pcoi->cLinks;
    la = GlobalToLocalAtom(gaItem);     // aLinkNew copy
    while (cLinks) {
        if (aLinkNew->laItem == la && aLinkNew->wFmt == wFmt) {
            aLinkNew->wType = wType;
            aLinkNew->state = 0;
            DeleteAtom(la);
            return TRUE;
        }
        aLinkNew++;
        cLinks--;
    }

    if (pcoi->aLinks == NULL) {
        aLinkNew = (PADVISE_LINK)DDEMLAlloc(sizeof(ADVISE_LINK));
    } else {
        aLinkNew = (PADVISE_LINK)DDEMLReAlloc(pcoi->aLinks,
                sizeof(ADVISE_LINK) * (pcoi->cLinks + 1));
    }
    if (aLinkNew == NULL) {
        SetLastDDEMLError(pcoi->pcii, DMLERR_MEMORY_ERROR);
        DeleteAtom(la);
        return FALSE;
    }
    pcoi->aLinks = aLinkNew;
    aLinkNew += pcoi->cLinks;
    pcoi->cLinks++;

    aLinkNew->laItem = la;
    aLinkNew->wFmt = wFmt;
    aLinkNew->wType = wType;
    aLinkNew->state = 0;

    if (!(pcoi->state & ST_CLIENT)) {
        /*
         * Add count for this link
         */
        pcii = pcoi->pcii;

        for (aLinkNew->pLinkCount = pcii->pLinkCount;
                aLinkNew->pLinkCount;
                    aLinkNew->pLinkCount = aLinkNew->pLinkCount->next) {
            if (aLinkNew->pLinkCount->laTopic == pcoi->laTopic &&
                    aLinkNew->pLinkCount->gaItem == gaItem &&
                    aLinkNew->pLinkCount->wFmt == wFmt) {
                aLinkNew->pLinkCount->Total++;
                return(TRUE);
            }
        }

        /*
         * Not found - add an entry
         */
        aLinkNew->pLinkCount = (PLINK_COUNT)DDEMLAlloc(sizeof(LINK_COUNT));
        if (aLinkNew->pLinkCount == NULL) {
            SetLastDDEMLError(pcoi->pcii, DMLERR_MEMORY_ERROR);
            return FALSE;
        }
        aLinkNew->pLinkCount->next = pcii->pLinkCount;
        pcii->pLinkCount = aLinkNew->pLinkCount;

        aLinkNew->pLinkCount->laTopic = IncLocalAtomCount(pcoi->laTopic); // LinkCount copy
        aLinkNew->pLinkCount->gaItem = IncGlobalAtomCount(gaItem); // LinkCount copy
        aLinkNew->pLinkCount->laItem = IncLocalAtomCount(la); // LinkCount copy

        aLinkNew->pLinkCount->wFmt = wFmt;
        aLinkNew->pLinkCount->Total = 1;
        // doesn't matter: aLinkNew->pLinkCount->Count = 0;
    }

    return TRUE;
}



/*
 * The LinkCount array is a list of all active links grouped by topic
 * and item.  The Total field is the number of active links total for
 * that particular topic/item pair for the entire instance.  The count
 * field is used to properly set up the links to go field of the XTYP_ADVREQ
 * callback.  Whenever links are added or removed, DeleteLinkCount or
 * AddLink need to be called to keep thses counts correct.
 */
VOID
DeleteLinkCount(
    PCL_INSTANCE_INFO pcii,
    PLINK_COUNT pLinkCountDelete)
{
    PLINK_COUNT pLinkCount, pLinkCountPrev;

    if (--pLinkCountDelete->Total != 0) {
        return;
    }

    pLinkCountPrev = NULL;
    pLinkCount     = pcii->pLinkCount;
    while (pLinkCount) {

        if (pLinkCount == pLinkCountDelete) {
            GlobalDeleteAtom(pLinkCount->gaItem);
            DeleteAtom(pLinkCount->laItem);
            DeleteAtom(pLinkCount->laTopic);
            if (pLinkCountPrev == NULL) {
                pcii->pLinkCount = pLinkCount->next;
            } else {
                pLinkCountPrev->next = pLinkCount->next;
            }
            DDEMLFree(pLinkCount);
            return;
        }

        pLinkCountPrev = pLinkCount;
        pLinkCount = pLinkCount->next;
    }
}

/***************************************************************************\
* GetTokenHandle
*
* Get handle of token for current thread
*
\***************************************************************************/
BOOL
GetTokenHandle(
    PHANDLE pTokenHandle)
{
    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                         TRUE,
                         pTokenHandle)) {
        if (GetLastError() == ERROR_NO_TOKEN) {
            /* This means we are not impersonating anybody.
             * Instead, lets get the token out of the process.
             */

            if (!OpenProcessToken(GetCurrentProcess(),
                                  TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                  pTokenHandle)) {
                return FALSE;
            }
        } else {
            return FALSE;
        }
    }

    return TRUE;
}

/***************************************************************************\
* GetUserSid
*
*  Well, actually it gets a pointer to a newly allocated TOKEN_USER,
*  which contains a SID, somewhere.
*  Caller must remember to free it when it's been used.
*
* History:
*   10-16-98 Chienho      stole from spooler
*
\***************************************************************************/
BOOL
GetUserSid(
    PTOKEN_USER *ppTokenUser)
{
    HANDLE      TokenHandle;
    PTOKEN_USER pTokenUser = NULL;
    DWORD       cbTokenUser = 0;
    DWORD       cbNeeded;
    BOOL        bRet = FALSE;

    if (!GetTokenHandle(&TokenHandle)) {
        return FALSE;
    }

    bRet = GetTokenInformation(TokenHandle,
                               TokenUser,
                               pTokenUser,
                               cbTokenUser,
                               &cbNeeded);

    /*
     * We've passed a NULL pointer and 0 for the amount of memory
     * allocated.  We expect to fail with bRet = FALSE and
     * GetLastError = ERROR_INSUFFICIENT_BUFFER. If we do not
     * have these conditions we will return FALSE.
     */

    if (!bRet && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {

        pTokenUser = LocalAlloc(LPTR, cbNeeded);

        if (pTokenUser == NULL) {
            goto GetUserSidDone;
        }

        cbTokenUser = cbNeeded;

        bRet = GetTokenInformation(TokenHandle,
                                   TokenUser,
                                   pTokenUser,
                                   cbTokenUser,
                                   &cbNeeded);
    } else {
        /*
         * Any other case -- return FALSE
         */
        bRet = FALSE;
    }

GetUserSidDone:
    if (bRet == TRUE) {
        *ppTokenUser = pTokenUser;
    } else if (pTokenUser != NULL) {
        LocalFree(pTokenUser);
    }

    CloseHandle(TokenHandle);

    return bRet;
}

BOOL
GetCurrentProcessName(
    WCHAR *pszProcessName,
    int cch)
{
    BOOL bRetVal;

    if (GetModuleFileName(NULL, pszProcessName, MAX_PATH)) {
        WCHAR *pwcs = wcsrchr(pszProcessName, TEXT('\\'));
        if (pwcs != NULL) {
            ++pwcs;
            lstrcpy(pszProcessName, pwcs);
        }
        bRetVal = TRUE;
    } else {
        LoadString(hmodUser, STR_UNKNOWN, pszProcessName, cch);
        bRetVal = FALSE;
    }

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\stdptcl.c ===
/****************************** Module Header ******************************\
* Module Name: stdptcl.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager DDE protocol transaction management functions
*
* NITTY GRITTY GUCK of DDE
*
* Created: 11/3/91 Sanford Staab
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/*

    StartFunctions:
        These are used to fill in a preallocated pxi with transaction
        specific data. They then start the desired transaction and
        link the pxi into the conversation's transaction queue.
        fSuccess is return ed. On error, SetLastDDEMLError is called
        by these functions and the pxi is untouched, ready for
        reuse on a subsequent call. Note that the pxi->gaItem field
        is a global atom and needs to be deleted by the caller on
        failure as apropriate. Success implies the transaction
        is started successfully.

    RespFunctions:
        These are called via the pxi->pfnRespnose field in response
        to expected DDE messages. If the msg parameter is 0, these
        functions assume transaction cleanup is being done. FALSE
        is only return ed if CBR_BLOCK was returned from a callback.

    SpontFunctions:
        These are called in response to a spontaneous (unexpected) DDE
        message. These functions may create a pxi and link it into the
        conversation's transaction queue to properly handle expected
        replies. FALSE is only return ed if CBR_BLOCK was returned
        from a callback.

    The prefixes Sv and Cl indicate which side of the DDE conversation
    is doing the work.

    Weaknesses: Can't deal well with failed PostMessage() or
                 lParam acessing/allocation failures. Hoping these
                 are rare enough (ie never) to not matter. If they
                 do fail, the tracking layer will eventually shut down
                 the conversation.

*/

//--------------------------------ADVISE-------------------------------//

/***************************************************************************\
* ClStartAdvise
*
* Description:
* CLIENT side Advise link processing
* Post WM_DDE_ADVISE message
* Link pxi for responding WM_DDE_ACK message.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
BOOL ClStartAdvise(
PXACT_INFO pxi)
{
    DWORD dwError;

    //
    // protocol quirk: DDE_FRELEASE is always assumed set in a WM_DDE_ADVISE
    // message. We set it here just in case the person on the other end
    // pays attention to it.
    //
    pxi->hDDESent = AllocAndSetDDEData(NULL, sizeof(DDE_DATA),
            (WORD)(((pxi->wType << 12) & (DDE_FDEFERUPD | DDE_FACKREQ)) | DDE_FRELEASE),
            pxi->wFmt);
    if (!pxi->hDDESent) {
        SetLastDDEMLError(pxi->pcoi->pcii, DMLERR_MEMORY_ERROR);
        return (FALSE);
    }

    IncGlobalAtomCount(pxi->gaItem); // message copy
    dwError = PackAndPostMessage(pxi->pcoi->hwndPartner, 0, WM_DDE_ADVISE,
            pxi->pcoi->hwndConv, 0, (UINT_PTR)pxi->hDDESent, pxi->gaItem);
    if (dwError) {
        SetLastDDEMLError(pxi->pcoi->pcii, dwError);
        WOWGLOBALFREE(pxi->hDDESent);
        pxi->hDDESent = 0;
        GlobalDeleteAtom(pxi->gaItem); // message copy
        return (FALSE);
    }

    pxi->state = XST_ADVSENT;
    pxi->pfnResponse = (FNRESPONSE)ClRespAdviseAck;
    LinkTransaction(pxi);
    return (TRUE);
}


/***************************************************************************\
* SvSpontAdvise
*
* Description:
* SERVER side WM_DDE_ADVISE processing
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
BOOL SvSpontAdvise(
PSVR_CONV_INFO psi,
LPARAM lParam)
{
    UINT_PTR uiHi;
    HANDLE hDDE;
    WORD wFmt, wStatus;
    ULONG_PTR dwRet = 0;
    DWORD dwError;
    LATOM la;

    UnpackDDElParam(WM_DDE_ADVISE, lParam, (PUINT_PTR)&hDDE, &uiHi);
    if (psi->ci.pcii->afCmd & CBF_FAIL_ADVISES) {
        goto Ack;
    }

    if (!ExtractDDEDataInfo(hDDE, &wStatus, &wFmt)) {
        goto Ack;
    }

    if (wStatus & DDE_FDEFERUPD) {
        wStatus &= ~DDE_FACKREQ;   // warm links shouldn't have this flag set
    }

    la = GlobalToLocalAtom((GATOM)uiHi);
    dwRet = (ULONG_PTR)DoCallback(psi->ci.pcii,
        XTYP_ADVSTART,
        wFmt, psi->ci.hConv,
        NORMAL_HSZ_FROM_LATOM(psi->ci.laTopic),
        NORMAL_HSZ_FROM_LATOM(la),
        (HDDEDATA)0, 0, 0);
    DeleteAtom(la);

    // check CBR_BLOCK case

    if (dwRet == (ULONG_PTR)CBR_BLOCK) {
        return (FALSE);
    }

    if (dwRet) {
        //
        // If we fail to add the link internally, dwRet == 0 -> NACK
        //
        dwRet = AddLink((PCONV_INFO)psi, (GATOM)uiHi, wFmt,
                (WORD)(wStatus & (WORD)(DDE_FDEFERUPD | DDE_FACKREQ)));
        if (dwRet) {
            MONLINK(psi->ci.pcii, TRUE, wStatus & DDE_FDEFERUPD, psi->ci.laService,
                    psi->ci.laTopic, (GATOM)uiHi, wFmt, TRUE,
                    (HCONV)psi->ci.hwndConv, (HCONV)psi->ci.hwndPartner);
        }
    }

Ack:
    if (dwRet) {
        WOWGLOBALFREE(hDDE); // hOptions - NACK -> HE frees it.
    }
    // IncGlobalAtomCount((GATOM)uiHi);         // message copy - reuse
    dwError = PackAndPostMessage(psi->ci.hwndPartner, WM_DDE_ADVISE, WM_DDE_ACK,
            psi->ci.hwndConv, lParam, dwRet ? DDE_FACK : 0, uiHi);
    if (dwError) {
        SetLastDDEMLError(psi->ci.pcii, dwError);
        GlobalDeleteAtom((ATOM)uiHi); // message copy
    }

    return (TRUE);
}



/***************************************************************************\
* ClRespAdviseAck
*
* Description:
* Client's response to an expected Advise Ack.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
BOOL ClRespAdviseAck(
PXACT_INFO pxi,
UINT msg,
LPARAM lParam)
{
    UINT_PTR uiLo, uiHi;

    if (msg) {
        if (msg != WM_DDE_ACK) {
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }

        UnpackDDElParam(WM_DDE_ACK, lParam, &uiLo, &uiHi);
#if DBG
        if ((GATOM)uiHi != pxi->gaItem) {
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }
#endif

        GlobalDeleteAtom((ATOM)uiHi); // message copy

        pxi->state = XST_ADVACKRCVD;
        pxi->wStatus = (WORD)uiLo;

        if (pxi->wStatus & DDE_FACK) {
            if (AddLink(pxi->pcoi, pxi->gaItem, pxi->wFmt,
                    (WORD)((pxi->wType << 12) & (DDE_FACKREQ | DDE_FDEFERUPD)))) {
                //
                // only server side reports links on local conversations.
                //
                if (!(pxi->pcoi->state & ST_ISLOCAL)) {
                    MONLINK(pxi->pcoi->pcii, TRUE, (WORD)uiLo & DDE_FDEFERUPD,
                            pxi->pcoi->laService, pxi->pcoi->laTopic, pxi->gaItem,
                            pxi->wFmt, FALSE, (HCONV)pxi->pcoi->hwndPartner,
                            (HCONV)pxi->pcoi->hwndConv);
                }
            } else {
                pxi->wStatus = 0;  // memory failure - fake a NACK.
            }
        } else {
            WOWGLOBALFREE(pxi->hDDESent);  // Nack free.
        }

        if (TransactionComplete(pxi,
                (pxi->wStatus & DDE_FACK) ? (HDDEDATA)1L : (HDDEDATA)0L)) {
            goto Cleanup;
        }
    } else {
Cleanup:
        GlobalDeleteAtom(pxi->gaItem); // pxi copy
        UnlinkTransaction(pxi);
        DDEMLFree(pxi);
    }
    if (msg) {
        FreeDDElParam(msg, lParam);
    }
    return (TRUE);
}

//-------------------------ADVISE LINK UPDATE--------------------------//


/***************************************************************************\
* SvStartAdviseUpdate
*
* Description:
* Starts a single link update transaction. The return value is TRUE only
* if pxi was queued.
*
* History:
* 11-19-91 sanfords Created.
* 8-24-92  sanfords Added cLinksToGo
\***************************************************************************/
BOOL SvStartAdviseUpdate(
PXACT_INFO pxi,
DWORD cLinksToGo)
{
    HDDEDATA hData = NULL;
    PDDE_DATA pdde;
    DWORD dwError;
    HANDLE hDDE;
    LATOM al;

    CheckDDECritIn;

    if (pxi->wType & DDE_FDEFERUPD) {
        hDDE = 0;
    } else {
        al = GlobalToLocalAtom(pxi->gaItem);
        hData = DoCallback(pxi->pcoi->pcii,
                           XTYP_ADVREQ,
                           pxi->wFmt,
                           pxi->pcoi->hConv,
                           NORMAL_HSZ_FROM_LATOM(pxi->pcoi->laTopic),
                           NORMAL_HSZ_FROM_LATOM(al),
                           (HDDEDATA)0,
                           MAKELONG(cLinksToGo, 0),
                           0);
        DeleteAtom(al);
        if (!hData) {
            // app doesn't honor the advise.
            return (FALSE); // reuse pxi
        }
        hDDE = UnpackAndFreeDDEMLDataHandle(hData, FALSE);
        if (!hDDE) {

            /*
             * failed - must be execute type data
             */
            InternalFreeDataHandle(hData, FALSE);
            SetLastDDEMLError(pxi->pcoi->pcii, DMLERR_DLL_USAGE);
            return (FALSE);
        }
        /*
         * Set fAckReq bit apropriately - note APPOWNED handles will already
         * have the fAckReq bit set so this will not change their state.
         */
        USERGLOBALLOCK(hDDE, pdde);
        if (pdde == NULL) {
            return (FALSE);
        }
        if (pdde->wFmt != pxi->wFmt) {

            /*
             * bogus data - wrong format!
             */
            USERGLOBALUNLOCK(hDDE);
            InternalFreeDataHandle(hData, FALSE);
            SetLastDDEMLError(pxi->pcoi->pcii, DMLERR_DLL_USAGE);
            return (FALSE);
        }
        if (!(pdde->wStatus & DDE_FRELEASE)) {
            pxi->wType |= DDE_FACKREQ; // dare not allow neither flag set!
        }
        pdde->wStatus |= (pxi->wType & DDE_FACKREQ);
        USERGLOBALUNLOCK(hDDE);
    }

    IncGlobalAtomCount(pxi->gaItem); // message copy
    dwError = PackAndPostMessage(pxi->pcoi->hwndPartner, 0, WM_DDE_DATA,
            pxi->pcoi->hwndConv, 0, (UINT_PTR)hDDE, pxi->gaItem);
    if (dwError) {
        if (hData) {
            InternalFreeDataHandle(hData, FALSE);
        }
        SetLastDDEMLError(pxi->pcoi->pcii, dwError);
        GlobalDeleteAtom(pxi->gaItem); // message copy
        return (FALSE);
    }

    pxi->state = XST_ADVDATASENT;
    if (pxi->wType & DDE_FACKREQ) {
        pxi->hDDESent = hDDE;
        pxi->pfnResponse = (FNRESPONSE)SvRespAdviseDataAck;
        LinkTransaction(pxi);
        return (TRUE); // prevents reuse - since its queued.
    } else {
        return (FALSE); // causes pxi to be reused for next advdata message.
    }
}



/***************************************************************************\
* ClSpontAdviseData
*
* Description:
* Handles WM_DDE_DATA messages that are not request data.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ClSpontAdviseData(
PCL_CONV_INFO pci,
LPARAM lParam)
{
    UINT_PTR uiHi;
    DWORD dwError;
    HANDLE hDDE = 0;
    HDDEDATA hData, hDataReturn;
    PDDE_DATA pdde;
    WORD wFmt;
    WORD wStatus;
    LATOM la;
    PADVISE_LINK paLink;
    int iLink;

    UnpackDDElParam(WM_DDE_DATA, lParam, (PUINT_PTR)&hDDE, &uiHi);
    UserAssert(!hDDE || GlobalSize(hDDE));
    wFmt = 0;
    wStatus = 0;
    hDataReturn = 0;
    la = GlobalToLocalAtom((GATOM)uiHi);
    if (hDDE) {
        USERGLOBALLOCK(hDDE, pdde);
        if (pdde == NULL) {
            hData = 0;
        } else {
            wFmt = pdde->wFmt;
            wStatus = pdde->wStatus;
            USERGLOBALUNLOCK(hDDE);

            /*
             * if data is coming in, create a data handle for the app
             */
            hData = InternalCreateDataHandle(pci->ci.pcii, (LPBYTE)hDDE,
                    (DWORD)-1, 0, HDATA_NOAPPFREE | HDATA_READONLY, 0, 0);
        }
        if (hData) {
            hDataReturn = DoCallback(pci->ci.pcii, XTYP_ADVDATA,
                    wFmt, pci->ci.hConv,
                    NORMAL_HSZ_FROM_LATOM(pci->ci.laTopic),
                    NORMAL_HSZ_FROM_LATOM(la),
                    hData, 0, 0);
            if (hDataReturn != CBR_BLOCK) {
                UnpackAndFreeDDEMLDataHandle(hData, FALSE);
                if (((ULONG_PTR)hDataReturn & DDE_FACK) || !(wStatus & DDE_FACKREQ)) {
                    /*
                     * Nacked Advise data with fAckReq set is server's
                     * responsibility to free!
                     */
                    FreeDDEData(hDDE, FALSE, TRUE);
                }
            }
        }
    } else {
        /*
         * WARM LINK CASE
         *
         * Search through the client's link info to find what formats this
         * puppy is on. We let the client know for each format being supported
         * on this item that is warm-linked. The last hDataReturn determines
         * the ACK returned - for lack of a better method.
         */
        for (paLink = pci->ci.aLinks, iLink = 0; iLink < pci->ci.cLinks; iLink++, paLink++) {
            if ((paLink->laItem == la) && (paLink->wType & DDE_FDEFERUPD)) {
                hDataReturn = DoCallback(pci->ci.pcii, XTYP_ADVDATA,
                        paLink->wFmt, pci->ci.hConv,
                        NORMAL_HSZ_FROM_LATOM(pci->ci.laTopic),
                        NORMAL_HSZ_FROM_LATOM(la),
                        0, 0, 0);
                if (hDataReturn == CBR_BLOCK) {
                    DeleteAtom(la);
                    return (FALSE);
                }
            }
        }
    }
    DeleteAtom(la);
    if (hDataReturn == CBR_BLOCK) {
        return (FALSE);
    }

    if (wStatus & DDE_FACKREQ) {

        (ULONG_PTR)hDataReturn &= ~DDE_FACKRESERVED;
        // reuse uiHi
        if (dwError = PackAndPostMessage(pci->ci.hwndPartner, WM_DDE_DATA,
                WM_DDE_ACK, pci->ci.hwndConv, lParam, (UINT_PTR)hDataReturn, uiHi)) {
            SetLastDDEMLError(pci->ci.pcii, dwError);
        }
    } else {
        GlobalDeleteAtom((ATOM)uiHi); // data message copy
        FreeDDElParam(WM_DDE_DATA, lParam); // not reused so free it.
    }
    return (TRUE);
}




/***************************************************************************\
* SvRespAdviseDataAck
*
* Description:
* Handles expected Advise Data ACK message.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL SvRespAdviseDataAck(
PXACT_INFO pxi,
UINT msg,
LPARAM lParam)
{
    UINT_PTR uiLo, uiHi;
    int iLink;
    PADVISE_LINK paLink;
    PXACT_INFO pxiNew;
    LATOM la;
    BOOL fSwapped;
#if DBG
    int cLinks;
#endif

    if (msg) {
        if (msg != WM_DDE_ACK) {
            return (SpontaneousServerMessage((PSVR_CONV_INFO)pxi->pcoi, msg, lParam));
        }
        UnpackDDElParam(WM_DDE_ACK, lParam, &uiLo, &uiHi);
        if ((GATOM)uiHi != pxi->gaItem) {
            RIPMSG0(RIP_ERROR, "DDE Protocol violation: Data ACK had wrong item");
            return (SpontaneousServerMessage((PSVR_CONV_INFO)pxi->pcoi, msg, lParam));
        }

        GlobalDeleteAtom((ATOM)uiHi); // message copy
        FreeDDElParam(WM_DDE_ACK, lParam);

        if (!((uiLo & DDE_FACK) && pxi->hDDESent)) {
            FreeDDEData(pxi->hDDESent, FALSE, TRUE);
        }

        #if DBG
        /*
         * Rememeber the number of links so we can assert if they change during the loop below
         */
        cLinks = pxi->pcoi->cLinks;
        #endif
        /*
         * locate link info and clear ADVST_WAITING bit
         */
        la = GlobalToLocalAtom((GATOM)uiHi);
        paLink = pxi->pcoi->aLinks;
        for (iLink = 0; iLink < pxi->pcoi->cLinks; iLink++, paLink++) {
            if (paLink->laItem == la &&
                    paLink->state & ADVST_WAITING) {
                paLink->state &= ~ADVST_WAITING;
                /*
                 * We have to allocate pxiNew because it may become linked
                 * into pcoi->pxiIn.
                 */
                pxiNew = (PXACT_INFO)DDEMLAlloc(sizeof(XACT_INFO));

                if (pxiNew && !UpdateLinkIfChanged(paLink, pxiNew, pxi->pcoi,
                        &pxi->pcoi->aLinks[pxi->pcoi->cLinks - 1], &fSwapped,
                        CADV_LATEACK)) {
                    /*
                     * Not used, free it.
                     */
                    DDEMLFree(pxiNew);
                }
                break;
            }
        }
        #if DBG
        if (cLinks != pxi->pcoi->cLinks) {
            RIPMSG1(RIP_ERROR, "SvRespAdviseDataAck: cLinks changed. pxi:%#p", pxi);
        }
        #endif

        DeleteAtom(la);
    }
    GlobalDeleteAtom(pxi->gaItem); // pxi copy
    UnlinkTransaction(pxi);
    DDEMLFree(pxi);
    return (TRUE);
}



//------------------------------UNADVISE-------------------------------//

/***************************************************************************\
* ClStartUnadvise
*
* Description:
* Starts a WM_DDE_UNADVISE transaction.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ClStartUnadvise(
PXACT_INFO pxi)
{
    DWORD dwError;

    IncGlobalAtomCount(pxi->gaItem); // message copy
    dwError = PackAndPostMessage(pxi->pcoi->hwndPartner, 0, WM_DDE_UNADVISE,
            pxi->pcoi->hwndConv, 0, pxi->wFmt, pxi->gaItem);
    if (dwError) {
        SetLastDDEMLError(pxi->pcoi->pcii, dwError);
        GlobalDeleteAtom(pxi->gaItem); // message copy
        return (FALSE);
    }

    //
    // only server side reports links on local conversations.
    //
    if (!(pxi->pcoi->state & ST_ISLOCAL)) {
        MONLINK(pxi->pcoi->pcii, FALSE, 0,
                pxi->pcoi->laService, pxi->pcoi->laTopic, pxi->gaItem,
                pxi->wFmt, FALSE, (HCONV)pxi->pcoi->hwndPartner,
                (HCONV)pxi->pcoi->hwndConv);
    }
    pxi->state = XST_UNADVSENT;
    pxi->pfnResponse = (FNRESPONSE)ClRespUnadviseAck;
    LinkTransaction(pxi);
    return (TRUE);
}
/***************************************************************************\
* CloseTransaction
*
* Description:
* Remove all outstanding pxi coresponding to the transaction
* that will be closed in responds to a WM_DDE_UNADVISE message.
*
* History:
* 6-4-96 clupu Created.
\***************************************************************************/
void CloseTransaction(
    PCONV_INFO pci,
    ATOM       atom)
{
    PXACT_INFO pxi;
    PXACT_INFO pxiD;

    pxi = pci->pxiOut;

    while (pxi && (pxi->gaItem == atom)) {
        pxiD = pxi;
        pxi  = pxi->next;
        DDEMLFree(pxiD);
    }
    pci->pxiOut = pxi;

    if (pxi == NULL) {
        pci->pxiIn = NULL;
        return;
    }

    while (pxi->next) {
        if (pxi->next->gaItem == atom) {
            pxiD = pxi->next;
            pxi->next = pxiD->next;
            DDEMLFree(pxiD);
        } else
            pxi = pxi->next;
    }
    pci->pxiIn = pxi;
}

/***************************************************************************\
* SvSpontUnadvise
*
* Description:
* Responds to a WM_DDE_UNADVISE message.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL SvSpontUnadvise(
PSVR_CONV_INFO psi,
LPARAM lParam)
{
    ULONG_PTR dwRet = 0;
    DWORD dwError;
    INT iLink;
    PADVISE_LINK aLink;
    LATOM la;

    la = GlobalToLocalAtom((GATOM)HIWORD(lParam));

    CloseTransaction(&psi->ci, HIWORD(lParam));

    for (aLink = psi->ci.aLinks, iLink = 0; iLink < psi->ci.cLinks;) {

        if (la == 0 || aLink->laItem == la &&
                (LOWORD(lParam) == 0 || LOWORD(lParam) == aLink->wFmt)) {

            if (!(psi->ci.pcii->afCmd & CBF_FAIL_ADVISES)) {
                /*
                 * Only do the callbacks if he wants them.
                 */
                dwRet = (ULONG_PTR)DoCallback(psi->ci.pcii,
                    (WORD)XTYP_ADVSTOP, aLink->wFmt, psi->ci.hConv,
                    NORMAL_HSZ_FROM_LATOM(psi->ci.laTopic),
                    NORMAL_HSZ_FROM_LATOM(la),
                    (HDDEDATA)0, 0L, 0L);
                if (dwRet == (ULONG_PTR)CBR_BLOCK) {
                    DeleteAtom(la);
                    return(FALSE);
                }
            }
            /*
             * Notify any DDESPY apps.
             */
            MONLINK(psi->ci.pcii, TRUE, 0, psi->ci.laService,
                    psi->ci.laTopic, HIWORD(lParam), aLink->wFmt, TRUE,
                    (HCONV)psi->ci.hwndConv, (HCONV)psi->ci.hwndPartner);
            /*
             * Remove link info
             */
            DeleteAtom(aLink->laItem);  // aLink copy
            DeleteLinkCount(psi->ci.pcii, aLink->pLinkCount);
            if (--psi->ci.cLinks) {
                memmove((LPSTR)aLink, (LPSTR)(aLink + 1),
                        sizeof(ADVISE_LINK) * (psi->ci.cLinks - iLink));
            }
        } else {
            aLink++;
            iLink++;
        }
    }

    DeleteAtom(la);

    /*
     * Now ACK the unadvise message.
     */
    dwError = PackAndPostMessage(psi->ci.hwndPartner, 0,
            WM_DDE_ACK, psi->ci.hwndConv, 0, DDE_FACK, HIWORD(lParam));
    if (dwError) {
        SetLastDDEMLError(psi->ci.pcii, dwError);
        GlobalDeleteAtom((ATOM)HIWORD(lParam));      // message copy
        // FreeDDElParam(WM_DDE_UNADVISE, lParam);   // no unpack needed
    }

    return (TRUE);
}

/***************************************************************************\
* ClRespUnadviseAck
*
* Description:
* Client's response to an expected Unadvise Ack.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
BOOL ClRespUnadviseAck(
PXACT_INFO pxi,
UINT msg,
LPARAM lParam)
{
    UINT_PTR uiLo, uiHi;
    LATOM al;
    PADVISE_LINK aLink;
    int iLink;

    if (msg) {
        if (msg != WM_DDE_ACK) {
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }

        UnpackDDElParam(WM_DDE_ACK, lParam, &uiLo, &uiHi);
        if ((GATOM)uiHi != pxi->gaItem) {
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }

        al = GlobalToLocalAtom((ATOM)uiHi);
        for (aLink = pxi->pcoi->aLinks, iLink = 0;
                iLink < pxi->pcoi->cLinks;
                    ) {
            if (aLink->laItem == al &&
                    (pxi->wFmt == 0 || aLink->wFmt == pxi->wFmt)) {
                DeleteAtom(al);  // aLink copy
                if (--pxi->pcoi->cLinks) {
                    memmove((LPSTR)aLink, (LPSTR)(aLink + 1),
                            sizeof(ADVISE_LINK) * (pxi->pcoi->cLinks - iLink));
                }
            } else {
                aLink++;
                iLink++;
            }
        }
        DeleteAtom(al);  // local copy
        GlobalDeleteAtom((ATOM)uiHi);   // message copy

        pxi->state = XST_UNADVACKRCVD;
        pxi->wStatus = (WORD)uiLo;
        if (TransactionComplete(pxi, (HDDEDATA)1)) {
            goto Cleanup;
        }
    } else {
Cleanup:
        GlobalDeleteAtom(pxi->gaItem);   // pxi copy
        UnlinkTransaction(pxi);
        if (pxi->hXact) {
            DestroyHandle(pxi->hXact);
        }
        DDEMLFree(pxi);
    }
    if (msg) {
        FreeDDElParam(msg, lParam);
    }
    return (TRUE);
}


//-------------------------------EXECUTE-------------------------------//


/***************************************************************************\
* MaybeTranslateExecuteData
*
* Description:
* Translates DDE execute data if needed.
*
* History:
* 1/28/92 sanfords created
\***************************************************************************/
HANDLE MaybeTranslateExecuteData(
HANDLE hDDE,
BOOL fUnicodeFrom,
BOOL fUnicodeTo,
BOOL fFreeSource)
{
    PSTR pstr;
    PWSTR pwstr;
    DWORD cb;
    HANDLE hDDEnew;

    if (fUnicodeFrom && !fUnicodeTo) {
        // translate data from UNICODE to ANSII
        cb = (DWORD)(GlobalSize(hDDE) >> 1);
        hDDEnew = UserGlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE, cb);
        USERGLOBALLOCK(hDDEnew, pstr);
        USERGLOBALLOCK(hDDE, pwstr);
        if (pstr != NULL && pwstr != NULL) {
            WCSToMB(pwstr, -1, &pstr, cb, FALSE);
        }
        if (pwstr) {
            USERGLOBALUNLOCK(hDDE);
        }
        if (pstr) {
            USERGLOBALUNLOCK(hDDEnew);
        }
    } else if (!fUnicodeFrom && fUnicodeTo) {
        // translate data from ANSII to UNICODE
        cb = (DWORD)(GlobalSize(hDDE) << 1);
        hDDEnew = UserGlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE, cb);
        USERGLOBALLOCK(hDDEnew, pwstr);
        USERGLOBALLOCK(hDDE, pstr);
        if (pwstr != NULL && pstr != NULL) {
            MBToWCS(pstr, -1, &pwstr, cb, FALSE);
        }
        if (pstr) {
            USERGLOBALUNLOCK(hDDE);
        }
        if (pwstr) {
            USERGLOBALUNLOCK(hDDEnew);
        }
    } else {
        return (hDDE); // no translation needed.
    }
    if (fFreeSource) {
        WOWGLOBALFREE(hDDE);
    }
    return (hDDEnew);
}


/***************************************************************************\
* ClStartExecute
*
* Description:
* Starts an execute transaction.
*
* History:
* 11-19-91 sanfords Created.
* 1/28/92 sanfords added UNICODE support.
\***************************************************************************/
BOOL ClStartExecute(
PXACT_INFO pxi)
{
    DWORD dwError;

    pxi->hDDESent = MaybeTranslateExecuteData(pxi->hDDESent,
            pxi->pcoi->pcii->flags & IIF_UNICODE,
            pxi->pcoi->state & ST_UNICODE_EXECUTE,
            TRUE);

    dwError = PackAndPostMessage(pxi->pcoi->hwndPartner, 0, WM_DDE_EXECUTE,
            pxi->pcoi->hwndConv, 0, 0, (UINT_PTR)pxi->hDDESent);
    if (dwError) {
        SetLastDDEMLError(pxi->pcoi->pcii, dwError);
        return (FALSE);
    }
    pxi->state = XST_EXECSENT;
    pxi->pfnResponse = (FNRESPONSE)ClRespExecuteAck;
    LinkTransaction(pxi);
    return (TRUE);
}


/***************************************************************************\
* SvSpontExecute
*
* Description:
* Responds to a WM_DDE_EXECUTE message.
*
* History:
* 11-19-91 sanfords Created.
* 1/28/92 sanfords added UNICODE support.
\***************************************************************************/
BOOL SvSpontExecute(
PSVR_CONV_INFO psi,
LPARAM lParam)
{
    HANDLE hDDE, hDDEx;
    ULONG_PTR dwRet = 0;
    DWORD dwError;
    HDDEDATA hData = 0;

    hDDEx = hDDE = (HANDLE)lParam; // UnpackDDElParam(msg, lParam, NULL, &hDDE);
    if (psi->ci.pcii->afCmd & CBF_FAIL_EXECUTES) {
        goto Ack;
    }

    /*
     * Note that if unicode translation is needed, we use the translated
     * handle for the callback and then destroy it but the ACK is always
     * the original hDDE so that the protocol isn't violated:
     *
     * DDE COMMANDMENT #324: Thou shalt pass back the exact same data
     * handle in an execute ACK that you were given by the execute
     * message.
     */
    hDDEx = MaybeTranslateExecuteData(hDDE,
            psi->ci.state & ST_UNICODE_EXECUTE,
            psi->ci.pcii->flags & IIF_UNICODE,
            FALSE);

    hData = InternalCreateDataHandle(psi->ci.pcii, (LPBYTE)hDDEx, (DWORD)-1, 0,
        HDATA_EXECUTE | HDATA_READONLY | HDATA_NOAPPFREE, 0, 0);
    if (!hData) {
        SetLastDDEMLError(psi->ci.pcii, DMLERR_MEMORY_ERROR);
        goto Ack;
    }

    dwRet = (ULONG_PTR)DoCallback(psi->ci.pcii,
            XTYP_EXECUTE, 0, psi->ci.hConv,
            NORMAL_HSZ_FROM_LATOM(psi->ci.laTopic), 0, hData, 0, 0);
    UnpackAndFreeDDEMLDataHandle(hData, TRUE);

    if (dwRet == (ULONG_PTR)CBR_BLOCK) {
        if (hDDEx != hDDE) {
            WOWGLOBALFREE(hDDEx);
        }
        return (FALSE);
    }

Ack:
    dwRet &= ~DDE_FACKRESERVED;
    dwError = PackAndPostMessage(psi->ci.hwndPartner, WM_DDE_EXECUTE,
            WM_DDE_ACK, psi->ci.hwndConv, lParam, dwRet, (UINT_PTR)hDDE);
    if (dwError) {
        SetLastDDEMLError(psi->ci.pcii, dwError);
    }

    if (hDDEx != hDDE) {
        WOWGLOBALFREE(hDDEx);
    }

    return (TRUE);
}



/***************************************************************************\
* ClRespExecuteAck
*
* Description:
* Responds to a WM_DDE_ACK in response to a WM_DDE_EXECUTE message.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ClRespExecuteAck(
PXACT_INFO pxi,
UINT msg,
LPARAM lParam)
{
    UINT_PTR uiLo, uiHi;

    if (msg) {
        if (msg != WM_DDE_ACK) {
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }

        UnpackDDElParam(WM_DDE_ACK, lParam, &uiLo, &uiHi);
        if (uiHi != (UINT_PTR)pxi->hDDESent) {
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }

        WOWGLOBALFREE((HANDLE)uiHi);

        pxi->state = XST_EXECACKRCVD;
        pxi->wStatus = (WORD)uiLo;

        if (TransactionComplete(pxi, (HDDEDATA)((ULONG_PTR)(pxi->wStatus & DDE_FACK ? 1 : 0)))) {
            goto Cleanup;
        }
    } else {
Cleanup:
        GlobalDeleteAtom(pxi->gaItem); // pxi copy
        UnlinkTransaction(pxi);
        if (pxi->hXact) {
            DestroyHandle(pxi->hXact);
        }
        DDEMLFree(pxi);
    }
    if (msg) {
        FreeDDElParam(msg, lParam);
    }
    return (TRUE);
}



//----------------------------------POKE-------------------------------//


/***************************************************************************\
* ClStartPoke
*
* Description:
* Initiates a poke transaction.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ClStartPoke(
PXACT_INFO pxi)
{
    DWORD dwError;

    IncGlobalAtomCount(pxi->gaItem); // message copy
    dwError = PackAndPostMessage(pxi->pcoi->hwndPartner, 0, WM_DDE_POKE,
            pxi->pcoi->hwndConv, 0, (UINT_PTR)pxi->hDDESent, pxi->gaItem);
    if (dwError) {
        SetLastDDEMLError(pxi->pcoi->pcii, dwError);
        GlobalDeleteAtom(pxi->gaItem); // message copy
        return (FALSE);
    }

    pxi->state = XST_POKESENT;
    pxi->pfnResponse = (FNRESPONSE)ClRespPokeAck;
    LinkTransaction(pxi);
    return (TRUE);
}


/***************************************************************************\
* SvSpontPoke
*
* Description:
* Handles WM_DDE_POKE messages.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL SvSpontPoke(
PSVR_CONV_INFO psi,
LPARAM lParam)
{
    UINT_PTR uiHi;
    HANDLE hDDE = 0;
    HDDEDATA hData;
    ULONG_PTR dwRet = 0;
    DWORD dwError;
    WORD wFmt, wStatus;
    LATOM al;

    // See what we have

    UnpackDDElParam(WM_DDE_DATA, lParam, (PUINT_PTR)&hDDE, &uiHi);

    if (!(psi->ci.pcii->afCmd & CBF_FAIL_POKES)) {
        if (!hDDE) {
            goto Ack;
        }
        if (!ExtractDDEDataInfo(hDDE, &wStatus, &wFmt)) {
            FreeDDEData(hDDE, FALSE, TRUE);             // free message data
            goto Ack;
        }

        hData = InternalCreateDataHandle(psi->ci.pcii, (LPBYTE)hDDE, (DWORD)-1, 0,
                HDATA_NOAPPFREE | HDATA_READONLY, 0, 0);
        if (!hData) {
            SetLastDDEMLError(psi->ci.pcii, DMLERR_MEMORY_ERROR);
            FreeDDEData(hDDE, FALSE, TRUE);       // free message data
            goto Ack;                             // Nack it.
            return(TRUE);
        }

        al = GlobalToLocalAtom((GATOM)uiHi);
            dwRet = (ULONG_PTR)DoCallback(psi->ci.pcii, XTYP_POKE,
                    wFmt, psi->ci.hConv,
                    NORMAL_HSZ_FROM_LATOM(psi->ci.laTopic),
                    NORMAL_HSZ_FROM_LATOM(al),
                    hData, 0, 0);
        DeleteAtom(al);
        UnpackAndFreeDDEMLDataHandle(hData, FALSE);
    }
    if (dwRet == (ULONG_PTR)CBR_BLOCK) {

        // Note: this code makes an app that return s CBR_BLOCK unable to
        // access the data after the callback return .

        return (FALSE);
    }
    if (dwRet & DDE_FACK) {
        FreeDDEData(hDDE, FALSE, TRUE);
    }

Ack:
    dwRet &= ~DDE_FACKRESERVED;
    dwError = PackAndPostMessage(psi->ci.hwndPartner, WM_DDE_POKE, WM_DDE_ACK,
            psi->ci.hwndConv, lParam, dwRet, uiHi);
    if (dwError) {
        SetLastDDEMLError(psi->ci.pcii, dwError);
    }
    return (TRUE);
}


/***************************************************************************\
* ClRespPokeAck
*
* Description:
* Response to a WM_DDE_ACK message in response to a WM_DDE_POKE message.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ClRespPokeAck(
PXACT_INFO pxi,
UINT msg,
LPARAM lParam)
{
    UINT_PTR uiLo, uiHi;

    if (msg) {
        if (msg != WM_DDE_ACK) {
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }

        UnpackDDElParam(WM_DDE_ACK, lParam, &uiLo, &uiHi);
        if ((GATOM)uiHi != pxi->gaItem) {
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }

        GlobalDeleteAtom((ATOM)uiHi); // message copy

        pxi->state = XST_POKEACKRCVD;
        pxi->wStatus = (WORD)uiLo;

        if (!((WORD)uiLo & DDE_FACK)) {
            //
            // NACKs make it our business to free the poked data.
            //
            FreeDDEData(pxi->hDDESent, FALSE, TRUE);
        }

        if (TransactionComplete(pxi,
                (HDDEDATA)((ULONG_PTR)(pxi->wStatus & DDE_FACK ? 1 : 0)))) {
            goto Cleanup;
        }
    } else {
Cleanup:
        GlobalDeleteAtom(pxi->gaItem); // pxi copy
        UnlinkTransaction(pxi);
        if (pxi->hXact) {
            DestroyHandle(pxi->hXact);
        }
        DDEMLFree(pxi);
    }
    if (msg) {
        FreeDDElParam(msg, lParam);
    }
    return (TRUE);
}


//-------------------------------REQUEST-------------------------------//

/***************************************************************************\
* ClStartRequest
*
* Description:
* Start a request transaction.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ClStartRequest(
PXACT_INFO pxi)
{
    DWORD dwError;

    IncGlobalAtomCount(pxi->gaItem); // message copy
    dwError = PackAndPostMessage(pxi->pcoi->hwndPartner, 0, WM_DDE_REQUEST,
            pxi->pcoi->hwndConv, 0, pxi->wFmt, pxi->gaItem);
    if (dwError) {
        SetLastDDEMLError(pxi->pcoi->pcii, dwError);
        GlobalDeleteAtom(pxi->gaItem); // message copy
        return (FALSE);
    }

    pxi->state = XST_REQSENT;
    pxi->pfnResponse = (FNRESPONSE)ClRespRequestData;
    LinkTransaction(pxi);
    return (TRUE);
}



/***************************************************************************\
* SvSpontRequest
*
* Description:
* Respond to a WM_DDE_REQUEST message.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL SvSpontRequest(
PSVR_CONV_INFO psi,
LPARAM lParam)
{
    HANDLE hDDE = 0;
    HDDEDATA hDataRet;
    WORD wFmt, wStatus;
    DWORD dwError;
    LATOM la;

    if (psi->ci.pcii->afCmd & CBF_FAIL_REQUESTS) {
        goto Nack;
    }
    // See what we have

    // UnpackDDElParam(lParam, WM_DDE_REQUEST, .... Requests arn't packed
    wFmt = LOWORD(lParam);
    la = GlobalToLocalAtom((GATOM)HIWORD(lParam));
    hDataRet = DoCallback(psi->ci.pcii, XTYP_REQUEST,
            wFmt, psi->ci.hConv,
            NORMAL_HSZ_FROM_LATOM(psi->ci.laTopic),
            NORMAL_HSZ_FROM_LATOM(la),
            (HDDEDATA)0, 0, 0);
    DeleteAtom(la);

    if (hDataRet == CBR_BLOCK) {
        return (FALSE);
    }

    if (hDataRet) {

        hDDE = UnpackAndFreeDDEMLDataHandle(hDataRet, FALSE);
        if (!hDDE) {
            SetLastDDEMLError(psi->ci.pcii, DMLERR_DLL_USAGE);
            goto Nack;
        }
        if (!ExtractDDEDataInfo(hDDE, &wStatus, &wFmt)) {
            SetLastDDEMLError(psi->ci.pcii, DMLERR_DLL_USAGE);
            goto Nack;
        }
        if (!(wStatus & DDE_FRELEASE)) {
            // Its APPOWNED or relayed from another server - only safe
            // thing to do is use a copy.
            hDDE = CopyDDEData(hDDE, FALSE);
            if (!hDDE) {
                SetLastDDEMLError(psi->ci.pcii, DMLERR_MEMORY_ERROR);
                goto Nack;
            }
        }

        // Keep it simple, DDEML servers never ask for acks from requests.

        wStatus = DDE_FRELEASE | DDE_FREQUESTED;
        AllocAndSetDDEData((LPBYTE)hDDE, (DWORD)-1, wStatus, wFmt);

        // just reuse HIWORD(lParam) (aItem) - message copy
        if (dwError = PackAndPostMessage(psi->ci.hwndPartner, WM_DDE_REQUEST,
                WM_DDE_DATA, psi->ci.hwndConv, 0, (UINT_PTR)hDDE, HIWORD(lParam))) {
            SetLastDDEMLError(psi->ci.pcii, dwError);
            GlobalDeleteAtom(HIWORD(lParam)); // message copy
        }

    } else {
Nack:
        // just reuse HIWORD(lParam) (aItem) - message copy
        dwError = PackAndPostMessage(psi->ci.hwndPartner, WM_DDE_REQUEST,
                WM_DDE_ACK, psi->ci.hwndConv, 0, 0, HIWORD(lParam));
        if (dwError) {
            SetLastDDEMLError(psi->ci.pcii, dwError);
            GlobalDeleteAtom(HIWORD(lParam)); // message copy
        }
    }

    return (TRUE);
}


/***************************************************************************\
* ClRespRequestData
*
* Description:
* Handles response to either a WM_DDE_ACK or WM_DDE_DATA in response to
* a WM_DDE_REQUEST message.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ClRespRequestData(
PXACT_INFO pxi,
UINT msg,
LPARAM lParam)
{
    UINT_PTR uiLo, uiHi;
    WORD wFmt, wStatus;
    DWORD dwError;

    if (msg) {
        switch (msg) {
        case WM_DDE_DATA:
            UnpackDDElParam(WM_DDE_DATA, lParam, (PUINT_PTR)&pxi->hDDEResult, &uiHi);
            if (!pxi->hDDEResult) {
                // must be an advise data message with NODATA.
                return (ClSpontAdviseData((PCL_CONV_INFO)pxi->pcoi, lParam));
            }
            if (!ExtractDDEDataInfo(pxi->hDDEResult, &wStatus, &wFmt)) {
                return (ClSpontAdviseData((PCL_CONV_INFO)pxi->pcoi, lParam));
            }
            if (!(wStatus & DDE_FREQUESTED)) {
                // must be advise data
                return (ClSpontAdviseData((PCL_CONV_INFO)pxi->pcoi, lParam));
            }
            if (wStatus & DDE_FACKREQ) {

                // if DDE_FRELEASE is not set, and this is a synchronous
                // transaction, we need to make a copy here so the user
                // can free at his leisure.

                // reuse uiHi - message copy
                dwError = PackAndPostMessage(pxi->pcoi->hwndPartner,
                        WM_DDE_DATA, WM_DDE_ACK, pxi->pcoi->hwndConv, 0,
                        pxi->wFmt == wFmt && pxi->gaItem == (GATOM)uiHi ?
                            DDE_FACK : 0, uiHi);
                if (dwError) {
                    SetLastDDEMLError(pxi->pcoi->pcii, dwError);
                }
            } else {
                GlobalDeleteAtom((GATOM)uiHi);     // message copy
            }
            if (wFmt != pxi->wFmt || (GATOM)uiHi != pxi->gaItem) {
                /*
                 * BOGUS returned data!  Just free it and make it look like
                 * a NACK
                 */
                FreeDDEData(pxi->hDDEResult, FALSE, TRUE);
                pxi->hDDEResult = 0;
                if (TransactionComplete(pxi, 0)) {
                    goto Cleanup;
                }
            } else {
                if (TransactionComplete(pxi, (HDDEDATA)-1)) {
                    goto Cleanup;
                }
            }
            break;

        case WM_DDE_ACK:
            UnpackDDElParam(WM_DDE_ACK, lParam, &uiLo, &uiHi);
            if ((GATOM)uiHi != pxi->gaItem) {
                return(SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
            }
            pxi->state = XST_DATARCVD;
            pxi->wStatus = (WORD)uiLo;
            GlobalDeleteAtom((GATOM)uiHi); // message copy
            if (TransactionComplete(pxi, 0)) {
                goto Cleanup;
            }
            break;

        default:
            return (SpontaneousClientMessage((PCL_CONV_INFO)pxi->pcoi, msg, lParam));
        }

    } else {

Cleanup:
        GlobalDeleteAtom(pxi->gaItem); // pxi copy
        if (pxi->hDDEResult) {
            FreeDDEData(pxi->hDDEResult, FALSE, TRUE);  // free message data
        }
        UnlinkTransaction(pxi);
        DDEMLFree(pxi);
    }
    if (msg) {
        FreeDDElParam(msg, lParam);
    }
    return (TRUE);
}

//----------------------SPONTANEOUS CLIENT MESSAGE---------------------//

/***************************************************************************\
* SpontaneousClientMessage
*
* Description:
* General unexpected message client side handler.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL SpontaneousClientMessage(
PCL_CONV_INFO pci,
UINT msg,
LPARAM lParam)
{
    switch (msg) {
    case WM_DDE_DATA:
        return (ClSpontAdviseData(pci, lParam));
        break;

    default:
        DumpDDEMessage(!(pci->ci.state & ST_INTRA_PROCESS), msg, lParam);
        ShutdownConversation((PCONV_INFO)pci, TRUE);
        return (TRUE);
    }
}

//----------------------SPONTANEOUS SERVER MESSAGE---------------------//

/***************************************************************************\
* SpontaneousServerMessage
*
* Description:
* General unexpected message server side handler.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL SpontaneousServerMessage(
PSVR_CONV_INFO psi,
UINT msg,
LPARAM lParam)
{
    switch (msg) {
    case WM_DDE_ADVISE:
        return (SvSpontAdvise(psi, lParam));
        break;

    case WM_DDE_UNADVISE:
        return (SvSpontUnadvise(psi, lParam));
        break;

    case WM_DDE_EXECUTE:
        return (SvSpontExecute(psi, lParam));
        break;

    case WM_DDE_POKE:
        return (SvSpontPoke(psi, lParam));
        break;

    case WM_DDE_REQUEST:
        return (SvSpontRequest(psi, lParam));
        break;

    default:
        DumpDDEMessage(!(psi->ci.state & ST_INTRA_PROCESS), msg, lParam);

        /*
         * It use to call ShutdownConversation here. Don't call it
         * anymore. Fix for bugs: 49063, 70906
         */
        //ShutdownConversation((PCONV_INFO)psi, TRUE);
        return (TRUE);
    }
}



//-------------------------HELPER FUNCTIONS----------------------------//



/***************************************************************************\
* AllocAndSetDDEData
*
* Description:
* Worker function to create a data handle of size cb with wStatus and
* wFmt initialized. If cb == -1 pSrc is assumed to be a valid hDDE
* that is to have its data set.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
HANDLE AllocAndSetDDEData(
LPBYTE pSrc,
DWORD cb,
WORD wStatus,
WORD wFmt) // a 0 format implied execute data
{
    HANDLE hDDE;
    DWORD cbOff;
    PDDE_DATA pdde;
    DWORD fCopyIt;

    if (cb == -1) {
        hDDE = (HANDLE)pSrc;
        cb = (DWORD)GlobalSize(hDDE);
        fCopyIt = FALSE;
    } else {
        hDDE = UserGlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE | GMEM_ZEROINIT,
                (wFmt ? (cb + 4) : cb));
        fCopyIt = (pSrc != NULL);
    }
    if (hDDE == NULL) {
        return(0);
    }
    USERGLOBALLOCK(hDDE, pdde);
    if (pdde == NULL) {
        WOWGLOBALFREE(hDDE);
        return (0);
    }
    if (wFmt) {
        pdde->wStatus = wStatus;
        pdde->wFmt = wFmt;
        cbOff = 4;
    } else {
        cbOff = 0;
    }
    if (fCopyIt) {
        RtlCopyMemory((PBYTE)pdde + cbOff, pSrc, cb);
    }
    USERGLOBALUNLOCK(hDDE);

    return (hDDE);
}



/***************************************************************************\
* PackAndPostMessage
*
* Description:
* Worker function to provide common functionality. An error code is
* return ed on failure. 0 on success.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
DWORD PackAndPostMessage(
HWND hwndTo,
UINT msgIn,
UINT msgOut,
HWND hwndFrom,
LPARAM lParam,
UINT_PTR uiLo,
UINT_PTR uiHi)
{
    DWORD retval;

    lParam = ReuseDDElParam(lParam, msgIn, msgOut, uiLo, uiHi);
    if (!lParam) {
        return (DMLERR_MEMORY_ERROR);
    }
    CheckDDECritIn;
    LeaveDDECrit;
    CheckDDECritOut;

    retval = (DWORD)PostMessage(hwndTo, msgOut, (WPARAM)hwndFrom, lParam);
    switch (retval) {
    case FAIL_POST:
#if (FAIL_POST != FALSE)
#error FAIL_POST must be defined as PostMessage's failure return value.
#endif
        FreeDDElParam(msgOut, lParam);
        RIPMSG0(RIP_WARNING, "PostMessage failed.");
        /* Fall through */

    case FAILNOFREE_POST:
        retval = DMLERR_POSTMSG_FAILED;
        break;

    default:
#if (FAKE_POST != TRUE)
#error FAKE_POST must be defined as PostMessage's success return value.
#endif
        UserAssert(retval == TRUE);
        retval = 0;
    }

    EnterDDECrit;
    return (retval);
}



/***************************************************************************\
* ExtractDDEDataInfo
*
* Description:
* Worker function to retrieve wStatus and wFmt from a standard DDE data
* handle - NOT FOR EXECUTE HANDLES.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL ExtractDDEDataInfo(
HANDLE hDDE,
LPWORD pwStatus,
LPWORD pwFmt)
{
    PDDE_DATA pdde;

    USERGLOBALLOCK(hDDE, pdde);
    if (pdde == NULL) {
        return (FALSE);
    }
    *pwStatus = pdde->wStatus;
    *pwFmt = pdde->wFmt;
    USERGLOBALUNLOCK(hDDE);
    return (TRUE);
}



/***************************************************************************\
* TransactionComplete
*
* Description:
* Called when a response function completes a transaction. pxi->wStatus,
* pxi->flags, pxi->wFmt, pxi->gaItem, pxi->hXact, and hData are expected
* to be set apropriately for a XTYP_XACT_COMPLETE callback.
*
* fCleanup is returned - TRUE implies the calling function needs to
* cleanup its pxi before returning.  (fAsync case.)
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
BOOL TransactionComplete(
PXACT_INFO pxi,
HDDEDATA hData)
{
    LATOM al;
    BOOL fMustFree;

    if (pxi->flags & XIF_ABANDONED) {
        UserAssert(!(pxi->flags & XIF_SYNCHRONOUS));
        return (TRUE);
    }
    pxi->flags |= XIF_COMPLETE;
    if (pxi->flags & XIF_SYNCHRONOUS) {
        PostMessage(pxi->pcoi->hwndConv, WM_TIMER, TID_TIMEOUT, 0);
        return (FALSE);
    } else {
        if (hData == (HDDEDATA)(-1)) {
            fMustFree = TRUE;
            hData = InternalCreateDataHandle(pxi->pcoi->pcii,
                (LPBYTE)pxi->hDDEResult, (DWORD)-1, 0,
                HDATA_NOAPPFREE | HDATA_READONLY, 0, 0);
        } else {
            fMustFree = FALSE;
        }
        al = GlobalToLocalAtom(pxi->gaItem);

        if (!(pxi->wStatus & DDE_FACK)) {
            if (pxi->wStatus & DDE_FBUSY) {
                SetLastDDEMLError(pxi->pcoi->pcii, DMLERR_BUSY);
            } else {
                SetLastDDEMLError(pxi->pcoi->pcii, DMLERR_NOTPROCESSED);
            }
        }

        /*
         * During the callback the app may disconnect or otherwise kill
         * this conversation so we unlink the pxi FIRST so cleanup code
         * doesn't destroy it before this transaction code exits.
         */
        UnlinkTransaction(pxi);

        DoCallback(
            pxi->pcoi->pcii,
            (WORD)XTYP_XACT_COMPLETE,
            pxi->wFmt,
            pxi->pcoi->hConv,
            NORMAL_HSZ_FROM_LATOM(pxi->pcoi->laTopic),
            (HSZ)al,
            hData,
            (ULONG_PTR)pxi->hXact,
            (DWORD)pxi->wStatus);
        DeleteAtom(al);
        if (fMustFree) {
            InternalFreeDataHandle(hData, FALSE);
            pxi->hDDEResult = 0;
        }

        /*
         * during the callback is the only time the app has to access the
         * transaction information.   pxi->hXact will be invalid once he
         * returns.
         */
        if (pxi->hXact) {
            DestroyHandle(pxi->hXact);
            pxi->hXact = 0;
        }
        return (TRUE);
    }
}



/***************************************************************************\
* UnpackAndFreeDDEMLDataHandle
*
* Description:
* Removes DDEML data handle wrapping from a DDE data handle. If the
* data handle is APPOWNED the wrapping is NOT freed. The hDDE is
* return ed or 0 on failure. If fExec is FALSE, this call fails on
* HDATA_EXECUTE type handles.
*
* History:
* 11-19-91 sanfords Created.
\***************************************************************************/
HANDLE UnpackAndFreeDDEMLDataHandle(
HDDEDATA hData,
BOOL fExec)
{
    PDDEMLDATA pdd;
    HANDLE hDDE;

    CheckDDECritIn;

    if (hData == 0) {
        return (0);
    }
    pdd = (PDDEMLDATA)ValidateCHandle((HANDLE)hData, HTYPE_DATA_HANDLE,
            HINST_ANY);
    if (pdd == NULL) {
        return (0);
    }
    if (!fExec && pdd->flags & HDATA_EXECUTE) {
        return (0);
    }

    hDDE = pdd->hDDE;
    if (pdd->flags & HDATA_APPOWNED) {
        return (hDDE); // don't destroy appowned data handles
    }
    DDEMLFree(pdd);
    DestroyHandle((HANDLE)hData);
    return (hDDE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\usercli.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

/****************************** Module Header ******************************\
* Module Name: usercli.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Typedefs, defines, and prototypes that are used exclusively by the User
* client-side DLL.
*
* History:
* 04-27-91 DarrinM      Created from PROTO.H, MACRO.H and STRTABLE.H
\***************************************************************************/

#ifndef _USERCLI_
#define _USERCLI_

#define OEMRESOURCE 1

#include <windows.h>
#include <winnls32.h>

#include <w32gdip.h>
#include <w32err.h>
#include <ddeml.h>
#include "ddemlp.h"
#include "winuserp.h"
#include "w32wow64.h"
#include "winuserk.h"
#include <winnlsp.h>
#include <dde.h>
#include <ddetrack.h>
#include "kbd.h"
#include <wowuserp.h>
#include "immstruc.h"
#include "immuser.h"
#include <winbasep.h>

#include "user.h"
#include "callproc.h"

/*
 * This prototype is needed in client\globals.h which is included unintentionally
 * from usersrv.h
 */
typedef LRESULT (APIENTRY *CFNSCSENDMESSAGE)(HWND, UINT, WPARAM, LPARAM,
        ULONG_PTR, DWORD, BOOL);

/* Prototype needed by globals.h; used in shutdown logging */
typedef BOOL (*PFNREPORTEVENT)(HANDLE, WORD, WORD, DWORD, PSID, WORD, DWORD,
        LPCTSTR *, LPVOID);

/***************************************************************************\
* Typedefs and Macros
*
* Here are defined all types and macros that are shared across the User's
* client-side code modules.  Types and macros that are unique to a single
* module should be defined at the head of that module, not in this file.
*
\***************************************************************************/

#define MIRRORED_HDC(hdc)     (GetLayout(hdc) & LAYOUT_RTL)
#define MIRRORED_HWND(hwnd)   (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)

#if DBG

__inline void DebugUserGlobalUnlock(HANDLE h)
{
    UserAssert(
            "GlobalUnlock on bad handle" &&
            !(GlobalFlags(h) == GMEM_INVALID_HANDLE));

    GlobalUnlock((HANDLE) h);
}

/*
 * Bug 262144 - joejo
 *
 * Changed function to accept a pointer to the handle so we
 * can trash the handle and return it as trashed.
 *
 * Added a local handle variable to accept the return from GlobalFree
 * so we can return it as expected.
 *
 * Trash incoming handle freed so we can track any invalid access on
 * it after it's been free'd.
 */
__inline HANDLE DebugUserGlobalFree(HANDLE* ph)
{
    HANDLE th;

    UserAssert(
            "GlobalFree on bad handle" &&
            !(GlobalFlags(*ph) == GMEM_INVALID_HANDLE));

    th = GlobalFree(*ph);
#if defined(_WIN64)
    *ph = (HANDLE)(PVOID)0xBAADF00DBAADF00D;
#else
    *ph = (HANDLE)(PVOID)0xBAADF00D;
#endif
    return th;
}

__inline HANDLE DebugUserGlobalAlloc(UINT uFlags, SIZE_T dwBytes)
{
    HANDLE h = GlobalAlloc(uFlags, dwBytes);

    /*
     * Assert that FreeDDElParam and _ClientFreeDDEHandle assumption is correct.
     */
    if (h != NULL) {
        UserAssert(h > (HANDLE)0xFFFF);
    }

    return h;
}

#define USERGLOBALUNLOCK(h)             DebugUserGlobalUnlock((HANDLE)(h))
#define UserGlobalFree(h)               DebugUserGlobalFree((HANDLE*)(&h))
#define UserGlobalAlloc(flags, size)    DebugUserGlobalAlloc(flags, size)

#else

#define USERGLOBALUNLOCK(h)             GlobalUnlock((HANDLE)(h))
#define UserGlobalFree(h)               GlobalFree((HANDLE)(h))
#define UserGlobalAlloc(flags, size)    GlobalAlloc(flags, size)
#endif

#define USERGLOBALLOCK(h, p)   p = GlobalLock((HANDLE)(h))
#define UserGlobalReAlloc(pmem, cnt, flags) GlobalReAlloc(pmem,cnt,flags)
#define UserGlobalSize(pmem)                GlobalSize(pmem)
#define WOWGLOBALFREE(pmem)                 GlobalFree(pmem)

#define RESERVED_MSG_BITS   (0xFFFE0000)



/*
 * A macro for testing bits in the message bit-arrays.  Messages in the
 * the bit arrays must be processed
 */
#define FDEFWINDOWMSG(msg, procname) \
    ((msg <= (gSharedInfo.procname.maxMsgs)) && \
            ((gSharedInfo.procname.abMsgs)[msg / 8] & (1 << (msg & 7))))
#define FWINDOWMSG(msg, fnid) \
    ((msg <= (gSharedInfo.awmControl[fnid - FNID_START].maxMsgs)) && \
            ((gSharedInfo.awmControl[fnid - FNID_START].abMsgs)[msg / 8] & (1 << (msg & 7))))

#define CsSendMessage(hwnd, msg, wParam, lParam, xParam, pfn, bAnsi) \
        (((msg) >= WM_USER) ? \
            NtUserMessageCall(hwnd, msg, wParam, lParam, xParam, pfn, bAnsi) : \
            gapfnScSendMessage[MessageTable[msg].iFunction](hwnd, msg, wParam, lParam, xParam, pfn, bAnsi))

#define GetWindowProcess(hwnd) NtUserQueryWindow(hwnd, WindowProcess)
#define GETPROCESSID() (NtCurrentTeb()->ClientId.UniqueProcess)
#define GETTHREADID()  (NtCurrentTeb()->ClientId.UniqueThread)

/*
 * Macro to mask off uniqueness bits for WOW handles
 */
#define SAMEWOWHANDLE(h1, h2)  ((BOOL)!(((ULONG_PTR)(h1) ^ (ULONG_PTR)(h2)) & 0xffff))
#define DIFFWOWHANDLE(h1, h2)  (!SAMEWOWHANDLE(h1, h2))

/*
 * This macro can check to see if a function pointer is a server side
 * procedure.
 */
// #define ISSERVERSIDEPROC(p) (((DWORD)p) >= FNID_START && ((DWORD)p) <= FNID_END)

/*
 * For callbacks to the client - for msg and hook thunks, callback addresses
 * are passed as addresses, not function indexes as they are from client to
 * server.
 */
typedef INT_PTR (WINAPI *GENERICPROC)();

#define CALLPROC(p) ((GENERICPROC)p)
#define PACTCTXT(pwnd) (pwnd ? pwnd->pActCtx : NULL)

extern PFNWOWDLGPROCEX      pfnWowDlgProcEx;
extern PFNWOWWNDPROCEX      pfnWowWndProcEx;

BOOL UserCallDlgProcCheckWow(PACTIVATION_CONTEXT pActCtx, DLGPROC pfn,
        HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, PVOID pww, INT_PTR * pret);
LRESULT UserCallWinProcCheckWow(PACTIVATION_CONTEXT pActCtx, WNDPROC pfn,
        HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, PVOID pww, BOOL fEnableLiteHooks);


/***************************************************************************\
* IsMsgOverride
*
* Returns if a message should be sent to USERAPIHOOK OverrideWndProc()
* hooks.  The message should only be sent if its "index" is within the range
* specified by the hook and its "bit" is on.  It is very important to
* actually check guah.cbMsgMask instead of sizeof(gbLiteHookMsg) because the
* hook may have a smaller MsgMask in which case anything past the end fails.
*
* History:
* 27-Apr-2000  jstall     Created
\***************************************************************************/

__inline BOOL IsMsgOverride(UINT msg, MSGMASK * pmm)
{
    UINT idxMajor = msg / 8;
    if ((pmm->rgb != NULL) && (idxMajor < pmm->cb)) {
        return (pmm->rgb[idxMajor] & (1 << (msg & 7)));
    }

    return FALSE;
}



#define RevalidateHwnd(hwnd)    ((PWND)HMValidateHandleNoSecure(hwnd, TYPE_WINDOW))

#define VALIDATEHMENU(hmenu)        ((PMENU)HMValidateHandle(hmenu, TYPE_MENU))
#define VALIDATEHMONITOR(hmonitor)  ((PMONITOR)HMValidateSharedHandle(hmonitor, TYPE_MONITOR))


/*
 * REBASE macros take kernel desktop addresses and convert them into
 * user addresses.
 *
 * REBASEALWAYS converts a kernel address contained in an object
 * REBASEPWND casts REBASEALWAYS to a PWND
 * REBASE only converts if the address is in kernel space.  Also works for NULL
 * REBASEPTR converts a random kernel address
 */

#define REBASEALWAYS(p, elem) ((PVOID)((KERNEL_ULONG_PTR)(p) + ((KERNEL_ULONG_PTR)(p)->elem - (KERNEL_ULONG_PTR)(p)->head.pSelf)))
#define REBASEPTR(obj, p) ((PVOID)((KERNEL_ULONG_PTR)(p) - ((KERNEL_ULONG_PTR)(obj)->head.pSelf - (KERNEL_ULONG_PTR)(obj))))

#define REBASE(p, elem) ((KERNEL_ULONG_PTR)((p)->elem) <= (KERNEL_ULONG_PTR)gHighestUserAddress ? \
        ((PVOID)(KERNEL_ULONG_PTR)(p)->elem) : REBASEALWAYS(p, elem))
#define REBASEPWND(p, elem) ((PWND)REBASE(p, elem))

#ifndef USEREXTS

PTHREADINFO PtiCurrent(VOID);

/*
 * Window Proc Window Validation macro. This macro assumes
 * that pwnd and hwnd are existing variables pointing to the window.
 * Checking the BUTTON is for Mavis Beacon.
 */

#define VALIDATECLASSANDSIZE(pwnd, inFNID)                                      \
    switch ((pwnd)->fnid) {                                                     \
    case inFNID:                                                                \
        break;                                                                  \
                                                                                \
    case 0:                                                                     \
        if ((pwnd->cbwndExtra + sizeof(WND)) < (DWORD)(CBFNID(inFNID))) {       \
            RIPMSG3(RIP_ERROR,                                                  \
                   "(%#p %lX) needs at least (%ld) window words for this proc", \
                    pwnd, pwnd->cbwndExtra,                                     \
                    (DWORD)(CBFNID(inFNID)) - sizeof(WND));                     \
            return 0;                                                           \
        }                                                                       \
                                                                                \
        if (inFNID == FNID_BUTTON && *((KPULONG_PTR)(pwnd + 1))) {              \
                                                                                \
            RIPMSG3(RIP_WARNING, "Window (%#p) fnid = %lX overrides "           \
                "the extra pointer with %#p\n",                                 \
                pwnd, inFNID, *((KPULONG_PTR)(pwnd + 1)));                      \
                                                                                \
            NtUserSetWindowLongPtr(hwnd, 0, 0, FALSE);                          \
        }                                                                       \
                                                                                \
        NtUserSetWindowFNID(hwnd, inFNID);                                      \
        break;                                                                  \
                                                                                \
    case (inFNID | FNID_CLEANEDUP_BIT):                                         \
    case (inFNID | FNID_DELETED_BIT):                                           \
    case (inFNID | FNID_STATUS_BITS):                                           \
        return 0;                                                               \
                                                                                \
    default:                                                                    \
        RIPMSG3(RIP_WARNING,                                                    \
              "Window (%#p) not of correct class; fnid = %lX not %lX",          \
              (pwnd), (DWORD)((pwnd)->fnid), (DWORD)(inFNID));                  \
        return 0;                                                               \
    }

/*
 * This macro initializes the lookaside entry for a control.  It assumes
 * that pwnd and hwnd are existing variables pointing to the control's
 * windows and that fInit exists as a BOOL initialization flag.
 */
#define INITCONTROLLOOKASIDE(plaType, type, pwnditem, count)                \
    if (!*((KPULONG_PTR)(pwnd + 1))) {                                      \
        P ## type pType;                                                    \
        if (fInit) {                                                        \
            if (!NT_SUCCESS(InitLookaside(plaType, sizeof(type), count))) { \
                NtUserSetWindowFNID(hwnd, FNID_CLEANEDUP_BIT);              \
                NtUserDestroyWindow(hwnd);                                  \
                return FALSE;                                               \
            }                                                               \
            fInit = FALSE;                                                  \
        }                                                                   \
        if ((pType = (P ## type)AllocLookasideEntry(plaType))) {            \
            NtUserSetWindowLongPtr(hwnd, 0, (LONG_PTR)pType, FALSE);        \
            Lock(&(pType->pwnditem), pwnd);                                 \
        } else {                                                            \
            NtUserSetWindowFNID(hwnd, FNID_CLEANEDUP_BIT);                  \
            NtUserDestroyWindow(hwnd);                                      \
            return FALSE;                                                   \
        }                                                                   \
    }

#endif

#define ISREMOTESESSION()   (NtCurrentPeb()->SessionId != USER_SHARED_DATA->ActiveConsoleId)


/*
 * Bitmap related macroes.
 */
#define SetBestStretchMode(hdc, planes, bpp) \
    SetStretchBltMode(hdc, (((planes) * (bpp)) == 1 ? BLACKONWHITE : COLORONCOLOR))

#define BitmapSize(cx, cy, planes, bits) \
        (BitmapWidth(cx, bits) * (cy) * (planes))

#define BitmapWidth(cx, bpp)  (((((cx)*(bpp)) + 31) & ~31) >> 3)

#define RGBX(rgb)  RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb))

/*
 * Typedefs used for capturing string arguments to be passed
 * to the kernel.
 */
typedef struct _IN_STRING {
    UNICODE_STRING strCapture;
    PUNICODE_STRING pstr;
    BOOL fAllocated;
} IN_STRING, *PIN_STRING;

typedef struct _LARGE_IN_STRING {
    LARGE_UNICODE_STRING strCapture;
    PLARGE_UNICODE_STRING pstr;
    BOOL fAllocated;
} LARGE_IN_STRING, *PLARGE_IN_STRING;


/*
 * Lookaside definitions
 */
typedef struct _LOOKASIDE {
    PVOID LookasideBase;
    PVOID LookasideBounds;
    ZONE_HEADER LookasideZone;
    DWORD EntrySize;
#if DBG
    ULONG AllocHiWater;
    ULONG AllocCalls;
    ULONG AllocSlowCalls;
    ULONG DelCalls;
    ULONG DelSlowCalls;
#endif // DBG
} LOOKASIDE, *PLOOKASIDE;

NTSTATUS InitLookaside(PLOOKASIDE pla, DWORD cbEntry, DWORD cEntries);
PVOID AllocLookasideEntry(PLOOKASIDE pla);
void FreeLookasideEntry(PLOOKASIDE pla, PVOID pEntry);

/***************************************************************************\
*
* Thread and structure locking routines - we'll just define these to do
* nothing for now until we figure out what needs to be done
*
\***************************************************************************/

#undef ThreadLock
#undef ThreadLockAlways
#undef ThreadLockWithPti
#undef ThreadLockAlwaysWithPti
#undef ThreadUnlock
#undef Lock
#undef Unlock
#define CheckLock(pobj)
#define ThreadLock(pobj, ptl) DBG_UNREFERENCED_LOCAL_VARIABLE(*ptl)
#define ThreadLockAlways(pobj, ptl) DBG_UNREFERENCED_LOCAL_VARIABLE(*ptl)
#define ThreadLockWithPti(pti, pobj, ptl) DBG_UNREFERENCED_LOCAL_VARIABLE(*ptl)
#define ThreadLockAlwaysWithPti(pti, pobj, ptl) DBG_UNREFERENCED_LOCAL_VARIABLE(*ptl)
#define ThreadUnlock(ptl) (ptl)
#define Lock(ppobj, pobj) (*ppobj = pobj)
#define Unlock(ppobj) (*ppobj = NULL)

#if !defined(_USERRTL_) && !defined(USEREXTS)
typedef struct _TL {
    int iBogus;
} TL;
#endif

/***************************************************************************\
*
* Button Controls
*
\***************************************************************************/

/*
 *  Note: The button data structures are now found in user.h because the
 *        kernel needs to handle a special case of SetWindowWord on index
 *        0L to change the state of the button.
 */

#define BUTTONSTATE(pbutn)   (pbutn->buttonState)

#define BST_CHECKMASK       0x0003
#define BST_INCLICK         0x0010
#define BST_CAPTURED        0x0020
#define BST_MOUSE           0x0040
#define BST_DONTCLICK       0x0080
#define BST_INBMCLICK       0x0100

#define PBF_PUSHABLE     0x0001
#define PBF_DEFAULT      0x0002

/*
 * BNDrawText codes
 */
#define DBT_TEXT    0x0001
#define DBT_FOCUS   0x0002


/***************************************************************************\
*
* ComboBox
*
\***************************************************************************/

/*
 * ID numbers (hMenu) for the child controls in the combo box
 */
#define CBLISTBOXID 1000
#define CBEDITID    1001
#define CBBUTTONID  1002

/*
 * For CBOX.c. BoxType field, we define the following combo box styles. These
 * numbers are the same as the CBS_ style codes as defined in windows.h.
 */
#define SDROPPABLE      CBS_DROPDOWN
#define SEDITABLE       CBS_SIMPLE


#define SSIMPLE         SEDITABLE
#define SDROPDOWNLIST   SDROPPABLE
#define SDROPDOWN       (SDROPPABLE | SEDITABLE)


/*
 * CBOX.OwnerDraw & LBIV.OwnerDraw types
 */
#define OWNERDRAWFIXED 1
#define OWNERDRAWVAR   2

#define UPPERCASE   1
#define LOWERCASE   2

#define CaretCreate(plb)    ((plb)->fCaret = TRUE)

/*
 * combo.h - Include file for combo boxes.
 */

/*
 * This macro is used to isolate the combo box style bits.  Ie if it the combo
 * box is simple, atomic, dropdown, or a dropdown listbox.
 */
#define COMBOBOXSTYLE(style)   ((LOBYTE(style)) & 3)

#define IsComboVisible(pcbox) (!pcbox->fNoRedraw && IsVisible(pcbox->spwnd))

/*
 * Note that I depend on the fact that these CBN_ defines are the same as
 * their listbox counterparts.  These defines are found in windows.h.
 * #define CBN_ERRSPACE  (-1)
 * #define CBN_SELCHANGE 1
 * #define CBN_DBLCLK    2
 */


/***************************************************************************\
*
* Edit Control Types/Macros
*
\***************************************************************************/

/* Window extra bytes - we need at least this much space for compatibility */
#define CBEDITEXTRA 6

/*
 * NOTE: Text handle is sized as multiple of this constant
 *       (should be power of 2).
 */
#define CCHALLOCEXTRA   0x20

/* Maximum width in pixels for a line/rectangle */

#define MAXPIXELWIDTH   30000

#define MAXCLIPENDPOS   32764

/* Limit multiline edit controls to at most 1024 characters on a single line.
 * We will force a wrap if the user exceeds this limit.
 */

#define MAXLINELENGTH   1024

/*
 * Allow an initial maximum of 30000 characters in all edit controls since
 * some apps will run into unsigned problems otherwise.  If apps know about
 * the 64K limit, they can set the limit themselves.
 */
#define MAXTEXT         30000

/*
 * Key modifiers which have been pressed.  Code in KeyDownHandler and
 * CharHandler depend on these exact values.
 */
#define NONEDOWN   0 /* Neither shift nor control down */
#define CTRLDOWN   1 /* Control key only down */
#define SHFTDOWN   2 /* Shift key only down */
#define SHCTDOWN   3 /* Shift and control keys down = CTRLDOWN + SHFTDOWN */
#define NOMODIFY   4 /* Neither shift nor control down */


#define CALLWORDBREAKPROC(proc, pText, iStart, cch, iAction)                \
    (IsWOWProc(proc) ?                                                      \
        (* pfnWowEditNextWord)(pText, iStart, cch, iAction, PtrToUlong(proc)) :  \
        (* proc)(pText, iStart, cch, iAction))

/*
 * Types of undo supported in this ped
 */
#define UNDO_NONE   0  /* We can't undo the last operation. */
#define UNDO_INSERT 1  /* We can undo the user's insertion of characters */
#define UNDO_DELETE 2  /* We can undo the user's deletion of characters */

typedef struct tagUNDO {
    UINT    undoType;          /* Current type of undo we support */
    PBYTE   hDeletedText;      /* Pointer to text which has been deleted (for
                                  undo) -- note, the memory is allocated as fixed
                                */
    ICH     ichDeleted;        /* Starting index from which text was deleted */
    ICH     cchDeleted;        /* Count of deleted characters in buffer */
    ICH     ichInsStart;       /* Starting index from which text was
                                  inserted */
    ICH     ichInsEnd;         /* Ending index of inserted text */
} UNDO, *PUNDO;

#define Pundo(ped)             ((PUNDO)&(ped)->undoType)

/*
 * Length of the buffer for ASCII character width caching: for characters
 * 0x00 to 0xff (field charWidthBuffer in PED structure below).
 * As the upper half of the cache was not used by almost anyone and fixing
 * it's usage required a lot of conversion, we decided to get rid of it
 * MCostea #174031
 */
#define CHAR_WIDTH_BUFFER_LENGTH 128

typedef struct tagED {
    HANDLE  hText;             /* Block of text we are editing */
    ICH     cchAlloc;          /* Number of chars we have allocated for hText
                                */
    ICH     cchTextMax;        /* Max number bytes allowed in edit control
                                */
    ICH     cch;               /* Current number of bytes of actual text
                                */
    ICH     cLines;            /* Number of lines of text */

    ICH     ichMinSel;         /* Selection extent.  MinSel is first selected
                                  char */
    ICH     ichMaxSel;         /* MaxSel is first unselected character */
    ICH     ichCaret;          /* Caret location. Caret is on left side of
                                  char */
    ICH     iCaretLine;        /* The line the caret is on. So that if word
                                * wrapping, we can tell if the caret is at end
                                * of a line of at beginning of next line...
                                */
    ICH     ichScreenStart;    /* Index of left most character displayed on
                                * screen for sl ec and index of top most line
                                * for multiline edit controls
                                */
    ICH     ichLinesOnScreen;  /* Number of lines we can display on screen */
    UINT    xOffset;           /* x (horizontal) scroll position in pixels
                                * (for multiline text horizontal scroll bar)
                                */
    UINT    charPasswordChar;  /* If non null, display this character instead
                                * of the real text. So that we can implement
                                * hidden text fields.
                                */
    int     cPasswordCharWidth;/* Width of password char */

    HWND    hwnd;              /* Window for this edit control */
    PWND    pwnd;              /* Pointer to window */
    RECT    rcFmt;             /* Client rectangle */
    HWND    hwndParent;        /* Parent of this edit control window */

                               /* These vars allow us to automatically scroll
                                * when the user holds the mouse at the bottom
                                * of the multiline edit control window.
                                */
    POINT   ptPrevMouse;       /* Previous point for the mouse for system
                                * timer.
                                */
    UINT    prevKeys;          /* Previous key state for the mouse */


    UINT     fSingle       : 1; /* Single line edit control? (or multiline) */
    UINT     fNoRedraw     : 1; /* Redraw in response to a change? */
    UINT     fMouseDown    : 1; /* Is mouse button down? when moving mouse */
    UINT     fFocus        : 1; /* Does ec have the focus ? */
    UINT     fDirty        : 1; /* Modify flag for the edit control */
    UINT     fDisabled     : 1; /* Window disabled? */
    UINT     fNonPropFont  : 1; /* Fixed width font? */
    UINT     fNonPropDBCS  : 1; /* Non-Propotional DBCS font */
    UINT     fBorder       : 1; /* Draw a border? */
    UINT     fAutoVScroll  : 1; /* Automatically scroll vertically */
    UINT     fAutoHScroll  : 1; /* Automatically scroll horizontally */
    UINT     fNoHideSel    : 1; /* Hide sel when we lose focus? */
    UINT     fDBCS         : 1; /* Are we using DBCS font set for editing? */
    UINT     fFmtLines     : 1; /* For multiline only. Do we insert CR CR LF at
                                * word wrap breaks?
                                */
    UINT     fWrap         : 1; /* Do int  wrapping? */
    UINT     fCalcLines    : 1; /* Recalc ped->chLines array? (recalc line
                                * breaks?)
                                */
    UINT     fEatNextChar  : 1; /* Hack for ALT-NUMPAD stuff with combo boxes.
                                * If numlock is up, we want to eat the next
                                * character generated by the keyboard driver
                                * if user enter num pad ascii value...
                                */
    UINT     fStripCRCRLF  : 1; /* CRCRLFs have been added to text. Strip them
                                * before doing any internal edit control
                                * stuff
                                */
    UINT     fInDialogBox  : 1; /* True if the ml edit control is in a dialog
                                * box and we have to specially treat TABS and
                                * ENTER
                                */
    UINT     fReadOnly     : 1; /* Is this a read only edit control? Only
                                * allow scrolling, selecting and copying.
                                */
    UINT     fCaretHidden  : 1; /* This indicates whether the caret is
                                * currently hidden because the width or height
                                * of the edit control is too small to show it.
                                */
    UINT     fTrueType     : 1; /* Is the current font TrueType? */
    UINT     fAnsi         : 1; /* is the edit control Ansi or unicode */
    UINT     fWin31Compat  : 1; /* TRUE if created by Windows 3.1 app */
    UINT     f40Compat     : 1; /* TRUE if created by Windows 4.0 app */
    UINT     fFlatBorder   : 1; /* Do we have to draw this baby ourself? */
    UINT     fSawRButtonDown : 1;
    UINT     fInitialized  : 1; /* If any more bits are needed, then   */
    UINT     fSwapRoOnUp   : 1; /* Swap reading order on next keyup    */
    UINT     fAllowRTL     : 1; /* Allow RTL processing                */
    UINT     fDisplayCtrl  : 1; /* Display unicode control characters  */
    UINT     fRtoLReading  : 1; /* Right to left reading order         */

    BOOL    fInsertCompChr  :1; /* means WM_IME_COMPOSITION:CS_INSERTCHAR will come */
    BOOL    fReplaceCompChr :1; /* means need to replace current composition str. */
    BOOL    fNoMoveCaret    :1; /* means stick to current caret pos. */
    BOOL    fResultProcess  :1; /* means now processing result. */
    BOOL    fKorea          :1; /* for Korea */
    BOOL    fInReconversion :1; /* In reconversion mode */
    BOOL    fLShift         :1; /* L-Shift pressed with Ctrl */

    WORD    wImeStatus;        /* current IME status */

    WORD    cbChar;            /* count of bytes in the char size (1 or 2 if unicode) */
    LPICH   chLines;           /* index of the start of each line */

    UINT    format;            /* Left, center, or right justify multiline
                                * text.
                                */
    EDITWORDBREAKPROCA lpfnNextWord;  /* use CALLWORDBREAKPROC macro to call */

                               /* Next word function */
    int     maxPixelWidth;     /* WASICH Width (in pixels) of longest line */

    UNDO;                      /* Undo buffer */

    HANDLE  hFont;             /* Handle to the font for this edit control.
                                  Null if system font.
                                */
    int     aveCharWidth;      /* Ave width of a character in the hFont */
    int     lineHeight;        /* Height of a line in the hFont */
    int     charOverhang;      /* Overhang associated with the hFont */
    int     cxSysCharWidth;    /* System font ave width */
    int     cySysCharHeight;   /* System font height */
    HWND    listboxHwnd;       /* ListBox hwnd. Non null if we are a combo
                                  box */
    LPINT   pTabStops;         /* Points to an array of tab stops; First
                                * element contains the number of elements in
                                * the array
                                */
    LPINT   charWidthBuffer;
    BYTE    charSet;           /* Character set for currently selected font
                                * needed for all versions
                                */
    UINT    wMaxNegA;          /* The biggest negative A width, */
    UINT    wMaxNegAcharPos;   /* and how many characters it can span accross */
    UINT    wMaxNegC;          /* The biggest negative C width, */
    UINT    wMaxNegCcharPos;   /* and how many characters it can span accross */
    UINT    wLeftMargin;       /* Left margin width in pixels. */
    UINT    wRightMargin;      /* Right margin width in pixels. */

    ICH     ichStartMinSel;
    ICH     ichStartMaxSel;

    PLPKEDITCALLOUT pLpkEditCallout;
    HBITMAP hCaretBitmap;      /* Current caret bitmap handle */
    INT     iCaretOffset;      /* Offset in pixels (for LPK use) */

    HANDLE  hInstance;         /* for WOW */
    UCHAR   seed;              /* used to encode and decode password text */
    BOOLEAN fEncoded;          /* is the text currently encoded */
    int     iLockLevel;        /* number of times the text has been locked */

    BYTE    DBCSVector[8];     /* DBCS vector table */
    HIMC    hImcPrev;          /* place to save hImc if we disable IME */
    POINT   ptScreenBounding;   /* top left corner of edit window in screen */
} ED, *PED, **PPED;

typedef struct tagEDITWND {
    WND wnd;
    PED ped;
} EDITWND, * KPTR_MODIFIER PEDITWND;

#ifdef FAREAST_CHARSET_BITS
#error FAREAST_CHARSET_BITS should not be defined
#endif
#define FAREAST_CHARSET_BITS   (FS_JISJAPAN | FS_CHINESESIMP | FS_WANSUNG | FS_CHINESETRAD)


// Language pack specific context menu IDs

#define ID_CNTX_RTL         0x00008000L
#define ID_CNTX_DISPLAYCTRL 0x00008001L
#define ID_CNTX_INSERTCTRL  0x00008013L
#define ID_CNTX_ZWJ         0x00008002L
#define ID_CNTX_ZWNJ        0x00008003L
#define ID_CNTX_LRM         0x00008004L
#define ID_CNTX_RLM         0x00008005L
#define ID_CNTX_LRE         0x00008006L
#define ID_CNTX_RLE         0x00008007L
#define ID_CNTX_LRO         0x00008008L
#define ID_CNTX_RLO         0x00008009L
#define ID_CNTX_PDF         0x0000800AL
#define ID_CNTX_NADS        0x0000800BL
#define ID_CNTX_NODS        0x0000800CL
#define ID_CNTX_ASS         0x0000800DL
#define ID_CNTX_ISS         0x0000800EL
#define ID_CNTX_AAFS        0x0000800FL
#define ID_CNTX_IAFS        0x00008010L
#define ID_CNTX_RS          0x00008011L
#define ID_CNTX_US          0x00008012L

/*
 * The following structure is used to store a selection block; In Multiline
 * edit controls, "StPos" and "EndPos" fields contain the Starting and Ending
 * lines of the block. In Single line edit controls, "StPos" and "EndPos"
 * contain the Starting and Ending character positions of the block;
 */
typedef struct tagBLOCK {
    ICH StPos;
    ICH EndPos;
}  BLOCK, *LPBLOCK;

/*  The following structure is used to store complete information about a
 *  a strip of text.
 */
typedef  struct {
    LPSTR   lpString;
    ICH     ichString;
    ICH     nCount;
    int     XStartPos;
}  STRIPINFO;
typedef  STRIPINFO FAR *LPSTRIPINFO;


/***************************************************************************\
*
* ListBox
*
\***************************************************************************/

#define IsLBoxVisible(plb)  (plb->fRedraw && IsVisible(plb->spwnd))

/*
 * Number of list box items we allocated whenever we grow the list box
 * structures.
 */
#define CITEMSALLOC     32

/* Return Values */
#define EQ        0
#define PREFIX    1
#define LT        2
#define GT        3

#define         SINGLESEL       0
#define         MULTIPLESEL     1
#define         EXTENDEDSEL     2

#define LBI_ADD     0x0004

/*
 *  The various bits of wFileDetails field are used as mentioned below:
 *      0x0001    Should the file name be in upper case.
 *      0x0002    Should the file size be shown.
 *      0x0004    Date stamp of the file to be shown ?
 *      0x0008    Time stamp of the file to be shown ?
 *      0x0010    The dos attributes of the file ?
 *      0x0020    In DlgDirSelectEx(), along with file name
 *                all other details also will be returned
 *
 */

#define LBUP_RELEASECAPTURE 0x0001
#define LBUP_RESETSELECTION 0x0002
#define LBUP_NOTIFY         0x0004
#define LBUP_SUCCESS        0x0008
#define LBUP_SELCHANGE      0x0010

/*
 * rgpch is set up as follows:  First there are cMac 2 byte pointers to the
 * start of the strings in hStrings or if ownerdraw, it is 4 bytes of data
 * supplied by the app and hStrings is not used.  Then if multiselection
 * listboxes, there are cMac 1 byte selection state bytes (one for each item
 * in the list box).  If variable height owner draw, there will be cMac 1 byte
 * height bytes (once again, one for each item in the list box.).
 *
 * CHANGES DONE BY SANKAR:
 *      The selection byte in rgpch is divided into two nibbles. The lower
 * nibble is the selection state (1 => Selected; 0 => de-selected)
 * and higher nibble is the display state(1 => Hilited and 0 => de-hilited).
 * You must be wondering why on earth we should store this selection state and
 * the display state seperately.Well! The reason is as follows:
 *      While Ctrl+Dragging or Shift+Ctrl+Dragging, the user can adjust the
 * selection before the mouse button is up. If the user enlarges a range and
 * and before the button is up if he shrinks the range, then the old selection
 * state has to be preserved for the individual items that do not fall in the
 * range finally.
 *      Please note that the display state and the selection state for an item
 * will be the same except when the user is dragging his mouse. When the mouse
 * is dragged, only the display state is updated so that the range is hilited
 * or de-hilited) but the selection state is preserved. Only when the button
 * goes up, for all the individual items in the range, the selection state is
 * made the same as the display state.
 */

typedef struct tagLBItem {
    LONG offsz;
    ULONG_PTR itemData;
} LBItem, *lpLBItem;

typedef struct tagLBODItem {
    ULONG_PTR itemData;
} LBODItem, *lpLBODItem;

void LBEvent(PLBIV, UINT, int);

/***************************************************************************\
*
* Static Controls
*
\***************************************************************************/

typedef struct tagSTAT {
    PWND spwnd;
    union {
        HANDLE hFont;
        BOOL   fDeleteIt;
    };
    HANDLE hImage;
    UINT cicur;
    UINT iicur;
    UINT fPaintKbdCuesOnly : 1;
} STAT, *PSTAT;

typedef struct tagSTATWND {
    WND wnd;
    PSTAT pstat;
} STATWND, * KPTR_MODIFIER PSTATWND;


typedef struct tagCURSORRESOURCE {
    WORD xHotspot;
    WORD yHotspot;
    BITMAPINFOHEADER bih;
} CURSORRESOURCE, *PCURSORRESOURCE;


#define NextWordBoundary(p)     ((PBYTE)(p) + ((ULONG_PTR)(p) & 1))
#define NextDWordBoundary(p)    ((PBYTE)(p) + ((ULONG_PTR)(-(LONG_PTR)(p)) & 3))

// DDEML stub prototypes

DWORD  Event(PEVENT_PACKET pep);
PVOID CsValidateInstance(HANDLE hInst);

/***************************************************************************\
* WOW Prototypes, Typedefs and Defines
*
* WOW registers resource callback functions so it can load 16 bit resources
* transparently for Win32.  At resource load time, these WOW functions are
* called.
*
\***************************************************************************/

BOOL  APIENTRY _FreeResource(HANDLE hResData, HINSTANCE hModule);
LPSTR APIENTRY _LockResource(HANDLE hResData, HINSTANCE hModule);
BOOL  APIENTRY _UnlockResource(HANDLE hResData, HINSTANCE hModule);

#define FINDRESOURCEA(hModule,lpName,lpType)         ((*(pfnFindResourceExA))(hModule, lpType, lpName, 0))
#define FINDRESOURCEW(hModule,lpName,lpType)         ((*(pfnFindResourceExW))(hModule, lpType, lpName, 0))
#define FINDRESOURCEEXA(hModule,lpName,lpType,wLang) ((*(pfnFindResourceExA))(hModule, lpType, lpName, wLang))
#define FINDRESOURCEEXW(hModule,lpName,lpType,wLang) ((*(pfnFindResourceExW))(hModule, lpType, lpName, wLang))
#define LOADRESOURCE(hModule,hResInfo)               ((*(pfnLoadResource))(hModule, hResInfo))
#define LOCKRESOURCE(hResData, hModule)              ((*(pfnLockResource))(hResData, hModule))
#define UNLOCKRESOURCE(hResData, hModule)            ((*(pfnUnlockResource))(hResData, hModule))
#define FREERESOURCE(hResData, hModule)              ((*(pfnFreeResource))(hResData, hModule))
#define SIZEOFRESOURCE(hModule,hResInfo)             ((*(pfnSizeofResource))(hModule, hResInfo))
#define GETEXPWINVER(hModule)                        ((*(pfnGetExpWinVer))((hModule)?(hModule):GetModuleHandle(NULL)))

/*
 * Pointers to unaligned-bits.  These are necessary for handling
 * bitmap-info's loaded from file.
 */
typedef BITMAPINFO       UNALIGNED *UPBITMAPINFO;
typedef BITMAPINFOHEADER UNALIGNED *UPBITMAPINFOHEADER;
typedef BITMAPCOREHEADER UNALIGNED *UPBITMAPCOREHEADER;

#define CCHFILEMAX      MAX_PATH

HANDLE LocalReallocSafe(HANDLE hMem, DWORD dwBytes, DWORD dwFlags, PPED pped);

HLOCAL WINAPI DispatchLocalAlloc(
    UINT uFlags,
    UINT uBytes,
    HANDLE hInstance);

HLOCAL WINAPI DispatchLocalReAlloc(
    HLOCAL hMem,
    UINT uBytes,
    UINT uFlags,
    HANDLE hInstance,
    PVOID* ppv);

LPVOID WINAPI DispatchLocalLock(
    HLOCAL hMem,
    HANDLE hInstance);

BOOL WINAPI DispatchLocalUnlock(
    HLOCAL hMem,
    HANDLE hInstance);

UINT WINAPI DispatchLocalSize(
    HLOCAL hMem,
    HANDLE hInstance);

HLOCAL WINAPI DispatchLocalFree(
    HLOCAL hMem,
    HANDLE hInstance);

#define UserLocalAlloc(uFlag,uBytes) HeapAlloc(pUserHeap, uFlag, (uBytes))
#define UserLocalReAlloc(p, uBytes, uFlags) HeapReAlloc(pUserHeap, uFlags, (LPSTR)(p), (uBytes))
#define UserLocalFree(p)    HeapFree(pUserHeap, 0, (LPSTR)(p))
#define UserLocalSize(p)    HeapSize(pUserHeap, 0, (LPSTR)(p))
#define UserLocalLock(p)    (LPSTR)(p)
#define UserLocalUnlock(p)
#define UserLocalFlags(p)   0
#define UserLocalHandle(p)  (HLOCAL)(p)

LONG TabTextOut(HDC hdc, int x, int y, LPCWSTR lpstring, int nCount,
        int nTabPositions, CONST INT *lpTabPositions, int iTabOrigin,
        BOOL fDrawTheText, int iCharset);
LONG UserLpkTabbedTextOut(HDC hdc, int x, int y, LPCWSTR lpstring,
        int nCount, int nTabPositions, CONST INT *lpTabPositions,
        int iTabOrigin, BOOL fDrawTheText, int cxCharWidth,
        int cyCharHeight, int iCharset);
void UserLpkPSMTextOut(HDC hdc, int xLeft, int yTop,
        LPWSTR lpsz, int cch, DWORD dwFlags);
void PSMTextOut(HDC hdc, int xLeft, int yTop, LPWSTR lpsz, int cch, DWORD dwFlags);
void ECUpdateFormat(PED ped, DWORD dwStyle, DWORD dwExStyle);

#ifndef _USERK_
int  LoadStringOrError(HANDLE, UINT, LPTSTR, int, WORD);
int  RtlGetIdFromDirectory(PBYTE, BOOL, int, int, DWORD, PDWORD);
BOOL RtlCaptureAnsiString(PIN_STRING, LPCSTR, BOOL);
BOOL RtlCaptureLargeAnsiString(PLARGE_IN_STRING, LPCSTR, BOOL);
LONG BroadcastSystemMessageWorker(DWORD dwFlags, LPDWORD lpdwRecipients, UINT uiMessage,
        WPARAM wParam, LPARAM lParam, PBSMINFO pBSMInfo, BOOL fAnsi);
#endif  // !_USERK_

PWND FASTCALL ValidateHwnd(HWND hwnd);
PWND FASTCALL ValidateHwndNoRip(HWND hwnd);

PSTR ECLock(PED ped);
void ECUnlock(PED ped);
BOOL ECNcCreate(PED, PWND, LPCREATESTRUCT);
void ECInvalidateClient(PED ped, BOOL fErase);
BOOL ECCreate(PED ped, LONG windowStyle);
void ECWord(PED, ICH, BOOL, ICH*, ICH*);
ICH  ECFindTab(LPSTR, ICH);
void ECNcDestroyHandler(PWND, PED);
BOOL ECSetText(PED, LPSTR);
void ECSetPasswordChar(PED, UINT);
ICH  ECCchInWidth(PED, HDC, LPSTR, ICH, int, BOOL);
void ECEmptyUndo(PUNDO);
void ECSaveUndo(PUNDO pundoFrom, PUNDO pundoTo, BOOL fClear);
BOOL ECInsertText(PED, LPSTR, ICH*);
ICH  ECDeleteText(PED);
void ECResetTextInfo(PED ped);
void ECNotifyParent(PED, int);
void ECSetEditClip(PED, HDC, BOOL);
HDC  ECGetEditDC(PED, BOOL);
void ECReleaseEditDC(PED, HDC, BOOL);
ICH  ECGetText(PED, ICH, LPSTR, BOOL);
void ECSetFont(PED, HFONT, BOOL);
void ECSetMargin(PED, UINT, long, BOOL);
ICH  ECCopy(PED);
BOOL ECCalcChangeSelection(PED, ICH, ICH, LPBLOCK, LPBLOCK);
void ECFindXORblks(LPBLOCK, LPBLOCK, LPBLOCK, LPBLOCK);
BOOL ECIsCharNumeric(PED ped, DWORD keyPress);

/*
 * Combine two DBCS WM_CHAR messages to
 * a single WORD value.
 */
WORD DbcsCombine(HWND, WORD);
#define CrackCombinedDbcsLB(c)  ((BYTE)(c))
#define CrackCombinedDbcsTB(c)  ((c) >> 8)

ICH  ECAdjustIch(PED, LPSTR, ICH);
ICH  ECAdjustIchNext(PED, LPSTR, ICH);
int  ECGetDBCSVector(PED, HDC, BYTE);
BOOL ECIsDBCSLeadByte(PED, BYTE);
LPSTR ECAnsiNext(PED, LPSTR);
LPSTR ECAnsiPrev(PED, LPSTR, LPSTR);
ICH  ECPrevIch(PED, LPSTR, ICH);
ICH  ECNextIch(PED, LPSTR, ICH);

void ECEnableDisableIME( PED ped );
void ECImmSetCompositionFont( PED ped );
void ECImmSetCompositionWindow( PED ped, LONG, LONG );
void  ECSetCaretHandler(PED ped);
void  ECInitInsert(PED ped, HKL hkl);
LRESULT ECImeComposition(PED ped, WPARAM wParam, LPARAM lParam);
LRESULT EcImeRequestHandler(PED, WPARAM, LPARAM);  // NT 5.0
BOOL HanjaKeyHandler(PED ped);  // Korean Support

void ECInOutReconversionMode(PED ped, BOOL fIn);


// ECTabTheTextOut draw codes
#define ECT_CALC        0
#define ECT_NORMAL      1
#define ECT_SELECTED    2

#define ECGetCaretWidth() (gpsi->uCaretWidth)

UINT ECTabTheTextOut(HDC, int, int, int, int,
                     LPSTR, int, ICH, PED, int, BOOL, LPSTRIPINFO);
HBRUSH ECGetControlBrush(PED, HDC, LONG);
HBRUSH ECGetBrush(PED ped, HDC hdc);
int  ECGetModKeys(int);
void ECSize( PED, LPRECT, BOOL);

ICH  MLInsertText(PED, LPSTR, ICH, BOOL);
ICH  MLDeleteText(PED);
BOOL MLEnsureCaretVisible(PED);
void MLDrawText(PED, HDC, ICH, ICH, BOOL);
void MLDrawLine(PED, HDC, int, ICH, int, BOOL);
void MLPaintABlock(PED, HDC, int, int);
int  GetBlkEndLine(int, int, BOOL FAR *, int, int);
void MLBuildchLines(PED, ICH, int, BOOL, PLONG, PLONG);
void MLShiftchLines(PED, ICH, int);
BOOL MLInsertchLine(PED, ICH, ICH, BOOL);
void MLSetCaretPosition(PED,HDC);
void MLIchToXYPos(PED, HDC, ICH, BOOL, LPPOINT);
int  MLIchToLine(PED, ICH);
void MLRepaintChangedSelection(PED, HDC, ICH, ICH);
void MLMouseMotion(PED, UINT, UINT, LPPOINT);
ICH  MLLine(PED, ICH);
void MLStripCrCrLf(PED);
int  MLCalcXOffset(PED, HDC, int);
BOOL MLUndo(PED);
LRESULT MLEditWndProc(HWND, PED, UINT, WPARAM, LPARAM);
void MLChar(PED, DWORD, int);
void MLKeyDown(PED, UINT, int);
ICH  MLPasteText(PED);
void MLSetSelection(PED, BOOL, ICH, ICH);
LONG MLCreate(PED, LPCREATESTRUCT);
BOOL MLInsertCrCrLf(PED);
void MLSetHandle(PED, HANDLE);
LONG MLGetLine(PED, ICH, ICH, LPSTR);
ICH  MLLineIndex(PED, ICH);
void MLSize(PED, BOOL);
void MLChangeSelection(PED, HDC, ICH, ICH);
void MLSetRectHandler(PED, LPRECT);
BOOL MLExpandTabs(PED);
BOOL MLSetTabStops(PED, int, LPINT);
LONG MLScroll(PED, BOOL, int, int, BOOL);
int  MLThumbPosFromPed(PED, BOOL);
void MLUpdateiCaretLine(PED ped);
ICH  MLLineLength(PED, ICH);
void MLReplaceSel(PED, LPSTR);

void SLReplaceSel(PED, LPSTR);
BOOL SLUndo(PED);
void SLSetCaretPosition(PED, HDC);
int  SLIchToLeftXPos(PED, HDC, ICH);
void SLChangeSelection(PED, HDC, ICH, ICH);
void SLDrawText(PED, HDC, ICH);
void SLDrawLine(PED, HDC, int, int, ICH, int, BOOL);
int  SLGetBlkEnd(PED, ICH, ICH, BOOL FAR *);
BOOL SLScrollText(PED, HDC);
void SLSetSelection(PED,ICH, ICH);
ICH  SLInsertText(PED, LPSTR, ICH);
ICH  SLPasteText(PED);
void SLChar(PED, DWORD);
void SLKeyDown(PED, DWORD, int);
ICH  SLMouseToIch(PED, HDC, LPPOINT);
void SLMouseMotion(PED, UINT, UINT, LPPOINT);
LONG SLCreate(PED, LPCREATESTRUCT);
void SLPaint(PED, HDC);
void SLSetFocus(PED);
void SLKillFocus(PED, HWND);
LRESULT SLEditWndProc(HWND, PED, UINT, WPARAM, LPARAM);
LRESULT EditWndProc(PWND, UINT, WPARAM, LPARAM);

#define GETAPPVER() GetClientInfo()->dwExpWinVer
#define THREAD_HKL()      (KHKL_TO_HKL(GetClientInfo()->hKL))
#define GETCLIENTTHREADINFO()   (CLIENTTHREADINFO *)KPVOID_TO_PVOID(GetClientInfo()->pClientThreadInfo)
#define CLIENTTHREADINFO(pci)   (CLIENTTHREADINFO *)KPVOID_TO_PVOID((pci)->pClientThreadInfo)


UINT HelpMenu(HWND hwnd, PPOINT ppt);

#define ISDELIMETERA(ch) ((ch == ' ') || (ch == '\t'))
#define ISDELIMETERW(ch) ((ch == L' ') || (ch == L'\t'))

#define AWCOMPARECHAR(ped,pbyte,awchar) (ped->fAnsi ? (*(PUCHAR)(pbyte) == (UCHAR)(awchar)) : (*(LPWSTR)(pbyte) == (WCHAR)(awchar)))

/* Menu that comes up when you press the right mouse button on an edit
 * control
 */
#define ID_EC_PROPERTY_MENU      1

#define IDD_MDI_ACTIVATE         9

#ifndef _USERK_
/*
 * String IDs
 */
#define STR_ERROR                        0x00000002L
#define STR_MOREWINDOWS                  0x0000000DL
#define STR_NOMEMBITMAP                  0x0000000EL

/*
 * IME specific context menu string
 */
#define STR_IMEOPEN                 700
#define STR_IMECLOSE                701
#define STR_SOFTKBDOPEN             702
#define STR_SOFTKBDCLOSE            703
#define STR_RECONVERTSTRING         705

/*
 * Shutdown logging strings.
 */
#define STR_SHUTDOWN_SHUTDOWN       706
#define STR_SHUTDOWN_POWEROFF       707
#define STR_SHUTDOWN_REBOOT         708

/*
 * Misc. strings.
 */
#define STR_UNKNOWN                 709

/*
 * ExitWindowsEx warning dlg strings
 */
#define IDS_EXITWINDOWS_TITLE           710
#define IDS_SHUTDOWN_REMOTE             711
#define IDS_SHUTDOWN_REMOTE_OTHERUSERS  712
#define IDS_SHUTDOWN_OTHERUSERS         713
#define IDS_RESTART_OTHERUSERS          714

#endif  // !_USERK_


BOOL InitClientDrawing();

/***************************************************************************\
* Function Prototypes
*
* NOTE: Only prototypes for GLOBAL (across module) functions should be put
* here.  Prototypes for functions that are global to a single module should
* be put at the head of that module.
*
\***************************************************************************/

int InternalScrollWindowEx(HWND hwnd, int dx, int dy, CONST RECT *prcScroll,
        CONST RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate,
        UINT dwFlags, DWORD dwTime);

BOOL IsMetaFile(HDC hdc);

BOOL DrawDiagonal(HDC hdc, LPRECT lprc, HBRUSH hbrTL, HBRUSH hbrBR, UINT flags);
BOOL FillTriangle(HDC hdc, LPRECT lprc, HBRUSH hbr, UINT flags);

BOOL   _ClientFreeLibrary(HANDLE hmod);
DWORD  _ClientGetListboxString(PWND pwnd, UINT msg, WPARAM wParam, LPSTR lParam,
        ULONG_PTR xParam, PROC xpfn);
LPHLP  HFill(LPCSTR lpszHelp, DWORD ulCommand, ULONG_PTR ulData);
BOOL SetVideoTimeout(DWORD dwVideoTimeout);

DWORD _GetWindowLong(PWND pwnd, int index, BOOL bAnsi);
#ifdef _WIN64
ULONG_PTR _GetWindowLongPtr(PWND pwnd, int index, BOOL bAnsi);
#else
#define _GetWindowLongPtr   _GetWindowLong
#endif
WORD  _GetWindowWord(PWND pwnd, int index);

HWND InternalFindWindowExA(HWND hwndParent, HWND hwndChild, LPCSTR pClassName,
                          LPCSTR pWindowName, DWORD   dwFlag);
HWND InternalFindWindowExW(HWND hwndParent, HWND hwndChild, LPCTSTR pClassName,
                          LPCTSTR pWindowName, DWORD   dwFlag);


/*
 * Message thunks.
 */
#define fnCOPYDATA                      NtUserMessageCall
#define fnDDEINIT                       NtUserMessageCall
#define fnDWORD                         NtUserMessageCall
#define fnNCDESTROY                     NtUserMessageCall
#define fnDWORDOPTINLPMSG               NtUserMessageCall
#define fnGETTEXTLENGTHS                NtUserMessageCall
#define fnGETDBCSTEXTLENGTHS            NtUserMessageCall
#define fnINLPCREATESTRUCT              NtUserMessageCall
#define fnINLPCOMPAREITEMSTRUCT         NtUserMessageCall
#define fnINLPDELETEITEMSTRUCT          NtUserMessageCall
#define fnINLPDRAWITEMSTRUCT            NtUserMessageCall
#define fnINLPHELPINFOSTRUCT            NtUserMessageCall
#define fnINLPHLPSTRUCT                 NtUserMessageCall
#define fnINLPWINDOWPOS                 NtUserMessageCall
#define fnINOUTDRAG                     NtUserMessageCall
#define fnINOUTLPMEASUREITEMSTRUCT      NtUserMessageCall
#define fnINOUTLPPOINT5                 NtUserMessageCall
#define fnINOUTLPRECT                   NtUserMessageCall
#define fnINOUTLPSCROLLINFO             NtUserMessageCall
#define fnINOUTLPWINDOWPOS              NtUserMessageCall
#define fnINOUTNCCALCSIZE               NtUserMessageCall
#define fnINOUTNEXTMENU                 NtUserMessageCall
#define fnINOUTSTYLECHANGE              NtUserMessageCall
#define fnOPTOUTLPDWORDOPTOUTLPDWORD    NtUserMessageCall
#define fnOUTLPRECT                     NtUserMessageCall
#define fnPOPTINLPUINT                  NtUserMessageCall
#define fnPOUTLPINT                     NtUserMessageCall
#define fnSENTDDEMSG                    NtUserMessageCall
#define fnOUTDWORDINDWORD               NtUserMessageCall
#define fnINOUTMENUGETOBJECT            NtUserMessageCall
#define fnINCBOXSTRING                  NtUserMessageCall
#define fnINCNTOUTSTRING                NtUserMessageCall
#define fnINCNTOUTSTRINGNULL            NtUserMessageCall
#define fnINLBOXSTRING                  NtUserMessageCall
#define fnINLPMDICREATESTRUCT           NtUserMessageCall
#define fnINSTRING                      NtUserMessageCall
#define fnINSTRINGNULL                  NtUserMessageCall
#define fnINWPARAMCHAR                  NtUserMessageCall
#define fnOUTCBOXSTRING                 NtUserMessageCall
#define fnOUTLBOXSTRING                 NtUserMessageCall
#define fnOUTSTRING                     NtUserMessageCall
#define fnKERNELONLY                    NtUserMessageCall
#define fnOUTLPCOMBOBOXINFO             NtUserMessageCall
#define fnOUTLPSCROLLBARINFO            NtUserMessageCall


#define MESSAGEPROTO(func) \
LRESULT CALLBACK fn ## func(                               \
        HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, \
        ULONG_PTR xParam, DWORD xpfnWndProc, BOOL bAnsi)

MESSAGEPROTO(COPYGLOBALDATA);
MESSAGEPROTO(INDEVICECHANGE);
MESSAGEPROTO(INPAINTCLIPBRD);
MESSAGEPROTO(INSIZECLIPBRD);
MESSAGEPROTO(IMECONTROL);
MESSAGEPROTO(IMEREQUEST);
MESSAGEPROTO(INWPARAMDBCSCHAR);
MESSAGEPROTO(EMGETSEL);
MESSAGEPROTO(EMSETSEL);
MESSAGEPROTO(CBGETEDITSEL);


/*
 * clhook.c
 */
#define IsHooked(pci, fsHook) \
    ((fsHook & (pci->fsHooks | pci->pDeskInfo->fsHooks)) != 0)

LRESULT fnHkINLPCWPSTRUCTW(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, ULONG_PTR xParam);
LRESULT fnHkINLPCWPSTRUCTA(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, ULONG_PTR xParam);
LRESULT fnHkINLPCWPRETSTRUCTW(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, ULONG_PTR xParam);
LRESULT fnHkINLPCWPRETSTRUCTA(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, ULONG_PTR xParam);
LRESULT DispatchHookW(int dw, WPARAM wParam, LPARAM lParam, HOOKPROC pfn);
LRESULT DispatchHookA(int dw, WPARAM wParam, LPARAM lParam, HOOKPROC pfn);

/*
 * client.c
 */
LRESULT APIENTRY ButtonWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ButtonWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY MenuWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY MenuWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY DesktopWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY DesktopWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ScrollBarWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ScrollBarWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ListBoxWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ListBoxWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY StaticWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY StaticWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ComboBoxWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ComboBoxWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ComboListBoxWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ComboListBoxWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY MDIClientWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY MDIClientWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY MB_DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY MDIActivateDlgProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY MDIActivateDlgProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY EditWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY EditWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ImeWndProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ImeWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#ifdef MESSAGE_PUMP_HOOK
DWORD APIENTRY RealGetQueueStatus(UINT flags);
DWORD WINAPI RealMsgWaitForMultipleObjectsEx(DWORD nCount, CONST HANDLE *pHandles,
        DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags);
#endif
LRESULT APIENTRY RealDefWindowProcA(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY RealDefWindowProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY DispatchDefWindowProcA(PWND pwnd, UINT msg, WPARAM wParam, LPARAM lParam, ULONG_PTR pfn);
LRESULT APIENTRY DispatchDefWindowProcW(PWND pwnd, UINT msg, WPARAM wParam, LPARAM lParam, ULONG_PTR pfn);
BOOL    InitUserApiHook(HMODULE hmod, ULONG_PTR offPfnInitUserApiHook);
BOOL    ClearUserApiHook(HMODULE hmod);
BOOL    CALLBACK DefaultOWP(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT * pr, void ** pvCookie);
void    ResetUserApiHook(USERAPIHOOK * puah);
LRESULT SendMessageWorker(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam, BOOL fAnsi);
LRESULT SendMessageTimeoutWorker(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam,
            UINT fuFlags, UINT uTimeout, PULONG_PTR lpdwResult, BOOL fAnsi);

void ClientEmptyClipboard(void);
VOID GetActiveKeyboardName(LPWSTR lpszName);
HANDLE OpenKeyboardLayoutFile(LPWSTR lpszKLName, PUINT puFlags, PUINT poffTable, PUINT pKbdInputLocale, OUT OPTIONAL PKBDTABLE_MULTI_INTERNAL pKbdTableMulti);
VOID LoadPreloadKeyboardLayouts(void);
void SetWindowState(PWND pwnd, UINT flags);
void ClearWindowState(PWND pwnd, UINT flags);

HKL LoadKeyboardLayoutWorker(HKL hkl, LPCWSTR lpszKLName, UINT uFlags, BOOL fFailSafe);


/*
 * Worker routines called from both the window procs and
 * the callback thunks.
 */
LRESULT DispatchClientMessage(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, ULONG_PTR pfn);
LRESULT DefWindowProcWorker(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT RealDefWindowProcWorker(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT ButtonWndProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT ListBoxWndProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT StaticWndProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT ComboBoxWndProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT ComboListBoxWndProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT MDIClientWndProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT EditWndProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT DefDlgProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);
LRESULT ImeWndProcWorker(PWND pwnd, UINT msg, WPARAM wParam,
        LPARAM lParam, DWORD fAnsi);

/*
 * Server Stubs - ntstubs.c
 */

LONG _SetWindowLong(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong,
    BOOL bAnsi);

#ifdef _WIN64
LONG_PTR _SetWindowLongPtr(
    HWND hWnd,
    int nIndex,
    LONG_PTR dwNewLong,
    BOOL bAnsi);
#else
#define _SetWindowLongPtr   _SetWindowLong
#endif

BOOL _PeekMessage(
    LPMSG pmsg,
    HWND hwnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg,
    BOOL bAnsi);

BOOL _DefSetText(
    HWND hwnd,
    LPCWSTR pstr,
    BOOL bAnsi);

HCURSOR _GetCursorFrameInfo(
    HCURSOR hcur,
    LPWSTR id,
    int iFrame,
    LPDWORD pjifRate,
    LPINT pccur);

HWND _CreateWindowEx(
    DWORD dwExStyle,
    LPCTSTR pClassName,
    LPCTSTR pWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hwndParent,
    HMENU hmenu,
    HANDLE hModule,
    LPVOID pParam,
    DWORD dwFlags);

HWND VerNtUserCreateWindowEx(
    IN DWORD dwExStyle,
    IN PLARGE_STRING pstrClassName,
    IN PLARGE_STRING pstrWindowName OPTIONAL,
    IN DWORD dwStyle,
    IN int x,
    IN int y,
    IN int nWidth,
    IN int nHeight,
    IN HWND hwndParent,
    IN HMENU hmenu,
    IN HANDLE hModule,
    IN LPVOID pParam,
    IN DWORD dwFlags);

HKL _LoadKeyboardLayoutEx(
    HANDLE hFile,
    UINT offTable,
    PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    HKL hkl,
    LPCWSTR pwszKL,
    UINT KbdInputLocale,
    UINT Flags);

BOOL _SetCursorIconData(
    HCURSOR hCursor,
    PCURSORDATA pcur);

HCURSOR FindExistingCursorIcon(
    LPWSTR      pszModName,
    LPCWSTR     pszResName,
    PCURSORFIND pcfSearch);

HANDLE CreateLocalMemHandle(
    HANDLE hMem);

HANDLE ConvertMemHandle(
    HANDLE hMem,
    UINT cbNULL);

HHOOK _SetWindowsHookEx(
    HANDLE hmod,
    LPTSTR pszLib,
    DWORD idThread,
    int nFilterType,
    PROC pfnFilterProc,
    DWORD dwFlags);

#if 0
DWORD WINAPI ImmGetReconvertTotalSize(
    DWORD dwSize,
    REQ_CALLER eCaller,
    BOOL bAnsiTarget);

DWORD WINAPI ImmReconversionWorker(
    LPRECONVERTSTRING lpRecTo,
    LPRECONVERTSTRING lpRecFrom,
    BOOL bToAnsi,
    DWORD dwCodePage);
#endif

/*
 * classc.c
 */
ULONG_PTR _GetClassData(
    PCLS pcls,
    PWND pwnd,
    int index,
    BOOL bAnsi);

DWORD _GetClassLong(
    PWND pwnd,
    int index,
    BOOL bAnsi);

#ifdef _WIN64
ULONG_PTR _GetClassLongPtr(
    PWND pwnd,
    int index,
    BOOL bAnsi);
#else
#define _GetClassLongPtr    _GetClassLong
#endif

/*
 * mngrayc.c
 */
BOOL BitBltSysBmp(
    HDC hdc,
    int x,
    int y,
    UINT i);


/*
 * clenum.c
 */
DWORD BuildHwndList(
    HDESK hdesk,
    HWND hwndNext,
    BOOL fEnumChildren,
    DWORD idThread,
    HWND **phwndFirst);

/*
 * cltxt.h
 */
ATOM RegisterClassExWOWA(
    PWNDCLASSEXA lpWndClass,
    LPDWORD pdwWOWstuff,
    WORD fnid,
    DWORD dwFlags);

ATOM RegisterClassExWOWW(
    PWNDCLASSEXW lpWndClass,
    LPDWORD pdwWOWstuff,
    WORD fnid,
    DWORD dwFlags);

void CopyLogFontAtoW(
    PLOGFONTW pdest,
    PLOGFONTA psrc);

void CopyLogFontWtoA(
    PLOGFONTA pdest,
    PLOGFONTW psrc);

/*
 * dlgmgrc.c
 */
PWND _NextControl(
    PWND pwndDlg,
    PWND pwnd,
    UINT uFlags);

PWND _PrevControl(
    PWND pwndDlg,
    PWND pwnd,
    UINT uFlags);

PWND _GetNextDlgGroupItem(
    PWND pwndDlg,
    PWND pwnd,
    BOOL fPrev);

PWND _GetNextDlgTabItem(
    PWND pwndDlg,
    PWND pwnd,
    BOOL fPrev);

PWND _GetChildControl(
    PWND pwndDlg,
    PWND pwndLevel);

/*
 * winmgrc.c
 */
BOOL FChildVisible(
    HWND hwnd);

/*
 * draw.c
 */
BOOL PaintRect(
    HWND hwndBrush,
    HWND hwndPaint,
    HDC hdc,
    HBRUSH hbr,
    LPRECT lprc);

#define NtUserReleaseDC(hwnd,hdc)  NtUserCallOneParam((ULONG_PTR)(hdc), SFI__RELEASEDC)
#define NtUserArrangeIconicWindows(hwnd)  (UINT)NtUserCallHwndLock((hwnd), SFI_XXXARRANGEICONICWINDOWS)
#define NtUserBeginDeferWindowPos(nNumWindows) (HANDLE)NtUserCallOneParam((nNumWindows),SFI__BEGINDEFERWINDOWPOS)
#define NtUserCreateMenu()   (HMENU)NtUserCallNoParam(SFI__CREATEMENU)
#define NtUserDestroyCaret() (BOOL)NtUserCallNoParam(SFI_ZZZDESTROYCARET)
#define NtUserEnableWindow(hwnd, bEnable) (BOOL)NtUserCallHwndParamLock((hwnd), (bEnable),SFI_XXXENABLEWINDOW)
#define NtUserGetMessagePos() (DWORD)NtUserCallNoParam(SFI__GETMESSAGEPOS)
#define NtUserKillSystemTimer(hwnd,nIDEvent)  (BOOL)NtUserCallHwndParam((hwnd), (nIDEvent), SFI__KILLSYSTEMTIMER)
#define NtUserMessageBeep(wType)  (BOOL)NtUserCallOneParam((wType), SFI_XXXMESSAGEBEEP)
#define NtUserSetWindowContextHelpId(hwnd,id) (BOOL)NtUserCallHwndParam((hwnd), (id), SFI__SETWINDOWCONTEXTHELPID)
#define NtUserGetWindowContextHelpId(hwnd)   (BOOL)NtUserCallHwnd((hwnd), SFI__GETWINDOWCONTEXTHELPID)
#define NtUserRedrawFrame(hwnd)   NtUserCallHwndLock((hwnd), SFI_XXXREDRAWFRAME)
#define NtUserRedrawFrameAndHook(hwnd)  NtUserCallHwndLock((hwnd), SFI_XXXREDRAWFRAMEANDHOOK)
#define NtUserRedrawTitle(hwnd, wFlags)  NtUserCallHwndParamLock((hwnd), (wFlags), SFI_XXXREDRAWTITLE)
#define NtUserReleaseCapture()  (BOOL)NtUserCallNoParam(SFI_XXXRELEASECAPTURE)
#define NtUserSetCaretPos(X,Y)  (BOOL)NtUserCallTwoParam((DWORD)(X), (DWORD)(Y), SFI_ZZZSETCARETPOS)
#define NtUserSetCursorPos(X, Y)  (BOOL)NtUserCallTwoParam((X), (Y), SFI_ZZZSETCURSORPOS)
#define NtUserSetForegroundWindow(hwnd)  (BOOL)NtUserCallHwndLock((hwnd), SFI_XXXSTUBSETFOREGROUNDWINDOW)
#define NtUserSetSysMenu(hwnd)  NtUserCallHwndLock((hwnd), SFI_XXXSETSYSMENU)
#define NtUserSetVisible(hwnd,fSet)  NtUserCallHwndParam((hwnd), (fSet), SFI_SETVISIBLE)
#define NtUserShowCursor(bShow)   (int)NtUserCallOneParam((bShow), SFI_ZZZSHOWCURSOR)
#define NtUserUpdateClientRect(hwnd) NtUserCallHwndLock((hwnd), SFI_XXXUPDATECLIENTRECT)

#define CreateCaret         NtUserCreateCaret
#define FillWindow          NtUserFillWindow
#define GetControlBrush     NtUserGetControlBrush
#define GetControlColor     NtUserGetControlColor
#define GetDCEx             NtUserGetDCEx
#define GetWindowPlacement  NtUserGetWindowPlacement
#define RedrawWindow        NtUserRedrawWindow


/*
 * dmmnem.c
 */
int FindMnemChar(
    LPWSTR lpstr,
    WCHAR ch,
    BOOL fFirst,
    BOOL fPrefix);

/*
 * clres.c
 */
BOOL WowGetModuleFileName(
    HMODULE hModule,
    LPWSTR pwsz,
    DWORD  cchMax);

HICON WowServerLoadCreateCursorIcon(
    HANDLE hmod,
    LPTSTR lpModName,
    DWORD dwExpWinVer,
    LPCTSTR lpName,
    DWORD cb,
    PVOID pcr,
    LPTSTR lpType,
    BOOL fClient);

HANDLE InternalCopyImage(
    HANDLE hImage,
    UINT IMAGE_flag,
    int cxNew,
    int cyNew,
    UINT LR_flags);

HMENU CreateMenuFromResource(
    LPBYTE);

/*
 * acons.c
 */
#define BFT_ICON    0x4349  //  'IC'
#define BFT_BITMAP  0x4D42  //  'BM'
#define BFT_CURSOR  0x5450  //  'PT'

typedef struct _FILEINFO {
    LPBYTE  pFileMap;
    LPBYTE  pFilePtr;
    LPBYTE  pFileEnd;
    LPCWSTR pszName;
} FILEINFO, *PFILEINFO;

HANDLE LoadCursorIconFromFileMap(
    IN PFILEINFO   pfi,
    IN OUT LPWSTR *prt,
    IN DWORD       cxDesired,
    IN DWORD       cyDesired,
    IN DWORD       LR_flags,
    OUT LPBOOL     pfAni);

DWORD GetIcoCurWidth(
    DWORD cxOrg,
    BOOL  fIcon,
    UINT  LR_flags,
    DWORD cxDesired);

DWORD GetIcoCurHeight(
    DWORD cyOrg,
    BOOL  fIcon,
    UINT  LR_flags,
    DWORD cyDesired);

DWORD GetIcoCurBpp(
    UINT LR_flags);

HICON LoadIcoCur(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    LPWSTR    type,
    DWORD     cxDesired,
    DWORD     cyDesired,
    UINT      LR_flags);

HANDLE ObjectFromDIBResource(
    HINSTANCE hmod,
    LPCWSTR   lpName,
    LPWSTR    type,
    DWORD     cxDesired,
    DWORD     cyDesired,
    UINT      LR_flags);

HANDLE RtlLoadObjectFromDIBFile(
    LPCWSTR lpszName,
    LPWSTR  type,
    DWORD   cxDesired,
    DWORD   cyDesired,
    UINT    LR_flags);

HCURSOR LoadCursorOrIconFromFile(
    LPCWSTR pszFilename,
    BOOL    fIcon);

HBITMAP ConvertDIBBitmap(
    UPBITMAPINFOHEADER lpbih,
    DWORD              cxDesired,
    DWORD              cyDesired,
    UINT               flags,
    LPBITMAPINFOHEADER *lplpbih,
    LPSTR              *lplpBits);

HICON ConvertDIBIcon(
    LPBITMAPINFOHEADER lpbih,
    HINSTANCE          hmod,
    LPCWSTR            lpName,
    BOOL               fIcon,
    DWORD              cxNew,
    DWORD              cyNew,
    UINT               LR_flags);

int SmartStretchDIBits(
    HDC          hdc,
    int          xD,
    int          yD,
    int          dxD,
    int          dyD,
    int          xS,
    int          yS,
    int          dxS,
    int          dyS,
    LPVOID       lpBits,
    LPBITMAPINFO lpbi,
    UINT         wUsage,
    DWORD        rop);


/*
 * OFFSET for different DPI resources.
 * This allows us to take a resource number and "map" to an actual resource
 * based on what DPI the user selected
 */

#define OFFSET_SCALE_DPI 000
#define OFFSET_96_DPI    100
#define OFFSET_120_DPI   200
#define OFFSET_160_DPI   300

/*
 * defines the highest resource number so we can do math on the resource
 * number.
 */

#define MAX_RESOURCE_INDEX 32768


/*
 * Parameter for xxxAlterHilite()
 */
#define HILITEONLY      0x0001
#define SELONLY         0x0002
#define HILITEANDSEL    (HILITEONLY + SELONLY)

#define HILITE     1

// LATER IanJa: these vary by country!  For US they are VK_OEM_2 VK_OEM_5.
//       Change lboxctl2.c MapVirtualKey to character - and fix the spelling?
#define VERKEY_SLASH     0xBF   /* Vertual key for '/' character */
#define VERKEY_BACKSLASH 0xDC   /* Vertual key for '\' character */

/*
 * Procedures for combo boxes.
 */
LONG  xxxCBCommandHandler(PCBOX, DWORD, HWND);
LRESULT xxxCBMessageItemHandler(PCBOX, UINT, LPVOID);
int   xxxCBDir(PCBOX, UINT, LPWSTR);
VOID  xxxCBPaint(PCBOX, HDC);
VOID  xxxCBCompleteEditWindow(PCBOX pcbox);
BOOL  xxxCBHideListBoxWindow(PCBOX pcbox, BOOL fNotifyParent, BOOL fSelEndOK);
VOID  xxxCBShowListBoxWindow(PCBOX pcbox, BOOL fTrack);
void xxxCBPosition(PCBOX pcbox);

/*
 * combo.h
 */

/* Initialization code */
long  CBNcCreateHandler(PCBOX, PWND);
LRESULT xxxCBCreateHandler(PCBOX, PWND);
void xxxCBCalcControlRects(PCBOX pcbox, LPRECT lprcList);

/* Destruction code */
VOID  xxxCBNcDestroyHandler(PWND, PCBOX);

/* Generic often used routines */
VOID  xxxCBNotifyParent(PCBOX, SHORT);
VOID  xxxCBUpdateListBoxWindow(PCBOX, BOOL);


/* Helpers' */
VOID  xxxCBInternalUpdateEditWindow(PCBOX, HDC);
VOID  xxxCBGetFocusHelper(PCBOX);
VOID  xxxCBKillFocusHelper(PCBOX);
VOID  xxxCBInvertStaticWindow(PCBOX,BOOL,HDC);
VOID  xxxCBSetFontHandler(PCBOX, HANDLE, BOOL);
VOID  xxxCBSizeHandler(PCBOX);
LONG  xxxCBSetEditItemHeight(PCBOX pcbox, int editHeight);


/*
 * String
 */

INT xxxFindString(PLBIV, LPWSTR, INT, INT, BOOL);

VOID  InitHStrings(PLBIV);

int   xxxLBInsertItem(PLBIV, LPWSTR, int, UINT);

/*
 * Selection
 */
BOOL  ISelFromPt(PLBIV, POINT, LPDWORD);
BOOL  IsSelected(PLBIV, INT, UINT);
VOID LBSetCItemFullMax(PLBIV plb);

VOID  xxxLBSelRange(PLBIV, INT, INT, BOOL);

INT xxxLBSetCurSel(PLBIV, INT);

INT LBoxGetSelItems(PLBIV, BOOL, INT, LPINT);

LONG  xxxLBSetSel(PLBIV, BOOL, INT);

VOID  xxxSetISelBase(PLBIV, INT);

VOID  SetSelected(PLBIV, INT, BOOL, UINT);


/*
 * Caret
 */
void xxxLBSetCaret(PLBIV plb, BOOL fSetCaret);
VOID  xxxCaretDestroy(PLBIV);

/*
 * LBox
 */
LONG  xxxLBCreate(PLBIV, PWND, LPCREATESTRUCT);
VOID  xxxDestroyLBox(PLBIV, PWND);
VOID  xxxLBoxDeleteItem(PLBIV, INT);

VOID  xxxLBoxDoDeleteItems(PLBIV);
VOID  xxxLBoxDrawItem(PLBIV, INT, UINT, UINT, LPRECT);


/*
 * Scroll
 */
INT   LBCalcVarITopScrollAmt(PLBIV, INT, INT);

VOID  xxxLBoxCtlHScroll(PLBIV, INT, INT);

VOID  xxxLBoxCtlHScrollMultiColumn(PLBIV, INT, INT);

VOID  xxxLBoxCtlScroll(PLBIV, INT, INT);

VOID  xxxLBShowHideScrollBars(PLBIV);

/*
 * LBoxCtl
 */
INT xxxLBoxCtlDelete(PLBIV, INT);

VOID  xxxLBoxCtlCharInput(PLBIV, UINT, BOOL);
VOID  xxxLBoxCtlKeyInput(PLBIV, UINT, UINT);
VOID  xxxLBPaint(PLBIV, HDC, LPRECT);

BOOL xxxLBInvalidateRect(PLBIV plb, LPRECT lprc, BOOL fErase);
/*
 * Miscellaneous
 */
VOID  xxxAlterHilite(PLBIV, INT, INT, BOOL, INT, BOOL);

INT CItemInWindow(PLBIV, BOOL);

VOID  xxxCheckRedraw(PLBIV, BOOL, INT);

LPWSTR GetLpszItem(PLBIV, INT);

VOID  xxxInsureVisible(PLBIV, INT, BOOL);

VOID  xxxInvertLBItem(PLBIV, INT, BOOL);

VOID  xxxLBBlockHilite(PLBIV, INT, BOOL);

int   LBGetSetItemHeightHandler(PLBIV plb, UINT message, int item, UINT height);
VOID  LBDropObjectHandler(PLBIV, PDROPSTRUCT);
LONG_PTR LBGetItemData(PLBIV, INT);

INT LBGetText(PLBIV, BOOL, BOOL, INT, LPWSTR);

VOID  xxxLBSetFont(PLBIV, HANDLE, BOOL);
int LBSetItemData(PLBIV, INT, LONG_PTR);

BOOL  LBSetTabStops(PLBIV, INT, LPINT);

VOID  xxxLBSize(PLBIV, INT, INT);
INT LastFullVisible(PLBIV);

INT xxxLbDir(PLBIV, UINT, LPWSTR);

INT xxxLbInsertFile(PLBIV, LPWSTR);

VOID  xxxNewITop(PLBIV, INT);
VOID  xxxNewITopEx(PLBIV, INT, DWORD);

VOID  xxxNotifyOwner(PLBIV, INT);

VOID  xxxResetWorld(PLBIV, INT, INT, BOOL);

VOID  xxxTrackMouse(PLBIV, UINT, POINT);
BOOL  xxxDlgDirListHelper(PWND, LPWSTR, LPBYTE, int, int, UINT, BOOL);
BOOL  DlgDirSelectHelper(LPWSTR pFileName, int cbFileName, HWND hwndListBox);
BOOL xxxLBResetContent(PLBIV plb);
VOID xxxLBSetRedraw(PLBIV plb, BOOL fRedraw);
int xxxSetLBScrollParms(PLBIV plb, int nCtl);
void xxxLBButtonUp(PLBIV plb, UINT uFlags);

/*
 * Variable Height OwnerDraw Support Routines
 */
INT CItemInWindowVarOwnerDraw(PLBIV, BOOL);

INT LBPage(PLBIV, INT, BOOL);


/*
 * Multicolumn listbox
 */
VOID  LBCalcItemRowsAndColumns(PLBIV);

/*
 * Both multicol and var height
 */
BOOL  LBGetItemRect(PLBIV, INT, LPRECT);

VOID  LBSetVariableHeightItemHeight(PLBIV, INT, INT);

INT   LBGetVariableHeightItemHeight(PLBIV, INT);

/*
 * No-data (lazy evaluation) listbox
 */
INT  xxxLBSetCount(PLBIV, INT);

UINT LBCalcAllocNeeded(PLBIV, INT);

/*
 * Storage pre-allocation support for LB_INITSTORAGE
 */
LONG xxxLBInitStorage(PLBIV plb, BOOL fAnsi, INT cItems, INT cb);

/***************************************************************************\
*
* Dialog Boxes
*
\***************************************************************************/

HWND        InternalCreateDialog(HANDLE hmod,
             LPDLGTEMPLATE lpDlgTemplate, DWORD cb,
             HWND hwndOwner , DLGPROC pfnWndProc, LPARAM dwInitParam,
             UINT fFlags);

INT_PTR     InternalDialogBox(HANDLE hmod,
             LPDLGTEMPLATE lpDlgTemplate,
             HWND hwndOwner , DLGPROC pfnWndProc, LPARAM dwInitParam,
             UINT fFlags);

PWND        _FindDlgItem(PWND pwndParent, DWORD id);
PWND        _GetDlgItem(PWND, int);
long        _GetDialogBaseUnits(VOID);
PWND        GetParentDialog(PWND pwndDialog);
VOID        xxxRemoveDefaultButton(PWND pwndDlg, PWND pwndStart);
VOID        xxxCheckDefPushButton(PWND pwndDlg, HWND hwndOldFocus, HWND hwndNewFocus);
PWND        xxxGotoNextMnem(PWND pwndDlg, PWND pwndStart, WCHAR ch);
VOID        DlgSetFocus(HWND hwnd);
void        RepositionRect(PMONITOR pMonitor, LPRECT lprc, DWORD dwStyle, DWORD dwExStyle);
BOOL        ValidateDialogPwnd(PWND pwnd);
PMONITOR    GetDialogMonitor(HWND hwndOwner, DWORD dwFlags);

HANDLE      GetEditDS(VOID);
VOID        ReleaseEditDS(HANDLE h);
VOID        TellWOWThehDlg(HWND hDlg);

UINT        GetACPCharSet();

/***************************************************************************\
*
* Menus
*
\***************************************************************************/
// cltxt.h
BOOL GetMenuItemInfoInternalW(HMENU hMenu, UINT uID, BOOL fByPosition, LPMENUITEMINFOW lpmii);

#define MENUAPI_INSERT  0
#define MENUAPI_GET     1
#define MENUAPI_SET     2

// clmenu.c
BOOL InternalInsertMenuItem (HMENU hMenu, UINT uID, BOOL fByPosition, LPCMENUITEMINFO lpmii);
BOOL ValidateMENUITEMINFO(LPMENUITEMINFOW lpmiiIn, LPMENUITEMINFOW lpmii, DWORD dwAPICode);
BOOL ValidateMENUINFO(LPCMENUINFO lpmi, DWORD dwAPICode);


// ntstubs.c
BOOL ThunkedMenuItemInfo(HMENU hMenu, UINT  nPosition, BOOL fByPosition,
                            BOOL fInsert, LPMENUITEMINFOW lpmii, BOOL fAnsi);

// menuc.c
void SetMenuItemInfoStruct(HMENU hMenu, UINT wFlags, UINT_PTR wIDNew, LPWSTR pwszNew,
                              LPMENUITEMINFOW pmii);

/***************************************************************************\
*
* Message Boxes
*
\***************************************************************************/


#define WINDOWLIST_PROP_NAME    TEXT("SysBW")
#define MSGBOX_CALLBACK         TEXT("SysMB")

/* Unicode Right-To-Left mark unicode code point. Look in msgbox.c for more info */
#define UNICODE_RLM             0x200f

/***************************************************************************\
*
* MDI Windows
*
\***************************************************************************/

/* maximum number of MDI children windows listed in "Window" menu */
#define MAXITEMS         10

/*
 * MDI typedefs
 */
typedef struct tagSHORTCREATE {
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    HMENU       hMenu;
} SHORTCREATE, *PSHORTCREATE;

typedef struct tagMDIACTIVATEPOS {
    int     cx;
    int     cy;
    int     cxMin;
    int     cyMin;
} MDIACTIVATEPOS, *PMDIACTIVATEPOS;

BOOL CreateMDIChild(PSHORTCREATE pcs, LPMDICREATESTRUCT pmcs, DWORD dwExpWinVerAndFlags, HMENU *phSysMenu, PWND pwndParent);
BOOL MDICompleteChildCreation(HWND hwndChild, HMENU hSysMenu, BOOL fVisible, BOOL fDisabled);

/*
 * MDI defines
 */
#define WS_MDISTYLE     (WS_CHILD | WS_CLIPSIBLINGS | WS_SYSMENU|WS_CAPTION|WS_THICKFRAME|WS_MAXIMIZEBOX|WS_MINIMIZEBOX)
#define WS_MDICOMMANDS  (WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_MDIALLOWED   (WS_MINIMIZE | WS_MAXIMIZE | WS_CLIPCHILDREN | WS_DISABLED | WS_HSCROLL | WS_VSCROLL | 0x0000FFFFL)

#define HAS_SBVERT      0x0100
#define HAS_SBHORZ      0x0200
#define OTHERMAXING     0x0400
#define CALCSCROLL      0x0800

#define SCROLLSUPPRESS  0x0003
#define SCROLLCOUNT     0x00FF

#define CKIDS(pmdi)     (pmdi->cKids)
#define MAXED(pmdi)     (pmdi->hwndMaxedChild)
#define ACTIVE(pmdi)    (pmdi->hwndActiveChild)
#define WINDOW(pmdi)    (pmdi->hmenuWindow)
#define FIRST(pmdi)     (pmdi->idFirstChild)
#define SCROLL(pmdi)    (pmdi->wScroll)
#define ITILELEVEL(pmdi)    (pmdi->iChildTileLevel)
#define HTITLE(pmdi)    (pmdi->pTitle)

#define PROP_MDICLIENT  MAKEINTRESOURCE(0x8CAC)
#define MDIACTIVATE_PROP_NAME   TEXT("MDIA")

PWND  FindPwndChild(PWND pwndMDI, UINT wChildID);
int   MakeMenuItem(LPWSTR lpOut, PWND pwnd);
VOID  ModifyMenuItem(PWND pwnd);
BOOL  MDIAddSysMenu(HMENU hmenuFrame, HWND hwndChild);
BOOL  MDIRemoveSysMenu(HMENU hMenuFrame, HWND hwndChild);
VOID  ShiftMenuIDs(PWND pwnd, PWND pwndVictim);
HMENU MDISetMenu(PWND,BOOL,HMENU,HMENU);
void  MDIRedrawFrame(HWND hwndChild, BOOL fAdd);

/*
 * Drag and Drop menus.
 */
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#include <ole2.h>

/*
 * Prototypes to cast function pointers
 */
typedef HRESULT (* OLEINITIALIZEPROC)(LPVOID);
typedef HRESULT (* OLEUNINITIALIZEPROC)(VOID);
typedef HRESULT (* REGISTERDDPROC)(HWND, LPDROPTARGET);
typedef HRESULT (* REVOKEDDPROC)(HWND);
typedef HRESULT (* DODDPROC)(LPDATAOBJECT, LPDROPSOURCE, DWORD, LPDWORD);

/*
 * Internal IDropTarget interface info
 */
typedef struct tagMNIDROPTARGET
{
   IDropTarget idt;                 /* Interal IDropTarget */
   DWORD dwRefCount;                /* Ref count */
   IDataObject * pido;              /* IDataObject received at DragEnter */
   IDropTarget * pidt;              /* Application IDropTarget, if any */
} MNIDROPTARGET, * PMNIDROPTARGET;

/*
 * OLE procs info (used by LoadOLEOnce GetProcAddress calls)
 */
typedef struct tagGETPROCINFO
{
    FARPROC * ppfn;
    LPCSTR lpsz;
} GETPROCINFO;

/*
 * Special value used by __ClientLoadOLE.
 */
#define OLEWONTLOAD (HINSTANCE)IntToPtr(0xFFFFFFFF)

/*
 * Accelerator table resources list.
 */
typedef struct tagACCELCACHE
{
    struct tagACCELCACHE *pacNext;
    UINT dwLockCount;
    HACCEL hAccel;
    PVOID pRes;
} ACCELCACHE, *PACCELCACHE;


/*
 * x86 callback return function prototype
 */
#if defined(_X86_) && !defined(BUILD_WOW6432)
NTSTATUS
FASTCALL
XyCallbackReturn(
    IN PVOID Buffer,
    IN ULONG Length,
    IN NTSTATUS Status
    );

#define UserCallbackReturn XyCallbackReturn
#else
#define UserCallbackReturn NtCallbackReturn
#endif

/*
 * Reader mode support
 */
typedef LONG (CALLBACK* READERMODEPROC)(LPARAM lParam, int nCode, int dx, int dy);

typedef struct tagREADERMODE {  // rdrm
    UINT cbSize;
    DWORD dwFlags;
    READERMODEPROC pfnReaderModeProc;
    LPARAM lParam;
} READERMODE, *PREADERMODE, *LPREADERMODE;

#define RDRMODE_VERT    0x00000001
#define RDRMODE_HORZ    0x00000002
#define RDRMODE_DIAG    0x00000004

#define RDRCODE_START   1
#define RDRCODE_SCROLL  2
#define RDRCODE_END     3

typedef struct tagREADERINFO {
    READERMODE;
    int dx;
    int dy;
    UINT uCursor;
    HBITMAP hbm;
    UINT dxBmp;
    UINT dyBmp;
} READERINFO, *PREADERINFO;

typedef struct tagREADERWND {
    WND wnd;
    PREADERINFO prdr;
} READERWND, * KPTR_MODIFIER PREADERWND;

BOOL EnterReaderModeHelper(HWND hwnd);

#include "ddemlcli.h"
#include "globals.h"
#include "cscall.h"
#include "ntuser.h"

/***************************************************************************\
*
* DBCS MESSAGING
*
\***************************************************************************/
/*
 * Message keeper for ...
 *
 * Client to Client.
 */
#define GetDispatchDbcsInfo()          (&(GetClientInfo()->achDbcsCF[0]))
/*
 * Client to Server.
 */
#define GetForwardDbcsInfo()           (&(GetClientInfo()->achDbcsCF[1]))
/*
 * Server to Client.
 */
#define GetCallBackDbcsInfo()          (&(GetClientInfo()->msgDbcsCB))

/*
 * Macros for DBCS Messaging for Recieve side.
 */
#define GET_DBCS_MESSAGE_IF_EXIST(_apiName,_pmsg,_wMsgFilterMin,_wMsgFilterMax,bRemoveMsg)  \
                                                                                            \
        if (GetCallBackDbcsInfo()->wParam) {                                                \
            /*                                                                              \
             * Check message filter... only WM_CHAR message will be pushed                  \
             * into CLIENTINFO. Then if WM_CHAR is filtered out, we should                  \
             * get message from queue...                                                    \
             */                                                                             \
            if ((!(_wMsgFilterMin) && !(_wMsgFilterMax)) ||                                 \
                ((_wMsgFilterMin) <= WM_CHAR && (_wMsgFilterMax) >= WM_CHAR)) {             \
                PKERNEL_MSG pmsgDbcs = GetCallBackDbcsInfo();                               \
                /*                                                                          \
                 * Get pushed message.                                                      \
                 *                                                                          \
                 * Backup current message. this backupped message will be used              \
                 * when Apps peek (or get) message from thier WndProc.                      \
                 * (see GetMessageA(), PeekMessageA()...)                                   \
                 *                                                                          \
                 * pmsg->hwnd    = pmsgDbcs->hwnd;                                          \
                 * pmsg->message = pmsgDbcs->message;                                       \
                 * pmsg->wParam  = pmsgDbcs->wParam;                                        \
                 * pmsg->lParam  = pmsgDbcs->lParam;                                        \
                 * pmsg->time    = pmsgDbcs->time;                                          \
                 * pmsg->pt      = pmsgDbcs->pt;                                            \
                 */                                                                         \
                COPY_KERNELMSG_TO_MSG((_pmsg),pmsgDbcs);                                   \
                /*                                                                          \
                 * if we don't want to clear the cached data, just leave it there.          \
                 */                                                                         \
                if (bRemoveMsg) {                                                           \
                    /*                                                                      \
                     * Invalidate pushed message in CLIENTINFO.                             \
                     */                                                                     \
                    pmsgDbcs->wParam = 0;                                                   \
                }                                                                           \
                /*                                                                          \
                 * Set return value to TRUE.                                                \
                 */                                                                         \
                retval = TRUE;                                                              \
                /*                                                                          \
                 * Exit function..                                                          \
                 */                                                                         \
                goto Exit ## _apiName;                                                      \
            }                                                                               \
        }

/*
 * Macros for DBCS Messaging for Send side.
 */
#define BUILD_DBCS_MESSAGE_TO_SERVER_FROM_CLIENTA(_msg,_wParam,_RetVal)                     \
                                                                                            \
        if (IS_DBCS_ENABLED() && (((_msg) == WM_CHAR) || ((_msg) == EM_SETPASSWORDCHAR))) { \
            /*                                                                              \
             * Chech wParam is DBCS character or not.                                       \
             */                                                                             \
            if (IS_DBCS_MESSAGE((_wParam))) {                                               \
                if ((_wParam) & WMCR_IR_DBCSCHAR) {                                         \
                    /*                                                                      \
                     * This message sent with IR_DBCSCHAR, already aligned for conversion   \
                     */                                                                     \
                } else {                                                                    \
                    /*                                                                      \
                     * Make IR_DBCSCHAR compatible DBCS packed message                      \
                     */                                                                     \
                    (_wParam) = MAKEWPARAM(MAKE_IR_DBCSCHAR(LOWORD((_wParam))),0);          \
                }                                                                           \
            } else {                                                                        \
                PBYTE pchDbcsCF = GetForwardDbcsInfo();                                     \
                /*                                                                          \
                 * If we have cached Dbcs LeadingByte character, build A Dbcs character     \
                 * with the TrailingByte in wParam...                                       \
                 */                                                                         \
                if (*pchDbcsCF) {                                                           \
                    WORD DbcsLeadChar = (WORD)(*pchDbcsCF);                                 \
                    /*                                                                      \
                     * HIBYTE(LOWORD(wParam)) = Dbcs LeadingByte.                           \
                     * LOBYTE(LOWORD(wParam)) = Dbcs TrailingByte.                          \
                     */                                                                     \
                    (_wParam) |= (DbcsLeadChar << 8);                                       \
                    /*                                                                      \
                     * Invalidate cached data..                                             \
                     */                                                                     \
                    *pchDbcsCF = 0;                                                         \
                } else if (IsDBCSLeadByteEx(THREAD_CODEPAGE(),LOBYTE(LOWORD(_wParam)))) { \
                    /*                                                                      \
                     * if this is Dbcs LeadByte character, we should wait Dbcs TrailingByte \
                     * to convert this to Unicode. then we cached it here...                \
                     */                                                                     \
                    *pchDbcsCF = LOBYTE(LOWORD((_wParam)));                                 \
                    /*                                                                      \
                     * Right now, we have nothing to do for this, just return with TRUE.    \
                     */                                                                     \
                    return((_RetVal));                                                      \
                }                                                                           \
            }                                                                               \
        }

#define BUILD_DBCS_MESSAGE_TO_CLIENTW_FROM_CLIENTA(_msg,_wParam,_RetVal)                    \
                                                                                            \
        if (IS_DBCS_ENABLED() && (((_msg) == WM_CHAR) || ((_msg) == EM_SETPASSWORDCHAR))) { \
            /*                                                                              \
             * Check wParam is DBCS character or not.                                       \
             */                                                                             \
            if (IS_DBCS_MESSAGE((_wParam))) {                                               \
                if ((_wParam) & WMCR_IR_DBCSCHAR) {                                         \
                    /*                                                                      \
                     * This message sent with IR_DBCSCHAR, already aligned for conversion   \
                     */                                                                     \
                } else {                                                                    \
                    /*                                                                      \
                     * Make IR_DBCSCHAR compatible DBCS packed message                      \
                     */                                                                     \
                    (_wParam) = MAKEWPARAM(MAKE_IR_DBCSCHAR(LOWORD((_wParam))),0);          \
                }                                                                           \
            } else {                                                                        \
                PBYTE pchDbcsCF = GetDispatchDbcsInfo();                                    \
                /*                                                                          \
                 * If we have cached Dbcs LeadingByte character, build A Dbcs character     \
                 * with the TrailingByte in wParam...                                       \
                 */                                                                         \
                if (*pchDbcsCF) {                                                           \
                    WORD DbcsLeadChar = (WORD)(*pchDbcsCF);                                 \
                    /*                                                                      \
                     * HIBYTE(LOWORD(wParam)) = Dbcs LeadingByte.                           \
                     * LOBYTE(LOWORD(wParam)) = Dbcs TrailingByte.                          \
                     */                                                                     \
                    (_wParam) |= (DbcsLeadChar << 8);                                       \
                    /*                                                                      \
                     * Invalidate cached data..                                             \
                     */                                                                     \
                    *pchDbcsCF = 0;                                                         \
                } else if (IsDBCSLeadByteEx(THREAD_CODEPAGE(),LOBYTE(LOWORD(_wParam)))) { \
                    /*                                                                      \
                     * if this is Dbcs LeadByte character, we should wait Dbcs TrailingByte \
                     * to convert this to Unicode. then we cached it here...                \
                     */                                                                     \
                    *pchDbcsCF = LOBYTE(LOWORD((_wParam)));                                 \
                    /*                                                                      \
                     * Right now, we have nothing to do for this, just return with TRUE.    \
                     */                                                                     \
                    return((_RetVal));                                                      \
                }                                                                           \
            }                                                                               \
        }

#define BUILD_DBCS_MESSAGE_TO_CLIENTA_FROM_SERVER(_pmsg,_dwAnsi,_bIrDbcsFormat,bSaveMsg)    \
        /*                                                                                  \
         * _bIrDbcsFormat parameter is only effective WM_CHAR/EM_SETPASSWORDCHAR message    \
         *                                                                                  \
         * (_bIrDbcsFormat == FALSE) dwAnsi has ....                                        \
         *                                                                                  \
         * HIBYTE(LOWORD(_dwAnsi)) = DBCS TrailingByte character.                           \
         * LOBYTE(LOWORD(_dwAnsi)) = DBCS LeadingByte character                             \
         *                           or SBCS character.                                     \
         *                                                                                  \
         * (_bIrDbcsFormat == TRUE) dwAnsi has ....                                         \
         *                                                                                  \
         * HIBYTE(LOWORD(_dwAnsi)) = DBCS LeadingByte character.                            \
         * LOBYTE(LOWORD(_dwAnsi)) = DBCS TrailingByte character                            \
         *                           or SBCS character.                                     \
         */                                                                                 \
    if (IS_DBCS_ENABLED())                                                 \
        switch ((_pmsg)->message) {                                                         \
        case WM_CHAR:                                                                       \
        case EM_SETPASSWORDCHAR:                                                            \
            if (IS_DBCS_MESSAGE((_dwAnsi))) {                                               \
                /*                                                                          \
                 * This is DBCS character..                                                 \
                 */                                                                         \
                if ((_pmsg)->wParam & WMCR_IR_DBCSCHAR) {                                   \
                    /*                                                                      \
                     * Build IR_DBCSCHAR format message.                                    \
                     */                                                                     \
                    if ((_bIrDbcsFormat)) {                                                 \
                        (_pmsg)->wParam = (WPARAM)(LOWORD((_dwAnsi)));                      \
                    } else {                                                                \
                        (_pmsg)->wParam = MAKE_IR_DBCSCHAR(LOWORD((_dwAnsi)));              \
                    }                                                                       \
                } else {                                                                    \
                    PKERNEL_MSG pDbcsMsg = GetCallBackDbcsInfo();                           \
                    if ((_bIrDbcsFormat)) {                                                 \
                        /*                                                                  \
                         * if the format is IR_DBCSCHAR format, adjust it to regular        \
                         * WPARAM format...                                                 \
                         */                                                                 \
                        (_dwAnsi) = MAKE_WPARAM_DBCSCHAR((_dwAnsi));                        \
                    }                                                                       \
                    if ((bSaveMsg)) {                                                       \
                        /*                                                                  \
                         * Copy this message to CLIENTINFO for next GetMessage              \
                         * or PeekMesssage() call.                                          \
                         */                                                                 \
                        COPY_MSG_TO_KERNELMSG(pDbcsMsg,(_pmsg));                            \
                        /*                                                                  \
                         * Only Dbcs Trailingbyte is nessesary for pushed message. we'll    \
                         * pass this message when GetMessage/PeekMessage is called at next. \
                         */                                                                 \
                        pDbcsMsg->wParam = (WPARAM)(((_dwAnsi) & 0x0000FF00) >> 8);         \
                    }                                                                       \
                    /*                                                                      \
                     * Return DbcsLeading byte to Apps.                                     \
                     */                                                                     \
                    (_pmsg)->wParam =  (WPARAM)((_dwAnsi) & 0x000000FF);                    \
                }                                                                           \
            } else {                                                                        \
                /*                                                                          \
                 * This is single byte character... set it to wParam.                       \
                 */                                                                         \
                (_pmsg)->wParam = (WPARAM)((_dwAnsi) & 0x000000FF);                         \
            }                                                                               \
            break;                                                                          \
        case WM_IME_CHAR:                                                                   \
        case WM_IME_COMPOSITION:                                                            \
            /*                                                                              \
             * if the message is not adjusted to IR_DBCSCHAR format yet,                    \
             * Build WM_IME_xxx format message.                                             \
             */                                                                             \
            if (!(_bIrDbcsFormat)) {                                                        \
                (_pmsg)->wParam = MAKE_IR_DBCSCHAR(LOWORD((_dwAnsi)));                      \
            }                                                                               \
            break;                                                                          \
        default:                                                                            \
            (_pmsg)->wParam = (WPARAM)(_dwAnsi);                                            \
            break;                                                                          \
        } /* switch */                                                                      \
    else                                                                                    \

#define BUILD_DBCS_MESSAGE_TO_CLIENTW_FROM_SERVER(_msg,_wParam)                             \
                                                                                            \
        if (((_msg) == WM_CHAR) || ((_msg) == EM_SETPASSWORDCHAR)) {                        \
            /*                                                                              \
             * Only LOWORD of WPARAM is valid for WM_CHAR....                               \
             * (Mask off DBCS messaging information.)                                       \
             */                                                                             \
            (_wParam) &= 0x0000FFFF;                                                        \
        }

#define BUILD_DBCS_MESSAGE_TO_CLIENTA_FROM_CLIENTW(_hwnd,_msg,_wParam,_lParam,_time,_pt,_bDbcs) \
                                                                                                \
        if (IS_DBCS_ENABLED() && (((_msg) == WM_CHAR) || ((_msg) == EM_SETPASSWORDCHAR))) {     \
            /*                                                                                  \
             * Check this message is DBCS Message or not..                                      \
             */                                                                                 \
            if (IS_DBCS_MESSAGE((_wParam))) {                                                   \
                PKERNEL_MSG pmsgDbcsCB = GetCallBackDbcsInfo();                                 \
                /*                                                                              \
                 * Mark this is DBCS character.                                                 \
                 */                                                                             \
                (_bDbcs) = TRUE;                                                                \
                /*                                                                              \
                 * Backup current message. this backupped message will be used                  \
                 * when Apps peek (or get) message from thier WndProc.                          \
                 * (see GetMessageA(), PeekMessageA()...)                                       \
                 */                                                                             \
                pmsgDbcsCB->hwnd    = (_hwnd);                                                  \
                pmsgDbcsCB->message = (_msg);                                                   \
                pmsgDbcsCB->lParam  = (_lParam);                                                \
                pmsgDbcsCB->time    = (_time);                                                  \
                pmsgDbcsCB->pt      = (_pt);                                                    \
                /*                                                                              \
                 * DbcsLeadByte will be sent below soon, we just need DbcsTrailByte             \
                 * for further usage..                                                          \
                 */                                                                             \
                pmsgDbcsCB->wParam = ((_wParam) & 0x000000FF);                                  \
                /*                                                                              \
                 * Pass the LeadingByte of the DBCS character to an ANSI WndProc.               \
                 */                                                                             \
                (_wParam) = ((_wParam) & 0x0000FF00) >> 8;                                      \
            } else {                                                                            \
                /*                                                                              \
                 * Validate only BYTE for WM_CHAR.                                              \
                 */                                                                             \
                (_wParam) &= 0x000000FF;                                                        \
            }                                                                                   \
        }

#define DISPATCH_DBCS_MESSAGE_IF_EXIST(_msg,_wParam,_bDbcs,_apiName)                            \
        /*                                                                                      \
         * Check we need to send trailing byte or not, if the wParam has Dbcs character         \
         */                                                                                     \
        if (IS_DBCS_ENABLED() && (_bDbcs) && (GetCallBackDbcsInfo()->wParam)) {                 \
            PKERNEL_MSG pmsgDbcsCB = GetCallBackDbcsInfo();                                            \
            /*                                                                                  \
             * If an app didn't peek (or get) the trailing byte from within                     \
             * WndProc, and then pass the DBCS TrailingByte to the ANSI WndProc here            \
             * pmsgDbcsCB->wParam has DBCS TrailingByte here.. see above..                      \
             */                                                                                 \
            (_wParam) = KERNEL_WPARAM_TO_WPARAM(pmsgDbcsCB->wParam);                            \
            /*                                                                                  \
             * Invalidate cached message.                                                       \
             */                                                                                 \
            pmsgDbcsCB->wParam = 0;                                                             \
            /*                                                                                  \
             * Send it....                                                                      \
             */                                                                                 \
            goto _apiName ## Again;                                                             \
        }

#define CalcAnsiStringLengthW(_unicodestring,_unicodeLength,_ansiLength)                        \
        /*                                                                                      \
         * Get AnsiStringLength from UnicodeString,UnicodeLength                                \
         */                                                                                     \
        {                                                                                       \
            RtlUnicodeToMultiByteSize((ULONG *)(_ansiLength),                                   \
                                      (LPWSTR)(_unicodestring),                                 \
                                      (ULONG)((_unicodeLength)*sizeof(WCHAR)));                 \
        }

#define CalcAnsiStringLengthA(_ansistring,_unicodeLength,_ansiLength)                           \
        /*                                                                                      \
         * Get AnsiStringLength from AnsiString,UnicodeLength                                   \
         */                                                                                     \
        {                                                                                       \
            LPSTR _string = (_ansistring);                                                      \
            LONG  _length = (LONG)(_unicodeLength);                                             \
            (*(_ansiLength)) = 0;                                                               \
            while(*_string && _length) {                                                        \
                if(IsDBCSLeadByte(*_string)) {                                                  \
                    (*(_ansiLength)) += 2; _string++;                                           \
                } else {                                                                        \
                    (*(_ansiLength))++;                                                         \
                }                                                                               \
                _string++; _length--;                                                           \
            }                                                                                   \
        }

#define CalcUnicodeStringLengthA(_ansistring,_ansiLength,_unicodeLength)                        \
        /*                                                                                      \
         * Get UnicodeLength from AnsiString,AnsiLength                                         \
         */                                                                                     \
        {                                                                                       \
            RtlMultiByteToUnicodeSize((ULONG *)(_unicodeLength),                                \
                                      (LPSTR)(_ansistring),                                     \
                                      (ULONG)(_ansiLength));                                    \
            (*(_unicodeLength)) /= sizeof(WCHAR);                                               \
        }

#define CalcUnicodeStringLengthW(_unicodestring,_ansiLength,_unicodeLength)                     \
        /*                                                                                      \
         * Get UnicodeLength from UnicodeString,AnsiLength                                      \
         */                                                                                     \
        {                                                                                       \
            LPWSTR _string = (_unicodestring);                                                  \
            LONG   _length = (LONG)(_ansiLength);                                               \
            LONG   _charlength;                                                                 \
            (*(_unicodeLength)) = 0;                                                            \
            while(*_string && (_length > 0)) {                                                  \
                CalcAnsiStringLengthW(_string,1,&_charlength);                                  \
                _length -= _charlength;                                                         \
                if(_length >= 0) {                                                              \
                    (*(_unicodeLength))++;                                                      \
                }                                                                               \
                _string++;                                                                      \
            }                                                                                   \
        }


/*
 * DBCS function defined in userrtl.lib (see ..\rtl\userrtl.h)
 */
DWORD UserGetCodePage(HDC hdc);
BOOL  UserIsFullWidth(DWORD dwCodePage,WCHAR wChar);
BOOL  UserIsFELineBreak(DWORD dwCodePage,WCHAR wChar);


// FE_IME   // fareast.c
typedef struct {
    BOOL (WINAPI* ImmWINNLSEnableIME)(HWND, BOOL);
    BOOL (WINAPI* ImmWINNLSGetEnableStatus)(HWND);
    LRESULT (WINAPI* ImmSendIMEMessageExW)(HWND, LPARAM);
    LRESULT (WINAPI* ImmSendIMEMessageExA)(HWND, LPARAM);
    BOOL (WINAPI* ImmIMPGetIMEW)(HWND, LPIMEPROW);
    BOOL (WINAPI* ImmIMPGetIMEA)(HWND, LPIMEPROA);
    BOOL (WINAPI* ImmIMPQueryIMEW)(LPIMEPROW);
    BOOL (WINAPI* ImmIMPQueryIMEA)(LPIMEPROA);
    BOOL (WINAPI* ImmIMPSetIMEW)(HWND, LPIMEPROW);
    BOOL (WINAPI* ImmIMPSetIMEA)(HWND, LPIMEPROA);

    HIMC (WINAPI* ImmAssociateContext)(HWND, HIMC);
    LRESULT (WINAPI* ImmEscapeA)(HKL, HIMC, UINT, LPVOID);
    LRESULT (WINAPI* ImmEscapeW)(HKL, HIMC, UINT, LPVOID);
    LONG (WINAPI* ImmGetCompositionStringA)(HIMC, DWORD, LPVOID, DWORD);
    LONG (WINAPI* ImmGetCompositionStringW)(HIMC, DWORD, LPVOID, DWORD);
    BOOL (WINAPI* ImmGetCompositionWindow)(HIMC, LPCOMPOSITIONFORM);
    HIMC (WINAPI* ImmGetContext)(HWND);
    HWND (WINAPI* ImmGetDefaultIMEWnd)(HWND);
    BOOL (WINAPI* ImmIsIME)(HKL);
    BOOL (WINAPI* ImmReleaseContext)(HWND, HIMC);
    BOOL (*ImmRegisterClient)(PSHAREDINFO, HINSTANCE);

    BOOL (WINAPI* ImmGetCompositionFontW)(HIMC, LPLOGFONTW);
    BOOL (WINAPI* ImmGetCompositionFontA)(HIMC, LPLOGFONTA);
    BOOL (WINAPI* ImmSetCompositionFontW)(HIMC, LPLOGFONTW);
    BOOL (WINAPI* ImmSetCompositionFontA)(HIMC, LPLOGFONTA);

    BOOL (WINAPI* ImmSetCompositionWindow)(HIMC, LPCOMPOSITIONFORM);
    BOOL (WINAPI* ImmNotifyIME)(HIMC, DWORD, DWORD, DWORD);
    PINPUTCONTEXT (WINAPI* ImmLockIMC)(HIMC);
    BOOL (WINAPI* ImmUnlockIMC)(HIMC);
    BOOL (WINAPI* ImmLoadIME)(HKL);
    BOOL (WINAPI* ImmSetOpenStatus)(HIMC, BOOL);
    BOOL (WINAPI* ImmFreeLayout)(DWORD);
    BOOL (WINAPI* ImmActivateLayout)(HKL);
    BOOL (WINAPI* ImmGetCandidateWindow)(HIMC, DWORD, LPCANDIDATEFORM);
    BOOL (WINAPI* ImmSetCandidateWindow)(HIMC, LPCANDIDATEFORM);
    BOOL (WINAPI* ImmConfigureIMEW)(HKL, HWND, DWORD, LPVOID);
    BOOL (WINAPI* ImmGetConversionStatus)(HIMC, LPDWORD, LPDWORD);
    BOOL (WINAPI* ImmSetConversionStatus)(HIMC, DWORD, DWORD);
    BOOL (WINAPI* ImmSetStatusWindowPos)(HIMC, LPPOINT);
    BOOL (WINAPI* ImmGetImeInfoEx)(PIMEINFOEX, IMEINFOEXCLASS, PVOID);
    PIMEDPI (WINAPI* ImmLockImeDpi)(HKL);
    VOID (WINAPI* ImmUnlockImeDpi)(PIMEDPI);
    BOOL (WINAPI* ImmGetOpenStatus)(HIMC);
    BOOL (*ImmSetActiveContext)(HWND, HIMC, BOOL);
    BOOL (*ImmTranslateMessage)(HWND, UINT, WPARAM, LPARAM);
    BOOL (*ImmLoadLayout)(HKL, PIMEINFOEX);
    DWORD (WINAPI* ImmProcessKey)(HWND, HKL, UINT, LPARAM, DWORD);
    LRESULT (*ImmPutImeMenuItemsIntoMappedFile)(HIMC);
    DWORD (WINAPI* ImmGetProperty)(HKL hKL, DWORD dwIndex);
    BOOL (WINAPI* ImmSetCompositionStringA)(
        HIMC hImc, DWORD dwIndex, LPCVOID lpComp, DWORD dwCompLen, LPCVOID lpRead, DWORD dwReadLen);
    BOOL (WINAPI* ImmSetCompositionStringW)(
        HIMC hImc, DWORD dwIndex, LPCVOID lpComp, DWORD dwCompLen, LPCVOID lpRead, DWORD dwReadLen);
    BOOL (WINAPI* ImmEnumInputContext)(
        DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);
    LRESULT (WINAPI* ImmSystemHandler)(HIMC, WPARAM, LPARAM);

#ifdef CUAS_ENABLE
    // Cicero
    HRESULT (WINAPI* CtfImmTIMActivate)(HKL hKL);
    void (WINAPI* CtfImmRestoreToolbarWnd)(DWORD dwPrevSts);
    DWORD (WINAPI* CtfImmHideToolbarWnd)(void);
    LRESULT (WINAPI* CtfImmDispatchDefImeMessage)(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
#endif // CUAS_ENABLE
} ImmApiEntries;

extern ImmApiEntries gImmApiEntries;
extern HMODULE ghImm32;
VOID InitializeImmEntryTable(VOID);
VOID GetImmFileName(PWSTR);
VOID CliImmInitializeHotKeys(DWORD dwAction, HKL hkl);

#define fpImmAssociateContext       gImmApiEntries.ImmAssociateContext
#define fpImmEscapeA                gImmApiEntries.ImmEscapeA
#define fpImmEscapeW                gImmApiEntries.ImmEscapeW
#define fpImmGetContext             gImmApiEntries.ImmGetContext
#define fpImmGetCompositionStringA  gImmApiEntries.ImmGetCompositionStringA
#define fpImmGetCompositionStringW  gImmApiEntries.ImmGetCompositionStringW
#define fpImmGetCompositionWindow   gImmApiEntries.ImmGetCompositionWindow
#define fpImmGetDefaultIMEWnd       gImmApiEntries.ImmGetDefaultIMEWnd
#define fpImmIsIME                  gImmApiEntries.ImmIsIME
#define fpImmLockIMC                gImmApiEntries.ImmLockIMC
#define fpImmReleaseContext         gImmApiEntries.ImmReleaseContext
#define fpImmRegisterClient         gImmApiEntries.ImmRegisterClient
#define fpImmGetCompositionFontW    gImmApiEntries.ImmGetCompositionFontW
#define fpImmGetCompositionFontA    gImmApiEntries.ImmGetCompositionFontA
#define fpImmSetCompositionFontW    gImmApiEntries.ImmSetCompositionFontW
#define fpImmSetCompositionFontA    gImmApiEntries.ImmSetCompositionFontA
#define fpImmSetCompositionFont     gImmApiEntries.ImmSetCompositionFont
#define fpImmSetCompositionWindow   gImmApiEntries.ImmSetCompositionWindow
#define fpImmNotifyIME              gImmApiEntries.ImmNotifyIME
#define fpImmUnlockIMC              gImmApiEntries.ImmUnlockIMC
#define fpImmLoadIME                gImmApiEntries.ImmLoadIME
#define fpImmSetOpenStatus          gImmApiEntries.ImmSetOpenStatus
#define fpImmFreeLayout             gImmApiEntries.ImmFreeLayout
#define fpImmActivateLayout         gImmApiEntries.ImmActivateLayout
#define fpImmGetCandidateWindow     gImmApiEntries.ImmGetCandidateWindow
#define fpImmSetCandidateWindow     gImmApiEntries.ImmSetCandidateWindow
#define fpImmConfigureIMEW          gImmApiEntries.ImmConfigureIMEW
#define fpImmGetConversionStatus    gImmApiEntries.ImmGetConversionStatus
#define fpImmSetConversionStatus    gImmApiEntries.ImmSetConversionStatus
#define fpImmSetStatusWindowPos     gImmApiEntries.ImmSetStatusWindowPos
#define fpImmGetImeInfoEx           gImmApiEntries.ImmGetImeInfoEx
#define fpImmLockImeDpi             gImmApiEntries.ImmLockImeDpi
#define fpImmUnlockImeDpi           gImmApiEntries.ImmUnlockImeDpi
#define fpImmGetOpenStatus          gImmApiEntries.ImmGetOpenStatus
#define fpImmSetActiveContext       gImmApiEntries.ImmSetActiveContext
#define fpImmTranslateMessage       gImmApiEntries.ImmTranslateMessage
#define fpImmLoadLayout             gImmApiEntries.ImmLoadLayout
#define fpImmProcessKey             gImmApiEntries.ImmProcessKey
#define fpImmPutImeMenuItemsIntoMappedFile gImmApiEntries.ImmPutImeMenuItemsIntoMappedFile
#define fpImmGetProperty            gImmApiEntries.ImmGetProperty
#define fpImmSetCompositionStringA  gImmApiEntries.ImmSetCompositionStringA
#define fpImmSetCompositionStringW  gImmApiEntries.ImmSetCompositionStringW
#define fpImmEnumInputContext       gImmApiEntries.ImmEnumInputContext
#define fpImmSystemHandler          gImmApiEntries.ImmSystemHandler

BOOL SyncSoftKbdState(HIMC hImc, LPARAM lParam); // imectl.c

#ifdef CUAS_ENABLE
// Cicero
#define fpCtfImmTIMActivate            gImmApiEntries.CtfImmTIMActivate
#define fpCtfImmRestoreToolbarWnd      gImmApiEntries.CtfImmRestoreToolbarWnd
#define fpCtfImmHideToolbarWnd         gImmApiEntries.CtfImmHideToolbarWnd
#define fpCtfImmDispatchDefImeMessage  gImmApiEntries.CtfImmDispatchDefImeMessage

#endif // CUAS_ENABLE


// end FE_IME

/*
 * Rebasing functions for shared memory. Need to located after
 * inclusion of globals.h.
 */
__inline PVOID
REBASESHAREDPTRALWAYS(KERNEL_PVOID p)
{
    return (PVOID)(((KERNEL_UINT_PTR)p) - gSharedInfo.ulSharedDelta);
}

__inline PVOID
REBASESHAREDPTR(KERNEL_PVOID p)
{
    return (p) ? REBASESHAREDPTRALWAYS(p) : NULL;
}

/*
 * Multimonitor macros used in RTL. There are similar definitions
 * in kernel\userk.h
 */
__inline PDISPLAYINFO
GetDispInfo(VOID)
{
    return gSharedInfo.pDispInfo;
}

__inline PMONITOR
GetPrimaryMonitor(VOID)
{
    return REBASESHAREDPTR(GetDispInfo()->pMonitorPrimary);
}


/*
 * UserApiHook functions
 */

__inline BOOL IsInsideUserApiHook(
    VOID)
{
    return (ghmodUserApiHook != NULL) && gfUserApiHook;
}

__inline BOOL _BeginIfHookedUserApiHook()
{
    UserAssert(gcCallUserApiHook < MAXLONG);

    InterlockedIncrement(&gcCallUserApiHook);
    if (!IsInsideUserApiHook()) {
        InterlockedDecrement(&gcCallUserApiHook);
        return FALSE;
    } else {
        UserAssertMsg0(ghmodUserApiHook != NULL, "Should not reach 0 while outstanding call");
        return TRUE;
    }
}

VOID _EndUserApiHook(VOID);

__inline BOOL _InsideLoaderLock(
    VOID)
{
    return (NtCurrentTeb()->ClientId.UniqueThread ==
            ((PRTL_CRITICAL_SECTION)(NtCurrentPeb()->LoaderLock))->OwningThread);
}

__inline VOID _AcquireLoaderLock(
    VOID)
{
    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
}

__inline VOID _ReleaseLoaderLock(
    VOID)
{
    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
}

#define BEGIN_USERAPIHOOK()                                                 \
    {                                                                       \
        BOOL fInsideHook = IsInsideUserApiHook();                           \
                                                                            \
        if (!gfServerProcess && !fInsideHook && TEST_SRVIF(SRVIF_HOOKED)) { \
            if (!_InsideLoaderLock()) {                                     \
                NtUserCallNoParam(SFI_XXXLOADUSERAPIHOOK);                  \
            }                                                               \
        }                                                                   \
                                                                            \
        fInsideHook = _BeginIfHookedUserApiHook();                          \
        try {                                                               \


#define END_USERAPIHOOK()               \
        } finally {                     \
            if (fInsideHook) {          \
                _EndUserApiHook();      \
            }                           \
        }                               \
    }                                   \


#ifdef MESSAGE_PUMP_HOOK

__inline BOOL IsInsideMessagePumpHook()
{
    PCLIENTTHREADINFO pcti = GetClientInfo()->pClientThreadInfo;
    return gfMessagePumpHook && (pcti != NULL) && (pcti->cMessagePumpHooks > 0);
}

#define BEGIN_MESSAGEPUMPHOOK()                         \
    {                                                   \
        BOOL fInsideHook = IsInsideMessagePumpHook();   \


#define END_MESSAGEPUMPHOOK()           \
    }                                   \

#endif // MESSAGE_PUMP_HOOK


int RealSetScrollInfo(HWND hwnd, int fnBar, LPCSCROLLINFO lpsi, BOOL fRedraw);
BOOL RealGetScrollInfo(HWND hwnd, int code, LPSCROLLINFO lpsi);
BOOL RealEnableScrollBar(HWND hWnd, UINT wSBflags, UINT wArrows);
BOOL RealAdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle);
BOOL RealSetWindowRgn(HWND hwnd, HRGN hrgn, BOOL bRedraw);
int RealGetSystemMetrics(int index);
BOOL RealSystemParametersInfoA(UINT wFlag, UINT wParam, PVOID lParam, UINT flags);
BOOL RealSystemParametersInfoW(UINT wFlag, UINT wParam, PVOID lParam, UINT flags);
BOOL ForceResetUserApiHook(HMODULE hmod);
BOOL RealDrawFrameControl(HDC hdc, LPRECT lprc, UINT wType, UINT wState);
BOOL RealDrawCaption(HWND hwnd, HDC hdc, CONST RECT *lprc, UINT flags);
void RealMDIRedrawFrame(HWND hwndChild, BOOL fAdd);


/*
 * Event logging stuff
 */
HANDLE InitLogging(LPWSTR lpszSource);
HMODULE LoadAdvApi32(VOID);
VOID UnloadAdvApi32(VOID);
BOOL GetCurrentProcessName(WCHAR *pszProcessName, int cch);
BOOL GetUserSid(PTOKEN_USER *ppTokenUser);
VOID UnloadLogging(HANDLE hEventLog);

#define LOAD_ADVAPI_FN(var, a, err)                                         \
    if ((var = (void*)GetProcAddress(ghAdvApi, #a)) == NULL) {              \
        RIPMSG0(RIP_WARNING, "GetProcAddress " #a " failed.");              \
        UnloadAdvApi32();                                                   \
        return err;                                                         \
    }

#ifdef _JANUS_
BOOL InitInstrument(LPDWORD lpEMIControl);
#endif

#define MAX_ATOM_LEN    256
LPWSTR ClassNameToVersion (LPCWSTR lpClassName, LPWSTR pClassVerName, LPWSTR* lpDllName,BOOL bIsANSI);


#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#define TEST_DUSER_WMH 0

#if TEST_DUSER_WMH

DECLARE_HANDLE(HDCONTEXT);

typedef struct tagINITGADGET
{
    DWORD       cbSize;         // Size of structure
    UINT        nThreadMode;    // Threading model
    UINT        nMsgMode;       // DirectUser/Core messaging subsystem mode
    HDCONTEXT   hctxShare;      // Existing context to share with
} INITGADGET;

typedef HDCONTEXT (WINAPI * InitGadgetsProc)(INITGADGET * pInit);
extern HDCONTEXT g_hctx;        // DirectUser Context

#define IGTM_SEPARATE           (2)     // | MT with single thread per context

#define IGMM_STANDARD           (3)     // | Standard mode on Whistler

#endif // TEST_DUSER_WMH

#endif // !_USERCLI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\strings.c ===
/****************************** Module Header ******************************\
* Module Name: strings.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the string handling APIs and functions.  Since
* they don't access server-specific data they belong here in the client DLL.
*
* History:
* 10-18-90 DarrinM      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/* LATER these should be in a public header file!!!
 * Assorted defines used to support the standard Windows ANSI code page
 * (now known as code page 1252 and officially registered by IBM).
 * This is intended only for the PDK release.  Subsequent releases will
 * use the NLSAPI and Unicode.
 */
#define LATIN_CAPITAL_LETTER_A_GRAVE    (CHAR)0xc0
#define LATIN_CAPITAL_LETTER_THORN      (CHAR)0xde
#define LATIN_SMALL_LETTER_SHARP_S      (CHAR)0xdf
#define LATIN_SMALL_LETTER_Y_DIAERESIS  (CHAR)0xff
#define DIVISION_SIGN                   (CHAR)0xf7
#define MULTIPLICATION_SIGN             (CHAR)0xd7


/***************************************************************************\
* CharLowerA (API)
*
* Convert either a single character or an entire string to lower case.  The
* two cases are differentiated by checking the high-word of psz.  If it is
* 0 then we just convert the low-word of psz.
*
* History:
* 11-26-90 DarrinM      Created non-NLS version.
* 06-22-91 GregoryW     Modified to support code page 1252.  This is for
*                       the PDK release only.  After the PDK this routine
*                       will be modified to use the NLSAPI.  Also renamed
*                       API to conform to new naming conventions.  AnsiLower
*                       is now a #define which resolves to this routine.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, LPSTR, WINAPI, CharLowerA, LPSTR, psz)
LPSTR WINAPI CharLowerA(
    LPSTR psz)
{
    NTSTATUS st;

    /*
     * Early out for NULL string or '\0'
     */
    if (psz == NULL) {
        return psz;
    }

    if (!IS_PTR(psz)) {
        WCHAR wch;

#ifdef FE_SB // CharLowerA()
        /*
         * if only DBCS Leadbyte was passed, just return the character.
         * Same behavior as Windows 3.1J and Windows 95 FarEast version.
         */
        if (IS_DBCS_ENABLED() && IsDBCSLeadByte((BYTE)(ULONG_PTR)psz)) {
            return psz;
        }
#endif // FE_SB

        //
        // LATER 14 Feb 92 GregoryW
        //    For DBCS code pages is a double byte character ever
        //    passed in the low word of psz or is the high nibble
        //    of the low word always ignored?
        //
        st = RtlMultiByteToUnicodeN(&wch, sizeof(WCHAR), NULL, (PCH)&psz, sizeof(CHAR));
        if (!NT_SUCCESS(st)) {
            /*
             * Failed!  Caller is not expecting failure, CharLowerA does not
             * have a failure indicator, so just return the original character.
             */
            RIPMSG1(RIP_WARNING, "CharLowerA(%#p) failed\n", psz);
        } else {
            /*
             * The next two calls never fail.
             */
            LCMapStringW(LOCALE_USER_DEFAULT, LCMAP_LOWERCASE, &wch, 1, &wch, 1);
            RtlUnicodeToMultiByteN((PCH)&psz, sizeof(CHAR), NULL, &wch, sizeof(WCHAR));
        }
        return psz;

    }

    /*
     * psz is a null-terminated string
     */
    CharLowerBuffA(psz, strlen(psz)+1);
    return psz;
}


/***************************************************************************\
* CharUpperA (API)
*
* Convert either a single character or an entire string to upper case.  The
* two cases are differentiated by checking the high-word of psz.  If it is
* 0 then we just convert the low-word of psz.
*
* History:
* 12-03-90 IanJa        derived from DarrinM's non-NLS AnsiLower
* 06-22-91 GregoryW     Modified to support code page 1252.  This is for
*                       the PDK release only.  After the PDK this routine
*                       will be modified to use the NLSAPI.  Also renamed
*                       API to conform to new naming conventions.  AnsiUpper
*                       is now a #define which resolves to this routine.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, LPSTR, WINAPI, CharUpperA, LPSTR, psz)
LPSTR WINAPI CharUpperA(
    LPSTR psz)
{
    NTSTATUS st;

    /*
     * Early out for NULL string or '\0'
     */
    if (psz == NULL) {
        return psz;
    }

    if (!IS_PTR(psz)) {
        WCHAR wch;

#ifdef FE_SB // CharLowerA()
        /*
         * if only DBCS Leadbyte was passed, just return the character.
         * Same behavior as Windows 3.1J and Windows 95 FarEast version.
         */
        if (IS_DBCS_ENABLED() && IsDBCSLeadByte((BYTE)(ULONG_PTR)psz)) {
            return psz;
        }
#endif // FE_SB

        //
        // LATER 14 Feb 92 GregoryW
        //    For DBCS code pages is a double byte character ever
        //    passed in the low word of psz or is the high nibble
        //    of the low word always ignored?
        //
        st = RtlMultiByteToUnicodeN(&wch, sizeof(WCHAR), NULL, (PCH)&psz, sizeof(CHAR));
        if (!NT_SUCCESS(st)) {
            /*
             * Failed!  Caller is not expecting failure, CharUpperA does not
             * have a failure indicator, so return the original character.
             */
            RIPMSG1(RIP_WARNING, "CharUpperA(%#p) failed\n", psz);
        } else {
            /*
             * The next two calls never fail.
             */
            LCMapStringW(LOCALE_USER_DEFAULT, LCMAP_UPPERCASE, &wch, 1, &wch, 1);
            RtlUnicodeToMultiByteN((PCH)&psz, sizeof(CHAR), NULL, &wch, sizeof(WCHAR));
        }
        return psz;

    }

    /*
     * psz is a null-terminated string
     */
    CharUpperBuffA(psz, strlen(psz)+1);
    return psz;
}


/***************************************************************************\
* CharNextA (API)
*
* Move to next character in string unless already at '\0' terminator
* DOES NOT WORK CORRECTLY FOR DBCS (eg: Japanese)
*
* History:
* 12-03-90 IanJa        Created non-NLS version.
* 06-22-91 GregoryW     Renamed API to conform to new naming conventions.
*                       AnsiNext is now a #define which resolves to this
*                       routine.  This routine is only intended to support
*                       code page 1252 for the PDK release.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, LPSTR, WINAPI, CharNextA, LPCSTR, lpCurrentChar)
LPSTR WINAPI CharNextA(
    LPCSTR lpCurrentChar)
{
#ifdef FE_SB // CharNextA(): dbcs enabling
    if (IS_DBCS_ENABLED() && IsDBCSLeadByte(*lpCurrentChar)) {
        lpCurrentChar++;
    }
    /*
     * if we have only DBCS LeadingByte, we will point string-terminaler.
     */
#endif // FE_SB

    if (*lpCurrentChar) {
        lpCurrentChar++;
    }
    return (LPSTR)lpCurrentChar;
}


/***************************************************************************\
* CharNextExA (API)
*
* Move to next character in string unless already at '\0' terminator.
*
* History:
* 05-01-95 GregoryW     Ported from Win95.
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, LPSTR, WINAPI, CharNextExA, WORD, CodePage, LPCSTR, lpCurrentChar, DWORD, dwFlags)
LPSTR WINAPI CharNextExA(
    WORD CodePage,
    LPCSTR lpCurrentChar,
    DWORD dwFlags)
{
    if (lpCurrentChar == (LPSTR)NULL)
    {
        return (LPSTR)lpCurrentChar;
    }

    if (IsDBCSLeadByteEx(CodePage, *lpCurrentChar))
    {
        lpCurrentChar++;
    }

    if (*lpCurrentChar)
    {
        lpCurrentChar++;
    }
    return (LPSTR)lpCurrentChar;

    UNREFERENCED_PARAMETER(dwFlags);
}


/***************************************************************************\
* CharPrevA (API)
*
* Move to previous character in string, unless already at start
* DOES NOT WORK CORRECTLY FOR DBCS (eg: Japanese)
*
* History:
* 12-03-90 IanJa        Created non-NLS version.
* 06-22-91 GregoryW     Renamed API to conform to new naming conventions.
*                       AnsiPrev is now a #define which resolves to this
*                       routine.  This routine is only intended to support
*                       code page 1252 for the PDK release.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, LPSTR, WINAPI, CharPrevA, LPCSTR, lpStart, LPCSTR, lpCurrentChar)
LPSTR WINAPI CharPrevA(
    LPCSTR lpStart,
    LPCSTR lpCurrentChar)
{
#ifdef FE_SB // CharPrevA : dbcs enabling
    if (lpCurrentChar > lpStart) {
        if (IS_DBCS_ENABLED()) {
            LPCSTR lpChar;
            BOOL bDBC = FALSE;

            for (lpChar = --lpCurrentChar - 1 ; lpChar >= lpStart ; lpChar--) {
                if (!IsDBCSLeadByte(*lpChar))
                    break;
                bDBC = !bDBC;
            }

            if (bDBC)
                lpCurrentChar--;
        }
        else
            lpCurrentChar--;
    }
    return (LPSTR)lpCurrentChar;
#else
    if (lpCurrentChar > lpStart) {
        lpCurrentChar--;
    }
    return (LPSTR)lpCurrentChar;
#endif // FE_SB
}

/***************************************************************************\
* CharPrevExA (API)
*
* Move to previous character in string, unless already at start.
*
* History:
* 05-01-95 GregoryW     Ported from Win95.
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, LPSTR, WINAPI, CharPrevExA, WORD, CodePage, LPCSTR, lpStart, LPCSTR, lpCurrentChar, DWORD, dwFlags)
LPSTR WINAPI CharPrevExA(
    WORD CodePage,
    LPCSTR lpStart,
    LPCSTR lpCurrentChar,
    DWORD dwFlags)
{
    if (lpCurrentChar > lpStart) {
        LPCSTR lpChar;
        BOOL bDBC = FALSE;

        for (lpChar = --lpCurrentChar - 1 ; lpChar >= lpStart ; lpChar--) {
            if (!IsDBCSLeadByteEx(CodePage, *lpChar))
                break;
            bDBC = !bDBC;
        }

        if (bDBC)
            lpCurrentChar--;
    }
    return (LPSTR)lpCurrentChar;

    UNREFERENCED_PARAMETER(dwFlags);
}


/***************************************************************************\
* CharLowerBuffA (API)
*
* History:
* 14-Jan-1991 mikeke from win 3.0
* 06-22-91 GregoryW     Renamed API to conform to new naming conventions.
*                       AnsiLowerBuff is now a #define which resolves to this
*                       routine.  This routine is only intended to support
*                       code page 1252 for the PDK release.
* 02-20-1992 GregoryW   Modified to use NLS API.
\***************************************************************************/
#define CCH_LOCAL_BUFF 256


FUNCLOG2(LOG_GENERAL, DWORD, WINAPI, CharLowerBuffA, LPSTR, psz, DWORD, nLength)
DWORD WINAPI CharLowerBuffA(
    LPSTR psz,
    DWORD nLength)
{
    ULONG cb;
    WCHAR awchLocal[CCH_LOCAL_BUFF];
    LPWSTR pwszT = awchLocal;
    int cwch;

    if (nLength == 0) {
        return(0);
    }

    /*
     * Convert ANSI to Unicode.
     * Use awchLocal if it is big enough, otherwise allocate space.
     */
    cwch = MBToWCS(
            psz,       // ANSI buffer
            nLength,   // length of buffer
            &pwszT,    // address of Unicode string
            (nLength > CCH_LOCAL_BUFF ? -1 : nLength),
            (nLength > CCH_LOCAL_BUFF) );

    if (cwch != 0) {
        CharLowerBuffW(pwszT, cwch);

        /*
         * This can't fail
         */
        RtlUnicodeToMultiByteN(
                  psz,                   // ANSI string
                  nLength,               // given to us
                  &cb,                   // result length
                  pwszT,                 // Unicode string
                  cwch * sizeof(WCHAR)); // length IN BYTES

        if (pwszT != awchLocal) {
            UserLocalFree(pwszT);
        }

        return (DWORD)cb;
    }

    /*
     * MBToWCS failed!  The caller is not expecting failure,
     * so we convert the string to lower case as best we can.
     */
    RIPMSG2(RIP_WARNING,
            "CharLowerBuffA(%#p, %lx) failed\n", psz, nLength);

    for (cb=0; cb < nLength; cb++) {
#ifdef FE_SB // CharLowerBuffA(): skip double byte character
        if (IS_DBCS_ENABLED() && IsDBCSLeadByte(psz[cb])) {
            cb++;
        } else if (IsCharUpperA(psz[cb])) {
            psz[cb] += 'a'-'A';
        }
#else
        if (IsCharUpperA(psz[cb])) {
            psz[cb] += 'a'-'A';
        }
#endif // FE_SB
    }

    return nLength;
}


/***************************************************************************\
* CharUpperBuffA (API)
*
* History:
* 14-Jan-1991 mikeke from win 3.0
* 06-22-91 GregoryW     Renamed API to conform to new naming conventions.
*                       AnsiUpperBuff is now a #define which resolves to this
*                       routine.  This routine is only intended to support
*                       code page 1252 for the PDK release.
* 02-Feb-1992 GregoryW   Modified to use NLS API.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, DWORD, WINAPI, CharUpperBuffA, LPSTR, psz, DWORD, nLength)
DWORD WINAPI CharUpperBuffA(
    LPSTR psz,
    DWORD nLength)
{
    DWORD cb;
    WCHAR awchLocal[CCH_LOCAL_BUFF];
    LPWSTR pwszT = awchLocal;
    int cwch;

    if (nLength==0) {
        return(0);
    }

    /*
     * Convert ANSI to Unicode.
     * Use awchLocal if it is big enough, otherwise allocate space.
     */
    cwch = MBToWCS(
            psz,       // ANSI buffer
            nLength,   // length of buffer
            &pwszT,    // address of Unicode string
            (nLength > CCH_LOCAL_BUFF ? -1 : nLength),
            (nLength > CCH_LOCAL_BUFF) );

    if (cwch != 0) {
        CharUpperBuffW(pwszT, cwch);

        RtlUnicodeToMultiByteN(
                  psz,                   // address of ANSI string
                  nLength,               // given to us
                  &cb,                   // result length
                  pwszT,                 // Unicode string
                  cwch * sizeof(WCHAR)); // length IN BYTES

        if (pwszT != awchLocal) {
            UserLocalFree(pwszT);
        }

        return (DWORD)cb;
    }

    /*
     * MBToWCS failed!  The caller is not expecting failure,
     * so we convert the string to upper case as best we can.
     */
    RIPMSG2(RIP_WARNING,
            "CharLowerBuffA(%#p, %lx) failed\n", psz, nLength);

    for (cb=0; cb < nLength; cb++) {
#ifdef FE_SB // CharUpperBuffA(): skip double byte characters
        if (IS_DBCS_ENABLED() && IsDBCSLeadByte(psz[cb])) {
            cb++;
        } else if (IsCharLowerA(psz[cb]) &&
                   /*
                    * Sometime, LATIN_xxxx code is DBCS LeadingByte depending on ACP.
                    * In that case, we never come here...
                    */
                   (psz[cb] != LATIN_SMALL_LETTER_SHARP_S) &&
                   (psz[cb] != LATIN_SMALL_LETTER_Y_DIAERESIS)) {
            psz[cb] += 'A'-'a';
        }
#else
        if (IsCharLowerA(psz[cb]) &&
            (psz[cb] != LATIN_SMALL_LETTER_SHARP_S) &&
            (psz[cb] != LATIN_SMALL_LETTER_Y_DIAERESIS)) {
            psz[cb] += 'A'-'a';
        }
#endif // FE_SB
    }

    return nLength;
}


/***************************************************************************\
* IsCharLowerA (API)
*
* History:
* 14-Jan-1991 mikeke from win 3.0
* 22-Jun-1991 GregoryW   Modified to support code page 1252 (Windows ANSI
*                        code page).  This is for the PDK only.  After the
*                        PDK this routine will be rewritten to use the
*                        NLSAPI.
* 02-Feb-1992 GregoryW   Modified to use NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IsCharLowerA, char, cChar)
BOOL WINAPI IsCharLowerA(
    char cChar)
{
    WORD ctype1info = 0;
    WCHAR wChar = 0;

#ifdef FE_SB // IsCharLowerA()
    /*
     * if only DBCS Leadbyte was passed, just return FALSE.
     * Same behavior as Windows 3.1J and Windows 95 FarEast version.
     */
    if (IS_DBCS_ENABLED() && IsDBCSLeadByte(cChar)) {
        return FALSE;
    }
#endif // FE_SB

    /*
     * The following 2 calls cannot fail here
     */
    RtlMultiByteToUnicodeN(&wChar, sizeof(WCHAR), NULL, &cChar, sizeof(CHAR));
    GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info);
    return (ctype1info & C1_LOWER) == C1_LOWER;
}


/***************************************************************************\
* IsCharUpperA (API)
*
* History:
* 22-Jun-1991 GregoryW   Created to support code page 1252 (Windows ANSI
*                        code page).  This is for the PDK only.  After the
*                        PDK this routine will be rewritten to use the
*                        NLSAPI.
* 02-Feb-1992 GregoryW   Modified to use NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IsCharUpperA, char, cChar)
BOOL WINAPI IsCharUpperA(
    char cChar)
{
    WORD ctype1info = 0;
    WCHAR wChar = 0;

#ifdef FE_SB // IsCharUpperA()
    /*
     * if only DBCS Leadbyte was passed, just return FALSE.
     * Same behavior as Windows 3.1J and Windows 95 FarEast version.
     */
    if (IS_DBCS_ENABLED() && IsDBCSLeadByte(cChar)) {
        return FALSE;
    }
#endif // FE_SB

    /*
     * The following 2 calls cannot fail here
     */
    RtlMultiByteToUnicodeN(&wChar, sizeof(WCHAR), NULL, &cChar, sizeof(CHAR));
    GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info);
    return (ctype1info & C1_UPPER) == C1_UPPER;
}


/***************************************************************************\
* IsCharAlphaNumericA (API)
*
* Returns TRUE if character is alphabetical or numerical, otherwise FALSE
*
* History:
* 12-03-90 IanJa        Created non-NLS stub version.
* 06-22-91 GregoryW     Modified to support code page 1252 (Windows ANSI
*                       code page).  This is for the PDK only.  After the
*                       PDK this routine will be rewritten to use the
*                       NLSAPI.
* 02-20-92 GregoryW     Modified to use the NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IsCharAlphaNumericA, char, cChar)
BOOL WINAPI IsCharAlphaNumericA(
    char cChar)
{
    WORD ctype1info = 0;
    WCHAR wChar = 0;

    /*
     * The following 2 calls cannot fail here
     */
    RtlMultiByteToUnicodeN(&wChar, sizeof(WCHAR), NULL, &cChar, sizeof(CHAR));
    GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info);
#ifdef FE_SB // IsCharAlphaNumericA()
    if (ctype1info & C1_ALPHA) {
        WORD ctype3info = 0;
        if (!IS_DBCS_ENABLED()) {
            return TRUE;
        }
        /*
         * We don't want to return TRUE for halfwidth katakana.
         * Katakana is linguistic character (C1_ALPHA), but it is not
         * alphabet character.
         */
        GetStringTypeW(CT_CTYPE3, &wChar, 1, &ctype3info);
        return ((ctype3info & (C3_KATAKANA|C3_HIRAGANA)) ? FALSE : TRUE);
    }
    /* Otherwise, it might be digits ? */
    return !!(ctype1info & C1_DIGIT);
#else
    return (ctype1info & C1_ALPHA) || (ctype1info & C1_DIGIT);
#endif // FE_SB
}


/***************************************************************************\
* IsCharAlphaA (API)
*
* Returns TRUE if character is alphabetical, otherwise FALSE
*
* History:
* 06-22-91 GregoryW     Created to support code page 1252 (Windows ANSI
*                       code page).  This is for the PDK only.  After the
*                       PDK this routine will be rewritten to use the
*                       NLSAPI.
* 02-20-92 GregoryW     Modified to use the NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IsCharAlphaA, char, cChar)
BOOL WINAPI IsCharAlphaA(
    char cChar)
{
    WORD ctype1info = 0;
    WCHAR wChar = 0;

    /*
     * The following 2 calls cannot fail here
     */
    RtlMultiByteToUnicodeN(&wChar, sizeof(WCHAR), NULL, &cChar, sizeof(CHAR));
    GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info);
#ifdef FE_SB // IsCharAlphaA()
    if ((ctype1info & C1_ALPHA) == C1_ALPHA) {
        WORD ctype3info = 0;
        if (!IS_DBCS_ENABLED()) {
            return TRUE;
        }
        /*
         * We don't want to return TRUE for halfwidth katakana.
         * Katakana is linguistic character (C1_ALPHA), but it is not
         * alphabet character.
         */
        GetStringTypeW(CT_CTYPE3, &wChar, 1, &ctype3info);
        return ((ctype3info & (C3_KATAKANA|C3_HIRAGANA)) ? FALSE : TRUE);
    }
    return (FALSE);
#else
    return (ctype1info & C1_ALPHA) == C1_ALPHA;
#endif // FE_SB
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\winable.c ===
/****************************** Module Header ******************************\
* Module Name: winable.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains
*
* History:
* 20-Feb-1992 DarrinM   Pulled functions from user\server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
*
* GetWindowInfo()
* PRIVATE
*
* Gets information about a window in one self-consistent big block.
*
\***************************************************************************/

FUNCLOG2(LOG_GENERAL, BOOL, WINAPI, GetWindowInfo, HWND, hwnd, PWINDOWINFO, pwi)
BOOL WINAPI
GetWindowInfo(HWND hwnd, PWINDOWINFO pwi)
{
    PWND pwnd;
    UINT cBorders;
    PCLS pclsT;

    if (pwi->cbSize != sizeof(WINDOWINFO)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "WINDOWINFO.cbSize %d is wrong", pwi->cbSize);
    }
    /*
     * Validate the window
     */
    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL) {
        return FALSE;
    }

    try {
        // Window rect
        pwi->rcWindow = pwnd->rcWindow;

        // Client rect
        pwi->rcClient = pwnd->rcClient;

        // Style
        pwi->dwStyle = pwnd->style;
        pwi->dwExStyle = pwnd->ExStyle;
        pwi->dwWindowStatus = 0;
        if (TestWF(pwnd, WFFRAMEON))
            pwi->dwWindowStatus |= WS_ACTIVECAPTION;

        // Borders
        cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
        pwi->cxWindowBorders = cBorders * SYSMET(CXBORDER);
        pwi->cyWindowBorders = cBorders * SYSMET(CYBORDER);

        // Type
        pclsT = (PCLS)REBASEALWAYS(pwnd, pcls);
        pwi->atomWindowType = pclsT->atomNVClassName;

        // Version
        if (TestWF(pwnd, WFWIN50COMPAT)) {
            pwi->wCreatorVersion = VER50;
        } else if (TestWF(pwnd, WFWIN40COMPAT)) {
            pwi->wCreatorVersion = VER40;
        } else if (TestWF(pwnd, WFWIN31COMPAT)) {
            pwi->wCreatorVersion = VER31;
        } else {
            pwi->wCreatorVersion = VER30;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
                RIP_WARNING,
                "Window %x no longer valid",
                hwnd);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\winmgrc.c ===
/****************************** Module Header ******************************\
* Module Name: winmgrc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains
*
* History:
* 20-Feb-1992 DarrinM   Pulled functions from user\server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define CONSOLE_WINDOW_CLASS (L"ConsoleWindowClass")

/***************************************************************************\
* GetWindowWord (API)
*
* Return a window word.  Positive index values return application window words
* while negative index values return system window words.  The negative
* indices are published in WINDOWS.H.
*
* History:
* 20-Feb-1992 DarrinM   Wrote.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, WORD, DUMMYCALLINGTYPE, GetWindowWord, HWND, hwnd, int, index)
WORD GetWindowWord(
    HWND hwnd,
    int  index)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    /*
     * If it's a dialog window the window data is on the server side
     * We just call the "long" routine instead of have two thunks.
     * We know there is enough data if its DWLP_USER so we won't fault.
     */
    if (TestWF(pwnd, WFDIALOGWINDOW) && (index == DWLP_USER)) {
        return (WORD)_GetWindowLong(pwnd, index, FALSE);
    }

    return _GetWindowWord(pwnd, index);
}


BOOL FChildVisible(
    HWND hwnd)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    return (_FChildVisible(pwnd));
}


FUNCLOG4(LOG_GENERAL, BOOL, WINAPI, AdjustWindowRectEx, LPRECT, lpRect, DWORD, dwStyle, BOOL, bMenu, DWORD, dwExStyle)
BOOL WINAPI AdjustWindowRectEx(
    LPRECT lpRect,
    DWORD dwStyle,
    BOOL bMenu,
    DWORD dwExStyle)
{
    ConnectIfNecessary(0);

    return _AdjustWindowRectEx(lpRect, dwStyle, bMenu, dwExStyle);
}



FUNCLOG3(LOG_GENERAL, int, WINAPI, GetClassNameW, HWND, hwnd, LPWSTR, lpClassName, int, nMaxCount)
int WINAPI GetClassNameW(
    HWND hwnd,
    LPWSTR lpClassName,
    int nMaxCount)
{
    UNICODE_STRING strClassName;

    strClassName.MaximumLength = (USHORT)(nMaxCount * sizeof(WCHAR));
    strClassName.Buffer = lpClassName;
    return NtUserGetClassName(hwnd, FALSE, &strClassName);
}


HWND GetFocus(VOID)
{
    return (HWND)NtUserGetThreadState(UserThreadStateFocusWindow);
}


HWND GetCapture(VOID)
{
    /*
     * If no captures are currently taking place, just return NULL.
     */
    if (gpsi->cCaptures == 0) {
        return NULL;
    }
    return (HWND)NtUserGetThreadState(UserThreadStateCaptureWindow);
}

/***************************************************************************\
* AnyPopup (API)
*
*
*
* History:
* 12-Nov-1990 DarrinM   Ported.
\***************************************************************************/

BOOL AnyPopup(VOID)
{
    PWND pwnd = _GetDesktopWindow();

    for (pwnd = REBASEPWND(pwnd, spwndChild); pwnd; pwnd = REBASEPWND(pwnd, spwndNext)) {

        if ((pwnd->spwndOwner != NULL) && TestWF(pwnd, WFVISIBLE))
            return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* GetInputState
*
*
*
* History:
\***************************************************************************/

BOOL GetInputState(VOID)
{
    CLIENTTHREADINFO *pcti = GETCLIENTTHREADINFO();

    if ((pcti == NULL) || (pcti->fsChangeBits & (QS_MOUSEBUTTON | QS_KEY)))
        return (BOOL)NtUserGetThreadState(UserThreadStateInputState);

    return FALSE;
}

/***************************************************************************\
* MapWindowPoints
*
*
*
* History:
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, int, DUMMYCALLINGTYPE, MapWindowPoints, HWND, hwndFrom, HWND, hwndTo, LPPOINT, lppt, UINT, cpt)
int MapWindowPoints(
    HWND    hwndFrom,
    HWND    hwndTo,
    LPPOINT lppt,
    UINT    cpt)
{
    PWND pwndFrom;
    PWND pwndTo;

    if (hwndFrom != NULL) {

        if ((pwndFrom = ValidateHwnd(hwndFrom)) == NULL)
            return 0;

    } else {

        pwndFrom = NULL;
    }

    if (hwndTo != NULL) {


        if ((pwndTo = ValidateHwnd(hwndTo)) == NULL)
            return 0;

    } else {

        pwndTo = NULL;
    }

    return _MapWindowPoints(pwndFrom, pwndTo, lppt, cpt);
}

/***************************************************************************\
* GetLastActivePopup
*
*
*
* History:
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, GetLastActivePopup, HWND, hwnd)
HWND GetLastActivePopup(
    HWND hwnd)
{
    PWND pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return NULL;

    pwnd = _GetLastActivePopup(pwnd);

    return HW(pwnd);
}

/**************************************************************************\
* PtiWindow
*
* Gets the PTHREADINFO of window or NULL if not valid.
*
* 12-Feb-1997 JerrySh   Created.
\**************************************************************************/

PTHREADINFO PtiWindow(
    HWND hwnd)
{
    PHE phe;
    DWORD dw;
    WORD uniq;

    dw = HMIndexFromHandle(hwnd);
    if (dw < gpsi->cHandleEntries) {
        phe = &gSharedInfo.aheList[dw];
        if ((phe->bType == TYPE_WINDOW) && !(phe->bFlags & HANDLEF_DESTROY)) {
            uniq = HMUniqFromHandle(hwnd);
            if (   uniq == phe->wUniq
#if !defined(_WIN64) && !defined(BUILD_WOW6432)
                || uniq == 0
                || uniq == HMUNIQBITS
#endif
                ) {
                return phe->pOwner;
            }
        }
    }
    UserSetLastError(ERROR_INVALID_WINDOW_HANDLE);
    return NULL;
}

/***************************************************************************\
* GetWindowThreadProcessId
*
* Get's windows process and thread ids.
*
* 24-Jun-1991 ScottLu   Created.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, GetWindowThreadProcessId, HWND, hwnd, LPDWORD, lpdwProcessId)
DWORD GetWindowThreadProcessId(
    HWND    hwnd,
    LPDWORD lpdwProcessId)
{
    PTHREADINFO ptiWindow;
    DWORD dwThreadId;

    if ((ptiWindow = PtiWindow(hwnd)) == NULL)
        return 0;

    /*
     * For non-system threads get the info from the thread info structure
     */
    if (ptiWindow == PtiCurrent()) {

        if (lpdwProcessId != NULL)
            *lpdwProcessId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess);
        dwThreadId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread);

    } else {

        /*
         * Make this better later on.
         */
        if (lpdwProcessId != NULL)
            *lpdwProcessId = HandleToUlong(NtUserQueryWindow(hwnd, WindowProcess));
        dwThreadId = HandleToUlong(NtUserQueryWindow(hwnd, WindowThread));
    }

    return dwThreadId;
}

/***************************************************************************\
* GetScrollPos
*
* Returns the current position of a scroll bar
*
* !!! WARNING a similiar copy of this code is in server\sbapi.c
*
* History:
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetScrollPos, HWND, hwnd, int, code)
int GetScrollPos(
    HWND hwnd,
    int  code)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return 0;

    switch (code) {
    case SB_CTL:
        return (int)SendMessageWorker(pwnd, SBM_GETPOS, 0, 0, FALSE);

    case SB_HORZ:
    case SB_VERT:
        if (pwnd->pSBInfo != NULL) {
            PSBINFO pSBInfo = (PSBINFO)(REBASEALWAYS(pwnd, pSBInfo));
            return (code == SB_VERT) ? pSBInfo->Vert.pos : pSBInfo->Horz.pos;
        } else {
            RIPERR0(ERROR_NO_SCROLLBARS, RIP_VERBOSE, "");
        }
        break;

    default:
        /*
         * Win3.1 validation layer code.
         */
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
    }

    return 0;
}

/***************************************************************************\
* GetScrollRange
*
* !!! WARNING a similiar copy of this code is in server\sbapi.c
*
* History:
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/


FUNCLOG4(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetScrollRange, HWND, hwnd, int, code, LPINT, lpposMin, LPINT, lpposMax)
BOOL GetScrollRange(
    HWND  hwnd,
    int   code,
    LPINT lpposMin,
    LPINT lpposMax)
{
    PSBINFO pSBInfo;
    PWND    pwnd;

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return FALSE;

    switch (code) {
    case SB_CTL:
        SendMessageWorker(pwnd, SBM_GETRANGE, (WPARAM)lpposMin, (LPARAM)lpposMax, FALSE);
        return TRUE;

    case SB_VERT:
    case SB_HORZ:
        if (pSBInfo = REBASE(pwnd, pSBInfo)) {
            PSBDATA pSBData;
            pSBData = KPSBDATA_TO_PSBDATA((code == SB_VERT) ? &pSBInfo->Vert : &pSBInfo->Horz);
            *lpposMin = pSBData->posMin;
            *lpposMax = pSBData->posMax;
        } else {
            RIPERR0(ERROR_NO_SCROLLBARS, RIP_VERBOSE, "");
            *lpposMin = 0;
            *lpposMax = 0;
        }

        return TRUE;

    default:
        /*
         * Win3.1 validation layer code.
         */
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
        return FALSE;
    }
}


FUNCLOG4(LOG_GENERAL, int, DUMMYCALLINGTYPE, SetScrollInfo, HWND, hwnd, int, fnBar, LPCSCROLLINFO, lpsi, BOOL, fRedraw)
int SetScrollInfo(
    HWND            hwnd,
    int             fnBar,
    LPCSCROLLINFO   lpsi,
    BOOL            fRedraw)
{
    int ret;

    BEGIN_USERAPIHOOK()
        ret = guah.pfnSetScrollInfo(hwnd, fnBar, lpsi, fRedraw);
    END_USERAPIHOOK()

    return ret;
}


int RealSetScrollInfo(
    HWND            hwnd,
    int             fnBar,
    LPCSCROLLINFO   lpsi,
    BOOL            fRedraw)
{
    return NtUserSetScrollInfo(hwnd, fnBar, lpsi, fRedraw);
}



FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetScrollInfo, HWND, hwnd, int, code, LPSCROLLINFO, lpsi)
BOOL GetScrollInfo(
    HWND         hwnd,
    int          code,
    LPSCROLLINFO lpsi)
{
    int ret;

    BEGIN_USERAPIHOOK()
        ret = guah.pfnGetScrollInfo(hwnd, code, lpsi);
    END_USERAPIHOOK()

    return ret;
}

/***************************************************************************\
* RealGetScrollInfo
*
* !!! WARNING a similiar copy of this code is in server\winmgrc.c
*
\***************************************************************************/

BOOL RealGetScrollInfo(
    HWND         hwnd,
    int          code,
    LPSCROLLINFO lpsi)
{
    PWND    pwnd;
    PSBINFO pSBInfo;
    PSBDATA pSBData;

    if (lpsi->cbSize != sizeof(SCROLLINFO)) {

        if (lpsi->cbSize != sizeof(SCROLLINFO) - 4) {
            RIPMSG0(RIP_WARNING, "SCROLLINFO: Invalid cbSize");
            return FALSE;

        } else {
            RIPMSG0(RIP_WARNING, "SCROLLINFO: Invalid cbSize");
        }
    }

    if (lpsi->fMask & ~SIF_MASK) {
        RIPMSG0(RIP_WARNING, "SCROLLINFO: Invalid fMask");
        return FALSE;
    }

    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return FALSE;

    switch (code) {
    case SB_CTL:
        SendMessageWorker(pwnd, SBM_GETSCROLLINFO, 0, (LPARAM)lpsi, FALSE);
        return TRUE;

    case SB_HORZ:
    case SB_VERT:
        if (pwnd->pSBInfo == NULL) {
            RIPERR0(ERROR_NO_SCROLLBARS, RIP_VERBOSE, "");
            return FALSE;
        }

        /*
         * Rebase rgwScroll so probing will work
         */
        pSBInfo = (PSBINFO)REBASEALWAYS(pwnd, pSBInfo);

        pSBData = KPSBDATA_TO_PSBDATA((code == SB_VERT) ? &pSBInfo->Vert : &pSBInfo->Horz);

        return(NtUserSBGetParms(hwnd, code, pSBData, lpsi));

    default:
        /*
         * Win3.1 validation layer code.
         */
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
        return FALSE;
    }
}

/****************************************************************************\
* _GetActiveWindow (API)
*
*
* 23-Oct-1990 MikeHar   Ported from Windows.
* 12-Nov-1990 DarrinM   Moved from getset.c to here.
\****************************************************************************/

HWND GetActiveWindow(VOID)
{
    return (HWND)NtUserGetThreadState(UserThreadStateActiveWindow);
}

/****************************************************************************\
* GetCursor
*
*
* History:
\****************************************************************************/

HCURSOR GetCursor(VOID)
{
    return (HCURSOR)NtUserGetThreadState(UserThreadStateCursor);
}

/***************************************************************************\
* BOOL IsMenu(HMENU);
*
* Verifies that the handle passed in is a menu handle.
*
* Histroy:
* 10-Jul-1992 MikeHar   Created.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsMenu, HMENU, hMenu)
BOOL IsMenu(
   HMENU hMenu)
{
   if (HMValidateHandle(hMenu, TYPE_MENU))
      return TRUE;

   return FALSE;
}

/***************************************************************************\
* GetAppCompatFlags
*
* Compatibility flags for < Win 3.1 apps running on 3.1
*
* History:
* 01-Apr-1992 ScottLu   Created.
* 04-May-1992 DarrinM   Moved to USERRTL.DLL.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, GetAppCompatFlags, PTHREADINFO, pti)
DWORD GetAppCompatFlags(
    PTHREADINFO pti)
{
    UNREFERENCED_PARAMETER(pti);

    ConnectIfNecessary(0);

    return GetClientInfo()->dwCompatFlags;
}

/***************************************************************************\
* GetAppCompatFlags2
*
* Compatibility flags for <= wVer apps.  Newer apps will get no hacks
* from this DWORD.
*
* History:
* 06-29-98 MCostea      Created.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, GetAppCompatFlags2, WORD, wVer)
DWORD GetAppCompatFlags2(
    WORD wVer)
{
    ConnectIfNecessary(0);
    /*
     * Newer apps should behave, so they get no hacks
     */
    if (wVer < GETAPPVER()) {
        return 0;
    }
    return GetClientInfo()->dwCompatFlags2;
}

/**************************************************************************\
* IsWindowUnicode
*
* 25-Feb-1992 IanJa     Created
\**************************************************************************/

BOOL IsWindowUnicode(
    IN HWND hwnd)
{
    PWND pwnd;


    if ((pwnd = ValidateHwnd(hwnd)) == NULL)
        return FALSE;

    return !TestWF(pwnd, WFANSIPROC);
}

/**************************************************************************\
* TestWindowProcess
*
* 14-Nov-1994 JimA      Created.
\**************************************************************************/

BOOL TestWindowProcess(
    PWND pwnd)
{
    /*
     * If the threads are the same, don't bother going to the kernel
     * to get the window's process id.
     */
    if (GETPTI(pwnd) == PtiCurrent()) {
        return TRUE;
    }

    return (GetWindowProcess(HW(pwnd)) == GETPROCESSID());
}

/**************************************************************************\
* IsHungAppWindow
*
* 11-14-94 JimA         Created.
\**************************************************************************/
FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsHungAppWindow, HWND, hwnd)
BOOL IsHungAppWindow(
    HWND hwnd)
{
    return (NtUserQueryWindow(hwnd, WindowIsHung) != NULL);
}

/***************************************************************************\
* CreateSystemThreads
*
* Simply calls xxxCreateSystemThreads, which will call the appropriate
* thread routine (depending on uThreadID).
*
* History:
* 20-Aug-00 MSadek      Created.
\***************************************************************************/
WINUSERAPI
DWORD
WINAPI
CreateSystemThreads (
    LPVOID pUnused)
{
    UNREFERENCED_PARAMETER(pUnused);

    NtUserCallOneParam(TRUE, SFI_XXXCREATESYSTEMTHREADS);
    ExitThread(0);
}

/***************************************************************************\
* PtiCurrent
*
* Returns the THREADINFO structure for the current thread.
* LATER: Get DLL_THREAD_ATTACH initialization working right and we won't
*        need this connect code.
*
* History:
* 10-28-90 DavidPe      Created.
\***************************************************************************/

PTHREADINFO PtiCurrent(VOID)
{
    ConnectIfNecessary(0);
    return (PTHREADINFO)NtCurrentTebShared()->Win32ThreadInfo;
}


/***************************************************************************\
* _AdjustWindowRectEx (API)
*
*
*
* History:
* 10-24-90 darrinm      Ported from Win 3.0.
\***************************************************************************/

BOOL _AdjustWindowRectEx(
    LPRECT lprc,
    DWORD style,
    BOOL fMenu,
    DWORD dwExStyle)
{
    BOOL ret;

    BEGIN_USERAPIHOOK()
        ret = guah.pfnAdjustWindowRectEx(lprc, style, fMenu, dwExStyle);
    END_USERAPIHOOK()

    return ret;
}


BOOL RealAdjustWindowRectEx(
    LPRECT lprc,
    DWORD style,
    BOOL fMenu,
    DWORD dwExStyle)
{
    //
    // Here we add on the appropriate 3D borders for old and new apps.
    //
    // Rules:
    //   (1) Do nothing for windows that have 3D border styles.
    //   (2) If the window has a dlgframe border (has a caption or is a
    //          a dialog), then add on the window edge style.
    //   (3) We NEVER add on the CLIENT STYLE.  New apps can create
    //          it if they want.  This is because it screws up alignment
    //          when the app doesn't know about it.
    //

    if (NeedsWindowEdge(style, dwExStyle, GETAPPVER() >= VER40))
        dwExStyle |= WS_EX_WINDOWEDGE;
    else
        dwExStyle &= ~WS_EX_WINDOWEDGE;

    //
    // Space for a menu bar
    //
    if (fMenu)
        lprc->top -= SYSMET(CYMENU);

    //
    // Space for a caption bar
    //
    if ((HIWORD(style) & HIWORD(WS_CAPTION)) == HIWORD(WS_CAPTION)) {
        lprc->top -= (dwExStyle & WS_EX_TOOLWINDOW) ? SYSMET(CYSMCAPTION) : SYSMET(CYCAPTION);
    }

    //
    // Space for borders (window AND client)
    //
    {
        int cBorders;

        //
        // Window AND Client borders
        //

        if (cBorders = GetWindowBorders(style, dwExStyle, TRUE, TRUE))
            InflateRect(lprc, cBorders*SYSMET(CXBORDER), cBorders*SYSMET(CYBORDER));
    }

    return TRUE;
}

/***************************************************************************\
* ShowWindowNoRepaint
\***************************************************************************/

void ShowWindowNoRepaint(PWND pwnd)
{
    HWND hwnd = HWq(pwnd);
    PCLS pcls = REBASE(pwnd, pcls);
    NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE |
            SWP_NOSIZE | SWP_NOZORDER | SWP_NOOWNERZORDER |
            SWP_NOREDRAW | SWP_SHOWWINDOW | SWP_NOACTIVATE |
            ((pcls->style & CS_SAVEBITS) ? SWP_CREATESPB : 0));
}

/***************************************************************************\
* AnimateBlend
*
* 6-Mar-1997    vadimg      created
\***************************************************************************/

#define ALPHASTART 40
#define ONEFRAME 10

BOOL AnimateBlend(PWND pwnd, HDC hdcScreen, HDC hdcImage, DWORD dwTime, BOOL fHide, BOOL fActivateWindow)
{
    HWND hwnd = HWq(pwnd);
    SIZE size;
    POINT ptSrc = {0, 0}, ptDst;
    BLENDFUNCTION blend;
    DWORD dwElapsed;
    BYTE bAlpha = ALPHASTART;
    LARGE_INTEGER liFreq, liStart, liDiff;
    LARGE_INTEGER liIter;
    DWORD dwIter;
    BOOL fFirstFrame = TRUE;

    if (QueryPerformanceFrequency(&liFreq) == 0)
        return FALSE;

    SetLastError(0);

    SetWindowLong(hwnd, GWL_EXSTYLE, GetWindowLong(hwnd, GWL_EXSTYLE) | WS_EX_LAYERED);

    if (GetLastError() != 0) {
        return FALSE;
    }

    if (fHide) {
        /*
         * Give up the time slice and sleep just a touch to allow windows
         * below invalidated by the SetWindowLong(WS_EX_LAYERED) call to
         * repaint enough for the sprite to get good background image.
         */
        Sleep(10);
    }

    ptDst.x = pwnd->rcWindow.left;
    ptDst.y = pwnd->rcWindow.top;
    size.cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
    size.cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

    blend.BlendOp     = AC_SRC_OVER;
    blend.BlendFlags  = 0;
    blend.AlphaFormat = 0;
    blend.SourceConstantAlpha = fHide ? (255 - bAlpha) : bAlpha;

    /*
     * Copy the initial image with the initial alpha.
     */
    NtUserUpdateLayeredWindow(hwnd, NULL, &ptDst, &size, hdcImage, &ptSrc, 0,
            &blend, ULW_ALPHA);

    if (!fHide) {
        ShowWindowNoRepaint(pwnd);
    }

    /*
     * Time and start the animation cycle.
     */
    dwElapsed = (dwTime * ALPHASTART + 255) / 255 + 10;
    QueryPerformanceCounter(&liStart);
    liStart.QuadPart = liStart.QuadPart - dwElapsed * liFreq.QuadPart / 1000;

    while (dwElapsed < dwTime) {

        if (fHide) {
            blend.SourceConstantAlpha = (BYTE)((255 * (dwTime - dwElapsed)) / dwTime);
        } else {
            blend.SourceConstantAlpha = (BYTE)((255 * dwElapsed) / dwTime);
        }

        QueryPerformanceCounter(&liIter);

        if (fFirstFrame && fActivateWindow) {
            NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0,
                               SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER);
        }
        fFirstFrame = FALSE;

        NtUserUpdateLayeredWindow(hwnd, NULL, NULL, NULL, NULL, NULL, 0,
                &blend, ULW_ALPHA);

        QueryPerformanceCounter(&liDiff);

        /*
         * Calculate how long in ms the previous frame took.
         */
        liIter.QuadPart = liDiff.QuadPart - liIter.QuadPart;
        dwIter = (DWORD)((liIter.QuadPart * 1000) / liFreq.QuadPart);

        if (dwIter < ONEFRAME) {
            Sleep(ONEFRAME - dwIter);
        }

        liDiff.QuadPart -= liStart.QuadPart;
        dwElapsed = (DWORD)((liDiff.QuadPart * 1000) / liFreq.QuadPart);
    }

    /*
     * Hide the window before removing the layered bit to make sure that
     * the bits for the window are not left on the screen.
     */
    if (fHide) {
        NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_HIDEWINDOW |
                SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    SetWindowLong(hwnd, GWL_EXSTYLE, GetWindowLong(hwnd, GWL_EXSTYLE) &
            ~WS_EX_LAYERED);

    if (!fHide) {
        BitBlt(hdcScreen, 0, 0, size.cx, size.cy, hdcImage, 0, 0, SRCCOPY | NOMIRRORBITMAP);
    }

    return TRUE;
}


/***************************************************************************\
* TakeWindowSnapshot
*
* Helper routine to grab the visual appearance of a window to a bitmap.
*
\***************************************************************************/
HBITMAP TakeWindowSnapshot(HWND hwnd, HDC hdcWindow, HDC hdcSnapshot)
{
    PWND pwnd;
    int cx;
    int cy;
    HBITMAP hbmOld, hbmSnapshot;
    BOOL fOK = FALSE;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL)
        return NULL;
    cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
    cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

    hbmSnapshot = CreateCompatibleBitmap(hdcWindow, cx, cy);
    if (hbmSnapshot == NULL) {
        return NULL;
    }

    hbmOld = SelectObject(hdcSnapshot, hbmSnapshot);

    /*
     * Try redirection first.
     */
    /*
    if (NtUserPrintWindow(hwnd, hdcSnapshot, 0)) {
        fOK = TRUE;
    } else */ {
        /*
         * We failed to redirect the window!  This can be caused by windows
         * with class or parent DCs.  Maybe other reasons as well.  Revert to
         * the old way of sending a WM_PRINT to the window.
         */
        
        UINT uBounds;
        RECT rcBounds;
        DWORD dwOldLayout = GDI_ERROR;
        BOOL fError = TRUE;

        /*
         * The WM_PRINT message expects a "normal" layout setting on the DC.
         * The message will handle RTL stuff itself.
         */
        dwOldLayout = SetLayout(hdcSnapshot, 0);

        /*
         * Clear the dirty bounds so we can tell if anything was painted.
         */
        SetBoundsRect(hdcSnapshot, NULL, DCB_RESET | DCB_ENABLE);

        /*
         * Get the actual image. The windows participating here must implement
         * WM_PRINTCLIENT or they will look ugly.
         */
        SendMessage(hwnd, WM_PRINT, (WPARAM)hdcSnapshot, PRF_CLIENT | PRF_NONCLIENT | PRF_CHILDREN | PRF_ERASEBKGND);

        /*
         * Check to see if the app painted in our DC.  We do this by checking to
         * see if the bounding rect of operations performed on the DC is set.
         */
        uBounds = GetBoundsRect(hdcSnapshot, &rcBounds, 0);
        if ((uBounds & DCB_RESET) && (!(uBounds & DCB_ACCUMULATE))) {
            goto Cleanup;
        }
    
        fOK = TRUE;

Cleanup:
        SetLayout(hdcSnapshot, dwOldLayout);
    }

    SelectObject(hdcSnapshot, hbmOld);

    if (!fOK) {
        DeleteObject(hbmSnapshot);
        hbmSnapshot = NULL;
    }

    return hbmSnapshot;
}

/***************************************************************************\
* AnimateWindow (API)
*
* Hide animations are done by updating a la full-drag.  Uses window's window
* region to do some of the magic.
*
* We have to put in the CLIPCHILDREN hack to work around a bug with the
* DC cache resetting attributes even if DCX_USESTYLE is not used whe
* the DC cache is invalidated.
*
* History:
* 9-Sep-1996    vadimg      created
\***************************************************************************/

#define AW_HOR          (AW_HOR_POSITIVE | AW_HOR_NEGATIVE | AW_CENTER)
#define AW_VER          (AW_VER_POSITIVE | AW_VER_NEGATIVE | AW_CENTER)

__inline int AnimInc(int x, int y, int z)
{
    return MultDiv(x, y, z);
}

__inline int AnimDec(int x, int y, int z)
{
    return x - AnimInc(x, y, z);
}


FUNCLOG3(LOG_GENERAL, BOOL, WINAPI, AnimateWindow, HWND, hwnd, DWORD, dwTime, DWORD, dwFlags)
BOOL WINAPI AnimateWindow(HWND hwnd, DWORD dwTime, DWORD dwFlags)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    HDC hdc = NULL, hdcMem = NULL;
    PCLS pcls = NULL;
    HRGN hrgnOriginal = NULL, hrgnUpdate = NULL, hrgnOldAnim = NULL, hrgnAnim = NULL;
    HBITMAP hbmMem = NULL, hbmOld;
    BOOL fHide = dwFlags & AW_HIDE, fRet = FALSE, fSlide = dwFlags & AW_SLIDE;
    BOOL fRestoreClipChildren = FALSE;
    BOOL fRestoreOriginalRegion = FALSE;
    BOOL fShowWindow = FALSE;
    BOOL fHideWindow = FALSE;
    BOOL fActivateWindow = FALSE;
    BOOL fFirstFrame = TRUE;
    BOOL fRedrawParentWindow = FALSE;
    HWND hwndParent;
    int x, y, nx, ny, cx, cy, ix, iy, ixLast, iyLast, xWin, yWin;
    int xReal, yReal, xMem, yMem, xRgn, yRgn;
    DWORD dwStart, dwElapsed;
    RECT rcAnim, rcWin;
    PWND pwnd;
    BOOL fRTL = FALSE;

#if DBG
    int cAnimationFrames = 0;
    DWORD dwElapsed2 = 0;
#endif

    /*
     * Check to see if we have nothing to do or the flags didn't validate.
     */
    if ((dwFlags & ~AW_VALID) != 0 ||
        (dwFlags & (AW_HOR_POSITIVE | AW_HOR_NEGATIVE | AW_CENTER | AW_VER_POSITIVE | AW_VER_NEGATIVE | AW_BLEND)) == 0)
        return FALSE;
    
    /*
     * Convert the HWND to a PWND.  Fail if this is an invalid window.
     */
    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL)
        return FALSE;

    /*
     * The animation effect is applied to a window that is changing from being
     * hidden to being visible, or from being visible to being hidden.  If the
     * window is already in the final state, there is nothing to do.
     */
    if (!IsWindowVisible(hwnd)) {
        if (fHide) {
            return FALSE;
        }
    } else {
        if (!fHide) {
            return FALSE;
        }
    }

    /*
     * Grab a DC for this window.
     */
    if ((hdc = GetDCEx(hwnd, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE)) == NULL) {
        return FALSE;
    }
    fRTL = (GetLayout(hdc) & LAYOUT_RTL) ? TRUE : FALSE;

    /*
     * ----------------------------------------------------------------------
     * After this point, we will not return directly.  Instead, we will fall
     * out through the cleanup section at the bottom!  Up until this point
     * we may have bailed out for any number of easily-detected problems.
     * From now on, we have resources we'll need to clean up.
     * ----------------------------------------------------------------------
     */
 
    /*
     * Remember to hide/show/activate the window as requested.
     */
    if (dwFlags & AW_HIDE) {
        TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Need to hide window");
        fHideWindow = TRUE;
    } else {
        TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Need to show window");
        fShowWindow = TRUE;
    }
    if (dwFlags & AW_ACTIVATE) {
        TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Need to activate window");
        fActivateWindow = TRUE;
    }

    /*
     * If this is a child window we are animating, then we may need to
     * repaint the parent every time we move the child so that the
     * background can be refreshed.
     */
    if (TestWF(pwnd, WFCHILD) && (pwnd->spwndParent != NULL)) {
        TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Animating a child window" );
        if (dwFlags & AW_BLEND) {
            TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Can not fade a child window!" );
            goto Cleanup;
        }
        fRedrawParentWindow = TRUE;
        hwndParent = HW(_GetParent(pwnd));
    }

    /*
     * In the process of animating the window, we are going to draw directly
     * on top of the window region ourselves.  As such, we don't want any
     * "holes" in the window region due to it clipping out the children.  But
     * we will need to restore this setting when we are all done, so we set
     * a flag here and check it at the end.
     */
    if (TestWF(pwnd, WFCLIPCHILDREN)) {
        fRestoreClipChildren = TRUE;
        ClearWindowState(pwnd, WFCLIPCHILDREN);
    }

    /*
     * Remember the original window region.  We will restore this when we are
     * all done.
     */
    if (pwnd->hrgnClip != NULL) {
        hrgnOriginal = CreateRectRgn(0, 0, 0, 0);
        if (hrgnOriginal == NULL) {
            goto Cleanup;
        }

        if (GetWindowRgn(hwnd, hrgnOriginal) == ERROR) {
            goto Cleanup;
        }
    }
    fRestoreOriginalRegion = TRUE;

    /*
     * Precreate the regions we use.
     */
    if (((hrgnUpdate = CreateRectRgn(0, 0, 0, 0)) == NULL) ||
        ((hrgnOldAnim = CreateRectRgn(0, 0, 0, 0)) == NULL)) {
        goto Cleanup;
    }

    rcWin = pwnd->rcWindow;
    xWin = rcWin.left;
    yWin = rcWin.top;
    cx = rcWin.right - rcWin.left;
    cy = rcWin.bottom - rcWin.top;

    /*
     * Initialize the "old" animation region to be:
     * 1) Empty, if the window is being show.
     * 2) Full, if the window is being hiddem.
     */
    if (fHide) {
        if (hrgnOriginal != NULL) {
            if (CombineRgn(hrgnOldAnim, hrgnOriginal, NULL, RGN_COPY) == ERROR) {
                goto Cleanup;
            }
        } else {
            if (SetRectRgn(hrgnOldAnim, 0, 0, cx, cy) == 0) {
                goto Cleanup;
            }
        }
    } else {
        if (SetRectRgn(hrgnOldAnim, 0, 0, 0, 0) == 0) {
            goto Cleanup;
        }
    }


    /*
     * The window needs to be visible since we are going to be drawing parts
     * of it.  If the window is being hidden, then it is currently visible.
     * If the window is being shown, then we go ahead and make it visible
     * now but we don't repaint it.
     */
    if (!(dwFlags & AW_BLEND)) {
        HRGN hrgnWin = NULL;

        /*
         * Set window region to nothing, so that if the window draws during
         * callbacks in WM_PRINT, it doesn't happen on screen.
         */
        if ((hrgnWin = CreateRectRgn(0, 0, 0, 0)) == NULL) {
            goto Cleanup;
        }
        RealSetWindowRgn(hwnd, hrgnWin, FALSE);
    
        if (!fHide) {
            ShowWindowNoRepaint(pwnd);
            fShowWindow = FALSE;
        }
    }    

    /*
     * Set up an offscreen DC, and back it to a bitmap.  We will use this to
     * capture the visual representation of the window being animated.
     */
    if ((hdcMem = CreateCompatibleDC(hdc)) == NULL) {
        goto Cleanup;
    }
    hbmMem = TakeWindowSnapshot(hwnd, hdc, hdcMem);
    if (hbmMem != NULL) {
        /*
         * If the window changed its size while we were taking a snapshot,
         * we need to do it again.  For instance, like RAID does with
         * combo boxes by resizing them on WM_CTLCOLOR from WM_ERASEBKGND.
         */
        if (!EqualRect(&rcWin, KPRECT_TO_PRECT(&pwnd->rcWindow))) {
            /*
             * Update all of our variables taking into account the new size.
             */
            TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Size change on paint!");
            TAGMSG4(DBGTAG_AnimateWindow, "AnimateWindow: Old = (%d,%d)-(%d,%d)", rcWin.left, rcWin.top, rcWin.right, rcWin.bottom);
            rcWin = pwnd->rcWindow;
            TAGMSG4(DBGTAG_AnimateWindow, "AnimateWindow: New = (%d,%d)-(%d,%d)", rcWin.left, rcWin.top, rcWin.right, rcWin.bottom);
            xWin = rcWin.left;
            yWin = rcWin.top;
            cx = rcWin.right - rcWin.left;
            cy = rcWin.bottom - rcWin.top;

            if (hrgnOriginal != NULL) {
                if (GetWindowRgn(hwnd, hrgnOriginal) == ERROR) {
                    goto Cleanup;
                }
            }

            /*
             * Initialize the "old" animation region to be:
             * 1) Empty, if the window is being show.
             * 2) Full, if the window is being hiddem.
             */
            if (fHide) {
                if (hrgnOriginal != NULL) {
                    if (CombineRgn(hrgnOldAnim, hrgnOriginal, NULL, RGN_COPY) == ERROR) {
                        goto Cleanup;
                    }
                } else {
                    if (SetRectRgn(hrgnOldAnim, 0, 0, cx, cy) == 0) {
                        goto Cleanup;
                    }
                }
            } else {
                if (SetRectRgn(hrgnOldAnim, 0, 0, 0, 0) == 0) {
                    goto Cleanup;
                }
            }

            DeleteObject(hbmMem);
            hbmMem = TakeWindowSnapshot(hwnd, hdc, hdcMem);
        }

        if (hbmMem != NULL) {
            hbmOld = SelectBitmap(hdcMem, hbmMem);
        } else {
            goto Cleanup;
        }
    } else {
        goto Cleanup;
    }

    /*
     * Use the default animation duration if the caller didn't specify it.
     */
    if (dwTime == 0) {
        dwTime = CMS_QANIMATION;
    }

    /*
     * If we are doing an alpha blend animation, call a separate routine to
     * do it and then return.
     */
    if (dwFlags & AW_BLEND) {
        fRet = AnimateBlend(pwnd, hdc, hdcMem, dwTime, fHide, fActivateWindow);
        if (fRet) {
            fHideWindow = FALSE;
            fShowWindow = FALSE;
        }
        goto Cleanup;
    }

    /*
     * Our central animation routine uses an equation to update the new
     * position of the window during the animation.  This equation uses some
     * variables so that it is configurable.
     *
     * x and y describe where the left and top edges are caluclated relative
     * to.  xReal and yReal are the result of that calculation.
     *
     * nx and ny are used to control in which direction the the top and left
     * edges are offset from x and y.  The left/top edges are either fixed in
     * place (nx and ny are set to 0), or are calculated as a negative offset
     * from the right/bottom edges (nx and ny are set to -1).
     *
     * ix, and iy are the amount of the width and height that the
     * animation should be showing at a particular iteration through the
     * loop.  If we are showing the window, this amount starts at
     * 0 and increments towards the window's true dimension.  If we are
     * hiding a window, this amount starts at the window's true dimension
     * and decrements towards 0.
     */
    ix = iy = 0;
    ixLast = fHide ? cx : 0; // The opposite condition of what signals we're done.
    iyLast = fHide ? cy : 0; // The opposite condition of what signals we're done.

    if (dwFlags & AW_CENTER) {
        /*
         * Expand the window from the center.  The left edge is calculated as
         * a negative offset from the center.  As the width either grows or
         * shrinks, the left edge will be repositioned.
         */
        x = cx / 2;
        nx = -1;
        fSlide = FALSE;
    } else if (dwFlags & AW_HOR_POSITIVE) {
        if (fHide) {
            /*
             * Slide/Roll to the right.  The left edge moves to the right, and
             * the right edge stays put.  Thus, the width gets smaller.  The
             * left edge is calculated as a negative offset from the right
             * edge.
             */
            x = cx;
            nx = -1;
        } else {
            /*
             * Slide/Roll to the right.  The left edge stays put, and the right
             * edge moves to the right.  Thus, the width gets bigger.  The
             * left edge is always 0.
             */
            x = 0;
            nx = 0;
        }
    } else if (dwFlags & AW_HOR_NEGATIVE) {
        if (fHide) {
            /*
             * Slide/Roll to the left.  The left edge stays put, and the right
             * edge moves to the left.  Thus, the width gets smaller.  The
             * left edge is always 0.
             */
            x = 0;
            nx = 0;
        } else {
            /*
             * Slide/Roll to the left.  The left edge moves to the left, and
             * the right edge stays put.  Thus, the width gets bigger.
             * The left edge is calculated as a negative offset from the right
             * edge.
             */
            x = cx;
            nx = -1;
        }
    } else {
        /*
         * There is not supposed to be any horizontal animation.  The
         * animation is always as wide as the window.
         */
        x = 0;
        nx = 0;
        ix = cx;
    }

    if (dwFlags & AW_CENTER) {
        /*
         * Expand the window from the center.  The top edge is calculated as
         * a negative offset from the center.  As the height either grows or
         * shrinks, the top edge will be repositioned.
         */
        y = cy / 2;
        ny = -1;
    } else if (dwFlags & AW_VER_POSITIVE) {
        if (fHide) {
            /*
             * Slide/Roll down.  The top edge moves down, and the bottom
             * edge stays put.  Thus, the height gets smaller.  The top edge
             * is calculated as a negative offset from the bottom edge.
             */
            y = cy;
            ny = -1;
        } else {
            /*
             * Slide/Roll down.  The top edge stays put, and the bottom edge
             * moves down.  Thus, the height gets bigger.  The top edge is
             * always 0.
             */
            y = 0;
            ny = 0;
        }
    } else if (dwFlags & AW_VER_NEGATIVE) {
        if (fHide) {
            /*
             * Slide/Roll up.  The top edge stays put, and the bottom edge
             * moves up.  Thus, the height gets smaller.  The top edge is
             * always 0.
             */
            y = 0;
            ny = 0;
        } else {
            /*
             * Slide/Roll up.  The top edge moves up, and the bottom edge
             * stays put.  Thus, the height gets bigger.  The top edge is
             * calculated as a negative offset from the bottom edge.
             */
            y = cy;
            ny = -1;
        }
    } else {
        /*
         * There is not supposed to be any vertical animation.  The
         * animation is always as tall as the window.
         */
        y = 0;
        ny = 0;
        iy = cy;
    }

    /*
     * Summary of the animation loop:
     *
     * We sit in a tight loop and update the positions of the left and
     * top edges of the window, as well as the width and height.  We set
     * a window region with these dimensions on the window so that windows
     * behind it will be updated properly.  Then we draw the cached snapshot
     * of the window on top of (and clipped to) this region.
     *
     * dwTime is the amount of time the animation should take.  dwStart
     * was the value of the internal tick counter when we started the
     * animation loop.  dwElapsed counts how many ticks (nilliseconds)
     * have passed at the start of each pass through the animation loop.
     *
     * ixLast and iyLast are simply the values of ix and iy the last
     * time we went through the loop.  If these are the same, there is
     * no work to be done, and we force our thread to be rescheduled by
     * calling Sleep(1).
     */
    dwStart = GetTickCount();

#if DBG
    cAnimationFrames = 0;
#endif

    while (TRUE) {
        dwElapsed = GetTickCount() - dwStart;

        /*
         * Calculate the amount of the window width we should be showing.
         */
        if (dwFlags & AW_HOR) {
            ix = (fHide ? AnimDec : AnimInc)(cx, dwElapsed, dwTime);
        }

        /*
         * Calculate the amount of the window height we should be showing.
         */
        if (dwFlags & AW_VER) {
            iy = (fHide ? AnimDec : AnimInc)(cy, dwElapsed, dwTime);
        }

        /*
         * We have exceeded our time, make sure we draw the final frame.
         */
        if (dwElapsed > dwTime) {
            TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Exceeded animation time. Drawing fimal frame.");
            ix = fHide ? 0 : cx;
            iy = fHide ? 0 : cy;
        }
        
        if (ixLast == ix && iyLast == iy) {
            /*
             * There was no change in the amount of the window we are
             * supposed to show since last time.  Chances are we are
             * being animated really slowly or a short distance.  Either
             * way, sitting in this tight loop is kind of a waste.  So
             * force the thread to get rescheduled.
             */
            TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Drawing frames faster than needed. Sleeping." );
            Sleep(1);
        } else {
            /*
             * Calculate the new positions of the left and top edges of the
             * window being animated.
             */
            if (dwFlags & AW_CENTER) {
                xReal = x + nx * (ix / 2);
                yReal = y + ny * (iy / 2);
            } else {
                xReal = x + nx * ix;
                yReal = y + ny * iy;
            }

            /*
             * Calculate new animation dimensions on the screen.
             */
            rcAnim.left = xReal;
            rcAnim.top = yReal;
            rcAnim.right = rcAnim.left + ix;
            rcAnim.bottom = rcAnim.top + iy;

            TAGMSG5(DBGTAG_AnimateWindow, "AnimateWindow: Frame %d = (%d,%d)-(%d,%d)", cAnimationFrames, rcAnim.left, rcAnim.top, rcAnim.right, rcAnim.bottom);

            /*
             * Calculate the offset of this animation rectangle in the bitmap.
             */
            if (fSlide) {
                if (dwFlags & AW_HOR_POSITIVE) {
                    xMem = fHide ? 0: cx - ix;
                } else if (dwFlags & AW_HOR_NEGATIVE) {
                    xMem = fHide ? cx - ix : 0;
                } else {
                    xMem = xReal;
                }
                xRgn = xMem ? -xMem : xReal;

                if (dwFlags & AW_VER_POSITIVE) {
                    yMem = fHide ? 0 : cy - iy;
                } else if (dwFlags & AW_VER_NEGATIVE) {
                    yMem = fHide ? cy - iy : 0;
                } else {
                    yMem = yReal;
                }

                yRgn = yMem ? -yMem : yReal;
            } else {
                xMem = xReal;
                yMem = yReal;
                xRgn = 0;
                yRgn = 0;
            }

            /*
             * Create a new region that spans the animation rectangle.  We
             * have to create a new region every time because when we set
             * it into the window, the system will take ownership of it.
             */
            hrgnAnim = CreateRectRgnIndirect(&rcAnim);
            if (hrgnAnim == NULL) {
                goto Cleanup;
            }

            /*
             * If the original window had a region, we need to merge it
             * with the animation rectangle.  We may have to offset the
             * original region to accomplish effects like slides.
             */
            if (hrgnOriginal != NULL) {
                if (OffsetRgn(hrgnOriginal, xRgn, yRgn) == ERROR) {
                    goto Cleanup;
                }
                if (CombineRgn(hrgnAnim, hrgnOriginal, hrgnAnim, RGN_AND) == ERROR) {
                    goto Cleanup;
                }
                if (OffsetRgn(hrgnOriginal, -xRgn, -yRgn) == ERROR) {
                    goto Cleanup;
                }
            }

            /*
             * Now calculate how much of the screen (ie desktop window)
             * we need to update.  All we really need to paint is the
             * difference in the new animation region and the old
             * animation region.  Note that we have to convert to
             * coordinates in the regions to be relative to the desktop
             * window instead of being relative to the window being
             * animated.
             */
            if (CombineRgn(hrgnUpdate, hrgnOldAnim, hrgnAnim, RGN_DIFF) == ERROR) {
                goto Cleanup;
            }
            if (fRTL) {
                MirrorRgn(hwnd, hrgnUpdate);
            }
            if (OffsetRgn(hrgnUpdate, xWin, yWin) == ERROR) {
                goto Cleanup;
            }

            /*
             * The system will own the region when we set it into the
             * window.  We need to keep it around so that we can
             * calculate the update region on the next pass through
             * the animation loop.  So we make a copy.
             */
            if (CombineRgn(hrgnOldAnim, hrgnAnim, NULL, RGN_COPY) == ERROR) {
                goto Cleanup;
            }

            /*
             * Set the window region.  Note that we haven't actually moved
             * the window.  And that the coordinates in the region are all
             * relative to the window.  After this call, the system owns
             * the hrgnAnim.  Then repaint the update region of the
             * DESKTOP window.  This is the region under/around the window
             * that we have exposed.
             *
             * Note: We use the RealSetWindowRgn to work around theming.
             * The theming system will hook the standard SetWindowRgn API
             * and revoke the theming of the window since it detects us
             * setting our own region.  The idea being that if we are setting
             * a region, we must have a "custom" look in mind for the window.
             * Which we dont, we just want to hide parts of it temporarily.
             */
            if(0 == RealSetWindowRgn(hwnd, hrgnAnim, FALSE)) {
                goto Cleanup;
            } else {
                /*
                 * The system now owns the region.  Lets simply forget about
                 * it to be safe.
                 */
                hrgnAnim = NULL;
            }

            /*
             * If we are supposed to activate the window, do so on the first
             * frame of the animation.  This will cause the window to be
             * z-ordered properly.  Note that we leave the flag set to
             * true so that we will activate it again at the end.  This will
             * force a repaint since we are currently drawing the bits of the
             * window that doesn't look activated.
             */
            if (fFirstFrame && fActivateWindow) {
                NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0,
                                   SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER | SWP_NOREDRAW);
            }
            fFirstFrame = FALSE;

            if (RedrawWindow(NULL, NULL, hrgnUpdate, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN) == 0) {
                goto Cleanup;
            }
            if (fRedrawParentWindow) {
                if (NtUserCallHwndParamLock(hwndParent, (ULONG_PTR)hrgnUpdate, SFI_XXXUPDATEWINDOWS) == 0) {
                    TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Warning: xxxUpdateWindows failed!");
                    goto Cleanup;
                }
            }

            /*
             * Now draw the cached snapshot of the window on top of the window
             * itself.  We do this by drawing into the window's DC.  Since we
             * applied a region already, all clipping is done for us.
             */
            if (BitBlt(hdc, xReal, yReal, ix, iy, hdcMem, xMem, yMem, SRCCOPY | NOMIRRORBITMAP) == 0) {
                goto Cleanup;
            }

#if DBG
            cAnimationFrames++;
            dwElapsed2 = GetTickCount() - dwStart;
            dwElapsed2 -= dwElapsed;
#endif
            TAGMSG2(DBGTAG_AnimateWindow, "AnimateWindow: Frame %d took %lums", cAnimationFrames, dwElapsed2 );

            ixLast = ix;
            iyLast = iy;

            /*
             * Break out of the animation loop when, either:
             * 1) We've exceeded the animation time.
             * 2) We're hiding the window and one of the dimensions is 0.
             *    The window is completely hidden now anyways,
             * 3) We're showing the window and both dimensions are at their
             *    full size.  The window is completely shown now anyways.
             */
            if (dwElapsed > dwTime) {
                TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Done with the animation late!");
                break;
            }
            if ((fHide && (ix == 0 || iy == 0)) ||
                (!fHide && (ix == cx && iy == cy))) {
                TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Done with the animation on time or early!");
                break;
            }
        }
    }

    TAGMSG2(DBGTAG_AnimateWindow, "AnimateWindow: Animation completed after %lums, drawing %d frames.", dwElapsed, cAnimationFrames);
    fRet = TRUE;

    if (fHide) {
        UserAssert(ixLast == 0 || iyLast == 0);

        /*
         * We are supposed to be hiding the window.  Go ahead and restore the
         * child clipping setting, and hide the window.
         */
        if (fRestoreClipChildren) {
            SetWindowState(pwnd, WFCLIPCHILDREN);
            fRestoreClipChildren = FALSE;
        }

        NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0,
                           SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOREDRAW | SWP_HIDEWINDOW | SWP_NOACTIVATE);
        fHideWindow = FALSE;
    } else {
        UserAssert(ixLast == cx && iyLast == cy);

        /*
         * We successfully finished the animation loop!  Validate the entire window since
         * we claimed responsibility for drawing it correctly.
         */
        RedrawWindow(hwnd, NULL, NULL, RDW_NOERASE | RDW_NOFRAME | RDW_NOINTERNALPAINT | RDW_VALIDATE);
    }

Cleanup:
    /*
     * Things to do on cleanup.  Make sure we restore the "children clipping"
     * setting of the window if we removed it!
     */
    if (fRestoreClipChildren) {
        SetWindowState(pwnd, WFCLIPCHILDREN);
        fRestoreClipChildren = FALSE;
    }

    /*
     * Hide the window if needed before we reapply the window region.
     */
    if (fHideWindow) {
        TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Hiding the window during cleanup" );
        NtUserShowWindow(hwnd, SW_HIDE);
    }

    /*
     * Restore the original window region.  Note that the system now owns
     * the handle, so we should not delete it.  Also, if the original
     * handle was NULL, this removes any regions we inflicted on the window
     * in order to do the animation.
     */
    if (fRestoreOriginalRegion) {
        RealSetWindowRgn(hwnd, hrgnOriginal, FALSE);
        hrgnOriginal = NULL;
        fRestoreOriginalRegion = FALSE;
    }

    /*
     * More things to do on cleanup.  Make sure we show/activate the window
     * if needed!
     */
    if (fShowWindow && fActivateWindow) {
        TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Showing and activating the window during cleanup" );
        NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_DRAWFRAME | SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER);
        fShowWindow = FALSE;
        fActivateWindow = FALSE;
    }
    if (fShowWindow) {
        TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Showing the window during cleanup" );
        NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0,
                           SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOOWNERZORDER);
        fShowWindow = FALSE;
    }
    if (fActivateWindow) {
        TAGMSG0(DBGTAG_AnimateWindow, "AnimateWindow: Activating the window during cleanup" );
        NtUserSetWindowPos(hwnd, NULL, 0, 0, 0, 0,
                           SWP_DRAWFRAME | SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER);
        fActivateWindow = FALSE;
    }

    if (hdcMem != NULL) {
        DeleteDC(hdcMem);
    }

    if (hbmMem != NULL) {
        DeleteObject(hbmMem);
    }

    if (hdc != NULL) {
        ReleaseDC(hwnd, hdc);
    }

    if (hrgnAnim != NULL) {
        DeleteObject(hrgnAnim);
        hrgnAnim = NULL;
    }
    
    if (hrgnOldAnim != NULL) {
        DeleteObject(hrgnOldAnim);
        hrgnOldAnim = NULL;
    }

    if (hrgnUpdate != NULL) {
        DeleteObject(hrgnUpdate);
        hrgnUpdate = NULL;
    }

    return fRet;
}

/***************************************************************************\
* SmoothScrollWindowEx
*
* History:
* 24-Sep-1996   vadimg      wrote
\***************************************************************************/

#define MINSCROLL 10
#define MAXSCROLLTIME 200

int SmoothScrollWindowEx(HWND hwnd, int dx, int dy, CONST RECT *prcScroll,
        CONST RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, DWORD dwFlags,
        DWORD dwTime)
{
    RECT rc, rcT, rcUpdate;
    int dxStep, dyStep, dxDone, dyDone, xSrc, ySrc, xDst, yDst, dxBlt, dyBlt;
    int nRet = ERROR, nClip;
    BOOL fNegX = FALSE, fNegY = FALSE;
    HDC hdc, hdcMem = NULL;
    HBITMAP hbmMem = NULL, hbmOld;
    DWORD dwSleep;
    BOOL fCalcSubscroll = FALSE;
    PWND pwnd = ValidateHwnd(hwnd);
    HRGN hrgnScroll = NULL, hrgnErase = NULL;
    MSG msg;
    UINT uBounds;
    RECT rcBounds;

    if (pwnd == NULL)
        return ERROR;
    /*
     * Keep track of the signs so we don't have to mess with abs all the time.
     */
    if (dx < 0) {
        fNegX = TRUE;
        dx = -dx;
    }

    if (dy < 0) {
        fNegY = TRUE;
        dy = -dy;
    }

    /*
     * Set up the client rectangle.
     */
    if (prcScroll != NULL) {
        rc = *prcScroll;
    } else {
        rc.left = rc.top = 0;
        rc.right = pwnd->rcClient.right - pwnd->rcClient.left;
        rc.bottom = pwnd->rcClient.bottom - pwnd->rcClient.top;
    }

    /*
     * If they want to scroll less than we can let them, or more than
     * one page, or need repainting send them to the API.
     */
    if (pwnd->hrgnUpdate != NULL || (dx == 0 && dy == 0) ||
        (dx != 0 && dx > rc.right) ||
        (dy != 0 && dy > rc.bottom)) {
        return NtUserScrollWindowEx(hwnd, fNegX ? -dx : dx, fNegY ? -dy : dy,
                prcScroll, prcClip, hrgnUpdate, prcUpdate,
                dwFlags | SW_ERASE | SW_INVALIDATE);
    }

    if ((hdc = GetDCEx(hwnd, NULL, DCX_USESTYLE | DCX_CACHE)) == NULL) {
        return ERROR;
    }

    /*
     * Part of the window may be obscured, which means that more may be
     * invisible and may need to be bltted. Take that into account by
     * gettting the clip box.
     */
    nClip = GetClipBox(hdc, &rcT);
    if (nClip == ERROR || nClip == NULLREGION) {
        goto Cleanup;
    }

    /*
     * Set up the offscreen dc and send WM_PRINT to get the image.
     */
    if ((hbmMem = CreateCompatibleBitmap(hdc, rc.right, rc.bottom)) == NULL) {
        goto Cleanup;
    }
    if ((hdcMem = CreateCompatibleDC(hdc)) == NULL) {
        goto Cleanup;
    }
    hbmOld = SelectBitmap(hdcMem, hbmMem);

    SetBoundsRect(hdcMem, NULL, DCB_RESET | DCB_ENABLE);

    SendMessage(hwnd, WM_PRINT, (WPARAM)hdcMem, PRF_CLIENT |
            PRF_ERASEBKGND | ((dwFlags & SW_SCROLLCHILDREN) ? PRF_CHILDREN : 0));

    /*
     * If the client rect changes during the callback, send WM_PRINT
     * again to get the correctly sized image.
     */
    if (prcScroll == NULL) {
        rcT.left = rcT.top = 0;
        rcT.right = pwnd->rcClient.right - pwnd->rcClient.left;
        rcT.bottom = pwnd->rcClient.bottom - pwnd->rcClient.top;

        if (!EqualRect(&rc, &rcT)) {
            rc = rcT;

            SelectObject(hdcMem, hbmOld);
            DeleteObject(hbmMem);

            if ((hbmMem = CreateCompatibleBitmap(hdc, rc.right, rc.bottom)) == NULL) {
                goto Cleanup;
            }

            SelectObject(hdcMem, hbmMem);
            SendMessage(hwnd, WM_PRINT, (WPARAM)hdcMem, PRF_CLIENT |
                    PRF_ERASEBKGND | ((dwFlags & SW_SCROLLCHILDREN) ? PRF_CHILDREN : 0));
        }
    }

    /*
     * Check to see if the app painted in our DC.
     */
    uBounds = GetBoundsRect(hdcMem, &rcBounds, 0);
    if ((uBounds & DCB_RESET) && (!(uBounds & DCB_ACCUMULATE))) {
        goto Cleanup;
    }

    if ((hrgnScroll = CreateRectRgn(0, 0, 0, 0)) == NULL) {
        goto Cleanup;
    }
    if ((hrgnErase = CreateRectRgn(0, 0, 0, 0)) == NULL) {
        goto Cleanup;
    }
    SetRectEmpty(&rcUpdate);

    /*
     * Start off with MINSCROLL and adjust it based on available time after
     * the first iteration. We should consider adding a NOTIMELIMIT flag.
     */
    xDst = xSrc = 0;
    yDst = ySrc = 0;

    dxBlt = rc.right;
    dyBlt = rc.bottom;

    if (dx == 0) {
        dxDone = rc.right;
        dxStep = 0;
    } else {
        dxDone = 0;
        dxStep = max(dx / MINSCROLL, 1);
    }

    if (dy == 0) {
        dyDone = rc.bottom;
        dyStep = 0;
    } else {
        dyDone = 0;
        dyStep = max(dy / MINSCROLL, 1);
    }

    if (dwTime == 0) {
        dwTime = MAXSCROLLTIME;
    }
    dwSleep = dwTime / MINSCROLL;

    do {

        /*
         * When the dc is scrolled, the part that's revealed cannot be
         * updated properly. We set up the variables to blt just the part that
         * was just uncovered.
         */
        if (dx != 0) {
            if (dxDone + dxStep > dx) {
                dxStep = dx - dxDone;
            }
            dxDone += dxStep;

            xDst = dx - dxDone;
            dxBlt = rc.right - xDst;
            if (!fNegX) {
                xSrc = xDst;
                xDst = 0;
            }
        }

        if (dy != 0) {
            if (dyDone + dyStep > dy) {
                dyStep = dy - dyDone;
            }
            dyDone += dyStep;

            yDst = dy - dyDone;
            dyBlt = rc.bottom - yDst;
            if (!fNegY) {
                ySrc = yDst;
                yDst = 0;
            }
        }

        /*
         * This is a hack for ReaderMode to be smoothly continuous. We'll make an
         * attempt for the scrolling to take as close to dwTime
         * as possible. We'll also dispatch MOUSEMOVEs to the ReaderMode window, so it
         * can update mouse cursor.
         */
        if (MsgWaitForMultipleObjects(0, NULL, FALSE, dwSleep, QS_MOUSEMOVE) == WAIT_OBJECT_0) {
            if (PeekMessage(&msg, NULL, WM_MOUSEMOVE, WM_MOUSEMOVE, MAKELONG(PM_NOREMOVE, QS_INPUT))) {
                PWND pwndPeek = ValidateHwnd(msg.hwnd);
                if (pwndPeek != NULL) {
                    PCLS pcls = (PCLS)REBASEALWAYS(pwndPeek, pcls);
                    if (pcls->atomClassName == gatomReaderMode) {
                        if (PeekMessage(&msg, msg.hwnd, WM_MOUSEMOVE, WM_MOUSEMOVE, MAKELONG(PM_REMOVE, QS_INPUT))) {
                            DispatchMessage(&msg);
                        }
                    }
                }
            }
        }

        if ((nRet = NtUserScrollWindowEx(hwnd, fNegX ? -dxStep : dxStep,
                fNegY ? -dyStep : dyStep, prcScroll, prcClip,
                hrgnScroll, &rcT, dwFlags)) == ERROR)
            goto Cleanup;

        UnionRect(&rcUpdate, &rcUpdate, &rcT);

        /*
         * Blt the uncovered part.
         */
        BitBlt(hdc, xDst, yDst, dxBlt, dyBlt, hdcMem, xSrc, ySrc, SRCCOPY | NOMIRRORBITMAP);

        SetRectRgn(hrgnErase, xDst, yDst, xDst + dxBlt, yDst + dyBlt);
        CombineRgn(hrgnErase, hrgnScroll, hrgnErase, RGN_DIFF);
        RedrawWindow(hwnd, NULL, hrgnErase, RDW_ERASE | RDW_INVALIDATE | RDW_ERASENOW);

    } while (dxDone < dx || dyDone < dy);

    if (prcUpdate != NULL) {
        *prcUpdate = rcUpdate;
    }
    if (hrgnUpdate != NULL) {
        SetRectRgn(hrgnUpdate, rcUpdate.left, rcUpdate.top,
                rcUpdate.right, rcUpdate.bottom);
    }

Cleanup:
    if (hdcMem != NULL) {
        DeleteDC(hdcMem);
    }
    if (hbmMem != NULL) {
        DeleteObject(hbmMem);
    }
    if (hdc != NULL) {
        ReleaseDC(hwnd, hdc);
    }
    if (hrgnErase != NULL) {
        DeleteObject(hrgnErase);
    }
    if (hrgnScroll != NULL) {
        DeleteObject(hrgnScroll);
    }
    return nRet;
}

/***************************************************************************\
* ScrollWindowEx (API)
*
\***************************************************************************/

int ScrollWindowEx(HWND hwnd, int dx, int dy, CONST RECT *prcScroll,
        CONST RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate,
        UINT dwFlags)
{
    if (dwFlags & SW_SMOOTHSCROLL) {
        return SmoothScrollWindowEx(hwnd, dx, dy, prcScroll, prcClip,
                hrgnUpdate, prcUpdate, LOWORD(dwFlags), HIWORD(dwFlags));
    } else {
        return NtUserScrollWindowEx(hwnd, dx, dy, prcScroll, prcClip,
                hrgnUpdate, prcUpdate, dwFlags);
    }
}

/***************************************************************************\
* IsGUIThread (API)
*
* Checks whether the current thread is a GUI thread. If bConvert is TRUE, will
* convert the current thread to GUI, if necessary.
*
* History:
* 22-Jun-2000 JasonSch   Wrote.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsGUIThread, BOOL, bConvert)
BOOL IsGUIThread(BOOL bConvert)
{
    BOOL bIsGUI = (GetClientInfo() != NULL);

    if (!bIsGUI && bConvert) {
        bIsGUI = (BOOL)USERTHREADCONNECT();
        if (!bIsGUI) {
            UserSetLastError(ERROR_OUTOFMEMORY);
        }
    }

    return bIsGUI;
}

/***************************************************************************\
* IsWindowInDestroy (API)
*
* Checks whether the current window is in the process of being destroyed.
*
* History:
* 02-Jan-2001 Mohamed   Wrote.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsWindowInDestroy, HWND, hwnd)
BOOL IsWindowInDestroy(IN HWND hwnd)
{
    PWND pwnd;
    
    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return FALSE;
    }
    return TestWF(pwnd, WFINDESTROY);
}

/***************************************************************************\
* IsServerSideWindow (API)
*
* Checks whether the current window is marked as having a server side WndProc.
*
* History:
* 13-Jun-2001 Mohamed   Created.
\***************************************************************************/

FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsServerSideWindow, HWND, hwnd)
BOOL IsServerSideWindow(IN HWND hwnd)
{
    PWND pwnd;
    
    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL) {
        return FALSE;
    }
    return TestWF(pwnd, WFSERVERSIDEPROC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\wsprintf.c ===
/****************************** Module Header ******************************\
* Module Name: wsprintf.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*  sprintf.c
*
*  Implements Windows friendly versions of sprintf and vsprintf
*
*  History:
*   2-15-89  craigc     Initial
*  11-12-90  MikeHar    Ported from windows 3
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define out(c) if (cchLimit) {*lpOut++=(c); cchLimit--;} else goto errorout

/***************************************************************************\
* SP_PutNumber
*
* Takes an unsigned long integer and places it into a buffer, respecting
* a buffer limit, a radix, and a case select (upper or lower, for hex).
*
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   need to increment lpstr after assignment of mod
\***************************************************************************/

int SP_PutNumber(
    LPSTR   lpstr,
    ULONG64 n,
    int     limit,
    DWORD   radix,
    int     uppercase)
{
    DWORD mod;
    int count = 0;

    /* It might not work for some locales or digit sets */
    if(uppercase)
        uppercase =  'A'-'0'-10;
    else
        uppercase = 'a'-'0'-10;

    if (count < limit) {
        do  {
            mod =  (ULONG)(n % radix);
            n /= radix;

            mod += '0';
            if (mod > '9')
                mod += uppercase;
            *lpstr++ = (char)mod;
            count++;
        } while((count < limit) && n);
    }

    return count;
}

/***************************************************************************\
* SP_Reverse
*
*  reverses a string in place
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   fixed boundary conditions; removed count
\***************************************************************************/

void SP_Reverse(
    LPSTR lpFirst,
    LPSTR lpLast)
{
    char ch;

    while(lpLast > lpFirst){
        ch = *lpFirst;
        *lpFirst++ = *lpLast;
        *lpLast-- = ch;
    }
}

/***************************************************************************\
* SP_GetFmtValue
*
*  reads a width or precision value from the format string
*
* History:
*  11-12-90  MikeHar    Ported from windows 3
\***************************************************************************/

LPCSTR SP_GetFmtValue(
    LPCSTR lpch,
    int *lpw)
{
    int ii = 0;

    /* It might not work for some locales or digit sets */
    while (*lpch >= '0' && *lpch <= '9') {
        ii *= 10;
        ii += (int)(*lpch - '0');
        lpch++;
    }

    *lpw = ii;

    /*
     * return the address of the first non-digit character
     */
    return lpch;
}

/***************************************************************************\
* SP_GetFmtValueW
*
*  reads a width or precision value from the format string
*
* History:
*  11-12-90  MikeHar    Ported from windows 3
*  07-27-92  GregoryW   Created Unicode version (copied from SP_GetFmtValue)
\***************************************************************************/

LPCWSTR SP_GetFmtValueW(
    LPCWSTR lpch,
    int *lpw)
{
    int ii = 0;

    /* It might not work for some locales or digit sets */
    while (*lpch >= L'0' && *lpch <= L'9') {
        ii *= 10;
        ii += (int)(*lpch - L'0');
        lpch++;
    }

    *lpw = ii;

    /*
     * return the address of the first non-digit character
     */
    return lpch;
}

/***************************************************************************\
* wvsprintfA (API)
*
* Windows version of vsprintf().  Does not support floating point or
* pointer types, and all strings are assumed to be FAR.  Supports only
* the left alignment flag.
*
* Takes pointers to an output buffer, where the string is built, a
* pointer to an input buffer, and a pointer to a list of parameters.
*
* The cdecl function wsprintf() calls this function.
*
* History:
* 11-12-90 MikeHar      Ported from windows 3
* 12-11-90 GregoryW     after %d format is parsed lpParms needs to be aligned
*                       to a dword boundary.
* 09-Aug-1991 mikeke    no it doesn't
* 11-19-91 DarrinM      Now wvsprintf and wsprintf treat parameters the same
*                       (as if they originated from a DWORD-aligned stack).
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, int, DUMMYCALLINGTYPE, wvsprintfA, LPSTR, lpOut, LPCSTR, lpFmt, va_list, arglist)
int wvsprintfA(
    LPSTR lpOut,
    LPCSTR lpFmt,
    va_list arglist)
{
    BOOL fAllocateMem;
    char prefix, fillch;
    int left, width, prec, size, sign, radix, upper, hprefix;
    int cchLimit = WSPRINTF_LIMIT, cch;
    LPSTR lpT, lpTMB;
    LPWSTR pwsz;
    va_list varglist = arglist;
    union {
        LONG64 l;
        ULONG64 ul;
        char sz[2];
        WCHAR wsz[2];
    } val;

    while (*lpFmt != 0) {
        if (*lpFmt == '%') {
            /*
             * read the flags.  These can be in any order
             */
            left = 0;
            prefix = 0;
            while (*++lpFmt) {
                if (*lpFmt == '-')
                    left++;
                else if (*lpFmt == '#')
                    prefix++;
                else
                    break;
            }

            /*
             * find fill character
             */
            if (*lpFmt == '0') {
                fillch = '0';
                lpFmt++;
            } else
                fillch = ' ';

            /*
             * read the width specification
             */
            lpFmt = SP_GetFmtValue((LPCSTR)lpFmt, &cch);
            width = cch;

            /*
             * read the precision
             */
            if (*lpFmt == '.') {
                lpFmt = SP_GetFmtValue((LPCSTR)++lpFmt, &cch);
                prec = cch;
            } else
                prec = -1;

            /*
             * get the operand size
             * default size: size == 0
             * long number:  size == 1
             * wide chars:   size == 2
             * 64bit number: size == 3
             * It may be a good idea to check the value of size when it
             * is tested for non-zero below (IanJa)
             */
            hprefix = 0;
            if (*lpFmt == 'w') {
                size = 2;
                lpFmt++;
            } else if (*lpFmt == 'l') {
                size = 1;
                lpFmt++;
            } else if (*lpFmt == 't') {
                size = 0;
                lpFmt++;
            } else if (*lpFmt == 'I') {
                if (*(lpFmt+1) == '3' && *(lpFmt+2) == '2') {
                    size = 1;
                    lpFmt += 3;
                } else if (*(lpFmt+1) == '6' && *(lpFmt+2) == '4') {
                    size = 3;
                    lpFmt += 3;
                } else {
                    size = (sizeof(INT_PTR) == sizeof(LONG)) ? 1 : 3;
                    lpFmt++;
                }
            } else {
                size = 0;
                if (*lpFmt == 'h') {
                    lpFmt++;
                    hprefix = 1;
                } else if ((*lpFmt == 'i') || (*lpFmt == 'd')) {
                    // %i or %d specified (no modifiers) - use long
                    // %u seems to have always been short - leave alone
                    size = 1;
                }
            }

            upper = 0;
            sign = 0;
            radix = 10;

            switch (*lpFmt) {
            case 0:
                goto errorout;

            case 'i':
            case 'd':
                sign++;

                /*** FALL THROUGH to case 'u' ***/

            case 'u':
                /* turn off prefix if decimal */
                prefix = 0;
donumeric:
                /* special cases to act like MSC v5.10 */
                if (left || prec >= 0)
                    fillch = ' ';

                /*
                 * if size == 1, "%lu" was specified (good);
                 * if size == 2, "%wu" was specified (bad)
                 * if size == 3, "%p" was specified
                 */
                if (size == 3) {
                    val.l = va_arg(varglist, LONG64);
                } else if (size) {
                    val.l = va_arg(varglist, long);
                } else if (sign) {
                    val.l = (long)va_arg(varglist, short);
                } else {
                    val.ul = va_arg(varglist, unsigned);
                }

                if (sign && val.l < 0L)
                    val.l = -val.l;
                else
                    sign = 0;

                /*
                 * Unless printing a full 64-bit value, ensure values
                 * here are not in canonical longword format to prevent
                 * the sign extended upper 32-bits from being printed.
                 */
                if (size != 3) {
                    val.l &= MAXULONG;
                }

                lpT = lpOut;

                /*
                 * blast the number backwards into the user buffer
                 */
                cch = SP_PutNumber(lpOut, val.l, cchLimit, radix, upper);
                if (!(cchLimit -= cch))
                    goto errorout;

                lpOut += cch;
                width -= cch;
                prec -= cch;
                if (prec > 0)
                    width -= prec;

                /*
                 * fill to the field precision
                 */
                while (prec-- > 0)
                    out('0');

                if (width > 0 && !left) {
                    /*
                     * if we're filling with spaces, put sign first
                     */
                    if (fillch != '0') {
                        if (sign) {
                            sign = 0;
                            out('-');
                            width--;
                        }

                        if (prefix) {
                            out(prefix);
                            out('0');
                            prefix = 0;
                        }
                    }

                    if (sign)
                        width--;

                    /*
                     * fill to the field width
                     */
                    while (width-- > 0)
                        out(fillch);

                    /*
                     * still have a sign?
                     */
                    if (sign)
                        out('-');

                    if (prefix) {
                        out(prefix);
                        out('0');
                    }

                    /*
                     * now reverse the string in place
                     */
                    SP_Reverse(lpT, lpOut - 1);
                } else {
                    /*
                     * add the sign character
                     */
                    if (sign) {
                        out('-');
                        width--;
                    }

                    if (prefix) {
                        out(prefix);
                        out('0');
                    }

                    /*
                     * reverse the string in place
                     */
                    SP_Reverse(lpT, lpOut - 1);

                    /*
                     * pad to the right of the string in case left aligned
                     */
                    while (width-- > 0)
                        out(fillch);
                }
                break;

            case 'p':
                size = (sizeof(PVOID) == sizeof(LONG)) ? 1 : 3;
                if (prec == -1) {
                    prec = 2 * sizeof(PVOID);
                }

                /*** FALL THROUGH to case 'X' ***/

            case 'X':
                upper++;

                /*** FALL THROUGH to case 'x' ***/

            case 'x':
                radix = 16;
                if (prefix)
                    if (upper)
                        prefix = 'X';
                    else
                        prefix = 'x';
                goto donumeric;

            case 'C':
                /*
                 * explicit size specifier overrides case
                 */
                if (!size && !hprefix) {
                    size = 1;           // force WCHAR
                }

                /*** FALL THROUGH to case 'c' ***/

            case 'c':
                /*
                 * if size == 0, "%c" or "%hc" or "%tc" was specified (CHAR)
                 * if size == 1, "%C" or "%lc" was specified (WCHAR);
                 * if size == 2, "%wc" was specified (WCHAR)
                 */
                cch = 1; /* One character must be copied to the output buffer */
                if (size) {
                    val.wsz[0] = va_arg(varglist, WCHAR);
                    val.wsz[1] = 0x0000;
                    pwsz = val.wsz;
                    goto putwstring;
                } else {
                    val.sz[0] = va_arg(varglist, CHAR);
                    val.sz[1] = 0;
                    lpT = val.sz;
                    goto putstring;
                }

            case 'S':
                /*
                 * explicit size specifier overrides case
                 */
                if (!size && !hprefix) {
                    size = 1;           // force LPWSTR
                }

                /*** FALL THROUGH to case 's' ***/

            case 's':
                /*
                 * if size == 0, "%s" or "%hs" or "%ts" was specified (LPSTR);
                 * if size == 1, "%S" or "%ls" was specified (LPWSTR);
                 * if size == 2, "%ws" was specified (LPWSTR)
                 */
                if (size) {
                    pwsz = va_arg(varglist, LPWSTR);
                    if (pwsz == NULL) {
                        cch = 0;
                    } else {
                        cch = wcslen(pwsz);
                    }
putwstring:
                    cch = WCSToMB(pwsz, cch, &lpTMB, -1, TRUE);
                    fAllocateMem = (BOOL) cch;
                    lpT = lpTMB;
                } else {
                    lpT = va_arg(varglist, LPSTR);
                    if (lpT == NULL) {
                        cch = 0;
                    } else {
                        cch = strlen(lpT);
                    }
putstring:
                    fAllocateMem = FALSE;
                }

                if (prec >= 0 && cch > prec)
                    cch = prec;
                width -= cch;

                if (fAllocateMem) {
                    if (cch + (width < 0 ? 0 : width) >= cchLimit) {
                        UserLocalFree(lpTMB);
                        goto errorout;
                    }
                }

                if (left) {
                    while (cch--)
                        out(*lpT++);
                    while (width-- > 0)
                        out(fillch);
                } else {
                    while (width-- > 0)
                        out(fillch);
                    while (cch--)
                        out(*lpT++);
                }

                if (fAllocateMem) {
                     UserLocalFree(lpTMB);
                }
                break;

            default:
normalch:
                out(*lpFmt);
                break;
            }  /* END OF SWITCH(*lpFmt) */
        }  /* END OF IF(%) */ else
            goto normalch;  /* character not a '%', just do it */

        /*
         * advance to next format string character
         */
        lpFmt++;
    }  /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut = 0;

    return WSPRINTF_LIMIT - cchLimit;
}

/***************************************************************************\
* StringPrintfA (API)
*
* Windows version of sprintf
*
* History:
* 11-12-90 MikeHar      Ported from windows 3
* 02-05-90 DarrinM      Cleaned up with STDARG.h vararg stuff.
\***************************************************************************/

int WINAPIV wsprintfA(
    LPSTR lpOut,
    LPCSTR lpFmt,
    ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvsprintfA(lpOut, lpFmt, arglist);
    va_end(arglist);
    return ret;
}

/***************************************************************************\
* SP_PutNumberW
*
* Takes an unsigned long integer and places it into a buffer, respecting
* a buffer limit, a radix, and a case select (upper or lower, for hex).
*
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   need to increment lpstr after assignment of mod
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

int SP_PutNumberW(
    LPWSTR  lpstr,
    ULONG64 n,
    int     limit,
    DWORD   radix,
    int     uppercase)
{
    DWORD mod;
    int count = 0;

    /* It might not work for some locales or digit sets */
    if(uppercase)
        uppercase =  'A'-'0'-10;
    else
        uppercase = 'a'-'0'-10;

    if (count < limit) {
        do  {
            mod =  (ULONG)(n % radix);
            n /= radix;

            mod += '0';
            if (mod > '9')
            mod += uppercase;
            *lpstr++ = (WCHAR)mod;
            count++;
        } while((count < limit) && n);
    }

    return count;
}

/***************************************************************************\
* SP_ReverseW
*
*  reverses a string in place
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   fixed boundary conditions; removed count
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

void SP_ReverseW(
    LPWSTR lpFirst,
    LPWSTR lpLast)
{
    WCHAR ch;

    while(lpLast > lpFirst){
        ch = *lpFirst;
        *lpFirst++ = *lpLast;
        *lpLast-- = ch;
    }
}


/***************************************************************************\
* wvsprintfW (API)
*
* wsprintfW() calls this function.
*
* History:
*    11-Feb-1992 GregoryW copied xwvsprintf
*         Temporary hack until we have C runtime support
\***************************************************************************/


FUNCLOG3(LOG_GENERAL, int, DUMMYCALLINGTYPE, wvsprintfW, LPWSTR, lpOut, LPCWSTR, lpFmt, va_list, arglist)
int wvsprintfW(
    LPWSTR lpOut,
    LPCWSTR lpFmt,
    va_list arglist)
{
    BOOL fAllocateMem;
    WCHAR prefix, fillch;
    int left, width, prec, size, sign, radix, upper, hprefix;
    int cchLimit = WSPRINTF_LIMIT, cch;
    LPWSTR lpT, lpTWC;
    LPBYTE psz;
    va_list varglist = arglist;
    union {
        LONG64 l;
        ULONG64 ul;
        char sz[2];
        WCHAR wsz[2];
    } val;

    while (*lpFmt != 0) {
        if (*lpFmt == L'%') {

            /*
             * read the flags.  These can be in any order
             */
            left = 0;
            prefix = 0;
            while (*++lpFmt) {
                if (*lpFmt == L'-')
                    left++;
                else if (*lpFmt == L'#')
                    prefix++;
                else
                    break;
            }

            /*
             * find fill character
             */
            if (*lpFmt == L'0') {
                fillch = L'0';
                lpFmt++;
            } else
                fillch = L' ';

            /*
             * read the width specification
             */
            lpFmt = SP_GetFmtValueW(lpFmt, &cch);
            width = cch;

            /*
             * read the precision
             */
            if (*lpFmt == L'.') {
                lpFmt = SP_GetFmtValueW(++lpFmt, &cch);
                prec = cch;
            } else
                prec = -1;

            /*
             * get the operand size
             * default size: size == 0
             * long number:  size == 1
             * wide chars:   size == 2
             * 64bit number: size == 3
             * It may be a good idea to check the value of size when it
             * is tested for non-zero below (IanJa)
             */
            hprefix = 0;
            if ((*lpFmt == L'w') || (*lpFmt == L't')) {
                size = 2;
                lpFmt++;
            } else if (*lpFmt == L'l') {
                size = 1;
                lpFmt++;
            } else if (*lpFmt == L'I') {
                if (*(lpFmt+1) == L'3' && *(lpFmt+2) == L'2') {
                    size = 1;
                    lpFmt += 3;
                } else if (*(lpFmt+1) == L'6' && *(lpFmt+2) == L'4') {
                    size = 3;
                    lpFmt += 3;
                } else {
                    size = (sizeof(INT_PTR) == sizeof(LONG)) ? 1 : 3;
                    lpFmt++;
                }
            } else {
                size = 0;
                if (*lpFmt == L'h') {
                    lpFmt++;
                    hprefix = 1;
                } else if ((*lpFmt == L'i') || (*lpFmt == L'd')) {
                    // %i or %d specified (no modifiers) - use long
                    // %u seems to have always been short - leave alone
                    size = 1;
                }
            }

            upper = 0;
            sign = 0;
            radix = 10;

            switch (*lpFmt) {
            case 0:
                goto errorout;

            case L'i':
            case L'd':
                sign++;

                /*** FALL THROUGH to case 'u' ***/

            case L'u':
                /* turn off prefix if decimal */
                prefix = 0;
donumeric:
                /* special cases to act like MSC v5.10 */
                if (left || prec >= 0)
                    fillch = L' ';

                /*
                 * if size == 1, "%lu" was specified (good);
                 * if size == 2, "%wu" was specified (bad)
                 * if size == 3, "%p" was specified
                 */
                if (size == 3) {
                    val.l = va_arg(varglist, LONG64);
                } else if (size) {
                    val.l = va_arg(varglist, LONG);
                } else if (sign) {
                    val.l = va_arg(varglist, SHORT);
                } else {
                    val.ul = va_arg(varglist, unsigned);
                }

                if (sign && val.l < 0L)
                    val.l = -val.l;
                else
                    sign = 0;

                /*
                 * Unless printing a full 64-bit value, ensure values
                 * here are not in canonical longword format to prevent
                 * the sign extended upper 32-bits from being printed.
                 */
                if (size != 3) {
                    val.l &= MAXULONG;
                }

                lpT = lpOut;

                /*
                 * blast the number backwards into the user buffer
                 */
                cch = SP_PutNumberW(lpOut, val.l, cchLimit, radix, upper);
                if (!(cchLimit -= cch))
                    goto errorout;

                lpOut += cch;
                width -= cch;
                prec -= cch;
                if (prec > 0)
                    width -= prec;

                /*
                 * fill to the field precision
                 */
                while (prec-- > 0)
                    out(L'0');

                if (width > 0 && !left) {
                    /*
                     * if we're filling with spaces, put sign first
                     */
                    if (fillch != L'0') {
                        if (sign) {
                            sign = 0;
                            out(L'-');
                            width--;
                        }

                        if (prefix) {
                            out(prefix);
                            out(L'0');
                            prefix = 0;
                        }
                    }

                    if (sign)
                        width--;

                    /*
                     * fill to the field width
                     */
                    while (width-- > 0)
                        out(fillch);

                    /*
                     * still have a sign?
                     */
                    if (sign)
                        out(L'-');

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * now reverse the string in place
                     */
                    SP_ReverseW(lpT, lpOut - 1);
                } else {
                    /*
                     * add the sign character
                     */
                    if (sign) {
                        out(L'-');
                        width--;
                    }

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * reverse the string in place
                     */
                    SP_ReverseW(lpT, lpOut - 1);

                    /*
                     * pad to the right of the string in case left aligned
                     */
                    while (width-- > 0)
                        out(fillch);
                }
                break;

            case L'p':
                size = (sizeof(PVOID) == sizeof(LONG)) ? 1 : 3;
                if (prec == -1) {
                    prec = 2 * sizeof(PVOID);
                }

                /*** FALL THROUGH to case 'X' ***/

            case L'X':
                upper++;

                /*** FALL THROUGH to case 'x' ***/

            case L'x':
                radix = 16;
                if (prefix)
                    if (upper)
                        prefix = L'X';
                    else
                        prefix = L'x';
                goto donumeric;

            case L'c':
                if (!size && !hprefix) {
                    size = 1;           // force WCHAR
                }

                /*** FALL THROUGH to case 'C' ***/

            case L'C':
                /*
                 * if size == 0, "%C" or "%hc" was specified (CHAR);
                 * if size == 1, "%c" or "%lc" was specified (WCHAR);
                 * if size == 2, "%wc" or "%tc" was specified (WCHAR)
                 */
                cch = 1; /* One character must be copied to the output buffer */
                if (size) {
                    val.wsz[0] = va_arg(varglist, WCHAR);
                    val.wsz[1] = 0;
                    lpT = val.wsz;
                    goto putwstring;
                } else {
                    val.sz[0] = va_arg(varglist, CHAR);
                    val.sz[1] = 0;
                    psz = val.sz;
                    goto putstring;
                }

            case L's':
                if (!size && !hprefix) {
                    size = 1;           // force LPWSTR
                }

                /*** FALL THROUGH to case 'S' ***/

            case L'S':
                /*
                 * if size == 0, "%S" or "%hs" was specified (LPSTR)
                 * if size == 1, "%s" or "%ls" was specified (LPWSTR);
                 * if size == 2, "%ws" or "%ts" was specified (LPWSTR)
                 */
                if (size) {
                    lpT = va_arg(varglist, LPWSTR);
                    if (lpT == NULL) {
                        cch = 0;
                    } else {
                        cch = wcslen(lpT);
                    }
putwstring:
                    fAllocateMem = FALSE;
                } else {
                    psz = va_arg(varglist, LPBYTE);
                    if (psz == NULL) {
                        cch = 0;
                    } else {
                        cch = strlen(psz);
                    }
putstring:
                    cch = MBToWCS(psz, cch, &lpTWC, -1, TRUE);
                    fAllocateMem = (BOOL) cch;
                    lpT = lpTWC;
                }

                if (prec >= 0 && cch > prec)
                    cch = prec;
                width -= cch;

                if (fAllocateMem) {
                    if (cch + (width < 0 ? 0 : width) >= cchLimit) {
                        UserLocalFree(lpTWC);
                        goto errorout;
                    }
                }

                if (left) {
                    while (cch--)
                        out(*lpT++);
                    while (width-- > 0)
                        out(fillch);
                } else {
                    while (width-- > 0)
                        out(fillch);
                    while (cch--)
                        out(*lpT++);
                }

                if (fAllocateMem) {
                     UserLocalFree(lpTWC);
                }

                break;

            default:
normalch:
                out((WCHAR)*lpFmt);
                break;
            }  /* END OF SWITCH(*lpFmt) */
        }  /* END OF IF(%) */ else
            goto normalch;  /* character not a '%', just do it */

        /*
         * advance to next format string character
         */
        lpFmt++;
    }  /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut = 0;

    return WSPRINTF_LIMIT - cchLimit;
}

int WINAPIV wsprintfW(
    LPWSTR lpOut,
    LPCWSTR lpFmt,
    ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvsprintfW(lpOut, lpFmt, arglist);
    va_end(arglist);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\wow64\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\keizon\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\wow.c ===
/****************************** Module Header ******************************\
* Module Name: wow.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains shared code between USER32 and USER16
* No New CODE should be added to this file, unless its shared
* with USER16.
*
* History:
* 29-DEC-93 NanduriR      shared user32/user16 code.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* ValidateHwnd
*
* Verify that the handle is valid.  If the handle is invalid or access
* cannot be granted fail.
*
* History:
* 03-18-92 DarrinM      Created from pieces of misc server-side funcs.
\***************************************************************************/
PWND FASTCALL ValidateHwnd(
    HWND hwnd)
{
    PCLIENTINFO pci = GetClientInfo();

    /*
     * Attempt fast window validation.
     */
    if (hwnd != NULL && hwnd == pci->CallbackWnd.hwnd) {
        return pci->CallbackWnd.pwnd;
    }

    /*
     * Validate that the handle is of the proper type.
     */
    return HMValidateHandle(hwnd, TYPE_WINDOW);
}


PWND FASTCALL ValidateHwndNoRip(
    HWND hwnd)
{
    PCLIENTINFO pci = GetClientInfo();

    /*
     * Attempt fast window validation.
     */
    if (hwnd != NULL && hwnd == pci->CallbackWnd.hwnd) {
        return pci->CallbackWnd.pwnd;
    }

    /*
     * Validate the handle is of the proper type.
     */
    return HMValidateHandleNoRip(hwnd, TYPE_WINDOW);
}




FUNCLOG3(LOG_GENERAL, int, WINAPI, GetClassNameA, HWND, hwnd, LPSTR, lpClassName, int, nMaxCount)
int WINAPI GetClassNameA(
    HWND hwnd,
    LPSTR lpClassName,
    int nMaxCount)
{
    PCLS pcls;
    LPSTR lpszClassNameSrc;
    PWND pwnd;
    int cchSrc;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return FALSE;

    try {
        if (nMaxCount != 0) {
            pcls = (PCLS)REBASEALWAYS(pwnd, pcls);
            lpszClassNameSrc = REBASEPTR(pwnd, pcls->lpszAnsiClassName);
            cchSrc = lstrlenA(lpszClassNameSrc);
            nMaxCount = min(cchSrc, nMaxCount - 1);
            RtlCopyMemory(lpClassName, lpszClassNameSrc, nMaxCount);
            lpClassName[nMaxCount] = '\0';
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        nMaxCount = 0;
    }

    return nMaxCount;
}

/***************************************************************************\
* _GetDesktopWindow (API)
*
*
*
* History:
* 11-07-90 darrinm      Implemented.
\***************************************************************************/
PWND _GetDesktopWindow(void)
{
    PCLIENTINFO pci;

    ConnectIfNecessary(0);

    pci = GetClientInfo();
    return (PWND)((KERNEL_ULONG_PTR)pci->pDeskInfo->spwnd -
            pci->ulClientDelta);
}



HWND GetDesktopWindow(void)
{
    PWND        pwnd;
    PCLIENTINFO pci;

    pwnd = _GetDesktopWindow();

    pci = GetClientInfo();

    /*
     * validate the parent window's handle if a restricted process
     */
    if (pci && (pci->dwTIFlags & TIF_RESTRICTED)) {
        if (ValidateHwnd(HW(pwnd)) == NULL) {
            return NULL;
        }
    }
    return HW(pwnd);
}


PWND _GetDlgItem(
    PWND pwnd,
    int id)
{
    if (pwnd != NULL) {
        pwnd = REBASEPWND(pwnd, spwndChild);
        while (pwnd != NULL) {
            if (PtrToLong(pwnd->spmenu) == id)
                break;
            pwnd = REBASEPWND(pwnd, spwndNext);
        }
    }

    return pwnd;
}



FUNCLOG2(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, GetDlgItem, HWND, hwnd, int, id)
HWND GetDlgItem(
    HWND hwnd,
    int id)
{
    PWND pwnd;
    HWND hwndRet;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL)
        return NULL;

    pwnd = _GetDlgItem(pwnd, id);

    hwndRet = HW(pwnd);

    if (hwndRet == (HWND)0)
        RIPERR0(ERROR_CONTROL_ID_NOT_FOUND, RIP_VERBOSE, "");

    return hwndRet;
}



FUNCLOG1(LOG_GENERAL, HMENU, DUMMYCALLINGTYPE, GetMenu, HWND, hwnd)
HMENU GetMenu(
    HWND hwnd)
{
    PWND pwnd;
    PMENU pmenu;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return 0;

    /*
     * Some ill-behaved apps use GetMenu to get the child id, so
     * only map to the handle for non-child windows.
     */
    if (!TestwndChild(pwnd)) {
        pmenu = REBASE(pwnd, spmenu);
        return (HMENU)PtoH(pmenu);
    } else {
        return (HMENU)KPVOID_TO_PVOID(pwnd->spmenu);
    }
}


/***************************************************************************\
* GetMenuItemCount
*
* Returns a count of the number of items in the menu. Returns -1 if
* invalid menu.
*
* History:
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetMenuItemCount, HMENU, hMenu)
int GetMenuItemCount(
    HMENU hMenu)
{
    PMENU pMenu;

    pMenu = VALIDATEHMENU(hMenu);

    if (pMenu == NULL)
        return -1;

    return pMenu->cItems;
}

/***************************************************************************\
* GetMenuItemID
*
* Return the ID of a menu item at the specified position.
*
* History:
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, GetMenuItemID, HMENU, hMenu, int, nPos)
UINT GetMenuItemID(
    HMENU hMenu,
    int nPos)
{
    PMENU pMenu;
    PITEM pItem;

    pMenu = VALIDATEHMENU(hMenu);

    if (pMenu == NULL)
        return (UINT)-1;

    /*
     * If the position is valid and the item is not a popup, get the ID
     * Don't allow negative indexes, because that'll cause an access violation.
     */
    if (nPos < (int)pMenu->cItems && nPos >= 0) {
        pItem = &((PITEM)REBASEALWAYS(pMenu, rgItems))[nPos];
        if (pItem->spSubMenu == NULL)
            return pItem->wID;
    }

    return (UINT)-1;
}



FUNCLOG3(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, GetMenuState, HMENU, hMenu, UINT, uId, UINT, uFlags)
UINT GetMenuState(
    HMENU hMenu,
    UINT uId,
    UINT uFlags)
{
    PMENU pMenu;

    pMenu = VALIDATEHMENU(hMenu);

    if (pMenu == NULL || (uFlags & ~MF_VALID) != 0) {
        return (UINT)-1;
    }

    return _GetMenuState(pMenu, uId, uFlags);
}



FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsWindow, HWND, hwnd)
BOOL IsWindow(
    HWND hwnd)
{
    PWND pwnd;

    /*
     * Validate the handle is of type window
     */
    pwnd = ValidateHwndNoRip(hwnd);

    /*
     * And validate this handle is valid for this desktop by trying to read it
     */
    if (pwnd != NULL) {
        try {
            if (pwnd->fnid & FNID_DELETED_BIT) {
                pwnd = 0;
            }
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            RIPMSG1(RIP_WARNING, "IsWindow: Window %#p not of this desktop",
                    pwnd);
            pwnd = 0;
        }
    }
    return !!pwnd;
}



FUNCLOG2(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, GetWindow, HWND, hwnd, UINT, wCmd)
HWND GetWindow(
    HWND hwnd,
    UINT wCmd)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL)
        return NULL;

    pwnd = _GetWindow(pwnd, wCmd);
    return HW(pwnd);
}


FUNCLOG1(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, GetParent, HWND, hwnd)
HWND GetParent(
    HWND hwnd)
{
    PWND        pwnd;
    PCLIENTINFO pci;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL)
        return NULL;

    try {
        pwnd = _GetParent(pwnd);
        hwnd = HW(pwnd);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        hwnd = NULL;
    }

    pci = GetClientInfo();

    /*
     * validate the parent window's handle if a restricted process
     */
    if (pci && (pci->dwTIFlags & TIF_RESTRICTED)) {
        if (ValidateHwnd(hwnd) == NULL) {
            return NULL;
        }
    }

    return hwnd;
}


FUNCLOG2(LOG_GENERAL, HMENU, DUMMYCALLINGTYPE, GetSubMenu, HMENU, hMenu, int, nPos)
HMENU GetSubMenu(
    HMENU hMenu,
    int nPos)
{
    PMENU pMenu;

    pMenu = VALIDATEHMENU(hMenu);

    if (pMenu == NULL)
        return 0;

    pMenu = _GetSubMenu(pMenu, nPos);
    return (HMENU)PtoH(pMenu);
}



FUNCLOG1(LOG_GENERAL, DWORD, DUMMYCALLINGTYPE, GetSysColor, int, nIndex)
DWORD GetSysColor(
    int nIndex)
{

    /*
     * Currently we don't do client side checks because they do not really
     * make sense;  someone can read the data even with the checks.  We
     * leave in the attribute values in case we want to move these values
     * back to the server side someday
     */
#ifdef ENABLE_CLIENTSIDE_ACCESSCHECK
    /*
     * Make sure we have access to the system colors.
     */
    if (!(gamWinSta & WINSTA_READATTRIBUTES)) {
        return 0;
    }
#endif

    /*
     * Return 0 if the index is out of range.
     */
    if (nIndex < 0 || nIndex >= COLOR_MAX) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"nIndex\" (%ld) to GetSysColor",
                nIndex);

        return 0;
    }

    return (gpsi->argbSystem[nIndex]);
}



FUNCLOG1(LOG_GENERAL, int, DUMMYCALLINGTYPE, GetSystemMetrics, int, index)
int GetSystemMetrics(
    int index)
{
    int ret;

    BEGIN_USERAPIHOOK()
        ret = guah.pfnGetSystemMetrics(index);
    END_USERAPIHOOK()

    return ret;
}


int RealGetSystemMetrics(
    int index)
{
    ConnectIfNecessary(0);

    /*
     * First check for values that aren't in the aiSysMet array.
     */
    switch (index) {
    case SM_REMOTESESSION:
        return ISREMOTESESSION();
    }

    /*
     * If it's in the BOOLEAN system metric range then do our magic.
     */
    if (index >= SM_STARTBOOLRANGE && index <= SM_ENDBOOLRANGE) {
        return SYSMETBOOL2(index);
    }

    if ((index < 0) || (index >= SM_CMETRICS)) {
        return 0;
    }

    switch (index) {
    case SM_DBCSENABLED:
#ifdef FE_SB
        return TEST_BOOL_FLAG(gpsi->wSRVIFlags, SRVIF_DBCS);
#else
        return FALSE;
#endif
    case SM_IMMENABLED:
#ifdef FE_IME
        return TEST_BOOL_FLAG(gpsi->wSRVIFlags, SRVIF_IME);
#else
        return FALSE;
#endif

    case SM_MIDEASTENABLED:
        return TEST_BOOL_FLAG(gpsi->wSRVIFlags, SRVIF_MIDEAST);
    }

    if (!Is400Compat(GetClientInfo()->dwExpWinVer)) {
        /*
         * SCROLL BAR
         * before 4.0, the scroll bars and the border overlapped by a pixel.  Many apps
         * rely on this overlap when they compute dimensions.  Now, in 4.0, this pixel
         * overlap is no longer there.  So for old apps, we lie and pretend the overlap
         * is there by making the scroll bar widths one bigger.
         *
         * DLGFRAME
         * In Win3.1, SM_CXDLGFRAME & SM_CYDLGFRAME were border space MINUS 1
         * In Win4.0, they are border space
         *
         * CAPTION
         * In Win3.1, SM_CYCAPTION was the caption height PLUS 1
         * In Win4.0, SM_CYCAPTION is the caption height
         *
         * MENU
         * In Win3.1, SM_CYMENU was the menu height MINUS 1
         * In Win4.0, SM_CYMENU is the menu height
         */

        switch (index) {

        case SM_CXDLGFRAME:
        case SM_CYDLGFRAME:
        case SM_CYMENU:
        case SM_CYFULLSCREEN:
            return gpsi->aiSysMet[index] - 1;

        case SM_CYCAPTION:
        case SM_CXVSCROLL:
        case SM_CYHSCROLL:
            return gpsi->aiSysMet[index] + 1;
        }
    }

    return gpsi->aiSysMet[index];
}

/***************************************************************************\
* GetTopWindow (API)
*
* This poorly named API should really be called 'GetFirstChild', which is
* what it does.
*
* History:
* 11-12-90 darrinm      Ported.
* 02-19-91 JimA         Added enum access check
* 05-04-02 DarrinM      Removed enum access check and moved to USERRTL.DLL
\***************************************************************************/
FUNCLOG1(LOG_GENERAL, HWND, DUMMYCALLINGTYPE, GetTopWindow, HWND, hwnd)
HWND GetTopWindow(
    HWND hwnd)
{
    PWND pwnd;

    /*
     * Allow a NULL hwnd to go through here.
     */
    if (hwnd == NULL) {
        pwnd = _GetDesktopWindow();
    } else {
        pwnd = ValidateHwnd(hwnd);
    }
    if (pwnd == NULL)
        return NULL;

    pwnd = REBASEPWND(pwnd, spwndChild);
    return HW(pwnd);
}



FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsChild, HWND, hwndParent, HWND, hwnd)
BOOL IsChild(
    HWND hwndParent,
    HWND hwnd)
{
    PWND pwnd, pwndParent;

    pwnd = ValidateHwnd(hwnd);
    if (pwnd == NULL)
        return FALSE;

    pwndParent = ValidateHwnd(hwndParent);
    if (pwndParent == NULL)
        return FALSE;

    return _IsChild(pwndParent, pwnd);
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsIconic, HWND, hwnd)
BOOL IsIconic(
    HWND hwnd)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return FALSE;

    return _IsIconic(pwnd);
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsWindowEnabled, HWND, hwnd)
BOOL IsWindowEnabled(
    HWND hwnd)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return FALSE;

    return _IsWindowEnabled(pwnd);
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsWindowVisible, HWND, hwnd)
BOOL IsWindowVisible(
    HWND hwnd)
{
    PWND pwnd;
    BOOL bRet;

    pwnd = ValidateHwnd(hwnd);

    /*
     * We have have to try - except this call because there is no
     * synchronization on the window structure on the client side.
     * If the window is deleted after it is validated then we can
     * fault so we catch that on return that the window is not
     * visible.  As soon as this API returns there is no guarentee
     * the return is still valid in a muli-tasking environment.
     */
    try {
        if (pwnd == NULL) {
            bRet = FALSE;
        } else {
            bRet = _IsWindowVisible(pwnd);
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        bRet = FALSE;
    }

    return bRet;
}


FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, IsZoomed, HWND, hwnd)
BOOL IsZoomed(
    HWND hwnd)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return FALSE;

    return _IsZoomed(pwnd);
}


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, ClientToScreen, HWND, hwnd, LPPOINT, ppoint)
BOOL ClientToScreen(
    HWND hwnd,
    LPPOINT ppoint)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return FALSE;

    _ClientToScreen(pwnd, ppoint);
    return TRUE;
}


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetClientRect, HWND, hwnd, LPRECT, prect)
BOOL GetClientRect(
    HWND   hwnd,
    LPRECT prect)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return FALSE;

    _GetClientRect(pwnd, prect);
    return TRUE;
}



FUNCLOG1(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetCursorPos, LPPOINT, lpPoint)
BOOL GetCursorPos(
    LPPOINT lpPoint)
{
    return  (BOOL)NtUserCallOneParam((ULONG_PTR)lpPoint, SFI_XXXGETCURSORPOS);
}


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, GetWindowRect, HWND, hwnd, LPRECT, prect)
BOOL GetWindowRect(
    HWND hwnd,
    LPRECT prect)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return FALSE;

    _GetWindowRect(pwnd, prect);
    return TRUE;
}


FUNCLOG2(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, ScreenToClient, HWND, hwnd, LPPOINT, ppoint)
BOOL ScreenToClient(
    HWND hwnd,
    LPPOINT ppoint)
{
    PWND pwnd;

    pwnd = ValidateHwnd(hwnd);

    if (pwnd == NULL)
        return FALSE;

    _ScreenToClient(pwnd, ppoint);
    return TRUE;
}


FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, EnableMenuItem, HMENU, hMenu, UINT, uIDEnableItem, UINT, uEnable)
BOOL EnableMenuItem(
    HMENU hMenu,
    UINT uIDEnableItem,
    UINT uEnable)
{
    PMENU pMenu;
    PITEM pItem;

    pMenu = VALIDATEHMENU(hMenu);
    if (pMenu == NULL) {
        return (BOOL)-1;
    }

    /*
     * Get a pointer the the menu item
     */
    if ((pItem = MNLookUpItem(pMenu, uIDEnableItem, (BOOL) (uEnable & MF_BYPOSITION), NULL)) == NULL)
        return (DWORD)-1;

    /*
     * If the item is already in the state we're
     * trying to set, just return.
     */
    if ((pItem->fState & MFS_GRAYED) ==
            (uEnable & MFS_GRAYED)) {
        return pItem->fState & MFS_GRAYED;
    }

    return NtUserEnableMenuItem(hMenu, uIDEnableItem, uEnable);
}

/***************************************************************************\
* CallNextHookEx
*
* This routine is called to call the next hook in the hook chain.
*
* 05-09-91 ScottLu Created.
\***************************************************************************/
FUNCLOG4(LOG_GENERAL, LRESULT, WINAPI, CallNextHookEx, HHOOK, hhk, int, nCode, WPARAM, wParam, LPARAM, lParam)
LRESULT WINAPI CallNextHookEx(
    HHOOK hhk,
    int nCode,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT nRet;
    BOOL  bAnsi;
    DWORD dwHookCurrent;
    PCLIENTINFO pci;
    ULONG_PTR dwHookData;
    ULONG_PTR dwFlags;

    DBG_UNREFERENCED_PARAMETER(hhk);

    ConnectIfNecessary(0);

    pci = GetClientInfo();
    dwHookCurrent = pci->dwHookCurrent;
    bAnsi = LOWORD(dwHookCurrent);

    /*
     * If this is the last hook in the hook chain then return 0; we're done
     */
    UserAssert(pci->phkCurrent);
    if (PhkNextValid((PHOOK)((KERNEL_ULONG_PTR)pci->phkCurrent - pci->ulClientDelta)) == NULL) {
        return 0;
    }

    switch ((INT)(SHORT)HIWORD(dwHookCurrent)) {
    case WH_CALLWNDPROC:
    case WH_CALLWNDPROCRET:
        /*
         * This is the hardest of the hooks because we need to thunk through
         * the message hooks in order to deal with synchronously sent messages
         * that point to structures - to get the structures passed across
         * alright, etc.
         *
         * This will call a special kernel-side routine that'll rebundle the
         * arguments and call the hook in the right format.
         *
         * Currently, the message thunk callbacks to the client-side don't take
         * enough parameters to pass wParam (which == fInterThread send msg).
         * To do this, save the state of wParam in the CLIENTINFO structure.
         */
        dwFlags = KERNEL_ULONG_PTR_TO_ULONG_PTR(pci->CI_flags) & CI_INTERTHREAD_HOOK;
        dwHookData = KERNEL_ULONG_PTR_TO_ULONG_PTR(pci->dwHookData);
        if (wParam) {
            pci->CI_flags |= CI_INTERTHREAD_HOOK;
        } else {
            pci->CI_flags &= ~CI_INTERTHREAD_HOOK;
        }

        if ((INT)(SHORT)HIWORD(dwHookCurrent) == WH_CALLWNDPROC) {
            nRet = CsSendMessage(
                    ((LPCWPSTRUCT)lParam)->hwnd,
                    ((LPCWPSTRUCT)lParam)->message,
                    ((LPCWPSTRUCT)lParam)->wParam,
                    ((LPCWPSTRUCT)lParam)->lParam,
                    0, FNID_HKINLPCWPEXSTRUCT, bAnsi);
        } else {
            pci->dwHookData = ((LPCWPRETSTRUCT)lParam)->lResult;
            nRet = CsSendMessage(
                    ((LPCWPRETSTRUCT)lParam)->hwnd,
                    ((LPCWPRETSTRUCT)lParam)->message,
                    ((LPCWPRETSTRUCT)lParam)->wParam,
                    ((LPCWPRETSTRUCT)lParam)->lParam,
                    0, FNID_HKINLPCWPRETEXSTRUCT, bAnsi);
        }

        /*
         * Restore previous hook state.
         */
        pci->CI_flags ^= ((pci->CI_flags ^ dwFlags) & CI_INTERTHREAD_HOOK);
        pci->dwHookData = dwHookData;
        break;

    default:
        nRet = NtUserCallNextHookEx(
                nCode,
                wParam,
                lParam,
                bAnsi);
    }

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\wow6432\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\wstrings.c ===
/****************************** Module Header ******************************\
* Module Name: wstrings.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 03-20-91 IanJa      Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/* LATER these should be in a public header file!!!
 * Assorted defines used to support the standard Windows ANSI code page
 * (now known as code page 1252 and officially registered by IBM).
 * This is intended only for the PDK release.  Subsequent releases will
 * use the NLSAPI and Unicode.
 */
#define LATIN_CAPITAL_LETTER_A_GRAVE    (WCHAR)0xc0
#define LATIN_CAPITAL_LETTER_THORN      (WCHAR)0xde
#define LATIN_SMALL_LETTER_SHARP_S      (WCHAR)0xdf
#define LATIN_SMALL_LETTER_Y_DIAERESIS  (WCHAR)0xff
#define DIVISION_SIGN                   (WCHAR)0xf7
#define MULTIPLICATION_SIGN             (WCHAR)0xd7


/*
 * Temporary defines to support Unicode block 1 (0x0000 - 0x00ff).
 */
#define WCTOA(wch)  ((wch) & 0xff)
#define IS_UNICODE_BLK1(wch)  ((int)(wch) <= 0x00ff)


/***************************************************************************\
* CharLowerW (API)
*
* Convert either a single character or an entire string to lower case.  The
* two cases are differentiated by checking the high-word of pwsz.  If it is
* 0 then we just convert the low-word of pwsz.
*
* History:
* 06-24-91 GregoryW     Created.  Supports Unicode equivalent of code
*                       page 1252 (simple zero extension).  This is for
*                       the PDK release only.  After the PDK this routine
*                       will be modified to use the NLSAPI.
* 02-11-93 IanJa        Modified to use NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, LPWSTR, WINAPI, CharLowerW, LPWSTR, pwsz)
LPWSTR WINAPI CharLowerW(
    LPWSTR pwsz)
{
    /*
     * Early out for NULL string or '\0'
     */
    if (pwsz == NULL) {
        return pwsz;
    }

    if (!IS_PTR(pwsz)) {
        if (!LCMapStringW(
                 LOCALE_USER_DEFAULT,
                 LCMAP_LOWERCASE,
                 (LPWSTR)&pwsz,
                 1,
                 (LPWSTR)&pwsz,
                 1
                 )) {
            /*
             * We don't expect LCMapString to fail!  The caller is not expecting
             * failure, CharLowerW does not have a failure indicator, so we do
             * nothing.
             */
            RIPMSG1(RIP_WARNING, "CharLowerW(%#p): LCMapString failed\n", pwsz);
        }

        return pwsz;
    }

    /*
     * pwsz is a null-terminated string
     */
    CharLowerBuffW(pwsz, wcslen(pwsz)+1);
    return pwsz;
}


/***************************************************************************\
* CharUpperW (API)
*
* Convert either a single character or an entire string to upper case.  The
* two cases are differentiated by checking the high-word of pwsz.  If it is
* 0 then we just convert the low-word of pwsz.
*
* History:
* 06-24-91 GregoryW     Created.  Supports Unicode equivalent of code
*                       page 1252 (simple zero extension).  This is for
*                       the PDK release only.  After the PDK this routine
*                       will be modified to use the NLSAPI.
* 02-11-93 IanJa        Modified to use NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, LPWSTR, WINAPI, CharUpperW, LPWSTR, pwsz)
LPWSTR WINAPI CharUpperW(
    LPWSTR pwsz)
{
    /*
     * Early out for NULL string or '\0'
     */
    if (pwsz == NULL) {
        return pwsz;
    }

    if (!IS_PTR(pwsz)) {
        if (!LCMapStringW(
                 LOCALE_USER_DEFAULT,
                 LCMAP_UPPERCASE,
                 (LPWSTR)&pwsz,
                 1,
                 (LPWSTR)&pwsz,
                 1
                 )) {
            /*
             * We don't expect LCMapString to fail!  The caller is not expecting
             * failure, CharLowerW does not have a failure indicator, so we do
             * nothing.
             */
            RIPMSG1(RIP_WARNING, "CharUpperW(%#p): LCMapString failed", pwsz);
        }

        return pwsz;
    }

    /*
     * pwsz is a null-terminated string
     */
    CharUpperBuffW(pwsz, wcslen(pwsz)+1);
    return pwsz;
}


/***************************************************************************\
* CharNextW (API)
*
* Move to next character in string unless already at '\0' terminator
*
* History:
* 06-24-91 GregoryW     Created.  This routine will not work for non-spacing
*                       characters!!  This version is only intended for
*                       limited use in the PDK release.
* 02-20-92 GregoryW     Modified to work with combining marks (formerly known
*                       as non-spacing).
* 09-21-93 JulieB       Added ALPHA to combining mark code.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, LPWSTR, WINAPI, CharNextW, LPCWSTR, lpwCurrentChar)
LPWSTR WINAPI CharNextW(
    LPCWSTR lpwCurrentChar)
{
    WORD ctype3info;

    if (*lpwCurrentChar) {
        //
        // Examine each code element.  Skip all combining elements.
        //
        while (*(++lpwCurrentChar)) {
            if (!GetStringTypeW(
                    CT_CTYPE3,
                    lpwCurrentChar,
                    1,
                    &ctype3info)) {
                /*
                 * GetStringTypeW failed!  The caller is not expecting failure,
                 * CharNextW does not have a failure indicator, so just return
                 * a pointer to the character we couldn't analyze.
                 */
                RIPMSG2(RIP_WARNING, "CharNextW failed, L'\\x%.4x' at %#p",
                        *lpwCurrentChar, lpwCurrentChar);
                break;
            }
            if (!((ctype3info & C3_NONSPACING) && (!(ctype3info & C3_ALPHA)))) {
                break;
            }
        }
    }

    return (LPWSTR)lpwCurrentChar;
}


/***************************************************************************\
* CharPrevW (API)
*
* Move to previous character in string, unless already at start
*
* History:
* 06-24-91 GregoryW     Created.  This routine will not work for non-spacing
*                       characters!!  This version is only intended for
*                       limited use in the PDK release.
* 02-20-92 GregoryW     Modified to work with combining marks (formerly
*                       known as non-spacing).
* 09-21-93 JulieB       Added ALPHA to combining mark code.
* 12-06-93 JulieB       Fixed combining mark code.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, LPWSTR, WINAPI, CharPrevW, LPCWSTR, lpwStart, LPCWSTR, lpwCurrentChar)
LPWSTR WINAPI CharPrevW(
    LPCWSTR lpwStart,
    LPCWSTR lpwCurrentChar)
{
    WORD ctype3info;
    LPWSTR lpwValidChar = (LPWSTR)lpwCurrentChar;


    if (lpwCurrentChar > lpwStart) {
        //
        // Examine each code element.  Skip all combining elements.
        //
        while (lpwCurrentChar-- > lpwStart) {
            if (!GetStringTypeW(
                    CT_CTYPE3,
                    lpwCurrentChar,
                    1,
                    &ctype3info)) {
                /*
                 * GetStringTypeW failed!  The caller is not expecting failure,
                 * CharPrevW does not have a failure indicator, so just return
                 * a pointer to the character we couldn't analyze.
                 */
                RIPMSG2(RIP_WARNING, "CharPrevW failed, L'\\x%.4x' at %#p",
                        *lpwCurrentChar, lpwCurrentChar);
                break;
            }
            if (!((ctype3info & C3_NONSPACING) && (!(ctype3info & C3_ALPHA)))) {
                lpwValidChar = (LPWSTR)lpwCurrentChar;
                break;  // found non-combining code element
            }
        }

        /*
         * We need to always go back one character. If we've looped through
         * the entire buffer and haven't found a "legitimate" character, just
         * step back. See bug #27649.
         */
        if(lpwCurrentChar < lpwStart){
            --lpwValidChar;
            UserAssert(lpwValidChar >= lpwStart);
        }
    }

    return (LPWSTR)lpwValidChar;
}


/***************************************************************************\
* CharLowerBuffW (API)
*
* History:
* 06-24-91 GregoryW     Created.  This version only supports Unicode
*                       block 1 (0x0000 - 0x00ff).  All other code points
*                       are copied verbatim.  This version is intended
*                       only for the PDK release.
* 02-11-93 IanJa        Modified to use NLS API.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, DWORD, WINAPI, CharLowerBuffW, LPWSTR, pwsz, DWORD, cwch)
DWORD WINAPI CharLowerBuffW(
    LPWSTR pwsz,
    DWORD cwch)
{
    int cwchT;
    DWORD i;

    if (cwch == 0) {
        return 0;
    }

    cwchT = LCMapStringW(LOCALE_USER_DEFAULT, LCMAP_LOWERCASE,
                pwsz, cwch, pwsz, cwch);

    if (cwchT != 0) {
        return cwchT;
    }

    /*
     * LCMapString failed!  The caller is not expecting failure,
     * CharLowerBuffW does not have a failure indicator, so we
     * convert the buffer to lower case as best we can.
     */
    RIPMSG1(RIP_WARNING, "CharLowerBuffW(%ls) failed", pwsz);

    for (i=0; i < cwch; i++) {
        if (IS_UNICODE_BLK1(pwsz[i]) && IsCharUpperA((char)pwsz[i])) {
            pwsz[i] += 'a'-'A';
        }
    }

    return cwch;
}


/***************************************************************************\
* CharUpperBuffW (API)
*
* History:
* 06-24-91 GregoryW     Created.  This version only supports Unicode
*                       block 1 (0x0000 - 0x00ff).  All other code points
*                       are copied verbatim.  This version is intended
*                       only for the PDK release.
* 02-11-93 IanJa        Modified to use NLS API.
\***************************************************************************/


FUNCLOG2(LOG_GENERAL, DWORD, WINAPI, CharUpperBuffW, LPWSTR, pwsz, DWORD, cwch)
DWORD WINAPI CharUpperBuffW(
    LPWSTR pwsz,
    DWORD cwch)
{
    int cwchT;
    DWORD i;

    if (cwch == 0) {
        return 0;
    }

    cwchT = LCMapStringW(LOCALE_USER_DEFAULT, LCMAP_UPPERCASE,
                pwsz, cwch, pwsz, cwch);

    if (cwchT != 0) {
        return cwchT;
    }

    /*
     * LCMapString failed!  The caller is not expecting failure,
     * CharUpperBuffW does not have a failure indicator, so we
     * convert the buffer to upper case as best we can.
     */
    RIPMSG1(RIP_WARNING, "CharUpperBuffW(%ls) failed", pwsz);

    for (i=0; i < cwch; i++) {
        if (IS_UNICODE_BLK1(pwsz[i]) &&
                IsCharLowerA((char)pwsz[i]) &&
                (pwsz[i] != LATIN_SMALL_LETTER_SHARP_S) &&
                (pwsz[i] != LATIN_SMALL_LETTER_Y_DIAERESIS)) {
            pwsz[i] += (WCHAR)('A'-'a');
        }
    }

    return cwch;
}



/***************************************************************************\
* IsCharLowerW (API)
*
* History:
* 06-24-91 GregoryW     Created.  This version only supports Unicode
*                       block 1 (0x0000 - 0x00ff).  FALSE is returned
*                       for all other code points. This version is intended
*                       only for the PDK release.
* 02-20-92 GregoryW     Modified to use NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IsCharLowerW, WCHAR, wChar)
BOOL WINAPI IsCharLowerW(
    WCHAR wChar)
{
    WORD ctype1info;

    if (GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info)) {
        if (ctype1info & C1_LOWER) {
            return TRUE;
        } else {
            return FALSE;
        }
    }

    /*
     * GetStringTypeW failed!  The caller is not expecting
     * failure, IsCharLowerW does not have a failure indicator, so we
     * determine the case as best we can.
     */
    RIPMSG1(RIP_WARNING, "IsCharLowerW(L'\\x%.4lx') failed", wChar);

    if (IS_UNICODE_BLK1(wChar)) {
        return IsCharLowerA((CHAR)wChar);
    } else {
        return FALSE;
    }
}


/***************************************************************************\
* IsCharUpperW (API)
*
* History:
* 06-24-91 GregoryW     Created.  This version only supports Unicode
*                       block 1 (0x0000 - 0x00ff).  FALSE is returned
*                       for all other code points. This version is intended
*                       only for the PDK release.
* 02-20-92 GregoryW     Modified to use NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IsCharUpperW, WCHAR, wChar)
BOOL WINAPI IsCharUpperW(
    WCHAR wChar)
{
    WORD ctype1info;

    if (GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info)) {
        if (ctype1info & C1_UPPER) {
            return TRUE;
        } else {
            return FALSE;
        }
    }

    /*
     * GetStringTypeW failed!  The caller is not expecting
     * failure, IsCharLowerW does not have a failure indicator, so we
     * determine the case as best we can.
     */
    RIPMSG1(RIP_WARNING, "IsCharUpper(L'\\x%.4lx') failed", wChar);

    if (IS_UNICODE_BLK1(wChar)) {
        return IsCharUpperA((CHAR)wChar);
    } else {
        return FALSE;
    }
}


/***************************************************************************\
* IsCharAlphaNumericW (API)
*
* Returns TRUE if character is alphabetical or numerical, otherwise FALSE
*
* History:
* 06-24-91 GregoryW     Created.  This version only supports Unicode
*                       block 1 (0x0000 - 0x00ff).
*                       This version is intended only for the PDK release.
* 02-20-92 GregoryW     Modified to use NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IsCharAlphaNumericW, WCHAR, wChar)
BOOL WINAPI IsCharAlphaNumericW(
    WCHAR wChar)
{
    WORD ctype1info;

    if (!GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info)) {
        //
        // GetStringTypeW returned an error!  IsCharAlphaNumericW has no
        // provision for returning an error...  The best we can do is to
        // return FALSE
        //
        UserAssert(FALSE);
        return FALSE;
    }
    //
    // LATER 20 Feb 92 GregoryW
    //    We may need to check ctype 3 info if we want to check for
    //    digits other than ASCII '0'-'9' (such as Lao digits or
    //    Tibetan digits, etc.).
    //
#ifdef FE_SB // IsCharAlphaNumericW()
    if (ctype1info & C1_ALPHA) {
        WORD ctype3info = 0;
        /*
         * We don't want to return TRUE for halfwidth katakana.
         * Katakana is linguistic character (C1_ALPHA), but it is not
         * alphabet character.
         */
        if (!GetStringTypeW(CT_CTYPE3, &wChar, 1, &ctype3info)) {
            UserAssert(FALSE);
            /*
             * Assume, it is alphabet character, because it has
             * C1_ALPHA attribute.
             */
            return TRUE;
        }

        if (ctype3info & (C3_KATAKANA|C3_HIRAGANA)) {
            /*
             * This is 'Katakana'.
             */
            return FALSE;
        } else {
            return TRUE;
        }
    } else if (ctype1info & C1_DIGIT) {
        return TRUE;
    } else {
        return FALSE;
    }
#else
    if ((ctype1info & C1_ALPHA) || (ctype1info & C1_DIGIT)) {
        return TRUE;
    } else {
        return FALSE;
    }
#endif // FE_SB
}


/***************************************************************************\
* IsCharAlphaW (API)
*
* Returns TRUE if character is alphabetical, otherwise FALSE
*
* History:
* 06-24-91 GregoryW     Created.  This version only supports Unicode
*                       block 1 (0x0000 - 0x00ff).
*                       This version is intended only for the PDK release.
* 02-20-92 GregoryW     Modified to use NLS API.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, BOOL, WINAPI, IsCharAlphaW, WCHAR, wChar)
BOOL WINAPI IsCharAlphaW(
    WCHAR wChar)
{
    WORD ctype1info;

    if (!GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info)) {
        //
        // GetStringTypeW returned an error!  IsCharAlphaW has no
        // provision for returning an error...  The best we can do
        // is to return FALSE
        //
        UserAssert(FALSE);
        return FALSE;
    }
    if (ctype1info & C1_ALPHA) {
#ifdef FE_SB // IsCharAlphaA()
        WORD ctype3info = 0;
        /*
         * We don't want to return TRUE for halfwidth katakana.
         * Katakana is linguistic character (C1_ALPHA), but it is not
         * alphabet character.
         */
        if (!GetStringTypeW(CT_CTYPE3, &wChar, 1, &ctype3info)) {
            UserAssert(FALSE);
            /*
             * Assume, it is alphabet character, because it has
             * C1_ALPHA attribute.
             */
            return TRUE;
        }

        if (ctype3info & (C3_KATAKANA|C3_HIRAGANA)) {
            /*
             * This is 'Katakana'.
             */
            return FALSE;
        } else {
            return TRUE;
        }
#else
        return TRUE;
#endif // FE_SB
    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\i386\callret.asm ===
title  "User Callback Return"
;++
;
; Copyright (c) 1985 - 1999, Microsoft Corporation
;
; Module Name:
;
;    callret.asm
;
; Abstract:
;
;    This module implements the fastpath callback return.
;
; Author:
;
;    David N. Cutler (davec) 21-Dec-95
;
; Environment:
;
;    User mode.
;
; Revision History:
;
;--

.386p
        .xlist
include callconv.inc            ; calling convention macros
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Return from User Mode Callback"

ifndef BUILD_WOW6432
;++
;
; NTSTATUS
; FASTCALL
; XyCallbackReturn (
;    IN PVOID OutputBuffer OPTIONAL,
;    IN ULONG OutputLength,
;    IN NTSTATUS Status
;    )
;
; Routine Description:
;
;    This function returns from a user mode callout to the kernel mode
;    caller of the user mode callback function.
;
; Arguments:
;
;    OutputBuffer (ecx) - Supplies an optional pointer to an output buffer.
;
;    OutputLength (edx) - Supplies the length of the output buffer.
;
;    Status (esp + 4) - Supplies the status value returned to the caller of the
;        callback function.
;
; Return Value:
;
;    Normally there is no return from this function. If a callbac is not active,
;    then the error status is returned to the caller.
;
;--

cPublicFastCall XyCallbackReturn, 3

        mov     eax,[esp] + 4           ; get return status value
        int     02bH                    ; call fast path system service
        fstRET  XyCallbackReturn        ; return status to caller

fstENDP XyCallbackReturn
endif

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\i386\callproc.asm ===
title   "Callback Routines"
;++
;
;  Copyright (c) 1985 - 1999, Microsoft Corporation
;
;  Module Name:
;
;     callproc.asm
;
;  Abstract:
;
;     This module implements stack cleanup to gaurd against cdecl
;     declared wndprocs.
;     Bug 234292
;
;  Author:
;
;     Joseph Jones (joejo) 12/4/98
;
;
;  Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132


;++
;
;LRESULT
;InternalCallWinProc(
;    WNDPROC winproc,
;    HWND hwnd,
;    UINT message,
;    WPARAM wParam,
;    LPARAM lParam
;    )
;
; Routine Description:
;
;    this function cals an x86 window procedure. It protects against
;    window procedures that don't preserve EBX or fail to clean up
;    enough stack.
;
;    The only register that the window proc cannot trash is ESI.
;
; Arguments:
;
;    winproc - x86 Procedure to call
;
;    hwnd - window handle that sent the message
;
;    message - message being sent
;
;    wParam - wParam argument to window procedure
;
;    lParam - lParam argument to window proc
;
; Return Value:
;
;    LRESULT return value from called window procedure
;
;--

cPublicProc _InternalCallWinProc , 5

winproc         equ [ebp + 8]
hwnd            equ [ebp + 12]
message         equ [ebp + 16]
wParam          equ [ebp + 20]
lParam          equ [ebp + 24]

StackGuard      equ 0DCBAABCDh

        push    ebp
        mov     ebp, esp

        push    esi
        push    edi
        push    ebx

        push    StackGuard  ; push guard on the stack
        push    esi         ; push another DWORD on the stack
                            ; so that bogus apps that treat &lParam
                            ; as an LPPOINT don't corrupt the StackGuard

        push    lParam
        push    wParam
        push    message
        push    hwnd
        call    winproc

        cmp     DWORD PTR [esp+4], StackGuard
        je      goodCalling

;--
;       Bug 386625: fix for Corel Presentation 9.0 that restores the stack
;                   for 5 parameters instead of 4
;--

        cmp     DWORD PTR [esp], StackGuard
        jne     fixupTheStack
        sub     esp, 04h
        jmp     goodCalling

fixupTheStack:
        add     esp, 010h   ; fix up the stack

goodCalling:
        add     esp, 08h    ; pop the extra DWORD
                            ; pop the second StackGuard

        pop     ebx
        pop     edi
        pop     esi

        pop     ebp
        stdRET  _InternalCallWinProc
stdENDP _InternalCallWinProc


;/*
; * Bug 246472 - joejo
; * fixup all DDE Callbacks since some apps make their callbacks
; * C-Style instead of PASCAL.
; */

;++
;
;HDDEDATA
;UserCallDDECallback(
;    UINT wType,
;    UINT wFmt,
;    HCONV hConv,
;    HSZ hsz1,
;    HSZ hsz2,
;    HDDEDATA hData,
;    ULONG_PTR dwData1,
;    ULONG_PTR dwData2
;    )
;
; Routine Description:
;
;    this function cals an x86 DDE Callback procedure. It protects against
;    callback procedures that don't preserve EBX or fail to clean up
;    enough stack.
;
;    The only register that the window proc cannot trash is ESI.
;
; Arguments:
;
;       pfnDDECallback - DDE Callback function pointer
;       wType
;       wFmt
;       hConv
;       hsz1
;       hsz2
;       hData
;       dwData1
;       dwData2
;
; Return Value:
;
;    HDDEDATA   - Handle to a returnded DDE Data object
;
;--

cPublicProc _UserCallDDECallback , 9

pfnDDECallback  equ [ebp + 8]
wType           equ [ebp + 12]
wFmt            equ [ebp + 16]
hConv           equ [ebp + 20]
hsz1            equ [ebp + 24]
hsz2            equ [ebp + 28]
hData           equ [ebp + 32]
dwData1         equ [ebp + 36]
dwData2         equ [ebp + 40]


        push    ebp
        mov     ebp, esp
        push    esi         ; save esi across the call
        push    edi         ; save edi across the call
        push    ebx         ; save ebx on the stack across the call
        mov     esi,esp     ; save the stack pointer in esi across the call
        push    dwData2
        push    dwData1
        push    hData
        push    hsz2
        push    hsz1
        push    hConv
        push    wFmt
        push    wType
        call    pfnDDECallback
        mov     esp,esi     ; restore the stack pointer in case callee forgot to clean up
        pop     ebx         ; restore ebx
        pop     edi         ; restore edi
        pop     esi         ; restore esi
        pop     ebp
        stdRET  _UserCallDDECallback
stdENDP _UserCallDDECallback



_TEXT   ends


        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\xact.c ===
/****************************** Module Header ******************************\
* Module Name: xact.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager transaction processing module
*
* Created: 11/3/91 Sanford Staab
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* DdeClientTransaction (DDEML API)
*
* Description:
* Initiates all DDE transactions.
*
* History:
* 11-1-91 sanfords Created.
\***************************************************************************/

FUNCLOG8(LOG_GENERAL, HDDEDATA, DUMMYCALLINGTYPE, DdeClientTransaction, LPBYTE, pData, DWORD, cbData, HCONV, hConv, HSZ, hszItem, UINT, wFmt, UINT, wType, DWORD, ulTimeout, LPDWORD, pulResult)
HDDEDATA DdeClientTransaction(
LPBYTE pData,
DWORD cbData,
HCONV hConv,
HSZ hszItem,
UINT wFmt,
UINT wType,
DWORD ulTimeout,
LPDWORD pulResult)
{
    MSG msg;
    PCL_INSTANCE_INFO pcii = NULL;
    HDDEDATA hRet = 0;
    PCL_CONV_INFO pci;
    PDDEMLDATA pdd = NULL;
    PXACT_INFO pxi;
    BOOL fStarted;
    PDDE_DATA pdde;

    EnterDDECrit;

    pci = (PCL_CONV_INFO)ValidateCHandle((HANDLE)hConv,
            HTYPE_CLIENT_CONVERSATION, HINST_ANY);
    if (pci == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    pcii = pci->ci.pcii;
    if (ulTimeout != TIMEOUT_ASYNC && GetClientInfo()->CI_flags & CI_IN_SYNC_TRANSACTION) {
        SetLastDDEMLError(pcii, DMLERR_REENTRANCY);
        goto Exit;
    }
    if (!(pci->ci.state & ST_CONNECTED)) {
        SetLastDDEMLError(pcii, DMLERR_NO_CONV_ESTABLISHED);
        goto Exit;
    }

    switch (wType) {
    case XTYP_POKE:
    case XTYP_ADVSTART:
    case XTYP_ADVSTART | XTYPF_NODATA:
    case XTYP_ADVSTART | XTYPF_ACKREQ:
    case XTYP_ADVSTART | XTYPF_NODATA | XTYPF_ACKREQ:
    case XTYP_REQUEST:
    case XTYP_ADVSTOP:
        if (hszItem == 0) {
            SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
            goto Exit;
        }
        break;

    case XTYP_EXECUTE: // just ignore wFmt & hszItem
        break;

    default:
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    pxi = DDEMLAlloc(sizeof(XACT_INFO));
    if (pxi == NULL) {
        SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
        goto Exit;
    }

    switch (wType) {
    case XTYP_EXECUTE:
    case XTYP_POKE:
        if ((LONG)cbData == -1L) {

            // We are accepting an existing data handle for export to another
            // app.

            pdd = (PDDEMLDATA)ValidateCHandle((HANDLE)pData,
                    HTYPE_DATA_HANDLE, HINST_ANY);
            if (pdd == NULL) {
InvParam:
                SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
                DDEMLFree(pxi);
                goto Exit;
            }

            // make sure data handle holds apropriate data for this transaction

            if ((pdd->flags & HDATA_EXECUTE && wType != XTYP_EXECUTE) ||
                    (!(pdd->flags & HDATA_EXECUTE) && wType == XTYP_EXECUTE)) {
                goto InvParam;
            }

            // To simplify life, use a copy if this handle is potentially
            // a relay or APPOWNED handle.

            if (pdd->flags & (HDATA_APPOWNED | HDATA_NOAPPFREE)) {
                pxi->hDDESent = CopyDDEData(pdd->hDDE, wType == XTYP_EXECUTE);
                if (!pxi->hDDESent) {
MemErr:
                    DDEMLFree(pxi);
                    SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
                    goto Exit;
                }
                USERGLOBALLOCK(pxi->hDDESent, pdde);
                if (pdde == NULL) {
                    FreeDDEData(pxi->hDDESent, TRUE, TRUE);
                    goto MemErr;
                }
                pdde->wStatus = DDE_FRELEASE;
                USERGLOBALUNLOCK(pxi->hDDESent);
            } else {
                pxi->hDDESent = pdd->hDDE;
            }

            // make sure handle has proper format

            if (wType == XTYP_POKE) {
                USERGLOBALLOCK(pxi->hDDESent, pdde);
                if (pdde == NULL) {
                    goto InvParam;
                }
                pdde->wFmt = (WORD)wFmt;
                USERGLOBALUNLOCK(pxi->hDDESent);
            }

        } else {  // Convert data in buffer into an apropriate hDDE

            if (wType == XTYP_POKE) {
                pxi->hDDESent = AllocAndSetDDEData(pData, cbData,
                        DDE_FRELEASE, (WORD)wFmt);
            } else {
                pxi->hDDESent = AllocAndSetDDEData(pData, cbData, 0, 0);
            }
            if (!pxi->hDDESent) {
                goto MemErr;
            }
        }
    }

    // FINALLY - start the transaction

    pxi->pcoi = (PCONV_INFO)pci;
    pxi->gaItem = LocalToGlobalAtom(LATOM_FROM_HSZ(hszItem)); // pxi copy
    pxi->wFmt = (WORD)wFmt;
    pxi->wType = (WORD)wType;

    switch (wType) {
    case XTYP_ADVSTART:
    case XTYP_ADVSTART | XTYPF_NODATA:
    case XTYP_ADVSTART | XTYPF_ACKREQ:
    case XTYP_ADVSTART | XTYPF_NODATA | XTYPF_ACKREQ:
        fStarted = ClStartAdvise(pxi);
        break;

    case XTYP_ADVSTOP:
        fStarted = ClStartUnadvise(pxi);
        break;

    case XTYP_EXECUTE:
        fStarted = ClStartExecute(pxi);
        break;

    case XTYP_POKE:
        fStarted = ClStartPoke(pxi);
        break;

    case XTYP_REQUEST:
        fStarted = ClStartRequest(pxi);
    }

    if (!fStarted) {
        // if we copied or allocated data - free it.
        if (pxi->hDDESent && (pdd == NULL || pxi->hDDESent != pdd->hDDE)) {
            FreeDDEData(pxi->hDDESent, FALSE, TRUE);     // free data copy
        }
        GlobalDeleteAtom(pxi->gaItem); // pxi copy
        DDEMLFree(pxi);
        goto Exit;
    }

    if (pdd != NULL && !(pdd->flags & (HDATA_NOAPPFREE | HDATA_APPOWNED))) {

        // invalidate given handle on success - unless we copied it because
        // the app will either be return ing it from a callback or potentially
        // using it again.

        DDEMLFree(pdd);
        DestroyHandle((HANDLE)pData);
    }

    if (ulTimeout == TIMEOUT_ASYNC) {

        // asynchronous transaction

        if (pulResult != NULL) {
            pxi->hXact = CreateHandle((ULONG_PTR)pxi, HTYPE_TRANSACTION,
                    InstFromHandle(pcii->hInstClient));
            *pulResult = HandleToUlong(pxi->hXact);
        }
        hRet = (HDDEDATA)TRUE;

    } else {

        // synchronous transaction

        GetClientInfo()->CI_flags |= CI_IN_SYNC_TRANSACTION;
        pcii->flags |= IIF_IN_SYNC_XACT;

        pxi->flags |= XIF_SYNCHRONOUS;
        NtUserSetTimer(pci->ci.hwndConv, TID_TIMEOUT, ulTimeout, NULL);

        LeaveDDECrit;
        CheckDDECritOut;

        GetMessage(&msg, (HWND)NULL, 0, 0);

        /*
         * stay in modal loop until a timeout happens.
         */
        while (msg.hwnd != pci->ci.hwndConv || msg.message != WM_TIMER ||
            (msg.wParam != TID_TIMEOUT)) {

            if (!CallMsgFilter(&msg, MSGF_DDEMGR))
                DispatchMessage(&msg);

            GetMessage(&msg, (HWND)NULL, 0, 0);
        }

        EnterDDECrit;

        NtUserKillTimer(pci->ci.hwndConv, TID_TIMEOUT);
        GetClientInfo()->CI_flags &= ~CI_IN_SYNC_TRANSACTION;
        pcii->flags &= ~IIF_IN_SYNC_XACT;

        if (pxi->flags & XIF_COMPLETE) {
            if (pulResult != NULL) {
                *pulResult = pxi->wStatus; // NACK status bits
            }
            switch (wType) {
            case XTYP_ADVSTART:
            case XTYP_ADVSTART | XTYPF_NODATA:
            case XTYP_ADVSTART | XTYPF_ACKREQ:
            case XTYP_ADVSTART | XTYPF_NODATA | XTYPF_ACKREQ:
            case XTYP_ADVSTOP:
            case XTYP_EXECUTE:
            case XTYP_POKE:
                hRet = (HDDEDATA)((ULONG_PTR)((pxi->wStatus & DDE_FACK) ? TRUE : FALSE));
                if (!hRet) {
                    if (pxi->wStatus & DDE_FBUSY) {
                        SetLastDDEMLError(pcii, DMLERR_BUSY);
                    } else {
                        SetLastDDEMLError(pcii, DMLERR_NOTPROCESSED);
                    }
                }
                break;

            case XTYP_REQUEST:
                if (pxi->hDDEResult == 0) {
                    hRet = (HDDEDATA)((ULONG_PTR)((pxi->wStatus & DDE_FACK) ? TRUE : FALSE));
                    if (!hRet) {
                        if (pxi->wStatus & DDE_FBUSY) {
                            SetLastDDEMLError(pcii, DMLERR_BUSY);
                        } else {
                            SetLastDDEMLError(pcii, DMLERR_NOTPROCESSED);
                        }
                    }
                    break;
                }
                // Note that if the incoming data didn't have the DDE_FRELEASE
                // bit set, the transaction code would have made a copy so
                // the app is free to keep is as long as he likes.

                hRet = InternalCreateDataHandle(pcii, (LPBYTE)pxi->hDDEResult, (DWORD)-1, 0,
                        HDATA_READONLY, 0, 0);
                pxi->hDDEResult = 0; // so cleanup doesn't free it.
            }

            (pxi->pfnResponse)((struct tagXACT_INFO *)pxi, 0, 0); // cleanup transaction

        } else {    // Timed out

            // abandon the transaction and make it asyncronous so it will
            // clean itself up when the response finally comes in.

            pxi->flags &= ~XIF_SYNCHRONOUS;
            pxi->flags |= XIF_ABANDONED;

            switch (wType) {
            case XTYP_ADVSTART:
            case XTYP_ADVSTART | XTYPF_NODATA:
            case XTYP_ADVSTART | XTYPF_ACKREQ:
            case XTYP_ADVSTART | XTYPF_NODATA | XTYPF_ACKREQ:
                SetLastDDEMLError(pcii, DMLERR_ADVACKTIMEOUT);
                break;
            case XTYP_ADVSTOP:
                SetLastDDEMLError(pcii, DMLERR_UNADVACKTIMEOUT);
                break;
            case XTYP_EXECUTE:
                SetLastDDEMLError(pcii, DMLERR_EXECACKTIMEOUT);
                break;
            case XTYP_POKE:
                SetLastDDEMLError(pcii, DMLERR_POKEACKTIMEOUT);
                break;
            case XTYP_REQUEST:
                SetLastDDEMLError(pcii, DMLERR_DATAACKTIMEOUT);
                break;
            }
            // cleanup of pxi happens when transaction actually completes.
        }
    }
    if (pci->ci.state & ST_FREE_CONV_RES_NOW) {
        /*
         * The conversation was terminated during the synchronous transaction
         * so we need to clean up now that we are out of the loop.
         */
         FreeConversationResources((PCONV_INFO)pci);
    }

Exit:
    /*
     * Because this API is capable of blocking DdeUninitialize(), we check
     * before exit to see if it needs to be called.
     */
    if (pcii != NULL &&
            (pcii->afCmd & APPCMD_UNINIT_ASAP) &&
            // !(pcii->flags & IIF_IN_SYNC_XACT) &&
            !pcii->cInDDEMLCallback) {
        DdeUninitialize(HandleToUlong(pcii->hInstClient));
        hRet = 0;
    }
    LeaveDDECrit;
    return (hRet);
}




/***************************************************************************\
* GetConvContext
*
* Description:
* Retrieves conversation context information from the DDEML client window
* given. pl points to a CONVCONTEXT structure.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
VOID GetConvContext(
HWND hwnd,
LONG *pl)
{
    int i;

    for (i = 0; i < sizeof(CONVCONTEXT); i += 4) {
        *pl++ = GetWindowLong(hwnd, GWL_CONVCONTEXT + i);
    }
}

/***************************************************************************\
* SetConvContext
*
* Description:
*
* History:
* 11-19-92 sanfords Created.
\***************************************************************************/
VOID SetConvContext(
HWND hwnd,
LONG *pl)
{
    int i;

    for (i = 0; i < sizeof(CONVCONTEXT); i += 4) {
        SetWindowLong(hwnd, GWL_CONVCONTEXT + i, *pl++);
    }
}




/***************************************************************************\
* DdeQueryConvInfo (DDEML API)
*
* Description:
* Retrieves detailed conversation information on a per conversation/
* transaction basis.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, UINT, DUMMYCALLINGTYPE, DdeQueryConvInfo, HCONV, hConv, DWORD, idTransaction, PCONVINFO, pConvInfo)
UINT DdeQueryConvInfo(
HCONV hConv,
DWORD idTransaction,
PCONVINFO pConvInfo)
{
    PCONV_INFO pcoi;
    PXACT_INFO pxi;
    CONVINFO ci;
    UINT uiRet = 0;

    EnterDDECrit;

    if (!ValidateTransaction(hConv, (HANDLE)LongToHandle( idTransaction ), &pcoi, &pxi)) {
        goto Exit;
    }

    try {
        if (pConvInfo->cb > sizeof(CONVINFO)) {
            SetLastDDEMLError(pcoi->pcii, DMLERR_INVALIDPARAMETER);
            goto Exit;
        }
        ci.cb = pConvInfo->cb;
        ci.hConvPartner = 0; // no longer supported.
        ci.hszSvcPartner = NORMAL_HSZ_FROM_LATOM(pcoi->laService);
        ci.hszServiceReq = NORMAL_HSZ_FROM_LATOM(pcoi->laServiceRequested);
        ci.hszTopic = NORMAL_HSZ_FROM_LATOM(pcoi->laTopic);
        ci.wStatus = pcoi->state;
        ci.wLastError = (WORD)pcoi->pcii->LastError;
        if (pcoi->state & ST_CLIENT) {
            ci.hConvList = ((PCL_CONV_INFO)pcoi)->hConvList;
            GetConvContext(pcoi->hwndConv, (LONG *)&ci.ConvCtxt);
        } else {
            ci.hConvList = 0;
            if (pcoi->state & ST_ISLOCAL) {
                GetConvContext(pcoi->hwndPartner, (LONG *)&ci.ConvCtxt);
            } else {
                ci.ConvCtxt = DefConvContext;
            }
        }
        if (pxi == NULL) {
            ci.hUser = pcoi->hUser;
            ci.hszItem = 0;
            ci.wFmt = 0;
            ci.wType = 0;
            ci.wConvst = XST_CONNECTED;
        } else {
            ci.hUser = pxi->hUser;
            // BUG - not fixable - This will result in extra local atoms
            // since we can never know when he is done with them.
            ci.hszItem = NORMAL_HSZ_FROM_LATOM(GlobalToLocalAtom(pxi->gaItem));
            ci.wFmt = pxi->wFmt;
            ci.wType = pxi->wType;
            ci.wConvst = pxi->state;
        }
        ci.hwnd = pcoi->hwndConv;
        ci.hwndPartner = pcoi->hwndPartner;
        RtlCopyMemory((LPSTR)pConvInfo, (LPSTR)&ci, pConvInfo->cb);
    } except(W32ExceptionHandler(FALSE, RIP_WARNING)) {
        SetLastDDEMLError(pcoi->pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    uiRet = TRUE;

Exit:
    LeaveDDECrit;
    return (uiRet);
}


/***************************************************************************\
* DdeSetUserHandle (DDEML API)
*
* Description:
* Sets a user DWORD on a per conversation/transaction basis.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeSetUserHandle, HCONV, hConv, DWORD, id, DWORD_PTR, hUser)
BOOL DdeSetUserHandle(
HCONV hConv,
DWORD id,
DWORD_PTR hUser)
{
    PCONV_INFO pcoi;
    PXACT_INFO pxi;
    BOOL fRet = FALSE;

    EnterDDECrit;

    if (!ValidateTransaction(hConv, (HANDLE)LongToHandle( id ), &pcoi, &pxi)) {
        goto Exit;
    }
    if (pxi == NULL) {
        pcoi->hUser = hUser;
    } else {
        pxi->hUser = hUser;
    }
    fRet = TRUE;

Exit:
    LeaveDDECrit;
    return (fRet);
}



VOID AbandonTransaction(
PCONV_INFO pcoi,
PXACT_INFO pxi)
{
    if (pxi != NULL) {
        pxi->flags |= XIF_ABANDONED;
    } else {
        for (pxi = pcoi->pxiIn; pxi != NULL; pxi = pxi->next) {
            pxi->flags |= XIF_ABANDONED;
        }
    }
}



BOOL AbandonEnumerateProc(
HWND hwnd,
LPARAM idTransaction)
{
    PCONV_INFO pcoi;

    pcoi = (PCONV_INFO)GetWindowLongPtr(hwnd, GWLP_PCI);
    if (!pcoi || !(pcoi->state & ST_CLIENT)) {
        return(TRUE);
    }
    while (pcoi) {
        AbandonTransaction(pcoi, (PXACT_INFO)idTransaction);
        pcoi = pcoi->next;
    }
    return(TRUE);
}



/***************************************************************************\
* DdeAbandonTransaction (DDEML API)
*
* Description:
* Cancels application interest in completing an asynchronous transaction.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdeAbandonTransaction, DWORD, idInst, HCONV, hConv, DWORD, idTransaction)
BOOL DdeAbandonTransaction(
DWORD idInst,
HCONV hConv,
DWORD idTransaction)
{
    PCONV_INFO pcoi;
    PXACT_INFO pxi;
    PCL_INSTANCE_INFO pcii;
    BOOL fRet = FALSE;

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));

    if (hConv == 0 && idTransaction == 0) {
        EnumChildWindows(pcii->hwndMother, AbandonEnumerateProc, 0);
        goto Exit;
    }
    if (idTransaction == 0) {
        idTransaction = QID_SYNC;
    }
    if (!ValidateTransaction(hConv, (HANDLE)LongToHandle( idTransaction ), &pcoi, &pxi)) {
        goto Exit;
    }
    if (pcii == NULL || pcoi->pcii != pcii) {
        SetLastDDEMLError(pcoi->pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    AbandonTransaction(pcoi, pxi);
    fRet = TRUE;

Exit:
    LeaveDDECrit;
    return (fRet);
}




/***************************************************************************\
* UpdateLinkIfChanged
*
* Description:
*   Helper function for updating a link
*
* Returns: TRUE if pxi was used - ie fMustReallocPxi
*
* History:
* 3-11-92   sanfords    Created.
* 8-24-92   sanfords    added cLinksToGo
\***************************************************************************/
BOOL UpdateLinkIfChanged(
PADVISE_LINK paLink,
PXACT_INFO pxi,
PCONV_INFO pcoi,
PADVISE_LINK paLinkLast,
PBOOL pfSwapped,
DWORD cLinksToGo)
{
    ADVISE_LINK aLinkT;

    CheckDDECritIn;

    *pfSwapped = FALSE;
    if (paLink->state & ADVST_CHANGED && !(paLink->state & ADVST_WAITING)) {
        pxi->pfnResponse = SvRespAdviseDataAck;
        pxi->pcoi = pcoi;
        pxi->gaItem = LocalToGlobalAtom(paLink->laItem);    // pxi copy
        pxi->wFmt = paLink->wFmt;
        pxi->wType = paLink->wType;
        paLink->state &= ~ADVST_CHANGED;
        if (SvStartAdviseUpdate(pxi, cLinksToGo)) {
            if (pxi->wType & DDE_FACKREQ) {
                paLink->state |= ADVST_WAITING;
                /*
                 * swap paLink with the last non-moved link to make ack search find
                 * oldest updated format.
                 */
                if (paLink != paLinkLast) {
                    aLinkT = *paLink;
                    RtlMoveMemory(paLink, paLink + 1,
                            (PBYTE)paLinkLast - (PBYTE)paLink);
                    *paLinkLast = aLinkT;
                    *pfSwapped = TRUE;
                }
            }
            return(TRUE);
        } else {
            GlobalDeleteAtom(pxi->gaItem);  // pxi copy
            return(FALSE);
        }
    }
    return(FALSE);
}


/***************************************************************************\
* DdePostAdvise     (DDEML API)
*
* Description:
* Updates outstanding server advise links as needed.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/

FUNCLOG3(LOG_GENERAL, BOOL, DUMMYCALLINGTYPE, DdePostAdvise, DWORD, idInst, HSZ, hszTopic, HSZ, hszItem)
BOOL DdePostAdvise(
DWORD idInst,
HSZ hszTopic,
HSZ hszItem)
{
    PCL_INSTANCE_INFO pcii;
    PSVR_CONV_INFO psi;
    PXACT_INFO pxi;
    PADVISE_LINK paLink;
    BOOL fRet = FALSE, fSwapped, fFound;
    int iServer, iLink;
    PLINK_COUNT pLinkCount;
#if DBG
    int cLinks;
#endif

    EnterDDECrit;

    pcii = ValidateInstance((HANDLE)LongToHandle( idInst ));
    if (pcii == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        goto Exit;
    }
    if ((ValidateHSZ(hszTopic) == HSZT_INVALID) ||
            (ValidateHSZ(hszItem) == HSZT_INVALID)) {
        SetLastDDEMLError(pcii, DMLERR_INVALIDPARAMETER);
        goto Exit;
    }

    /*
     * Initialize all link counters and check if any links qualify
     */
    fFound = FALSE;
    for (pLinkCount = pcii->pLinkCount;
            pLinkCount; pLinkCount = pLinkCount->next) {
        pLinkCount->Count = pLinkCount->Total;
        fFound |= pLinkCount->laTopic == LATOM_FROM_HSZ(hszTopic) &&
                  pLinkCount->laItem == LATOM_FROM_HSZ(hszItem);
    }
    if (!fFound && hszTopic && hszItem) {
        fRet = TRUE;
        goto Exit;
    }

    /*
     * preallocate incase we are low on memory.
     */
    pxi = DDEMLAlloc(sizeof(XACT_INFO));
    if (pxi == NULL) {
        SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
        fRet = FALSE;
        goto Exit;
    }

    /*
     * For each server window on the specified topic
     */
    for (iServer = 0; iServer < pcii->cServerLookupAlloc; iServer++) {
        if (hszTopic == 0 ||
                pcii->aServerLookup[iServer].laTopic == LATOM_FROM_HSZ(hszTopic)) {

            /*
             * For each conversation within that window
             */
            psi = (PSVR_CONV_INFO)GetWindowLongPtr(
                    pcii->aServerLookup[iServer].hwndServer, GWLP_PSI);
            UserAssert(psi != NULL && psi->ci.pcii == pcii);    // sanity check
            while (psi != NULL) {


                /*
                 * UpdateLinkIfChanged might leave the critical section so lock this conversation
                 */
                psi->ci.cLocks++;

                #if DBG
                /*
                 * Rememeber the number of links so we can assert if they change during the loop below
                 */
                cLinks = psi->ci.cLinks;
                #endif
                /*
                 * For each active link on the given item...
                 */
                for (paLink = psi->ci.aLinks, iLink = 0;
                        iLink < psi->ci.cLinks; paLink++, iLink++) {
                    if (hszItem == 0 ||
                            paLink->laItem == LATOM_FROM_HSZ(hszItem)) {

// Bit of a hack here. For FACKREQ links, we don't want the server to
// outrun the client so we set the ADVST_WAITING bit till the ack is
// received. When the ack comes in, the protocol code has to search
// the aLinks array again to locate the apropriate link state flags and
// clear the ADVST_WAITING flag. At that time, if the ADVST_CHANGED flag
// is set, it is cleared and another SvStartAdviseUpdate transaction
// is started to get the link up to date.  To complicate matters,
// the ACK contains no format information.  Thus we need to move
// the Link info to the end of the list so that the right format
// is updated when the ack comes in.

                        paLink->state |= ADVST_CHANGED;
                        if (UpdateLinkIfChanged(paLink, pxi, &psi->ci,
                                &psi->ci.aLinks[psi->ci.cLinks - 1],
                                &fSwapped, --paLink->pLinkCount->Count)) {
                            if (fSwapped) {
                                paLink--;
                            }
                            /*
                             * preallocate for next advise
                             */
                            pxi = DDEMLAlloc(sizeof(XACT_INFO));
                            if (pxi == NULL) {
                                SetLastDDEMLError(pcii, DMLERR_MEMORY_ERROR);
                                /*
                                 * Unlock the conversation
                                 */
                                psi->ci.cLocks--;
                                if ((psi->ci.cLocks == 0) && (psi->ci.state & ST_FREE_CONV_RES_NOW)) {
                                    RIPMSG1(RIP_ERROR, "DdePostAdvise: Conversation terminated. psi:%#p", psi);
                                    FreeConversationResources((PCONV_INFO)psi);
                                }
                                goto Exit;
                            }
                        }
                        /*
                         * We might have left the crit sect...
                         */
                        UserAssert(pcii == ValidateInstance((HANDLE)LongToHandle( idInst )));
                    }
                }
                #if DBG
                if (cLinks != psi->ci.cLinks) {
                    RIPMSG1(RIP_ERROR, "DdePostAdvise: cLinks changed. psi:%#p", psi);
                }
                #endif

                /*
                 * If the converstaion got nuked, stop working on this conversation chain.
                 */
                psi->ci.cLocks--;
                if ((psi->ci.cLocks == 0) && (psi->ci.state & ST_FREE_CONV_RES_NOW)) {
                    RIPMSG1(RIP_ERROR, "DdePostAdvise: Conversation terminated. psi:%#p", psi);
                    FreeConversationResources((PCONV_INFO)psi);
                    break;
                }

                psi = (PSVR_CONV_INFO)psi->ci.next;     // next conversation
            }
        }
    }
    DDEMLFree(pxi);
    fRet = TRUE;

Exit:
    /*
     * Because callbacks are capable of blocking DdeUninitialize(), we check
     * before exit to see if it needs to be called.
     */
    UserAssert(pcii == ValidateInstance((HANDLE)LongToHandle( idInst )));
    if (pcii != NULL &&
            pcii->afCmd & APPCMD_UNINIT_ASAP &&
            !(pcii->flags & IIF_IN_SYNC_XACT) &&
            !pcii->cInDDEMLCallback) {
        DdeUninitialize(HandleToUlong(pcii->hInstClient));
        fRet = TRUE;
    }
    LeaveDDECrit;
    return (fRet);
}


/***************************************************************************\
* LinkTransaction
*
* Description:
* Adds a transaction structure to the associated conversation's transaction
* queue.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
VOID LinkTransaction(
PXACT_INFO pxi)
{
    CheckDDECritIn;

    pxi->next = NULL;
    if (pxi->pcoi->pxiOut == NULL) {
        pxi->pcoi->pxiIn = pxi->pcoi->pxiOut = pxi;
    } else {
        pxi->pcoi->pxiIn->next = pxi;
        pxi->pcoi->pxiIn = pxi;
    }
#if DBG
    /*
     * Temporary check to find stress bug - make sure pxi list is not
     * looped on itself.  If it is, this loop will never exit and things
     * will get investigated. (sanfords)
     */
    {
        PXACT_INFO pxiT;

        for (pxiT = pxi->pcoi->pxiOut; pxiT != NULL; pxiT = pxiT->next) {
            ;
        }
    }
#endif // DBG
}


/***************************************************************************\
* UnlinkTransaction
*
* Description:
* Removes a transaction structure from the associated conversation's transaction
* queue.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
VOID UnlinkTransaction(
PXACT_INFO pxi)
{
    CheckDDECritIn;
    if (pxi == pxi->pcoi->pxiOut) {
        pxi->pcoi->pxiOut = pxi->next;
        if (pxi->next == NULL) {
            pxi->pcoi->pxiIn = NULL;
        }
    }
}


/***************************************************************************\
* ValidateTransaction
*
* Description:
* Common validation code for DDEML APIs that take a conversation handle
* and a transaction ID. *ppxi may be null on return if hXact was 0.
* Returns fSuccess.
*
* History:
* 11-12-91 sanfords Created.
\***************************************************************************/
BOOL ValidateTransaction(
HCONV hConv,
HANDLE hXact,
PCONV_INFO *ppcoi,
PXACT_INFO *ppxi)
{
    PCL_INSTANCE_INFO pcii;

    *ppcoi = (PCONV_INFO)ValidateCHandle((HANDLE)hConv,
            HTYPE_CLIENT_CONVERSATION, HINST_ANY);
    if (*ppcoi == NULL) {
        *ppcoi = (PCONV_INFO)ValidateCHandle((HANDLE)hConv,
                HTYPE_SERVER_CONVERSATION, HINST_ANY);
    }
    if (*ppcoi == NULL) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        return (FALSE);
    }
    pcii = ValidateInstance((*ppcoi)->pcii->hInstClient);
    if (pcii != (*ppcoi)->pcii) {
        BestSetLastDDEMLError(DMLERR_INVALIDPARAMETER);
        return (FALSE);
    }

    if (hXact == (HANDLE)IntToPtr( QID_SYNC )) {
        *ppxi = NULL;
    } else {
        *ppxi = (PXACT_INFO)ValidateCHandle(hXact, HTYPE_TRANSACTION,
                InstFromHandle((*ppcoi)->pcii->hInstClient));
        if (*ppxi == NULL) {
            SetLastDDEMLError((*ppcoi)->pcii, DMLERR_INVALIDPARAMETER);
            return (FALSE);
        }
    }
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\com.c ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    com.c

Abstract:

    This file implements the COM entry.

Author:

Revision History:

Notes:

--*/

#include "precomp.h"
#define COBJMACROS
#include "msctf.h"
#include "tlapi.h"
#include "apcompat.h"


#ifdef CUAS_ENABLE

#ifndef RtlIsThreadWithinLoaderCallout 
BOOLEAN NTAPI RtlIsThreadWithinLoaderCallout (VOID);
#endif

HRESULT CtfAImmCreateInputContext(HIMC himc);
HRESULT ActivateOrDeactivateTIM( BOOL fActivate);
DWORD GetCoInitCountSkip();
DWORD IncCoInitCountSkip();
DWORD DecCoInitCountSkip();
HRESULT Internal_CoInitializeEx(void* pv, DWORD dw);


//+---------------------------------------------------------------------------
//
// For InitializeSpy
//
//----------------------------------------------------------------------------

typedef struct _IMMISPY
{
  IInitializeSpy;
  ULONG cref;
} IMMISPY;

//+---------------------------------------------------------------------------
//
// CTFIMMTLS
//
//----------------------------------------------------------------------------

typedef struct _CTFIMMTLS
{
    IMMISPY *pimmispy;
    ULARGE_INTEGER uliISpyCookie;
    DWORD dwInRefCountSkipMode;
    DWORD dwRefCountSkip;
    BOOL  fInCtfImmCoUninitialize;
} CTFIMMTLS;

CTFIMMTLS* GetTLS();

IMMISPY *AllocIMMISPY();
void DeleteIMMISPY(IMMISPY *pimmispy);

//+---------------------------------------------------------------------------
//
// _InsideLoaderLock()
//
//----------------------------------------------------------------------------

BOOL _InsideLoaderLock()
{
    return (NtCurrentTeb()->ClientId.UniqueThread ==
           ((PRTL_CRITICAL_SECTION)(NtCurrentPeb()->LoaderLock))->OwningThread);
}

//+---------------------------------------------------------------------------
//
// PImmISpyFromPISpy
//
//----------------------------------------------------------------------------

IMMISPY *PImmISpyFromPISpy(IInitializeSpy *pispy)
{
    return (IMMISPY *)pispy;
}

//+---------------------------------------------------------------------------
//
// ISPY_AddRef
//
//----------------------------------------------------------------------------

ULONG ISPY_AddRef(IInitializeSpy *pispy)
{
    IMMISPY *pimmispy = PImmISpyFromPISpy(pispy);

    pimmispy->cref++;
    return pimmispy->cref;
}

//+---------------------------------------------------------------------------
//
// ISPY_Release
//
//----------------------------------------------------------------------------

ULONG ISPY_Release(IInitializeSpy *pispy)
{
    IMMISPY *pimmispy = PImmISpyFromPISpy(pispy);

    pimmispy->cref--;
    if (!pimmispy->cref)
    {
        DeleteIMMISPY(pimmispy);
        return 0;
    }

    return pimmispy->cref;
}

//+---------------------------------------------------------------------------
//
// ISPY_QueryInterface
//
//----------------------------------------------------------------------------

HRESULT ISPY_QueryInterface(IInitializeSpy *pispy,
                            REFIID riid,
                            void **ppvObject)
{

    if (!ppvObject)
        return E_INVALIDARG;

    *ppvObject = NULL;

    if (IsEqualIID(riid, &IID_IUnknown) ||
        IsEqualIID(riid, &IID_IInitializeSpy))
    {
        ISPY_AddRef(pispy);
        *ppvObject = pispy;
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
// ISPY_PreInitialize
//
//----------------------------------------------------------------------------

HRESULT ISPY_PreInitialize(IInitializeSpy * pispy,
                           DWORD dwCoInit,
                           DWORD dwCurThreadAptRefs)
{
    DWORD dwRet = IncCoInitCountSkip();

    UNREFERENCED_PARAMETER(pispy);

    //
    // If we already initialize com and a 2nd initialization is MT,
    // we should disable CUAS. So the CoInit(MT) from caller will work.
    //
    if (GetClientInfo()->CI_flags & CI_CUAS_COINIT_CALLED)
    {
        if ((dwCurThreadAptRefs == (dwRet + 1)) &&  
            (dwCoInit == COINIT_MULTITHREADED))
        {
             ActivateOrDeactivateTIM(FALSE);
             CtfImmCoUninitialize();
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ISPY_PostInitialize
//
//----------------------------------------------------------------------------

HRESULT ISPY_PostInitialize(IInitializeSpy * pispy,
                            HRESULT hrCoInit,
                            DWORD dwCoInit,
                            DWORD dwNewThreadAptRefs)
{
    DWORD dwRet = GetCoInitCountSkip();
    UNREFERENCED_PARAMETER(pispy);
    UNREFERENCED_PARAMETER(dwCoInit);

    //
    // If we already initialize com and got a 2nd initialization,
    // change the return value to S_OK. So the caller think
    // that it is the first initialization.
    //
    if (GetClientInfo()->CI_flags & CI_CUAS_COINIT_CALLED)
    {
        if ((hrCoInit == S_FALSE) && (dwNewThreadAptRefs == (dwRet + 2)))
        {
            return S_OK;
        }
    }

    return hrCoInit;
}

//+---------------------------------------------------------------------------
//
// ISPY_PreUninitialize
//
//----------------------------------------------------------------------------

HRESULT ISPY_PreUninitialize(IInitializeSpy * pispy,
                             DWORD dwCurThreadAptRefs)
{
    UNREFERENCED_PARAMETER(pispy);
    UNREFERENCED_PARAMETER(dwCurThreadAptRefs);

    //
    // #607467
    //
    // Norton Systemworks setup calls CoUninitialize() without calling
    // CoInitialize(). So we got under ref problem.
    // If the last ref count is ours, we recover it by calling
    // CoInitializeEx().
    //
    if (dwCurThreadAptRefs == 1)
    {
        if (!RtlDllShutdownInProgress() &&
            !_InsideLoaderLock() &&
            (GetClientInfo()->CI_flags & CI_CUAS_COINIT_CALLED))
        {
            CTFIMMTLS* ptls = GetTLS();
            if (ptls && !ptls->fInCtfImmCoUninitialize)
            {
                Internal_CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
            }
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ISPY_PostUninitialize
//
//----------------------------------------------------------------------------

HRESULT ISPY_PostUninitialize(IInitializeSpy * pispy,
                              DWORD dwNewThreadAptRefs)
{
    UNREFERENCED_PARAMETER(pispy);
    UNREFERENCED_PARAMETER(dwNewThreadAptRefs);

    DecCoInitCountSkip();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// g_vtbnlISPY
//
//----------------------------------------------------------------------------

IInitializeSpyVtbl g_vtblISPY = {
    ISPY_QueryInterface,
    ISPY_AddRef,
    ISPY_Release,
    ISPY_PreInitialize,
    ISPY_PostInitialize,
    ISPY_PreUninitialize,
    ISPY_PostUninitialize,
};

//+---------------------------------------------------------------------------
//
// AllocIMMISPY
//
//----------------------------------------------------------------------------

IMMISPY *AllocIMMISPY()
{
    IMMISPY *pimmispy = ImmLocalAlloc(0, sizeof(IMMISPY));
    if (!pimmispy)
        return NULL;

    pimmispy->lpVtbl = &g_vtblISPY;
    pimmispy->cref = 1;

    return pimmispy;
}

//+---------------------------------------------------------------------------
//
// DeletIMMISPY
//
//----------------------------------------------------------------------------

void DeleteIMMISPY(IMMISPY *pimmispy)
{
    ImmLocalFree(pimmispy);
}


//////////////////////////////////////////////////////////////////////////////
//
// TLS
//
//////////////////////////////////////////////////////////////////////////////

DWORD g_dwTLSIndex = (DWORD)-1;

//+---------------------------------------------------------------------------
//
// InitTLS
//
//----------------------------------------------------------------------------

void InitTLS()
{
    RtlEnterCriticalSection(&gcsImeDpi);
    if (g_dwTLSIndex == (DWORD)-1)
        g_dwTLSIndex = TlsAlloc();
    RtlLeaveCriticalSection(&gcsImeDpi);
}

//+---------------------------------------------------------------------------
//
// InternalAllocateTLS
//
//----------------------------------------------------------------------------

CTFIMMTLS* InternalAllocateTLS()
{
    CTFIMMTLS* ptls;

    if (g_dwTLSIndex == (DWORD)-1)
        return NULL;

    ptls = (CTFIMMTLS*)TlsGetValue(g_dwTLSIndex);
    if (ptls == NULL)
    {
        if ((ptls = (CTFIMMTLS*)ImmLocalAlloc(HEAP_ZERO_MEMORY, 
                                              sizeof(CTFIMMTLS))) == NULL)
            return NULL;

        if (!TlsSetValue(g_dwTLSIndex, ptls))
        {
            ImmLocalFree(ptls);
            return NULL;
        }
    }
    return ptls;
}

//+---------------------------------------------------------------------------
//
// GetTLS
//
//----------------------------------------------------------------------------

CTFIMMTLS* GetTLS()
{
    if (g_dwTLSIndex == (DWORD)-1)
        return NULL;

    return (CTFIMMTLS*)TlsGetValue(g_dwTLSIndex);
}

//+---------------------------------------------------------------------------
//
// CtfImmEnterCoInitCountSkipMode
//
//----------------------------------------------------------------------------

BOOL WINAPI CtfImmEnterCoInitCountSkipMode()
{
    CTFIMMTLS* ptls = GetTLS();
    if (!ptls)
        return FALSE;

    ptls->dwInRefCountSkipMode++;
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// CtfImmLeaveCoInitCountSkip
//
//----------------------------------------------------------------------------

BOOL WINAPI CtfImmLeaveCoInitCountSkipMode()
{
    CTFIMMTLS* ptls = GetTLS();
    if (!ptls)
        return FALSE;

    if (ptls->dwInRefCountSkipMode < 1)
    {
        UserAssert(0);
        return FALSE;
    }

    ptls->dwInRefCountSkipMode--;
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// GetCoInitCountSkip
//
//----------------------------------------------------------------------------

DWORD GetCoInitCountSkip()
{
    CTFIMMTLS* ptls = GetTLS();
    if (!ptls)
        return 0;

    return ptls->dwRefCountSkip;
}

//+---------------------------------------------------------------------------
//
// IncCoInitCountSkip
//
//----------------------------------------------------------------------------

DWORD IncCoInitCountSkip()
{
    DWORD dwRet = 0;
    CTFIMMTLS* ptls = GetTLS();
    if (!ptls)
        return dwRet;

    dwRet = ptls->dwRefCountSkip;
    if (ptls->dwInRefCountSkipMode)
        ptls->dwRefCountSkip++;

    return dwRet;
}

//+---------------------------------------------------------------------------
//
// DecCoInitCountSkip
//
//----------------------------------------------------------------------------

DWORD DecCoInitCountSkip()
{
    DWORD dwRet = 0;
    CTFIMMTLS* ptls = GetTLS();
    if (!ptls)
        return dwRet;

    dwRet = ptls->dwRefCountSkip;
    if (ptls->dwInRefCountSkipMode)
    {
        if (ptls->dwRefCountSkip < 1)
        {
            UserAssert(0);
            return dwRet;
        }
        ptls->dwRefCountSkip--;
    }
    return dwRet;
}

//+---------------------------------------------------------------------------
//
// InternalDestroyTLS
//
//----------------------------------------------------------------------------

BOOL InternalDestroyTLS()
{
    CTFIMMTLS* ptls;

    ptls = (CTFIMMTLS*)TlsGetValue(g_dwTLSIndex);
    if (ptls != NULL)
    {
        ImmLocalFree(ptls);
        TlsSetValue(g_dwTLSIndex, NULL);
        return TRUE;
    }
    return FALSE;
}


/*
 * Text frame service processing is disabled for all the thread in the current process
 */
BOOL g_disable_CUAS_flag = FALSE;

//+---------------------------------------------------------------------------
//
// delay load
//
//----------------------------------------------------------------------------

FARPROC GetFn(HINSTANCE *phInst, TCHAR *pchLib, char *pchFunc)
{
    if (*phInst == NULL)
    {
        *phInst = LoadLibrary(pchLib);
        if (*phInst == NULL)
        {
            UserAssert(0);
            return NULL;
        }
    }

    return GetProcAddress(*phInst, pchFunc);
}


HINSTANCE g_hOle32 = NULL;

HRESULT Internal_CoInitializeEx(void* pv, DWORD dw)
{
    static FARPROC pfn = NULL;
    if (pfn == NULL || g_hOle32 == NULL) {
        pfn = GetFn(&g_hOle32, L"ole32.dll", "CoInitializeEx");
        if (pfn == NULL) {
            UserAssert(0);
            return E_FAIL;
        }
    }
    return (HRESULT)(*pfn)(pv, dw);
}

void Internal_CoUninitialize()
{
    static FARPROC pfn = NULL;
    if (pfn == NULL || g_hOle32 == NULL) {
        pfn = GetFn(&g_hOle32, L"ole32.dll", "CoUninitialize");
        if (pfn == NULL) {
            UserAssert(0);
            return;
        }
    }
    (*pfn)();
}


HRESULT Internal_CoRegisterInitializeSpy(LPINITIALIZESPY pSpy, 
                                         ULARGE_INTEGER *puliCookie)
{
    static FARPROC pfn = NULL;
    if (pfn == NULL || g_hOle32 == NULL) {
        pfn = GetFn(&g_hOle32, L"ole32.dll", "CoRegisterInitializeSpy");
        if (pfn == NULL) {
            UserAssert(0);
            return E_FAIL;
        }
    }
    return (HRESULT)(*pfn)(pSpy, puliCookie);
}

HRESULT Internal_CoRevokeInitializeSpy(ULARGE_INTEGER uliCookie)
{
    static FARPROC pfn = NULL;
    if (pfn == NULL || g_hOle32 == NULL) {
        pfn = GetFn(&g_hOle32, L"ole32.dll", "CoRevokeInitializeSpy");
        if (pfn == NULL) {
            UserAssert(0);
            return E_FAIL;
        }
    }
    return (HRESULT)(*pfn)(uliCookie);
}



HINSTANCE g_hMsctf = NULL;

HRESULT Internal_TF_CreateLangBarMgr(ITfLangBarMgr** pv)
{
    static FARPROC pfn = NULL;
    if (pfn == NULL || g_hMsctf == NULL) {
        pfn = GetFn(&g_hMsctf, L"msctf.dll", "TF_CreateLangBarMgr");
        if (pfn == NULL) {
            UserAssert(0);
            return E_FAIL;
        }
    }
    return (HRESULT)(*pfn)(pv);
}

DWORD Internal_TF_CicNotify(int nCode, WPARAM wParam, LPARAM lParam)
{
    static FARPROC pfn = NULL;
    if (pfn == NULL || g_hMsctf == NULL) {
        pfn = GetFn(&g_hMsctf, L"msctf.dll", "TF_CicNotify");
        if (pfn == NULL) {
            UserAssert(0);
            return E_FAIL;
        }
    }
    return (DWORD)(*pfn)(nCode, wParam, lParam);
}


#if 0
HINSTANCE g_hNtdll = NULL;

BOOLEAN Internal_RtlIsThreadWithinLoaderCallout(VOID)
{
    static FARPROC pfn = NULL;
    if (pfn == NULL || g_hNtdll == NULL) {
        pfn = GetFn(&g_hNtdll, L"ntdll.dll", "RtlIsThreadWithinLoaderCallout");
        if (pfn == NULL) {
            UserAssert(0);
            return FALSE;
        }
    }
    return (BOOLEAN)(*pfn)();
}
#endif


//+---------------------------------------------------------------------------
//
// CtfImmCoInitialize
//
//----------------------------------------------------------------------------

HRESULT
CtfImmCoInitialize()
{
    //
    // CoInitializeEx
    //
    HRESULT hr = E_NOINTERFACE;

    //
    // Check CI flag
    //
    if (GetClientInfo()->CI_flags & CI_CUAS_COINIT_CALLED) 
        return S_OK;

    hr = Internal_CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hr))
    {
        RIPMSG0(RIP_VERBOSE, "CtfImmCoInitialize succeeded.");

        //
        // Set CI flag
        //
        GetClientInfo()->CI_flags |= CI_CUAS_COINIT_CALLED;

        {
            CTFIMMTLS* ptls;
            //
            // Initialize CoInitSpy.
            //
            InitTLS();
            ptls = InternalAllocateTLS();

            if (ptls && !ptls->pimmispy)
            {
                ptls->pimmispy = AllocIMMISPY();
                if (ptls->pimmispy)
                {
                    HRESULT hrTemp;
                    hrTemp = Internal_CoRegisterInitializeSpy((LPINITIALIZESPY)ptls->pimmispy,
                                                          &(ptls->uliISpyCookie));

                    if (FAILED(hrTemp))
                    {
                        DeleteIMMISPY(ptls->pimmispy);
                        ptls->pimmispy = NULL;
                        memset(&ptls->uliISpyCookie, 0, sizeof(ULARGE_INTEGER));

                    }
                }
            }
        }

        hr = S_OK;
    }
    else
    {
        RIPMSG1(RIP_WARNING, "CtfImmCoInitialize failed. err=%x", hr);
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
// CtfImmCoUninitialize
//
//----------------------------------------------------------------------------

void WINAPI
CtfImmCoUninitialize()
{
    if (GetClientInfo()->CI_flags & CI_CUAS_COINIT_CALLED)
    {
        CTFIMMTLS* ptls = GetTLS();
        if (ptls)
        {
             ptls->fInCtfImmCoUninitialize = TRUE;
             Internal_CoUninitialize();
             ptls->fInCtfImmCoUninitialize = FALSE;
             GetClientInfo()->CI_flags &= ~CI_CUAS_COINIT_CALLED;
        }

        {
            CTFIMMTLS* ptls;
            //
            // revoke initialize spy
            //
            ptls = InternalAllocateTLS();
            if (ptls && ptls->pimmispy)
            {
                Internal_CoRevokeInitializeSpy(ptls->uliISpyCookie);
                ISPY_Release((IInitializeSpy *)ptls->pimmispy);
                ptls->pimmispy = NULL;
                memset(&ptls->uliISpyCookie, 0, sizeof(ULARGE_INTEGER));
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
// CtfImmTIMActivate
//
//----------------------------------------------------------------------------

HRESULT
CtfImmTIMActivate(
    HKL hKL)
{
    HRESULT hr = S_OK;

    /*
     * Text frame service processing is disabled for all the thread in the current process
     */
    if (g_disable_CUAS_flag) {
        RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: g_disable_CUAS_flag is ON.");
        /*
         * set client info flag.
         */
        GetClientInfo()->CI_flags |= CI_CUAS_DISABLE;
        return hr;
    }

    /*
     * Check client info flag.
     */
    if (GetClientInfo()->CI_flags & CI_CUAS_DISABLE) {
        RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: CI_CUAS_DISABLE is ON.");
        return hr;
    }

    /*
     * Check Disable Advanced Text Services switch.
     * If it is On, doesn't activate TIM.
     */
    if (IsDisabledTextServices()) {
        /*
         * set client info flag.
         */
        GetClientInfo()->CI_flags |= CI_CUAS_DISABLE;

        RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: Disabled Text Services.");
        return hr;
    }

    /*
     * Check a interactive user logon.
     */
    if (!IsInteractiveUserLogon() || IsRunningInMsoobe()) {
        RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: Not a interactive user logon. or MSOOBE mode");
        return hr;
    }

    /*
     * Check CUAS switch. If CUAS is OFF, doesn't activate TIM.
     */
    if (! IsCUASEnabled()) {
        /*
         * If AIMM enabled, then return S_OK;
         */
        DWORD dwImeCompatFlags = ImmGetAppCompatFlags(NULL);
        if (dwImeCompatFlags & (IMECOMPAT_AIMM12 | IMECOMPAT_AIMM_LEGACY_CLSID | IMECOMPAT_AIMM12_TRIDENT)) {
            return S_OK;
        }

        /*
         * set client info flag.
         */
        GetClientInfo()->CI_flags |= CI_CUAS_DISABLE;

        RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: CUAS switch is OFF.");
        return hr;
    }

    /*
     *  
     *  KACF_DISABLECICERO is already defined in private/Lab06_DEV
     *  we will use this flag later.
     *  
     *    APPCOMPATFLAG(KACF_DISABLECICERO)
     *    KACF_DISABLECICERO is 0x100
     */
    #ifndef KACF_DISABLECICERO
    #define KACF_DISABLECICERO 0x00000100    // If set. Cicero support for the current process
                                             // is disabled.
    #endif

    if (APPCOMPATFLAG(KACF_DISABLECICERO)) {
        /*
         * set client info flag.
         */
        GetClientInfo()->CI_flags |= CI_CUAS_DISABLE;

        RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: KACF_DISABLECICERO app compatiblity flag is ON.");
        return hr;
    }

    if (RtlIsThreadWithinLoaderCallout())
    {
        RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: we're in DllMain().");
        return hr;
    }

    if (_InsideLoaderLock()) {
        RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: we're in DllMain.");
        return hr;
    }

    if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
        HINSTANCE hCtf = NULL;

        if (IS_IME_KBDLAYOUT(hKL)) {
             LANGID lg = LOWORD(HandleToUlong(hKL));
             hKL = (HKL)LongToHandle( MAKELONG(lg, lg) );
        }

        if (!ImmLoadIME(hKL)) {
            //
            RIPMSG1(RIP_VERBOSE, "CtfImmTIMActivate: ImmLoadIME=%lx fail.", hKL);
            //
            // Cicero keyboard layout doesn't loaded yet.
            // MSCTF ! TF_InvalidAssemblyListCacheIfExist load Cicero assembly.
            //
            hCtf = LoadLibrary(TEXT("msctf.dll"));
            if (hCtf) {
                typedef BOOL (WINAPI* PFNINVALIDASSEMBLY)();
                PFNINVALIDASSEMBLY pfn;
                pfn = (PFNINVALIDASSEMBLY)GetProcAddress(hCtf, "TF_InvalidAssemblyListCacheIfExist");
                if (pfn) {
                    pfn();
                }
            }
        }

        /*
         * Initialize COM for Cicero IME.
         */
        CtfImmCoInitialize();

        if (  (GetClientInfo()->CI_flags & CI_CUAS_COINIT_CALLED) &&
            ! (GetClientInfo()->CI_flags & CI_CUAS_TIM_ACTIVATED)) {
            /*
             * Create and Activate TIM
             */
            hr = Internal_CtfImeCreateThreadMgr();
            if (SUCCEEDED(hr)) {
                GetClientInfo()->CI_flags |= CI_CUAS_TIM_ACTIVATED;
                RIPMSG0(RIP_VERBOSE, "CtfImmTIMActivate: Succeeded CtfImeCreateThreadMgr.");
            }
            else {
                RIPMSG0(RIP_WARNING, "CtfImmTIMActivate: Fail CtfImeCreateThreadMgr.");
            }
        }

        if (hCtf) {
            FreeLibrary(hCtf);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CtfImmTIMCreateInputContext
//
//----------------------------------------------------------------------------

HRESULT
CtfImmTIMCreateInputContext(
    HIMC hImc)
{
    PCLIENTIMC pClientImc;
    HRESULT hr = S_FALSE;
    DWORD dwThreadId;

    if (GetClientInfo()->CI_flags & CI_CUAS_AIMM12ACTIVATED)
    {
        if ((pClientImc = ImmLockClientImc(hImc)) == NULL)
            return E_FAIL;

        /*
         * check fCtfImeContext first
         */
        if (pClientImc->fCtfImeContext) 
            goto Exit;

        pClientImc->fCtfImeContext = TRUE;
        hr = CtfAImmCreateInputContext(hImc);
        if (SUCCEEDED(hr)) {
            RIPMSG0(RIP_VERBOSE, "CtfImmTIMCreateInputContext: Succeeded CtfImeCreateInputContext.");
        }
        else {
            pClientImc->fCtfImeContext = FALSE;

            RIPMSG0(RIP_WARNING, "CtfImmTIMCreateInputContext: Fail CtfImeCreateInputContext.");
        }
        goto Exit;
    }

    if (!(GetClientInfo()->CI_flags & CI_CUAS_TIM_ACTIVATED))
    {
        //
        // Tim is not activated. We don't have to create the InputContext.
        //
        return S_OK;
    }

    if ((pClientImc = ImmLockClientImc(hImc)) == NULL)
        return E_FAIL;

    /*
     * check fCtfImeContext first
     */
    if (pClientImc->fCtfImeContext) 
        goto Exit;

    dwThreadId = GetInputContextThread(hImc);
    if (dwThreadId != GetCurrentThreadId())
        goto Exit;

    if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
            /*
             * Set fCtfImeContext before calling ctfime to avoid recursion 
             * call.
             */
            pClientImc->fCtfImeContext = TRUE;

            /*
             * Create Input Context
             */
            hr = Internal_CtfImeCreateInputContext(hImc);
            if (SUCCEEDED(hr)) {
                RIPMSG0(RIP_VERBOSE, "CtfImmTIMCreateInputContext: Succeeded CtfImeCreateInputContext.");
            }
            else {
                pClientImc->fCtfImeContext = FALSE;

                RIPMSG0(RIP_WARNING, "CtfImmTIMCreateInputContext: Fail CtfImeCreateInputContext.");
            }
    }

Exit:
    ImmUnlockClientImc(pClientImc);

    return hr;
}

//+---------------------------------------------------------------------------
//
// CtfImmTIMDestroyInputContext
//
//----------------------------------------------------------------------------

HRESULT
CtfImmTIMDestroyInputContext(
    HIMC hImc)
{
    HRESULT hr = E_NOINTERFACE;

    if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
        /*
         * Destroy Input Context.
         */
        hr = Internal_CtfImeDestroyInputContext(hImc);
        if (SUCCEEDED(hr)) {
            RIPMSG0(RIP_VERBOSE, "CtfImmTIMDestroyInputContext: Succeeded CtfImeDestroyInputContext.");
        }
        else {
            RIPMSG0(RIP_WARNING, "CtfImmTIMDestroyInputContext: Fail CtfImeDestroyInputContext.");
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// CtfImmRestoreToolbarWnd
//
//----------------------------------------------------------------------------

void
CtfImmRestoreToolbarWnd(
    DWORD dwStatus)
{
    ITfLangBarMgr* plbm;

    if (SUCCEEDED(Internal_TF_CreateLangBarMgr(&plbm)))
    {
        if (dwStatus)
        {
            ITfLangBarMgr_ShowFloating(plbm, dwStatus);
        }
        ITfLangBarMgr_Release(plbm);
    }
    return;
}

//+---------------------------------------------------------------------------
//
// CtfImmHideToolbarWnd
//
//----------------------------------------------------------------------------

DWORD
CtfImmHideToolbarWnd()
{
    ITfLangBarMgr* plbm;
    DWORD _dwPrev = 0;

    if (SUCCEEDED(Internal_TF_CreateLangBarMgr(&plbm)))
    {
        if (SUCCEEDED(ITfLangBarMgr_GetShowFloatingStatus(plbm, &_dwPrev)))
        {
            BOOL fHide = TRUE;
            if (_dwPrev & TF_SFT_DESKBAND)
                fHide = FALSE;

            //
            // mask for show/hide
            //
            _dwPrev &= (TF_SFT_SHOWNORMAL |
                        TF_SFT_DOCK |
                        TF_SFT_MINIMIZED |
                        TF_SFT_HIDDEN);

            if (fHide)
                ITfLangBarMgr_ShowFloating(plbm, TF_SFT_HIDDEN);
        }
        ITfLangBarMgr_Release(plbm);
    }

    return _dwPrev;
}

//+---------------------------------------------------------------------------
//
// CtfImmGetGuidAtom
//
//----------------------------------------------------------------------------

HRESULT
CtfImmGetGuidAtom(HIMC hImc, BYTE bAttr, DWORD* pGuidAtom)
{
    HRESULT hr = E_FAIL;

    *pGuidAtom = 0;

    if (IS_CICERO_ENABLED_AND_NOT16BIT()) {

        PIMEDPI       pImeDpi;
        DWORD         dwImcThreadId = (DWORD)NtUserQueryInputContext(hImc, InputContextThread);
        HKL           hKL = GetKeyboardLayout(dwImcThreadId);

        if (IS_IME_KBDLAYOUT(hKL)) {
            RIPMSG1(RIP_WARNING, "CtfImmGetGuidAtom: hKL=%lx.", hKL);
            return FALSE;
        }

        pImeDpi = FindOrLoadImeDpi(hKL);
        if (pImeDpi == NULL) {
            RIPMSG0(RIP_WARNING, "CtfImmGetGuidAtom: no pImeDpi entry.");
        }
        else {
            /*
             * Get GUID atom value
             */
            hr = (*pImeDpi->pfn.CtfImeGetGuidAtom)(hImc, bAttr, pGuidAtom);
            if (SUCCEEDED(hr)) {
                RIPMSG0(RIP_VERBOSE, "CtfImmGetGuidAtom: Succeeded CtfImeGetGuidAtom.");
            }
            else {
                RIPMSG0(RIP_WARNING, "CtfImmGetGuidAtom: Fail CtfImeGetGuidAtom.");
            }
            ImmUnlockImeDpi(pImeDpi);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CtfImmIsGuidMapEnable
//
//----------------------------------------------------------------------------

BOOL
CtfImmIsGuidMapEnable(HIMC hImc)
{
    BOOL ret = FALSE;

    if (IS_CICERO_ENABLED_AND_NOT16BIT()) {

        PIMEDPI       pImeDpi;
        DWORD         dwImcThreadId = (DWORD)NtUserQueryInputContext(hImc, InputContextThread);
        HKL           hKL = GetKeyboardLayout(dwImcThreadId);

        if (IS_IME_KBDLAYOUT(hKL)) {
            RIPMSG1(RIP_WARNING, "CtfImmIsGuidMapEnable: hKL=%lx.", hKL);
            return FALSE;
        }

        pImeDpi = FindOrLoadImeDpi(hKL);
        if (pImeDpi == NULL) {
            RIPMSG0(RIP_WARNING, "CtfImmIsGuidMapEnable: no pImeDpi entry.");
        }
        else {
            /*
             * Get GUID atom value
             */
            ret = (*pImeDpi->pfn.CtfImeIsGuidMapEnable)(hImc);
            ImmUnlockImeDpi(pImeDpi);
        }
    }

    return ret;
}

//+---------------------------------------------------------------------------
//
// CtfImmSetAppCompatFlags
//
//----------------------------------------------------------------------------

DWORD g_aimm_compat_flags = 0;

VOID
CtfImmSetAppCompatFlags(
    DWORD dwFlag)
{
    if (dwFlag & ~(IMECOMPAT_AIMM_LEGACY_CLSID |
                   IMECOMPAT_AIMM_TRIDENT55 |
                   IMECOMPAT_AIMM12_TRIDENT |
                   IMECOMPAT_AIMM12))
    {
        return;
    }

    g_aimm_compat_flags = dwFlag;
}

//+---------------------------------------------------------------------------
//
// ActivateOrDeactivateTIM
//
//----------------------------------------------------------------------------

HRESULT
ActivateOrDeactivateTIM(
    BOOL fActivate)
{
    HRESULT hr = S_OK;

    if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
        if (GetClientInfo()->CI_flags & CI_CUAS_COINIT_CALLED) {
            if (! fActivate) {
                /*
                 * Deactivate TIM
                 */
                if (GetClientInfo()->CI_flags & CI_CUAS_TIM_ACTIVATED) {
                    hr = Internal_CtfImeDestroyThreadMgr();
                    if (SUCCEEDED(hr)) {
                        GetClientInfo()->CI_flags &= ~CI_CUAS_TIM_ACTIVATED;
                        RIPMSG0(RIP_VERBOSE, "CtfImmLastEnabledWndDestroy: Succeeded CtfImeDestroyThreadMgr.");
                    }
                    else {
                        RIPMSG0(RIP_WARNING, "CtfImmLastEnabledWndDestroy: Fail CtfImeDestroyThreadMgr.");
                    }

                }
            }
            else {
                /*
                 * Activate TIM
                 */
                if (! (GetClientInfo()->CI_flags & CI_CUAS_TIM_ACTIVATED)) {
                    hr = Internal_CtfImeCreateThreadMgr();
                    if (SUCCEEDED(hr)) {
                        GetClientInfo()->CI_flags |= CI_CUAS_TIM_ACTIVATED;
                        RIPMSG0(RIP_VERBOSE, "CtfImmLastEnabledWndDestroy: Succeeded CtfImeDestroyThreadMgr.");
                    }
                    else {
                        RIPMSG0(RIP_WARNING, "CtfImmLastEnabledWndDestroy: Fail CtfImeDestroyThreadMgr.");
                    }
                }
            }
        }

    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// CtfImmLastEnabledWndDestroy
//     LPARAM 0 = Deactivate TIM.
//            ! 0 = Activate TIM.
//
//----------------------------------------------------------------------------

HRESULT 
CtfImmLastEnabledWndDestroy(
    LPARAM lParam)
{
    return ActivateOrDeactivateTIM(lParam ? TRUE : FALSE);
}

//+---------------------------------------------------------------------------
//
// ImmSetLangBand
//
//----------------------------------------------------------------------------

// TM_LANGUAGEBAND is defined in "shell\inc\trayp.h"
#define TM_LANGUAGEBAND     WM_USER+0x105

typedef struct _LANG_BAND {
    HWND hwndTray;
    BOOL fLangBand;
} LANG_BAND;

DWORD
DelaySetLangBand(
    LANG_BAND* langband)
{
    HWND hwndIME;

    //
    // Delay 3000msec.
    // If this delay value is not enough, Explorer takes CPU power 100%.
    // printui!CTrayNotify::_ResetAll
    //
    Sleep(3000);

    hwndIME = ImmGetDefaultIMEWnd(langband->hwndTray);
    if (hwndIME) {
        DWORD_PTR dwResult;
        LRESULT lResult = (LRESULT)0;

        lResult = SendMessageTimeout(hwndIME,
                                     WM_IME_SYSTEM,
                                     langband->fLangBand ? IMS_SETLANGBAND : IMS_RESETLANGBAND,
                                     (LPARAM)langband->hwndTray,
                                     SMTO_ABORTIFHUNG | SMTO_BLOCK,
                                     5000,
                                     &dwResult);

        //
        // Checking the language band setting fail case
        //
        if (!lResult || dwResult != langband->fLangBand)
        {
            // UserAssert(0);
        }
    }

    ImmLocalFree(langband);

    return 0;
}

LRESULT
CtfImmSetLangBand(
    HWND hwndTray,
    BOOL fLangBand)
{
    DWORD_PTR dwResult = 0;
    PWND pwnd;

    // check if the window of the Explorer Tray is valid
    if ((pwnd = ValidateHwnd(hwndTray)) == NULL) {
        RIPMSG1(RIP_WARNING, "CtfImmSetLangBand: Invalid hwndTray %lx.", hwndTray);
    } else {
        if (TestWF(pwnd, WFISINITIALIZED)) {    // TRUE if the Explorer Tray is initialized
            LRESULT lResult = (LRESULT)0;

            lResult = SendMessageTimeout(hwndTray,
                                         TM_LANGUAGEBAND,
                                         0,
                                         fLangBand,
                                         SMTO_ABORTIFHUNG | SMTO_BLOCK,
                                         5000,
                                         &dwResult);

            //
            // Checking the language band setting fail case
            //
            if (!lResult || dwResult != fLangBand)
            {
                // UserAssert(0);
            }
        }
        else {
            LANG_BAND* langband = (LANG_BAND*) ImmLocalAlloc(0, sizeof(LANG_BAND));
            if (langband != NULL) {
                HANDLE hThread;
                DWORD ThreadId;

                langband->hwndTray = hwndTray;
                langband->fLangBand = fLangBand;

                hThread = CreateThread(NULL,
                                       0,
                                       DelaySetLangBand,
                                       langband,
                                       0,
                                       &ThreadId);
                if (hThread) {
                    CloseHandle(hThread);
                }
            }
        }
    }
    return dwResult;
}

BOOL
CtfImmIsCiceroEnabled()
{
    return IS_CICERO_ENABLED();
}

BOOL
CtfImmIsCiceroStartedInThread()
{
    return (GetClientInfo()->CI_flags & CI_CUAS_MSCTF_RUNNING) ? TRUE : FALSE;
}

HRESULT
CtfImmSetCiceroStartInThread(BOOL fSet)
{
    if (fSet)
        GetClientInfo()->CI_flags |= CI_CUAS_MSCTF_RUNNING;
    else
        GetClientInfo()->CI_flags &= ~CI_CUAS_MSCTF_RUNNING;
    return S_OK;
}

BOOL
IsCUASEnabled()
{
    LONG lRet;
    HKEY hKeyCtf;
    DWORD dwType;
    DWORD dwCUAS;
    DWORD dwTmp;

    lRet = RegOpenKey(HKEY_LOCAL_MACHINE, gszRegCtfShared, &hKeyCtf);
    if ( lRet != ERROR_SUCCESS ) {
        return FALSE;
    }

    dwType = 0;
    dwCUAS = 0;
    dwTmp = sizeof(DWORD);
    lRet = RegQueryValueEx(hKeyCtf,
                           gszValCUASEnable,
                           NULL,
                           &dwType,
                           (LPBYTE)&dwCUAS,
                           &dwTmp);
    RegCloseKey(hKeyCtf);

    if ( lRet != ERROR_SUCCESS  ||  dwType != REG_DWORD) {
        return FALSE;
    }

    return (BOOL)dwCUAS;
}

//+---------------------------------------------------------------------------
//
// ImmDisableTextFrameService
//
//----------------------------------------------------------------------------

BOOL
ImmDisableTextFrameService(DWORD idThread)
{
    HRESULT hr = S_OK;

    if (idThread == -1)
    {
        // Text frame service processing is disabled for all the thread in the current process
        g_disable_CUAS_flag = TRUE;
    }

    if ((idThread == 0 || g_disable_CUAS_flag) &&
        (! (GetClientInfo()->CI_flags & CI_CUAS_DISABLE)))
    {
        /*
         * set client info flag.
         */
        GetClientInfo()->CI_flags |= CI_CUAS_DISABLE;

        if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
            if (GetClientInfo()->CI_flags & CI_CUAS_COINIT_CALLED) {
                /*
                 * Deactivate TIM
                 */
                if (GetClientInfo()->CI_flags & CI_CUAS_TIM_ACTIVATED) {
                    hr = Internal_CtfImeDestroyThreadMgr();
                    if (SUCCEEDED(hr)) {
                        GetClientInfo()->CI_flags &= ~CI_CUAS_TIM_ACTIVATED;
                        RIPMSG0(RIP_VERBOSE, "ImmDisableTextFrameService: Succeeded CtfImeDestroyThreadMgr.");
                    }
                    else {
                        RIPMSG0(RIP_WARNING, "ImmDisableTextFrameService: Fail CtfImeDestroyThreadMgr.");
                    }

                    if (SUCCEEDED(hr)) {
                        /*
                         * CoUninitialize
                         */
                        CtfImmCoUninitialize();
                    }
                }
            }
        }
    }

    return hr == S_OK ? TRUE : FALSE;
}

BOOL
CtfImmIsTextFrameServiceDisabled()
{
    return (GetClientInfo()->CI_flags & CI_CUAS_DISABLE) ? TRUE : FALSE;
}

BOOL
IsDisabledTextServices()
{
    static const TCHAR c_szCTFKey[]     = TEXT("SOFTWARE\\Microsoft\\CTF");
    static const TCHAR c_szDiableTim[]  = TEXT("Disable Thread Input Manager");

    HKEY hKey;

    if (RegOpenKey(HKEY_CURRENT_USER, c_szCTFKey, &hKey) == ERROR_SUCCESS)
    {
        DWORD cb;
        DWORD dwDisableTim = 0;

        cb = sizeof(DWORD);

        RegQueryValueEx(hKey,
                        c_szDiableTim,
                        NULL,
                        NULL,
                        (LPBYTE)&dwDisableTim,
                        &cb);

        RegCloseKey(hKey);

        //
        // Ctfmon disabling flag is set.
        //
        if (dwDisableTim)
            return TRUE;
    }

    return FALSE;
}

BOOL
IsInteractiveUserLogon()
{
    PSID InteractiveSid;
    BOOL bCheckSucceeded;
    BOOL bAmInteractive = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  1,
                                  SECURITY_INTERACTIVE_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &InteractiveSid))
    {
        return FALSE;
    }

    //
    // This checking is for logged on user or not. So we can blcok running
    // ctfmon.exe process from non-authorized user.
    //
    bCheckSucceeded = CheckTokenMembership(NULL,
                                           InteractiveSid,
                                           &bAmInteractive);

    if (InteractiveSid)
        FreeSid(InteractiveSid);

    return (bCheckSucceeded && bAmInteractive);
}

//+---------------------------------------------------------------------------
//
// IsRunningInMsoobe()
//
//----------------------------------------------------------------------------
BOOL IsRunningInMsoobe()
{
static const TCHAR c_szMsoobeModule[] = TEXT("msoobe.exe");

    TCHAR  szFileName[MAX_PATH];
    TCHAR szModuleName[MAX_PATH];
    LPTSTR pszFilePart = NULL;

    if (GetModuleFileName(NULL, szFileName, sizeof(szFileName)/sizeof(szFileName[0])) == 0)
        return FALSE;

    GetFullPathName(szFileName, 
                    sizeof(szFileName)/sizeof(szFileName[0]),
                    szModuleName,
                    &pszFilePart);

    if (pszFilePart == NULL)
        return FALSE;

    if (lstrcmpiW(pszFilePart, c_szMsoobeModule) == 0)
        return TRUE;

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// LoadCtfIme
//
//----------------------------------------------------------------------------

BOOL CheckAndApplyAppCompat(LPWSTR wszImeFile);

typedef HRESULT (CALLBACK* PFNCREATETHREADMGR)();
typedef HRESULT (CALLBACK* PFNDESTROYTHREADMGR)();
typedef HRESULT (CALLBACK* PFNCREATEINPUTCONTEXT)(HIMC);
typedef HRESULT (CALLBACK* PFNDESTROYINPUTCONTEXT)(HIMC);
typedef HRESULT (CALLBACK* PFNSETACTIVECONTEXTALWAYS)(HIMC, BOOL, HWND, HKL);
typedef BOOL    (CALLBACK* PFNPROCESSCICHOTKEY)(HIMC, UINT, LPARAM);
typedef LRESULT (CALLBACK* PFNDISPATCHDEFIMEMESSAGE)(HWND, UINT, WPARAM, LPARAM);
typedef BOOL    (CALLBACK* PFNIMEISIME)(HKL);



PFNCREATETHREADMGR           g_pfnCtfImeCreateThreadMgr = NULL;
PFNDESTROYTHREADMGR          g_pfnCtfImeDestroyThreadMgr = NULL;
PFNCREATEINPUTCONTEXT        g_pfnCtfImeCreateInputContext = NULL;
PFNDESTROYINPUTCONTEXT       g_pfnCtfImeDestroyInputContext= NULL;
PFNSETACTIVECONTEXTALWAYS    g_pfnCtfImeSetActiveContextAlways= NULL;
PFNPROCESSCICHOTKEY          g_pfnCtfImeProcessCicHotkey = NULL;
PFNDISPATCHDEFIMEMESSAGE     g_pfnCtfImeDispatchDefImeMessage = NULL;
PFNIMEISIME                  g_pfnCtfImeIsIME = NULL;

#define GET_CTFIMEPROC(x) \
    if (!(g_pfn##x = (PVOID) GetProcAddress(g_hCtfIme, #x))) {   \
        RIPMSG0(RIP_WARNING, "LoadCtfIme: " #x " not supported"); \
        goto LoadCtfIme_ErrOut; }

HMODULE g_hCtfIme = NULL; 

HMODULE LoadCtfIme()
{
    IMEINFOEX iiex;

    RtlEnterCriticalSection(&gcsImeDpi);

    if (g_hCtfIme)
        goto Exit;

    if (ImmLoadLayout((HKL)0x04090409, &iiex)) {
        WCHAR wszImeFile[MAX_PATH];

        GetSystemPathName(wszImeFile, iiex.wszImeFile, MAX_PATH);

        if (!CheckAndApplyAppCompat(wszImeFile)) {
            RIPMSG1(RIP_WARNING, "LoadCtfIme: IME (%ws) blocked by appcompat", wszImeFile);
        }
        else {
            g_hCtfIme = LoadLibraryW(wszImeFile);
            if (g_hCtfIme) {
                GET_CTFIMEPROC(CtfImeCreateThreadMgr);
                GET_CTFIMEPROC(CtfImeDestroyThreadMgr);
                GET_CTFIMEPROC(CtfImeCreateInputContext);
                GET_CTFIMEPROC(CtfImeDestroyInputContext);
                GET_CTFIMEPROC(CtfImeSetActiveContextAlways);
                GET_CTFIMEPROC(CtfImeProcessCicHotkey);
                GET_CTFIMEPROC(CtfImeDispatchDefImeMessage);
                GET_CTFIMEPROC(CtfImeIsIME);
            }
        }
    }
    goto Exit;

LoadCtfIme_ErrOut:
    if (g_hCtfIme) {
        FreeLibrary(g_hCtfIme);
        g_hCtfIme = NULL;
    }

Exit:

    RtlLeaveCriticalSection(&gcsImeDpi);
    return g_hCtfIme;
}


//+---------------------------------------------------------------------------
//
// CtfAImmCreateInputContext
//
//----------------------------------------------------------------------------

HRESULT CtfAImmCreateInputContext(HIMC himc)
{
    return Internal_CtfImeCreateInputContext(himc);
}

//+---------------------------------------------------------------------------
//
// EnumIMC
//
//----------------------------------------------------------------------------

BOOL EnumIMC(HIMC hIMC, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
    CtfAImmCreateInputContext(hIMC);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// CtfAImmActivate
//
//----------------------------------------------------------------------------

HRESULT CtfAImmActivate(HMODULE* phMod)
{
    HRESULT hr = E_FAIL;
    HMODULE hCtfIme = LoadCtfIme();

    hr = Internal_CtfImeCreateThreadMgr();
    if (hr == S_OK)
    {

        GetClientInfo()->CI_flags |= CI_CUAS_AIMM12ACTIVATED;

        /*
         * reset client info flag.
         * Bug#525583 - Reset CU_CUAS_DISABLE flag before create
         * the input context.
         */
        GetClientInfo()->CI_flags &= ~CI_CUAS_DISABLE;

        ImmEnumInputContext(0, EnumIMC, 0);
    }

    if (phMod)
        *phMod = hCtfIme;

    return hr;
}

//+---------------------------------------------------------------------------
//
// CtfAImmDectivate
//
//----------------------------------------------------------------------------

HRESULT CtfAImmDeactivate(HMODULE hMod)
{
    HRESULT hr = E_FAIL;

    //
    // Load CTFIME and destroy TIM.
    //
    if (hMod)
    {
        hr = Internal_CtfImeDestroyThreadMgr();
        if (hr == S_OK)
        {
            GetClientInfo()->CI_flags &= ~CI_CUAS_AIMM12ACTIVATED;
            /*
             * set client info flag.
             */
            GetClientInfo()->CI_flags |= CI_CUAS_DISABLE;
        }
        //
        // Win BUG: 611569
        //
        // Don't call FreeLibrary because LoadCtfIme() hold CTFIME module handle in global.
        //
        // FreeLibrary(hMod);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CtfAImmIsIME
//
//----------------------------------------------------------------------------

BOOL CtfAImmIsIME(HKL hkl)
{
    if (LoadCtfIme())
        return (g_pfnCtfImeIsIME)(hkl);

    return ImmIsIME(hkl);
}

//+---------------------------------------------------------------------------
//
// CtfImmDispatchDefImeMessage
//
//----------------------------------------------------------------------------

LRESULT CtfImmDispatchDefImeMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{

    if (RtlDllShutdownInProgress() || _InsideLoaderLock())
        return 0;

    if (LoadCtfIme())
    {
        return (g_pfnCtfImeDispatchDefImeMessage)(hwnd, message, wParam, lParam);
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
// Internal_CtfImeCreateThreadMgr
//
//----------------------------------------------------------------------------

HRESULT Internal_CtfImeCreateThreadMgr()
{
    if (!LoadCtfIme())
        return E_FAIL;

    return (g_pfnCtfImeCreateThreadMgr)();
}

//+---------------------------------------------------------------------------
//
// Internal_CtfImeDestroyThreadMgr
//
//----------------------------------------------------------------------------

HRESULT Internal_CtfImeDestroyThreadMgr()
{
    if (!LoadCtfIme())
        return E_FAIL;

    return (g_pfnCtfImeDestroyThreadMgr)();
}
            
//+---------------------------------------------------------------------------
//
// Internal_CtfImeProcessCicHotkey
//
//----------------------------------------------------------------------------

BOOL Internal_CtfImeProcessCicHotkey(HIMC hIMC, UINT uVKey, LPARAM lParam)
{
    if (!LoadCtfIme())
        return FALSE;

    return (g_pfnCtfImeProcessCicHotkey)(hIMC, uVKey, lParam);
}

//+---------------------------------------------------------------------------
//
// Internal_CtfImeCreateInputContext
//
//----------------------------------------------------------------------------

HRESULT Internal_CtfImeCreateInputContext(HIMC himc)
{
    if (!LoadCtfIme())
        return E_FAIL;

    return (g_pfnCtfImeCreateInputContext)(himc);
}

//+---------------------------------------------------------------------------
//
// Internal_CtfImeDestroyInputContext
//
//----------------------------------------------------------------------------

HRESULT Internal_CtfImeDestroyInputContext(HIMC himc)
{
    if (!LoadCtfIme())
        return E_FAIL;

    return (g_pfnCtfImeDestroyInputContext)(himc);
}

//+---------------------------------------------------------------------------
//
// Internal_CtfImeSetActiveContextAlways
//
//----------------------------------------------------------------------------

HRESULT Internal_CtfImeSetActiveContextAlways(HIMC himc, BOOL fActive, HWND hwnd, HKL hkl)
{
    if (!LoadCtfIme())
        return E_FAIL;

    return (g_pfnCtfImeSetActiveContextAlways)(himc, fActive, hwnd, hkl);
}



#else
void CtfImmGetGuidAtom() { }
void CtfImmHideToolbarWnd() { }
void CtfImmIsGuidMapEnable() { }
void CtfImmRestoreToolbarWnd() { }
void CtfImmSetAppCompatFlags() { }
void CtfImmTIMActivate() { }
void CtfImmIsCiceroEnabled() { }
void CtfImmDispatchDefImeMessage() { }
#endif // CUAS_ENABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\clwinnls.c ===
/****************************** Module Header ******************************\
* Module Name: clwinnls.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the code for the NT 3.x IMM API functions.
*
* History:
* 11-Jan-1995 wkwok      Created.
* 07-May-1996 takaok     Cleaned up.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL CheckCountry();
BOOL ImmEnableIME( HWND hwnd, BOOL fEnable );
BOOL IMPGetIMEWorker( HKL hkl, LPIMEPROW lpImeProW );
VOID ConvertImeProWtoA( LPIMEPROA lpImeProA, LPIMEPROW lpImeProW );
LRESULT SendIMEMessageAll( HWND hwndApp, HANDLE lParam, BOOL fAnsi );

BOOL ImmWINNLSEnableIME(
    HWND  hwndApp,
    BOOL  bFlag)
{
    if ( ! CheckCountry() ) {
        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
        return FALSE;
    }
    return ImmEnableIME( hwndApp, bFlag );
}

//
// returns the "enable/disable" state of the
// caller thread's default input context.
//
BOOL ImmWINNLSGetEnableStatus(
    HWND hwndApp)
{
    if ( ! CheckCountry() ) {
        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
        return FALSE;
    }

    return (ImmGetSaveContext(hwndApp, IGSC_WINNLSCHECK) != NULL_HIMC);
}


UINT WINAPI ImmWINNLSGetIMEHotkey(
    HWND hwndIme)
{
    UNREFERENCED_PARAMETER(hwndIme);

    //
    // Win95/NT3.51 behavior, i.e. always return 0.
    //
    return 0;
}


/***************************************************************************\
*
*         IME APIs
*
\***************************************************************************/

LRESULT WINAPI ImmSendIMEMessageExW(
    HWND   hwndApp,
    LPARAM lParam)
{
    return SendIMEMessageAll( hwndApp, (HANDLE)lParam, FALSE );
}

LRESULT WINAPI ImmSendIMEMessageExA(
    HWND   hwndApp,
    LPARAM lParam)
{
    return SendIMEMessageAll( hwndApp, (HANDLE)lParam, TRUE );
}

LRESULT SendIMEMessageAll(
    HWND hwndApp,
    HANDLE hMemImeStruct,
    BOOL fAnsi )
{
    HWND hWnd;
    LPIMESTRUCT lpIme;
    LRESULT lResult;

#ifdef LATER
  // Need for MSTEST30a(32bit)...
  // If different process of hWnd in SendIMEMessageEx, then we should be inter-send messag
on this.
    if (PtiCurrent() != pti) {
        HWND hDefIMEWnd = ImmGetDefaultIMEWnd(hWnd);
        if (hDefIMEWnd)
            return SendMessage(hDefIMEWnd,WM_CONVERTREQUESTEX,(WPARAM)hWnd,lParam);
    }
#endif

    //
    // the passed handle must be the handle of
    // global memory block.
    //
    lpIme = (LPIMESTRUCT)GlobalLock( hMemImeStruct );
    if ( lpIme == NULL ) {
        return (FALSE);
    }

    if ( ! CheckCountry( ) ) {

        lpIme->wParam = IME_RS_INVALID;
        GlobalUnlock( hMemImeStruct );
        return (FALSE);
    }

    //
    // We don't need to handle if it's non-IME layout
    //
    if ( ! ImmIsIME( GetKeyboardLayout(0) ) ) {

        lpIme->wParam = IME_RS_INVALID;
        GlobalUnlock( hMemImeStruct );
        return (FALSE);
    }

    //
    // check if the initialize of IMM has been done.
    //
    if ( !IsWindow(ImmGetDefaultIMEWnd(hwndApp)) ) {
        //
        // for Win3.1/Win95 compatibility
        // we need to return TRUE here.
        //
        // PPT4 calls SendImeMessage at the very
        // early stage of initialization. If we
        // return FALSE here, it thinks IME is
        // not available.
        //
        if ( lpIme->fnc == 0x07 )  // IME_GETVERSION
            //
            // Excel5.0J calls this function at the early stage
            // and we need to return version number.
            //
            lResult = IMEVER_31;
        else
            lResult = TRUE;

        GlobalUnlock( hMemImeStruct );
        return lResult;
    }

    //
    // caller may give us NULL window handle...
    //
    if ( !IsWindow(hwndApp) ) {
        hWnd = GetFocus();
    } else {
        hWnd = hwndApp;
    }

    lResult = TranslateIMESubFunctions( hWnd, lpIme, fAnsi );
    GlobalUnlock( hMemImeStruct );

    return lResult;
}


/***************************************************************************\
*
*        IMP APIs
*
\***************************************************************************/


BOOL WINAPI ImmIMPGetIMEW(
    HWND hwndApp,
    LPIMEPROW lpImeProW)
{
    UNREFERENCED_PARAMETER(hwndApp);

    if ( ! CheckCountry() ) {
        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
        return FALSE;
    }
    return IMPGetIMEWorker( GetKeyboardLayout(0), lpImeProW );

}

BOOL WINAPI ImmIMPGetIMEA(
    HWND hwndApp,
    LPIMEPROA lpImeProA)
{
    IMEPROW ImeProW;

    UNREFERENCED_PARAMETER(hwndApp);

    if ( ! CheckCountry() ) {
        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
        return FALSE;
    }
    if ( IMPGetIMEWorker( GetKeyboardLayout(0), &ImeProW ) ) {
        ConvertImeProWtoA( lpImeProA, &ImeProW );
        return TRUE;
    }
    return FALSE;
}

VOID ConvertImeProWtoA( LPIMEPROA lpImeProA, LPIMEPROW lpImeProW )
{
    lpImeProA->hWnd = lpImeProW->hWnd;
    lpImeProA->InstDate = lpImeProW->InstDate;
    lpImeProA->wVersion = lpImeProW->wVersion;

    WideCharToMultiByte( CP_ACP, 0,
                         lpImeProW->szDescription, -1,
                         lpImeProA->szDescription, sizeof(lpImeProA->szName),
                         NULL, NULL );

    WideCharToMultiByte( CP_ACP, 0,
                         lpImeProW->szName, -1,
                         lpImeProA->szName, sizeof(lpImeProA->szName),
                         NULL, NULL );

    lpImeProA->szOptions[0] = '\0';
}

DATETIME   CleanDate = {0};

BOOL IMPGetIMEWorker( HKL hkl, LPIMEPROW lpImeProW )
{
    IMEINFOEX iiex;

    if ( ImmGetImeInfoEx( &iiex, ImeInfoExKeyboardLayout, (PVOID)&hkl) ) {

        lpImeProW->hWnd = NULL;
        lpImeProW->InstDate = CleanDate;
        lpImeProW->wVersion = iiex.dwImeWinVersion;
        lstrcpynW( lpImeProW->szDescription, iiex.wszImeDescription, 50 );
        lstrcpynW( lpImeProW->szName, iiex.wszImeFile, 80 );
        lstrcpynW( lpImeProW->szOptions, TEXT(""), 1 );

        return TRUE;
    }

    return FALSE;
}


BOOL WINAPI ImmIMPQueryIMEW(
    LPIMEPROW lpImeProW)
{
    BOOL fResult = FALSE;
    INT numLayouts = 0;
    HKL *phklRoot = NULL;
    HKL *phkl = NULL;

    if ( ! CheckCountry() ) {
        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
        return FALSE;
    }

    //
    // get the number of keyboard layouts available
    //
    numLayouts = GetKeyboardLayoutList( 0, NULL );
    if ( numLayouts > 0 ) {
        //
        // allocate the buffer for the array of layouts.
        // +1 for a NULL sentinel
        //
        phklRoot = ImmLocalAlloc( 0, (numLayouts+1) * sizeof(HKL) );
        if ( phklRoot != NULL ) {
            //
            // get the keyboard layouts
            //
            if ( GetKeyboardLayoutList( numLayouts, phklRoot ) == numLayouts ) {
                //
                // put a NULL sentinel at the end of the buffer
                //
                *(phklRoot+numLayouts) = (HKL)NULL;

                if ( lpImeProW->szName[0] == L'\0' ) {
                //
                // This is the first call of IMPQueryIME
                // We will start at the first layout.
                //
                    phkl = phklRoot;

                } else {
                //
                // The caller specifies the name of IME.
                // We will start at the next layout.
                // Note this assumes that the order of keyboard  layouts
                // returned by GetKeyboardLayoutList() is not changed
                // between calls. ( Though actually there is no such
                // guarantee, we ignore the chance of the changing
                // the list of keyboard layouts for now. )
                //
                    IMEINFOEX iiex;
                    //
                    // Let's retrieve the corresponding hkl
                    // from the IME filename specified by the caller.
                    //
                    if ( ImmGetImeInfoEx( &iiex,
                                         ImeInfoExImeFileName,
                                         (PVOID)lpImeProW->szName ) ) {
                        //
                        // let phkl point to the next hkl
                        //
                        phkl = phklRoot;
                        while ( *phkl != NULL ) {
                            if ( *phkl++ == iiex.hkl ) {
                                break;
                            }
                        }
                    }
                }
                if ( phkl != NULL ) {
                    while ( *phkl != NULL ) {
                        //
                        // IMPGetIMEWorker will return FALSE if
                        // the hkl specified is a non-IME layout.
                        //
                        if ( fResult = IMPGetIMEWorker(*phkl++, lpImeProW) ) {
                            break;
                        }
                    }
                }
            }
            ImmLocalFree( phklRoot );
        }
    }
    return fResult;
}

BOOL WINAPI ImmIMPQueryIMEA(
    LPIMEPROA lpImeProA)
{

    IMEPROW    ImeProW;

    if ( ! CheckCountry() ) {
        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
        return FALSE;
    }

    if ( lpImeProA->szName[0] != '\0' ) {
    //
    // Convert MultiByteString(szName) to UnicodeString
    //
        INT i;

        i = MultiByteToWideChar( CP_ACP, (DWORD)MB_PRECOMPOSED,
                                 lpImeProA->szName,
                                 -1,
                                 ImeProW.szName,
                                 (INT)sizeof(ImeProW.szName)/sizeof(WCHAR));
        if ( i == 0 ) {
            return FALSE;
        }

    } else {
        ImeProW.szName[0] = L'\0';
    }

    if ( ImmIMPQueryIMEW( &ImeProW ) ) {
        ConvertImeProWtoA( lpImeProA, &ImeProW );
        return TRUE;
    }
    return FALSE;
}

BOOL WINAPI ImmIMPSetIMEW(
    HWND hwndApp,
    LPIMEPROW lpImeProW)
{
    IMEINFOEX iiex;
    HKL hkl = NULL;

    UNREFERENCED_PARAMETER(hwndApp);

    if ( ! CheckCountry() ) {
        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
        return FALSE;
    }

    if ( lpImeProW->szName[0] != L'\0' ) {
    //
    // IME name is specified. Switch to the IME specified.
    //
        if ( ImmGetImeInfoEx(&iiex,ImeInfoExImeFileName,(PVOID)lpImeProW->szName) ) {
            hkl = iiex.hkl;
        }
    } else {
    //
    // IME name is not specified. Switch to a non-IME layout
    //
        INT numLayouts;
        HKL   *phkl;
        HKL   *phklRoot;

        numLayouts = GetKeyboardLayoutList( 0, NULL );
        if ( numLayouts > 0 ) {
            phkl = phklRoot = ImmLocalAlloc( 0, (numLayouts + 1) * sizeof(HKL) );
            if ( phkl != NULL ) {
                if ( GetKeyboardLayoutList( numLayouts, phkl ) == numLayouts ) {
                    *(phklRoot+numLayouts) = (HKL)NULL;
                    while ( *phkl != NULL ) {
                        if ( ! ImmIsIME( *phkl ) ) {
                            hkl = *phkl;
                            break;
                        }
                        phkl++;
                    }
                }
                ImmLocalFree( phklRoot );
            }
        }
    }

    if ( hkl != NULL && GetKeyboardLayout(0) != hkl ) {
        HWND hwndFocus;

        hwndFocus = GetFocus();
        if ( hwndFocus != NULL ) {
            PostMessage( hwndFocus,
                         WM_INPUTLANGCHANGEREQUEST,
                         DEFAULT_CHARSET,
                         (LPARAM)hkl);
            return TRUE;
        }
    }
    return FALSE;
}

BOOL WINAPI ImmIMPSetIMEA(
    HWND hwndApp,
    LPIMEPROA lpImeProA)
{
    IMEPROW ImeProW;

    UNREFERENCED_PARAMETER(hwndApp);

    if ( ! CheckCountry() ) {
        SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
        return FALSE;
    }

    if ( lpImeProA->szName[0] != '\0' ) {
    //
    // Convert MultiByteString(szName) to UnicodeString
    //
        INT i;

        i = MultiByteToWideChar( CP_ACP, (DWORD)MB_PRECOMPOSED,
                                 lpImeProA->szName,
                                 -1,
                                 ImeProW.szName,
                                 (INT)sizeof(ImeProW.szName)/sizeof(WCHAR));
        if ( i == 0 ) {
            return FALSE;
        }

    } else {
        ImeProW.szName[0] = L'\0';
    }
    return ImmIMPSetIMEW(hwndApp, &ImeProW);
}

//
// if the "enable/disable" state of the default input context
// of the caller thread is same as the state specified by
// fEnalble parameter, this function does nothing but returns
// the current "enable/disable" state.
//
// if fEnable is FALSE, this function disables the default
// input context of caller thread.
//
// if fEnable is TRUE, this function enables the default
// input context of caller thread.
//
//
BOOL ImmEnableIME(
    HWND hwnd,
    BOOL fEnable
    )
{
    HIMC hImc;
    PCLIENTIMC pClientImc;
    BOOL fCurrentState;
    HWND hwndFocus;
    BOOL fImeInitialized;

    //
    // Get the caller thread's default input context
    //
    hImc = (HIMC)NtUserGetThreadState(UserThreadStateDefaultInputContext);
    if ( hImc == NULL_HIMC ) {
        return FALSE;
    }
    pClientImc = ImmLockClientImc( hImc );
    if ( pClientImc == NULL ) {
        return FALSE;
    }

    //
    // we will return the curren t"enable/disable" state of the input context
    //
    fCurrentState =  TestICF(pClientImc, IMCF_WINNLSDISABLE) ? FALSE : TRUE;

    //
    // if the current thread (caller thread) doesn't have the focus window,
    // UI windows will not be updated. When we're called later, we will end
    // up to just return the fCurrentState without calling ImmSetActiveContext.
    // To avoid that, the "same status" check below is disabled...

    if ( (fCurrentState && fEnable) || (!fCurrentState && !fEnable) ) {
       ImmUnlockClientImc( pClientImc );
        //
        // nothing has been changed. return the current state
        //
        return fCurrentState;
    }


    if ( ! IsWindow(hwnd) ) {
        hwndFocus = GetFocus();
    } else {
        hwndFocus = hwnd;
    }

    //
    // check if the initialize of IMM has been done.
    //
    if ( IsWindow(ImmGetDefaultIMEWnd(hwndFocus)) ) {
        fImeInitialized = TRUE;
    } else {
        fImeInitialized = FALSE;
    }

    if ( fImeInitialized ) {
        if ( ! fEnable ) {
        //
        // we're going to disable the target IMC
        //
            //
            // make the target IMC non-active
            //
            ImmSetActiveContext( hwndFocus, hImc, FALSE );

        } else {
        //
        // we're going to enable the target IMC
        //
            //
            // make NULL context non-active
            //
            ImmSetActiveContext( hwndFocus, NULL_HIMC, FALSE );
        }
    }

    //
    // update the state of the input context
    //
    if ( fEnable )
        ClrICF( pClientImc, IMCF_WINNLSDISABLE );
    else
        SetICF( pClientImc, IMCF_WINNLSDISABLE );
    ImmUnlockClientImc( pClientImc );


    if ( fImeInitialized ) {
        if ( fEnable ) {
        //
        // we're going to enable the target IMC
        //
            //
            // make the target IMC active
            //
            ImmSetActiveContext( hwndFocus, hImc, TRUE );
        } else {
        //
        // we're going to disable the target IMC
        //
            //
            // make NULL context active
            //
            ImmSetActiveContext( hwndFocus, NULL_HIMC, TRUE );
        }
    }

    //
    // the return value is previous state
    //
    return fCurrentState;
}

BOOL CheckCountry()
{
    WORD LangId;

    LangId = PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID()));
    if ( LangId == LANG_JAPANESE || LangId == LANG_KOREAN ) {
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\conime.c ===
/**************************************************************************\
* Module Name: conime.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* client side receiveing stubs
*
* History:
* 19-Sep-1995 v-HirShi Created
* 12-Jun-1996 v-HirShi Attached to SUR
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#define GUI_VKEY_MASK (0x00ff)

DWORD
ImmProcessKey(
    HWND hWnd,
    HKL  hkl,
    UINT uVKey,
    LPARAM lParam,
    DWORD dwHotKeyID
    ) ;

BOOL
ImmSetActiveContext(
    HWND   hWnd,
    HIMC   hIMC,
    BOOL   fFlag
    ) ;

DWORD
ImmCallImeConsoleIME(
    HWND   hWnd,
    UINT   Message,
    WPARAM wParam,
    LPARAM lParam,
    PUINT  puVKey
    )
/*++

Routine Description:

        Called by Console IME to convert Character
        This routine copy from user\kernel\ntimm.c :: xxxImmProcessKey
        for Console IME could not calls kernel function.

Arguments:

Return Value:
--*/
{
    DWORD          dwReturn ;
    PIMC           pImc ;
    HIMC           hImc ;
    BOOL           fDBERoman ;
    PWND           pwnd ;
    PIMEDPI        pImeDpi;
    HKL            hkl ;

    dwReturn = 0;
    pImc = NULL;
    fDBERoman = FALSE;

    //
    // we're interested in only keyboard messages.
    //
    if ( Message != WM_KEYDOWN    &&
         Message != WM_SYSKEYDOWN &&
         Message != WM_KEYUP      &&
         Message != WM_SYSKEYUP ) {

        return dwReturn;
    }

    hkl = GetKeyboardLayout( GetWindowThreadProcessId(hWnd, NULL) );
    pwnd = ValidateHwnd(hWnd);
    if ( pwnd == NULL) {
        return dwReturn;
    }
    hImc = ImmGetContext(hWnd);
    if ( hImc == NULL_HIMC ){
        return dwReturn;
    }

    *puVKey = (UINT)wParam & GUI_VKEY_MASK;

    //
    // Check input context
    //
    pImc = HMValidateHandle((HANDLE)hImc, TYPE_INPUTCONTEXT);
    if ( pImc == NULL ) {
        return dwReturn;
    }

#ifdef LATER
    //
    // If there is an easy way to check the input context open/close status
    // from the kernel side, IME_PROP_NO_KEYS_ON_CLOSE checking should be
    // done here in kernel side.  [ 3/10/96 takaok]
    //

    //
    // Check IME_PROP_NO_KEYS_ON_CLOSE bit
    //
    // if the current imc is not open and IME doesn't need
    // keys when being closed, we don't pass any keyboard
    // input to ime except hotkey and keys that change
    // the keyboard status.
    //
    if ( (piix->ImeInfo.fdwProperty & IME_PROP_NO_KEYS_ON_CLOSE) &&
         (!pimc->fdwState & IMC_OPEN)                            &&
         uVKey != VK_SHIFT                                       &&  // 0x10
         uVKey != VK_CONTROL                                     &&  // 0x11
         uVKey != VK_CAPITAL                                     &&  // 0x14
         uVKey != VK_KANA                                        &&  // 0x15
         uVKey != VK_NUMLOCK                                     &&  // 0x90
         uVKey != VK_SCROLL )                                        // 0x91
    {
      // Check if Korea Hanja conversion mode
      if( !(pimc->fdwConvMode & IME_CMODE_HANJACONVERT) ) {
          return dwReturn;
      }
    }
#endif

    //
    // if the IME doesn't need key up messages, we don't call ime.
    //
    pImeDpi = ImmLockImeDpi(hkl);
    if ( pImeDpi == NULL ) {
        return dwReturn;
    }

    if ( lParam & 0x80000000 &&          // set if key up, clear if key down
         pImeDpi->ImeInfo.fdwProperty & IME_PROP_IGNORE_UPKEYS )
    {
        return dwReturn;
    }

    //
    // we don't want to handle sys keys since many functions for
    // acceelerators won't work without this
    //
    fDBERoman = (BOOL)( (*puVKey == VK_DBE_ROMAN)            ||
                        (*puVKey == VK_DBE_NOROMAN)          ||
                        (*puVKey == VK_DBE_HIRAGANA)         ||
                        (*puVKey == VK_DBE_KATAKANA)         ||
                        (*puVKey == VK_DBE_CODEINPUT)        ||
                        (*puVKey == VK_DBE_NOCODEINPUT)      ||
                        (*puVKey == VK_DBE_IME_WORDREGISTER) ||
                        (*puVKey == VK_DBE_IME_DIALOG) );

    if (Message == WM_SYSKEYDOWN || Message == WM_SYSKEYUP ) {
        //
        // IME may be waiting for VK_MENU, VK_F10 or VK_DBE_xxx
        //
        if ( *puVKey != VK_MENU && *puVKey != VK_F10 && !fDBERoman ) {
            return dwReturn;
        }
    }

    //
    // check if the IME doesn't need ALT key
    //

    if ( !(pImeDpi->ImeInfo.fdwProperty & IME_PROP_NEED_ALTKEY) ) {
        //
        // IME doesn't need ALT key
        //
        // we don't pass the ALT and ALT+xxx except VK_DBE_xxx keys.
        //
        if ( ! fDBERoman &&
             (*puVKey == VK_MENU || (lParam & 0x20000000))  // KF_ALTDOWN
           )
        {
            return dwReturn;
        }
    }


    dwReturn = ImmProcessKey(hWnd, hkl, *puVKey, lParam, IME_INVALID_HOTKEY ) ;
    return dwReturn;
}

BOOL
ImmSetActiveContextConsoleIME(
    HWND   hWnd,
    BOOL   fFlag
    )

/*++

Routine Description:

    Set this context as active one.

Arguments:

    hWnd         - the get focus window
    fFlag        - get focus or kill focus

Return Value:

--*/

{
    HIMC hImc;

    hImc = ImmGetContext(hWnd) ;
    if (hImc == NULL_HIMC) {
        return FALSE;
    }
    return(ImmSetActiveContext(hWnd, hImc, fFlag)) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\context.c ===
/**************************************************************************\
* Module Name: context.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Context management routines for imm32 dll
*
* History:
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define IMCC_ALLOC_TOOLARGE             0x1000


/**************************************************************************\
* ImmCreateContext
*
* Creates and initializes an input context.
*
* 17-Jan-1996 wkwok       Created
\**************************************************************************/

HIMC WINAPI ImmCreateContext(void)
{
    PCLIENTIMC pClientImc;
    HIMC       hImc = NULL_HIMC;

    if (!IS_IME_ENABLED()) {
        return NULL_HIMC;
    }

    pClientImc = ImmLocalAlloc(HEAP_ZERO_MEMORY, sizeof(CLIENTIMC));

    if (pClientImc != NULL) {

        hImc = NtUserCreateInputContext((ULONG_PTR)pClientImc);
        if (hImc == NULL_HIMC) {
            ImmLocalFree(pClientImc);
            return NULL_HIMC;
        }

        InitImcCrit(pClientImc);
        pClientImc->dwImeCompatFlags = (DWORD)NtUserGetThreadState(UserThreadStateImeCompatFlags);
    }

    return hImc;
}


/**************************************************************************\
* ImmDestroyContext
*
* Destroys an input context.
*
* 17-Jan-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmDestroyContext(
    HIMC hImc)
{
    if (!IS_IME_ENABLED()) {
        return FALSE;
    }

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmDestroyContext: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    return DestroyInputContext(hImc, GetKeyboardLayout(0), FALSE);
}


/**************************************************************************\
* ImmAssociateContext
*
* Associates an input context to the specified window handle.
*
* 17-Jan-1996 wkwok       Created
\**************************************************************************/

HIMC WINAPI ImmAssociateContext(
    HWND hWnd,
    HIMC hImc)
{
    PWND  pWnd;
    HIMC  hPrevImc;
    AIC_STATUS Status;

    // early out
    if (!IS_IME_ENABLED()) {
        return NULL_HIMC;
    }

    if ((pWnd = ValidateHwnd(hWnd)) == (PWND)NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmAssociateContext: invalid window handle %x", hWnd);
        return NULL_HIMC;
    }



    if (hImc != NULL_HIMC &&
            GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmAssociateContext: Invalid input context access %lx.", hImc);
        return NULL_HIMC;
    }

    /*
     * associate to the same input context, do nothing.
     */
    if (pWnd->hImc == hImc)
        return hImc;

    hPrevImc = KHIMC_TO_HIMC(pWnd->hImc);

    Status = NtUserAssociateInputContext(hWnd, hImc, 0);

    switch (Status) {
    case AIC_FOCUSCONTEXTCHANGED:
        if (IsWndEqual(NtUserQueryWindow(hWnd, WindowFocusWindow), hWnd)) {
            ImmSetActiveContext(hWnd, hPrevImc, FALSE);
            ImmSetActiveContext(hWnd, hImc, TRUE);
        }

        // Fall thru.

    case AIC_SUCCESS:
        return hPrevImc;

    default:
        return NULL_HIMC;
    }
}


BOOL WINAPI ImmAssociateContextEx(
    HWND hWnd,
    HIMC hImc,
    DWORD dwFlag)
{
    HWND hWndFocus;
    PWND pWndFocus;
    HIMC hImcFocusOld;
    AIC_STATUS Status;

    if (!IS_IME_ENABLED()) {
        return FALSE;
    }

    hWndFocus = NtUserQueryWindow(hWnd, WindowFocusWindow);

    if (hImc != NULL_HIMC && !(dwFlag & IACE_DEFAULT) &&
            GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmAssociateContextEx: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    if ((pWndFocus = ValidateHwnd(hWndFocus)) != (PWND)NULL)
        hImcFocusOld = KHIMC_TO_HIMC(pWndFocus->hImc);
    else
        hImcFocusOld = NULL_HIMC;

    Status = NtUserAssociateInputContext(hWnd, hImc, dwFlag);

    switch (Status) {
    case AIC_FOCUSCONTEXTCHANGED:
        if ((pWndFocus = ValidateHwnd(hWndFocus)) != (PWND)NULL) {
            hImc = KHIMC_TO_HIMC(pWndFocus->hImc);
            if (hImc != hImcFocusOld) {
                ImmSetActiveContext(hWndFocus, hImcFocusOld, FALSE);
                ImmSetActiveContext(hWndFocus, hImc, TRUE);
            };
        };

        // Fall thru.

    case AIC_SUCCESS:
        return TRUE;

    default:
        return FALSE;
    }
}


/**************************************************************************\
* ImmGetContext
*
* Retrieves the input context that is associated to the given window.
*
* 17-Jan-1996 wkwok       Created
\**************************************************************************/

HIMC WINAPI ImmGetContext(
    HWND hWnd)
{
    if ( hWnd == NULL ) {
        RIPMSG1(RIP_WARNING,
              "ImmGetContext: invalid window handle %x", hWnd);
        return NULL_HIMC;
    }
    /*
     * for non-NULL hWnd, ImmGetSaveContext will do the
     * validation and "same process" checking.
     */
    return ImmGetSaveContext( hWnd, IGSC_WINNLSCHECK );
}


/**************************************************************************\
* ImmGetSaveContext
*
* Retrieves the input context that is associated to the given window.
*
* 15-Mar-1996 wkwok       Created
\**************************************************************************/

HIMC ImmGetSaveContext(
    HWND  hWnd,
    DWORD dwFlag)
{
    HIMC       hRetImc;
    PCLIENTIMC pClientImc;
    PWND  pwnd;

    if (!IS_IME_ENABLED()) {
        return NULL_HIMC;
    }

    if (hWnd == NULL) {
        /*
         * Retrieves the default input context of current thread.
         */
        hRetImc = (HIMC)NtUserGetThreadState(UserThreadStateDefaultInputContext);
    }
    else {
        /*
         * Retrieves the input context associated to the given window.
         */
        if ((pwnd = ValidateHwnd(hWnd)) == (PWND)NULL) {
            RIPMSG1(RIP_WARNING,
                  "ImmGetSaveContext: invalid window handle %x", hWnd);
            return NULL_HIMC;
        }
        /*
         * Don't allow other process to access input context
         */
        if (!TestWindowProcess(pwnd)) {
            RIPMSG0(RIP_WARNING,
                  "ImmGetSaveContext: can not get input context of other process");
            return NULL_HIMC;
        }
        hRetImc = KHIMC_TO_HIMC(pwnd->hImc);

        if (hRetImc == NULL_HIMC && (dwFlag & IGSC_DEFIMCFALLBACK)) {
            /*
             * hWnd associated with NULL input context, retrieves the
             * default input context of the hWnd's creator thread.
             */
            hRetImc = (HIMC)NtUserQueryWindow(hWnd, WindowDefaultInputContext);
        }
    }

    pClientImc = ImmLockClientImc(hRetImc);
    if (pClientImc == NULL)
        return NULL_HIMC;

    if ((dwFlag & IGSC_WINNLSCHECK) && TestICF(pClientImc, IMCF_WINNLSDISABLE))
        hRetImc = NULL_HIMC;

    ImmUnlockClientImc(pClientImc);

    return hRetImc;
}


/**************************************************************************\
* ImmReleaseContext
*
* Releases the input context retrieved by ImmGetContext().
*
* 17-Jan-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmReleaseContext(
    HWND hWnd,
    HIMC hImc)
{
    UNREFERENCED_PARAMETER(hWnd);
    UNREFERENCED_PARAMETER(hImc);

    return TRUE;
}


/**************************************************************************\
* ImmSetActiveContext
*
* 15-Mar-1996 wkwok       Created
\**************************************************************************/

BOOL ImmSetActiveContext(
    HWND hWnd,
    HIMC hImc,
    BOOL fActivate)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    PIMEDPI       pImeDpi;
    DWORD         dwISC;
    HIMC          hSaveImc;
    HWND          hDefImeWnd;
    DWORD         dwOpenStatus = 0;
    DWORD         dwConversion = 0;
#ifdef DEBUG
    PWND          pWnd = ValidateHwnd(hWnd);

    if (pWnd != NULL && GETPTI(pWnd) != PtiCurrent()) {
        RIPMSG1(RIP_WARNING, "hWnd (=%lx) is not of current thread.", hWnd);
    }
#endif

    if (!IS_IME_ENABLED()) {
        return FALSE;
    }

    dwISC = ISC_SHOWUIALL;

    pClientImc = ImmLockClientImc(hImc);

    if (!fActivate) {
        if (pClientImc != NULL)
            ClrICF(pClientImc, IMCF_ACTIVE);
        goto NotifySetActive;
    }

    if (hImc == NULL_HIMC) {
        hSaveImc = ImmGetSaveContext(hWnd, IGSC_DEFIMCFALLBACK);
        pInputContext = ImmLockIMC(hSaveImc);
        if (pInputContext != NULL) {
            pInputContext->hWnd = hWnd;
            ImmUnlockIMC(hSaveImc);
        }
        goto NotifySetActive;
    }

    /*
     * Non-NULL input context, window handle have to be updated.
     */
    if (pClientImc == NULL)
        return FALSE;

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        ImmUnlockClientImc(pClientImc);
        return FALSE;
    }

    pInputContext->hWnd = hWnd;
    SetICF(pClientImc, IMCF_ACTIVE);

#ifdef LATER
    // Do uNumLangVKey checking later
#endif

    if (pInputContext->fdw31Compat & F31COMPAT_MCWHIDDEN)
        dwISC = ISC_SHOWUIALL - ISC_SHOWUICOMPOSITIONWINDOW;

    dwOpenStatus = (DWORD)pInputContext->fOpen;
    dwConversion = pInputContext->fdwConversion;
    ImmUnlockIMC(hImc);

NotifySetActive:

#ifdef CUAS_ENABLE
    {
        HKL hKL = GetKeyboardLayout(0);
        //
        // call msctfime's ImeSetActiveContextAlways() no matter what is the cuurnet
        // hkl if we in Cicero Unaware App Support.
        //
        if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
            Internal_CtfImeSetActiveContextAlways(hImc, fActivate, hWnd, hKL);
        }
    }
#endif // CUAS_ENABLE

#if !defined(CUAS_ENABLE)
    pImeDpi = ImmLockImeDpi(GetKeyboardLayout(0));
    if (pImeDpi != NULL) {
        (*pImeDpi->pfn.ImeSetActiveContext)(hImc, fActivate);
        ImmUnlockImeDpi(pImeDpi);
    }
#else
    //
    // msctfime's SetFocus might be change hKL to Cicero.
    //
    // call IME's ImeSetActiveContext().
    //
    {
        HKL hKL;
        pImeDpi = ImmLockImeDpi(hKL=GetKeyboardLayout(0));
        if (pImeDpi != NULL) {
            if (IS_IME_KBDLAYOUT(hKL)) {
                (*pImeDpi->pfn.ImeSetActiveContext)(hImc, fActivate);
            }
            ImmUnlockImeDpi(pImeDpi);
        }
    }
#endif

    /*
     * Notify UI
     */
    if (IsWindow(hWnd)) {
        SendMessage(hWnd, WM_IME_SETCONTEXT, fActivate, dwISC);

        /*
         * send notify to shell / keyboard driver
         */
        if ( fActivate )
            NtUserNotifyIMEStatus( hWnd, dwOpenStatus, dwConversion );
    }
    else if (!fActivate) {
        /*
         * Because hWnd is not there (maybe destroyed), we send
         * WM_IME_SETCONTEXT to the default IME window.
         */
        if ((hDefImeWnd = ImmGetDefaultIMEWnd(NULL)) != NULL) {
            SendMessage(hDefImeWnd, WM_IME_SETCONTEXT, fActivate, dwISC);
        }
        else {
            RIPMSG0(RIP_WARNING,
                  "ImmSetActiveContext: can't send WM_IME_SETCONTEXT(FALSE).");
        }
    }
#ifdef DEBUG
    else {
        RIPMSG0(RIP_WARNING,
              "ImmSetActiveContext: can't send WM_IME_SETCONTEXT(TRUE).");
    }
#endif

#ifdef LATER
    // Implements ProcessIMCEvent() later.
#endif

    if (pClientImc != NULL)
        ImmUnlockClientImc(pClientImc);

    return TRUE;
}

/**************************************************************************\
* ModeSaver related routines
*
* Dec-1998 hiroyama     Created
\**************************************************************************/

PIMEMODESAVER GetImeModeSaver(
    PINPUTCONTEXT pInputContext,
    HKL hkl)
{
    PIMEMODESAVER pModeSaver;
    USHORT langId = PRIMARYLANGID(HKL_TO_LANGID(hkl));

    for (pModeSaver = pInputContext->pImeModeSaver; pModeSaver; pModeSaver = pModeSaver->next) {
        if (pModeSaver->langId == langId) {
            break;
        }
    }

    if (pModeSaver == NULL) {


        TAGMSG1(DBGTAG_IMM, "GetImeModeSaver: creating ModeSaver for langId=%04x", langId);
        pModeSaver = ImmLocalAlloc(HEAP_ZERO_MEMORY, sizeof *pModeSaver);
        if (pModeSaver == NULL) {
            RIPMSG1(RIP_WARNING, "GetImeModeSaver: failed to create ModeSaver for langId=%04x", langId);
            return NULL;
        }
        pModeSaver->langId = langId;
        pModeSaver->next = pInputContext->pImeModeSaver;
        pInputContext->pImeModeSaver = pModeSaver;
    }

    return pModeSaver;
}

VOID DestroyImeModeSaver(
    PINPUTCONTEXT pInputContext)
{
    PIMEMODESAVER pModeSaver = pInputContext->pImeModeSaver;

    //
    // Destroy mode savers
    //
    while (pModeSaver) {
        PIMEMODESAVER pNext = pModeSaver->next;
        PIMEPRIVATEMODESAVER pPrivateModeSaver = pModeSaver->pImePrivateModeSaver;

        //
        // Destroy private mode savers
        //
        while (pPrivateModeSaver) {
            PIMEPRIVATEMODESAVER pPrivateNext = pPrivateModeSaver->next;
            ImmLocalFree(pPrivateModeSaver);
            pPrivateModeSaver = pPrivateNext;
        }

        ImmLocalFree(pModeSaver);
        pModeSaver = pNext;
    }

    pInputContext->pImeModeSaver = NULL;
}

PIMEPRIVATEMODESAVER GetImePrivateModeSaver(
    PIMEMODESAVER pImeModeSaver,
    HKL hkl)
{
    PIMEPRIVATEMODESAVER pPrivateModeSaver;

    for (pPrivateModeSaver = pImeModeSaver->pImePrivateModeSaver; pPrivateModeSaver; pPrivateModeSaver = pPrivateModeSaver->next) {
        if (pPrivateModeSaver->hkl == hkl) {
            break;
        }
    }

    if (pPrivateModeSaver == NULL) {
        TAGMSG1(DBGTAG_IMM, "GetImePrivateModeSaver: creating private mode saver for hkl=%08x", hkl);
        pPrivateModeSaver = ImmLocalAlloc(0, sizeof *pPrivateModeSaver);
        if (pPrivateModeSaver == NULL) {
            RIPMSG1(RIP_WARNING, "GetImePrivateModeSaver: failed to create PrivateModeSaver for hlk=%08x", hkl);
            return NULL;
        }
        pPrivateModeSaver->hkl = hkl;
        pPrivateModeSaver->fdwSentence = 0;
        pPrivateModeSaver->next = pImeModeSaver->pImePrivateModeSaver;
        pImeModeSaver->pImePrivateModeSaver = pPrivateModeSaver;
    }

    return pPrivateModeSaver;
}

BOOL SavePrivateMode(
    PINPUTCONTEXT pInputContext,
    PIMEMODESAVER pImeModeSaver,
    HKL hkl)
{
    PIMEPRIVATEMODESAVER pPrivateModeSaver = GetImePrivateModeSaver(pImeModeSaver, hkl);

    if (pPrivateModeSaver == NULL) {
        return FALSE;
    }

    //
    // Save private sentence mode
    //
    pPrivateModeSaver->fdwSentence = pInputContext->fdwSentence & 0xffff0000;
    return TRUE;
}

BOOL RestorePrivateMode(
    PINPUTCONTEXT pInputContext,
    PIMEMODESAVER pImeModeSaver,
    HKL hkl)
{
    PIMEPRIVATEMODESAVER pPrivateModeSaver = GetImePrivateModeSaver(pImeModeSaver, hkl);

    if (pPrivateModeSaver == NULL) {
        return FALSE;
    }

    //
    // Restore private sentence mode
    //
    ImmAssert(LOWORD(pPrivateModeSaver->fdwSentence) == 0);
    pInputContext->fdwSentence |= pPrivateModeSaver->fdwSentence;
    return TRUE;
}

/**************************************************************************\
* CreateInputContext
*
* 20-Feb-1996 wkwok       Created
\**************************************************************************/

BOOL CreateInputContext(
    HIMC hImc,
    HKL  hKL,
    BOOL fCanCallImeSelect)
{
    PIMEDPI            pImeDpi;
    PCLIENTIMC         pClientImc;
    DWORD              dwPrivateDataSize;
    DWORD              fdwInitConvMode = 0;    // do it later
    BOOL               fInitOpen = FALSE;      // do it later
    PINPUTCONTEXT      pInputContext;
    PCOMPOSITIONSTRING pCompStr;
    PCANDIDATEINFO     pCandInfo;
    PGUIDELINE         pGuideLine;
    int                i;

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "CreateContext: Lock hIMC %x failure", hImc);
        goto CrIMCLockErrOut;
    }

    /*
     * Initialize the member of INPUTCONTEXT
     */
    pInputContext->hCompStr = ImmCreateIMCC(sizeof(COMPOSITIONSTRING));
    if (!pInputContext->hCompStr) {
        RIPMSG0(RIP_WARNING, "CreateContext: Create hCompStr failure");
        goto CrIMCUnlockIMC;
    }

    pCompStr = (PCOMPOSITIONSTRING)ImmLockIMCC(pInputContext->hCompStr);
    if (!pCompStr) {
        RIPMSG1(RIP_WARNING,
              "CreateContext: Lock hCompStr %x failure", pInputContext->hCompStr);
        goto CrIMCFreeCompStr;
    }

    pCompStr->dwSize = sizeof(COMPOSITIONSTRING);
    ImmUnlockIMCC(pInputContext->hCompStr);

    pInputContext->hCandInfo = ImmCreateIMCC(sizeof(CANDIDATEINFO));
    if (!pInputContext->hCandInfo) {
        RIPMSG0(RIP_WARNING, "CreateContext: Create hCandInfo failure");
        goto CrIMCFreeCompStr;
    }

    pCandInfo = (PCANDIDATEINFO)ImmLockIMCC(pInputContext->hCandInfo);
    if (!pCandInfo) {
        RIPMSG1(RIP_WARNING,
              "CreateContext: Lock hCandInfo %x failure", pInputContext->hCandInfo);
        goto CrIMCFreeCandInfo;
    }

    pCandInfo->dwSize = sizeof(CANDIDATEINFO);
    ImmUnlockIMCC(pInputContext->hCandInfo);

    pInputContext->hGuideLine = ImmCreateIMCC(sizeof(GUIDELINE));
    if (!pInputContext->hGuideLine) {
        RIPMSG0(RIP_WARNING, "CreateContext: Create hGuideLine failure");
        goto CrIMCFreeCandInfo;
    }

    pGuideLine = (PGUIDELINE)ImmLockIMCC(pInputContext->hGuideLine);
    if (!pGuideLine) {
        RIPMSG1(RIP_WARNING,
              "CreateContext: Lock hGuideLine %x failure", pInputContext->hGuideLine);
        goto CrIMCFreeGuideLine;
    }

    pGuideLine->dwSize = sizeof(GUIDELINE);
    ImmUnlockIMCC(pInputContext->hGuideLine);

    pInputContext->hMsgBuf = ImmCreateIMCC(sizeof(UINT));
    if (!pInputContext->hMsgBuf) {
        RIPMSG0(RIP_WARNING, "CreateContext: Create hMsgBuf failure");
        goto CrIMCFreeGuideLine;
    }

    pInputContext->dwNumMsgBuf = 0;
    pInputContext->fOpen = fInitOpen;
    pInputContext->fdwConversion = fdwInitConvMode;
    pInputContext->fdwSentence = 0;

    for (i = 0; i < 4; i++) {
        pInputContext->cfCandForm[i].dwIndex = (DWORD)(-1);
    }

    pImeDpi = ImmLockImeDpi(hKL);
    if (pImeDpi != NULL) {
        if ((pClientImc = ImmLockClientImc(hImc)) == NULL) {
            RIPMSG0(RIP_WARNING, "CreateContext: ImmLockClientImc() failure");
            ImmUnlockImeDpi(pImeDpi);
            goto CrIMCFreeMsgBuf;
        }

        /*
         * Unicode based IME expects an Uncode based input context.
         */
        if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)
            SetICF(pClientImc, IMCF_UNICODE);

        pClientImc->dwCodePage = IMECodePage(pImeDpi);

        ImmUnlockClientImc(pClientImc);

        dwPrivateDataSize = pImeDpi->ImeInfo.dwPrivateDataSize;
    }
    else {
        dwPrivateDataSize = sizeof(UINT);
    }

    pInputContext->hPrivate = ImmCreateIMCC(dwPrivateDataSize);
    if (!pInputContext->hPrivate) {
        RIPMSG0(RIP_WARNING, "CreateContext: Create hPrivate failure");
        ImmUnlockImeDpi(pImeDpi);
        goto CrIMCFreeMsgBuf;
    }

    pInputContext->pImeModeSaver = NULL;

#ifdef CUAS_ENABLE
    /*
     * Create Cicero Input Context.
     */
    CtfImmTIMCreateInputContext(hImc);
#endif // CUAS_ENABLE

#if !defined(CUAS_ENABLE)
    if (pImeDpi != NULL) {
        if (fCanCallImeSelect) {
            (*pImeDpi->pfn.ImeSelect)(hImc, TRUE);
        }
        ImmUnlockImeDpi(pImeDpi);
    }
#else
    if (pImeDpi != NULL) {
        if (fCanCallImeSelect) {
            if (IS_IME_KBDLAYOUT(hKL)) {
                (*pImeDpi->pfn.ImeSelect)(hImc, TRUE);
            }
            else if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
                (*pImeDpi->pfn.CtfImeSelectEx)(hImc, TRUE, hKL);
            }
        }
        if ((pClientImc = ImmLockClientImc(hImc)) != NULL) {
            pClientImc->SelectedHKL = hKL;
            ImmUnlockClientImc(pClientImc);
        }
        ImmUnlockImeDpi(pImeDpi);
    }
#endif

    ImmUnlockIMC(hImc);
    return TRUE;

    /*
     * context failure case
     */
CrIMCFreeMsgBuf:
    ImmDestroyIMCC(pInputContext->hMsgBuf);
CrIMCFreeGuideLine:
    ImmDestroyIMCC(pInputContext->hGuideLine);
CrIMCFreeCandInfo:
    ImmDestroyIMCC(pInputContext->hCandInfo);
CrIMCFreeCompStr:
    ImmDestroyIMCC(pInputContext->hCompStr);
CrIMCUnlockIMC:
    ImmUnlockIMC(hImc);
CrIMCLockErrOut:
    return FALSE;
}


/**************************************************************************\
* DestroyInputContext
*
* 20-Feb-1996 wkwok       Created
\**************************************************************************/

BOOL DestroyInputContext(
    HIMC      hImc,
    HKL       hKL,
    BOOL      bTerminate)
{
    PINPUTCONTEXT pInputContext;
    PIMEDPI       pImeDpi;
    PIMC          pImc;
    PCLIENTIMC    pClientImc;

    if (!IS_IME_ENABLED()) {
        return FALSE;

    }
    if (hImc == NULL_HIMC) {
        RIPMSG0(RIP_VERBOSE, "DestroyInputContext: hImc is NULL.");
        return FALSE;
    }

    pImc = HMValidateHandle((HANDLE)hImc, TYPE_INPUTCONTEXT);

    /*
     * Cannot destroy input context from other thread.
     */
    if (pImc == NULL || GETPTI(pImc) != PtiCurrent())
        return FALSE;

    /*
     * We are destroying this hImc so we don't bother calling
     * ImmLockClientImc() to get the pClientImc. Instead, we
     * reference the pImc->dwClientImcData directly and call
     * InterlockedIncrement(&pClientImc->cLockObj) right after
     * several quick checks.
     */
    pClientImc = (PCLIENTIMC)pImc->dwClientImcData;

    if (pClientImc == NULL) {
        /*
         * Client side Imc has not been initialzed yet.
         * We simply destroy this input context from kernel.
         */
        if (bTerminate) {
            /*
             * If called from THREAD_DETACH, we don't
             * have to destroy kernel side Input Context.
             */
            return TRUE;
        }
        return NtUserDestroyInputContext(hImc);
    }

    if (TestICF(pClientImc, IMCF_DEFAULTIMC) && !bTerminate) {
        /*
         * Cannot destroy default input context unless the
         * thread is terminating.
         */
        return FALSE;
    }

    if (TestICF(pClientImc, IMCF_INDESTROY)) {
        /*
         * This hImc is being destroyed. Returns as success.
         */
        return TRUE;
    }

    /*
     * Time to lock up the pClientImc.
     */
    InterlockedIncrement(&pClientImc->cLockObj);

    if (pClientImc->hInputContext != NULL) {

        pInputContext = ImmLockIMC(hImc);
        if (!pInputContext) {
            RIPMSG1(RIP_WARNING, "DestroyContext: Lock hImc %x failure", hImc);
            ImmUnlockClientImc(pClientImc);
            return FALSE;
        }

#ifdef CUAS_ENABLE
        /*
         * Destroy Cicero Input Context.
         */
        CtfImmTIMDestroyInputContext(hImc);
#endif // CUAS_ENABLE

#if !defined(CUAS_ENABLE)
        pImeDpi = ImmLockImeDpi(hKL);
        if (pImeDpi != NULL) {
            (*pImeDpi->pfn.ImeSelect)(hImc, FALSE);
            ImmUnlockImeDpi(pImeDpi);
        }
#else
        if (pClientImc->SelectedHKL == hKL) {
            pImeDpi = ImmLockImeDpi(hKL);
            if (pImeDpi != NULL) {
                if (IS_IME_KBDLAYOUT(hKL)) {
                    (*pImeDpi->pfn.ImeSelect)(hImc, FALSE);
                }
                else if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
                    (*pImeDpi->pfn.CtfImeSelectEx)(hImc, FALSE, hKL);
                }
                ImmUnlockImeDpi(pImeDpi);
            }
            pClientImc->SelectedHKL = NULL;
        }
#endif

        ImmDestroyIMCC(pInputContext->hPrivate);
        ImmDestroyIMCC(pInputContext->hMsgBuf);
        ImmDestroyIMCC(pInputContext->hGuideLine);
        ImmDestroyIMCC(pInputContext->hCandInfo);
        ImmDestroyIMCC(pInputContext->hCompStr);

        /*
         * Free all ImeModeSaver.
         */
        DestroyImeModeSaver(pInputContext);

        ImmUnlockIMC(hImc);
    }

    SetICF(pClientImc, IMCF_INDESTROY);

    /*
     * ImmUnlockClientImc() will free up the pClientImc
     * when InterlockedDecrement(&pClientImc->cLockObj)
     * reaches 0.
     */
    ImmUnlockClientImc(pClientImc);

    return (bTerminate) ? TRUE : NtUserDestroyInputContext(hImc);
}


/**************************************************************************\
* SelectInputContext
*
* 20-Feb-1996 wkwok       Created
\**************************************************************************/

VOID SelectInputContext(
    HKL  hSelKL,
    HKL  hUnSelKL,
    HIMC hImc)
{
    PIMEDPI            pSelImeDpi, pUnSelImeDpi;
    PCLIENTIMC         pClientImc;
    PINPUTCONTEXT      pInputContext;
    DWORD              dwSelPriv = 0, dwUnSelPriv = 0, dwSize;
    HIMCC              hImcc;
    PCOMPOSITIONSTRING pCompStr;
    PCANDIDATEINFO     pCandInfo;
    PGUIDELINE         pGuideLine;
    BOOLEAN            fLogFontInited;
#ifdef CUAS_ENABLE
    BOOLEAN            fUseImeSaverForSelIme = TRUE;
    BOOLEAN            fUseImeSaverForUnSelIme = TRUE;
#endif

    TAGMSG3(DBGTAG_IMM, "SelectInputContext: called for sel=%08p unsel=%08p hImc=%08p",
            hSelKL, hUnSelKL, hImc);

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG0(RIP_VERBOSE, "SelectInputContext: cannot lock client Imc. Bailing out.");
        return;
    }

    pSelImeDpi   = ImmLockImeDpi(hSelKL);

    if (hSelKL != hUnSelKL) {
        /*
         * If those new sel and unsel do no match but
         * somehow SelectInput is called, that means
         * we should initialize the input contex again
         * without dumping the old information.
         */
        pUnSelImeDpi = ImmLockImeDpi(hUnSelKL);
    } else {
        pUnSelImeDpi = NULL;
    }

    if (pSelImeDpi != NULL) {
        /*
         * According to private memory size of the two layout, we decide
         * whether we nee to reallocate this memory block
         */
        dwSelPriv = pSelImeDpi->ImeInfo.dwPrivateDataSize;

        /*
         * Setup the code page of the newly selected IME.
         */
        pClientImc->dwCodePage = IMECodePage(pSelImeDpi);
    }
    else {
        pClientImc->dwCodePage = CP_ACP;
    }

    if (pUnSelImeDpi != NULL)
        dwUnSelPriv = pUnSelImeDpi->ImeInfo.dwPrivateDataSize;

    dwSelPriv   = max(dwSelPriv,   sizeof(UINT));
    dwUnSelPriv = max(dwUnSelPriv, sizeof(UINT));

    /*
     * Unselect the input context.
     */
#if !defined(CUAS_ENABLE)
    if (pUnSelImeDpi != NULL)
        (*pUnSelImeDpi->pfn.ImeSelect)(hImc, FALSE);
#else
    if (pClientImc->SelectedHKL == hUnSelKL) {
        if (pUnSelImeDpi != NULL) {
            if (IS_IME_KBDLAYOUT(hUnSelKL)) {
                (*pUnSelImeDpi->pfn.ImeSelect)(hImc, FALSE);
            }
            else if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
                (*pUnSelImeDpi->pfn.CtfImeSelectEx)(hImc, FALSE, hUnSelKL);
            }
        }
        pClientImc->SelectedHKL = NULL;
    }

    //
    // don't use a mode saver for non IME or non CUAS.
    //
    if (CtfImmIsTextFrameServiceDisabled()) {
        if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
            if (!IS_IME_KBDLAYOUT(hSelKL))
                fUseImeSaverForSelIme = FALSE;
            if (!IS_IME_KBDLAYOUT(hUnSelKL))
                fUseImeSaverForUnSelIme = FALSE;
        }
    }
#endif

    /*
     * Reinitialize the client side input context for the selected layout.
     */
    if ((pInputContext = InternalImmLockIMC(hImc, FALSE)) != NULL) {
        DWORD fdwOldConversion = pInputContext->fdwConversion;
        DWORD fdwOldSentence = pInputContext->fdwSentence;
        BOOL fOldOpen = pInputContext->fOpen;
        PIMEMODESAVER pUnSelModeSaver, pSelModeSaver;
        const DWORD fdwConvPreserve = IME_CMODE_EUDC;

        fLogFontInited = ((pInputContext->fdwInit & INIT_LOGFONT) == INIT_LOGFONT);

        if (TestICF(pClientImc, IMCF_UNICODE) && pSelImeDpi != NULL &&
                !(pSelImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)) {
            /*
             * Check if there is any LOGFONT to be converted.
             */
            if (fLogFontInited) {
                LOGFONTA LogFontA;

                LFontWtoLFontA(&pInputContext->lfFont.W, &LogFontA);
                RtlCopyMemory(&pInputContext->lfFont.A, &LogFontA, sizeof(LOGFONTA));
            }

            ClrICF(pClientImc, IMCF_UNICODE);
        }
        else if (!TestICF(pClientImc, IMCF_UNICODE) && pSelImeDpi != NULL &&
                 (pSelImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)) {
            /*
             * Check if there is any LOGFONT to be converted.
             */
            if (fLogFontInited) {
                LOGFONTW LogFontW;

                LFontAtoLFontW(&pInputContext->lfFont.A, &LogFontW);
                RtlCopyMemory(&pInputContext->lfFont.W, &LogFontW, sizeof(LOGFONTW));
            }

            SetICF(pClientImc, IMCF_UNICODE);
        }

        /*
         * hPrivate
         */
        if (dwUnSelPriv != dwSelPriv) {
            hImcc = ImmReSizeIMCC(pInputContext->hPrivate, dwSelPriv);
            if (hImcc) {
                pInputContext->hPrivate = hImcc;
            }
            else {
                RIPMSG1(RIP_WARNING,
                      "SelectContext: resize hPrivate %lX failure",
                      pInputContext->hPrivate);
                ImmDestroyIMCC(pInputContext->hPrivate);
                pInputContext->hPrivate = ImmCreateIMCC(dwSelPriv);
            }
        }

        /*
         * hMsgBuf
         */
        dwSize = ImmGetIMCCSize(pInputContext->hMsgBuf);

        if (ImmGetIMCCLockCount(pInputContext->hMsgBuf) != 0 ||
                dwSize > IMCC_ALLOC_TOOLARGE) {

            RIPMSG0(RIP_WARNING, "SelectContext: create new hMsgBuf");
            ImmDestroyIMCC(pInputContext->hMsgBuf);
            pInputContext->hMsgBuf = ImmCreateIMCC(sizeof(UINT));
            pInputContext->dwNumMsgBuf = 0;
        }

        /*
         * hGuideLine
         */
        dwSize = ImmGetIMCCSize(pInputContext->hGuideLine);

        if (ImmGetIMCCLockCount(pInputContext->hGuideLine) != 0 ||
                dwSize < sizeof(GUIDELINE) || dwSize > IMCC_ALLOC_TOOLARGE) {

            RIPMSG0(RIP_WARNING, "SelectContext: create new hGuideLine");
            ImmDestroyIMCC(pInputContext->hGuideLine);
            pInputContext->hGuideLine = ImmCreateIMCC(sizeof(GUIDELINE));
            pGuideLine = (PGUIDELINE)ImmLockIMCC(pInputContext->hGuideLine);

            if (pGuideLine != NULL) {
                pGuideLine->dwSize = sizeof(GUIDELINE);
                ImmUnlockIMCC(pInputContext->hGuideLine);
            }
        }

        /*
         * hCandInfo
         */
        dwSize = ImmGetIMCCSize(pInputContext->hCandInfo);

        if (ImmGetIMCCLockCount(pInputContext->hCandInfo) != 0 ||
                dwSize < sizeof(CANDIDATEINFO) || dwSize > IMCC_ALLOC_TOOLARGE) {

            RIPMSG0(RIP_WARNING, "SelectContext: create new hCandInfo");
            ImmDestroyIMCC(pInputContext->hCandInfo);
            pInputContext->hCandInfo = ImmCreateIMCC(sizeof(CANDIDATEINFO));
            pCandInfo = (PCANDIDATEINFO)ImmLockIMCC(pInputContext->hCandInfo);

            if (pCandInfo != NULL) {
                pCandInfo->dwSize = sizeof(CANDIDATEINFO);
                ImmUnlockIMCC(pInputContext->hCandInfo);
            }
        }

        /*
         * hCompStr
         */
        dwSize = ImmGetIMCCSize(pInputContext->hCompStr);

        if (ImmGetIMCCLockCount(pInputContext->hCompStr) != 0 ||
                dwSize < sizeof(COMPOSITIONSTRING) || dwSize > IMCC_ALLOC_TOOLARGE) {

            RIPMSG0(RIP_WARNING, "SelectContext: create new hCompStr");
            ImmDestroyIMCC(pInputContext->hCompStr);
            pInputContext->hCompStr = ImmCreateIMCC(sizeof(COMPOSITIONSTRING));
            pCompStr = (PCOMPOSITIONSTRING)ImmLockIMCC(pInputContext->hCompStr);

            if (pCompStr != NULL) {
                pCompStr->dwSize = sizeof(COMPOSITIONSTRING);
                ImmUnlockIMCC(pInputContext->hCompStr);
            }
        }

        //
        // Save and restore the IME modes when the primary
        // language changes.
        //

#if !defined(CUAS_ENABLE)
        if (pUnSelImeDpi) 
#else
        if (pUnSelImeDpi && fUseImeSaverForUnSelIme)
#endif
        {
            //
            // If UnSelKL is IME, get ModeSaver per language.
            //
            pUnSelModeSaver = GetImeModeSaver(pInputContext, hUnSelKL);
            TAGMSG1(DBGTAG_IMM, "pUnSelModeSaver=%p", pUnSelModeSaver);

            if (pUnSelModeSaver) {
                //
                // Firstly save the private sentence mode per IME.
                //
                SavePrivateMode(pInputContext, pUnSelModeSaver, hUnSelKL);
            }
        }
        else {
            pUnSelModeSaver = NULL;
        }

#if !defined(CUAS_ENABLE)
        if (pSelImeDpi) 
#else
        if (pSelImeDpi && fUseImeSaverForSelIme)
#endif
        {
            //
            // If SelKL is IME, get is ModeSaver per language.
            //
            pSelModeSaver = GetImeModeSaver(pInputContext, hSelKL);
            TAGMSG1(DBGTAG_IMM, "pSelImeDpi. pImeModeSaver=%p", pSelModeSaver);
        }
        else {
            pSelModeSaver = NULL;
        }

        //
        // If the primary language of KL changes, save the current mode
        // and restore the previous modes of new language.
        //
        if (pUnSelModeSaver != pSelModeSaver) {
            //
            // If old KL is IME, save the current conversion, sentence and open mode.
            //
            if (pUnSelModeSaver) {
                pUnSelModeSaver->fOpen = (pInputContext->fOpen != FALSE);

                //
                // Don't have to save the preserved bits for conversion mode.
                //
                pUnSelModeSaver->fdwConversion = pInputContext->fdwConversion & ~fdwConvPreserve;

                pUnSelModeSaver->fdwSentence = LOWORD(pInputContext->fdwSentence);
                pUnSelModeSaver->fdwInit = pInputContext->fdwInit;
            }

            //
            // If new KL is IME, restore the previous conversion, sentence and open mode.
            //
            if (pSelModeSaver) {
                if (pInputContext->fdwDirty & IMSS_INIT_OPEN) {
                    //
                    // HKL change may be kicked from private IME hotkey, and
                    // a user wants it opened when switched.
                    //
                    pInputContext->fOpen = TRUE;
                    pInputContext->fdwDirty &= ~IMSS_INIT_OPEN;
                } else {
                    pInputContext->fOpen = pSelModeSaver->fOpen;
                }

                //
                // Some bits are preserved across the languages.
                //
                pInputContext->fdwConversion &= fdwConvPreserve;
                ImmAssert((pSelModeSaver->fdwConversion & fdwConvPreserve) == 0);
                pInputContext->fdwConversion |= pSelModeSaver->fdwConversion & ~fdwConvPreserve;

                ImmAssert(HIWORD(pSelModeSaver->fdwSentence) == 0);
                pInputContext->fdwSentence = pSelModeSaver->fdwSentence;
                pInputContext->fdwInit = pSelModeSaver->fdwInit;
            }
        }
        if (pSelModeSaver) {
            //
            // Restore the private sentence mode per IME.
            //
            RestorePrivateMode(pInputContext, pSelModeSaver, hSelKL);
        }

        /*
         * Select the input context.
         */
#if !defined(CUAS_ENABLE)
        if (pSelImeDpi != NULL)
            (*pSelImeDpi->pfn.ImeSelect)(hImc, TRUE);
#else
        if (pSelImeDpi != NULL) {
            if (IS_IME_KBDLAYOUT(hSelKL)) {
                (*pSelImeDpi->pfn.ImeSelect)(hImc, TRUE);
            }
            else if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
                (*pSelImeDpi->pfn.CtfImeSelectEx)(hImc, TRUE, hSelKL);
            }
            pClientImc->SelectedHKL = hSelKL;
        }
#endif

        //
        // Set the dirty bits so that IMM can send notifications later.
        // See SendNotificatonProc.
        //
        pInputContext->fdwDirty = 0;
        if (pInputContext->fOpen != fOldOpen) {
            pInputContext->fdwDirty |= IMSS_UPDATE_OPEN;
        }
        if (pInputContext->fdwConversion != fdwOldConversion) {
            pInputContext->fdwDirty |= IMSS_UPDATE_CONVERSION;
        }
        if (pInputContext->fdwSentence != fdwOldSentence) {
            pInputContext->fdwDirty |= IMSS_UPDATE_SENTENCE;
        }
        TAGMSG4(DBGTAG_IMM, "fOpen:%d fdwConv:%08x fdwSent:%08x dirty:%02x",
                pInputContext->fOpen, pInputContext->fdwConversion, pInputContext->fdwSentence, pInputContext->fdwDirty);

        ImmUnlockIMC(hImc);
    }
    else {
        //
        // To keep the backward compatibility,
        // select the input context here.
        //
#if !defined(CUAS_ENABLE)
        if (pSelImeDpi != NULL)
            (*pSelImeDpi->pfn.ImeSelect)(hImc, TRUE);
#else
        if (pSelImeDpi != NULL) {
            if (IS_IME_KBDLAYOUT(hSelKL)) {
                (*pSelImeDpi->pfn.ImeSelect)(hImc, TRUE);
            }
            else if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
                (*pSelImeDpi->pfn.CtfImeSelectEx)(hImc, TRUE, hSelKL);
            }
            pClientImc->SelectedHKL = hSelKL;
        }
#endif
    }

    ImmUnlockImeDpi(pUnSelImeDpi);
    ImmUnlockImeDpi(pSelImeDpi);
    ImmUnlockClientImc(pClientImc);
}

BOOL SendNotificationProc(
    HIMC hImc,
    LPARAM lParam)
{
    PINPUTCONTEXT pInputContext = ImmLockIMC(hImc);

    UNREFERENCED_PARAMETER(lParam);

    if (pInputContext != NULL) {
        HWND hwnd = pInputContext->hWnd;

        if (IsWindow(hwnd)) {
            TAGMSG2(DBGTAG_IMM, "SendNotificationProc: updating hImc=%08x dirty=%04x",
                    hImc, pInputContext->fdwDirty);

            if (pInputContext->fdwDirty & IMSS_UPDATE_OPEN) {
                SendMessageW(hwnd, WM_IME_NOTIFY, IMN_SETOPENSTATUS, 0);
            }
            if (pInputContext->fdwDirty & IMSS_UPDATE_CONVERSION) {
                SendMessageW(hwnd, WM_IME_NOTIFY, IMN_SETCONVERSIONMODE, 0);
            }
            if (pInputContext->fdwDirty & (IMSS_UPDATE_OPEN | IMSS_UPDATE_CONVERSION)) {
                NtUserNotifyIMEStatus(hwnd, pInputContext->fOpen, pInputContext->fdwConversion);
            }
            if (pInputContext->fdwDirty & IMSS_UPDATE_SENTENCE) {
                SendMessageW(hwnd, WM_IME_NOTIFY, IMN_SETSENTENCEMODE, 0);
            }
        }
        pInputContext->fdwDirty = 0;
    }

    return TRUE;
}

VOID ImmSendNotification(
    BOOL fForProcess)
{
    DWORD dwThreadId;

    if (fForProcess) {
        dwThreadId = -1;
    } else {
        dwThreadId = 0;
    }

    ImmEnumInputContext(dwThreadId, (IMCENUMPROC)SendNotificationProc, 0);
}

/**************************************************************************\
* ImmEnumInputContext
*
* 20-Feb-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmEnumInputContext(
    DWORD idThread,
    IMCENUMPROC lpfn,
    LPARAM lParam)
{
    UINT i;
    UINT cHimc;
    HIMC *phimcT;
    HIMC *phimcFirst;
    BOOL fSuccess = TRUE;

    /*
     * Get the himc list.  It is returned in a block of memory
     * allocated with ImmLocalAlloc.
     */
    if ((cHimc = BuildHimcList(idThread, &phimcFirst)) == 0) {
        return FALSE;
    }

    /*
     * Loop through the input contexts, call the function pointer back for
     * each one. End loop if either FALSE is returned or the end-of-list is
     * reached.
     */
    phimcT = phimcFirst;
    for (i = 0; i < cHimc; i++) {
        if (RevalidateHimc(*phimcT)) {
            if (!(fSuccess = (*lpfn)(*phimcT, lParam)))
                break;
        }
        phimcT++;
    }

    /*
     * Free up buffer and return status - TRUE if entire list was enumerated,
     * FALSE otherwise.
     */
    ImmLocalFree(phimcFirst);

    return fSuccess;
}

/**************************************************************************\
* BuildHimcList
*
* 20-Feb-1996 wkwok       Created
\**************************************************************************/

DWORD BuildHimcList(
    DWORD idThread,
    HIMC **pphimcFirst)
{
    UINT cHimc;
    HIMC *phimcFirst;
    NTSTATUS Status;
    int cTries;

    /*
     * Allocate a buffer to hold the names.
     */
    cHimc = 64;
    phimcFirst = ImmLocalAlloc(0, cHimc * sizeof(HIMC));
    if (phimcFirst == NULL)
        return 0;

    Status = NtUserBuildHimcList(idThread, cHimc, phimcFirst, &cHimc);

    /*
     * If the buffer wasn't big enough, reallocate
     * the buffer and try again.
     */
    cTries = 0;
    while (Status == STATUS_BUFFER_TOO_SMALL) {
        ImmLocalFree(phimcFirst);

        /*
         * If we can't seem to get it right,
         * call it quits
         */
        if (cTries++ == 10)
            return 0;

        phimcFirst = ImmLocalAlloc(0, cHimc * sizeof(HIMC));
        if (phimcFirst == NULL)
            return 0;

        Status = NtUserBuildHimcList(idThread, cHimc, phimcFirst, &cHimc);
    }

    if (!NT_SUCCESS(Status) || cHimc == 0) {
        ImmLocalFree(phimcFirst);
        return 0;
    }

    *pphimcFirst = phimcFirst;

    return cHimc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\globals.c ===
/****************************** Module Header ******************************\
* Module Name: global.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contains global data for the imm32 dll
*
* History:
* 03-Jan-1996 wkwok    Created
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

/*
 * We get this warning if we don't explicitly initalize gZero:
 *
 * C4132: 'gZero' : const object should be initialized
 *
 * But we can't explicitly initialize it since it is a union. So
 * we turn the warning off.
 */
#pragma warning(disable:4132)
CONST ALWAYSZERO gZero;
#pragma warning(default:4132)

BOOLEAN gfInitialized;
HINSTANCE  ghInst;
PVOID pImmHeap;
PSERVERINFO gpsi = NULL;
SHAREDINFO gSharedInfo;
ULONG_PTR gHighestUserAddress;

PIMEDPI gpImeDpi = NULL;
CRITICAL_SECTION gcsImeDpi;


POINT gptRaiseEdge;
UINT  guScanCode[0xFF];          // scan code for each virtual key

#ifdef LATER
CONST WCHAR gszRegKbdLayout[]  = L"Keyboard Layouts\\";
CONST INT sizeof_gszRegKbdLayout = sizeof gszRegKbdLayout;
#else
    // current
CONST WCHAR gszRegKbdLayout[]  = L"System\\CurrentControlSet\\Control\\Keyboard Layouts";
#ifdef CUAS_ENABLE
CONST WCHAR gszRegCiceroIME[]  = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\IMM";
CONST WCHAR gszRegCtfShared[]    = L"Software\\Microsoft\\CTF\\SystemShared";
CONST WCHAR gszValCUASEnable[] = L"CUAS";
#endif // CUAS_ENABLE
#endif

CONST WCHAR gszRegKbdOrder[]   = L"Keyboard Layout\\Preload";
CONST WCHAR gszValLayoutText[] = L"Layout Text";
CONST WCHAR gszValLayoutFile[] = L"Layout File";
CONST WCHAR gszValImeFile[]    = L"Ime File";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\imemenu.c ===
//////////////////////////////////////////////////////////////////////////
// imemenu.c -     IME Menu APIs
//
// handles IME specific menu retrieval
//
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
// History:
// 23-Mar-1997 hiroyama Created
//////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#ifdef HIRO_DEBUG
#define D(x)    x
#else
#define D(x)
#endif

#define IME_MENU_FILE_NAME  L"ImmMenuInfo"
#define IME_MENU_MAXMEM     (128 * 1024)   // maximum size of mapped file

////////////////////////////////////////////////////////////
// private structurs for inter process communication
//
// NOTE for NT50: these are dedicated to internat.exe
//
// uses memory mapped file as shared buffer
// all strings expect UNICODE
// HBITMAP is de-compiled and then compiled again using
// internat.exe's context
//
////////////////////////////////////////////////////////////

typedef struct _IMEMENU_BMP_HEADER {
    struct _IMEMENU_BMP_HEADER* lpNext;
    HBITMAP hBitmap;
    LPBYTE pBits;
    BITMAPINFO bmi;
} IMEMENU_BMP_HEADER;

typedef struct {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    IMEMENU_BMP_HEADER* lpBmpChecked;
    IMEMENU_BMP_HEADER* lpBmpUnchecked;
    DWORD dwItemData;
    WCHAR szString[IMEMENUITEM_STRING_SIZE];    // menu string: always UNICODE.
    IMEMENU_BMP_HEADER* lpBmpItem;   // NULL means no bitmap in this menu
} IMEMENU_ITEM;

typedef struct {
    DWORD dwVersion;                // holds version of this memory chunk
    DWORD dwMemSize;                // size of memory buffer allocated
    DWORD dwFlags;                  // flags returned from IME
    DWORD dwType;
    IMEMENU_ITEM* lpImeParentMenu;  // parent menu's offset (if any) passed from requester
    IMEMENU_ITEM* lpImeMenu;        // offset to first menu item (will be set by IME side)
    DWORD dwSize;                   // number of menus to fill (not byte count)
    IMEMENU_BMP_HEADER* lpBmp;      // offset to first bitmap header
    IMEMENU_BMP_HEADER* lpBmpNext;  // points next available location for bmp buffer
} IMEMENU_HEADER;


// address conversion
#define CONVTO_OFFSET(x)    ((x) = (LPVOID)((x) ? ((LPBYTE)(x) - offset) : NULL))
#define CONVTO_PTR(x)       ((x) = (LPVOID)((x) ? ((LPBYTE)(x) + offset) : NULL))

#if DBG
#define CHK_OFFSET(x)       if ((ULONG_PTR)(x) >= pHeader->dwMemSize) { \
                                RIPMSG2(RIP_WARNING, "CHK_OFFSET(%s=%lx) is out of range.", #x, (ULONG_PTR)(x)); \
                            }
#define CHK_PTR(x)          if ((LPVOID)(x) < (LPVOID)pHeader || (LPBYTE)(x) > (LPBYTE)pHeader + pHeader->dwMemSize) { \
                                if ((x) != NULL) { \
                                    RIPMSG2(RIP_WARNING, "CHK_PTR(%s=%lx) is out of range.", #x, (ULONG_PTR)(x)); \
                                    DebugBreak(); \
                                } \
                            }
#else
#define CHK_OFFSET(x)
#define CHK_PTR(x)          if ((x) != NULL) { \
                                if ((LPVOID)(x) < (LPVOID)pHeader || (LPBYTE)(x) > (LPBYTE)pHeader + pHeader->dwMemSize) { \
                                    goto cleanup; \
                                } \
                            }
#endif

void ConvertImeMenuItemInfoAtoW(LPIMEMENUITEMINFOA lpA, LPIMEMENUITEMINFOW lpW, int nCP, BOOL copyBmp)
{
    int i;

    lpW->cbSize         = lpA->cbSize;
    lpW->fType          = lpA->fType;
    lpW->fState         = lpA->fState;
    lpW->wID            = lpA->wID;
    if (copyBmp) {
        lpW->hbmpChecked    = lpA->hbmpChecked;
        lpW->hbmpUnchecked  = lpA->hbmpUnchecked;
        lpW->hbmpItem       = lpA->hbmpItem;
    }
    lpW->dwItemData     = lpA->dwItemData;

    i = MultiByteToWideChar(nCP,
                            0,
                            lpA->szString,
                            lstrlenA(lpA->szString),
                            lpW->szString,
                            IMEMENUITEM_STRING_SIZE);

    lpW->szString[i] = L'\0';
}

void ConvertImeMenuItemInfoWtoA(LPIMEMENUITEMINFOW lpW, LPIMEMENUITEMINFOA lpA, int nCP)
{
    int i;
    BOOL bUDC;

    lpA->cbSize         = lpW->cbSize;
    lpA->fType          = lpW->fType;
    lpA->fState         = lpW->fState;
    lpA->wID            = lpW->wID;
    lpA->hbmpChecked    = lpW->hbmpChecked;
    lpA->hbmpUnchecked  = lpW->hbmpUnchecked;
    lpA->dwItemData     = lpW->dwItemData;
    lpA->hbmpItem       = lpW->hbmpItem;


    i = WideCharToMultiByte(nCP,
                            0,
                            lpW->szString,
                            wcslen(lpW->szString),
                            lpA->szString,
                            IMEMENUITEM_STRING_SIZE,
                            (LPSTR)NULL,
                            &bUDC);

    lpA->szString[i] = '\0';
}


#if DBG
void DumpBytes(LPBYTE pb, UINT size)
{
    UINT i;
    TRACE(("\npbmi dump:"));
    for (i = 0; i < size; ++i) {
        TRACE(("%02X ", pb[i] & 0xff));
    }
    TRACE(("\n"));
    UNREFERENCED_PARAMETER(pb); // just in case
}
#else
#define DumpBytes(a,b)
#endif

////////////////////////////////////////////////////////////////////
// SaveBitmapToMemory

IMEMENU_BMP_HEADER* SaveBitmapToMemory(HDC hDC, HBITMAP hBmp, IMEMENU_BMP_HEADER* lpBH, IMEMENU_HEADER* pHeader)
{
    HBITMAP hTmpBmp, hBmpOld;
    IMEMENU_BMP_HEADER* lpNext = NULL;
    PBITMAPINFO pbmi = &lpBH->bmi;
    ULONG sizBMI;


    if (!hBmp) {
        RIPMSG0(RIP_WARNING, "SaveBitmapToMemory: hBmp == NULL");
        return NULL;
    }
    UserAssert(lpBH != NULL);

    //
    // Let the graphics engine to retrieve the dimension of the bitmap for us
    // GetDIBits uses the size to determine if it's BITMAPCOREINFO or BITMAPINFO
    // if BitCount != 0, color table will be retrieved
    //
    pbmi->bmiHeader.biSize = sizeof pbmi->bmiHeader;
    pbmi->bmiHeader.biBitCount = 0;             // don't get the color table
    if ((GetDIBits(hDC, hBmp, 0, 0, (LPSTR)NULL, pbmi, DIB_RGB_COLORS)) == 0) {
        RIPMSG0(RIP_WARNING, "SaveBitmapToMemory: failed to GetDIBits(NULL)");
       return NULL;
    }


    //
    // Note: 24 bits per pixel has no color table.  So, we don't have to
    // allocate memory for retrieving that.  Otherwise, we do.
    //
    switch (pbmi->bmiHeader.biBitCount) {
        case 24:                                      // has color table
            sizBMI = sizeof(BITMAPINFOHEADER);
            break;
        case 16:
        case 32:
            sizBMI = sizeof(BITMAPINFOHEADER) + sizeof(DWORD) * 3;
            break;
        default:
            sizBMI = sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * (1 << pbmi->bmiHeader.biBitCount);
            break;

    }

    //
    // check if the buffer has enough space to put bitmap
    //
    if ((LPBYTE)pHeader + pHeader->dwMemSize < (LPBYTE)lpBH + sizeof lpBH + sizBMI + pbmi->bmiHeader.biSizeImage) {
        RIPMSG0(RIP_WARNING, "SaveBitmapToMemory: size of bmp image(s) exceed limit ");
        return FALSE;
    }

    //
    // Now that we know the size of the image, let pBits point the given buffer
    //
    lpBH->pBits = (LPBYTE)pbmi + sizBMI;

    //
    // Bitmap can't be selected into a DC when calling GetDIBits
    // Assume that the hDC is the DC where the bitmap would have been selected
    // if indeed it has been selected
    //
    if (hTmpBmp = CreateCompatibleBitmap(hDC, pbmi->bmiHeader.biWidth, pbmi->bmiHeader.biHeight)) {
        hBmpOld = SelectObject(hDC, hTmpBmp);
        if (GetDIBits(hDC, hBmp, 0, pbmi->bmiHeader.biHeight, (LPSTR)lpBH->pBits, pbmi, DIB_RGB_COLORS) == 0){
            SelectObject(hDC, hBmpOld);
            RIPMSG0(RIP_WARNING, "SaveBitmapToMemory: GetDIBits() failed.");
            return NULL;
        }
        lpNext = (IMEMENU_BMP_HEADER*)((LPBYTE)pbmi + sizBMI + pbmi->bmiHeader.biSizeImage);

        DumpBytes((LPBYTE)pbmi, sizeof *pbmi);
    } else {
        RIPMSG0(RIP_WARNING, "SaveBitmapToMemory: CreateCompatibleBitmap() failed.");
        return NULL;
    }

    SelectObject(hDC, hBmpOld);
    DeleteObject(hTmpBmp);
    return lpNext;
}

//////////////////////////////////////////////////////////////////////////////
// DecompileBitmap()
//
// decompile given hBitmap into IMEMENU_BMP_HEADER
// manupilate IMEMENU_BMP_HEADER links in IMEMENU_HEADER
//
// History:
// 23-Mar-1997 HiroYama Created
//////////////////////////////////////////////////////////////////////////////

IMEMENU_BMP_HEADER* DecompileBitmap(IMEMENU_HEADER* pHeader, HBITMAP hBitmap)
{
    IMEMENU_BMP_HEADER* pBmp = pHeader->lpBmp;
    HDC hDC;

    // first search handled bitmap
    while (pBmp) {
        if (pBmp->hBitmap == hBitmap) {
            // if hBitmap is already de-compiled, return it
            return pBmp;
        }
        pBmp = pBmp->lpNext;
    }

    // not yet allocated, so prepare memory buffer
    pBmp = pHeader->lpBmpNext;
    UserAssert(pBmp != NULL);
    CHK_PTR(pBmp);
    if (pBmp == NULL) {
        RIPMSG1(RIP_WARNING, "DecompileBitmap: pBmp == NULL in L%d", __LINE__);
        return NULL;
    }

    // use desktop's DC
    hDC = GetDC(GetDesktopWindow());
    if (hDC == NULL) {
        RIPMSG1(RIP_WARNING, "DecompileBitmap: hDC == NULL in L%d", __LINE__);
        return NULL;
    }

    //
    // decompile hBitmap
    //
    pBmp->lpNext = pHeader->lpBmp;
    pHeader->lpBmpNext = SaveBitmapToMemory(hDC, hBitmap, pBmp, pHeader);
    if (pHeader->lpBmpNext == NULL) {
        RIPMSG1(RIP_WARNING, "DecompileBitmap: pHeader->lpBmpNext == NULL in L%d", __LINE__);
        // error case. restore bmp link, then returns NULL
        pHeader->lpBmpNext = pBmp;
        pHeader->lpBmp = pBmp->lpNext;
        pBmp = NULL;
        goto cleanup;
    }

    // if succeeded, mark this BITMAP_HEADER with hBitmap
    pBmp->hBitmap = hBitmap;

    //
    // put this BITMAP_HEADER in linked list
    //
    pHeader->lpBmp = pBmp;

cleanup:
    if (hDC)
        ReleaseDC(GetDesktopWindow(), hDC);
    return pBmp;
}

//////////////////////////////////////////////////////////////////////////////
// ImmPutImeMenuItemsIntoMappedFile()
//
// Interprocess IME Menu handler
//
// called from ImeSystemHandler() in user32.dll
//
// handler of WM_IME_SYSTEM:IMS_MENU_ITEM
//
// History:
// 23-Mar-1997 HiroYama Created
//////////////////////////////////////////////////////////////////////////////

LRESULT ImmPutImeMenuItemsIntoMappedFile(HIMC hImc)
{
    HANDLE hMap = NULL;
    LPVOID lpMap = NULL;
    IMEMENU_HEADER* pHeader;
    LPIMEMENUITEMINFO lpBuf = NULL;
    IMEMENU_ITEM* pMenu;
    IMEMENU_BMP_HEADER* pBmp;
    LRESULT lRet = 0;
    ULONG_PTR offset;
    DWORD i;

    // Open memory mapped file
    hMap = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, IME_MENU_FILE_NAME);
    if (hMap == NULL) {
        RIPMSG0(RIP_WARNING, "ImmPutImeMenuItemsIntoMappedFile: cannot open mapped file.");
        return 0L;
    }

    // Map entire view of the file into the process memory space
    lpMap = MapViewOfFile(hMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);
    if (lpMap == NULL) {
        RIPMSG0(RIP_WARNING, "ImmPutImeMenuItemsIntoMappedFile: cannot map view of file.");
        goto cleanup;
        // I wish if I could use C++...
    }

    pHeader = (IMEMENU_HEADER*)lpMap;

    ///////////////////
    // Version check
    ///////////////////
    if (pHeader->dwVersion != 1) {
        RIPMSG1(RIP_WARNING, "ImmPutImeMenuItemsIntoMappedFile: dwVersion(%d) does not match.",
                pHeader->dwVersion);
        goto cleanup;
    }

    //////////////////////////////
    // convert offset to pointer
    offset = (ULONG_PTR)pHeader;
    CONVTO_PTR(pHeader->lpImeParentMenu);
    CHK_PTR(pHeader->lpImeParentMenu);
    pMenu = CONVTO_PTR(pHeader->lpImeMenu);
    CHK_PTR(pHeader->lpImeMenu);
    if (pHeader->dwSize) {
        UserAssert(pHeader->lpImeMenu);    // if dwSize is specified, we need real buffer here
        lpBuf = ImmLocalAlloc(HEAP_ZERO_MEMORY, pHeader->dwSize * sizeof(IMEMENUITEMINFOW));
        if (lpBuf == NULL) {
            RIPMSG0(RIP_WARNING, "ImmPutImeMenuItemsIntoMappedFile: not enough memory for receiver's buffer.");
            goto cleanup;
        }
    }


    // preparation
#if DBG
    if (pHeader->lpImeParentMenu) {
        UserAssert(!pHeader->lpImeParentMenu->lpBmpChecked &&
                   !pHeader->lpImeParentMenu->lpBmpUnchecked &&
                   !pHeader->lpImeParentMenu->lpBmpItem);
    }
#endif

    //////////////////////////////////
    // Get IME menus
    pHeader->dwSize = ImmGetImeMenuItemsW(hImc, pHeader->dwFlags, pHeader->dwType,
                                 (LPIMEMENUITEMINFOW)pHeader->lpImeParentMenu, lpBuf,
                                  pHeader->dwSize * sizeof(IMEMENUITEMINFOW));
    // now, pHeader->dwSize contains number of menu items rather than byte size
    if (pHeader->dwSize == 0) {
        goto cleanup;
    }
    //////////////////////////////////

    //
    // Copy back the information
    //
    // if lpBuf != NULL, we need to copy back information
    //
    if (lpBuf) {
        LPIMEMENUITEMINFO lpMenuW = lpBuf;

        pHeader->lpBmp = NULL;
        // lpBmpNext will point first possible memory for bmp de-compile
        pHeader->lpBmpNext = (LPVOID)((LPBYTE)pHeader + (pHeader->dwSize + 1) * sizeof(IMEMENUITEMINFOW));

        // copy menuinfo
        for (i = 0; i < pHeader->dwSize; ++i, ++pMenu, ++lpMenuW) {
            RtlCopyMemory(pMenu, lpMenuW, sizeof *lpMenuW);
            // decompile hbitmap
            if (lpMenuW->hbmpChecked) {
                if ((pMenu->lpBmpChecked = DecompileBitmap(pHeader, lpMenuW->hbmpChecked)) == NULL) {
                    RIPMSG1(RIP_WARNING, "ImmPutImeMenuItemsIntoMappedFile: DecompileBitmap Failed in L%d", __LINE__);
                    goto cleanup;
                }
            }
            if (lpMenuW->hbmpUnchecked) {
                if ((pMenu->lpBmpUnchecked = DecompileBitmap(pHeader, lpMenuW->hbmpUnchecked)) == NULL) {
                    RIPMSG1(RIP_WARNING, "ImmPutImeMenuItemsIntoMappedFile: DecompileBitmap Failed in L%d", __LINE__);
                    goto cleanup;
                }
            }
            if (lpMenuW->hbmpItem) {
                if ((pMenu->lpBmpItem = DecompileBitmap(pHeader, lpMenuW->hbmpItem)) == NULL) {
                    RIPMSG1(RIP_WARNING, "ImmPutImeMenuItemsIntoMappedFile: DecompileBitmap Failed in L%d", __LINE__);
                    goto cleanup;
                }
            }
        }

        //////////////////////////////////////////////////////////////////////
        //
        // convert pointer to offset
        //

        pMenu = pHeader->lpImeMenu;
        CONVTO_OFFSET(pHeader->lpImeMenu);
        // no need to convert parent menu, so let it be NULL
        D(pHeader->lpImeParentMenu = NULL);

        // pointer to BITMAP_HEADER in each menu
        for (i = 0; i < pHeader->dwSize; ++i, ++pMenu) {
            TRACE(("ImmPutImeMenuItemsIntoMappedFile: convertiong '%S'\n", pMenu->szString));
            CONVTO_OFFSET(pMenu->lpBmpChecked);
            CONVTO_OFFSET(pMenu->lpBmpUnchecked);
            TRACE(("ImmPutImeMenuItemsIntoMappedFile: before conversion (%#lx)\n", pMenu->lpBmpItem));
            CONVTO_OFFSET(pMenu->lpBmpItem);
            TRACE(("ImmPutImeMenuItemsIntoMappedFile: after  conversion (%#lx)\n", pMenu->lpBmpItem));

            // check them
            CHK_OFFSET(pMenu->lpBmpChecked);
            CHK_OFFSET(pMenu->lpBmpChecked);
            CHK_OFFSET(pMenu->lpBmpItem);
        }

        //
        // first pointer to BITMAP_HEADER linked list
        //
        pBmp = pHeader->lpBmp;
        CONVTO_OFFSET(pHeader->lpBmp);
        CHK_OFFSET(pHeader->lpBmp);
        // pHeader->lpBmpNext will not be used, so let it be NULL
        D(pHeader->lpBmpNext = NULL);

        //
        // pointers in BITMAP_HEADER linked list
        //
        while (pBmp) {
            IMEMENU_BMP_HEADER* ptBmp = pBmp->lpNext;
            CONVTO_OFFSET(pBmp->pBits);
            CONVTO_OFFSET(pBmp->lpNext);
            CHK_OFFSET(pBmp->lpNext);
            pBmp = ptBmp;
        }
        //
        // pointer conversion finished
        //
        //////////////////////////////////////////////////////////////////////
    } // end if (lpBuf)

    //
    // everything went OK
    //
    lRet = 1;

cleanup:
    if (lpBuf)
        ImmLocalFree(lpBuf);
    if (lpMap)
        UnmapViewOfFile(lpMap);
    if (hMap)
        CloseHandle(hMap);
    return lRet;
}


//////////////////////////////////////////////////////////////////////////////
// InternalImeMenuCreateBitmap()
//
// create bitmap from IMEMENU_BMP_HEADER
//////////////////////////////////////////////////////////////////////////////

HBITMAP InternalImeMenuCreateBitmap(IMEMENU_BMP_HEADER* lpBH)
{
    HDC hDC;

    if (lpBH == NULL) {
        RIPMSG1(RIP_WARNING, "InternalImeMenuCreateBitmap: lpBH == NULL in L%d", __LINE__);
        return NULL;
    }
    if (lpBH->pBits == NULL) {
        RIPMSG1(RIP_WARNING, "InternalImeMenuCreateBitmap: lpBH->pBits == NULL in L%d", __LINE__);
        return NULL;
    }

    if (lpBH->hBitmap) {
        TRACE(("InternalImeMenuCreateBitmap: lpBH->hBitmap != NULL. will return it.\n"));
        return lpBH->hBitmap;
    }

    if (hDC = GetDC(GetDesktopWindow())) {
        HDC hMyDC = CreateCompatibleDC(hDC);
        if (hMyDC) {
            // (select palette) needed ?
            lpBH->hBitmap = CreateDIBitmap(hDC, &lpBH->bmi.bmiHeader, CBM_INIT,
                                                  lpBH->pBits, &lpBH->bmi, DIB_RGB_COLORS);
            if (lpBH->hBitmap == NULL) {
                DWORD dwErr = GetLastError();
                RIPMSG1(RIP_WARNING, "InternalImeMenuCreateBitmap: CreateDIBitmap Failed. Last error=%#x\n", dwErr);
            }
            DeleteDC(hMyDC);
        }
        else {
            RIPMSG0(RIP_WARNING, "InternalImeMenuCreateBitmap: CreateCompatibleDC failed.");
        }

        ReleaseDC(GetDesktopWindow(), hDC);
    }
    else {
        RIPMSG0(RIP_WARNING, "InternalImeMenuCreateBitmap: couldn't get Desktop DC.");
    }
    return lpBH->hBitmap;
}

//////////////////////////////////////////////////////////////////////////////
// ImmGetImeMenuItemsInterProcess()
//
// Inter process IME Menu handler
// sends WM_IME_SYSTEM:IMS_GETIMEMENU
//
// History:
// 23-Mar-1997 HiroYama Created
//////////////////////////////////////////////////////////////////////////////

DWORD ImmGetImeMenuItemsInterProcess(HIMC hImc,
                                     DWORD dwFlags,
                                     DWORD dwType,
                                     LPIMEMENUITEMINFOW lpParentMenu,
                                     LPIMEMENUITEMINFOW lpMenu,
                                     DWORD dwSize)
{
    HWND hwnd;
    HANDLE hMemFile = NULL;
    DWORD dwRet = 0;
    LPBYTE lpMap = NULL;
    IMEMENU_HEADER* pHeader;
    IMEMENU_ITEM* pMenuItem;
    IMEMENU_BMP_HEADER* pBmpHeader;
    DWORD i;
    ULONG_PTR offset;

    // Get default IME window
    //
    // Note: We do not consider user created HIMC here, because this inter-process call is intended to
    // support only internat.exe, and this message is passed as just a kick to IMM's def WinProc.
    hwnd = (HWND)NtUserQueryInputContext(hImc, InputContextDefaultImeWindow);
    if (hwnd == NULL || !IsWindow(hwnd)) {
        RIPMSG1(RIP_WARNING, "ImmGetImeMenuItemsInterProcess: hwnd(%lx) is not a valid window.", hwnd);
        return 0;
    }

    RtlEnterCriticalSection(&gcsImeDpi);

    // first, create memory mapped file
    hMemFile = CreateFileMapping((HANDLE)~0, NULL, PAGE_READWRITE,
                                 0, IME_MENU_MAXMEM, IME_MENU_FILE_NAME);
    if (hMemFile == NULL) {
        RIPMSG0(RIP_WARNING, "ImmGetImeMenuItemsInterProcess: cannot allocate memory mapped file.");
        goto cleanup;
    }
    // then get a view of the mapped file
    lpMap = (LPBYTE)MapViewOfFile(hMemFile, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
    if (lpMap == NULL) {
        RIPMSG0(RIP_WARNING, "ImmGetImeMenuItemsInterProcess: cannot map view of memory mapped file.");
        goto cleanup;
    }

    //
    // shared buffer (memory mapped file) initialization
    //
    pHeader = (IMEMENU_HEADER*)lpMap;
    RtlZeroMemory(pHeader, sizeof *pHeader);
    pHeader->dwVersion = 1;
    pHeader->dwMemSize = IME_MENU_MAXMEM;
    pHeader->dwSize = dwSize / sizeof(IMEMENUITEMINFOW);    // CAUTION: dwSize could be 0.
    RIPMSG1(RIP_WARNING, "ImmGetImeMenuItemsInterProcess: pHeader->dwSize=%ld", pHeader->dwSize);
    pHeader->dwFlags = dwFlags;
    pHeader->dwType = dwType;

    //
    // 1) dwSize != 0 and lpMenu != NULL means, caller requests the given buffer filled
    // 2) if lpParentMenu is passed, we need to put its information in shared buffer
    //
    if ((dwSize && lpMenu) || lpParentMenu) {
        // if parent menu is specified, copy it here
        if (lpParentMenu) {
            IMEMENU_ITEM* pPMenu =
                pHeader->lpImeParentMenu = (IMEMENU_ITEM*)&pHeader[1];

            RtlCopyMemory(pPMenu, lpParentMenu, sizeof(IMEMENUITEMINFOW));

            // by design, IME will receive NULL hbmpItem in parent menu.
            // there is no way to guarantee the same hbmpItem is returned, thus NULL is passed.
            pPMenu->lpBmpChecked = pPMenu->lpBmpUnchecked = pPMenu->lpBmpItem = NULL;
            pHeader->lpImeMenu = pHeader->lpImeParentMenu + 1;
        }
        else {
            pHeader->lpImeParentMenu = NULL;
            pHeader->lpImeMenu = (LPVOID)&pHeader[1];
        }
        // convert pointer to offset
        offset = (ULONG_PTR)lpMap;
        CONVTO_OFFSET(pHeader->lpImeParentMenu);
        CONVTO_OFFSET(pHeader->lpImeMenu);
    }




    ///////////////////////////////////////////////////////////////////////
    if (!SendMessage(hwnd, WM_IME_SYSTEM, IMS_GETIMEMENU, (LPARAM)hImc)) {
        // if it fails
        goto cleanup;
    }
    ///////////////////////////////////////////////////////////////////////

    // NOTE: dwSize is maximum index of menu array. not a total byte size of array.
    dwSize = pHeader->dwSize;

    if (lpMenu) {
        ///////////////////////////////
        // convert offset to pointer
        ///////////////////////////////
        pMenuItem = CONVTO_PTR(pHeader->lpImeMenu);
        CHK_PTR(pMenuItem);
        // NOTE: we don't have to handle parent menu

        //
        // pointers to BITMAP_HEADER in each menu structure
        //
        for (i = 0; i < dwSize; ++i, ++pMenuItem) {
            CONVTO_PTR(pMenuItem->lpBmpChecked);
            CONVTO_PTR(pMenuItem->lpBmpUnchecked);
            CONVTO_PTR(pMenuItem->lpBmpItem);
            //
            // check the pointers
            //
            CHK_PTR(pMenuItem->lpBmpChecked);
            CHK_PTR(pMenuItem->lpBmpUnchecked);
            CHK_PTR(pMenuItem->lpBmpItem);
        }

        //
        // pointer to first BITMAP_HEADER
        //
        pBmpHeader = CONVTO_PTR(pHeader->lpBmp);

        //
        // each BITMAP_HEADER
        //
        while (pBmpHeader) {
            pBmpHeader->hBitmap = NULL;    // clear
            // pBits
            CONVTO_PTR(pBmpHeader->pBits);
            CHK_PTR(pBmpHeader->pBits);

            // next BITMAP_HEADER
            pBmpHeader = CONVTO_PTR(pBmpHeader->lpNext);
            CHK_PTR(pBmpHeader);
        }

        //
        // copy back the results
        //
        pMenuItem = pHeader->lpImeMenu;
        for (i = 0; i < dwSize; ++i, ++pMenuItem, ++lpMenu) {
            lpMenu->cbSize = pMenuItem->cbSize;
            lpMenu->fType = pMenuItem->fType;
            lpMenu->fState = pMenuItem->fState;
            lpMenu->wID = pMenuItem->wID;
            lpMenu->dwItemData = pMenuItem->dwItemData;
            wcscpy(lpMenu->szString, pMenuItem->szString);

            // Create bitmap from memory buffer
            // hbmp will be NULL if no bmp is specified.
            if (pMenuItem->lpBmpChecked) {
                lpMenu->hbmpChecked = InternalImeMenuCreateBitmap(pMenuItem->lpBmpChecked);
            }
            else {
                lpMenu->hbmpChecked = NULL;
            }
            if (pMenuItem->lpBmpUnchecked) {
                lpMenu->hbmpUnchecked = InternalImeMenuCreateBitmap(pMenuItem->lpBmpUnchecked);
            }
            else {
                lpMenu->hbmpUnchecked = NULL;
            }
            if (pMenuItem->lpBmpItem) {
                lpMenu->hbmpItem = InternalImeMenuCreateBitmap(pMenuItem->lpBmpItem);
            }
            else {
                lpMenu->hbmpItem = NULL;
            }
        }
    }


cleanup:
    if (lpMap) {
        UnmapViewOfFile(lpMap);
    }
    RtlLeaveCriticalSection(&gcsImeDpi);
    // destroy memory mapped file
    if (hMemFile) {
        CloseHandle(hMemFile);
    }

    return dwSize;
}

//////////////////////////////////////////////////////////////////////////////
// ImmGetImeMenuItemsWorker()
//
// Handler of IME Menu
//
// if specified HIMC belongs to other process, it calls
// ImmGetImeMenuItemsInterProcess()
//
// History:
// 23-Mar-1997 HiroYama Created
//////////////////////////////////////////////////////////////////////////////


DWORD ImmGetImeMenuItemsWorker(HIMC hIMC,
                               DWORD dwFlags,
                               DWORD dwType,
                               LPVOID lpImeParentMenu,
                               LPVOID lpImeMenu,
                               DWORD dwSize,
                               BOOL bAnsiOrigin)
{
    BOOL bAnsiIme = IsAnsiIMC(hIMC);
    DWORD dwRet = 0;
    LPINPUTCONTEXT lpInputContext;
    DWORD dwThreadId;
    PIMEDPI pImeDpi = NULL;
    LPVOID lpImePTemp = lpImeParentMenu;    // keeps parent menu
    LPVOID lpImeTemp = lpImeMenu;           // points menu buffer
    IMEMENUITEMINFOA imiiParentA;
    IMEMENUITEMINFOW imiiParentW;

    //
    // check if the call will be inter process
    //
    {
        DWORD dwProcessId = GetInputContextProcess(hIMC);
        if (dwProcessId == 0) {
            RIPMSG0(RIP_WARNING, "ImmGetImeMenuItemsWorker: dwProcessId == 0");
            return 0;
        }
        if (dwProcessId != GetCurrentProcessId()) {
            //
            // going to call another process' IME
            //
            TRACE(("ImmGetImeMenuItemsWorker: Inter process.\n"));
            if (bAnsiOrigin) {
                //
                // this inter-process thing is only allowed to internat.exe or equivalent
                //
                RIPMSG0(RIP_WARNING, "ImmGetImeMenuItemsWorker: interprocess getmenu is not allowed for ANSI caller.");
                return 0;
            }
            return ImmGetImeMenuItemsInterProcess(hIMC, dwFlags, dwType, lpImeParentMenu,
                                                  lpImeMenu, dwSize);
        }
    }

    //
    // within process
    //

    if (hIMC == NULL || (lpInputContext = ImmLockIMC(hIMC)) == NULL) {
        RIPMSG2(RIP_WARNING, "ImmGetImeMenuItemsWorker: illegal hIMC(%#lx) in L%d", hIMC, __LINE__);
        return 0;
    }

    dwThreadId = GetInputContextThread(hIMC);
    if (dwThreadId == 0) {
        RIPMSG1(RIP_WARNING, "ImmGetImeMenuItemsWorker: dwThreadId = 0 in L%d", __LINE__);
        goto cleanup;
    }
    if ((pImeDpi = ImmLockImeDpi(GetKeyboardLayout(dwThreadId))) == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetImeMenuItemWorker: pImeDpi == NULL in L%d.", __LINE__);
        goto cleanup;
    }

#if 0   // NT: we don't keep version info in ImeDpi
    if (pImeDpi->dwWinVersion <= IMEVER_0310) {
        RIPMSG1(RIP_WARNING, "GetImeMenuItems: OldIME does not support this. %lx", hIMC);
        goto cleanup;
    }
#endif

    //
    // if IME does not support IME Menu, do nothing
    //
    if (pImeDpi->pfn.ImeGetImeMenuItems) {
        LPVOID lpNewBuf = NULL;

        TRACE(("ImmGetImeMenuItemsWorker: IME has menu callback.\n"));

        if (bAnsiIme != bAnsiOrigin) {
            //
            // we need A/W translation before calling IME
            //
            if (bAnsiOrigin) {
                // ANSI API and UNICODE IME.
                // A to W conversion needed here
                if (lpImeParentMenu) {
                    // parent menu is specified. need conversion
                    lpImePTemp = (LPVOID)&imiiParentW;
                    ConvertImeMenuItemInfoAtoW((LPIMEMENUITEMINFOA)lpImeParentMenu,
                                               (LPIMEMENUITEMINFOW)lpImePTemp,
                                                CP_ACP, TRUE);  // ANSI app, UNICODE IME: let's use CP_ACP
                }
                if (lpImeMenu) {
                    // allocate memory block for temporary storage
                    DWORD dwNumBuffer = dwSize / sizeof(IMEMENUITEMINFOA);
                    dwSize = dwNumBuffer * sizeof(IMEMENUITEMINFOW);
                    if (dwSize == 0) {
                        RIPMSG0(RIP_WARNING, "ImmGetImeMenuItemsWorker: (AtoW) dwSize is 0.");
                        goto cleanup;
                    }
                    lpImeTemp = lpNewBuf = ImmLocalAlloc(0, dwSize);
                    TRACE(("ImmGetImeMenuItemsWorker: for UNICODE IME memory allocated %d bytes. lpNewBuf=%#x\n", dwSize, lpNewBuf));
                    if (lpNewBuf == NULL) {
                        RIPMSG1(RIP_WARNING, "ImmGetImeMenuItemsWorker: cannot alloc lpNewBuf in L%d", __LINE__);
                        goto cleanup;
                    }
                }
            }
            else {
                // UNICODE API and ANSI IME.
                // W to A conversion needed here
                if (lpImeParentMenu) {
                    // parent menu is speicified. need conversion
                    lpImePTemp = (LPVOID)&imiiParentA;
                    ConvertImeMenuItemInfoWtoA((LPIMEMENUITEMINFOW)lpImeParentMenu,
                                               (LPIMEMENUITEMINFOA)lpImePTemp,
                                                pImeDpi->dwCodePage);   // Note: hopefully in the future, this can be changed to IMECodePage(pImeDpi)
                }
                if (lpImeMenu) {
                    // allocate memory block for temporary storage
                    DWORD dwNumBuffer = dwSize / sizeof(IMEMENUITEMINFOW);
                    dwSize = dwNumBuffer / sizeof(IMEMENUITEMINFOA);
                    if (dwSize == 0) {
                        RIPMSG0(RIP_WARNING, "ImmGetImeMenuItemsWorker: (WtoA) dwSize is 0.");
                        goto cleanup;
                    }
                    lpImeTemp = lpNewBuf = ImmLocalAlloc(0, dwSize);
                    RIPMSG2(RIP_WARNING, "ImmGetImeMenuItemsWorker: for ANSI IME memory allocated %d bytes. lpNewBuf=%#x", dwSize, lpNewBuf);
                    if (lpNewBuf == NULL) {
                        RIPMSG1(RIP_WARNING, "ImmGetImeMenuItemsWorker: cannot alloc lpNewBuf in L%d", __LINE__);
                        goto cleanup;
                    }
                }
            }
        }

        ////////////////////////////////////////
        dwRet = pImeDpi->pfn.ImeGetImeMenuItems(hIMC, dwFlags, dwType, lpImePTemp, lpImeTemp, dwSize);
        ////////////////////////////////////////

        //
        // back-conversion needed if:
        // 1) IME returns menus, and
        // 2) A/W is different between caller and IME, and
        // 3) caller wants the buffer to be filled
        //
        if (dwRet && bAnsiIme != bAnsiOrigin && lpImeTemp) {
            if (bAnsiOrigin) {
                // ANSI API and UNICODE IME.
                // W to A conversion needed here
                LPIMEMENUITEMINFOW lpW = (LPIMEMENUITEMINFOW)lpImeTemp;
                LPIMEMENUITEMINFOA lpA = (LPIMEMENUITEMINFOA)lpImeMenu;
                DWORD i;

                for (i = 0; i < dwRet; ++i) {
                    ConvertImeMenuItemInfoWtoA((LPIMEMENUITEMINFOW)lpW++,
                                               (LPIMEMENUITEMINFOA)lpA++,
                                                CP_ACP);    // ANSI app and UNICODE IME: let's use CP_ACP
                }
            }
            else {
                // UNICODE API and ANSI IME.
                // A to W conversion needed here
                LPIMEMENUITEMINFOA lpA = (LPIMEMENUITEMINFOA)lpImeTemp;
                LPIMEMENUITEMINFOW lpW = (LPIMEMENUITEMINFOW)lpImeMenu;
                DWORD i;

                for (i = 0; i < dwSize; i++) {
                    ConvertImeMenuItemInfoAtoW((LPIMEMENUITEMINFOA)lpA++,
                                               (LPIMEMENUITEMINFOW)lpW++,
                                               pImeDpi->dwCodePage,     // Note: hopefully in the future, this can be changed to IMECodePage(pImeDpi)
                                               TRUE); // copy hbitmap also
                }
            }
        }

        // free temporary buffer if we've allocated it
        if (lpNewBuf)
            ImmLocalFree(lpNewBuf);
    }   // end if IME has menu callback

cleanup:
    if (pImeDpi) {
        ImmUnlockImeDpi(pImeDpi);
    }

    if (hIMC != NULL) {
        ImmUnlockIMC(hIMC);
    }

    return dwRet;
}


DWORD WINAPI ImmGetImeMenuItemsA(
    HIMC    hIMC,
    DWORD   dwFlags,
    DWORD   dwType,
    LPIMEMENUITEMINFOA lpImeParentMenu,
    LPIMEMENUITEMINFOA lpImeMenu,
    DWORD   dwSize)
{
    return ImmGetImeMenuItemsWorker(hIMC, dwFlags, dwType,
                                    (LPVOID)lpImeParentMenu,
                                    (LPVOID)lpImeMenu, dwSize, TRUE /* ANSI origin */);
}


DWORD WINAPI ImmGetImeMenuItemsW(
    HIMC    hIMC,
    DWORD   dwFlags,
    DWORD   dwType,
    LPIMEMENUITEMINFOW lpImeParentMenu,
    LPIMEMENUITEMINFOW lpImeMenu,
    DWORD   dwSize)
{
    return ImmGetImeMenuItemsWorker(hIMC, dwFlags, dwType,
                                    (LPVOID)lpImeParentMenu,
                                    (LPVOID)lpImeMenu, dwSize, FALSE /* UNICODE origin */);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\ctxtinfo.c ===
/**************************************************************************\
* Module Name: ctxtinfo.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Get/set routines of various Input context information for imm32.dll
*
* History:
* 26-Feb-1996 wkwok
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

// Helper function:
// Converts RECONVERTSTRING structure between ANSI and UNICODE.
extern DWORD ImmReconversionWorker(LPRECONVERTSTRING lpRecTo, LPRECONVERTSTRING lpRecFrom, BOOL bToAnsi, DWORD dwCodePage);


int UnicodeToMultiByteSize(DWORD dwCodePage, LPCWSTR pwstr)
{
    char dummy[2], *lpszDummy = dummy;
    return WCSToMBEx((WORD)dwCodePage, pwstr, 1, &lpszDummy, sizeof(WCHAR), FALSE);
}


/***************************************************************************\
* ImmGetCompositionStringA
*
* Query composition string information specified by dwIndex.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

LONG WINAPI ImmGetCompositionStringA(
    HIMC   hImc,
    DWORD  dwIndex,
    LPVOID lpBuf,
    DWORD  dwBufLen)
{
    PCLIENTIMC     pClientImc;
    PINPUTCONTEXT  pInputContext;
    PCOMPOSITIONSTRING pCompStr;
    BOOL           fAnsi;
    LONG           lRet = 0;
    DWORD          dwCodePage;

    if (dwBufLen != 0 && lpBuf == NULL) {
        RIPMSG0(RIP_WARNING, "ImmGetCompositionStringW: NULL lpBuf.");
        return lRet;
    }

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmGetCompositionStringA: Invalid hImc %lx.", hImc);
        return lRet;
    }

    fAnsi = !TestICF(pClientImc, IMCF_UNICODE);
    dwCodePage = CImcCodePage(pClientImc);

    ImmUnlockClientImc(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionStringA: Lock hImc %lx failed.", hImc);
        return lRet;
    }

    pCompStr = (PCOMPOSITIONSTRING)ImmLockIMCC(pInputContext->hCompStr);
    if (pCompStr == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionStringA: Lock hCompStr %x failed",
              pInputContext->hCompStr);
        ImmUnlockIMC(hImc);
        return lRet;
    }

#if !defined(CUAS_ENABLE)
    lRet = InternalGetCompositionStringA(pCompStr, dwIndex,
                     lpBuf, dwBufLen, fAnsi, dwCodePage);
#else
    lRet = InternalGetCompositionStringA(hImc, pCompStr, dwIndex,
                     lpBuf, dwBufLen, fAnsi, dwCodePage);
#endif

    ImmUnlockIMCC(pInputContext->hCompStr);
    ImmUnlockIMC(hImc);

    return lRet;
}


/***************************************************************************\
* ImmGetCompositionStringA
*
* Query composition string information specified by dwIndex.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

LONG WINAPI ImmGetCompositionStringW(
    HIMC   hImc,
    DWORD  dwIndex,
    LPVOID lpBuf,
    DWORD  dwBufLen)
{
    PCLIENTIMC     pClientImc;
    PINPUTCONTEXT  pInputContext;
    PCOMPOSITIONSTRING pCompStr;
    BOOL           fAnsi;
    LONG           lRet = 0;
    DWORD          dwCodePage;

    if (dwBufLen != 0 && lpBuf == NULL) {
        RIPMSG0(RIP_WARNING, "ImmGetCompositionStringW: NULL lpBuf.");
        return lRet;
    }

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmGetCompositionStringW: Invalid hImc %lx.", hImc);
        return lRet;
    }

    fAnsi = !TestICF(pClientImc, IMCF_UNICODE);
    dwCodePage = CImcCodePage(pClientImc);

    ImmUnlockClientImc(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionStringW: Lock hImc %lx failed.", hImc);
        return lRet;
    }

    pCompStr = (PCOMPOSITIONSTRING)ImmLockIMCC(pInputContext->hCompStr);
    if (pCompStr == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionStringA: Lock hCompStr %x failed",
              pInputContext->hCompStr);
        ImmUnlockIMC(hImc);
        return lRet;
    }

#if !defined(CUAS_ENABLE)
    lRet = InternalGetCompositionStringW(pCompStr, dwIndex,
                     lpBuf, dwBufLen, fAnsi, dwCodePage);
#else
    lRet = InternalGetCompositionStringW(hImc, pCompStr, dwIndex,
                     lpBuf, dwBufLen, fAnsi, dwCodePage);
#endif

    ImmUnlockIMCC(pInputContext->hCompStr);
    ImmUnlockIMC(hImc);

    return lRet;
}


/***************************************************************************\
* ImmSetCompositionStringA
*
* Set composition string information specified by dwIndex.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmSetCompositionStringA(
    HIMC    hImc,
    DWORD   dwIndex,
    LPVOID lpComp,
    DWORD   dwCompLen,
    LPVOID lpRead,
    DWORD   dwReadLen)
{
    return ImmSetCompositionStringWorker(hImc, dwIndex, lpComp,
                                dwCompLen, lpRead, dwReadLen, TRUE);
}


/***************************************************************************\
* ImmSetCompositionStringW
*
* Set composition string information specified by dwIndex.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmSetCompositionStringW(
    HIMC    hImc,
    DWORD   dwIndex,
    LPVOID lpComp,
    DWORD   dwCompLen,
    LPVOID lpRead,
    DWORD   dwReadLen)
{
    return ImmSetCompositionStringWorker(hImc, dwIndex, lpComp,
                                dwCompLen, lpRead, dwReadLen, FALSE);
}


LONG CompositionString(
    HIMC               hImc,
    PINPUTCONTEXT      *ppInputContext,
    PCOMPOSITIONSTRING *ppCompStr,
    BOOL               fCheckSize)
{
    PINPUTCONTEXT      pInputContext;
    PCOMPOSITIONSTRING pCompStr;

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "CompositionString: Lock hImc %lx failed.", hImc);
        return (LONG)IMM_ERROR_GENERAL;
    }

    if (!pInputContext->hCompStr) {
        ImmUnlockIMC(hImc);
        return (LONG)IMM_ERROR_NODATA;
    }

    pCompStr = (PCOMPOSITIONSTRING)ImmLockIMCC(pInputContext->hCompStr);
    if (!pCompStr) {
        RIPMSG1(RIP_WARNING,
              "CompositionString: Lock hCompStr %lx failed.", pInputContext->hCompStr);
        ImmUnlockIMC(hImc);
        return (LONG)IMM_ERROR_GENERAL;
    }

    if (fCheckSize && pCompStr->dwSize < sizeof(COMPOSITIONSTRING)) {
        RIPMSG0(RIP_WARNING, "CompositionString: no composition string.");
        ImmUnlockIMCC(pInputContext->hCompStr);
        ImmUnlockIMC(hImc);
        return (LONG)IMM_ERROR_NODATA;
    }

    *ppInputContext = pInputContext;
    *ppCompStr = pCompStr;

    return (1);
}


BOOL CheckAttribute(
    LPBYTE  lpComp,        // the attr from apps
    DWORD   dwCompLen,     // the attr length from apps
    LPBYTE  lpAttr,        // the attr from IMC
    DWORD   dwAttrLen,     // the attr length from IMC
    LPDWORD lpClause,      // the clause from IMC
    DWORD   dwClauseLen)   // the clause length from IMC
{
    DWORD dwCnt;
    DWORD dwBound;
    BYTE bAttr;

    UNREFERENCED_PARAMETER(dwClauseLen);

    if (!lpClause) {
        RIPMSG0(RIP_WARNING, "CheckAttribute: no Clause. Pass it to IME.");
        return (TRUE);
    }

    if (!lpAttr) {
        RIPMSG0(RIP_WARNING, "CheckAttribute: no Attr. Not pass it to IME.");
        return (FALSE);
    }

    if (dwCompLen != dwAttrLen) {
        RIPMSG0(RIP_WARNING, "CheckAttribute: wrong length. Not pass it to IME.");
        return (FALSE);
    }

    /*
     * The attr. of chars of one clause have to be same.
     */
    while (*lpClause < dwCompLen) {
        dwBound = *(lpClause+1) - *lpClause;
        bAttr = *lpComp++;
        for (dwCnt = 1; dwCnt < dwBound; dwCnt++)
            if (bAttr != *lpComp++) {
                RIPMSG0(RIP_WARNING,
                      "CheckAttribute: mismatch clause att. Not Pass it to IME");
                return (FALSE);
            }
        lpClause++;
    }

    return (TRUE);
}


BOOL CheckClause(
    LPDWORD lpComp,        // the clause from apps
    DWORD   dwCompLen,     // the clause length from apps
    LPDWORD lpClause,      // the clause from IMC
    DWORD   dwClauseLen)   // the clause length from IMC
{
    UINT nCnt;
    INT  diff = 0;

    if (!dwClauseLen || !dwCompLen) {
        RIPMSG0(RIP_WARNING, "CheckClause: no Clause. Not Pass it to IME.");
        return (FALSE);
    }

    if (*lpComp || *lpClause) {
        RIPMSG0(RIP_WARNING, "CheckClause: lpClause[0] have to be ZERO.");
        return (FALSE);
    }

    for (nCnt = 0; nCnt < (UINT)(dwClauseLen/4); nCnt++)
    {
        if (*lpComp++ != *lpClause++)
        {
            diff++;
            if (dwCompLen > dwClauseLen)
                lpClause--;
            if (dwCompLen < dwClauseLen)
                lpComp--;
        }
        if (diff > 1)
            return (FALSE);
    }

    return (TRUE);
}


LPBYTE InternalSCS_SETSTR(
    LPCVOID  lpCompRead,
    DWORD    dwCompReadLen,
    LPVOID  *lplpNewCompRead,
    DWORD   *lpdwNewCompReadLen,
    BOOL     fAnsi,
    DWORD    dwCodePage)
{
    LPBYTE   lpBufRet;
    DWORD    dwBufSize;
    LPSTR    lpBufA;
    LPWSTR   lpBufW;
    INT      i;
    BOOL     bUDC;

    if (lpCompRead == NULL || dwCompReadLen == 0)
        return NULL;

    dwBufSize = dwCompReadLen * sizeof(WCHAR) * 2;

    lpBufRet = ImmLocalAlloc(0, dwBufSize);
    if (lpBufRet == NULL) {
        RIPMSG0(RIP_WARNING, "InternalSCS_SETSTR: memory failure.");
        return NULL;
    }

    lpBufW = (LPWSTR)lpBufRet;
    lpBufA = (LPSTR)(lpBufW + dwCompReadLen);

    if (fAnsi) {

        RtlCopyMemory(lpBufA, lpCompRead, dwCompReadLen);

        i = MultiByteToWideChar(dwCodePage,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpBufA,                  // src
                                (INT)dwCompReadLen,
                                (LPWSTR)lpBufW,                 // dest
                                (INT)dwCompReadLen);

        *lplpNewCompRead    = lpBufW;
        *lpdwNewCompReadLen = (DWORD)(i * sizeof(WCHAR));
    }
    else {

        RtlCopyMemory(lpBufW, lpCompRead, dwCompReadLen);

        i = WideCharToMultiByte(dwCodePage,
                                (DWORD)0,
                                lpBufW,                         // src
                                (INT)dwCompReadLen/sizeof(WCHAR),
                                (LPSTR)lpBufA,                  // dest
                                (INT)dwCompReadLen,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);

        *lplpNewCompRead    = lpBufA;
        *lpdwNewCompReadLen = (DWORD)(i * sizeof(CHAR));
    }

    return lpBufRet;
}


LPBYTE InternalSCS_CHANGEATTR(
    HIMC     hImc,
    LPCVOID  lpCompRead,
    DWORD    dwCompReadLen,
    DWORD    dwIndex,
    LPVOID  *lplpNewCompRead,
    DWORD   *lpdwNewCompReadLen,
    BOOL     fAnsi,
    DWORD    dwCodePage)
{
    LPBYTE lpBufRet;
    LPBYTE lpAttr, lpAttrA, lpAttrW;
    DWORD  dwBufLenA, dwBufLenW;
    LPSTR  lpStrBufA, lpBufA;
    LPWSTR lpStrBufW, lpBufW;
    CHAR   c;
    WCHAR  wc;
    ULONG  MultiByteSize;

    if (lpCompRead == NULL || dwCompReadLen == 0)
        return NULL;

    if (fAnsi) {

        dwBufLenA = ImmGetCompositionStringA(hImc, dwIndex, NULL, 0);

        lpStrBufA = ImmLocalAlloc(0, dwBufLenA);
        if (lpStrBufA == NULL) {
            RIPMSG0(RIP_WARNING, "InternalSCS_CHANGEATTR: memory failure.");
            return NULL;
        }

        ImmGetCompositionStringA(hImc, dwIndex, lpStrBufA, dwBufLenA);

        lpBufRet = ImmLocalAlloc(0, dwBufLenA);
        if (lpBufRet == NULL) {
            RIPMSG0(RIP_WARNING, "InternalSCS_CHANGEATTR: memory failure.");
            ImmLocalFree(lpStrBufA);
            return NULL;
        }

        lpBufA  = lpStrBufA;
        lpAttrA = (LPBYTE)lpCompRead;
        lpAttr  = lpBufRet;

        while (dwBufLenA != 0 && (c=*lpBufA++) != 0) {
            if (IsDBCSLeadByteEx(dwCodePage, c)) {
                if (dwBufLenA >= 2) {
                    *lpAttr++ = *lpAttrA++;
                    dwBufLenA--;
                } else {
                    *lpAttr++ = *lpAttrA;
                }
                lpBufA++;
            } else {
                *lpAttr++ = *lpAttrA;
            }
            lpAttrA++;
            dwBufLenA--;
        }

        ImmLocalFree(lpStrBufA);
    }
    else {

        dwBufLenW = ImmGetCompositionStringW(hImc, dwIndex, NULL, 0);

        lpStrBufW = ImmLocalAlloc(0, dwBufLenW);
        if (lpStrBufW == NULL) {
            RIPMSG0(RIP_WARNING, "InternalSCS_CHANGEATTR: memory failure.");
            return NULL;
        }

        ImmGetCompositionStringW(hImc, dwIndex, lpStrBufW, dwBufLenW);

        lpBufRet = ImmLocalAlloc(0, dwBufLenW);
        if (lpBufRet == NULL) {
            RIPMSG0(RIP_WARNING, "InternalSCS_CHANGEATTR: memory failure.");
            ImmLocalFree(lpStrBufW);
            return NULL;
        }

        lpBufW  = lpStrBufW;
        lpAttrW = (LPBYTE)lpCompRead;
        lpAttr  = lpBufRet;

        while (dwBufLenW != 0 && (wc=*lpBufW++) != L'\0') {
            MultiByteSize = UnicodeToMultiByteSize(dwCodePage, &wc);
            if (MultiByteSize == 2) {
                *lpAttr++ = *lpAttrW;
            }
            *lpAttr++ = *lpAttrW++;
            dwBufLenW -= sizeof(WCHAR);
        }

        ImmLocalFree(lpStrBufW);
    }

    *lplpNewCompRead    = lpBufRet;
    *lpdwNewCompReadLen = (DWORD)(lpAttr - (PBYTE)lpBufRet);

    return lpBufRet;
}


LPBYTE InternalSCS_CHANGECLAUSE(
    HIMC     hImc,
    LPCVOID  lpCompRead,
    DWORD    dwCompReadLen,
    DWORD    dwIndex,
    LPDWORD *lplpNewCompRead,
    DWORD   *lpdwNewCompReadLen,
    BOOL     fAnsi,
    DWORD    dwCodePage)
{
    LPDWORD lpdw, lpNewdw, lpBufRet;
    DWORD   dwBufLenA, dwBufLenW;
    LPSTR   lpStrBufA = NULL;
    LPWSTR  lpStrBufW = NULL;
    INT     i;

    if (lpCompRead == NULL || dwCompReadLen == 0)
        return NULL;

    lpdw = (LPDWORD)lpCompRead;

    lpBufRet = ImmLocalAlloc(0, dwCompReadLen);
    if (lpBufRet == NULL) {
        RIPMSG0(RIP_WARNING, "InternalSCS_CHANGECLAUSE: memory failure.");
        return NULL;
    }

    if (fAnsi) {

        dwBufLenA = ImmGetCompositionStringA(hImc, dwIndex, NULL, 0);

        lpStrBufA = ImmLocalAlloc(0, dwBufLenA);
        if (lpStrBufA == NULL) {
            RIPMSG0(RIP_WARNING, "InternalSCS_CHANGECLAUSE: memory failure.");
            ImmLocalFree(lpBufRet);
            return NULL;
        }

        ImmGetCompositionStringA(hImc, dwIndex, lpStrBufA, dwBufLenA);
    }
    else {

        dwBufLenW = ImmGetCompositionStringW(hImc, dwIndex, NULL, 0);

        lpStrBufW = ImmLocalAlloc(0, dwBufLenW);
        if (lpStrBufW == NULL) {
            RIPMSG0(RIP_WARNING, "InternalSCS_CHANGECLAUSE: memory failure.");
            ImmLocalFree(lpBufRet);
            return NULL;
        }

        ImmGetCompositionStringW(hImc, dwIndex, lpStrBufW, dwBufLenW);
    }

    *lplpNewCompRead = lpNewdw = lpBufRet;
    *lpdwNewCompReadLen = dwCompReadLen;

    for (i = 0; i < (INT)(dwCompReadLen / sizeof(DWORD)); i++) {
        *lpNewdw++ = fAnsi ? CalcCharacterPositionAtoW(*lpdw++, lpStrBufA, dwCodePage)
                           : CalcCharacterPositionWtoA(*lpdw++, lpStrBufW, dwCodePage);
    }

    if (lpStrBufA) {
        ImmLocalFree(lpStrBufA);
        UserAssert(lpStrBufW == NULL);
    } else {
        UserAssert(lpStrBufW);
        ImmLocalFree(lpStrBufW);
    }

    return (LPBYTE)lpBufRet;
}


LPBYTE InternalSCS_RECONVERTSTRING(
    LPRECONVERTSTRING  lpReconv,
    DWORD              dwReconvLen,
    LPRECONVERTSTRING *lplpNewReconv,
    DWORD             *lpdwNewReconvLen,
    BOOL               fAnsi,
    DWORD              dwCodePage)
{
    LPRECONVERTSTRING lpNewReconv;
    DWORD dwBufSize;

    if (lpReconv == NULL || dwReconvLen == 0)
        return NULL;

    if (fAnsi) {
        // AtoW
        dwBufSize = (lpReconv->dwSize - sizeof *lpReconv + 1) * sizeof(WCHAR) + sizeof *lpReconv;
    }
    else {
        dwBufSize = lpReconv->dwSize + sizeof(BYTE);
    }
    lpNewReconv = ImmLocalAlloc(0, dwBufSize);
    if (lpNewReconv == NULL) {
        RIPMSG0(RIP_WARNING, "InternalSCS_RECONVERTSTRING: memory failure.");
        return NULL;
    }

    lpNewReconv->dwVersion = 0;
    lpNewReconv->dwSize=  dwBufSize;

    lpNewReconv->dwSize = ImmReconversionWorker(lpNewReconv, lpReconv, !fAnsi, dwCodePage);
    if (lpNewReconv->dwSize == 0) {
        ImmLocalFree(lpNewReconv);
        return NULL;;
    }
    *lpdwNewReconvLen = lpNewReconv->dwSize;
    *lplpNewReconv = lpNewReconv;

    return (LPBYTE)lpNewReconv;
}


/***************************************************************************\
* ImmSetCompositionStringWorker
*
* Worker function of ImmSetCompositionStringA/ImmSetCompositionStringW
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL ImmSetCompositionStringWorker(
    HIMC    hImc,
    DWORD   dwIndex,
    LPVOID lpComp,
    DWORD   dwCompLen,
    LPVOID lpRead,
    DWORD   dwReadLen,
    BOOL    fAnsi)
{
    PINPUTCONTEXT      pInputContext;
    PCOMPOSITIONSTRING pCompStr;
    DWORD              dwThreadId;
    PIMEDPI            pImeDpi;
    LPBYTE             lpCompBuf, lpReadBuf;
    LPBYTE             lpNewComp = NULL, lpNewRead = NULL;
    DWORD              dwNewCompLen, dwNewReadLen;
    BOOL               fRet = FALSE;
    BOOL               fCheckSize = TRUE;
    BOOL               fNeedAWConversion;
    LPBYTE             lpOrgComp, lpOrgRead;
    DWORD              dwOrgCompLen, dwOrgReadLen;

    dwThreadId = GetInputContextThread(hImc);
    if (dwThreadId != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmSetCompositionString: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pImeDpi = ImmLockImeDpi(GetKeyboardLayout(dwThreadId));
    if (pImeDpi == NULL)
        return FALSE;

    lpCompBuf = lpReadBuf = NULL;

    // Backup original pointers to copyback for QUERY.
    lpOrgComp = lpComp;
    lpOrgRead = lpRead;
    dwOrgCompLen = dwCompLen;
    dwOrgReadLen = dwReadLen;

    /*
     * Check if we need ANSI/Unicode conversion
     */
    if (( fAnsi && !(pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)) ||
        (!fAnsi &&  (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE))) {
        /*
         * No A/W conversion needed.
         */
        fNeedAWConversion = FALSE;
        goto start_scs;
    }
    fNeedAWConversion = TRUE;

    switch (dwIndex) {
    case SCS_SETSTR:
        if ( lpComp &&
            (lpCompBuf = InternalSCS_SETSTR(lpComp, dwCompLen,
                                &lpNewComp, &dwNewCompLen, fAnsi, IMECodePage(pImeDpi))) == NULL)
            goto callime_scs;
        if ( lpRead &&
            (lpReadBuf = InternalSCS_SETSTR(lpRead, dwReadLen,
                                &lpNewRead, &dwNewReadLen, fAnsi, IMECodePage(pImeDpi))) == NULL)
            goto callime_scs;

        fCheckSize = FALSE;
        break;

    case SCS_CHANGEATTR:
        if ( lpComp &&
            (lpCompBuf = InternalSCS_CHANGEATTR(
                                hImc, lpComp, dwCompLen, GCS_COMPSTR,
                                &lpNewComp, &dwNewCompLen, fAnsi, IMECodePage(pImeDpi))) == NULL)
            goto callime_scs;
        if ( lpRead &&
            (lpReadBuf = InternalSCS_CHANGEATTR(
                                hImc, lpRead, dwReadLen, GCS_COMPREADSTR,
                                &lpNewRead, &dwNewReadLen, fAnsi, IMECodePage(pImeDpi))) == NULL)
            goto callime_scs;
        break;

    case SCS_CHANGECLAUSE:
       if ( lpComp &&
           (lpCompBuf = InternalSCS_CHANGECLAUSE(
                                hImc, lpComp, dwCompLen, GCS_COMPSTR,
                                (LPDWORD *)&lpNewComp, &dwNewCompLen, fAnsi, IMECodePage(pImeDpi))) == NULL)
            goto callime_scs;
        if ( lpRead &&
            (lpReadBuf = InternalSCS_CHANGECLAUSE(
                                hImc, lpRead, dwReadLen, GCS_COMPREADSTR,
                                (LPDWORD *)&lpNewRead, &dwNewReadLen, fAnsi, IMECodePage(pImeDpi))) == NULL)
            goto callime_scs;
        break;

    case SCS_SETRECONVERTSTRING:
    case SCS_QUERYRECONVERTSTRING:
        if (lpComp &&
            (lpCompBuf = InternalSCS_RECONVERTSTRING((LPRECONVERTSTRING)lpComp, dwCompLen,
                                (LPRECONVERTSTRING *)&lpNewComp, &dwNewCompLen,
                                fAnsi, IMECodePage(pImeDpi))) == NULL)
            goto callime_scs;
        if (lpRead &&
            (lpReadBuf = InternalSCS_RECONVERTSTRING((LPRECONVERTSTRING)lpRead, dwReadLen,
                                (LPRECONVERTSTRING *)&lpNewRead, &dwNewReadLen,
                                fAnsi, IMECodePage(pImeDpi))) == NULL)
            goto callime_scs;

        fCheckSize = FALSE;
        break;

    default:
        goto callime_scs;
    }

    if (lpCompBuf != NULL) {
        lpComp    = lpNewComp;
        dwCompLen = dwNewCompLen;
    }

    if (lpReadBuf != NULL) {
        lpRead    = lpNewRead;
        dwReadLen = dwNewReadLen;
    }

start_scs:

    if (CompositionString(hImc, &pInputContext, &pCompStr, fCheckSize) <= 0)
        goto callime_scs;

    switch (dwIndex)
    {
    case SCS_SETSTR:
        fRet = TRUE;
        break;

    case SCS_CHANGEATTR:
        if ( lpComp &&
            !CheckAttribute((LPBYTE)lpComp, dwCompLen,
                    (LPBYTE)((LPBYTE)pCompStr + pCompStr->dwCompAttrOffset),
                    pCompStr->dwCompAttrLen,
                    (LPDWORD)((LPBYTE)pCompStr + pCompStr->dwCompClauseOffset),
                    pCompStr->dwCompClauseLen)) break;

        if ( lpRead &&
            !CheckAttribute((LPBYTE)lpRead, dwReadLen,
                    (LPBYTE)((LPBYTE)pCompStr + pCompStr->dwCompReadAttrOffset),
                    pCompStr->dwCompReadAttrLen,
                    (LPDWORD)((LPBYTE)pCompStr + pCompStr->dwCompReadClauseOffset),
                    pCompStr->dwCompReadClauseLen)) break;
        fRet = TRUE;
        break;

    case SCS_CHANGECLAUSE:
        if ( lpComp &&
            !CheckClause((LPDWORD)lpComp, dwCompLen,
                         (LPDWORD)((LPBYTE)pCompStr + pCompStr->dwCompClauseOffset),
                         pCompStr->dwCompClauseLen)) break;
        if ( lpRead &&
            !CheckClause((LPDWORD)lpRead, dwReadLen,
                         (LPDWORD)((LPBYTE)pCompStr + pCompStr->dwCompReadClauseOffset),
                         pCompStr->dwCompReadClauseLen)) break;
        fRet = TRUE;
        break;

    case SCS_SETRECONVERTSTRING:
    case SCS_QUERYRECONVERTSTRING:
        if (pImeDpi->ImeInfo.fdwSCSCaps & SCS_CAP_SETRECONVERTSTRING) {
            fRet = TRUE;
        }
        break;

    default:
        break;
    }

    ImmUnlockIMCC(pInputContext->hCompStr);
    ImmUnlockIMC(hImc);

callime_scs:

    if (fRet) {
        fRet = (*pImeDpi->pfn.ImeSetCompositionString)(hImc, dwIndex,
                                    lpComp, dwCompLen, lpRead, dwReadLen);
    }

    /*
     * Check if we need ANSI/Unicode back conversion
     */
    if (fNeedAWConversion) {
        LPBYTE lpCompBufBack = NULL, lpReadBufBack = NULL;
        /*
         * A/W back conversion needed.
         */
        switch (dwIndex) {
        case SCS_QUERYRECONVERTSTRING:
            if (lpOrgComp &&
                (lpCompBufBack = InternalSCS_RECONVERTSTRING((LPRECONVERTSTRING)lpComp, dwCompLen,
                                    (LPRECONVERTSTRING *)&lpNewComp, &dwNewCompLen,
                                    !fAnsi, IMECodePage(pImeDpi)))) {
                RtlCopyMemory(lpOrgComp, lpNewComp, dwNewCompLen);
            }
            if (lpOrgRead &&
                (lpReadBufBack = InternalSCS_RECONVERTSTRING(
                                    (LPRECONVERTSTRING)lpRead, dwReadLen,
                                    (LPRECONVERTSTRING *)&lpNewRead, &dwNewReadLen,
                                    !fAnsi, IMECodePage(pImeDpi)))) {
                RtlCopyMemory(lpOrgRead, lpNewRead, dwNewReadLen);
            }
        }
        if (lpCompBufBack != NULL)
            LocalFree(lpCompBufBack);
        if (lpReadBufBack != NULL)
            LocalFree(lpReadBufBack);
    }

    if (lpCompBuf != NULL)
        ImmLocalFree(lpCompBuf);
    if (lpReadBuf != NULL)
        ImmLocalFree(lpReadBuf);

    ImmUnlockImeDpi(pImeDpi);

    return fRet;
}


/***************************************************************************\
* ImmGetCandidateListCountA
*
* Query the byte count and list count to receive all candidate list.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetCandidateListCountA(
    HIMC    hImc,
    LPDWORD lpdwListCount)      // the buffer pointer for list count
{
    return ImmGetCandidateListCountWorker(hImc, lpdwListCount, TRUE);
}


/***************************************************************************\
* ImmGetCandidateListCountW
*
* Query the byte count and list count to receive all candidate list.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetCandidateListCountW(
    HIMC    hImc,
    LPDWORD lpdwListCount)      // the buffer pointer for list count
{
    return ImmGetCandidateListCountWorker(hImc, lpdwListCount, FALSE);
}


/***************************************************************************\
* ImmGetCandidateListCountWorker
*
* Worker function of ImmGetCandidateListCountA/ImmGetCandidateListCountW.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD ImmGetCandidateListCountWorker(
    HIMC    hImc,
    LPDWORD lpdwListCount,
    BOOL    fAnsi)
{
    PCLIENTIMC      pClientImc;
    PINPUTCONTEXT   pInputContext;
    LPCANDIDATEINFO lpCandInfo;
    DWORD           dwRet = 0;
    INT             i;
    DWORD           dwCodePage;

    if (lpdwListCount) {
        *lpdwListCount = 0;
    } else {
        RIPMSG0(RIP_WARNING, "ImmGetCandidateListCount: NULL lpdwListCount.");
        return dwRet;
    }

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCandidateListCount: Invalid hImc %lx.", hImc);
        goto GetCandListCntExit;
    }
    dwCodePage = CImcCodePage(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCandidateListCount: Lock hImc %lx failed.", hImc);
        goto GetCandListCntUnlockClientImc;
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(pInputContext->hCandInfo);
    if (!lpCandInfo) {
        RIPMSG1(RIP_WARNING,
              "ImmGetCandidateListCount: Lock hCandInfo %x failed.",
              pInputContext->hCandInfo);
        goto GetCandListCntUnlockIMC;
    }

    if (lpCandInfo->dwSize < sizeof(CANDIDATEINFO)) {
        RIPMSG0(RIP_WARNING, "ImmGetCandidateListCount: no candidate list.");
        goto GetCandListCntUnlockIMC;
    }

    *lpdwListCount = lpCandInfo->dwCount;

    if (fAnsi && TestICF(pClientImc, IMCF_UNICODE)) {
        LPCANDIDATELIST lpCandListW;

        dwRet = DWORD_ALIGN(sizeof(CANDIDATEINFO))
              + DWORD_ALIGN(lpCandInfo->dwPrivateSize);

        for (i = 0; i < (INT)lpCandInfo->dwCount; i++) {
            lpCandListW = (LPCANDIDATELIST)((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[i]);
            dwRet += InternalGetCandidateListWtoA(lpCandListW, NULL, 0, dwCodePage);
        }
    }
    else if (!fAnsi && !TestICF(pClientImc, IMCF_UNICODE)) {
        LPCANDIDATELIST lpCandListA;

        dwRet = DWORD_ALIGN(sizeof(CANDIDATEINFO))
              + DWORD_ALIGN(lpCandInfo->dwPrivateSize);

        for (i = 0; i < (INT)lpCandInfo->dwCount; i++) {
            lpCandListA = (LPCANDIDATELIST)((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[i]);
            dwRet += InternalGetCandidateListAtoW(lpCandListA, NULL, 0, dwCodePage);
        }
    }
    else {
        dwRet = lpCandInfo->dwSize;
    }

    ImmUnlockIMCC(pInputContext->hCandInfo);

GetCandListCntUnlockIMC:
    ImmUnlockIMC(hImc);

GetCandListCntUnlockClientImc:
    ImmUnlockClientImc(pClientImc);

GetCandListCntExit:
    return dwRet;
}


/***************************************************************************\
* ImmGetCandidateListA
*
* Gets the candidate list information specified by dwIndex.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetCandidateListA(
    HIMC            hImc,
    DWORD           dwIndex,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen)
{
    return ImmGetCandidateListWorker(hImc, dwIndex,
                                     lpCandList, dwBufLen, TRUE);
}


/***************************************************************************\
* ImmGetCandidateListW
*
* Gets the candidate list information specified by dwIndex.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetCandidateListW(
    HIMC            hImc,
    DWORD           dwIndex,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen)
{
    return ImmGetCandidateListWorker(hImc, dwIndex,
                                     lpCandList, dwBufLen, FALSE);
}


/***************************************************************************\
* ImmGetCandidateListWorker
*
* Worker function of ImmGetCandidateListA/ImmGetCandidateListW.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD ImmGetCandidateListWorker(
    HIMC            hImc,
    DWORD           dwIndex,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen,
    BOOL            fAnsi)
{
    PCLIENTIMC      pClientImc;
    PINPUTCONTEXT   pInputContext;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandListTemp;
    DWORD           dwBufLenTemp;
    DWORD           dwRet = 0;
    DWORD           dwCodePage;

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCandidateList: Invalid hImc %lx.", hImc);
        goto GetCandListExit;

    }

    dwCodePage = CImcCodePage(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCandidateList: Lock hImc %lx failed.", hImc);
        goto GetCandListUnlockClientImc;
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(pInputContext->hCandInfo);
    if (!lpCandInfo) {
        RIPMSG1(RIP_WARNING, "ImmGetCandidateList: Lock hCandInfo %x failed",
              pInputContext->hCandInfo);
        goto GetCandListUnlockIMC;
    }

    if (lpCandInfo->dwSize < sizeof(CANDIDATEINFO)) {
        RIPMSG0(RIP_WARNING, "ImmGetCandidateList: no candidate list.");
        goto GetCandListUnlockIMCC;
    }

    /*
     * invalid access
     */
    if (dwIndex >= lpCandInfo->dwCount) {
        RIPMSG0(RIP_WARNING, "ImmGetCandidateList: dwIndex >= lpCandInfo->dwCount.");
        goto GetCandListUnlockIMCC;
    }

    lpCandListTemp = (LPCANDIDATELIST)((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[dwIndex]);

    if (fAnsi && TestICF(pClientImc, IMCF_UNICODE)) {
        /*
         * ANSI Caller with an Unicode hImc.
         */
        dwBufLenTemp = InternalGetCandidateListWtoA(lpCandListTemp, NULL, 0, dwCodePage);
    }
    else if (!fAnsi && !TestICF(pClientImc, IMCF_UNICODE)) {
        /*
         * Unicode Caller with an ANSI hImc.
         */
        dwBufLenTemp = InternalGetCandidateListAtoW(lpCandListTemp, NULL, 0, dwCodePage);
    }
    else {
        /*
         * No conversion required.
         */
        dwBufLenTemp = lpCandListTemp->dwSize;
    }

    /*
     * Query buffer size or early exit on error
     */
    if (dwBufLen == 0 || dwBufLenTemp == 0) {
        dwRet = dwBufLenTemp;
    }
    else if (!lpCandList) {
        RIPMSG0(RIP_WARNING, "ImmGetCandidateList: Null lpCandList.");
    }
    else if (dwBufLen < dwBufLenTemp) {
        RIPMSG2(RIP_WARNING, "ImmGetCandidateList: dwBufLen = %d too small, require = %d.",
              dwBufLen, dwBufLenTemp);
    } else {
        if (fAnsi && TestICF(pClientImc, IMCF_UNICODE)) {
            dwRet = InternalGetCandidateListWtoA(lpCandListTemp, lpCandList, dwBufLenTemp, dwCodePage);
        }
        else if (!fAnsi && !TestICF(pClientImc, IMCF_UNICODE)) {
            dwRet = InternalGetCandidateListAtoW(lpCandListTemp, lpCandList, dwBufLenTemp, dwCodePage);
        }
        else {
            RtlCopyMemory((LPBYTE)lpCandList, (LPBYTE)lpCandListTemp, dwBufLenTemp);
            dwRet = dwBufLenTemp;
        }
    }

GetCandListUnlockIMCC:
    ImmUnlockIMCC(pInputContext->hCandInfo);

GetCandListUnlockIMC:
    ImmUnlockIMC(hImc);

GetCandListUnlockClientImc:
    ImmUnlockClientImc(pClientImc);

GetCandListExit:
    return dwRet;
}


/***************************************************************************\
* ImmGetGuideLineA
*
* Gets the guide line information reported by the IME.
*
* History:
* 26-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetGuideLineA(
    HIMC    hImc,
    DWORD   dwIndex,
    LPSTR   lpszBuf,
    DWORD   dwBufLen)
{
    return ImmGetGuideLineWorker(hImc, dwIndex,
                                 (LPBYTE)lpszBuf, dwBufLen, TRUE);
}


/***************************************************************************\
* ImmGetGuideLineW
*
* Gets the guide line information reported by the IME.
*
* History:
* 26-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetGuideLineW(
    HIMC    hImc,
    DWORD   dwIndex,
    LPWSTR  lpwszBuf,
    DWORD   dwBufLen)
{
    return ImmGetGuideLineWorker(hImc, dwIndex,
                                 (LPBYTE)lpwszBuf, dwBufLen, FALSE);
}


/***************************************************************************\
* ImmGetGuideLineWorker
*
* Worker function of ImmGetGuideLineA/ImmGetGuideLineW.
*
* History:
* 26-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD ImmGetGuideLineWorker(
    HIMC    hImc,
    DWORD   dwIndex,
    LPBYTE  lpBuf,
    DWORD   dwBufLen,
    BOOL    fAnsi)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    LPGUIDELINE   lpGuideLine;
    LPBYTE        lpBufTemp;
    DWORD         dwRet = 0;
    DWORD         dwBufLenNeeded;
    BOOL          bUDC;
    DWORD         dwCodePage;

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetGuideLine: Invalid hImc %lx.", hImc);
        goto GetGuideLineExit;
    }
    dwCodePage = CImcCodePage(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetGuideLine: Lock hImc %lx failed.", hImc);
        goto GetGuideLineUnlockClientImc;
    }

    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(pInputContext->hGuideLine);
    if (!lpGuideLine) {
        RIPMSG1(RIP_WARNING, "ImmGetGuideLine: Lock hGuideLine %lx failed.",
              pInputContext->hGuideLine);
        goto GetGuideLineUnlockIMC;
    }

    switch (dwIndex) {
    case GGL_LEVEL:
        dwRet = lpGuideLine->dwLevel;
        break;

    case GGL_INDEX:
        dwRet = lpGuideLine->dwIndex;
        break;

    case GGL_STRING:

        lpBufTemp = (LPBYTE)lpGuideLine + lpGuideLine->dwStrOffset;

        /*
         * Calculate the required buffer length.
         */
        if (fAnsi && TestICF(pClientImc, IMCF_UNICODE)) {
            dwBufLenNeeded = WideCharToMultiByte(dwCodePage,
                                                 (DWORD)0,
                                                 (LPWSTR)lpBufTemp,
                                                 (INT)lpGuideLine->dwStrLen,
                                                 (LPSTR)NULL,
                                                 (INT)0,
                                                 (LPSTR)NULL,
                                                 (LPBOOL)&bUDC);
        }
        else if (!fAnsi && !TestICF(pClientImc, IMCF_UNICODE)) {
            dwBufLenNeeded = MultiByteToWideChar(dwCodePage,
                                                 (DWORD)MB_PRECOMPOSED,
                                                 (LPSTR)lpBufTemp,
                                                 (INT)lpGuideLine->dwStrLen,
                                                 (LPWSTR)NULL,
                                                 (INT)0);
            dwBufLenNeeded *= sizeof(WCHAR);
        }
        else {
            dwBufLenNeeded = lpGuideLine->dwStrLen;
            /*
             * The dwStrLen records the strlen and not the byte count.
             */
            if (TestICF(pClientImc, IMCF_UNICODE))
                dwBufLenNeeded *= sizeof(WCHAR);
        }

        /*
         * Query GuideLine string size only or early exit on error
         */
        if (dwBufLen == 0 || dwBufLenNeeded == 0) {
            dwRet = dwBufLenNeeded;
            goto GetGuideLineUnlockIMCC;
        }

        if (lpBuf == NULL || dwBufLen < dwBufLenNeeded)
            goto GetGuideLineUnlockIMCC;

        if (fAnsi && TestICF(pClientImc, IMCF_UNICODE)) {
            dwRet = WideCharToMultiByte(dwCodePage,
                                        (DWORD)0,
                                        (LPWSTR)lpBufTemp,
                                        (INT)lpGuideLine->dwStrLen,
                                        (LPSTR)lpBuf,
                                        (INT)dwBufLen,
                                        (LPSTR)NULL,
                                        (LPBOOL)&bUDC);
        }
        else if (!fAnsi && !TestICF(pClientImc, IMCF_UNICODE)) {
            dwRet = MultiByteToWideChar(dwCodePage,
                                        (DWORD)MB_PRECOMPOSED,
                                        (LPSTR)lpBufTemp,
                                        (INT)lpGuideLine->dwStrLen,
                                        (LPWSTR)lpBuf,
                                        (INT)dwBufLen/sizeof(WCHAR));
            dwRet *= sizeof(WCHAR);
        }
        else {
            RtlCopyMemory(lpBuf, lpBufTemp, dwBufLenNeeded);
            dwRet = dwBufLenNeeded;
        }

        break;

    case GGL_PRIVATE:

        lpBufTemp = (LPBYTE)lpGuideLine + lpGuideLine->dwPrivateOffset;

        /*
         * The dwPrivateOffset is an offset to a CANDIDATELIST when
         * lpGuideLine->dwIndex == GL_ID_REVERSECONVERSION. Do conversion
         * for this case only.
         */
        if (fAnsi && TestICF(pClientImc, IMCF_UNICODE) &&
                lpGuideLine->dwIndex == GL_ID_REVERSECONVERSION) {
            dwBufLenNeeded = InternalGetCandidateListWtoA(
                        (LPCANDIDATELIST)lpBufTemp, (LPCANDIDATELIST)NULL, 0, dwCodePage);
        }
        else if (!fAnsi && !TestICF(pClientImc, IMCF_UNICODE) &&
                lpGuideLine->dwIndex == GL_ID_REVERSECONVERSION) {
            dwBufLenNeeded = InternalGetCandidateListAtoW(
                        (LPCANDIDATELIST)lpBufTemp, (LPCANDIDATELIST)NULL, 0, dwCodePage);
        }
        else {
            dwBufLenNeeded = lpGuideLine->dwPrivateSize;
        }

        /*
         * Query dwPrivateSize size only or early exit on error
         */
        if (dwBufLen == 0 || dwBufLenNeeded == 0) {
            dwRet = dwBufLenNeeded;
            goto GetGuideLineUnlockIMCC;
        }

        if (lpBuf == NULL || dwBufLen < dwBufLenNeeded)
            goto GetGuideLineUnlockIMCC;

        if (fAnsi && TestICF(pClientImc, IMCF_UNICODE) &&
                lpGuideLine->dwIndex == GL_ID_REVERSECONVERSION) {
            dwRet = InternalGetCandidateListWtoA(
                    (LPCANDIDATELIST)lpBufTemp, (LPCANDIDATELIST)lpBuf, dwBufLenNeeded, dwCodePage);
        }
        else if (!fAnsi && !TestICF(pClientImc, IMCF_UNICODE) &&
                lpGuideLine->dwIndex == GL_ID_REVERSECONVERSION) {
            dwRet = InternalGetCandidateListAtoW(
                    (LPCANDIDATELIST)lpBufTemp, (LPCANDIDATELIST)lpBuf, dwBufLenNeeded, dwCodePage);
        }
        else {
            RtlCopyMemory(lpBuf, lpBufTemp, dwBufLenNeeded);
            dwRet = dwBufLenNeeded;
        }

        break;

    default:
        break;
    }

GetGuideLineUnlockIMCC:
    ImmUnlockIMCC(pInputContext->hGuideLine);

GetGuideLineUnlockIMC:
    ImmUnlockIMC(hImc);

GetGuideLineUnlockClientImc:
    ImmUnlockClientImc(pClientImc);

GetGuideLineExit:
    return dwRet;
}


/***************************************************************************\
* ImmGetConversionStatus
*
* Gets current conversion status.
*
* History:
* 26-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmGetConversionStatus(     // Get the conversion status
    HIMC    hImc,
    LPDWORD lpfdwConversion,
    LPDWORD lpfdwSentence)
{
    PINPUTCONTEXT pInputContext;

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetConversionStatus: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    if (lpfdwConversion != NULL)
        *lpfdwConversion = pInputContext->fdwConversion;

    if (lpfdwSentence != NULL)
        *lpfdwSentence = pInputContext->fdwSentence;

    ImmUnlockIMC(hImc);

    return TRUE;
}


/***************************************************************************\
* ImmSetConversionStatus
*
* Sets current conversion status.
*
* History:
* 26-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmSetConversionStatus(
    HIMC  hImc,
    DWORD fdwConversion,
    DWORD fdwSentence)
{
    PINPUTCONTEXT pInputContext;
    DWORD         fdwOldConversion;
    DWORD         fdwOldSentence;
    BOOL          fConvModeChg;
    BOOL          fSentenceChg;
    HWND          hWnd;
    DWORD         dwOpenStatus;
    DWORD         dwConversion;

#if defined(CUAS_ENABLE)
    BOOL          fMakeNotifyAlways = FALSE;
    HKL           hKL = GetKeyboardLayout(0);
    if (!IS_IME_KBDLAYOUT(hKL) && IS_CICERO_ENABLED_AND_NOT16BIT())
        fMakeNotifyAlways = TRUE;
#endif

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmSetConversionStatus: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmSetConversionStatus: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    fConvModeChg = FALSE;
    fSentenceChg = FALSE;

    if (pInputContext->fdwConversion != fdwConversion) {
        if ((fdwConversion & IME_CMODE_LANGUAGE) == IME_CMODE_KATAKANA) {
            RIPMSG0(RIP_WARNING, "ImmSetConversionStatus: wrong fdwConversion");
        }
        fdwOldConversion = pInputContext->fdwConversion;
        pInputContext->fdwConversion = fdwConversion;
        fConvModeChg = TRUE;
    }

    if (pInputContext->fdwSentence != fdwSentence) {
        fdwOldSentence = pInputContext->fdwSentence;
        pInputContext->fdwSentence = fdwSentence;
        fSentenceChg = TRUE;
    }

    hWnd = pInputContext->hWnd;
    if ( fConvModeChg ) {

        dwOpenStatus = (DWORD)pInputContext->fOpen;
        dwConversion = pInputContext->fdwConversion;
    }

    ImmUnlockIMC(hImc);

#ifdef LATER
    // Do uNumLangVKey and uNumVKey checking later.
#endif

    /*
     * inform IME and UI about the conversion mode changes.
     */
#if !defined(CUAS_ENABLE)
    if (fConvModeChg) 
#else
    if (fConvModeChg || fMakeNotifyAlways) 
#endif
    {
        MakeIMENotify(hImc, hWnd, NI_CONTEXTUPDATED, fdwOldConversion,
                IMC_SETCONVERSIONMODE, IMN_SETCONVERSIONMODE, 0L);

        /*
         * notify shell and keyboard the conversion mode change
         */
#if defined(CUAS_ENABLE)
        if (fConvModeChg) 
#endif
            NtUserNotifyIMEStatus( hWnd, dwOpenStatus, dwConversion );
    }

    /*
     * inform IME and UI about the sentence mode changes.
     */
#if !defined(CUAS_ENABLE)
    if (fSentenceChg) 
#else
    if (fSentenceChg || fMakeNotifyAlways) 
#endif
    {
        MakeIMENotify(hImc, hWnd, NI_CONTEXTUPDATED, fdwOldSentence,
                IMC_SETSENTENCEMODE, IMN_SETSENTENCEMODE, 0L);
    }

    return TRUE;
}


/***************************************************************************\
* ImmGetOpenStatus
*
* Gets the open or close status of the IME.
*
* History:
* 26-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmGetOpenStatus(
    HIMC hImc)
{
    PINPUTCONTEXT pInputContext;
    BOOL          fOpen;

    if (hImc == NULL_HIMC)
        return FALSE;

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmGetOpenStatus: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    fOpen = pInputContext->fOpen;
    ImmUnlockIMC(hImc);

    return (fOpen);
}


/***************************************************************************\
* ImmSetOpenStatus
*
* Opens or closes the IME.
*
* History:
* 26-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmSetOpenStatus(
    HIMC hImc,
    BOOL fOpen)
{
    PINPUTCONTEXT pInputContext;
    HWND          hWnd;
    DWORD         dwOpenStatus;
    DWORD         dwConversion;
    BOOL          fOpenChg = FALSE;

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmSetOpenStatus: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmSetOpenStatus: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    if (pInputContext->fOpen != fOpen) {
        fOpenChg = TRUE;
        pInputContext->fOpen = fOpen;
    }

    if ( fOpenChg ) {
        hWnd = (HWND)pInputContext->hWnd;
        dwOpenStatus = (DWORD)pInputContext->fOpen;
        dwConversion = (DWORD)pInputContext->fdwConversion;
    }

    ImmUnlockIMC(hImc);

    /*
     * inform IME and UI about the conversion mode changes.
     */
    if (fOpenChg) {
        MakeIMENotify(hImc, hWnd, NI_CONTEXTUPDATED, (DWORD)0,
                IMC_SETOPENSTATUS, IMN_SETOPENSTATUS, 0L);

        NtUserNotifyIMEStatus( hWnd, dwOpenStatus, dwConversion );
    }

    return TRUE;
}


/***************************************************************************\
* ImmGetCompositionFontA
*
* Opens or closes the IME.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmGetCompositionFontA(
    HIMC       hImc,
    LPLOGFONTA lpLogFontA)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    LOGFONTW      LogFontW;
    BOOL          fUnicode, fRet;

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionFontA: Invalid hImc %lx.", hImc);
        return FALSE;
    }

    fUnicode = TestICF(pClientImc, IMCF_UNICODE);

    ImmUnlockClientImc(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionFontA: Lock hImc %lx failed.", hImc);
        return FALSE;
    }

    if (fUnicode) {

        ImmUnlockIMC(hImc);

        if (ImmGetCompositionFontW(hImc, &LogFontW)) {
            LFontWtoLFontA(&LogFontW, lpLogFontA);
            return (TRUE);
        }

        return FALSE;
    }

    if ((pInputContext->fdwInit & INIT_LOGFONT) == INIT_LOGFONT) {
        *lpLogFontA = pInputContext->lfFont.A;
        fRet = TRUE;
    }
    else {
        fRet = FALSE;
    }

    ImmUnlockIMC(hImc);

    return fRet;
}


/***************************************************************************\
* ImmGetCompositionFontW
*
* Opens or closes the IME.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmGetCompositionFontW(
    HIMC       hImc,
    LPLOGFONTW lpLogFontW)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    LOGFONTA      LogFontA;
    BOOL          fUnicode, fRet;

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionFontW: Invalid hImc %lx.", hImc);
        return FALSE;
    }

    fUnicode = TestICF(pClientImc, IMCF_UNICODE);

    ImmUnlockClientImc(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionFontW: Lock hImc %lx failed.", hImc);
        return (FALSE);
    }

    if (!fUnicode) {

        ImmUnlockIMC(hImc);

        if (ImmGetCompositionFontA(hImc, &LogFontA)) {
            LFontAtoLFontW(&LogFontA, lpLogFontW);
            return (TRUE);
        }

        return FALSE;
    }

    if ((pInputContext->fdwInit & INIT_LOGFONT) == INIT_LOGFONT) {
        *lpLogFontW = pInputContext->lfFont.W;
        fRet = TRUE;
    }
    else {
        fRet = FALSE;
    }

    ImmUnlockIMC(hImc);

    return fRet;
}


BOOL WINAPI ImmSetCompositionFontA(
    HIMC       hImc,
    LPLOGFONTA lpLogFontA)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    LOGFONTW      LogFontW;
    HWND          hWnd;
    BOOL          fUnicode;

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmSetCompositionFontA: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImmSetCompositionFontA: Invalid hImc %lx.", hImc);
        return FALSE;
    }

    fUnicode = TestICF(pClientImc, IMCF_UNICODE);

    ImmUnlockClientImc(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmSetCompositionFontA: Lock hImc %lx failed.", hImc);
        return (FALSE);
    }

    if (fUnicode) {

        ImmUnlockIMC(hImc);

        LFontAtoLFontW(lpLogFontA, &LogFontW);

        return ImmSetCompositionFontW(hImc, &LogFontW);
    }

    /*
     * Japanese 3.x applications need to receive 3.x compatible notification message.
     *
     */
    if ( (GetClientInfo()->dwExpWinVer < VER40) &&
         (PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID())) == LANG_JAPANESE)   &&
         ! (pInputContext->fdw31Compat & F31COMPAT_MCWHIDDEN) &&
         (pInputContext->cfCompForm.dwStyle != CFS_DEFAULT) ) {

        PostMessageA( pInputContext->hWnd, WM_IME_REPORT, IR_CHANGECONVERT, (LPARAM)NULL);
    }

    pInputContext->lfFont.A = *lpLogFontA;
    pInputContext->fdwInit |= INIT_LOGFONT;
    hWnd = pInputContext->hWnd;

    ImmUnlockIMC(hImc);

    /*
     * inform IME and UI about the change of composition font.
     */
    MakeIMENotify(hImc, hWnd, NI_CONTEXTUPDATED, 0L,
            IMC_SETCOMPOSITIONFONT, IMN_SETCOMPOSITIONFONT, 0L);


    return TRUE;
}


BOOL WINAPI ImmSetCompositionFontW(
    HIMC       hImc,
    LPLOGFONTW lpLogFontW)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    LOGFONTA      LogFontA;
    HWND          hWnd;
    BOOL          fUnicode;

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmSetCompositionFontW: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING, "ImmSetCompositionFontW: Invalid hImc %lx.", hImc);
        return (FALSE);
    }

    fUnicode = TestICF(pClientImc, IMCF_UNICODE);

    ImmUnlockClientImc(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmSetCompositionFontW: Lock hImc %lx failed.", hImc);
        return (FALSE);
    }

    if (!fUnicode) {

        ImmUnlockIMC(hImc);

        LFontWtoLFontA(lpLogFontW, &LogFontA);

        return ImmSetCompositionFontA(hImc, &LogFontA);
    }

    /*
     * Japanese 3.x applications need to receive 3.x compatible notification message.
     *
     */
    if ( (GetClientInfo()->dwExpWinVer < VER40) &&
         (PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID())) == LANG_JAPANESE)   &&
         ! (pInputContext->fdw31Compat & F31COMPAT_MCWHIDDEN) &&
         (pInputContext->cfCompForm.dwStyle != CFS_DEFAULT) ) {

        PostMessageW( pInputContext->hWnd, WM_IME_REPORT, IR_CHANGECONVERT, (LPARAM)NULL);
    }
    pInputContext->lfFont.W = *lpLogFontW;
    pInputContext->fdwInit |= INIT_LOGFONT;
    hWnd = pInputContext->hWnd;

    ImmUnlockIMC(hImc);

    /*
     * inform IME and UI about the change of composition font.
     */
    MakeIMENotify(hImc, hWnd, NI_CONTEXTUPDATED, 0L,
            IMC_SETCOMPOSITIONFONT, IMN_SETCOMPOSITIONFONT, 0L);

    return TRUE;
}


/***************************************************************************\
* ImmGetConversionListA
*
* Obtains the list of FE character or word from one character or word.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetConversionListA(
    HKL             hKL,
    HIMC            hImc,
    LPCSTR          lpszSrc,
    LPCANDIDATELIST lpCandListA,
    DWORD           dwBufLen,
    UINT            uFlag)
{
    PIMEDPI pImeDpi;
    DWORD   dwRet;
    LPWSTR  lpwszSrc;
    DWORD   dwBufTemp;
    LPCANDIDATELIST lpCandListW;
    INT     i;
    DWORD   dwCodePage;

    pImeDpi = FindOrLoadImeDpi(hKL);

    if (pImeDpi == NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmGetConversionListA: cannot find DPI entry for hkl=%lx", hKL);
        return (0);
    }

    dwCodePage = IMECodePage(pImeDpi);

    if (!(pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)) {
        /*
         * This is an ANSI call to an ANSI IME.
         */
        dwRet = (*pImeDpi->pfn.ImeConversionList.a)(hImc, lpszSrc,
                                        lpCandListA, dwBufLen, uFlag);
        ImmUnlockImeDpi(pImeDpi);
        return dwRet;
    }

    ImmUnlockImeDpi(pImeDpi);

    /*
     * This is an ANSI call to an Unicode IME.
     */
    if (lpszSrc != NULL) {

        dwBufTemp = (strlen(lpszSrc) + 1) * sizeof(WCHAR);

        lpwszSrc = ImmLocalAlloc(0, dwBufTemp);
        if (lpwszSrc == NULL)
            return (0);

        i = MultiByteToWideChar(dwCodePage,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszSrc,              // src
                                (INT)strlen(lpszSrc),
                                (LPWSTR)lpwszSrc,            // dest
                                (INT)dwBufTemp/sizeof(WCHAR));

        lpwszSrc[i] = '\0';
    }
    else {
        lpwszSrc = NULL;
    }

    /*
     * Query the CandidateListW size required.
     */
    dwBufTemp = ImmGetConversionListW(hKL, hImc, lpwszSrc, NULL, 0, uFlag);

    if (dwBufTemp == 0 || (lpCandListW = ImmLocalAlloc(0, dwBufTemp)) == NULL) {
        if (lpwszSrc)
            ImmLocalFree(lpwszSrc);
        return (0);
    }

    /*
     * Now get the actual CandidateListW.
     */
    dwBufTemp = ImmGetConversionListW(hKL, hImc, lpwszSrc,
                                        lpCandListW, dwBufTemp, uFlag);

    /*
     * Query the CandidateListA size required.
     */
    if (dwBufTemp != 0) {
        dwBufTemp = InternalGetCandidateListWtoA(lpCandListW, NULL, 0, dwCodePage);
    }

    if (dwBufLen == 0 || dwBufTemp == 0) {
        /*
         * Query required buffer size or error has happened.
         */
        dwRet = dwBufTemp;
    }
    else if (dwBufLen < dwBufTemp) {
        /*
         * Not enough buffer area.
         */
        dwRet = 0;
    }
    else {
        /*
         * Get the actual CandidateListA
         */
        dwRet = InternalGetCandidateListWtoA(lpCandListW, lpCandListA, dwBufLen, dwCodePage);
    }

    if (lpwszSrc)
        ImmLocalFree(lpwszSrc);
    ImmLocalFree(lpCandListW);

    return dwRet;

}


/***************************************************************************\
* ImmGetConversionListW
*
* Obtains the list of FE character or word from one character or word.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetConversionListW(
    HKL             hKL,
    HIMC            hImc,
    LPCWSTR         lpwszSrc,
    LPCANDIDATELIST lpCandListW,
    DWORD           dwBufLen,
    UINT            uFlag)
{
    PIMEDPI pImeDpi;
    DWORD   dwRet;
    LPSTR   lpszSrc;
    DWORD   dwBufTemp;
    LPCANDIDATELIST lpCandListA;
    BOOL    bUDC;
    INT     i;
    DWORD   dwCodePage;

    pImeDpi = FindOrLoadImeDpi(hKL);

    if (pImeDpi == NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmGetConversionListW: cannot find DPI entry for hkl=%lx", hKL);
        return (0);
    }

    dwCodePage = IMECodePage(pImeDpi);

    if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) {
        /*
         * This is an Unicode call to an Unicode IME.
         */
        dwRet = (*pImeDpi->pfn.ImeConversionList.w)(hImc, lpwszSrc,
                                        lpCandListW, dwBufLen, uFlag);
        ImmUnlockImeDpi(pImeDpi);
        return dwRet;
    }

    ImmUnlockImeDpi(pImeDpi);

    /*
     * This is an Unicode call to an ANSI IME.
     */
    if (lpwszSrc != NULL) {

        dwBufTemp = (wcslen(lpwszSrc) + 1) * sizeof(WCHAR);

        lpszSrc = ImmLocalAlloc(0, dwBufTemp);
        if (lpszSrc == NULL)
            return (0);

        i = WideCharToMultiByte(dwCodePage,
                                (DWORD)0,
                                lpwszSrc,
                                (INT)wcslen(lpwszSrc),
                                (LPSTR)lpszSrc,
                                (INT)dwBufTemp,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);

        lpszSrc[i] = '\0';
    }
    else {
        lpszSrc = NULL;
    }

    /*
     * Query the CandidateListA size required.
     */
    dwBufTemp = ImmGetConversionListA(hKL, hImc, lpszSrc, NULL, 0, uFlag);

    if (dwBufTemp == 0 || (lpCandListA = ImmLocalAlloc(0, dwBufTemp)) == NULL) {
        if (lpszSrc)
            ImmLocalFree(lpszSrc);

        return (0);
    }

    /*
     * Now get the actual CandidateListA.
     */
    dwBufTemp = ImmGetConversionListA(hKL, hImc, lpszSrc,
                                        lpCandListA, dwBufTemp, uFlag);

    /*
     * Query the CandidateListW size required.
     */
    if (dwBufTemp != 0) {
        dwBufTemp = InternalGetCandidateListAtoW(lpCandListA, NULL, 0, dwCodePage);
    }

    if (dwBufLen == 0 || dwBufTemp == 0) {
        /*
         * Query required buffer size or error has happened.
         */
        dwRet = dwBufTemp;
    }
    else if (dwBufLen < dwBufTemp) {
        /*
         * Not enough buffer area.
         */
        dwRet = 0;
    }
    else {
        /*
         * Get the actual CandidateListW
         */
        dwRet = InternalGetCandidateListAtoW(lpCandListA, lpCandListW, dwBufLen, dwCodePage);
    }

    if (lpszSrc)
        ImmLocalFree(lpszSrc);
    ImmLocalFree(lpCandListA);

    return dwRet;
}


/***************************************************************************\
* ImmGetStatusWindowPos
*
* Gets the position, in screen coordinates, of the status window.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmGetStatusWindowPos(
    HIMC    hImc,
    LPPOINT lpptPos)
{
    PINPUTCONTEXT pInputContext;
    BOOL fStatusWndPosInited;

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmGetStatusWindowPos: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    fStatusWndPosInited = ((pInputContext->fdwInit & INIT_STATUSWNDPOS) == INIT_STATUSWNDPOS);
    ImmUnlockIMC(hImc);

    if (fStatusWndPosInited) {
        *lpptPos = pInputContext->ptStatusWndPos;
        return TRUE;
    }

    return FALSE;
}


BOOL WINAPI ImmSetStatusWindowPos(
    HIMC     hImc,
    LPPOINT  lpptPos)
{
    PINPUTCONTEXT pInputContext;
    HWND          hWnd;

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmSetStatusWindowPos: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmSetStatusWindowPos: Lock hImc %lx failed", hImc);
        return (FALSE);
    }

    pInputContext->ptStatusWndPos = *lpptPos;
    pInputContext->fdwInit |= INIT_STATUSWNDPOS;

    hWnd = pInputContext->hWnd;

    ImmUnlockIMC(hImc);

    /*
     * inform IME and UI about the change of composition font.
     */
    MakeIMENotify(hImc, hWnd, NI_CONTEXTUPDATED, 0L,
            IMC_SETSTATUSWINDOWPOS, IMN_SETSTATUSWINDOWPOS, 0L);

    return TRUE;
}


/***************************************************************************\
* ImmGetCompositionWindow
*
* Gets the information of the composition window.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmGetCompositionWindow(
    HIMC              hImc,
    LPCOMPOSITIONFORM lpCompForm)
{
    PINPUTCONTEXT pInputContext;
    BOOL fCompFormInited;

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmGetCompositionWindow: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    fCompFormInited = ((pInputContext->fdwInit & INIT_COMPFORM) == INIT_COMPFORM);
    ImmUnlockIMC(hImc);

    if (fCompFormInited) {
        *lpCompForm = pInputContext->cfCompForm;
        return TRUE;
    }

    return FALSE;
}


BOOL WINAPI ImmSetCompositionWindow(
    HIMC              hImc,
    LPCOMPOSITIONFORM lpCompForm)
{
    PINPUTCONTEXT pInputContext;
    HWND          hWnd;

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmSetCompositionWindow: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmSetCompositionWindow: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    pInputContext->cfCompForm = *lpCompForm;
    pInputContext->fdwInit |= INIT_COMPFORM;

    /*
     * Only WINNLS.DLL set F31COMPAT_MCWHIDDEN.
     * When the apps or edit control calls this API, we need to remove
     * F31COMPAT_MCWHIDDEN.
     */
    if (pInputContext->fdw31Compat & F31COMPAT_CALLFROMWINNLS)
       pInputContext->fdw31Compat &= ~F31COMPAT_CALLFROMWINNLS;
    else
       pInputContext->fdw31Compat &= ~F31COMPAT_MCWHIDDEN;

    hWnd = pInputContext->hWnd;

    ImmUnlockIMC(hImc);

    /*
     * inform IME and UI about the change of composition window.
     */
    MakeIMENotify(hImc, hWnd, NI_CONTEXTUPDATED, 0L,
            IMC_SETCOMPOSITIONWINDOW, IMN_SETCOMPOSITIONWINDOW, 0L);

    return TRUE;
}


/***************************************************************************\
* ImmGetCandidateWindow
*
* Gets the information of the candidate window specified by dwIndex.
*
* History:
* 27-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmGetCandidateWindow(
    HIMC              hImc,
    DWORD             dwIndex,
    LPCANDIDATEFORM   lpCandForm)
{
    PINPUTCONTEXT pInputContext;

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmGetCandidateWindow: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    if (pInputContext->cfCandForm[dwIndex].dwIndex == -1) {
        ImmUnlockIMC(hImc);
        return (FALSE);
    }

    *lpCandForm = pInputContext->cfCandForm[dwIndex];
    ImmUnlockIMC(hImc);
    return TRUE;
}


BOOL WINAPI ImmSetCandidateWindow(
    HIMC              hImc,
    LPCANDIDATEFORM   lpCandForm)
{
    PINPUTCONTEXT pInputContext;
    HWND          hWnd;

    if (lpCandForm->dwIndex >= 4)      // over flow candidate index
        return (FALSE);

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmSetCandidateWindow: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmSetCandidateWindow: Lock hImc %lx failed", hImc);
        return FALSE;
    }

    pInputContext->cfCandForm[lpCandForm->dwIndex] = *lpCandForm;

    hWnd = pInputContext->hWnd;

    ImmUnlockIMC(hImc);

    /*
     * inform IME and UI about the change of composition window.
     */
    MakeIMENotify(hImc, hWnd, NI_CONTEXTUPDATED, 0L, IMC_SETCANDIDATEPOS,
            IMN_SETCANDIDATEPOS, (LPARAM)(0x01 << lpCandForm->dwIndex));

    return TRUE;
}


#define GetCompInfoA(Component)                                                \
        if (!dwBufLen) {    /* query required buffer size */                   \
                            /* not include \0             */                   \
            dwBufLen = pCompStr->dw ## Component ## Len * sizeof(CHAR);        \
        } else {                                                               \
            if (dwBufLen > pCompStr->dw ## Component ## Len * sizeof(CHAR)) {  \
                dwBufLen = pCompStr->dw ## Component ## Len * sizeof(CHAR);    \
            }                                                                  \
            /* don't copy \0, maybe there is actually none */                  \
            RtlCopyMemory((LPBYTE)lpBuf, (LPBYTE)pCompStr +                    \
                pCompStr->dw ## Component ## Offset, dwBufLen);                \
        }

#define GetCompInfoW(Component)                                                \
        if (!dwBufLen) {    /* query required buffer size */                   \
                            /* not include \0             */                   \
            dwBufLen = pCompStr->dw ## Component ## Len * sizeof(WCHAR);       \
        } else {                                                               \
            if (dwBufLen > pCompStr->dw ## Component ## Len * sizeof(WCHAR)) { \
                dwBufLen = pCompStr->dw ## Component ## Len * sizeof(WCHAR);   \
            }                                                                  \
            /* don't copy \0, maybe there is actually none */                  \
            RtlCopyMemory((LPBYTE)lpBuf, (LPBYTE)pCompStr +                    \
                pCompStr->dw ## Component ## Offset, dwBufLen);                \
        }

#ifdef CUAS_ENABLE

#define GetPrivInfoA(pv, Component)                                                \
        if (!dwBufLen) {    /* query required buffer size */                   \
                            /* not include \0             */                   \
            dwBufLen = ## pv ## ->dw ## Component ## Len * sizeof(CHAR);       \
        } else {                                                               \
            if (dwBufLen > ## pv ## ->dw ## Component ## Len * sizeof(CHAR)) { \
                dwBufLen = ## pv ## ->dw ## Component ## Len * sizeof(CHAR);   \
            }                                                                  \
            /* don't copy \0, maybe there is actually none */                  \
            RtlCopyMemory((LPBYTE)lpBuf, (LPBYTE) ## pv ## +                   \
                 ## pv ## ->dw ## Component ## Offset, dwBufLen);              \
        }

#define GetPrivInfoW(pv, Component)                                            \
        if (!dwBufLen) {    /* query required buffer size */                   \
                            /* not include \0             */                   \
            dwBufLen = ## pv ## ->dw ## Component ## Len * sizeof(WCHAR);      \
        } else {                                                               \
            if (dwBufLen > ## pv ## ->dw ## Component ## Len * sizeof(WCHAR)) {\
                dwBufLen = ## pv ## ->dw ## Component ## Len * sizeof(WCHAR);  \
            }                                                                  \
            /* don't copy \0, maybe there is actually none */                  \
            RtlCopyMemory((LPBYTE)lpBuf, (LPBYTE) ## pv ##  +                  \
                ## pv ## ->dw ## Component ## Offset, dwBufLen);               \
        }

#endif // CUAS_ENABLE

/***************************************************************************\
* InternalGetCompositionStringA
*
* Internal version of ImmGetCompositionStringA.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

LONG InternalGetCompositionStringA(
#ifdef CUAS_ENABLE
    HIMC               hImc,
#endif // CUAS_ENABLE
    PCOMPOSITIONSTRING pCompStr,
    DWORD              dwIndex,
    LPVOID             lpBuf,
    DWORD              dwBufLen,
    BOOL               fAnsiImc,
    DWORD              dwCodePage)
{
    if (fAnsiImc) {
        /*
         * Composition string in input context is of ANSI style.
         */
        switch (dwIndex) {
        case GCS_COMPSTR:
            GetCompInfoA(CompStr);
            break;
        case GCS_COMPATTR:
            GetCompInfoA(CompAttr);
            break;
        case GCS_COMPREADSTR:
            GetCompInfoA(CompReadStr);
            break;
        case GCS_COMPREADATTR:
            GetCompInfoA(CompReadAttr);
            break;
        case GCS_COMPREADCLAUSE:
            GetCompInfoA(CompReadClause);
            break;
        case GCS_CURSORPOS:
            dwBufLen = (LONG)pCompStr->dwCursorPos;
            break;
        case GCS_DELTASTART:
            dwBufLen = (LONG)pCompStr->dwDeltaStart;
            break;
        case GCS_RESULTSTR:
            GetCompInfoA(ResultStr);
            break;
        case GCS_RESULTCLAUSE:
            GetCompInfoA(ResultClause);
            break;
        case GCS_RESULTREADSTR:
            GetCompInfoA(ResultReadStr);
            break;
        case GCS_RESULTREADCLAUSE:
            GetCompInfoA(ResultReadClause);
            break;
        case GCS_COMPCLAUSE:
            GetCompInfoA(CompClause);
            break;
#ifdef CUAS_ENABLE
        case GCS_COMPGUIDATTR:
            if (CtfImmIsGuidMapEnable(hImc) && (pCompStr->dwPrivateSize >= sizeof(GUIDMAPATTRIBUTE)))
            {
                PGUIDMAPATTRIBUTE pGuidMap = (PGUIDMAPATTRIBUTE)((PBYTE)pCompStr + pCompStr->dwPrivateOffset);
                if (pGuidMap != NULL)
                {
                    GetPrivInfoA(pGuidMap, GuidMapAttr);
                }
                else
                {
                    dwBufLen = (DWORD)(LONG)IMM_ERROR_GENERAL;
                }
            }
            else
            {
                dwBufLen = (DWORD)(LONG)IMM_ERROR_GENERAL;
            }
            break;
#endif // CUAS_ENABLE
        default:
            dwBufLen = (DWORD)(LONG)IMM_ERROR_GENERAL;
            break;
        }

        return (LONG)dwBufLen;
    }

    /*
     * ANSI caller, Unicode input context/composition string.
     */
    switch (dwIndex) {
    case GCS_COMPSTR:
    case GCS_COMPREADSTR:
    case GCS_RESULTSTR:
    case GCS_RESULTREADSTR:
    {
        DWORD  dwStrSize;
        LPWSTR lpStrW;
        BOOL   bUDC;

        /*
         * Get ANSI string from Unicode composition string.
         */
#if !defined(CUAS_ENABLE)
        dwStrSize = InternalGetCompositionStringW(pCompStr, dwIndex,
                                            NULL, 0, fAnsiImc, dwCodePage);
#else
        dwStrSize = InternalGetCompositionStringW(hImc, pCompStr, dwIndex,
                                            NULL, 0, fAnsiImc, dwCodePage);
#endif

        lpStrW = ImmLocalAlloc(HEAP_ZERO_MEMORY, dwStrSize + sizeof(WCHAR));
        if (lpStrW == NULL) {
            RIPMSG0(RIP_WARNING, "InternalGetCompositionStringA: memory failure.");
            return (LONG)IMM_ERROR_GENERAL;
        }

#if !defined(CUAS_ENABLE)
        dwStrSize = InternalGetCompositionStringW(pCompStr, dwIndex,
                                            lpStrW, dwStrSize, fAnsiImc, dwCodePage);
#else
        dwStrSize = InternalGetCompositionStringW(hImc, pCompStr, dwIndex,
                                            lpStrW, dwStrSize, fAnsiImc, dwCodePage);
#endif

        dwBufLen = WideCharToMultiByte(dwCodePage,
                                       (DWORD)0,
                                       lpStrW,          // src
                                       wcslen(lpStrW),
                                       (LPSTR)lpBuf,    // dest
                                       dwBufLen,
                                       (LPSTR)NULL,
                                       (LPBOOL)&bUDC);

        ImmLocalFree(lpStrW);
        break;
    }

    case GCS_COMPATTR:
    case GCS_COMPREADATTR:
#ifdef CUAS_ENABLE
    case GCS_COMPGUIDATTR:
#endif // CUAS_ENABLE
    {
        DWORD dwAttrLenW, dwIndexStr, dwStrSize;
        PBYTE lpAttrA, lpAttrW;
        LPSTR lpStrA, lpStrT;
        CHAR  c;

        /*
         * Get ANSI attribute from Unicode composition attribute.
         */
        switch (dwIndex) {
        case GCS_COMPATTR:
            lpAttrW = (PBYTE)pCompStr + pCompStr->dwCompAttrOffset;
            dwAttrLenW = pCompStr->dwCompAttrLen;
            dwIndexStr = GCS_COMPSTR;
            break;
        case GCS_COMPREADATTR:
            lpAttrW = (PBYTE)pCompStr + pCompStr->dwCompReadAttrOffset;
            dwAttrLenW = pCompStr->dwCompReadAttrLen;
            dwIndexStr = GCS_COMPREADSTR;
            break;
#ifdef CUAS_ENABLE
        case GCS_COMPGUIDATTR:
            if (CtfImmIsGuidMapEnable(hImc) && (pCompStr->dwPrivateSize >= sizeof(GUIDMAPATTRIBUTE)))
            {
                PGUIDMAPATTRIBUTE pGuidMap = (PGUIDMAPATTRIBUTE)((PBYTE)pCompStr + pCompStr->dwPrivateOffset);
                if (pGuidMap != NULL)
                {
                    lpAttrW = (PBYTE)pGuidMap + pGuidMap->dwGuidMapAttrOffset;
                    dwAttrLenW = pGuidMap->dwGuidMapAttrLen;
                    dwIndexStr = GCS_COMPSTR;
                    break;
                }
                else
                {
                    return (DWORD)(LONG)IMM_ERROR_GENERAL;
                }
            }
            else
            {
                return (DWORD)(LONG)IMM_ERROR_GENERAL;
            }
            break;
#endif // CUAS_ENABLE
        }

        if (dwAttrLenW == 0) {
            /*
             * No CompAttr or CompReadAttr exists, do nothing.
             */
            return 0;
        }

#if !defined(CUAS_ENABLE)
        dwStrSize = InternalGetCompositionStringA(pCompStr,
                                        dwIndexStr, NULL, 0, fAnsiImc, dwCodePage);
#else
        dwStrSize = InternalGetCompositionStringA(hImc, pCompStr,
                                        dwIndexStr, NULL, 0, fAnsiImc, dwCodePage);
#endif

        if (dwStrSize == (DWORD)(LONG)IMM_ERROR_GENERAL) {
            RIPMSG0(RIP_WARNING, "InternalGetCompositionStringA: IMM_ERROR_GENERAL.");
            return (LONG)IMM_ERROR_GENERAL;
        }

        /*
         * Query required size or early exit on error.
         */
        if (dwBufLen == 0 || dwStrSize == 0)
            return dwStrSize;

        lpStrA = ImmLocalAlloc(HEAP_ZERO_MEMORY, dwStrSize + sizeof(CHAR));
        if (lpStrA == NULL) {
            RIPMSG0(RIP_WARNING, "InternalGetCompositionStringA: memory failure.");
            return (LONG)IMM_ERROR_GENERAL;
        }

#if !defined(CUAS_ENABLE)
        dwStrSize = InternalGetCompositionStringA(pCompStr,
                                        dwIndexStr, lpStrA, dwStrSize, fAnsiImc, dwCodePage);
#else
        dwStrSize = InternalGetCompositionStringA(hImc, pCompStr,
                                        dwIndexStr, lpStrA, dwStrSize, fAnsiImc, dwCodePage);
#endif

        if (dwStrSize == (LONG)IMM_ERROR_GENERAL) {
            RIPMSG0(RIP_WARNING, "InternalGetCompositionStringA: IMM_ERROR_GENERAL.");
            ImmLocalFree(lpStrA);
            return (LONG)IMM_ERROR_GENERAL;
        }

        lpStrT = lpStrA;
        lpAttrA = (PBYTE)lpBuf;

        while ((c=*lpStrT++) != '\0' && dwBufLen != 0 && dwAttrLenW-- != 0) {
            if (IsDBCSLeadByteEx(dwCodePage, c)) {
                if (dwBufLen >= 2) {
                    *lpAttrA++ = *lpAttrW;
                    *lpAttrA++ = *lpAttrW;
                    dwBufLen--;
                }
                else {
                    *lpAttrA++ = *lpAttrW;
                }
                lpStrT++;
            }
            else {
                *lpAttrA++ = *lpAttrW;
            }
            lpAttrW++;
            dwBufLen--;
        }

        dwBufLen = (DWORD)(lpAttrA - (PBYTE)lpBuf);

        ImmLocalFree(lpStrA);
        break;
    }

    case GCS_COMPCLAUSE:
    case GCS_COMPREADCLAUSE:
    case GCS_RESULTCLAUSE:
    case GCS_RESULTREADCLAUSE:
    {
        LPWSTR  lpStrW;
        DWORD   dwClauseLen, dwBufLenA;
        LPDWORD lpdwSrc, lpdwDst;
        UINT    i;

        /*
         * Get ANSI clause from Unicode composition clause.
         */
        switch (dwIndex) {
        case GCS_COMPCLAUSE:
            lpStrW = (LPWSTR)((PBYTE)pCompStr + pCompStr->dwCompStrOffset);
            lpdwSrc = (LPDWORD)((PBYTE)pCompStr + pCompStr->dwCompClauseOffset);
            dwClauseLen = pCompStr->dwCompClauseLen;
            break;
        case GCS_COMPREADCLAUSE:
            lpStrW = (LPWSTR)((PBYTE)pCompStr + pCompStr->dwCompReadStrOffset);
            lpdwSrc = (LPDWORD)((PBYTE)pCompStr + pCompStr->dwCompReadClauseOffset);
            dwClauseLen = pCompStr->dwCompReadClauseLen;
            break;
        case GCS_RESULTCLAUSE:
            lpStrW = (LPWSTR)((PBYTE)pCompStr + pCompStr->dwResultStrOffset);
            lpdwSrc = (LPDWORD)((PBYTE)pCompStr + pCompStr->dwResultClauseOffset);
            dwClauseLen = pCompStr->dwResultClauseLen;
            break;
        case GCS_RESULTREADCLAUSE:
            lpStrW = (LPWSTR)((PBYTE)pCompStr + pCompStr->dwResultReadStrOffset);
            lpdwSrc = (LPDWORD)((PBYTE)pCompStr + pCompStr->dwResultReadClauseOffset);
            dwClauseLen = pCompStr->dwResultReadClauseLen;
            break;
        }

        /*
         * Query clause length or early exit on error.
         */
        if (dwBufLen == 0 || (LONG)dwClauseLen < 0) {
            dwBufLen = dwClauseLen;
            break;
        }

        lpdwDst = (LPDWORD)lpBuf;
        dwBufLenA = dwBufLen / sizeof(DWORD);

        for (i = 0; i < dwClauseLen / sizeof(DWORD) && dwBufLenA != 0; i++) {
            *lpdwDst++ = CalcCharacterPositionWtoA(*lpdwSrc++, lpStrW, dwCodePage);
            dwBufLenA--;
        }

        dwBufLen = i * sizeof(DWORD);
        break;
    }

    case GCS_CURSORPOS:
    case GCS_DELTASTART:
        /*
         * Get ANSI cursor/delta start position from Unicode composition string.
         */
        switch (dwIndex) {
        case GCS_CURSORPOS:
            dwBufLen = pCompStr->dwCursorPos;
            break;
        case GCS_DELTASTART:
            dwBufLen = pCompStr->dwDeltaStart;
            break;
        }

        if ((LONG)dwBufLen > 0) {
            dwBufLen = CalcCharacterPositionWtoA(dwBufLen,
                            (LPWSTR)((PBYTE)pCompStr + pCompStr->dwCompStrOffset),
                            dwCodePage);
        }
        break;

    default:
        dwBufLen = (DWORD)(LONG)IMM_ERROR_GENERAL;
    }

    return (LONG)dwBufLen;
}


/***************************************************************************\
* InternalGetCompositionStringW
*
* Internal version of ImmGetCompositionStringW.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

LONG InternalGetCompositionStringW(
#ifdef CUAS_ENABLE
    HIMC               hImc,
#endif // CUAS_ENABLE
    PCOMPOSITIONSTRING pCompStr,
    DWORD              dwIndex,
    LPVOID             lpBuf,
    DWORD              dwBufLen,
    BOOL               fAnsiImc,
    DWORD              dwCodePage)
{
    if (!fAnsiImc) {
        /*
         * Composition string in input context is of Unicode style.
         */
        switch (dwIndex) {
        case GCS_COMPSTR:
            GetCompInfoW(CompStr);
            break;
        case GCS_COMPATTR:              // ANSI-only
            GetCompInfoA(CompAttr);
            break;
        case GCS_COMPREADSTR:
            GetCompInfoW(CompReadStr);
            break;
        case GCS_COMPREADATTR:          // ANSI-only
            GetCompInfoA(CompReadAttr);
            break;
        case GCS_COMPREADCLAUSE:        // ANSI-only
            GetCompInfoA(CompReadClause);
            break;
        case GCS_CURSORPOS:
            dwBufLen = (LONG)pCompStr->dwCursorPos;
            break;
        case GCS_DELTASTART:
            dwBufLen = (LONG)pCompStr->dwDeltaStart;
            break;
        case GCS_RESULTSTR:
            GetCompInfoW(ResultStr);
            break;
        case GCS_RESULTCLAUSE:          // ANSI-only
            GetCompInfoA(ResultClause);
            break;
        case GCS_RESULTREADSTR:
            GetCompInfoW(ResultReadStr);
            break;
        case GCS_RESULTREADCLAUSE:      // ANSI-only
            GetCompInfoA(ResultReadClause);
            break;
        case GCS_COMPCLAUSE:            // ANSI-only
            GetCompInfoA(CompClause);
            break;
#ifdef CUAS_ENABLE
        case GCS_COMPGUIDATTR:          // ANSI-only
            if (CtfImmIsGuidMapEnable(hImc) && (pCompStr->dwPrivateSize >= sizeof(GUIDMAPATTRIBUTE)))
            {
                PGUIDMAPATTRIBUTE pGuidMap = (PGUIDMAPATTRIBUTE)((PBYTE)pCompStr + pCompStr->dwPrivateOffset);
                if (pGuidMap != NULL)
                {
                    GetPrivInfoA(pGuidMap, GuidMapAttr);
                }
                else
                {
                    dwBufLen = (DWORD)(LONG)IMM_ERROR_GENERAL;
                }
            }
            else
            {
                dwBufLen = (DWORD)(LONG)IMM_ERROR_GENERAL;
            }
            break;
#endif // CUAS_ENABLE
        default:
            dwBufLen = (DWORD)IMM_ERROR_GENERAL;
            break;
        }

        return (LONG)dwBufLen;
    }

    /*
     * Unicode caller, ANSI input context/composition string.
     */
    switch (dwIndex) {
    case GCS_COMPSTR:
    case GCS_COMPREADSTR:
    case GCS_RESULTSTR:
    case GCS_RESULTREADSTR:
    {
        DWORD  dwStrSize;
        LPSTR lpStrA;

        /*
         * Get Unicode string from ANSI composition string.
         */
#if !defined(CUAS_ENABLE)
        dwStrSize = InternalGetCompositionStringA(pCompStr, dwIndex,
                                            NULL, 0, fAnsiImc, dwCodePage);
#else
        dwStrSize = InternalGetCompositionStringA(hImc, pCompStr, dwIndex,
                                            NULL, 0, fAnsiImc, dwCodePage);
#endif

        lpStrA = ImmLocalAlloc(HEAP_ZERO_MEMORY, dwStrSize + sizeof(CHAR));
        if (lpStrA == NULL) {
            RIPMSG0(RIP_WARNING, "InternalGetCompositionStringW: memory failure.");
            return (LONG)IMM_ERROR_GENERAL;
        }

#if !defined(CUAS_ENABLE)
        dwStrSize = InternalGetCompositionStringA(pCompStr, dwIndex,
                                            lpStrA, dwStrSize, fAnsiImc, dwCodePage);
#else
        dwStrSize = InternalGetCompositionStringA(hImc, pCompStr, dwIndex,
                                            lpStrA, dwStrSize, fAnsiImc, dwCodePage);
#endif

        dwBufLen = MultiByteToWideChar(dwCodePage,
                                       (DWORD)MB_PRECOMPOSED,
                                       lpStrA,              // src
                                       strlen(lpStrA),
                                       (LPWSTR)lpBuf,        // dest
                                       (INT)dwBufLen);

        dwBufLen *= sizeof(WCHAR);     // return number of bytes required.

        ImmLocalFree(lpStrA);
        break;
    }

    case GCS_COMPATTR:
    case GCS_COMPREADATTR:
#ifdef CUAS_ENABLE
    case GCS_COMPGUIDATTR:
#endif // CUAS_ENABLE
    {
        DWORD  dwAttrLenA, dwIndexStr, dwStrSize;
        PBYTE  lpAttrA, lpAttrW;
        LPWSTR lpStrW, lpStrT;
        ULONG  MultiByteSize;
        WCHAR  wc;

        /*
         * Get Unicode attribute from ANSI composition attribute.
         */
        switch (dwIndex) {
        case GCS_COMPATTR:
            lpAttrA = (PBYTE)pCompStr + pCompStr->dwCompAttrOffset;
            dwAttrLenA = pCompStr->dwCompAttrLen;
            dwIndexStr = GCS_COMPSTR;
            break;
        case GCS_COMPREADATTR:
            lpAttrA = (PBYTE)pCompStr + pCompStr->dwCompReadAttrOffset;
            dwAttrLenA = pCompStr->dwCompReadAttrLen;
            dwIndexStr = GCS_COMPREADSTR;
            break;
#ifdef CUAS_ENABLE
        case GCS_COMPGUIDATTR:
            if (CtfImmIsGuidMapEnable(hImc) && (pCompStr->dwPrivateSize >= sizeof(GUIDMAPATTRIBUTE)))
            {
                PGUIDMAPATTRIBUTE pGuidMap = (PGUIDMAPATTRIBUTE)((PBYTE)pCompStr + pCompStr->dwPrivateOffset);
                if (pGuidMap != NULL)
                {
                    lpAttrA = (PBYTE)pGuidMap + pGuidMap->dwGuidMapAttrOffset;
                    dwAttrLenA = pGuidMap->dwGuidMapAttrLen;
                    dwIndexStr = GCS_COMPSTR;
                    break;
                }
                else
                {
                    return (DWORD)(LONG)IMM_ERROR_GENERAL;
                }
            }
            else
            {
                return (DWORD)(LONG)IMM_ERROR_GENERAL;
            }
            break;
#endif // CUAS_ENABLE
        }

        if (dwAttrLenA == 0) {
            /*
             * No CompAttr or CompReadAttr exists, do nothing.
             */
            return 0;
        }

#if !defined(CUAS_ENABLE)
        dwStrSize = InternalGetCompositionStringW(pCompStr,
                                        dwIndexStr, NULL, 0, fAnsiImc, dwCodePage);
#else
        dwStrSize = InternalGetCompositionStringW(hImc, pCompStr,
                                        dwIndexStr, NULL, 0, fAnsiImc, dwCodePage);
#endif

        if (dwStrSize == (DWORD)(LONG)IMM_ERROR_GENERAL) {
            RIPMSG0(RIP_WARNING, "InternalGetCompositionStringA: IMM_ERROR_GENERAL.");
            return (LONG)IMM_ERROR_GENERAL;
        }

        /*
         * Query required size or early exit on error.
         */
        if (dwBufLen == 0 || dwStrSize == 0)
            return dwStrSize / sizeof(WCHAR);

        lpStrW = ImmLocalAlloc(HEAP_ZERO_MEMORY, dwStrSize + sizeof(WCHAR));
        if (lpStrW == NULL) {
            RIPMSG0(RIP_WARNING, "InternalGetCompositionStringW: memory failure.");
            return (LONG)IMM_ERROR_GENERAL;
        }

#if !defined(CUAS_ENABLE)
        dwStrSize = InternalGetCompositionStringW(pCompStr,
                                        dwIndexStr, lpStrW, dwStrSize, fAnsiImc, dwCodePage);
#else
        dwStrSize = InternalGetCompositionStringW(hImc, pCompStr,
                                        dwIndexStr, lpStrW, dwStrSize, fAnsiImc, dwCodePage);
#endif

        if (dwStrSize == (LONG)IMM_ERROR_GENERAL) {
            RIPMSG0(RIP_WARNING, "InternalGetCompositionStringA: IMM_ERROR_GENERAL.");
            ImmLocalFree(lpStrW);
            return (LONG)IMM_ERROR_GENERAL;
        }

        lpStrT = lpStrW;
        lpAttrW = (PBYTE)lpBuf;

        while ((wc=*lpStrT++) != L'\0' && dwBufLen != 0 && dwAttrLenA-- != 0) {
            MultiByteSize = UnicodeToMultiByteSize(dwCodePage, &wc);
            if (MultiByteSize == 2 && dwAttrLenA != 0) {
                *lpAttrW++ = *lpAttrA++;
                dwAttrLenA--;
            }
            else {
                *lpAttrW++ = *lpAttrA;
            }
            lpAttrA++;
            dwBufLen--;
        }

        dwBufLen = (DWORD)(lpAttrW - (PBYTE)lpBuf);

        ImmLocalFree(lpStrW);
        break;
    }

    case GCS_COMPCLAUSE:
    case GCS_COMPREADCLAUSE:
    case GCS_RESULTCLAUSE:
    case GCS_RESULTREADCLAUSE:
    {
        LPSTR   lpStrA;
        DWORD   dwClauseLen, dwBufLenW;
        LPDWORD lpdwSrc, lpdwDst;
        UINT    i;

        /*
         * Get Unicode clause from ANSI composition clause.
         */
        switch (dwIndex) {
        case GCS_COMPCLAUSE:
            lpStrA = (LPSTR)((PBYTE)pCompStr + pCompStr->dwCompStrOffset);
            lpdwSrc = (LPDWORD)((PBYTE)pCompStr + pCompStr->dwCompClauseOffset);
            dwClauseLen = pCompStr->dwCompClauseLen;
            break;
        case GCS_COMPREADCLAUSE:
            lpStrA = (LPSTR)((PBYTE)pCompStr + pCompStr->dwCompReadStrOffset);
            lpdwSrc = (LPDWORD)((PBYTE)pCompStr + pCompStr->dwCompReadClauseOffset);
            dwClauseLen = pCompStr->dwCompReadClauseLen;
            break;
        case GCS_RESULTCLAUSE:
            lpStrA = (LPSTR)((PBYTE)pCompStr + pCompStr->dwResultStrOffset);
            lpdwSrc = (LPDWORD)((PBYTE)pCompStr + pCompStr->dwResultClauseOffset);
            dwClauseLen = pCompStr->dwResultClauseLen;
            break;
        case GCS_RESULTREADCLAUSE:
            lpStrA = (LPSTR)((PBYTE)pCompStr + pCompStr->dwResultReadStrOffset);
            lpdwSrc = (LPDWORD)((PBYTE)pCompStr + pCompStr->dwResultReadClauseOffset);
            dwClauseLen = pCompStr->dwResultReadClauseLen;
            break;
        }


        /*
         * Query clause length or early exit on error.
         */
        if (dwBufLen == 0 || (LONG)dwClauseLen < 0) {
            dwBufLen = dwClauseLen;
            break;
        }

        lpdwDst = (LPDWORD)lpBuf;
        dwBufLenW = dwBufLen / sizeof(DWORD);

        for (i = 0; i < dwClauseLen / sizeof(DWORD) && dwBufLenW != 0; i++) {
            *lpdwDst++ = CalcCharacterPositionAtoW(*lpdwSrc++, lpStrA, dwCodePage);
            dwBufLenW--;
        }

        dwBufLen = i * sizeof(DWORD);
        break;
    }

    case GCS_CURSORPOS:
    case GCS_DELTASTART:
        /*
         * Get Unicode cursor/delta start position from ANSI composition string.
         */
        switch (dwIndex) {
        case GCS_CURSORPOS:
            dwBufLen = pCompStr->dwCursorPos;
            break;
        case GCS_DELTASTART:
            dwBufLen = pCompStr->dwDeltaStart;
            break;
        }

        if ((LONG)dwBufLen > 0) {
            dwBufLen = CalcCharacterPositionAtoW(dwBufLen,
                            (LPSTR)((PBYTE)pCompStr + pCompStr->dwCompStrOffset),
                            dwCodePage);
        }
        break;

    default:
        dwBufLen = (DWORD)(LONG)IMM_ERROR_GENERAL;
    }

    return (LONG)dwBufLen;
}


DWORD InternalGetCandidateListAtoW(
    LPCANDIDATELIST     lpCandListA,
    LPCANDIDATELIST     lpCandListW,
    DWORD               dwBufLen,
    DWORD               dwCodePage)
{
    LPWSTR lpCandStrW;
    LPSTR  lpCandStrA;
    INT    i, j;
    DWORD  dwCandListLen;

    dwCandListLen = sizeof(CANDIDATELIST);

    /*
     * CANDIDATELIST has already contained the dwOffset[0]
     */
    if (lpCandListA->dwCount > 0)
        dwCandListLen += sizeof(DWORD) * (lpCandListA->dwCount - 1);

    for (i = 0; i < (INT)lpCandListA->dwCount; i++) {

        lpCandStrA = (LPSTR)((LPBYTE)lpCandListA + lpCandListA->dwOffset[i]);

        j = MultiByteToWideChar(dwCodePage,
                                (DWORD)MB_PRECOMPOSED,
                                lpCandStrA,
                                -1,
                                (LPWSTR)NULL,
                                0);

        dwCandListLen += (j * sizeof(WCHAR));
    }

    dwCandListLen = DWORD_ALIGN(dwCandListLen);

    if (dwBufLen == 0)
        return dwCandListLen;

    if (dwBufLen < dwCandListLen) {
        RIPMSG0(RIP_WARNING, "InternalGetCandidateListAtoW: dwBufLen too small.");
        return 0;
    }

    lpCandListW->dwSize = dwBufLen;
    lpCandListW->dwStyle = lpCandListA->dwStyle;
    lpCandListW->dwCount = lpCandListA->dwCount;
    lpCandListW->dwSelection = lpCandListA->dwSelection;
    lpCandListW->dwPageStart = lpCandListA->dwPageStart;
    lpCandListW->dwPageSize = lpCandListA->dwPageSize;
    lpCandListW->dwOffset[0] = sizeof(CANDIDATELIST);
    if (lpCandListW->dwCount > 0)
        lpCandListW->dwOffset[0] += sizeof(DWORD) * (lpCandListW->dwCount - 1);

    dwCandListLen = dwBufLen - lpCandListW->dwOffset[0];

    for  (i = 0; i < (INT)lpCandListW->dwCount; i++) {

        lpCandStrA = (LPSTR) ((LPBYTE)lpCandListA + lpCandListA->dwOffset[i]);
        lpCandStrW = (LPWSTR)((LPBYTE)lpCandListW + lpCandListW->dwOffset[i]);

        j = MultiByteToWideChar(dwCodePage,
                                (DWORD)MB_PRECOMPOSED,
                                lpCandStrA,
                                -1,
                                lpCandStrW,
                                (INT)dwCandListLen/sizeof(WCHAR));

        dwCandListLen -= (j * sizeof(WCHAR));

        if (i < (INT)lpCandListW->dwCount - 1)
            lpCandListW->dwOffset[i+1] = lpCandListW->dwOffset[i] + j * sizeof(WCHAR);
    }

    return dwBufLen;
}


DWORD InternalGetCandidateListWtoA(
    LPCANDIDATELIST     lpCandListW,
    LPCANDIDATELIST     lpCandListA,
    DWORD               dwBufLen,
    DWORD               dwCodePage)
{
    LPWSTR lpCandStrW;
    LPSTR  lpCandStrA;
    INT    i, j;
    DWORD  dwCandListLen;
    BOOL   bUDC;

    dwCandListLen = sizeof(CANDIDATELIST);

    /*
     * CANDIDATELIST has already contained the dwOffset[0]
     */
    if (lpCandListW->dwCount > 0)
        dwCandListLen += sizeof(DWORD) * (lpCandListW->dwCount - 1);

    for (i = 0; i < (INT)lpCandListW->dwCount; i++) {

        lpCandStrW = (LPWSTR)((LPBYTE)lpCandListW + lpCandListW->dwOffset[i]);

        j = WideCharToMultiByte(dwCodePage,
                                (DWORD)0,
                                lpCandStrW,
                                -1,
                                (LPSTR)NULL,
                                (INT)0,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);

        dwCandListLen += (j * sizeof(CHAR));
    }

    dwCandListLen = DWORD_ALIGN(dwCandListLen);

    if (dwBufLen == 0)
        return dwCandListLen;

    if (dwBufLen < dwCandListLen) {
        RIPMSG0(RIP_WARNING, "InternalGetCandidateListWtoA: dwBufLen too small.");
        return 0;
    }

    lpCandListA->dwSize = dwBufLen;
    lpCandListA->dwStyle = lpCandListW->dwStyle;
    lpCandListA->dwCount = lpCandListW->dwCount;
    lpCandListA->dwSelection = lpCandListW->dwSelection;
    lpCandListA->dwPageStart = lpCandListW->dwPageStart;
    lpCandListA->dwPageSize = lpCandListW->dwPageSize;
    lpCandListA->dwOffset[0] = sizeof(CANDIDATELIST);
    if (lpCandListA->dwCount > 0)
        lpCandListA->dwOffset[0] += sizeof(DWORD) * (lpCandListA->dwCount - 1);

    dwCandListLen = dwBufLen - lpCandListA->dwOffset[0];

    for  (i = 0; i < (INT)lpCandListA->dwCount; i++) {

        lpCandStrA = (LPSTR) ((LPBYTE)lpCandListA + lpCandListA->dwOffset[i]);
        lpCandStrW = (LPWSTR)((LPBYTE)lpCandListW + lpCandListW->dwOffset[i]);

        j = WideCharToMultiByte(dwCodePage,
                                (DWORD)0,
                                lpCandStrW,
                                -1,
                                (LPSTR)lpCandStrA,
                                (INT)dwCandListLen,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);

        dwCandListLen -= (j * sizeof(CHAR));

        if (i < (INT)lpCandListA->dwCount - 1)
            lpCandListA->dwOffset[i+1] = lpCandListA->dwOffset[i] + j * sizeof(CHAR);
    }

    return dwBufLen;
}

/***************************************************************************\
* CalcCharacterPositionAtoW
*
* Calculate Unicode character position to ANSI character position.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD CalcCharacterPositionAtoW(
    DWORD dwCharPosA,
    LPSTR lpszCharStr,
    DWORD dwCodePage)
{
    DWORD dwCharPosW = 0;

    while (dwCharPosA != 0) {
        if (IsDBCSLeadByteEx(dwCodePage, *lpszCharStr)) {
            if (dwCharPosA >= 2) {
                dwCharPosA -= 2;
            }
            else {
                dwCharPosA--;
            }
            lpszCharStr += 2;
        }
        else {
            dwCharPosA--;
            lpszCharStr++;
        }
        dwCharPosW++;
    }

    return dwCharPosW;
}


/***************************************************************************\
* CalcCharacterPositionWtoA
*
* Calculate ANSI character position to Unicode character position.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD CalcCharacterPositionWtoA(
    DWORD dwCharPosW,
    LPWSTR lpwszCharStr,
    DWORD  dwCodePage)
{
    DWORD dwCharPosA = 0;
    ULONG MultiByteSize;

    while (dwCharPosW != 0) {
        MultiByteSize = UnicodeToMultiByteSize(dwCodePage, lpwszCharStr);
        if (MultiByteSize == 2) {
            dwCharPosA += 2;
        }
        else {
            dwCharPosA++;
        }
        dwCharPosW--;
        lpwszCharStr++;
    }

    return dwCharPosA;
}


VOID LFontAtoLFontW(
    LPLOGFONTA lpLogFontA,
    LPLOGFONTW lpLogFontW)
{
    INT i;

    RtlCopyMemory(lpLogFontW, lpLogFontA, sizeof(LOGFONTA)-LF_FACESIZE);

    i = MultiByteToWideChar(CP_ACP,     // Note: font face name should use ACP for A/W conversion.
                            MB_PRECOMPOSED,
                            lpLogFontA->lfFaceName,
                            strlen(lpLogFontA->lfFaceName),
                            lpLogFontW->lfFaceName,
                            LF_FACESIZE);

    lpLogFontW->lfFaceName[i] = L'\0';

    return;
}


VOID LFontWtoLFontA(
    LPLOGFONTW lpLogFontW,
    LPLOGFONTA lpLogFontA)
{
    INT  i;
    BOOL bUDC;

    RtlCopyMemory(lpLogFontA, lpLogFontW, sizeof(LOGFONTA)-LF_FACESIZE);

    i = WideCharToMultiByte(CP_ACP,     // Note: font face name should use ACP for A/W conversion.
                            0,
                            lpLogFontW->lfFaceName,
                            wcslen(lpLogFontW->lfFaceName),
                            lpLogFontA->lfFaceName,
                            LF_FACESIZE,
                            (LPSTR)NULL,
                            &bUDC);

    lpLogFontA->lfFaceName[i] = '\0';

    return;
}


BOOL MakeIMENotify(
    HIMC   hImc,
    HWND   hWnd,
    DWORD  dwAction,
    DWORD  dwIndex,
    DWORD  dwValue,
    WPARAM wParam,
    LPARAM lParam)
{
    PIMEDPI pImeDpi;
    DWORD   dwThreadId;

#ifdef LATER
    // implement MakeIMENotifyEvent() later
#endif

    if (dwAction != 0 && (dwThreadId = GetInputContextThread(hImc)) != 0) {

        pImeDpi = ImmLockImeDpi(GetKeyboardLayout(dwThreadId));

        if (pImeDpi != NULL) {
            (*pImeDpi->pfn.NotifyIME)(hImc, dwAction, dwIndex, dwValue);
            ImmUnlockImeDpi(pImeDpi);
        }
    }

    if (hWnd != NULL && wParam != 0)
        SendMessage(hWnd, WM_IME_NOTIFY, wParam, lParam);

    return TRUE;
}



//////////////////////////////////////////////////////////////////////
// Reconversion support
//////////////////////////////////////////////////////////////////////

typedef enum {FROM_IME, FROM_APP} REQ_CALLER;

///////////////////////////////////////////////////////////////////////////////////
// ImmGetReconvertTotalSize
//
// calculate the appropriate size of the buffer, based on caller/ansi information
//
// History:
// 28-Feb-1997   hiroyama   Created
///////////////////////////////////////////////////////////////////////////////////

DWORD ImmGetReconvertTotalSize(DWORD dwSize, REQ_CALLER eCaller, BOOL bAnsiTarget)
{
    if (dwSize < sizeof(RECONVERTSTRING)) {
        return 0;
    }
    if (bAnsiTarget) {
        dwSize -= sizeof(RECONVERTSTRING);
        if (eCaller == FROM_IME) {
            dwSize /= 2;
        } else {
            dwSize *= 2;
        }
        dwSize += sizeof(RECONVERTSTRING);
    }
    return dwSize;
}

DWORD ImmReconversionWorker(
        LPRECONVERTSTRING lpRecTo,
        LPRECONVERTSTRING lpRecFrom,
        BOOL bToAnsi,
        DWORD dwCodePage)
{
    INT i;
    DWORD dwSize = 0;

    UserAssert(lpRecTo);
    UserAssert(lpRecFrom);

    if (lpRecFrom->dwVersion != 0 || lpRecTo->dwVersion != 0) {
        RIPMSG0(RIP_WARNING, "ImmReconversionWorker: dwVersion in lpRecTo or lpRecFrom is incorrect.");
        return 0;
    }
    // Note:
    // In any IME related structures, use the following principal.
    // 1) xxxStrOffset is an actual offset, i.e. byte count.
    // 2) xxxStrLen is a number of characters, i.e. TCHAR count.
    //
    // CalcCharacterPositionXtoY() takes TCHAR count so that we
    // need to adjust xxxStrOffset if it's being converted. But you
    // should be careful, because the actual position of the string
    // is always at something like (LPBYTE)lpStruc + lpStruc->dwStrOffset.
    //
    if (bToAnsi) {
        // Convert W to A
        lpRecTo->dwStrOffset = sizeof *lpRecTo;
        i = WideCharToMultiByte(dwCodePage,
                                (DWORD)0,
                                (LPWSTR)((LPSTR)lpRecFrom + lpRecFrom->dwStrOffset), // src
                                (INT)lpRecFrom->dwStrLen,
                                (LPSTR)lpRecTo + lpRecTo->dwStrOffset,  // dest
                                (INT)lpRecFrom->dwStrLen * DBCS_CHARSIZE,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpRecTo->dwCompStrOffset =
            CalcCharacterPositionWtoA(lpRecFrom->dwCompStrOffset / sizeof(WCHAR),
                                      (LPWSTR)((LPBYTE)lpRecFrom + lpRecFrom->dwStrOffset),
                                      dwCodePage)
                            * sizeof(CHAR);

        lpRecTo->dwCompStrLen =
            (CalcCharacterPositionWtoA(lpRecFrom->dwCompStrOffset / sizeof(WCHAR) +
                                      lpRecFrom->dwCompStrLen,
                                      (LPWSTR)((LPBYTE)lpRecFrom + lpRecFrom->dwStrOffset),
                                      dwCodePage)
                            * sizeof(CHAR))
            - lpRecTo->dwCompStrOffset;

        lpRecTo->dwTargetStrOffset =
            CalcCharacterPositionWtoA(lpRecFrom->dwTargetStrOffset / sizeof(WCHAR),
                                      (LPWSTR)((LPBYTE)lpRecFrom +
                                                lpRecFrom->dwStrOffset),
                                      dwCodePage)
                            * sizeof(CHAR);

        lpRecTo->dwTargetStrLen =
            (CalcCharacterPositionWtoA(lpRecFrom->dwTargetStrOffset / sizeof(WCHAR) +
                                      lpRecFrom->dwTargetStrLen,
                                      (LPWSTR)((LPBYTE)lpRecFrom + lpRecFrom->dwStrOffset),
                                       dwCodePage)
                            * sizeof(CHAR))
            - lpRecTo->dwTargetStrOffset;

        ((LPSTR)lpRecTo)[lpRecTo->dwStrOffset + i] = '\0';
        lpRecTo->dwStrLen = i * sizeof(CHAR);

        dwSize = sizeof(RECONVERTSTRING) + ((i + 1) * sizeof(CHAR));

    } else {

        // AtoW
        lpRecTo->dwStrOffset = sizeof *lpRecTo;
        i = MultiByteToWideChar(dwCodePage,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,  // src
                                (INT)lpRecFrom->dwStrLen,
                                (LPWSTR)((LPSTR)lpRecTo + lpRecTo->dwStrOffset), // dest
                                (INT)lpRecFrom->dwStrLen);

        lpRecTo->dwCompStrOffset =
            CalcCharacterPositionAtoW(lpRecFrom->dwCompStrOffset,
                                      (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,
                                      dwCodePage) * sizeof(WCHAR);

        lpRecTo->dwCompStrLen =
            ((CalcCharacterPositionAtoW(lpRecFrom->dwCompStrOffset +
                                       lpRecFrom->dwCompStrLen,
                                       (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,
                                        dwCodePage)  * sizeof(WCHAR))
            - lpRecTo->dwCompStrOffset) / sizeof(WCHAR);

        lpRecTo->dwTargetStrOffset =
            CalcCharacterPositionAtoW(lpRecFrom->dwTargetStrOffset,
                                      (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,
                                      dwCodePage) * sizeof(WCHAR);

        lpRecTo->dwTargetStrLen =
            ((CalcCharacterPositionAtoW(lpRecFrom->dwTargetStrOffset +
                                       lpRecFrom->dwTargetStrLen,
                                       (LPSTR)lpRecFrom + lpRecFrom->dwStrOffset,
                                       dwCodePage)  * sizeof(WCHAR))
            - lpRecTo->dwTargetStrOffset) / sizeof(WCHAR);

        lpRecTo->dwStrLen = i;  // Length is TCHAR count.
        if (lpRecTo->dwSize >= (DWORD)(lpRecTo->dwStrOffset + (i + 1)* sizeof(WCHAR))) {
            LPWSTR lpW = (LPWSTR)((LPSTR)lpRecTo + lpRecTo->dwStrOffset);
            lpW[i] = L'\0';
        }
        dwSize = sizeof(RECONVERTSTRING) + ((i + 1) * sizeof(WCHAR));
    }
    return dwSize;
}

///////////////////////////////////////////////////////////////////////////////////
// ImmRequestMessageWorker
//
// worker function for WM_IME_REQUEST message
//
// History:
// 30-Mar-1997   hiroyama   Created
///////////////////////////////////////////////////////////////////////////////////

LRESULT ImmRequestMessageWorker(HIMC hIMC, PWND pwnd, WPARAM wParam, LPARAM lParam, BOOL bAnsiOrigin)
{
    // the (least) size of the structure given in lParam: for valid pointer checking
    static CONST int nReqBufSize[][7] = {
        {   // sizes if IME is UNICODE
            sizeof(COMPOSITIONFORM),    // IMR_COMPOSITIONWINDOW
            sizeof(CANDIDATEFORM),      // IMR_CANDIDATEWINDOW
            sizeof(LOGFONTW),           // IMR_COMPOSITIONFONT
            sizeof(RECONVERTSTRING),    // IMR_RECONVERTSTRING
            sizeof(RECONVERTSTRING),    // IMR_CONFIRMRECONVERTSTRING
            sizeof(IMECHARPOSITION),    // IMR_QUERYCHARPOSITION
            sizeof(RECONVERTSTRING),    // IMR_DOCUMENTFEED
        },
        {   // sizes if IME is ANSI
            sizeof(COMPOSITIONFORM),    // IMR_COMPOSITIONWINDOW
            sizeof(CANDIDATEFORM),      // IMR_CANDIDATEWINDOW
            sizeof(LOGFONTA),           // IMR_COMPOSITIONFONT
            sizeof(RECONVERTSTRING),    // IMR_RECONVERTSTRING
            sizeof(RECONVERTSTRING),    // IMR_CONFIRMRECONVERTSTRING
            sizeof(IMECHARPOSITION),    // IMR_QUERYCHARPOSITION
            sizeof(RECONVERTSTRING),    // IMR_DOCUMENTFEED
        }
    };
    LRESULT lRet = 0L;
    CONST BOOLEAN bAnsiTarget = !!TestWF(pwnd, WFANSIPROC);    // TRUE if the target Window Proc is ANSI
    LPBYTE lpReq = (LPBYTE)lParam;                          // return buffer (maybe allocated buffer)
    LPBYTE lpNew = NULL;                                    // buffer allocated within this function
    DWORD dwSaveCharPos;
    PCLIENTIMC pClientImc;
    DWORD dwCodePage;

#define SEND_MESSAGE(bAnsi)   ((bAnsi) ? SendMessageA : SendMessageW)

    //////////////////////////////////////////////
    // Parameter checking

    // check wParam as sub messages
    if (wParam == 0 || wParam > IMR_DOCUMENTFEED) {  // wParam is not a proper sub message
        RIPMSG1(RIP_WARNING, "ImmRequestMessageWorker: wParam(%lx) out of range.", wParam);
        return 0L;
    }

    // Check if the pointer which is given through lParam points the proper memory block.
    UserAssert(bAnsiOrigin == 0 || bAnsiOrigin == 1);   // we'll use bAnsiOrigin as an index

    // The first sub message IMR_COMPOSITIONWINDOW is 1, so substract 1 from wParam
    if (lpReq && IsBadWritePtr(lpReq, nReqBufSize[bAnsiOrigin][wParam - 1])) {
        RIPMSG0(RIP_WARNING, "ImmRequestMessageWorker: Bad pointer passed from IME to write");
        return 0L;
    }

    // check the lpReq(==lParam): the spec does not allow lParam as NULL
    // except IMR_RECONVERTSTRING and IMR_DOCUMENTFEED
    if (wParam == IMR_RECONVERTSTRING || wParam == IMR_DOCUMENTFEED) {
        //
        // check version number
        //
        if (lpReq != NULL) {
            LPRECONVERTSTRING lpReconv = (LPRECONVERTSTRING)lParam;
            if (lpReconv->dwVersion != 0) {
                RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid version number: %d",
                        lpReconv->dwVersion);
                return 0L;
            }
            if (lpReconv->dwSize < sizeof(RECONVERTSTRING)) {
                RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid dwSize: %d",
                        lpReconv->dwSize);
                return 0L;
            }
        }
    } else if (wParam == IMR_CONFIRMRECONVERTSTRING) {
        // check if lParam is not NULL, and version of the structure is correct.
        if (lpReq == NULL || ((LPRECONVERTSTRING)lpReq)->dwVersion != 0) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid argument or invalid version number");
            return 0L;
        }
    } else if (lpReq == NULL) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING,
                "ImmRequestMessageWorker: lParam should not be NULL with this wParam(%lx).",
                wParam);
        return 0L;
    }
    // end parameter checking
    ////////////////////////////////////////////

    pClientImc = ImmLockClientImc(hIMC);
    if (pClientImc != NULL) {
        dwCodePage = CImcCodePage(pClientImc);
        ImmUnlockClientImc(pClientImc);
    }
    else {
        dwCodePage = CP_ACP;
    }

    // allocate and prepare required buffer if we need A/W conversion
    switch (wParam) {
    case IMR_CONFIRMRECONVERTSTRING:
    case IMR_RECONVERTSTRING:
    case IMR_DOCUMENTFEED:
        if (bAnsiOrigin != bAnsiTarget) {
            if (lpReq != NULL) {
                // IME wants not only the buffer size but the real reconversion information
                DWORD dwSize = ImmGetReconvertTotalSize(((LPRECONVERTSTRING)lpReq)->dwSize, FROM_IME, bAnsiTarget);
                LPRECONVERTSTRING lpReconv;

                lpNew = ImmLocalAlloc(0, dwSize + sizeof(WCHAR));
                if (lpNew == NULL) {
                    RIPMSG0(RIP_WARNING, "ImmRequestMessageWorker: failed to allocate a buffer for reconversion.");
                    return 0L;
                }
                lpReconv = (LPRECONVERTSTRING)lpNew;
                // setup the information in the allocated structure
                lpReconv->dwVersion = 0;
                lpReconv->dwSize = dwSize;

                //
                // if it's confirmation message, we need to translate the contents
                //
                if (wParam == IMR_CONFIRMRECONVERTSTRING) {
                    ImmReconversionWorker(lpReconv, (LPRECONVERTSTRING)lParam, bAnsiTarget, dwCodePage);
                }
            }
        }
        break;

    case IMR_COMPOSITIONFONT:
        UserAssert(lpReq != NULL);      // has been checked so far
        if (bAnsiOrigin != bAnsiTarget) {
            if (bAnsiTarget) {
                lpNew = ImmLocalAlloc(0, sizeof(LOGFONTA));
            } else {
                lpNew = ImmLocalAlloc(0, sizeof(LOGFONTW));
            }
            if (lpNew == NULL) {
                RIPMSG0(RIP_WARNING, "ImmRequestMessageWorker: IMR_COMPOSITIONFONT: failed to allocate memory for A/W conversion.");
                return 0L;
            }
        }
        break;

    case IMR_QUERYCHARPOSITION:
        UserAssert(lpReq != NULL);
        if (bAnsiOrigin != bAnsiTarget) {
#define lpIMEPOS    ((LPIMECHARPOSITION)lParam)
            LPVOID lpstr;
            DWORD dwLen;

            dwSaveCharPos = lpIMEPOS->dwCharPos;

            dwLen = (!bAnsiOrigin ? ImmGetCompositionStringW : ImmGetCompositionStringA)(hIMC, GCS_COMPSTR, 0, 0);
            if (dwLen == 0) {
                RIPMSG0(RIP_WARNING, "ImmRequestMessageWorker: IMR_QUERYCHARPOSITION no compositiong string.");
                return 0L;
            }

            lpstr = ImmLocalAlloc(0, (dwLen + 1) * (!bAnsiOrigin ? sizeof(WCHAR) : sizeof(CHAR)));
            if (lpstr == NULL) {
                RIPMSG0(RIP_WARNING, "ImmRequestMessageWorker: IMR_QUERYCHARPOSITION: failed to allocate memory for A/W conversion.");
                return 0L;
            }

            (!bAnsiOrigin ? ImmGetCompositionStringW : ImmGetCompositionStringA)(hIMC, GCS_COMPSTR, lpstr, dwLen);
            if (bAnsiTarget) {
                lpIMEPOS->dwCharPos = CalcCharacterPositionWtoA(lpIMEPOS->dwCharPos, lpstr, dwCodePage);
            } else {
                lpIMEPOS->dwCharPos = CalcCharacterPositionAtoW(lpIMEPOS->dwCharPos, lpstr, dwCodePage);
            }

            ImmLocalFree(lpstr);
        }
        break;

    default:
        UserAssert(lpReq != NULL);      // has been checked so far
        break;
    }

    if (lpNew) {
        // if we allocated the buffer, let lpReq point it; lpNew is used later to free memory
        lpReq = lpNew;
    }

    //////////////////////////////////
    lRet = SEND_MESSAGE(bAnsiTarget)(HW(pwnd), WM_IME_REQUEST, wParam, (LPARAM)lpReq);
    //////////////////////////////////

    // copy back the results from WinProc to IME's buffer (only if conversion is needed)
    if (bAnsiOrigin != bAnsiTarget) {
        switch (wParam) {
        case IMR_RECONVERTSTRING:
        case IMR_DOCUMENTFEED:
            // Note: by definition, we don't have to do back-conversion for IMR_CONFIRMRECONVERTSTRING
            if (lRet != 0) {
                // IME wants the buffer size
                lRet = ImmGetReconvertTotalSize((DWORD)lRet, FROM_APP, bAnsiTarget);
                if (lRet < sizeof(RECONVERTSTRING)) {
                    RIPMSG1(RIP_WARNING, "ImmRequestMessageWorker: return value from application %d is invalid.", lRet);
                    lRet = 0;
                } else if (lpReq) {
                    // We need to perform the A/W conversion of the contents
                    if (!ImmReconversionWorker((LPRECONVERTSTRING)lParam, (LPRECONVERTSTRING)lpReq, bAnsiOrigin, dwCodePage)) {
                        lRet = 0;   // Error !
                    }
                }
            }
            break;
        case IMR_COMPOSITIONFONT:
            if (bAnsiOrigin) {
                LFontWtoLFontA((LPLOGFONTW)lpNew, (LPLOGFONTA)lParam);
            } else {
                LFontAtoLFontW((LPLOGFONTA)lpNew, (LPLOGFONTW)lParam);
            }
            break;
        case IMR_QUERYCHARPOSITION:
            UserAssert((LPVOID)lParam != NULL);
            lpIMEPOS->dwCharPos = dwSaveCharPos;
    #undef lpIMEPOS
            break;
        default:
            break;
        }

    }
    if (lpNew) {
        // buffer has been allocated, free it before returning
        ImmLocalFree(lpNew);
    }
    return lRet;
}

/**************************************************************************\
* ImmRequestMessage: Send WM_IME_REQUEST message to the given HIMC window
*
* IME function
*
* 27-Feb-1997 hiroyama      Created
\**************************************************************************/
LRESULT ImmRequestMessageAorW(HIMC hIMC, WPARAM wParam, LPARAM lParam, BOOL bAnsiOrigin)
{
    LPINPUTCONTEXT lpInputContext;
    PWND pwnd;
    LRESULT lRet = 0L;
    DWORD dwThreadId = GetInputContextThread(hIMC);

    if (dwThreadId != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmRequestMessageAorW:: Invalid input context access %lx.", hIMC);
        return lRet;
    }

    if (hIMC == NULL || (lpInputContext = ImmLockIMC(hIMC)) == NULL) {
        RIPMSG1(RIP_WARNING, "ImmRequestMessage: Invalid hImc %lx.", hIMC);
        return 0L;
    }

    // check if the window of the input context is valid
    if ((pwnd = ValidateHwnd(lpInputContext->hWnd)) == NULL) {
        RIPMSG1(RIP_WARNING, "ImmRequestMessage: Invalid hWnd %lx.", lpInputContext->hWnd);
    } else {
        // check if the message is being sent inter thread
        if (PtiCurrent() != GETPTI(pwnd)) {
            RIPMSG0(RIP_WARNING, "ImmRequestMessage: IME Attempt to send IMR_ message to different thread.");
        } else {
            lRet = ImmRequestMessageWorker(hIMC, pwnd, wParam, lParam, bAnsiOrigin);
        }
    }

    ImmUnlockIMC(hIMC);

    return lRet;
}

LRESULT WINAPI ImmRequestMessageA(HIMC hIMC, WPARAM wParam, LPARAM lParam)
{
    return ImmRequestMessageAorW(hIMC, wParam, lParam, TRUE /* ANSI */);
}

LRESULT WINAPI ImmRequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam)
{
    return ImmRequestMessageAorW(hIMC, wParam, lParam, FALSE /* not ANSI */);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\hotkey.c ===
/**************************************************************************\
* Module Name: hotkey.c (corresponds to Win95 hotkey.c)
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* IME hot key management routines for imm32 dll
*
* History:
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop



//
// internal functions
//
BOOL CIMENonIMEToggle(HIMC hIMC, HKL hKL, HWND hWnd, LANGID langTarget);
BOOL IMENonIMEToggle( HIMC hIMC, HKL hKL, HWND hWnd, BOOL fIME, LANGID langTarget);
BOOL JCloseOpen( HIMC hIMC, HKL hKL, HWND hWnd);
BOOL CSymbolToggle(HIMC hIMC, HKL hKL, HWND hWnd);
BOOL TShapeToggle(HIMC hIMC, HKL hKL, HWND hWnd);
BOOL KEnglishHangul( HIMC hIMC);
BOOL KShapeToggle( HIMC hIMC);
BOOL KHanjaConvert( HIMC hIMC);


/***************************************************************************\
* ImmGetHotKey()
*
* Private API for IMEs and the control panel. The caller specifies
* the IME hotkey ID:dwID. If a hotkey is registered with the specified
* ID, this function returns the modifiers, vkey and hkl of the hotkey.
*
* History:
* 25-Mar-1996 TakaoK       Created
\***************************************************************************/
BOOL WINAPI ImmGetHotKey(
    DWORD dwID,
    PUINT puModifiers,
    PUINT puVKey,
    HKL   *phkl)
{
    if (puModifiers == NULL || puVKey == NULL) {
        return FALSE;
    }
    return NtUserGetImeHotKey( dwID, puModifiers, puVKey, phkl );
}

/**********************************************************************/
/* ImmSimulateHotKey()                                                */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImmSimulateHotKey(  // simulate the functionality of that hot key
    HWND  hAppWnd,              // application window handle
    DWORD dwHotKeyID)
{
    HIMC hImc;
    HKL  hKL;
    BOOL fReturn;

    hImc = ImmGetContext( hAppWnd );
    hKL = GetKeyboardLayout( GetWindowThreadProcessId(hAppWnd, NULL) );
    fReturn = HotKeyIDDispatcher( hAppWnd, hImc, hKL, dwHotKeyID);
    ImmReleaseContext( hAppWnd, hImc );
    return fReturn;
}


/***************************************************************************\
* SaveImeHotKey()
*
*  Put/Remove the specified IME hotkey entry from the registry
*
* History:
* 25-Mar-1996 TakaoK       Created
\***************************************************************************/

/**********************************************************************/
/* HotKeyIDDispatcher                                                 */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL HotKeyIDDispatcher( HWND hWnd, HIMC hImc, HKL hKlCurrent, DWORD dwHotKeyID )
{
    /*
     * Dispatch the IME hotkey event for the specified hImc
     * only if the calling thread owns the hImc.
     */
    if (hImc != NULL_HIMC &&
            GetInputContextThread(hImc) != GetCurrentThreadId()) {
        return FALSE;
    }

    switch ( dwHotKeyID ) {
    case IME_CHOTKEY_IME_NONIME_TOGGLE:
        return CIMENonIMEToggle(hImc, hKlCurrent, hWnd, MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED));

    case IME_THOTKEY_IME_NONIME_TOGGLE:
        return CIMENonIMEToggle(hImc, hKlCurrent, hWnd, MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL));

    case IME_CHOTKEY_SYMBOL_TOGGLE:
    case IME_THOTKEY_SYMBOL_TOGGLE:
        return CSymbolToggle( hImc, hKlCurrent, hWnd);

    case IME_JHOTKEY_CLOSE_OPEN:
        return JCloseOpen( hImc, hKlCurrent, hWnd);

    case IME_KHOTKEY_ENGLISH:           // VK_HANGUL : English/Hangul mode
        return KEnglishHangul( hImc );

    case IME_KHOTKEY_SHAPE_TOGGLE:      // VK_JUNJA : full/half width
        return KShapeToggle( hImc );

    case IME_KHOTKEY_HANJACONVERT:      // VK_HANJA : convert hangul to hanja
        return KHanjaConvert( hImc );

    case IME_CHOTKEY_SHAPE_TOGGLE:
    case IME_THOTKEY_SHAPE_TOGGLE:
        return TShapeToggle( hImc, hKlCurrent, hWnd);

    default:
        /*
         * Direct swithing hotkey should have been handled in the kernel side.
         */
        ImmAssert(dwHotKeyID < IME_HOTKEY_DSWITCH_FIRST || dwHotKeyID > IME_HOTKEY_DSWITCH_LAST);

        if ( dwHotKeyID >= IME_HOTKEY_PRIVATE_FIRST &&
                    dwHotKeyID <= IME_HOTKEY_PRIVATE_LAST ) {

            PIMEDPI pImeDpi;
            BOOL    bRet = FALSE;

            if ( (pImeDpi = ImmLockImeDpi(hKlCurrent)) != NULL ) {

                bRet = (BOOL)(*pImeDpi->pfn.ImeEscape)( hImc,
                                                  IME_ESC_PRIVATE_HOTKEY,
                                                  (PVOID)&dwHotKeyID );
                ImmUnlockImeDpi(pImeDpi);
                return bRet;
            }
        }
    }
    return (FALSE);
}

/**********************************************************************/
/* JCloseOpen()                                                       */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL JCloseOpen(         // open/close toggle
    HIMC        hIMC,
    HKL         hCurrentKL,
    HWND        hWnd)
{

    if (ImmIsIME(hCurrentKL) &&
            LOWORD(HandleToUlong(hCurrentKL)) == MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT)) {
        //
        // If current KL is IME and its language is Japanese,
        // we only have to switch the open/close status.
        //
        ImmSetOpenStatus( hIMC, !ImmGetOpenStatus(hIMC) );
    } else {
        //
        // If current KL is not IME or its language is not Japanese,
        // we should find the Japanese IME and set it open.
        //
        if (IMENonIMEToggle(hIMC, hCurrentKL, hWnd, FALSE, MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT))) {
            //
            // Mark it so that later we can initialize the fOpen
            // as expected.
            //
            PINPUTCONTEXT pInputContext = ImmLockIMC(hIMC);

            if (pInputContext) {
                pInputContext->fdwDirty |= IMSS_INIT_OPEN;
                ImmUnlockIMC(hIMC);
            }
        }
    }
    return TRUE;

#if 0   // for your reference : old code ported from Win95
    LPINPUTCONTEXT pInputContext;
    PIMEDPI            pImeDpi;


    if ( (pInputContext = ImmLockIMC( hIMC )) == NULL ) {
    //
    // The return value is same as Win95.
    // Not happens so often any way.
    //
        return TRUE;
    }

    pImeDpi = ImmLockImeDpi( hCurrentKL );
    if ( pImeDpi != NULL ) {
    //
    // update Input Context
    //
        pInputContext->fOpen = !pInputContext->fOpen;

    //
    // notify IME
    //
        (*pImeDpi->pfn.NotifyIME)( hIMC,
                                   NI_CONTEXTUPDATED,
                                   0L,
                                   IMC_SETOPENSTATUS );
    //
    // inform UI
    //
        SendMessage(hWnd, WM_IME_NOTIFY, IMN_SETOPENSTATUS, 0L);
        SendMessage(hWnd, WM_IME_SYSTEM, IMS_SETOPENSTATUS, 0L);

        ImmUnlockIMC( hIMC );
        ImmUnlockImeDpi(pImeDpi);
        return TRUE;

    } else {

        if ( !pInputContext->fOpen ) {
            pInputContext->fOpen = TRUE;
            SendMessage(hWnd, WM_IME_NOTIFY, IMN_SETOPENSTATUS, 0L);
            SendMessage(hWnd, WM_IME_SYSTEM, IMS_SETOPENSTATUS, 0L);
        }
        ImmUnlockIMC( hIMC );

        return IMENonIMEToggle(hIMC, hCurrentKL, hWnd, FALSE);
    }
#endif
}

/***************************************************************************\
* HotkeyImmIsIME
*
* Checks whether the specified hKL is a HKL of an IME or not.
*
\***************************************************************************/

BOOL HotkeyImmIsIME(
    HKL hKL)
{
#if defined(CUAS_ENABLE)
    if (!IS_IME_KBDLAYOUT(hKL))
        return FALSE;
#else
    if (!ImmIsIME(hKL))
        return FALSE;
#endif

    return TRUE;
}

/**********************************************************************/
/* CIMENonIMEToggle()                                                 */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL CIMENonIMEToggle(   // non-IME and IME toggle
    HIMC        hIMC,
    HKL         hKlCurrent,
    HWND        hWnd,
    LANGID      langId)
{
    if (hWnd == NULL)
        return(FALSE);

    if (!HotkeyImmIsIME(hKlCurrent) || LOWORD(HandleToUlong(hKlCurrent)) != langId) 
    {
        //
        // Current keyboard layout is not IME or its language does not match.
        // Let's try to switch to our IME.
        //
        IMENonIMEToggle(hIMC, hKlCurrent, hWnd, FALSE, langId);
        return TRUE;

    } else {

        LPINPUTCONTEXT pInputContext = ImmLockIMC( hIMC );

        if ( pInputContext == NULL ) {
            //
            // returning TRUE even if we didn't change
            //
            return TRUE;
        }
        if (!pInputContext->fOpen) {
            //
            // toggle close to open
            //
            ImmSetOpenStatus(hIMC, TRUE);
            ImmUnlockIMC(hIMC);
            return TRUE;
        } else {
            ImmUnlockIMC(hIMC);
            IMENonIMEToggle(hIMC, hKlCurrent, hWnd, TRUE, 0);
            return TRUE;
        }
    }
}

/**********************************************************************/
/* IMENonIMEToggle()                                                  */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL IMENonIMEToggle(
    HIMC        hIMC,
    HKL         hCurrentKL,
    HWND        hWnd,
    BOOL        fCurrentIsIME,
    LANGID      langTarget)
{
    HKL  hEnumKL[32], hTargetKL;
    UINT nLayouts, i;
    HKL hPrevKL;

    UNREFERENCED_PARAMETER(hIMC);

    hPrevKL = (HKL)NtUserGetThreadState( UserThreadStatePreviousKeyboardLayout );

    //
    // If we find the same layout in the layout list, let's switch to
    // the layout. If we fail, let's switch to a first-found good
    // layout.
    //

    hTargetKL = NULL;
    nLayouts = GetKeyboardLayoutList(sizeof(hEnumKL)/sizeof(HKL), hEnumKL);

    // LATER:
    // Hmm, looks like we can't simply rely on hPrevKL on multiple lanugage
    // environment..
    //
    if (hPrevKL != NULL) {
        if (langTarget == 0 || LOWORD(HandleToUlong(hPrevKL)) == langTarget) {
            //
            // If langtarget is not specified, or
            // if it matches the previous langauge.
            //
            for (i = 0; i < nLayouts; i++) {
                // valid target HKL
                if (hEnumKL[i] == hPrevKL) {
                    hTargetKL = hPrevKL;
                    break;
                }
            }
        }
    }
    if (hTargetKL == NULL) {
        for (i = 0; i < nLayouts; i++) {
            // find a valid target HKL
            if (fCurrentIsIME ^ HotkeyImmIsIME(hEnumKL[i])) {
                if (langTarget != 0 && LOWORD(HandleToUlong(hEnumKL[i])) != langTarget) {
                    // If the target language is specified, check it
                    continue;
                }
                hTargetKL = hEnumKL[i];
                break;
            }
        }
    }
    if (hTargetKL != NULL && hCurrentKL != hTargetKL) {

        // depends on multilingual message and how to get the base charset
        // wait for confirmation of multiingual spec - tmp solution
        PostMessage(hWnd, WM_INPUTLANGCHANGEREQUEST, DEFAULT_CHARSET, (LPARAM)hTargetKL);
    }
    //
    // returning TRUE, even if we failed to switch
    //
    return HotkeyImmIsIME(hTargetKL);
}

/**********************************************************************/
/* CSymbolToggle()                                                    */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL CSymbolToggle(              // symbol & non symbol toggle
    HIMC        hIMC,
    HKL         hKL,
    HWND        hWnd)
{
    LPINPUTCONTEXT pInputContext;

    //
    // Return TRUE even no layout switching - Win95 behavior
    //
    if (hWnd == NULL)
        return(FALSE);

    if ( ! HotkeyImmIsIME( hKL ) ) {
        return (FALSE);
    }

    if ( (pInputContext = ImmLockIMC( hIMC )) == NULL ) {
        //
        // The return value is same as Win95.
        // Not happens so often any way.
        //
        return TRUE;
    }

    if (pInputContext->fOpen) {
        //
        // toggle the symbol mode
        //
        ImmSetConversionStatus(hIMC,
                               pInputContext->fdwConversion ^ IME_CMODE_SYMBOL,
                               pInputContext->fdwSentence);
    }
    else {
        //
        // change close -> open
        //
        ImmSetOpenStatus(hIMC, TRUE);
    }

    ImmUnlockIMC(hIMC);
    return (TRUE);

}

/**********************************************************************/
/* TShapeToggle()                                                     */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL TShapeToggle(               // fullshape & halfshape toggle
    HIMC        hIMC,
    HKL         hKL,
    HWND        hWnd)
{
    LPINPUTCONTEXT pInputContext;

    //
    // Return TRUE even no layout switching - Win95 behavior
    //
    if (hWnd == NULL)
        return(FALSE);

    if ( ! HotkeyImmIsIME( hKL ) ) {
        return (FALSE);
    }

    if ( (pInputContext = ImmLockIMC( hIMC )) == NULL ) {
        //
        // The return value is same as Win95.
        // Not happens so often any way.
        //
        return TRUE;
    }

    if (pInputContext->fOpen) {
        //
        // toggle the symbol mode
        //
        ImmSetConversionStatus(hIMC,
                               pInputContext->fdwConversion ^ IME_CMODE_FULLSHAPE,
                               pInputContext->fdwSentence);
    }
    else {
        //
        // change close -> open
        //
        ImmSetOpenStatus(hIMC, TRUE);
    }

    ImmUnlockIMC(hIMC);
    return (TRUE);
}

/**********************************************************************/
/* KEnglishHangul() - Egnlish & Hangeul toggle                       */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL KEnglishHangul( HIMC hImc )
{
    PINPUTCONTEXT pInputContext;

    if ((pInputContext = ImmLockIMC(hImc)) != NULL) {

        ImmSetConversionStatus(hImc,
                pInputContext->fdwConversion ^ IME_CMODE_HANGEUL,
                pInputContext->fdwSentence);

        if ((pInputContext->fdwConversion & IME_CMODE_HANGEUL) ||
                (pInputContext->fdwConversion & IME_CMODE_FULLSHAPE)) {
            ImmSetOpenStatus(hImc, TRUE);
        } else {
            ImmSetOpenStatus(hImc, FALSE);
        }
        ImmUnlockIMC(hImc);
        return TRUE;
    }

    return FALSE;
}

/**********************************************************************/
/* KShapeToggle() - Fullshape & Halfshape toggle                      */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL KShapeToggle( HIMC hImc )
{
    PINPUTCONTEXT pInputContext;

    if ( (pInputContext = ImmLockIMC( hImc )) != NULL ) {

        ImmSetConversionStatus(hImc,
            pInputContext->fdwConversion ^ IME_CMODE_FULLSHAPE,
            pInputContext->fdwSentence);

        if ((pInputContext->fdwConversion & IME_CMODE_HANGEUL)
                || (pInputContext->fdwConversion & IME_CMODE_FULLSHAPE))
            ImmSetOpenStatus(hImc, TRUE);
        else
            ImmSetOpenStatus(hImc, FALSE);
        ImmUnlockIMC(hImc);
        return TRUE;
    }

    return FALSE;
}

/**********************************************************************/
/* KHanjaConvert() - Hanja conversion toggle                          */
/* Return Value:                                                      */
/*      TRUE - a hot key processed, FALSE - not processed             */
/**********************************************************************/
BOOL KHanjaConvert( HIMC hImc )
{
    PINPUTCONTEXT pInputContext;

    if ( (pInputContext = ImmLockIMC( hImc )) != NULL ) {

        ImmSetConversionStatus( hImc,
                                pInputContext->fdwConversion ^ IME_CMODE_HANJACONVERT,
                                pInputContext->fdwSentence );

        ImmUnlockIMC( hImc );
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\immime.c ===
/**************************************************************************\
* Module Name: immime.c (corresponds to Win95 ime.c)
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* IME DLL related functinality
*
* History:
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

typedef struct tagSELECTCONTEXT_ENUM {
    HKL hSelKL;
    HKL hUnSelKL;
} SCE, *PSCE;


BOOL NotifyIMEProc(
    HIMC hImc,
    LPARAM lParam)
{
    UserAssert(lParam == CPS_COMPLETE || lParam == CPS_CANCEL);
    ImmNotifyIME(hImc, NI_COMPOSITIONSTR, (DWORD)lParam, 0);
    return TRUE;
}


BOOL SelectContextProc(
    HIMC hImc,
    PSCE psce)
{
    SelectInputContext(psce->hSelKL, psce->hUnSelKL, hImc);
    return TRUE;
}


BOOL InquireIme(
    PIMEDPI pImeDpi)
{
    WNDCLASS    wc;
    BYTE        ClassName[IM_UI_CLASS_SIZE * sizeof(WCHAR)];
    DWORD       dwSystemInfoFlags;
    PIMEINFO    pImeInfo = &pImeDpi->ImeInfo;

    /*
     * Check if this process requires the security.
     * Adding to the pid check, the current desktop check is required,
     * for there are applications run on the secure desktop.
     */
    dwSystemInfoFlags = (NtUserGetThreadState(UserThreadStateNeedsSecurity) ? IME_SYSINFO_WINLOGON : 0);

    if (GetClientInfo()->dwTIFlags & TIF_16BIT)
        dwSystemInfoFlags |= IME_SYSINFO_WOW16;

#if !defined(CUAS_ENABLE)
    (*pImeDpi->pfn.ImeInquire.w)(pImeInfo, (PVOID)ClassName, dwSystemInfoFlags);
#else
    if (! IS_IME_KBDLAYOUT(pImeDpi->hKL) && IS_CICERO_ENABLED_AND_NOT16BIT()) {
        if ((*pImeDpi->pfn.CtfImeInquireExW)(pImeInfo, (PVOID)ClassName, dwSystemInfoFlags, pImeDpi->hKL) == S_OK)
        {
        }
        else
        {
            RIPMSG0(RIP_WARNING, "InquireIme: pImeDpi->pfn.ImeInquireExW failed");
            return FALSE;
        }
    }
    else {
        (*pImeDpi->pfn.ImeInquire.w)(pImeInfo, (PVOID)ClassName, dwSystemInfoFlags);
    }
#endif

    /*
     * parameter checking for each fields.
     */
    if (pImeInfo->dwPrivateDataSize == 0)
        pImeInfo->dwPrivateDataSize = sizeof(UINT);

    if (pImeInfo->fdwProperty & ~(IME_PROP_ALL)) {
        RIPMSG0(RIP_WARNING, "wrong property");
        return FALSE;
    }

    if (pImeInfo->fdwConversionCaps & ~(IME_CMODE_ALL)) {
        RIPMSG0(RIP_WARNING, "wrong conversion capabilities");
        return FALSE;
    }

    if (pImeInfo->fdwSentenceCaps & ~(IME_SMODE_ALL)) {
        RIPMSG0(RIP_WARNING, "wrong sentence capabilities");
        return FALSE;
    }

    if (pImeInfo->fdwUICaps & ~(UI_CAP_ALL)) {
        RIPMSG0(RIP_WARNING, "wrong UI capabilities");
        return FALSE;
    }

    if (pImeInfo->fdwSCSCaps & ~(SCS_CAP_ALL)) {
        RIPMSG0(RIP_WARNING, "wrong set comp string capabilities");
        return FALSE;
    }

    if (pImeInfo->fdwSelectCaps & ~(SELECT_CAP_ALL)) {
        RIPMSG0(RIP_WARNING, "wrong select capabilities");
        return FALSE;
    }

    if (!(pImeInfo->fdwProperty & IME_PROP_UNICODE)) {

        /*
         * This is ANSI IME. Ensure that it is usable under current system
         * codepage.
         */
        if (pImeDpi->dwCodePage != GetACP() && pImeDpi->dwCodePage != CP_ACP) {
            // Note: in the future, if possible, these reference to dwCodepage
            // should be IMECodePage()...
            RIPMSG1(RIP_WARNING, "incompatible codepage(%d) for ANSI IME", pImeDpi->dwCodePage);
            return FALSE;
        }

        /*
         * ANSI -> Unicode Class name.
         */
        MultiByteToWideChar(IMECodePage(pImeDpi),
                            (DWORD)MB_PRECOMPOSED,
                            (LPSTR)ClassName,               // src
                            (INT)-1,
                            pImeDpi->wszUIClass,            // dest
                            IM_UI_CLASS_SIZE);
    } else {
        RtlCopyMemory(pImeDpi->wszUIClass, ClassName, sizeof(ClassName));
    }
    pImeDpi->wszUIClass[IM_UI_CLASS_SIZE-1] = L'\0';

    if (!GetClassInfoW((HINSTANCE)pImeDpi->hInst, pImeDpi->wszUIClass, &wc)) {
        RIPMSG1(RIP_WARNING, "UI class (%ws) not found in this IME", pImeDpi->wszUIClass);
        return FALSE;
    } else if (wc.cbWndExtra < sizeof(DWORD) * 2) {
        RIPMSG0(RIP_WARNING, "UI class cbWndExtra problem");
        return FALSE;
    }

    return TRUE;
}

BOOL CheckAndApplyAppCompat(LPWSTR wszImeFile)
{
    DWORD dwReason;
    HMODULE hAppHelp;
    typedef BOOL (*PFNApphelpCheckIME)(
        IN  LPCWSTR     pwszPath            // Unicode path to the executable (DOS_PATH)
        );
    PFNApphelpCheckIME pfnAppHelpCheckIME;
    BOOL    bRunIME = TRUE;
    //
    // tentative prototype (find out a semi-public header to include! [and a lib too])
    //
    BOOL
    WINAPI
    BaseCheckAppcompatCache(
        LPCWSTR pwszPath,
        HANDLE  hFile,
        PVOID   pEnvironment,
        DWORD*  dwReason
        );

    //
    // Assuming most of IMEs are just fine, not needing
    // Shim's help, let's check the good guy cache first
    // so that the overhead should be minimum. This API
    // is meant to be really light weight.
    //
    if (BaseCheckAppcompatCache(wszImeFile, INVALID_HANDLE_VALUE, NULL, &dwReason)) {
        // This IME is in the good guy cache. Just bail out quietly.
        return bRunIME;
    }

    // What's a good use of dwReason?

    RIPMSG1(RIP_VERBOSE, "Shim'ing this IME='%ls'", wszImeFile);

    //
    // Call the real Shim helper for this IME.
    //
    hAppHelp = GetModuleHandleW(L"apphelp.dll");
    if (hAppHelp == NULL) {
        hAppHelp = LoadLibraryW(L"apphelp.dll");
        if (hAppHelp == NULL) {
            // Failed to load apphelp.dll.
            // We have no other choice than bailing out.
            RIPMSG0(RIP_WARNING, "CheckAndApplyAppCompat: failed to load apphelp.dll");
            return bRunIME;
        }
    }
    UserAssert(hAppHelp);

    pfnAppHelpCheckIME = (PFNApphelpCheckIME)GetProcAddress(hAppHelp, "ApphelpCheckIME");
    if (pfnAppHelpCheckIME == NULL) {
        RIPMSG0(RIP_WARNING, "CheckAndApplyAppCompat: failed to getproc ApphelpCheckIME");
        return bRunIME;
    }

    //
    // return result has no meaning for this ca
    //
    bRunIME =  pfnAppHelpCheckIME(wszImeFile);

    return bRunIME;
}

BOOL LoadIME(
    PIMEINFOEX piiex,
    PIMEDPI    pImeDpi)
{
    WCHAR wszImeFile[MAX_PATH];
    BOOL  fSuccess;

    GetSystemPathName(wszImeFile, piiex->wszImeFile, MAX_PATH);

    if (!CheckAndApplyAppCompat(wszImeFile)) {
        RIPMSG1(RIP_WARNING, "LoadIME: IME (%ws) blocked by appcompat", wszImeFile);
        goto LoadIME_ErrOut;
    }

    pImeDpi->hInst = LoadLibraryW(wszImeFile);

    if (!pImeDpi->hInst) {
        RIPMSG1(RIP_WARNING, "LoadIME: LoadLibraryW(%ws) failed", wszImeFile);
        goto LoadIME_ErrOut;
    }

#define GET_IMEPROCT(x) \
    if (!(pImeDpi->pfn.##x.t = (PVOID) GetProcAddress(pImeDpi->hInst, #x))) { \
        RIPMSG1(RIP_WARNING, "LoadIME: " #x " not supported in %ws", wszImeFile);           \
        goto LoadIME_ErrOut; }

#define GET_IMEPROC(x) \
    if (!(pImeDpi->pfn.##x = (PVOID) GetProcAddress(pImeDpi->hInst, #x))) {   \
        RIPMSG1(RIP_WARNING, "LoadIME: " #x " not supported in %ws", wszImeFile);           \
        goto LoadIME_ErrOut; }

    GET_IMEPROCT(ImeInquire);
    GET_IMEPROCT(ImeConversionList);
    GET_IMEPROCT(ImeRegisterWord);
    GET_IMEPROCT(ImeUnregisterWord);
    GET_IMEPROCT(ImeGetRegisterWordStyle);
    GET_IMEPROCT(ImeEnumRegisterWord);
    GET_IMEPROC (ImeConfigure);
    GET_IMEPROC (ImeDestroy);
    GET_IMEPROC (ImeEscape);
    GET_IMEPROC (ImeProcessKey);
    GET_IMEPROC (ImeSelect);
    GET_IMEPROC (ImeSetActiveContext);
    GET_IMEPROC (ImeToAsciiEx);
    GET_IMEPROC (NotifyIME);
    GET_IMEPROC (ImeSetCompositionString);

    // 4.0 IMEs don't have this entry. could be NULL.
    pImeDpi->pfn.ImeGetImeMenuItems = (PVOID)GetProcAddress(pImeDpi->hInst, "ImeGetImeMenuItems");

#ifdef CUAS_ENABLE
    //
    // Cicero IME
    //
    if (! IS_IME_KBDLAYOUT(pImeDpi->hKL) && IS_CICERO_ENABLED_AND_NOT16BIT()) {
        GET_IMEPROC (CtfImeInquireExW);
        GET_IMEPROC (CtfImeSelectEx);
        GET_IMEPROC (CtfImeEscapeEx);
        GET_IMEPROC (CtfImeGetGuidAtom);
        GET_IMEPROC (CtfImeIsGuidMapEnable);
    }
#endif // CUAS_ENABLE

#undef GET_IMEPROCT
#undef GET_IMEPROC

    if (!InquireIme(pImeDpi)) {
        RIPMSG0(RIP_WARNING, "LoadIME: InquireIme failed");
LoadIME_ErrOut:
        FreeLibrary(pImeDpi->hInst);
        pImeDpi->hInst = NULL;
        fSuccess = FALSE;
    }
    else {
        fSuccess = TRUE;
    }

    /*
     * Update kernel side IMEINFOEX for this keyboard layout if
     * this is its first loading.
     */
    if (piiex->fLoadFlag == IMEF_NONLOAD) {
        if (fSuccess) {
            RtlCopyMemory((PBYTE)&piiex->ImeInfo,
                          (PBYTE)&pImeDpi->ImeInfo, sizeof(IMEINFO));
            RtlCopyMemory((PBYTE)piiex->wszUIClass,
                          (PBYTE)pImeDpi->wszUIClass, sizeof(pImeDpi->wszUIClass));
            piiex->fLoadFlag = IMEF_LOADED;
        }
        else {
            piiex->fLoadFlag = IMEF_LOADERROR;
            RIPMSG1(RIP_WARNING, "LoadIME: hKL=%lx piiex->fLoadFlag = IMEF_LOADERROR", piiex->hkl);
        }
        NtUserSetImeInfoEx(piiex);
    }

    return fSuccess;
}


VOID UnloadIME(
    PIMEDPI pImeDpi,
    BOOL    fTerminateIme)
{
    if (pImeDpi->hInst == NULL) {
        RIPMSG0(RIP_WARNING, "UnloadIME: No IME's hInst.");
        return;
    }

    if (fTerminateIme) {
        /*
         * Destroy IME first.
         */
        (*pImeDpi->pfn.ImeDestroy)(0);
    }

    FreeLibrary(pImeDpi->hInst);
    pImeDpi->hInst = NULL;

    return;
}

PIMEDPI LoadImeDpi(
    HKL  hKL,
    BOOL fLock)
{
    PIMEDPI        pImeDpi, pImeDpiT;
    IMEINFOEX      iiex;

    /*
     * Query the IME information.
     */
    if (!ImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayout, &hKL)) {
        RIPMSG1(RIP_WARNING, "LoadImeDpi: ImmGetImeInfoEx(%lx) failed", hKL);
        return NULL;
    }

    /*
     * Win95 behaviour: If there was an IME load error for this layout,
     * further attempt to load the same IME layout will be rejected.
     */
    if (iiex.fLoadFlag == IMEF_LOADERROR)
    {
        RIPMSG1(RIP_WARNING, "LoadImeDpi: hKL=%lx iiex.fLoadFlag = IMEF_LOADERROR", iiex.hkl);
        return NULL;
    }

    /*
     * Allocate a new IMEDPI for this layout.
     */
    pImeDpi = (PIMEDPI)ImmLocalAlloc(HEAP_ZERO_MEMORY, sizeof(IMEDPI));
    if (pImeDpi == NULL)
        return NULL;

    pImeDpi->hKL = hKL;

    // get code page of IME
    {
        CHARSETINFO cs;
        if (TranslateCharsetInfo((DWORD*)LOWORD(HandleToUlong(hKL)), &cs, TCI_SRCLOCALE)) {
            pImeDpi->dwCodePage = cs.ciACP;
        }
        else {
            pImeDpi->dwCodePage = CP_ACP;
        }
    }

    /*
     * Load up IME DLL.
     */
    if (!LoadIME(&iiex, pImeDpi)) {
        ImmLocalFree(pImeDpi);
        return NULL;
    }

    /*
     * Link in the newly allocated entry.
     */
    RtlEnterCriticalSection(&gcsImeDpi);

    pImeDpiT = ImmGetImeDpi(hKL);

    if (pImeDpiT == NULL) {
        if (fLock) {
            /*
             * Newly loaded with lock, will unload upon unlock.
             */
            pImeDpi->cLock = 1;
            pImeDpi->dwFlag |= IMEDPI_UNLOCKUNLOAD;
        }

        /*
         * Update the global list for this new pImeDpi entry.
         */
        pImeDpi->pNext = gpImeDpi;
        gpImeDpi = pImeDpi;

        RtlLeaveCriticalSection(&gcsImeDpi);
    }
    else {

        if (!fLock) {
            pImeDpiT->dwFlag &= ~IMEDPI_UNLOCKUNLOAD;
        }

        /*
         * The same IME has been loaded, discard this extra entry.
         */
        RtlLeaveCriticalSection(&gcsImeDpi);
        UnloadIME(pImeDpi, FALSE);
        ImmLocalFree(pImeDpi);
        pImeDpi = pImeDpiT;
    }

    return pImeDpi;
}


PIMEDPI FindOrLoadImeDpi(
    HKL  hKL)
{
    PIMEDPI pImeDpi;

    /*
     * Non IME based keyboard layout doesn't have IMEDPI.
     */
#if !defined(CUAS_ENABLE)
    if (!IS_IME_KBDLAYOUT(hKL))
        return (PIMEDPI)NULL;
#else
    if (! IS_IME_KBDLAYOUT(hKL) && ! IS_CICERO_ENABLED_AND_NOT16BIT())
        return (PIMEDPI)NULL;
#endif

    pImeDpi = ImmLockImeDpi(hKL);
    if (pImeDpi == NULL)
        pImeDpi = LoadImeDpi(hKL, TRUE);

    return pImeDpi;
}


BOOL WINAPI ImmLoadIME(
    HKL hKL)
{
    PIMEDPI pImeDpi;

    /*
     * Non IME based keyboard layout doesn't have IMEDPI.
     */
#if !defined(CUAS_ENABLE)
    if (!IS_IME_KBDLAYOUT(hKL))
        return FALSE;
#else
    if (! IS_IME_KBDLAYOUT(hKL) && ! IS_CICERO_ENABLED_AND_NOT16BIT())
        return FALSE;
#endif

    pImeDpi = ImmGetImeDpi(hKL);
    if (pImeDpi == NULL)
        pImeDpi = LoadImeDpi(hKL, FALSE);

    return (pImeDpi != NULL);
}


BOOL WINAPI ImmUnloadIME(
    HKL hKL)
{
    PIMEDPI pImeDpi, pImeDpiT;

    RtlEnterCriticalSection(&gcsImeDpi);

    pImeDpi = gpImeDpi;

    while (pImeDpi != NULL && pImeDpi->hKL != hKL)
        pImeDpi = pImeDpi->pNext;

    if (pImeDpi == NULL) {
        RtlLeaveCriticalSection(&gcsImeDpi);
        return TRUE;
    }
    else if (pImeDpi->cLock != 0) {
        pImeDpi->dwFlag |= IMEDPI_UNLOADED;
        RtlLeaveCriticalSection(&gcsImeDpi);
        return FALSE;
    }

    /*
     * Unlink it.
     */
    if (gpImeDpi == pImeDpi) {
        gpImeDpi = pImeDpi->pNext;
    }
    else {
        pImeDpiT = gpImeDpi;

        while (pImeDpiT != NULL && pImeDpiT->pNext != pImeDpi)
            pImeDpiT = pImeDpiT->pNext;

        if (pImeDpiT != NULL)
            pImeDpiT->pNext = pImeDpi->pNext;
    }

    /*
     * Unload the IME DLL.
     */
    UnloadIME(pImeDpi, TRUE);

    ImmLocalFree(pImeDpi);

    RtlLeaveCriticalSection(&gcsImeDpi);

    return TRUE;
}


BOOL WINAPI ImmFreeLayout(
    DWORD  dwFlag)
{
    PIMEDPI pImeDpi;
    HKL   *phklRoot, hklCurrent;
    WCHAR  pwszNonImeKLID[KL_NAMELENGTH];
    UINT   nLayouts, uNonImeKLID = 0, i;

    hklCurrent = GetKeyboardLayout(0);

    switch (dwFlag) {

    case IFL_DEACTIVATEIME:
        /*
         * Do nothing if no IME to be deactivated.
         */
        if (!IS_IME_KBDLAYOUT(hklCurrent))
            return TRUE;

        /*
         * Deactivate IME based layout by activating a non-IME based
         * keyboard layout.
         */
        uNonImeKLID = (UINT)LANGIDFROMLCID(GetSystemDefaultLCID());

        nLayouts = GetKeyboardLayoutList(0, NULL);

        if (nLayouts != 0) {
            phklRoot = ImmLocalAlloc(0, nLayouts * sizeof(HKL));
            if (phklRoot == NULL)
                return FALSE;

            nLayouts = GetKeyboardLayoutList(nLayouts, phklRoot);

            for (i = 0; i < nLayouts && IS_IME_KBDLAYOUT(phklRoot[i]); i++) ;

            if (i < nLayouts)
                uNonImeKLID = HandleToUlong(phklRoot[i]) & 0xffff;

            ImmLocalFree(phklRoot);
        }

        wsprintf(pwszNonImeKLID, L"%08x", uNonImeKLID);

        if (LoadKeyboardLayoutW(pwszNonImeKLID, KLF_ACTIVATE) == NULL) {
            RIPMSG1(RIP_WARNING, "ImmFreeLayout: LoadKeyboardLayoutW(%S, KLF_ACTIVATE) failed. Trying 00000409", pwszNonImeKLID);
            // Somehow it failed (probably a bad setup), let's try
            // 409 KL, which should be installed on all localized NTs.
            if (LoadKeyboardLayoutW(L"00000409", KLF_ACTIVATE | KLF_FAILSAFE) == NULL) {
                RIPMSG0(RIP_WARNING, "LoadKeyboardLayoutW(00000409) failed either. will try NULL.");
            }
        }

        break;

    case IFL_UNLOADIME:
        RtlEnterCriticalSection(&gcsImeDpi);
UnloadImeDpiLoop:
        for (pImeDpi = gpImeDpi; pImeDpi != NULL; pImeDpi = pImeDpi->pNext) {
            if (ImmUnloadIME(pImeDpi->hKL))
                goto UnloadImeDpiLoop;        // Rescan as list was updated.
        }
        RtlLeaveCriticalSection(&gcsImeDpi);
        break;

    default:
        {
            HKL hklFlag = (HKL)LongToHandle( dwFlag );
            if (IS_IME_KBDLAYOUT(hklFlag) && hklFlag != hklCurrent) {
                ImmUnloadIME(hklFlag);
            }
        }
        break;
    }

    return TRUE;
}


BOOL WINAPI ImmActivateLayout(
    HKL    hSelKL)
{
    HKL     hUnSelKL;
    HWND    hWndDefaultIme;
    SCE     sce;
    DWORD   dwCPS;
    PIMEDPI pImeDpi;
    BOOLEAN fOptimizeActivation = TRUE;

    hUnSelKL = GetKeyboardLayout(0);

    {
        PCLIENTINFO pClientInfo = GetClientInfo();

        if (pClientInfo->CI_flags & CI_INPUTCONTEXT_REINIT) {
            fOptimizeActivation = FALSE;
        }
    }

    /*
     * if already current active, do nothing
     */
    if (hUnSelKL == hSelKL && fOptimizeActivation)
        return TRUE;

    ImmLoadIME(hSelKL);

    if (hUnSelKL != hSelKL) {
        pImeDpi = ImmLockImeDpi(hUnSelKL);
        if (pImeDpi != NULL) {
            /*
             * Send out CPS_CANCEL or CPS_COMPLETE to every input
             * context assoicated to window(s) created by this thread.
             * Starting from SUR, we only assoicate input context to window created
             * by the same thread.
             */
            dwCPS = (pImeDpi->ImeInfo.fdwProperty & IME_PROP_COMPLETE_ON_UNSELECT) ? CPS_COMPLETE : CPS_CANCEL;
            ImmUnlockImeDpi(pImeDpi);
            ImmEnumInputContext(0, NotifyIMEProc, dwCPS);
        }

        hWndDefaultIme = ImmGetDefaultIMEWnd(NULL);

        if (IsWindow(hWndDefaultIme))
            SendMessage(hWndDefaultIme, WM_IME_SELECT, FALSE, (LPARAM)hUnSelKL);

        /*
         * This is the time to update the kernel side layout handles.
         * We must do this before sending WM_IME_SELECT.
         */
        NtUserSetThreadLayoutHandles(hSelKL, hUnSelKL);
    }

    /*
     * Unselect and select input context(s).
     */
    sce.hSelKL   = hSelKL;
    sce.hUnSelKL = hUnSelKL;
    ImmEnumInputContext(0, (IMCENUMPROC)SelectContextProc, (LPARAM)&sce);

    /*
     * inform UI select after all hIMC select
     */
    if (IsWindow(hWndDefaultIme))
        SendMessage(hWndDefaultIme, WM_IME_SELECT, TRUE, (LPARAM)hSelKL);

    return (TRUE);
}


/***************************************************************************\
* ImmConfigureIMEA
*
* Brings up the configuration dialogbox of the IME with the specified hKL.
*
* History:
* 29-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmConfigureIMEA(
    HKL    hKL,
    HWND   hWnd,
    DWORD  dwMode,
    LPVOID lpData)
{
    PWND    pWnd;
    PIMEDPI pImeDpi;
    BOOL    fRet = FALSE;

    if ((pWnd = ValidateHwnd(hWnd)) == (PWND)NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmConfigureIMEA: invalid window handle %x", hWnd);
        return FALSE;
    }

    if (!TestWindowProcess(pWnd)) {
        RIPMSG1(RIP_WARNING,
              "ImmConfigureIMEA: hWnd=%lx belongs to different process!", hWnd);
        return FALSE;
    }

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmConfigureIMEA: no pImeDpi entry.");
        return FALSE;
    }

    if (!(pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) || lpData == NULL) {
        /*
         * Doesn't need A/W conversion. Calls directly to IME to
         * bring up the configuration dialogbox.
         */
            // This message handles by Console IME.
            SendMessage(hWnd, WM_IME_SYSTEM, IMS_OPENPROPERTYWINDOW, 0L);
        fRet = (*pImeDpi->pfn.ImeConfigure)(hKL, hWnd, dwMode, lpData);
            // This message handles by Console IME.
            SendMessage(hWnd, WM_IME_SYSTEM, IMS_CLOSEPROPERTYWINDOW, 0L);
        ImmUnlockImeDpi(pImeDpi);
        return fRet;
    }

    /*
     * ANSI caller, Unicode IME. Needs A/W conversion on lpData when
     * dwMode == IME_CONFIG_REGISTERWORD. In this case, lpData points
     * to a structure of REGISTERWORDA.
     */
    switch (dwMode) {
    case IME_CONFIG_REGISTERWORD:
        {
            LPREGISTERWORDA lpRegisterWordA;
            REGISTERWORDW   RegisterWordW;
            LPVOID          lpBuffer;
            ULONG           cbBuffer;
            INT             i;

            lpRegisterWordA = (LPREGISTERWORDA)lpData;
            cbBuffer = 0;
            lpBuffer = NULL;

            if (lpRegisterWordA->lpReading != NULL)
                cbBuffer += strlen(lpRegisterWordA->lpReading) + 1;

            if (lpRegisterWordA->lpWord != NULL)
                cbBuffer += strlen(lpRegisterWordA->lpWord) + 1;

            if (cbBuffer != 0) {
                cbBuffer *= sizeof(WCHAR);
                if ((lpBuffer = ImmLocalAlloc(0, cbBuffer)) == NULL) {
                    RIPMSG0(RIP_WARNING, "ImmConfigureIMEA: memory failure.");
                    break;
                }
            }

            if (lpRegisterWordA->lpReading != NULL) {
                RegisterWordW.lpReading = lpBuffer;
                i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                        (DWORD)MB_PRECOMPOSED,
                                        (LPSTR)lpRegisterWordA->lpReading,
                                        (INT)strlen(lpRegisterWordA->lpReading),
                                        (LPWSTR)RegisterWordW.lpReading,
                                        (INT)(cbBuffer/sizeof(WCHAR)));
                RegisterWordW.lpReading[i] = L'\0';
                cbBuffer -= (i * sizeof(WCHAR));
            }
            else {
                RegisterWordW.lpReading = NULL;
            }

            if (lpRegisterWordA->lpWord != NULL) {
                if (RegisterWordW.lpReading != NULL)
                    RegisterWordW.lpWord = &RegisterWordW.lpReading[i+1];
                else
                    RegisterWordW.lpWord = lpBuffer;
                i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                        (DWORD)MB_PRECOMPOSED,
                                        (LPSTR)lpRegisterWordA->lpWord,
                                        (INT)strlen(lpRegisterWordA->lpWord),
                                        (LPWSTR)RegisterWordW.lpWord,
                                        (INT)(cbBuffer/sizeof(WCHAR)));
                RegisterWordW.lpWord[i] = L'\0';
            }
            else
                RegisterWordW.lpWord = NULL;

            fRet = ImmConfigureIMEW(hKL, hWnd, dwMode, &RegisterWordW);

            if (lpBuffer != NULL)
                ImmLocalFree(lpBuffer);

            break;
        }
    default:
        fRet = ImmConfigureIMEW(hKL, hWnd, dwMode, lpData);
        break;
    }

    ImmUnlockImeDpi(pImeDpi);

    return fRet;
}


/***************************************************************************\
* ImmConfigureIMEW
*
* Brings up the configuration dialogbox of the IME with the specified hKL.
*
* History:
* 29-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmConfigureIMEW(
    HKL    hKL,
    HWND   hWnd,
    DWORD  dwMode,
    LPVOID lpData)
{
    PWND    pWnd;
    PIMEDPI pImeDpi;
    BOOL    fRet = FALSE;

    if ((pWnd = ValidateHwnd(hWnd)) == (PWND)NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmConfigureIMEA: invalid window handle %x", hWnd);
        return FALSE;
    }

    if (!TestWindowProcess(pWnd)) {
        RIPMSG1(RIP_WARNING,
              "ImmConfigureIMEA: hWnd=%lx belongs to different process!", hWnd);
        return FALSE;
    }

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmConfigureIMEA: no pImeDpi entry.");
        return FALSE;
    }

    if ((pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) || lpData == NULL) {
        /*
         * Doesn't need A/W conversion. Calls directly to IME to
         * bring up the configuration dialogbox.
         */
            // This message handles by Console IME.
            SendMessage(hWnd, WM_IME_SYSTEM, IMS_OPENPROPERTYWINDOW, 0L);
        fRet = (*pImeDpi->pfn.ImeConfigure)(hKL, hWnd, dwMode, lpData);
            // This message handles by Console IME.
            SendMessage(hWnd, WM_IME_SYSTEM, IMS_CLOSEPROPERTYWINDOW, 0L);
        ImmUnlockImeDpi(pImeDpi);
        return fRet;
    }

    /*
     * Unicode caller, ANSI IME. Needs A/W conversion on lpData when
     * dwMode == IME_CONFIG_REGISTERWORD. In this case, lpData points
     * to a structure of REGISTERWORDW.
     */
    switch (dwMode) {
    case IME_CONFIG_REGISTERWORD:
        {
            LPREGISTERWORDW lpRegisterWordW;
            REGISTERWORDA   RegisterWordA;
            LPVOID          lpBuffer;
            ULONG           cbBuffer;
            BOOL            bUDC;
            INT             i;

            lpRegisterWordW = (LPREGISTERWORDW)lpData;
            cbBuffer = 0;
            lpBuffer = NULL;

            if (lpRegisterWordW->lpReading != NULL)
                cbBuffer += wcslen(lpRegisterWordW->lpReading) + 1;

            if (lpRegisterWordW->lpWord != NULL)
                cbBuffer += wcslen(lpRegisterWordW->lpWord) + 1;

            if (cbBuffer != 0) {
                cbBuffer *= sizeof(WCHAR);
                if ((lpBuffer = ImmLocalAlloc(0, cbBuffer)) == NULL) {
                    RIPMSG0(RIP_WARNING, "ImmConfigureIMEW: memory failure.");
                    break;
                }
            }

            if (lpRegisterWordW->lpReading != NULL) {
                RegisterWordA.lpReading = lpBuffer;
                i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                        (DWORD)0,
                                        (LPWSTR)lpRegisterWordW->lpReading,
                                        (INT)wcslen(lpRegisterWordW->lpReading),
                                        (LPSTR)RegisterWordA.lpReading,
                                        (INT)cbBuffer,
                                        (LPSTR)NULL,
                                        (LPBOOL)&bUDC);
                RegisterWordA.lpReading[i] = '\0';
                cbBuffer -= (i * sizeof(CHAR));
            }
            else {
                RegisterWordA.lpReading = NULL;
            }

            if (lpRegisterWordW->lpWord != NULL) {
                if (RegisterWordA.lpReading != NULL)
                    RegisterWordA.lpWord = &RegisterWordA.lpReading[i+1];
                else
                    RegisterWordA.lpWord = lpBuffer;
                i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                        (DWORD)0,
                                        (LPWSTR)lpRegisterWordW->lpWord,
                                        (INT)wcslen(lpRegisterWordW->lpWord),
                                        (LPSTR)RegisterWordA.lpWord,
                                        (INT)cbBuffer,
                                        (LPSTR)NULL,
                                        (LPBOOL)&bUDC);
                RegisterWordA.lpWord[i] = '\0';
            }
            else
                RegisterWordA.lpWord = NULL;

            fRet = ImmConfigureIMEA(hKL, hWnd, dwMode, &RegisterWordA);

            if (lpBuffer != NULL)
                ImmLocalFree(lpBuffer);

            break;
        }
    default:
        fRet = ImmConfigureIMEA(hKL, hWnd, dwMode, lpData);
        break;
    }

    ImmUnlockImeDpi(pImeDpi);

    return fRet;
}


#define IME_T_EUDC_DIC_SIZE 80  // the Traditional Chinese EUDC dictionary

/***************************************************************************\
* ImmEscapeA
*
* This API allows an application to access capabilities of a particular
* IME with specified hKL not directly available thru. other IMM APIs.
* This is necessary mainly for country specific functions or private
* functions in IME.
*
* History:
* 29-Feb-1995   wkwok   Created
\***************************************************************************/

LRESULT WINAPI ImmEscapeA(
    HKL    hKL,
    HIMC   hImc,
    UINT   uSubFunc,
    LPVOID lpData)
{
    PIMEDPI pImeDpi;
    LRESULT lRet = 0;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmEscapeA: no pImeDpi entry.");
        return lRet;
    }

    if ((pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) == 0 || lpData == NULL) {
        /*
         * Doesn't need A/W conversion. Calls directly to IME to
         * bring up the configuration dialogbox.
         */
#if !defined(CUAS_ENABLE)
        lRet = (*pImeDpi->pfn.ImeEscape)(hImc, uSubFunc, lpData);
#else
        if (IS_IME_KBDLAYOUT(hKL)) {
            lRet = (*pImeDpi->pfn.ImeEscape)(hImc, uSubFunc, lpData);
        }
        else if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
            lRet = (*pImeDpi->pfn.CtfImeEscapeEx)(hImc, uSubFunc, lpData, hKL);
        }
#endif
        ImmUnlockImeDpi(pImeDpi);
        return lRet;
    }

    /*
     * ANSI caller, Unicode IME. Needs A/W conversion depending on
     * uSubFunc.
     */
    switch (uSubFunc) {
    case IME_ESC_GET_EUDC_DICTIONARY:
    case IME_ESC_IME_NAME:
    case IME_ESC_GETHELPFILENAME:
        {
            WCHAR wszData[IME_T_EUDC_DIC_SIZE];
            BOOL  bUDC;
            INT   i;

            lRet = ImmEscapeW(hKL, hImc, uSubFunc, (LPVOID)wszData);

            if (lRet != 0) {

                try {
                    i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                            (DWORD)0,
                                            (LPWSTR)wszData,         // src
                                            (INT)wcslen(wszData),
                                            (LPSTR)lpData,           // dest
                                            (INT)IME_T_EUDC_DIC_SIZE,
                                            (LPSTR)NULL,
                                            (LPBOOL)&bUDC);
                    ((LPSTR)lpData)[i] = '\0';
                }
                except (EXCEPTION_EXECUTE_HANDLER) {
                    lRet = 0;
                }
            }

            break;
        }

    case IME_ESC_SET_EUDC_DICTIONARY:
    case IME_ESC_HANJA_MODE:
        {
            WCHAR wszData[IME_T_EUDC_DIC_SIZE];
            INT   i;

            i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                    (DWORD)MB_PRECOMPOSED,
                                    (LPSTR)lpData,             // src
                                    (INT)strlen(lpData),
                                    (LPWSTR)wszData,          // dest
                                    (INT)sizeof(wszData)/sizeof(WCHAR));
            wszData[i] = L'\0';

            lRet = ImmEscapeW(hKL, hImc, uSubFunc, (LPVOID)wszData);

            break;
        }

    case IME_ESC_SEQUENCE_TO_INTERNAL:
        {
            CHAR    szData[4];
            WCHAR   wszData[4];
            INT     i = 0;

            lRet = ImmEscapeW(hKL, hImc, uSubFunc, lpData);

            if (HIWORD(lRet))
                wszData[i++] = HIWORD(lRet);

            if (LOWORD(lRet))
                wszData[i++] = LOWORD(lRet);

            i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                    (DWORD)0,
                                    (LPWSTR)wszData,        // src
                                    (INT)i,
                                    (LPSTR)szData,          // dest
                                    (INT)sizeof(szData),
                                    (LPSTR)NULL,
                                    (LPBOOL)NULL);

            switch (i) {
            case 1:
                lRet = MAKELONG(MAKEWORD(szData[0], 0), 0);
                break;

            case 2:
                lRet = MAKELONG(MAKEWORD(szData[1], szData[0]), 0);
                break;

            case 3:
                lRet = MAKELONG(MAKEWORD(szData[2], szData[1]), MAKEWORD(szData[0], 0));
                break;

            case 4:
                lRet = MAKELONG(MAKEWORD(szData[3], szData[2]), MAKEWORD(szData[1], szData[0]));
                break;

            default:
                lRet = 0;
                break;
            }

            break;
        }
    default:
        lRet = ImmEscapeW(hKL, hImc, uSubFunc, lpData);
        break;
    }

    ImmUnlockImeDpi(pImeDpi);

    return lRet;
}


/***************************************************************************\
* ImmEscapeW
*
* This API allows an application to access capabilities of a particular
* IME with specified hKL not directly available thru. other IMM APIs.
* This is necessary mainly for country specific functions or private
* functions in IME.
*
* History:
* 29-Feb-1995   wkwok   Created
\***************************************************************************/

LRESULT WINAPI ImmEscapeW(
    HKL    hKL,
    HIMC   hImc,
    UINT   uSubFunc,
    LPVOID lpData)
{
    PIMEDPI pImeDpi;
    LRESULT lRet = 0;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmEscapeW: no pImeDpi entry.");
        return lRet;
    }

    if ((pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) || lpData == NULL) {
        /*
         * Doesn't need W/A conversion. Calls directly to IME to
         * bring up the configuration dialogbox.
         */
#if !defined(CUAS_ENABLE)
        lRet = (*pImeDpi->pfn.ImeEscape)(hImc, uSubFunc, lpData);
#else
        if (IS_IME_KBDLAYOUT(hKL)) {
            lRet = (*pImeDpi->pfn.ImeEscape)(hImc, uSubFunc, lpData);
        }
        else if (IS_CICERO_ENABLED_AND_NOT16BIT()) {
            lRet = (*pImeDpi->pfn.CtfImeEscapeEx)(hImc, uSubFunc, lpData, hKL);
        }
#endif
        ImmUnlockImeDpi(pImeDpi);
        return lRet;
    }

    /*
     * Unicode caller, ANSI IME. Needs W/A conversion depending on
     * uSubFunc.
     */
    switch (uSubFunc) {
    case IME_ESC_GET_EUDC_DICTIONARY:
    case IME_ESC_IME_NAME:
    case IME_ESC_GETHELPFILENAME:
        {
            CHAR szData[IME_T_EUDC_DIC_SIZE];
            INT  i;

            lRet = ImmEscapeA(hKL, hImc, uSubFunc, (LPVOID)szData);

            if (lRet != 0) {

                try {
                    i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                            (DWORD)MB_PRECOMPOSED,
                                            (LPSTR)szData,          // src
                                            (INT)strlen(szData),
                                            (LPWSTR)lpData,         // dest
                                            (INT)IME_T_EUDC_DIC_SIZE);
                    ((LPWSTR)lpData)[i] = L'\0';
                }
                except (EXCEPTION_EXECUTE_HANDLER) {
                    lRet = 0;
                }
            }

            break;
        }

    case IME_ESC_SET_EUDC_DICTIONARY:
    case IME_ESC_HANJA_MODE:
        {
            CHAR szData[IME_T_EUDC_DIC_SIZE];
            BOOL bUDC;
            INT  i;

            i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                    (DWORD)0,
                                    (LPWSTR)lpData,          // src
                                    (INT)wcslen(lpData),
                                    (LPSTR)szData,          // dest
                                    (INT)sizeof(szData),
                                    (LPSTR)NULL,
                                    (LPBOOL)&bUDC);
            szData[i] = '\0';

            lRet = ImmEscapeA(hKL, hImc, uSubFunc, (LPVOID)szData);

            break;
        }

    case IME_ESC_SEQUENCE_TO_INTERNAL:
        {
            CHAR    szData[4];
            WCHAR   wszData[4];
            INT     i = 0;

            lRet = ImmEscapeA(hKL, hImc, uSubFunc, lpData);

            if (HIBYTE(LOWORD(lRet)))
                szData[i++] = HIBYTE(LOWORD(lRet));

            if (LOBYTE(LOWORD(lRet)))
                szData[i++] = LOBYTE(LOWORD(lRet));

            i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                    (DWORD)MB_PRECOMPOSED,
                                    (LPSTR)szData,            // src
                                    i,
                                    (LPWSTR)wszData,          // dest
                                    (INT)sizeof(wszData)/sizeof(WCHAR));

            switch (i) {
            case 1:
                lRet = MAKELONG(wszData[0], 0);
                break;

            case 2:
                lRet = MAKELONG(wszData[1], wszData[0]);
                break;

            default:
                lRet = 0;
                break;
            }

            break;
        }

    default:
        lRet = ImmEscapeA(hKL, hImc, uSubFunc, lpData);
        break;
    }

    ImmUnlockImeDpi(pImeDpi);

    return lRet;
}


BOOL WINAPI ImmPenAuxInput(HWND hwndSender, LPVOID lpData)
{
    PIMEDPI pImeDpi = NULL;
    PCOPYDATASTRUCT lpCopyData = (PCOPYDATASTRUCT)lpData;
    PENINPUTDATA* lpPenInputData = (LPVOID)lpCopyData->lpData;
    IMEPENDATA ImePenData;
    HWND hwnd;
    HIMC himc;
    HKL hkl;
    DWORD dwData = 0 ;
    LPDWORD lpdwData = NULL;

    UNREFERENCED_PARAMETER(hwndSender);

    if (lpCopyData->dwData != LM_IMM_MAGIC || lpCopyData->cbData < sizeof(PENINPUTDATA)) {
        RIPMSG0(RIP_WARNING, "ImmPenAuxInput: invalid COPYDATASTRUCT signagure.");
        return FALSE;
    }

    if (lpPenInputData->dwVersion != 0) {
        RIPMSG0(RIP_WARNING, "ImmPenAuxInput: invalid Pendata version.");
        return FALSE;
    }

    hwnd = GetFocus();
    hkl = GetKeyboardLayout(0);
    if (hwnd == NULL || hkl == NULL || (himc = ImmGetContext(hwnd)) == NULL) {
        RIPMSG0(RIP_WARNING, "ImmPenAuxInput: hwnd, hkl or himc cannot be aquired.");
        return FALSE;
    }

    if ((pImeDpi = FindOrLoadImeDpi(hkl)) == NULL) {
        RIPMSG0(RIP_WARNING, "ImmPenAuxInput: IME DPI cannot be found.");
        return FALSE;
    }

    do {    // dummy loop (execute just once) so that we can 'break' in case of unexpected errors
        dwData = IME_ESC_PENAUXDATA;
        if (!pImeDpi->pfn.ImeEscape(himc, IME_ESC_QUERY_SUPPORT, (LPVOID)&dwData)) {
            //
            // IME_ESC_PENAUXDATA is not supported by the current IME.
            //
            RIPMSG1(RIP_VERBOSE, "ImmPenAuxInput: IME(hkl=%08x) does not support IME_ESC_PENDATA", hkl);
            break;
        }

        dwData = 0; // Be prepared for unexpected exodus

        //
        // Makeup the IMEPENDATA structure.
        //

        RtlZeroMemory(&ImePenData, sizeof ImePenData);

        ImePenData.dwCount = lpPenInputData->cnt;

        if (lpPenInputData->flags & ~(LMDATA_SYMBOL_DWORD | LMDATA_SKIP_WORD | LMDATA_SCORE_WORD)) {
            RIPMSG1(RIP_WARNING, "ImmPenAuxInput: flag out of range (0x%08x)", lpPenInputData->flags);
        }

        //
        // Setup the structure for IME.
        //

        if (lpPenInputData->flags & LMDATA_SYMBOL_DWORD) {
            if (lpPenInputData->dwOffsetSymbols > lpCopyData->cbData ||
                    lpPenInputData->dwOffsetSymbols + lpPenInputData->cnt * sizeof(DWORD) > lpCopyData->cbData) {
                //
                // Invalid structure
                //
                RIPMSG1(RIP_WARNING, "ImmPenAuxInput: illegal dwOffsetSymbols (0x%x)", lpPenInputData->dwOffsetSymbols);
                break;
            }
            ImePenData.wd.lpSymbol = (LPVOID)&lpPenInputData->ab[lpPenInputData->dwOffsetSymbols];
            ImePenData.dwFlags |= IME_PEN_SYMBOL;

            //
            // If it's ANSI IME, we need to translate the symbols
            //
            if ((pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) == 0) {
                USHORT wCodePage = (USHORT)GetKeyboardLayoutCP(hkl);
                int i;

                lpdwData = ImmLocalAlloc(HEAP_ZERO_MEMORY, sizeof *lpdwData * ImePenData.dwCount);
                if (lpdwData == NULL) {
                    RIPMSG0(RIP_WARNING, "ImmPenAuxInput: could not allocate lpdwData");
                    break;
                }
                for (i = 0; i < (int)ImePenData.dwCount; ++i) {
                    LPSTR lpstr = (LPSTR)(lpdwData + i);

                    // Assuming little endian:
                    WCSToMBEx(wCodePage,
                              (LPCWSTR)(ImePenData.wd.lpSymbol + i), 1,
                              &lpstr, 2,
                              FALSE);
                    ImmAssert(HIWORD(lpdwData[i]) == 0);

                    // Copy the high word (column #).
                    lpdwData[i] |= (ImePenData.wd.lpSymbol[i] & ~0xffff);
                }
                ImePenData.wd.lpSymbol = lpdwData;
            }

        }

        if (lpPenInputData->flags & LMDATA_SKIP_WORD) {
            if (lpPenInputData->dwOffsetSkip > lpCopyData->cbData ||
                    lpPenInputData->dwOffsetSkip + lpPenInputData->cnt * sizeof(WORD) > lpCopyData->cbData) {
                //
                // Invalid structure
                //
                RIPMSG1(RIP_WARNING, "ImmPenAuxInput: illegal dwOffsetSkip (0x%x)", lpPenInputData->dwOffsetSkip);
                break;
            }
            ImePenData.wd.lpSkip = (LPVOID)&lpPenInputData->ab[lpPenInputData->dwOffsetSkip];
            ImePenData.dwFlags |= IME_PEN_SKIP;
        }

        if (lpPenInputData->flags & LMDATA_SCORE_WORD) {
            if (lpPenInputData->dwOffsetScore > lpCopyData->cbData ||
                    lpPenInputData->dwOffsetScore + lpPenInputData->cnt * sizeof(WORD) > lpCopyData->cbData) {
                //
                // Invalid structure
                //
                RIPMSG1(RIP_WARNING, "ImmPenAuxInput: illegal dwOffsetScore (0x%x)", lpPenInputData->dwOffsetScore);
                break;
            }
            ImePenData.wd.lpScore = (LPVOID)&lpPenInputData->ab[lpPenInputData->dwOffsetScore];
            ImePenData.dwFlags |= IME_PEN_SCORE;
        }
        dwData = (DWORD)pImeDpi->pfn.ImeEscape(himc, IME_ESC_PENAUXDATA, &ImePenData);
    } while (FALSE);

    if (lpdwData) {
        ImmLocalFree(lpdwData);
    }

    ImmAssert(pImeDpi);
    ImmUnlockImeDpi(pImeDpi);

    return dwData;
}

LRESULT WINAPI ImmSendMessageToActiveDefImeWndW(
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndIme;

    //
    // Today we only support this for WM_COPYDATA
    //
    if (msg != WM_COPYDATA) {
        return 0;
    }

    hwndIme = NtUserQueryWindow((HWND)wParam, WindowActiveDefaultImeWindow);
    if (hwndIme == NULL) {
        return 0;
    }

    return SendMessage(hwndIme, msg, wParam, lParam);
}

BOOL WINAPI ImmNotifyIME(
    HIMC  hImc,
    DWORD dwAction,
    DWORD dwIndex,
    DWORD dwValue)
{
    PIMEDPI pImeDpi;
    BOOL    bRet;

    if (hImc != NULL_HIMC &&
            GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmNotifyIME: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pImeDpi = ImmLockImeDpi(GetKeyboardLayout(0));
    if (pImeDpi == NULL)
        return FALSE;

    bRet = (*pImeDpi->pfn.NotifyIME)(hImc, dwAction, dwIndex, dwValue);

    ImmUnlockImeDpi(pImeDpi);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\immcli.h ===
/****************************** Module Header ******************************\
* Module Name: immcli.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Typedefs, defines, and prototypes that are used exclusively by the IMM
* client-side DLL.
*
* History:
* 11-Jan-96 wkwok      Created
\***************************************************************************/

#ifndef _IMMCLI_
#define _IMMCLI_

#pragma once

#define OEMRESOURCE 1

#include <windows.h>

#include <stddef.h>
#include <w32err.h>
#include <w32gdip.h>
#include "winuserp.h"
#include "winuserk.h"
#include "kbd.h"
#include <wowuserp.h>
#include <memory.h>
#include <string.h>
#include <imm.h>
#include <immp.h>
#include <ime.h>
#include <imep.h>
#include <winnls32.h>

#include "immstruc.h"
#include "immuser.h"

#include "user.h"

typedef struct _ENUMREGWORDDATA {
    union {
        REGISTERWORDENUMPROCW w;
        REGISTERWORDENUMPROCA a;
    } lpfn;
    LPVOID lpData;
    DWORD  dwCodePage;
} ENUMREGWORDDATA, *PENUMREGWORDDATA;

#define HEX_ASCII_SIZE          20

typedef struct tagIMELAYOUT {
    HKL     hImeKL;
    WCHAR   szKeyName[HEX_ASCII_SIZE];
    WCHAR   szImeName[IM_FILE_SIZE];
} IMELAYOUT, *PIMELAYOUT;

#define ImmAssert UserAssert

typedef struct tagFE_KEYBOARDS {
    BOOLEAN fJPN : 1;
    BOOLEAN fCHT : 1;
    BOOLEAN fCHS : 1;
    BOOLEAN fKOR : 1;
} FE_KEYBOARDS;

/*
 * Function pointers to registry routines in advapi32.dll.
 */
typedef struct {
    LONG (WINAPI* RegCreateKeyW)(HKEY, LPCWSTR, PHKEY);
    LONG (WINAPI* RegOpenKeyW)(HKEY, LPCWSTR, PHKEY);
    LONG (WINAPI* RegCloseKey)(HKEY);
    LONG (WINAPI* RegDeleteKeyW)(HKEY, LPCWSTR);
    LONG (WINAPI* RegCreateKeyExW)(HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD);
    LONG (WINAPI* RegSetValueExW)(HKEY, LPCWSTR, DWORD Reserved, DWORD, CONST BYTE*, DWORD);
    LONG (WINAPI* RegQueryValueExW)(HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
    HMODULE hModule;
    BOOLEAN fOk;
} ADVAPI_FN;

/***************************************************************************\
*
* Globals declarations
*
\***************************************************************************/

extern BOOLEAN gfInitialized;
extern HINSTANCE ghInst;
extern PVOID pImmHeap;
extern PSERVERINFO gpsi;
extern SHAREDINFO gSharedInfo;

extern PIMEDPI gpImeDpi;
extern CRITICAL_SECTION gcsImeDpi;

extern POINT     gptWorkArea;
extern POINT     gptRaiseEdge;
extern UINT      guScanCode[0XFF];

extern CONST WCHAR     gszRegKbdLayout[];
#ifdef CUAS_ENABLE
extern CONST WCHAR     gszRegCiceroIME[];
extern CONST WCHAR     gszRegCtfShared[];
extern CONST WCHAR     gszValCUASEnable[];
#endif // CUAS_ENABLE
#ifdef LATER
extern CONST INT       sizeof_gszRegKbdLayout;
#endif
extern CONST WCHAR     gszRegKbdOrder[];
extern CONST WCHAR     gszValLayoutText[];
extern CONST WCHAR     gszValLayoutFile[];
extern CONST WCHAR     gszValImeFile[];

#ifdef CUAS_ENABLE
extern DWORD g_aimm_compat_flags;
#endif // CUAS_ENABLE

/***************************************************************************\
*
* Validation handling
*
\***************************************************************************/

#define bUser32Initialized (gpsi != NULL)

#define ValidateHwnd(hwnd)   (((hwnd) == (HWND)NULL || !bUser32Initialized) \
        ? (PWND)NULL : HMValidateHandle(hwnd, TYPE_WINDOW))

#define ValidateHimc(himc)   (((himc) == (HIMC)NULL || !bUser32Initialized) \
        ? (PIMC)NULL : HMValidateHandle((HANDLE)himc, TYPE_INPUTCONTEXT))

#define RevalidateHimc(himc) (((himc) == (HIMC)NULL || !bUser32Initialized) \
        ? (PIMC)NULL : HMValidateHandleNoRip((HANDLE)himc, TYPE_INPUTCONTEXT))

/***************************************************************************\
*
* Memory management macros
*
\***************************************************************************/

LPVOID  ImmLocalAlloc(DWORD uFlag, DWORD uBytes);
#define ImmLocalReAlloc(p, uBytes, uFlags) HeapReAlloc(pImmHeap, uFlags, (LPSTR)(p), (uBytes))
#define ImmLocalFree(p)    HeapFree(pImmHeap, 0, (LPSTR)(p))
#define ImmLocalSize(p)    HeapSize(pImmHeap, 0, (LPSTR)(p))
#define ImmLocalLock(p)    (LPSTR)(p)
#define ImmLocalUnlock(p)
#define ImmLocalFlags(p)   0
#define ImmLocalHandle(p)  (HLOCAL)(p)

/***************************************************************************\
*
* Other Typedefs and Macros
*
\***************************************************************************/
#define GetInputContextProcess(himc) \
            (DWORD)NtUserQueryInputContext(himc, InputContextProcess)

#define GetInputContextThread(himc) \
            (DWORD)NtUserQueryInputContext(himc, InputContextThread)

#define GetWindowProcess(hwnd) \
            (ULONG_PTR)NtUserQueryWindow(hwnd, WindowProcess)

#define GETPROCESSID() (ULONG_PTR)(NtCurrentTeb()->ClientId.UniqueProcess)

#define DWORD_ALIGN(x) ((x+3)&~3)

#define SetICF(pClientImc, flag)  ((pClientImc)->dwFlags |= flag)

#define ClrICF(pClientImc, flag)  ((pClientImc)->dwFlags &= ~flag)

#define TestICF(pClientImc, flag) ((pClientImc)->dwFlags & flag)

#define IsWndEqual(hWnd1, hWnd2) (LOWORD(HandleToUlong(hWnd1)) == LOWORD(HandleToUlong(hWnd2)) && \
            ValidateHwnd(hWnd1) == ValidateHwnd(hWnd2))

#define HKL_TO_LANGID(hkl)      (LOWORD(HandleToUlong(hkl)))

/*
 * Obsolete, but keep this for backward compat. for a while
 */
#define LANGIDFROMHKL(hkl)      (LOBYTE(LOWORD((ULONG_PTR)hkl)))

#ifdef IMM_CONV_ON_HKL
#define IMECodePage(pImeDpi)        ((pImeDpi)->dwCodePage)
#define CImcCodePage(pClientImc)    ((pClientImc)->dwCodePage)
#else
#define IMECodePage(pImeDpi)        (CP_ACP)
#define CImcCodePage(pClientImc)    (CP_ACP)
#endif

/***************************************************************************\
*
* Function declarations
*
\***************************************************************************/

/*
 * context.c
 */
BOOL CreateInputContext(
    HIMC hImc,
    HKL  hKL,
    BOOL fCanCallImeSelect);

BOOL DestroyInputContext(
    HIMC      hImc,
    HKL       hKL,
    BOOL      bTerminate);

VOID SelectInputContext(
    HKL  hSelKL,
    HKL  hUnSelKL,
    HIMC hImc);

DWORD BuildHimcList(
    DWORD idThread,
    HIMC **pphimcFirst);

HIMC ImmGetSaveContext(
    HWND  hWnd,
    DWORD dwFlag);

/*
 * ctxtinfo.c
 */
BOOL ImmSetCompositionStringWorker(
    HIMC    hImc,
    DWORD   dwIndex,
    LPVOID lpComp,
    DWORD   dwCompLen,
    LPVOID lpRead,
    DWORD   dwReadLen,
    BOOL    fAnsi);

DWORD ImmGetCandidateListCountWorker(
    HIMC    hImc,
    LPDWORD lpdwListCount,
    BOOL    fAnsi);

DWORD ImmGetCandidateListWorker(
    HIMC            hImc,
    DWORD           dwIndex,
    LPCANDIDATELIST lpCandList,
    DWORD           dwBufLen,
    BOOL            fAnsi);

DWORD ImmGetGuideLineWorker(
    HIMC    hImc,
    DWORD   dwIndex,
    LPBYTE  lpBuf,
    DWORD   dwBufLen,
    BOOL    fAnsi);

LONG InternalGetCompositionStringA(
#ifdef CUAS_ENABLE
    HIMC                hImc,
#endif // CUAS_ENABLE
    LPCOMPOSITIONSTRING lpCompStr,
    DWORD               dwIndex,
    LPVOID              lpBuf,
    DWORD               dwBufLen,
    BOOL                fAnsiImc,
    DWORD               dwCodePage);

LONG InternalGetCompositionStringW(
#ifdef CUAS_ENABLE
    HIMC                hImc,
#endif // CUAS_ENABLE
    LPCOMPOSITIONSTRING lpCompStr,
    DWORD               dwIndex,
    LPVOID              lpBuf,
    DWORD               dwBufLen,
    BOOL                fAnsiImc,
    DWORD               dwCodePage);

DWORD InternalGetCandidateListAtoW(
    LPCANDIDATELIST     lpCandListA,
    LPCANDIDATELIST     lpCandListW,
    DWORD               dwBufLen,
    DWORD               dwCodePage);

DWORD InternalGetCandidateListWtoA(
    LPCANDIDATELIST     lpCandListW,
    LPCANDIDATELIST     lpCandListA,
    DWORD               dwBufLen,
    DWORD               dwCodePage);

DWORD CalcCharacterPositionAtoW(
    DWORD dwCharPosA,
    LPSTR lpszCharStr,
    DWORD dwCodePage);

DWORD CalcCharacterPositionWtoA(
    DWORD dwCharPosW,
    LPWSTR lpwszCharStr,
    DWORD  dwCodePage);

VOID LFontAtoLFontW(
    LPLOGFONTA lfFontA,
    LPLOGFONTW lfFontW);

VOID LFontWtoLFontA(
    LPLOGFONTW lfFontW,
    LPLOGFONTA lfFontA);

BOOL MakeIMENotify(
    HIMC   hImc,
    HWND   hWnd,
    DWORD  dwAction,
    DWORD  dwIndex,
    DWORD  dwValue,
    WPARAM wParam,
    LPARAM lParam);

VOID ImmSendNotification(
    BOOL fForProcess);


/*
 * immime.c
 */
BOOL InquireIme(
    PIMEDPI pImeDpi);

BOOL LoadIME(
    PIMEINFOEX piiex,
    PIMEDPI    pImeDpi);

VOID UnloadIME(
    PIMEDPI pImeDpi,
    BOOL    fTerminateIme);

PIMEDPI LoadImeDpi(
    HKL  hKL,
    BOOL fLock);

PIMEDPI FindOrLoadImeDpi(
    HKL hKL);

/*
 * layime.c
 */
VOID GetSystemPathName(PWSTR /*OUT*/ pwszPath, PWSTR pwszFileName, UINT maxChar);

BOOL LoadVersionInfo(
    PIMEINFOEX piiex);

LPWSTR MakeStringFromRegFullInfo(PKEY_VALUE_FULL_INFORMATION pKey, size_t limit);

/*
 * misc.c
 */

PINPUTCONTEXT InternalImmLockIMC(
    HIMC hImc,
    BOOL fCanCallImeSelect);

BOOL ImmIsUIMessageWorker(
    HWND   hIMEWnd,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL   fAnsi);


PTHREADINFO PtiCurrent(VOID);

BOOL TestInputContextProcess(
    PIMC pImc);

PIMEDPI ImmGetImeDpi(HKL hKL);
DWORD   ImmGetAppCompatFlags(HIMC hImc);

BOOL ImmPtInRect(
    int left,
    int top,
    int width,
    int height,
    LPPOINT lppt);

UINT GetKeyboardLayoutCP(
    HKL hKL);

/*
 * regword.c
 */
UINT CALLBACK EnumRegisterWordProcA(
    LPCSTR            lpszReading,
    DWORD             dwStyle,
    LPCSTR            lpszString,
    PENUMREGWORDDATA  pEnumRegWordData);

UINT CALLBACK EnumRegisterWordProcW(
    LPCWSTR          lpwszReading,
    DWORD            dwStyle,
    LPCWSTR          lpwszString,
    PENUMREGWORDDATA pEnumRegWordData);

/*
 * hotkey.c
 */


VOID ImmPostMessages(
    HWND hwnd,
    HIMC hImc,
    INT  iNum,
    PTRANSMSG pTransMsg);

BOOL HotKeyIDDispatcher( HWND hWnd, HIMC hImc, HKL hKL, DWORD dwHotKeyID );

BOOL OpenRegApi(ADVAPI_FN* pfn);
void CloseRegApi(ADVAPI_FN* pfn);

/*
 * transsub.c
 */
LRESULT TranslateIMESubFunctions(
    HWND hWndApp,
    LPIMESTRUCT lpIme,
    BOOL fAnsi);

LRESULT TransGetLevel( HWND hWndApp );
LRESULT TransSetLevel( HWND hWndApp, LPIMESTRUCT lpIme);

/*
 * kcodecnv.c
 */
LRESULT TransCodeConvert( HIMC hImc, LPIMESTRUCT lpIme);
LRESULT TransConvertList( HIMC hImc, LPIMESTRUCT lpIme);
LRESULT TransGetMNTable( HIMC hImc, LPIMESTRUCT lpIme);

/*
 * ktranmsg.c
 */
UINT WINNLSTranslateMessageK(
    int                 iNumMsg,
    PTRANSMSG           pTransMsg,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    BOOL bAnsiIMC);

/*
 * jtranmsg.c
 */
UINT WINNLSTranslateMessageJ(
    UINT                uiNumMsg,
    PTRANSMSG           pTransMsg,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    BOOL bAnsiIMC );

/*
 * input.c
 */
UINT WINNLSTranslateMessage(
    INT    iNum,         // number of messages in the source buffer
    PTRANSMSG pTransMsg, // source buffer that contains 4.0 style messages
    HIMC   hImc,         // input context handle
    BOOL   fAnsi,        // TRUE if pdwt contains ANSI messages
    DWORD  dwLangId );   // language ID ( KOREAN or JAPANESE )


/*
 * support routine: IsAnsiClientIMC
 */
__inline int IsAnsiIMC(HIMC hIMC)
{
    BOOL bAnsi;

    // get ansi mode of origin IMC
    PCLIENTIMC pClientIMC = ImmLockClientImc(hIMC);
    if (pClientIMC == NULL) {
        return -1;
    }
    bAnsi = !TestICF(pClientIMC, IMCF_UNICODE);
    ImmUnlockClientImc(pClientIMC);
    return bAnsi;
}

#ifdef CUAS_ENABLE
/*
 * com.c
 */
HRESULT CtfImmTIMCreateInputContext(HIMC hImc);
HRESULT CtfImmTIMDestroyInputContext(HIMC hImc);
HRESULT CtfImmLastEnabledWndDestroy(LPARAM lParam);
LRESULT CtfImmSetLangBand(HWND hwndTray, BOOL fLangBand);
HRESULT Internal_CtfImeCreateThreadMgr();
HRESULT Internal_CtfImeDestroyThreadMgr();
BOOL    Internal_CtfImeProcessCicHotkey(HIMC hIMC, UINT uVKey, LPARAM lParam);
HRESULT Internal_CtfImeCreateInputContext(HIMC himc);
HRESULT Internal_CtfImeDestroyInputContext(HIMC himc);
HRESULT Internal_CtfImeSetActiveContextAlways(HIMC himc, BOOL fActive, HWND hwnd, HKL hkl);
BOOL    IsCUASEnabled();
BOOL IsDisabledTextServices();
BOOL IsInteractiveUserLogon();
BOOL IsRunningInMsoobe();

#endif // CUAS_ENABLE


#define TRACE(x)

//
// Resources
//

// CHT software keyboard bitmaps
#define BACK_T1     100
#define TAB_T1      101
#define CAPS_T1     102
#define ENTER_T1    103
#define SHIFT_T1    104
#define CTRL_T1     105
#define ESC_T1      106
#define ALT_T1      107
#define LABEL_T1    108

// CHS software keyboard bitmaps
#define BACKSP_C1   201
#define TAB_C1      202
#define CAPS_C1     203
#define ENTER_C1    204
#define SHIFT_C1    205
#define INS_C1      206
#define DEL_C1      207
#define ESC_C1      208
#define LABEL_C1    209

#endif // _IMMCLI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\jtranmsg.c ===
/**************************************************************************\
* Module Name: jtranmsg.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the code for the Japanese translation subroutine.
*
* History:
* 15-Aug-1995 kazum
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop


UINT
JTransCompositionA(
    LPINPUTCONTEXT lpIMC,
    LPCOMPOSITIONSTRING lpCompStrA,
    PTRANSMSG      pTransMsgSrc,
    PTRANSMSG      pTransMsgDest
    );

UINT
JTransCompositionW(
    LPINPUTCONTEXT lpIMC,
    LPCOMPOSITIONSTRING lpCompStrW,
    PTRANSMSG      pTransMsgSrc,
    PTRANSMSG      pTransMsgDest
    );

DWORD
CompStrWToUndetW(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrW,
    LPUNDETERMINESTRUCT lpUndetW
    );

DWORD
CompStrWToUndetA(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrW,
    LPUNDETERMINESTRUCT lpUndetA
    );

DWORD
CompStrWToStringExW(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrW,
    LPSTRINGEXSTRUCT lpStringExW
    );

DWORD
CompStrWToStringExA(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrW,
    LPSTRINGEXSTRUCT lpStringExA
    );

DWORD
CompStrWToStringW(
    LPCOMPOSITIONSTRING lpCompStrW,
    LPWSTR lpStringW
    );

DWORD
CompStrWToStringA(
    LPCOMPOSITIONSTRING lpCompStrW,
    LPSTR lpStringA
    );

VOID
CompStrWToCharW(
    HWND hWnd,
    LPCOMPOSITIONSTRING lpCompStrW
    );

VOID
CompStrWToCharA(
    HWND hWnd,
    LPCOMPOSITIONSTRING lpCompStrW
    );

DWORD
CompStrAToUndetA(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrA,
    LPUNDETERMINESTRUCT lpUndetA
    );

DWORD
CompStrAToUndetW(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrA,
    LPUNDETERMINESTRUCT lpUndetW
    );

DWORD
CompStrAToStringExA(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrA,
    LPSTRINGEXSTRUCT lpStringExA
    );

DWORD
CompStrAToStringExW(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrA,
    LPSTRINGEXSTRUCT lpStringExW
    );

DWORD
CompStrAToStringA(
    LPCOMPOSITIONSTRING lpCompStrA,
    LPSTR lpStringA
    );

DWORD
CompStrAToStringW(
    LPCOMPOSITIONSTRING lpCompStrA,
    LPWSTR lpStringW
    );

VOID
CompStrAToCharA(
    HWND hWnd,
    LPCOMPOSITIONSTRING lpCompStrA
    );

VOID
CompStrAToCharW(
    HWND hWnd,
    LPCOMPOSITIONSTRING lpCompStrA
    );


UINT
JTransCompositionA(
    LPINPUTCONTEXT lpIMC,
    LPCOMPOSITIONSTRING lpCompStrA,
    PTRANSMSG      pTransMsgSrc,
    PTRANSMSG      pTransMsgDest
    )
{
    UINT i = 0;
    int iNum = 0;
    DWORD dwSize;
    HWND hWnd;
    WORD wTextLen = 0;
    BOOL fDoneUndet = FALSE;
    BOOL fDoneDet = FALSE;
    DWORD dwGCS;
    BOOL bAnsiWnd;

    hWnd = (HWND)lpIMC->hWnd;

    if (!IsWindow(hWnd))
        return 0;

    bAnsiWnd = (! IsWindowUnicode(hWnd)) ? TRUE : FALSE;

    dwGCS = (DWORD)pTransMsgSrc->lParam;

    if (lpIMC->fdw31Compat & F31COMPAT_MCWHIDDEN)
    {
        if (bAnsiWnd) {
            dwSize = CompStrAToUndetA(dwGCS, lpCompStrA, NULL);
            if (dwSize != 0) {
                HGLOBAL hUndetA = NULL;
                LPUNDETERMINESTRUCT lpUndetA;

                if (hUndetA = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                    if (lpUndetA = (LPUNDETERMINESTRUCT)GlobalLock(hUndetA)) {
                        CompStrAToUndetA(dwGCS, lpCompStrA, lpUndetA);
                        fDoneUndet = TRUE;
                        GlobalUnlock(hUndetA);

                        if (SendMessageA(hWnd,WM_IME_REPORT,IR_UNDETERMINE, (LPARAM)hUndetA)) {
                            GlobalFree(hUndetA);
                            return 0;
                        }
                    }
                    GlobalFree(hUndetA);
                }
            }
        }
        else {
            dwSize = CompStrAToUndetW(dwGCS, lpCompStrA, NULL);
            if (dwSize != 0) {
                HGLOBAL hUndetW = NULL;
                LPUNDETERMINESTRUCT lpUndetW;

                if (hUndetW = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                    if (lpUndetW = (LPUNDETERMINESTRUCT)GlobalLock(hUndetW)) {
                        CompStrAToUndetW(dwGCS, lpCompStrA, lpUndetW);
                        fDoneUndet = TRUE;
                        GlobalUnlock(hUndetW);

                        if (SendMessageW(hWnd,WM_IME_REPORT,IR_UNDETERMINE, (LPARAM)hUndetW)) {
                            GlobalFree(hUndetW);
                            return 0;
                        }
                    }
                    GlobalFree(hUndetW);
                }
            }
        }
    }

    //
    // This is generate result string routine.
    // This should be same as WINNLSSendString of WIN3.1.
    //

    if (dwGCS & GCS_RESULTSTR)
    {
        //
        // Can we generate IR_STRINGEX ?
        //

        if (dwGCS & GCS_RESULTREADSTR)
        {
            if (bAnsiWnd) {
                dwSize = CompStrAToStringExA(dwGCS, lpCompStrA, NULL);
                if (dwSize != 0) {
                    HGLOBAL hStringExA = NULL;
                    LPSTRINGEXSTRUCT lpStringExA;

                    if (hStringExA = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                        if (lpStringExA = (LPSTRINGEXSTRUCT)GlobalLock(hStringExA)) {
                            CompStrAToStringExA(dwGCS, lpCompStrA, lpStringExA);
                            GlobalUnlock(hStringExA);

                            if (SendMessageA(hWnd,WM_IME_REPORT,IR_STRINGEX, (LPARAM)hStringExA))
                            {
                                GlobalFree(hStringExA);
                                fDoneDet = TRUE;
                                goto jtc_exit_30;
                            }
                        }
                        GlobalFree(hStringExA);
                    }
                }
            }
            else {
                dwSize = CompStrAToStringExW(dwGCS, lpCompStrA, NULL);
                if (dwSize != 0) {
                    HGLOBAL hStringExW = NULL;
                    LPSTRINGEXSTRUCT lpStringExW;

                    if (hStringExW = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                        if (lpStringExW = (LPSTRINGEXSTRUCT)GlobalLock(hStringExW)) {
                            CompStrAToStringExW(dwGCS, lpCompStrA, lpStringExW);
                            GlobalUnlock(hStringExW);

                            if (SendMessageW(hWnd,WM_IME_REPORT,IR_STRINGEX, (LPARAM)hStringExW))
                            {
                                GlobalFree(hStringExW);
                                fDoneDet = TRUE;
                                goto jtc_exit_30;
                            }
                        }
                        GlobalFree(hStringExW);
                    }
                }
            }
        }

        //
        // generate IR_STRING
        //

        if (bAnsiWnd) {
            dwSize = CompStrAToStringA(lpCompStrA, NULL);
            if (dwSize != 0) {
                HGLOBAL hStringA = NULL;
                LPSTR lpStringA;

                if (hStringA = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                    if (lpStringA = (LPSTR)GlobalLock(hStringA)) {
                        CompStrAToStringA(lpCompStrA, lpStringA);
                        GlobalUnlock(hStringA);

                        if (SendMessageA(hWnd,WM_IME_REPORT,IR_STRING, (LPARAM)hStringA))
                        {
                            GlobalFree(hStringA);
                            fDoneDet = TRUE;
                            goto jtc_exit_30;
                        }
                    }
                    GlobalFree(hStringA);
                }
            }
            else {
                return 0;
            }
        }
        else {
            dwSize = CompStrAToStringW(lpCompStrA, NULL);
            if (dwSize != 0) {
                HGLOBAL hStringW = NULL;
                LPWSTR lpStringW;

                if (hStringW = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                    if (lpStringW = (LPWSTR)GlobalLock(hStringW)) {
                        CompStrAToStringW(lpCompStrA, lpStringW);
                        GlobalUnlock(hStringW);

                        if (SendMessageW(hWnd,WM_IME_REPORT,IR_STRING, (LPARAM)hStringW))
                        {
                            GlobalFree(hStringW);
                            fDoneDet = TRUE;
                            goto jtc_exit_30;
                        }
                    }
                    GlobalFree(hStringW);
                }
            }
            else {
                return 0;
            }
        }

        //
        // generate IR_DBCSCHAR/IR_STRINGSTART/WM_CHAR/IR_STRINGEND
        //

        if (bAnsiWnd) {
            CompStrAToCharA(hWnd, lpCompStrA);
        }
        else {
            CompStrAToCharW(hWnd, lpCompStrA);
        }

        fDoneDet = TRUE;
    }


    if (!fDoneUndet && !fDoneDet)
    {
        *pTransMsgDest = *pTransMsgSrc;
        iNum++;
    }

jtc_exit_30:

    if (!fDoneUndet && fDoneDet && (dwGCS & GCS_COMPSTR))
    {
        pTransMsgDest->message = pTransMsgSrc->message;
        pTransMsgDest->wParam  = pTransMsgSrc->wParam;
        pTransMsgDest->lParam  = (LPARAM)(dwGCS & ~(GCS_RESULT | GCS_RESULTREAD));
        iNum++;
    }

    return iNum;
}


UINT
JTransCompositionW(
    LPINPUTCONTEXT lpIMC,
    LPCOMPOSITIONSTRING lpCompStrW,
    PTRANSMSG      pTransMsgSrc,
    PTRANSMSG      pTransMsgDest
    )
{
    UINT i = 0;
    int iNum = 0;
    DWORD dwSize;
    HWND hWnd;
    WORD wTextLen = 0;
    BOOL fDoneUndet = FALSE;
    BOOL fDoneDet = FALSE;
    DWORD dwGCS;
    BOOL bAnsiWnd;

    hWnd = (HWND)lpIMC->hWnd;

    if (!IsWindow(hWnd))
        return 0;

    bAnsiWnd = (! IsWindowUnicode(hWnd)) ? TRUE : FALSE;

    dwGCS = (DWORD)pTransMsgSrc->lParam;

    if (lpIMC->fdw31Compat & F31COMPAT_MCWHIDDEN)
    {
        if (bAnsiWnd) {
            dwSize = CompStrWToUndetA(dwGCS, lpCompStrW, NULL);
            if (dwSize != 0) {
                HGLOBAL hUndetA = NULL;
                LPUNDETERMINESTRUCT lpUndetA;

                if (hUndetA = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                    if (lpUndetA = (LPUNDETERMINESTRUCT)GlobalLock(hUndetA)) {
                        CompStrWToUndetA(dwGCS, lpCompStrW, lpUndetA);
                        fDoneUndet = TRUE;
                        GlobalUnlock(hUndetA);

                        if (SendMessageA(hWnd,WM_IME_REPORT,IR_UNDETERMINE, (LPARAM)hUndetA)) {
                            GlobalFree(hUndetA);
                            return 0;
                        }
                    }
                    GlobalFree(hUndetA);
                }
            }
        }
        else {
            dwSize = CompStrWToUndetW(dwGCS, lpCompStrW, NULL);
            if (dwSize != 0) {
                HGLOBAL hUndetW = NULL;
                LPUNDETERMINESTRUCT lpUndetW;

                if (hUndetW = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                    if (lpUndetW = (LPUNDETERMINESTRUCT)GlobalLock(hUndetW)) {
                        CompStrWToUndetW(dwGCS, lpCompStrW, lpUndetW);
                        fDoneUndet = TRUE;
                        GlobalUnlock(hUndetW);

                        if (SendMessageW(hWnd,WM_IME_REPORT,IR_UNDETERMINE, (LPARAM)hUndetW)) {
                            GlobalFree(hUndetW);
                            return 0;
                        }
                    }
                    GlobalFree(hUndetW);
                }
            }
        }
    }

    //
    // This is generate result string routine.
    // This should be same as WINNLSSendString of WIN3.1.
    //

    if (dwGCS & GCS_RESULTSTR)
    {
        //
        // Can we generate IR_STRINGEX ?
        //

        if (dwGCS & GCS_RESULTREADSTR)
        {
            if (bAnsiWnd) {
                dwSize = CompStrWToStringExA(dwGCS, lpCompStrW, NULL);
                if (dwSize != 0) {
                    HGLOBAL hStringExA = NULL;
                    LPSTRINGEXSTRUCT lpStringExA;

                    if (hStringExA = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                        if (lpStringExA = (LPSTRINGEXSTRUCT)GlobalLock(hStringExA)) {
                            CompStrWToStringExA(dwGCS, lpCompStrW, lpStringExA);
                            GlobalUnlock(hStringExA);

                            if (SendMessageA(hWnd,WM_IME_REPORT,IR_STRINGEX, (LPARAM)hStringExA))
                            {
                                GlobalFree(hStringExA);
                                fDoneDet = TRUE;
                                goto jtc_exit_30;
                            }
                        }
                        GlobalFree(hStringExA);
                    }
                }
            }
            else {
                dwSize = CompStrWToStringExW(dwGCS, lpCompStrW, NULL);
                if (dwSize != 0) {
                    HGLOBAL hStringExW = NULL;
                    LPSTRINGEXSTRUCT lpStringExW;

                    if (hStringExW = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                        if (lpStringExW = (LPSTRINGEXSTRUCT)GlobalLock(hStringExW)) {
                            CompStrWToStringExW(dwGCS, lpCompStrW, lpStringExW);
                            GlobalUnlock(hStringExW);

                            if (SendMessageW(hWnd,WM_IME_REPORT,IR_STRINGEX, (LPARAM)hStringExW))
                            {
                                GlobalFree(hStringExW);
                                fDoneDet = TRUE;
                                goto jtc_exit_30;
                            }
                        }
                        GlobalFree(hStringExW);
                    }
                }
            }
        }

        //
        // generate IR_STRING
        //

        if (bAnsiWnd) {
            dwSize = CompStrWToStringA(lpCompStrW, NULL);
            if (dwSize != 0) {
                HGLOBAL hStringA = NULL;
                LPSTR lpStringA;

                if (hStringA = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                    if (lpStringA = (LPSTR)GlobalLock(hStringA)) {
                        CompStrWToStringA(lpCompStrW, lpStringA);
                        GlobalUnlock(hStringA);

                        if (SendMessageA(hWnd,WM_IME_REPORT,IR_STRING, (LPARAM)hStringA))
                        {
                            GlobalFree(hStringA);
                            fDoneDet = TRUE;
                            goto jtc_exit_30;
                        }
                    }
                    GlobalFree(hStringA);
                }
            }
            else {
                return 0;
            }
        }
        else {
            dwSize = CompStrWToStringW(lpCompStrW, NULL);
            if (dwSize != 0) {
                HGLOBAL hStringW = NULL;
                LPWSTR lpStringW;

                if (hStringW = GlobalAlloc(GHND | GMEM_SHARE, dwSize)) {
                    if (lpStringW = (LPWSTR)GlobalLock(hStringW)) {
                        CompStrWToStringW(lpCompStrW, lpStringW);
                        GlobalUnlock(hStringW);

                        if (SendMessageW(hWnd,WM_IME_REPORT,IR_STRING, (LPARAM)hStringW))
                        {
                            GlobalFree(hStringW);
                            fDoneDet = TRUE;
                            goto jtc_exit_30;
                        }
                    }
                    GlobalFree(hStringW);
                }
            }
            else {
                return 0;
            }
        }

        //
        // generate IR_DBCSCHAR/IR_STRINGSTART/WM_CHAR/IR_STRINGEND
        //

        if (bAnsiWnd) {
            CompStrWToCharA(hWnd, lpCompStrW);
        }
        else {
            CompStrWToCharW(hWnd, lpCompStrW);
        }

        fDoneDet = TRUE;
    }


    if (!fDoneUndet && !fDoneDet)
    {
        *pTransMsgDest = *pTransMsgSrc;
        iNum++;
    }

jtc_exit_30:

    if (!fDoneUndet && fDoneDet && (dwGCS & GCS_COMPSTR))
    {
        pTransMsgDest->message = pTransMsgSrc->message;
        pTransMsgDest->wParam  = pTransMsgSrc->wParam;
        pTransMsgDest->lParam  = (LPARAM)(dwGCS & ~(GCS_RESULT | GCS_RESULTREAD));
        iNum++;
    }

    return iNum;
}



UINT
WINNLSTranslateMessageJ(
    UINT                uiNumMsg,
    PTRANSMSG           pTransMsg,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    BOOL bAnsiIMC
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PTRANSMSG       pTransMsgBuf, pTransMsgTemp;
    UINT            uiNewNum = 0;
    UINT            uiTempNum;
    DWORD           dwTempSize;
    HWND            hDefIMEWnd;
    UINT            i;
    BOOL            bAnsiWnd;

    hDefIMEWnd = ImmGetDefaultIMEWnd((HWND)lpIMC->hWnd);

    bAnsiWnd = (! IsWindowUnicode(lpIMC->hWnd)) ? TRUE : FALSE;

    dwTempSize = uiNumMsg * sizeof(TRANSMSG);

    //
    // Allocate one more TRANSMSG and ZEROINIT the whole thing!
    //

    pTransMsgBuf = (PTRANSMSG)ImmLocalAlloc( HEAP_ZERO_MEMORY,
                                             dwTempSize + sizeof(TRANSMSG)
                                           );
    if ( pTransMsgBuf == NULL )
        goto wtmsg2_j_10;

    RtlCopyMemory(pTransMsgBuf, pTransMsg, dwTempSize);
    pTransMsgTemp = pTransMsgBuf;

    //
    // When MCW_HIDDEN mode, WM_IME_ENDCOMPOSITION will be translated to
    // IR_UNDETERMINE with 0 string. So that, this message have to be
    // generated after all messages.
    //

    if (lpIMC->fdw31Compat & F31COMPAT_MCWHIDDEN) {

        for (i = 0; i < uiNumMsg; i++, pTransMsgTemp++) {
            if (pTransMsgTemp->message == WM_IME_ENDCOMPOSITION) {
                break;
            }
        }

        if (pTransMsgTemp->message == WM_IME_ENDCOMPOSITION) {

            PTRANSMSG pTransMsgSrc = pTransMsgTemp + 1;

            while (pTransMsgSrc->message != 0) {
                *pTransMsgTemp++ = *pTransMsgSrc++;
            }

            pTransMsgTemp->message = WM_IME_ENDCOMPOSITION;
            pTransMsgTemp->wParam  = 0L;
            pTransMsgTemp->lParam  = 0L;

        }

        pTransMsgTemp = pTransMsgBuf;
    }

    while (pTransMsgTemp->message != 0) {

        switch (pTransMsgTemp->message)
        {
            case WM_IME_COMPOSITION:

                if (bAnsiIMC)
                    uiTempNum = JTransCompositionA(lpIMC,lpCompStr,pTransMsgTemp,pTransMsg);
                else
                    uiTempNum = JTransCompositionW(lpIMC,lpCompStr,pTransMsgTemp,pTransMsg);

                uiNewNum  += uiTempNum;
                pTransMsg += uiTempNum;

                if ( !(lpIMC->fdw31Compat & F31COMPAT_MCWHIDDEN) )
                {
                    if ( lpIMC->cfCompForm.dwStyle != CFS_DEFAULT ) {
                        SendMessage((HWND)lpIMC->hWnd, WM_IME_REPORT, IR_CHANGECONVERT, 0L);
                    }
                }

                break;

            case WM_IME_STARTCOMPOSITION:

                if ( !(lpIMC->fdw31Compat & F31COMPAT_MCWHIDDEN) )
                {
                    if ( lpIMC->cfCompForm.dwStyle != CFS_DEFAULT ) {
                        SendMessage((HWND)lpIMC->hWnd, WM_IME_REPORT, IR_OPENCONVERT, 0L);
                    }

                    *pTransMsg++ = *pTransMsgTemp;
                    uiNewNum++;
                }

                break;

            case WM_IME_ENDCOMPOSITION:

                if ( !(lpIMC->fdw31Compat & F31COMPAT_MCWHIDDEN) )
                {
                    if ( lpIMC->cfCompForm.dwStyle != CFS_DEFAULT ) {
                        SendMessage((HWND)lpIMC->hWnd, WM_IME_REPORT, IR_CLOSECONVERT, 0L);
                    }

                    *pTransMsg++ = *pTransMsgTemp;
                    uiNewNum++;

                }
                else {

                    HWND hWnd = (HWND)lpIMC->hWnd;
                    HGLOBAL hUndet = 0L;

                    if (hUndet = GlobalAlloc(GHND | GMEM_SHARE, sizeof(UNDETERMINESTRUCT)))
                    {
                        if (! IsWindowUnicode(lpIMC->hWnd))
                            SendMessageA(hWnd,WM_IME_REPORT, IR_UNDETERMINE, (LPARAM)hUndet);
                        else
                            SendMessageW(hWnd,WM_IME_REPORT, IR_UNDETERMINE, (LPARAM)hUndet);

                        GlobalFree(hUndet);
                    }
                }

                break;

            case WM_IME_NOTIFY:

                switch (pTransMsgTemp->wParam)
                {
                    case IMN_OPENCANDIDATE:

                        //
                        // When 3.1 Application want to set MCW_HIDDEN,
                        // the candidate window of Chicago IME go way
                        // from the restangle of the composition string
                        // that will be drawn by the application.
                        //

                        if (IsWindow((HWND)lpIMC->hWnd) &&
                            (lpIMC->fdw31Compat & F31COMPAT_MCWHIDDEN)) {
                            CANDIDATEFORM cfCandForm;
                            DWORD i;
                            DWORD dwNumCand = 0;

                            for (i = 0; i < 32; i++)
                            {
                                //
                                // Only the opened candidate should be updated.
                                //
                                if (!(pTransMsgTemp->lParam & (01L << i)))
                                    continue;

                                cfCandForm.dwIndex = i;
                                cfCandForm.dwStyle = CFS_EXCLUDE;
                                cfCandForm.ptCurrentPos = lpIMC->cfCompForm.ptCurrentPos;
                                cfCandForm.rcArea       = lpIMC->cfCompForm.rcArea;
                                SendMessage(hDefIMEWnd, WM_IME_CONTROL, IMC_SETCANDIDATEPOS,
                                               (LPARAM)(LPCANDIDATEFORM)&cfCandForm);
                            }
                        }

                        break;

                    default :
                        break;
                }

                if (!(lpIMC->fdw31Compat & F31COMPAT_MCWHIDDEN)) {
                    *pTransMsg++ = *pTransMsgTemp;
                    uiNewNum++;
                }
                else {
                    //
                    // For win31 apps who set MCW_HIDDEN, we won't give them
                    // IMN_OPENCANDIDATE here. Instead, send it directly to the
                    // default IME window.
                    //
                    SendMessage( hDefIMEWnd, 
                                 pTransMsgTemp->message,
                                 pTransMsgTemp->wParam,
                                 pTransMsgTemp->lParam
                               );
                }

                break;

            default :
                *pTransMsg++ = *pTransMsgTemp;
                uiNewNum++;
                break;
        }

        pTransMsgTemp++;
    }

    ImmLocalFree(pTransMsgBuf);

wtmsg2_j_10:
    return (uiNewNum);
}


DWORD
CompStrAToUndetA(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrA,
    LPUNDETERMINESTRUCT lpUndetA
    )

/*++

Routine Description:

    Convert composition string (ANSI) to undetermine string (ANSI).

Arguments:

Return Value:

--*/

{
    DWORD dwPos;
    DWORD dwSize;
    UINT  i;

    dwSize = DWORD_ALIGN((sizeof(UNDETERMINESTRUCT)+1)) +
             DWORD_ALIGN(((lpCompStrA->dwResultStrLen+1) * sizeof(CHAR))) +
             DWORD_ALIGN((lpCompStrA->dwResultClauseLen+1)) +
             DWORD_ALIGN(((lpCompStrA->dwResultReadStrLen+1) * sizeof(CHAR))) +
             DWORD_ALIGN((lpCompStrA->dwResultReadClauseLen+1)) +
             DWORD_ALIGN((lpCompStrA->dwCompAttrLen+1)) +
             DWORD_ALIGN(((lpCompStrA->dwCompStrLen+1) * sizeof(CHAR)));

    if (lpUndetA == NULL) {
        return dwSize;
    }

    dwPos = DWORD_ALIGN((sizeof(UNDETERMINESTRUCT) + 1));
    lpUndetA->dwSize = dwSize;

    if (dwGCS & GCS_COMPSTR)
    {
        lpUndetA->uUndetTextLen = lpCompStrA->dwCompStrLen;
        lpUndetA->uUndetTextPos = dwPos;
        memcpy((PBYTE)lpUndetA   + dwPos,
               (PBYTE)lpCompStrA + lpCompStrA->dwCompStrOffset,
               lpCompStrA->dwCompStrLen * sizeof(CHAR)
              );
        *(LPSTR)((PBYTE)lpUndetA + dwPos + lpCompStrA->dwCompStrLen*sizeof(CHAR)) = '\0';
        dwPos += DWORD_ALIGN(((lpUndetA->uUndetTextLen+1)*sizeof(CHAR)));

        // Sometime Chicago IME does not generate GCS_COMPATTR
        // with GCS_COMPSTR. But uUndetAttrPos should be filled
        // when the UndetText is updated.
        if (lpCompStrA->dwCompAttrLen && !(dwGCS & GCS_COMPATTR))
            dwGCS |= GCS_COMPATTR;
    }

    if (dwGCS & GCS_COMPATTR)
    {
        lpUndetA->uUndetAttrPos = dwPos;
        memcpy((PBYTE)lpUndetA   + dwPos,
               (PBYTE)lpCompStrA + lpCompStrA->dwCompAttrOffset,
               lpCompStrA->dwCompAttrLen
              );
        dwPos += DWORD_ALIGN((lpUndetA->uUndetTextLen + 1));
    }

    if (dwGCS & GCS_CURSORPOS)
    {
        lpUndetA->uCursorPos = lpCompStrA->dwCursorPos;
    }

    if (dwGCS & GCS_DELTASTART)
    {
        lpUndetA->uDeltaStart = lpCompStrA->dwDeltaStart;
    }

    if (dwGCS & GCS_RESULTSTR)
    {
        lpUndetA->uDetermineTextLen = lpCompStrA->dwResultStrLen;
        lpUndetA->uDetermineTextPos = dwPos;
        memcpy((PBYTE)lpUndetA   + dwPos,
               (PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset,
               lpCompStrA->dwResultStrLen * sizeof(CHAR)
              );
        *(LPSTR)((PBYTE)lpUndetA + dwPos + lpCompStrA->dwResultStrLen*sizeof(CHAR)) = '\0';
        dwPos += DWORD_ALIGN(((lpUndetA->uDetermineTextLen + 1)*sizeof(CHAR)));
    }

    if ( (dwGCS & GCS_RESULTCLAUSE) &&
         (lpCompStrA->dwResultClauseLen > 0) )
    {
        LPDWORD lpw;
        LPDWORD lpdw;

        lpUndetA->uDetermineDelimPos = dwPos;

        lpw  = (LPDWORD)((PBYTE)lpUndetA + dwPos);
        lpdw = (LPDWORD)((PBYTE)lpCompStrA + lpCompStrA->dwResultClauseOffset);
        for (i = 0; i < (lpCompStrA->dwResultClauseLen / sizeof(DWORD)); i++)
            *lpw++ = *lpdw++;

        dwPos += DWORD_ALIGN((lpCompStrA->dwResultClauseLen + 1));
    }

    if (dwGCS & GCS_RESULTREADSTR)
    {
        lpUndetA->uYomiTextLen = lpCompStrA->dwResultReadStrLen;
        lpUndetA->uYomiTextPos = dwPos;
        memcpy((PBYTE)lpUndetA   + dwPos,
               (PBYTE)lpCompStrA + lpCompStrA->dwResultReadStrOffset,
               lpCompStrA->dwResultReadStrLen * sizeof(CHAR)
              );
        *(LPSTR)((PBYTE)lpUndetA + dwPos + lpCompStrA->dwResultReadStrLen*sizeof(CHAR)) = '\0';
        dwPos += DWORD_ALIGN(((lpUndetA->uYomiTextLen + 1)*sizeof(CHAR)));
    }

    if ( (dwGCS & GCS_RESULTREADCLAUSE) &&
         (lpCompStrA->dwResultReadClauseLen > 0) )
    {
        LPDWORD lpw;
        LPDWORD lpdw;

        lpUndetA->uYomiDelimPos = dwPos;

        lpw  = (LPDWORD)((PBYTE)lpUndetA + dwPos);
        lpdw = (LPDWORD)((PBYTE)lpCompStrA + lpCompStrA->dwResultReadClauseOffset);
        for (i = 0; i < (lpCompStrA->dwResultReadClauseLen / sizeof(DWORD)); i++)
            *lpw++ = *lpdw++;

        dwPos += DWORD_ALIGN((lpCompStrA->dwResultReadClauseLen + 1));
    }

    return dwSize;
}

DWORD
CompStrAToUndetW(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrA,
    LPUNDETERMINESTRUCT lpUndetW
    )

/*++

Routine Description:

    Convert composition string (ANSI) to undetermine string (Unicode).

Arguments:

Return Value:

--*/

{
    DWORD dwPos;
    DWORD dwSize;
    UINT  i;

    dwSize = DWORD_ALIGN((sizeof(UNDETERMINESTRUCT)+1)) +
             DWORD_ALIGN(((lpCompStrA->dwResultStrLen+1) * sizeof(WCHAR))) +
             DWORD_ALIGN((lpCompStrA->dwResultClauseLen+1)) +
             DWORD_ALIGN(((lpCompStrA->dwResultReadStrLen+1) * sizeof(WCHAR))) +
             DWORD_ALIGN((lpCompStrA->dwResultReadClauseLen+1)) +
             DWORD_ALIGN((lpCompStrA->dwCompAttrLen * 2)) +
             DWORD_ALIGN(((lpCompStrA->dwCompStrLen+1) * sizeof(WCHAR)));

    if (lpUndetW == NULL) {
        return dwSize;
    }

    dwPos = DWORD_ALIGN((sizeof(UNDETERMINESTRUCT) + 1));
    lpUndetW->dwSize = dwSize;

    if (dwGCS & GCS_COMPSTR)
    {
        i = MultiByteToWideChar( CP_ACP,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwCompStrOffset),  // src
                                (INT)lpCompStrA->dwCompStrLen,
                                (LPWSTR)((PBYTE)lpUndetW + dwPos),                         // dest
                                (INT)dwSize - dwPos);
        ((LPWSTR)((PBYTE)lpUndetW + dwPos))[i] = L'\0';
        lpUndetW->uUndetTextLen = i;
        lpUndetW->uUndetTextPos = dwPos;
        dwPos += DWORD_ALIGN(((lpUndetW->uUndetTextLen + 1)*sizeof(WCHAR)));

        // Sometime Chicago IME does not generate GCS_COMPATTR
        // with GCS_COMPSTR. But uUndetAttrPos should be filled
        // when the UndetText is updated.
        if (lpCompStrA->dwCompAttrLen && !(dwGCS & GCS_COMPATTR))
            dwGCS |= GCS_COMPATTR;
    }

    if (dwGCS & GCS_COMPATTR)
    {
        if (lpUndetW->uUndetTextLen != 0) {
            LPWSTR lpwszUndetText;
            PBYTE  lpAttrW;
            PBYTE  lpAttrA;
            WCHAR  wc;
            ULONG  MultiByteSize;

            lpwszUndetText = (LPWSTR)((PBYTE)lpUndetW + lpUndetW->uUndetTextPos);
            lpAttrA = (PBYTE)lpCompStrA + lpCompStrA->dwCompAttrOffset;
            lpAttrW = (PBYTE)lpUndetW   + dwPos;

            while (wc=*lpwszUndetText++) {
                RtlUnicodeToMultiByteSize(&MultiByteSize, &wc, sizeof(WCHAR));
                if (MultiByteSize == 2) {
                    *lpAttrW++ = *lpAttrA;
                    lpAttrA += 2;
                }
                else {
                    *lpAttrW++ = *lpAttrA++;
                }
            }

            lpUndetW->uUndetAttrPos = dwPos;
            dwPos += DWORD_ALIGN((lpUndetW->uUndetTextLen + 1));
        }
    }

    if (dwGCS & GCS_CURSORPOS)
    {
        if (lpCompStrA->dwCursorPos != -1) {
            lpUndetW->uCursorPos = CalcCharacterPositionAtoW(lpCompStrA->dwCursorPos,
                                                             (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwCompStrOffset),
                                                             CP_ACP
                                                            );
        }
        else {
            lpUndetW->uCursorPos = lpCompStrA->dwCursorPos;
        }
    }

    if (dwGCS & GCS_DELTASTART)
    {
        if (lpCompStrA->dwDeltaStart != -1) {
            lpUndetW->uDeltaStart = CalcCharacterPositionAtoW(lpCompStrA->dwDeltaStart,
                                                              (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwCompStrOffset),
                                                              CP_ACP
                                                             );
        }
        else {
            lpUndetW->uDeltaStart = lpCompStrA->dwDeltaStart;
        }
    }

    if (dwGCS & GCS_RESULTSTR)
    {
        i = MultiByteToWideChar( CP_ACP,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset),  // src
                                (INT)lpCompStrA->dwResultStrLen,
                                (LPWSTR)((PBYTE)lpUndetW + dwPos),                           // dest
                                (INT)dwSize - dwPos);
        ((LPWSTR)((PBYTE)lpUndetW + dwPos))[i] = L'\0';
        lpUndetW->uDetermineTextLen = i;
        lpUndetW->uDetermineTextPos = dwPos;
        dwPos += DWORD_ALIGN(((lpUndetW->uDetermineTextLen + 1)*sizeof(WCHAR)));
    }

    if ( (dwGCS & GCS_RESULTCLAUSE) &&
         (lpCompStrA->dwResultClauseLen > 0) )
    {
        if (lpUndetW->uDetermineTextLen != 0) {
            LPDWORD lpw;
            LPDWORD lpdw;

            lpw  = (LPDWORD)((PBYTE)lpUndetW + dwPos);
            lpdw = (LPDWORD)((PBYTE)lpCompStrA + lpCompStrA->dwResultClauseOffset);

            for (i = 0; i < (lpCompStrA->dwResultClauseLen / sizeof(DWORD)); i++) {
                *lpw++ = CalcCharacterPositionAtoW(*lpdw++,
                                                   (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset),
                                                   CP_ACP
                                                  );
            }

            lpUndetW->uDetermineDelimPos = dwPos;
            dwPos += DWORD_ALIGN((lpCompStrA->dwResultClauseLen + 1));
        }
    }

    if (dwGCS & GCS_RESULTREADSTR)
    {
        i = MultiByteToWideChar( CP_ACP,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultReadStrOffset),  // src
                                (INT)lpCompStrA->dwResultReadStrLen,
                                (LPWSTR)((PBYTE)lpUndetW + dwPos),                               // dest
                                (INT)dwSize - dwPos);
        ((LPWSTR)((PBYTE)lpUndetW + dwPos))[i] = L'\0';
        lpUndetW->uYomiTextLen = i;
        lpUndetW->uYomiTextPos = dwPos;
        dwPos += DWORD_ALIGN(((lpUndetW->uYomiTextLen + 1)*sizeof(WCHAR)));
    }

    if ( (dwGCS & GCS_RESULTREADCLAUSE) &&
         (lpCompStrA->dwResultReadClauseLen > 0) )
    {
        if (lpUndetW->uYomiTextLen != 0) {
            LPDWORD lpw;
            LPDWORD lpdw;

            lpw  = (LPDWORD)((PBYTE)lpUndetW + dwPos);
            lpdw = (LPDWORD)((PBYTE)lpCompStrA + lpCompStrA->dwResultReadClauseOffset);

            for (i = 0; i < (lpCompStrA->dwResultReadClauseLen / sizeof(DWORD)); i++) {
                *lpw++ = CalcCharacterPositionAtoW(*lpdw++,
                                                   (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultReadStrOffset),
                                                   CP_ACP
                                                  );
            }

            lpUndetW->uYomiDelimPos = dwPos;
            dwPos += DWORD_ALIGN((lpCompStrA->dwResultReadClauseLen + 1));
        }
    }

    return dwSize;
}


DWORD
CompStrAToStringExA(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrA,
    LPSTRINGEXSTRUCT lpStringExA
    )

/*++

Routine Description:

    Convert composition string (ANSI) to StringEx (ANSI).

Arguments:

Return Value:

--*/

{
    DWORD dwPos;
    DWORD dwSize;
    UINT  i;

    dwSize = DWORD_ALIGN((sizeof(STRINGEXSTRUCT)+1)) +
             DWORD_ALIGN(((lpCompStrA->dwResultStrLen+1) * sizeof(CHAR))) +
             DWORD_ALIGN(lpCompStrA->dwResultClauseLen+1) +
             DWORD_ALIGN(((lpCompStrA->dwResultReadStrLen+1) * sizeof(CHAR))) +
             DWORD_ALIGN(lpCompStrA->dwResultReadClauseLen+1);

    if (lpStringExA == NULL) {
        return dwSize;
    }

    dwPos = DWORD_ALIGN(sizeof(STRINGEXSTRUCT) + 1);
    lpStringExA->dwSize = dwSize;

    lpStringExA->uDeterminePos = dwPos;
    memcpy((PBYTE)lpStringExA + dwPos,
           (PBYTE)lpCompStrA  + lpCompStrA->dwResultStrOffset,
           lpCompStrA->dwResultStrLen * sizeof(CHAR)
          );
    *(LPSTR)((PBYTE)lpStringExA + dwPos + lpCompStrA->dwResultStrLen*sizeof(CHAR)) = '\0';
    dwPos += DWORD_ALIGN(((lpCompStrA->dwResultStrLen + 1)*sizeof(CHAR)));

    if ( (dwGCS & GCS_RESULTCLAUSE) &&
         (lpCompStrA->dwResultClauseLen > 0) )
    {
        LPDWORD lpw;
        LPDWORD lpdw;

        lpStringExA->uDetermineDelimPos = dwPos;

        lpw  = (LPDWORD)((PBYTE)lpStringExA + dwPos);
        lpdw = (LPDWORD)((PBYTE)lpCompStrA + lpCompStrA->dwResultClauseOffset);
        for (i = 0; i < (lpCompStrA->dwResultClauseLen / sizeof(DWORD)); i++)
            *lpw++ = *lpdw++;

        dwPos += DWORD_ALIGN((lpCompStrA->dwResultClauseLen + 1));
    }

    lpStringExA->uYomiPos = dwPos;
    memcpy((PBYTE)lpStringExA + dwPos,
           (PBYTE)lpCompStrA  + lpCompStrA->dwResultReadStrOffset,
           lpCompStrA->dwResultReadStrLen * sizeof(CHAR)
          );
    *(LPSTR)((PBYTE)lpStringExA + dwPos + lpCompStrA->dwResultReadStrLen*sizeof(CHAR)) = '\0';
    dwPos += DWORD_ALIGN(((lpCompStrA->dwResultReadStrLen + 1)*sizeof(CHAR)));

    if ( (dwGCS & GCS_RESULTREADCLAUSE) &&
         (lpCompStrA->dwResultReadClauseLen > 0) )
    {
        LPDWORD lpw;
        LPDWORD lpdw;

        lpStringExA->uYomiDelimPos = dwPos;

        lpw  = (LPDWORD)((PBYTE)lpStringExA + dwPos);
        lpdw = (LPDWORD)((PBYTE)lpCompStrA + lpCompStrA->dwResultReadClauseOffset);
        for (i = 0; i < (lpCompStrA->dwResultReadClauseLen / sizeof(DWORD)); i++)
            *lpw++ = *lpdw++;
    }

    return dwSize;
}

DWORD
CompStrAToStringExW(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrA,
    LPSTRINGEXSTRUCT lpStringExW
    )

/*++

Routine Description:

    Convert composition string (ANSI) to StringEx (Unicode).

Arguments:

Return Value:

--*/

{
    DWORD dwPos;
    DWORD dwSize;
    DWORD dwLen;
    UINT  i;

    dwSize = DWORD_ALIGN((sizeof(STRINGEXSTRUCT)+1)) +
             (lpCompStrA->dwResultStrLen > 0 ? DWORD_ALIGN(((lpCompStrA->dwResultStrLen+1) * sizeof(WCHAR))) : 0) +
             (lpCompStrA->dwResultClauseLen > 0 ? DWORD_ALIGN(lpCompStrA->dwResultClauseLen+1) : 0) +
             (lpCompStrA->dwResultReadStrLen > 0 ? DWORD_ALIGN(((lpCompStrA->dwResultReadStrLen+1) * sizeof(WCHAR))) : 0)+
             (lpCompStrA->dwResultReadClauseLen > 0 ? DWORD_ALIGN(lpCompStrA->dwResultReadClauseLen+1) : 0);

    if (lpStringExW == NULL) {
        return dwSize;
    }

    dwPos = DWORD_ALIGN(sizeof(STRINGEXSTRUCT) + 1);
    lpStringExW->dwSize = dwSize;

    if (lpCompStrA->dwResultStrLen > 0) {
        i = MultiByteToWideChar( CP_ACP,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset),  // src
                                (INT)lpCompStrA->dwResultStrLen,
                                (LPWSTR)((PBYTE)lpStringExW + dwPos),                        // dest
                                (INT)dwSize - dwPos);
        ((LPWSTR)((PBYTE)lpStringExW + dwPos))[i] = L'\0';
        dwLen = i;
        lpStringExW->uDeterminePos = dwPos;
        dwPos += DWORD_ALIGN(((dwLen + 1)*sizeof(WCHAR)));
    } else {
        dwLen = 0;
        lpStringExW->uDeterminePos = 0;
    }

    if ( (dwGCS & GCS_RESULTCLAUSE) &&
         (lpCompStrA->dwResultClauseLen > 0) )
    {
        if (dwLen != 0 && lpCompStrA->dwResultClauseLen > 0) {
            LPDWORD lpw;
            LPDWORD lpdw;

            lpw  = (LPDWORD)((PBYTE)lpStringExW + dwPos);
            lpdw = (LPDWORD)((PBYTE)lpCompStrA + lpCompStrA->dwResultClauseOffset);

            for (i = 0; i < (lpCompStrA->dwResultClauseLen / sizeof(DWORD)); i++) {
                *lpw++ = CalcCharacterPositionAtoW(*lpdw++,
                                                   (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset),
                                                   CP_ACP
                                                  );
            }

            lpStringExW->uDetermineDelimPos = dwPos;
            dwPos += DWORD_ALIGN((lpCompStrA->dwResultClauseLen + 1));
        }
    }

    if (lpCompStrA->dwResultReadStrLen > 0) {
        i = MultiByteToWideChar( CP_ACP,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultReadStrOffset),  // src
                                (INT)lpCompStrA->dwResultReadStrLen,
                                (LPWSTR)((PBYTE)lpStringExW + dwPos),                            // dest
                                (INT)dwSize - dwPos);
        ((LPWSTR)((PBYTE)lpStringExW + dwPos))[i] = L'\0';
        dwLen = i;
        lpStringExW->uYomiPos = dwPos;
        dwPos += DWORD_ALIGN(((dwLen + 1)*sizeof(WCHAR)));
    } else {
        dwLen = 0;
        lpStringExW->uYomiPos = 0;
    }

    if ( (dwGCS & GCS_RESULTREADCLAUSE) &&
         (lpCompStrA->dwResultReadClauseLen > 0) )
    {
        if (dwLen != 0 && lpCompStrA->dwResultReadClauseLen > 0) {
            LPDWORD lpw;
            LPDWORD lpdw;

            lpw  = (LPDWORD)((PBYTE)lpStringExW + dwPos);
            lpdw = (LPDWORD)((PBYTE)lpCompStrA + lpCompStrA->dwResultReadClauseOffset);

            for (i = 0; i < (lpCompStrA->dwResultReadClauseLen / sizeof(DWORD)); i++) {
                *lpw++ = CalcCharacterPositionAtoW(*lpdw++,
                                                   (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultReadStrOffset),
                                                   CP_ACP
                                                  );
            }

            lpStringExW->uYomiDelimPos = dwPos;
            dwPos += DWORD_ALIGN((lpCompStrA->dwResultReadClauseLen + 1));
        }
    }

    return dwSize;
}

DWORD
CompStrAToStringA(
    LPCOMPOSITIONSTRING lpCompStrA,
    LPSTR lpStringA
    )

/*++

Routine Description:

    Convert composition string (ANSI) to String (ANSI).

Arguments:

Return Value:

--*/

{
    LPSTR lpszString;
    DWORD dwSize;

    lpszString = (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset);
    dwSize = lpCompStrA->dwResultStrLen;

    if (lpStringA == NULL) {
        return ((dwSize + 1) * sizeof(CHAR));
    }

    memcpy((PBYTE)lpStringA,
           (PBYTE)lpszString,
           (dwSize * sizeof(CHAR))
          );
    lpStringA[dwSize] = '\0';

    return ((dwSize + 1) * sizeof(CHAR));
}

DWORD
CompStrAToStringW(
    LPCOMPOSITIONSTRING lpCompStrA,
    LPWSTR lpStringW
    )

/*++

Routine Description:

    Convert composition string (ANSI) to String (Unicode).

Arguments:

Return Value:

--*/

{
    LPSTR lpszString;
    DWORD dwSize;
    UINT  i;

    lpszString = (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset);

    i = MultiByteToWideChar( CP_ACP,
                            (DWORD)MB_PRECOMPOSED,
                            (LPSTR)lpszString,              // src
                            (INT)lpCompStrA->dwResultStrLen,
                            (LPWSTR)lpStringW,              // dest
                            (INT)0);

    if (lpStringW == NULL) {
        dwSize = (i+1) * sizeof(WCHAR);
    }
    else {
        dwSize = (i+1) * sizeof(WCHAR);

        i = MultiByteToWideChar( CP_ACP,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszString,              // src
                                (INT)lpCompStrA->dwResultStrLen,
                                (LPWSTR)lpStringW,              // dest
                                (INT)dwSize);

        lpStringW[i] = L'\0';
        dwSize = (i+1) * sizeof(WCHAR);
    }

    return dwSize;
}

VOID
CompStrAToCharA(
    HWND hWnd,
    LPCOMPOSITIONSTRING lpCompStrA
    )

/*++

Routine Description:

    Convert composition string (ANSI) to WM_CHAR (ANSI).

Arguments:

Return Value:

--*/

{
    LPSTR lpszString;
    BOOL  fDBCSWmChar = FALSE;
    WORD  wDBCSChar;
    BYTE  szAscii[3];

    lpszString = (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset);

    // IR_DBCSCHAR: If the app reply to this message with TRUE, we can
    // queue up double byte character in a WM_CHAR message.
    if ( GetClientInfo()->dwExpWinVer >= 0x030A ) {
        fDBCSWmChar = (BOOL)SendMessageA( hWnd,WM_IME_REPORT,IR_DBCSCHAR, 0L);
    }

    // Send IR_STRINGSTART prior to anything.
    PostMessageA( hWnd, WM_IME_REPORT, IR_STRINGSTART, 0L );


    while(szAscii[0]=*lpszString)
    {
        if( *CharNextA(lpszString) == 0 )
        {
            PostMessageA( hWnd, WM_IME_REPORT, IR_STRINGEND, 0L );
        }
        if( IsDBCSLeadByte( szAscii[0] ) )
        {
            szAscii[1] = *((PBYTE)(lpszString+1));

            //  If fDBCSWmChar==TRUE, The app can recieve WM_CHARs which
            // have double byte code in wParam.
            if ( fDBCSWmChar )
            {
                // It's necessary to swap bytes to put 1st byte into upper
                // part of wParam, and 2nd byte into lower part.
                wDBCSChar = MAKEWORD(szAscii[1], szAscii[0]);
                PostMessageA( hWnd, WM_CHAR, (WPARAM)wDBCSChar|WMCR_IR_DBCSCHAR, 1L );
            }
            else
            {
                // Send each byte on a WM_CHAR
                PostMessageA( hWnd, WM_CHAR, (WPARAM)(szAscii[0]), 1L);
                PostMessageA( hWnd, WM_CHAR, (WPARAM)(szAscii[1]), 1L);
            }
        }
        else
        {
            PostMessageA( hWnd, WM_CHAR, (WPARAM)(szAscii[0]), 1L);
        }
        lpszString = CharNextA(lpszString);
    }
}

VOID
CompStrAToCharW(
    HWND hWnd,
    LPCOMPOSITIONSTRING lpCompStrA
    )

/*++

Routine Description:

    Convert composition string (ANSI) to WM_CHAR (Unicode).

Arguments:

Return Value:

--*/

{
    LPSTR lpszString;
    UINT  i;
    BYTE  c;
    WORD  wszUnicode[2];

    lpszString = (LPSTR)((PBYTE)lpCompStrA + lpCompStrA->dwResultStrOffset);

    // IR_DBCSCHAR: If the app reply to this message with TRUE, we can
    // queue up double byte character in a WM_CHAR message.
    // SendMessageW( hWnd,WM_IME_REPORT,IR_DBCSCHAR, 0L);

    // Send IR_STRINGSTART prior to anything.
    PostMessageW( hWnd, WM_IME_REPORT, IR_STRINGSTART, 0L );


    while(c=*lpszString)
    {
        if( *CharNextA(lpszString) == 0 )
        {
            PostMessageW( hWnd, WM_IME_REPORT, IR_STRINGEND, 0L );
        }
        if( IsDBCSLeadByte( c ) ) {
            i = MultiByteToWideChar( CP_ACP,
                                    (DWORD)MB_PRECOMPOSED,
                                    (LPSTR)lpszString,  // src
                                    (INT)2,
                                    (LPWSTR)wszUnicode, // dest
                                    (INT)sizeof(wszUnicode));
        }
        else {
            i = MultiByteToWideChar( CP_ACP,
                                    (DWORD)MB_PRECOMPOSED,
                                    (LPSTR)lpszString,  // src
                                    (INT)1,
                                    (LPWSTR)wszUnicode, // dest
                                    (INT)sizeof(wszUnicode));
        }
        if (i != 0) {
            PostMessageW( hWnd, WM_CHAR, (WPARAM)(wszUnicode[0]), 1L);
        }
        lpszString = CharNextA(lpszString);
    }
}

DWORD
CompStrWToUndetW(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrW,
    LPUNDETERMINESTRUCT lpUndetW
    )

/*++

Routine Description:

    Convert composition string (Unicode) to undetermine string (Unicode).

Arguments:

Return Value:

--*/

{
    DWORD dwPos;
    DWORD dwSize;
    UINT  i;

    dwSize = DWORD_ALIGN((sizeof(UNDETERMINESTRUCT)+1)) +
             DWORD_ALIGN(((lpCompStrW->dwResultStrLen+1) * sizeof(WCHAR))) +
             DWORD_ALIGN((lpCompStrW->dwResultClauseLen+1)) +
             DWORD_ALIGN(((lpCompStrW->dwResultReadStrLen+1) * sizeof(WCHAR))) +
             DWORD_ALIGN((lpCompStrW->dwResultReadClauseLen+1)) +
             DWORD_ALIGN((lpCompStrW->dwCompAttrLen+1)) +
             DWORD_ALIGN(((lpCompStrW->dwCompStrLen+1) * sizeof(WCHAR)));

    if (lpUndetW == NULL) {
        return dwSize;
    }

    dwPos = DWORD_ALIGN((sizeof(UNDETERMINESTRUCT) + 1));
    lpUndetW->dwSize = dwSize;

    if (dwGCS & GCS_COMPSTR)
    {
        lpUndetW->uUndetTextLen = lpCompStrW->dwCompStrLen;
        lpUndetW->uUndetTextPos = dwPos;
        memcpy((PBYTE)lpUndetW   + dwPos,
               (PBYTE)lpCompStrW + lpCompStrW->dwCompStrOffset,
               lpCompStrW->dwCompStrLen * sizeof(WCHAR)
              );
        *(LPWSTR)((PBYTE)lpUndetW + dwPos + lpCompStrW->dwCompStrLen*sizeof(WCHAR)) = L'\0';
        dwPos += DWORD_ALIGN(((lpUndetW->uUndetTextLen+1)*sizeof(WCHAR)));

        // Sometime Chicago IME does not generate GCS_COMPATTR
        // with GCS_COMPSTR. But uUndetAttrPos should be filled
        // when the UndetText is updated.
        if (lpCompStrW->dwCompAttrLen && !(dwGCS & GCS_COMPATTR))
            dwGCS |= GCS_COMPATTR;
    }

    if (dwGCS & GCS_COMPATTR)
    {
        lpUndetW->uUndetAttrPos = dwPos;
        memcpy((PBYTE)lpUndetW   + dwPos,
               (PBYTE)lpCompStrW + lpCompStrW->dwCompAttrOffset,
               lpCompStrW->dwCompAttrLen
              );
        dwPos += DWORD_ALIGN((lpUndetW->uUndetTextLen + 1));
    }

    if (dwGCS & GCS_CURSORPOS)
    {
        lpUndetW->uCursorPos = lpCompStrW->dwCursorPos;
    }

    if (dwGCS & GCS_DELTASTART)
    {
        lpUndetW->uDeltaStart = lpCompStrW->dwDeltaStart;
    }

    if (dwGCS & GCS_RESULTSTR)
    {
        lpUndetW->uDetermineTextLen = lpCompStrW->dwResultStrLen;
        lpUndetW->uDetermineTextPos = dwPos;
        memcpy((PBYTE)lpUndetW   + dwPos,
               (PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset,
               lpCompStrW->dwResultStrLen * sizeof(WCHAR)
              );
        *(LPWSTR)((PBYTE)lpUndetW + dwPos + lpCompStrW->dwResultStrLen*sizeof(WCHAR)) = L'\0';
        dwPos += DWORD_ALIGN(((lpUndetW->uDetermineTextLen + 1)*sizeof(WCHAR)));
    }

    if ( (dwGCS & GCS_RESULTCLAUSE) &&
         (lpCompStrW->dwResultClauseLen > 0) )
    {
        LPDWORD lpw;
        LPDWORD lpdw;

        lpUndetW->uDetermineDelimPos = dwPos;

        lpw  = (LPDWORD)((PBYTE)lpUndetW + dwPos);
        lpdw = (LPDWORD)((PBYTE)lpCompStrW + lpCompStrW->dwResultClauseOffset);
        for (i = 0; i < (lpCompStrW->dwResultClauseLen / sizeof(DWORD)); i++)
            *lpw++ = *lpdw++;

        dwPos += DWORD_ALIGN((lpCompStrW->dwResultClauseLen + 1));
    }

    if (dwGCS & GCS_RESULTREADSTR)
    {
        lpUndetW->uYomiTextLen = lpCompStrW->dwResultReadStrLen;
        lpUndetW->uYomiTextPos = dwPos;
        memcpy((PBYTE)lpUndetW   + dwPos,
               (PBYTE)lpCompStrW + lpCompStrW->dwResultReadStrOffset,
               lpCompStrW->dwResultReadStrLen * sizeof(WCHAR)
              );
        *(LPWSTR)((PBYTE)lpUndetW + dwPos + lpCompStrW->dwResultReadStrLen*sizeof(WCHAR)) = L'\0';
        dwPos += DWORD_ALIGN(((lpUndetW->uYomiTextLen + 1)*sizeof(WCHAR)));
    }

    if ( (dwGCS & GCS_RESULTREADCLAUSE) &&
         (lpCompStrW->dwResultReadClauseLen > 0) )
    {
        LPDWORD lpw;
        LPDWORD lpdw;

        lpUndetW->uYomiDelimPos = dwPos;

        lpw  = (LPDWORD)((PBYTE)lpUndetW + dwPos);
        lpdw = (LPDWORD)((PBYTE)lpCompStrW + lpCompStrW->dwResultReadClauseOffset);
        for (i = 0; i < (lpCompStrW->dwResultReadClauseLen / sizeof(DWORD)); i++)
            *lpw++ = *lpdw++;

        dwPos += DWORD_ALIGN((lpCompStrW->dwResultReadClauseLen + 1));
    }

    return dwSize;
}

DWORD
CompStrWToUndetA(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrW,
    LPUNDETERMINESTRUCT lpUndetA
    )

/*++

Routine Description:

    Convert composition string (Unicode) to undetermine string (ANSI).

Arguments:

Return Value:

--*/

{
    DWORD dwPos;
    DWORD dwSize;
    UINT  i;
    BOOL bUDC;

    dwSize = DWORD_ALIGN((sizeof(UNDETERMINESTRUCT)+1)) +
             DWORD_ALIGN(((lpCompStrW->dwResultStrLen+1) * sizeof(WCHAR))) +
             DWORD_ALIGN((lpCompStrW->dwResultClauseLen+1)) +
             DWORD_ALIGN(((lpCompStrW->dwResultReadStrLen+1) * sizeof(WCHAR))) +
             DWORD_ALIGN((lpCompStrW->dwResultReadClauseLen+1)) +
             DWORD_ALIGN((lpCompStrW->dwCompAttrLen * 2)) +
             DWORD_ALIGN(((lpCompStrW->dwCompStrLen+1) * sizeof(WCHAR)));

    if (lpUndetA == NULL) {
        return dwSize;
    }

    dwPos = DWORD_ALIGN((sizeof(UNDETERMINESTRUCT) + 1));
    lpUndetA->dwSize = dwSize;

    if (dwGCS & GCS_COMPSTR)
    {
        i = WideCharToMultiByte( CP_ACP,
                                (DWORD)0,
                                (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwCompStrOffset),  // src
                                (INT)lpCompStrW->dwCompStrLen,
                                (LPSTR)((PBYTE)lpUndetA + dwPos),                           // dest
                                (INT)dwSize - dwPos,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);
        ((LPSTR)((PBYTE)lpUndetA + dwPos))[i] = '\0';
        lpUndetA->uUndetTextLen = i;
        lpUndetA->uUndetTextPos = dwPos;
        dwPos += DWORD_ALIGN(((lpUndetA->uUndetTextLen + 1)*sizeof(CHAR)));

        // Sometime Chicago IME does not generate GCS_COMPATTR
        // with GCS_COMPSTR. But uUndetAttrPos should be filled
        // when the UndetText is updated.
        if (lpCompStrW->dwCompAttrLen && !(dwGCS & GCS_COMPATTR))
            dwGCS |= GCS_COMPATTR;
    }

    if (dwGCS & GCS_COMPATTR)
    {
        if (lpUndetA->uUndetTextLen != 0) {
            LPSTR  lpszUndetText;
            PBYTE  lpAttrW;
            PBYTE  lpAttrA;
            BYTE   c;

            lpszUndetText  = (LPSTR)((PBYTE)lpUndetA + lpUndetA->uUndetTextPos);
            lpAttrW = (PBYTE)lpCompStrW + lpCompStrW->dwCompAttrOffset;
            lpAttrA = (PBYTE)lpUndetA   + dwPos;

            while (c=*lpszUndetText++) {
                if (IsDBCSLeadByte(c)) {
                    *lpAttrA++ = *lpAttrW;
                    *lpAttrA++ = *lpAttrW;
                    lpszUndetText++;
                }
                else {
                    *lpAttrA++ = *lpAttrW;
                }
                lpAttrW++;
            }

            lpUndetA->uUndetAttrPos = dwPos;
            dwPos += DWORD_ALIGN((lpUndetA->uUndetTextLen + 1));
        }
    }

    if (dwGCS & GCS_CURSORPOS)
    {
        if (lpCompStrW->dwCursorPos != -1) {
            lpUndetA->uCursorPos = CalcCharacterPositionWtoA(lpCompStrW->dwCursorPos,
                                                             (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwCompStrOffset),
                                                             CP_ACP
                                                            );
        }
        else {
            lpUndetA->uCursorPos = lpCompStrW->dwCursorPos;
        }
    }

    if (dwGCS & GCS_DELTASTART)
    {
        if (lpCompStrW->dwDeltaStart != -1) {
            lpUndetA->uDeltaStart = CalcCharacterPositionWtoA(lpCompStrW->dwDeltaStart,
                                                              (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwCompStrOffset),
                                                              CP_ACP
                                                             );
        }
        else {
            lpUndetA->uDeltaStart = lpCompStrW->dwDeltaStart;
        }
    }

    if (dwGCS & GCS_RESULTSTR)
    {
        i = WideCharToMultiByte( CP_ACP,
                                (DWORD)0,
                                (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset),  // src
                                (INT)lpCompStrW->dwResultStrLen,
                                (LPSTR)((PBYTE)lpUndetA + dwPos),                             // dest
                                (INT)dwSize - dwPos,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);
        ((LPSTR)((PBYTE)lpUndetA + dwPos))[i] = '\0';
        lpUndetA->uDetermineTextLen = i;
        lpUndetA->uDetermineTextPos = dwPos;
        dwPos += DWORD_ALIGN(((lpUndetA->uDetermineTextLen + 1)*sizeof(CHAR)));
    }

    if ( (dwGCS & GCS_RESULTCLAUSE) &&
         (lpCompStrW->dwResultClauseLen > 0) )
    {
        if (lpUndetA->uDetermineTextLen != 0) {
            LPDWORD lpw;
            LPDWORD lpdw;

            lpw  = (LPDWORD)((PBYTE)lpUndetA + dwPos);
            lpdw = (LPDWORD)((PBYTE)lpCompStrW + lpCompStrW->dwResultClauseOffset);

            for (i = 0; i < (lpCompStrW->dwResultClauseLen / sizeof(DWORD)); i++) {
                *lpw++ = CalcCharacterPositionWtoA(*lpdw++,
                                                   (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset),
                                                   CP_ACP
                                                  );
            }

            lpUndetA->uDetermineDelimPos = dwPos;
            dwPos += DWORD_ALIGN((lpCompStrW->dwResultClauseLen + 1));
        }
    }

    if (dwGCS & GCS_RESULTREADSTR)
    {
        i = WideCharToMultiByte( CP_ACP,
                                (DWORD)0,
                                (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultReadStrOffset),  // src
                                (INT)lpCompStrW->dwResultReadStrLen,
                                (LPSTR)((PBYTE)lpUndetA + dwPos),                                 // dest
                                (INT)dwSize - dwPos,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);
        ((LPSTR)((PBYTE)lpUndetA + dwPos))[i] = '\0';
        lpUndetA->uYomiTextLen = i;
        lpUndetA->uYomiTextPos = dwPos;
        dwPos += DWORD_ALIGN(((lpUndetA->uYomiTextLen + 1)*sizeof(CHAR)));
    }

    if ( (dwGCS & GCS_RESULTREADCLAUSE) &&
         (lpCompStrW->dwResultReadClauseLen > 0) )
    {
        if (lpUndetA->uYomiTextLen != 0) {
            LPDWORD lpw;
            LPDWORD lpdw;

            lpw  = (LPDWORD)((PBYTE)lpUndetA + dwPos);
            lpdw = (LPDWORD)((PBYTE)lpCompStrW + lpCompStrW->dwResultReadClauseOffset);

            for (i = 0; i < (lpCompStrW->dwResultReadClauseLen / sizeof(DWORD)); i++) {
                *lpw++ = CalcCharacterPositionWtoA(*lpdw++,
                                                   (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultReadStrOffset),
                                                   CP_ACP
                                                  );
            }

            lpUndetA->uYomiDelimPos = dwPos;
            dwPos += DWORD_ALIGN((lpCompStrW->dwResultReadClauseLen + 1));
        }
    }

    return dwSize;
}


DWORD
CompStrWToStringExW(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrW,
    LPSTRINGEXSTRUCT lpStringExW
    )

/*++

Routine Description:

    Convert composition string (Unicode) to StringEx (Unicode).

Arguments:

Return Value:

--*/

{
    DWORD dwPos;
    DWORD dwSize;
    UINT  i;

    dwSize = DWORD_ALIGN((sizeof(STRINGEXSTRUCT)+1)) +
             DWORD_ALIGN(((lpCompStrW->dwResultStrLen+1) * sizeof(WCHAR))) +
             DWORD_ALIGN(lpCompStrW->dwResultClauseLen+1) +
             DWORD_ALIGN(((lpCompStrW->dwResultReadStrLen+1) * sizeof(WCHAR))) +
             DWORD_ALIGN(lpCompStrW->dwResultReadClauseLen+1);

    if (lpStringExW == NULL) {
        return dwSize;
    }

    dwPos = DWORD_ALIGN(sizeof(STRINGEXSTRUCT) + 1);
    lpStringExW->dwSize = dwSize;

    lpStringExW->uDeterminePos = dwPos;
    memcpy((PBYTE)lpStringExW + dwPos,
           (PBYTE)lpCompStrW  + lpCompStrW->dwResultStrOffset,
           lpCompStrW->dwResultStrLen * sizeof(WCHAR)
          );
    *(LPWSTR)((PBYTE)lpStringExW + dwPos + lpCompStrW->dwResultStrLen*sizeof(WCHAR)) = L'\0';
    dwPos += DWORD_ALIGN(((lpCompStrW->dwResultStrLen + 1)*sizeof(WCHAR)));

    if ( (dwGCS & GCS_RESULTCLAUSE) &&
         (lpCompStrW->dwResultClauseLen > 0) )
    {
        LPDWORD lpw;
        LPDWORD lpdw;

        lpStringExW->uDetermineDelimPos = dwPos;

        lpw  = (LPDWORD)((PBYTE)lpStringExW + dwPos);
        lpdw = (LPDWORD)((PBYTE)lpCompStrW + lpCompStrW->dwResultClauseOffset);
        for (i = 0; i < (lpCompStrW->dwResultClauseLen / sizeof(DWORD)); i++)
            *lpw++ = *lpdw++;

        dwPos += DWORD_ALIGN((lpCompStrW->dwResultClauseLen + 1));
    }

    lpStringExW->uYomiPos = dwPos;
    memcpy((PBYTE)lpStringExW + dwPos,
           (PBYTE)lpCompStrW  + lpCompStrW->dwResultReadStrOffset,
           lpCompStrW->dwResultReadStrLen * sizeof(WCHAR)
          );
    *(LPWSTR)((PBYTE)lpStringExW + dwPos + lpCompStrW->dwResultReadStrLen*sizeof(WCHAR)) = L'\0';
    dwPos += DWORD_ALIGN(((lpCompStrW->dwResultReadStrLen + 1)*sizeof(WCHAR)));

    if ( (dwGCS & GCS_RESULTREADCLAUSE) &&
         (lpCompStrW->dwResultReadClauseLen > 0) )
    {
        LPDWORD lpw;
        LPDWORD lpdw;

        lpStringExW->uYomiDelimPos = dwPos;

        lpw  = (LPDWORD)((PBYTE)lpStringExW + dwPos);
        lpdw = (LPDWORD)((PBYTE)lpCompStrW + lpCompStrW->dwResultReadClauseOffset);
        for (i = 0; i < (lpCompStrW->dwResultReadClauseLen / sizeof(DWORD)); i++)
            *lpw++ = *lpdw++;
    }

    return dwSize;
}

DWORD
CompStrWToStringExA(
    DWORD dwGCS,
    LPCOMPOSITIONSTRING lpCompStrW,
    LPSTRINGEXSTRUCT lpStringExA
    )

/*++

Routine Description:

    Convert composition string (Unicode) to StringEx (ANSI).

Arguments:

Return Value:

--*/

{
    DWORD dwPos;
    DWORD dwSize;
    DWORD dwLen;
    UINT  i;
    BOOL bUDC;

    dwSize = DWORD_ALIGN((sizeof(STRINGEXSTRUCT)+1)) +
             (lpCompStrW->dwResultStrLen > 0 ? DWORD_ALIGN(((lpCompStrW->dwResultStrLen+1) * sizeof(WCHAR))) : 0) +
             (lpCompStrW->dwResultClauseLen > 0 ? DWORD_ALIGN(lpCompStrW->dwResultClauseLen+1) : 0) +
             (lpCompStrW->dwResultReadStrLen > 0 ? DWORD_ALIGN(((lpCompStrW->dwResultReadStrLen+1) * sizeof(WCHAR))) : 0)+
             (lpCompStrW->dwResultReadClauseLen > 0 ? DWORD_ALIGN(lpCompStrW->dwResultReadClauseLen+1) : 0);

    if (lpStringExA == NULL) {
        return dwSize;
    }

    dwPos = DWORD_ALIGN(sizeof(STRINGEXSTRUCT) + 1);
    lpStringExA->dwSize = dwSize;

    if (lpCompStrW->dwResultStrLen > 0) {
        i = WideCharToMultiByte( CP_ACP,
                                (DWORD)0,
                                (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset),  // src
                                (INT)lpCompStrW->dwResultStrLen,
                                (LPSTR)((PBYTE)lpStringExA + dwPos),                          // dest
                                (INT)dwSize - dwPos,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);
        ((LPSTR)((PBYTE)lpStringExA + dwPos))[i] = '\0';
        dwLen = i;
        lpStringExA->uDeterminePos = dwPos;
        dwPos += DWORD_ALIGN(((dwLen + 1)*sizeof(CHAR)));
    } else {
        dwLen = 0;
        lpStringExA->uDeterminePos = 0;
    }

    if ( (dwGCS & GCS_RESULTCLAUSE) &&
         (lpCompStrW->dwResultClauseLen > 0) )
    {
        if (dwLen != 0 && lpCompStrW->dwResultClauseLen > 0) {
            LPDWORD lpw;
            LPDWORD lpdw;

            lpw  = (LPDWORD)((PBYTE)lpStringExA + dwPos);
            lpdw = (LPDWORD)((PBYTE)lpCompStrW + lpCompStrW->dwResultClauseOffset);

            for (i = 0; i < (lpCompStrW->dwResultClauseLen / sizeof(DWORD)); i++) {
                *lpw++ = CalcCharacterPositionWtoA(*lpdw++,
                                                   (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset),
                                                   CP_ACP
                                                  );
            }

            lpStringExA->uDetermineDelimPos = dwPos;
            dwPos += DWORD_ALIGN((lpCompStrW->dwResultClauseLen + 1));
        }
    }

    if (lpCompStrW->dwResultReadStrLen > 0) {
        i = WideCharToMultiByte( CP_ACP,
                                (DWORD)0,
                                (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultReadStrOffset),  // src
                                (INT)lpCompStrW->dwResultReadStrLen,
                                (LPSTR)((PBYTE)lpStringExA + dwPos),                              // dest
                                (INT)dwSize - dwPos,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);
        ((LPSTR)((PBYTE)lpStringExA + dwPos))[i] = '\0';
        dwLen = i;
        lpStringExA->uYomiPos = dwPos;
        dwPos += DWORD_ALIGN(((dwLen + 1)*sizeof(CHAR)));
    } else {
        dwLen = 0;
        lpStringExA->uYomiPos = 0;
    }

    if ( (dwGCS & GCS_RESULTREADCLAUSE) &&
         (lpCompStrW->dwResultReadClauseLen > 0) )
    {
        if (dwLen != 0 && lpCompStrW->dwResultReadClauseLen > 0) {
            LPDWORD lpw;
            LPDWORD lpdw;

            lpw  = (LPDWORD)((PBYTE)lpStringExA + dwPos);
            lpdw = (LPDWORD)((PBYTE)lpCompStrW + lpCompStrW->dwResultReadClauseOffset);

            for (i = 0; i < (lpCompStrW->dwResultReadClauseLen / sizeof(DWORD)); i++) {
                *lpw++ = CalcCharacterPositionWtoA(*lpdw++,
                                                   (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultReadStrOffset),
                                                   CP_ACP
                                                  );
            }

            lpStringExA->uYomiDelimPos = dwPos;
            dwPos += DWORD_ALIGN((lpCompStrW->dwResultReadClauseLen + 1));
        }
    }

    return dwSize;
}

DWORD
CompStrWToStringW(
    LPCOMPOSITIONSTRING lpCompStrW,
    LPWSTR lpStringW
    )

/*++

Routine Description:

    Convert composition string (Unicode) to String (Unicode).

Arguments:

Return Value:

--*/

{
    LPWSTR lpwszString;
    DWORD dwSize;

    lpwszString = (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset);
    dwSize = lpCompStrW->dwResultStrLen;

    if (lpStringW == NULL) {
        return ((dwSize + 1) * sizeof(WCHAR));
    }

    memcpy((PBYTE)lpStringW,
           (PBYTE)lpwszString,
           (dwSize * sizeof(WCHAR))
          );
    lpStringW[dwSize] = L'\0';

    return ((dwSize + 1) * sizeof(WCHAR));
}

DWORD
CompStrWToStringA(
    LPCOMPOSITIONSTRING lpCompStrW,
    LPSTR lpStringA
    )

/*++

Routine Description:

    Convert composition string (Unicode) to String (ANSI).

Arguments:

Return Value:

--*/

{
    LPWSTR lpwszString;
    DWORD dwSize;
    UINT  i;
    BOOL bUDC;

    lpwszString = (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset);

    i = WideCharToMultiByte( CP_ACP,
                            (DWORD)0,
                            (LPWSTR)lpwszString,                             // src
                            (INT)lpCompStrW->dwResultStrLen,
                            (LPSTR)lpStringA,                                // dest
                            (INT)0,
                            (LPSTR)NULL,
                            (LPBOOL)&bUDC);

    if (lpStringA == NULL) {
        dwSize = (i+1) * sizeof(CHAR);
    }
    else {
        dwSize = (i+1) * sizeof(CHAR);

        i = WideCharToMultiByte( CP_ACP,
                                (DWORD)0,
                                (LPWSTR)lpwszString,                             // src
                                (INT)lpCompStrW->dwResultStrLen,
                                (LPSTR)lpStringA,                                // dest
                                (INT)dwSize,
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);

        lpStringA[i] = '\0';
        dwSize = (i+1) * sizeof(CHAR);
    }

    return dwSize;
}

VOID
CompStrWToCharW(
    HWND hWnd,
    LPCOMPOSITIONSTRING lpCompStrW
    )

/*++

Routine Description:

    Convert composition string (Unicode) to WM_CHAR (Unicode).

Arguments:

Return Value:

--*/

{
    LPWSTR lpwszString;

    lpwszString = (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset);

    // IR_DBCSCHAR: If the app reply to this message with TRUE, we can
    // queue up double byte character in a WM_CHAR message.
    // SendMessageW( hWnd,WM_IME_REPORT,IR_DBCSCHAR, 0L);

    // Send IR_STRINGSTART prior to anything.
    PostMessageW( hWnd, WM_IME_REPORT, IR_STRINGSTART, 0L );


    while(*lpwszString)
    {
        if( *CharNextW(lpwszString) == 0 )
        {
            PostMessageW( hWnd, WM_IME_REPORT, IR_STRINGEND, 0L );
        }
        PostMessageW( hWnd, WM_CHAR, *lpwszString, 1L);
        lpwszString = CharNextW(lpwszString);
    }
}

VOID
CompStrWToCharA(
    HWND hWnd,
    LPCOMPOSITIONSTRING lpCompStrW
    )

/*++

Routine Description:

    Convert composition string (Unicode) to WM_CHAR (ANSI).

Arguments:

Return Value:

--*/

{
    LPWSTR lpwszString;
    BOOL   fDBCSWmChar = FALSE;
    WORD   wDBCSChar;
    UINT   i;
    BOOL   bUDC;
    BYTE   szAscii[3];

    lpwszString = (LPWSTR)((PBYTE)lpCompStrW + lpCompStrW->dwResultStrOffset);

    //
    // IR_DBCSCHAR: If the app reply to this message with TRUE, we can
    // queue up double byte character in a WM_CHAR message.
    //
    //

    if ( GetClientInfo()->dwExpWinVer >= 0x030A ) {
       fDBCSWmChar = (BOOL)SendMessageA( hWnd,WM_IME_REPORT,IR_DBCSCHAR, 0L);
    }

    //
    // Send IR_STRINGSTART prior to anything.
    //

    PostMessageA( hWnd, WM_IME_REPORT, IR_STRINGSTART, 0L );


    while (*lpwszString) {

       if ( *CharNextW(lpwszString) == 0 ) {
           PostMessageA( hWnd, WM_IME_REPORT, IR_STRINGEND, 0L );
       }

       i = WideCharToMultiByte( CP_ACP,
                                (DWORD)0,
                                (LPWSTR)lpwszString,  // src
                                (INT)1,
                                (LPSTR)szAscii,       // dest
                                (INT)sizeof(szAscii),
                                (LPSTR)NULL,
                                (LPBOOL)&bUDC);

        if (i != 0) {

            if ( IsDBCSLeadByte( szAscii[0] ) ) {

               //
               //  If fDBCSWmChar==TRUE, The app can recieve WM_CHARs which
               // have double byte code in wParam.
               //

               if ( fDBCSWmChar )
               {
                   //
                   // It's necessary to swap bytes to put 1st byte into upper
                   // part of wParam, and 2nd byte into lower part.
                   //

                   wDBCSChar = MAKEWORD(szAscii[1], szAscii[0]);
                   PostMessageA( hWnd, WM_CHAR, wDBCSChar|WMCR_IR_DBCSCHAR, 1L );
               }
               else
               {
                   //
                   // Send each byte on a WM_CHAR
                   //

                   PostMessageA( hWnd, WM_CHAR, (WPARAM)(szAscii[0]), 1L);
                   PostMessageA( hWnd, WM_CHAR, (WPARAM)(szAscii[1]), 1L);
               }
           }
           else
           {
               PostMessageA( hWnd, WM_CHAR, (WPARAM)(szAscii[0]), 1L);
           }
       }

       lpwszString = CharNextW(lpwszString);
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\kcodecnv.c ===
/**************************************************************************\
* Module Name: kcodecnv.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the code for the Korean code conversion functions.
*
* History:
* 15-Jul-1995
* 22-Feb-1996  bklee
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#define IDD_2BEOL    100
#define IDD_3BEOL1   101
#define IDD_3BEOL2   102

#define lpSource(lpks) (LPSTR)((LPSTR)lpks+lpks->dchSource)
#define lpDest(lpks)   (LPSTR)((LPSTR)lpks+lpks->dchDest)

#define JOHAB_CP   1361
#define WANSUNG_CP 949
#define TWO_BYTE   2
#define ONE_WORD   1

typedef struct tagHIGH_LOW              // For high byte and low byte
{
    BYTE    low, high;
}   HIGH_LOW;

typedef union tagWANSUNG                // For Wansung character code
{
    HIGH_LOW    e;
    WORD        w;
}   WANSUNG;

/* Hanguel Mnemonic Table for 2 BeolSik and 3 BeolSik */
CONST WORD HMNTable[3][96] =
{
// For 2 Beolsik.
    {
    /*  20  SP  */  0xA1A1,
    /*  21  !   */  0xA3A1,
    /*  22  "   */  0xA1A8,
    /*  23  #   */  0xA3A3,
    /*  24  $   */  0xA3A4,
    /*  25  %   */  0xA3A5,
    /*  26  &   */  0xA3A6,
    /*  27  `   */  0xA1AE,     /* A1AE ? AiA2 */
    /*  28  (   */  0xA3A8,
    /*  29  )   */  0xA3A9,
    /*  2A  *   */  0xA3AA,
    /*  2B  +   */  0xA3AB,
    /*  2C  '   */  0xA3A7,
    /*  2D  -   */  0xA3AD,
    /*  2E  .   */  0xA3AE,
    /*  2F  /   */  0xA3AF,
    /*  30  0   */  0xA3B0,
    /*  31  1   */  0xA3B1,
    /*  32  2   */  0xA3B2,
    /*  33  3   */  0xA3B3,
    /*  34  4   */  0xA3B4,
    /*  35  5   */  0xA3B5,
    /*  36  6   */  0xA3B6,
    /*  37  7   */  0xA3B7,
    /*  38  8   */  0xA3B8,
    /*  39  9   */  0xA3B9,
    /*  3A  :   */  0xA3BA,
    /*  3B  ;   */  0xA3BB,
    /*  3C  <   */  0xA3BC,
    /*  3D  =   */  0xA3BD,
    /*  3E  >   */  0xA3BE,
    /*  3F  ?   */  0xA3BF,
    /*  40  @   */  0xA3C0,
    /*  41  A   */  0xA4B1,
    /*  42  B   */  0xA4D0,
    /*  43  C   */  0xA4BA,
    /*  44  D   */  0xA4B7,
    /*  45  E   */  0xA4A8,
    /*  46  F   */  0xA4A9,
    /*  47  G   */  0xA4BE,
    /*  48  H   */  0xA4C7,
    /*  49  I   */  0xA4C1,
    /*  4A  J   */  0xA4C3,
    /*  4B  K   */  0xA4BF,
    /*  4C  L   */  0xA4D3,
    /*  4D  M   */  0xA4D1,
    /*  4E  N   */  0xA4CC,
    /*  4F  O   */  0xA4C2,
    /*  50  P   */  0xA4C6,
    /*  51  Q   */  0xA4B3,
    /*  52  R   */  0xA4A2,
    /*  53  S   */  0xA4A4,
    /*  54  T   */  0xA4B6,
    /*  55  U   */  0xA4C5,
    /*  56  V   */  0xA4BD,
    /*  57  W   */  0xA4B9,
    /*  58  X   */  0xA4BC,
    /*  59  Y   */  0xA4CB,
    /*  5A  Z   */  0xA4BB,
    /*  5B  [   */  0xA3DB,
    /*  5C  \   */  0xA1AC,
    /*  5D  ]   */  0xA3DD,
    /*  5E  ^   */  0xA3DE,
    /*  5F  _   */  0xA3DF,
    /*  60  `   */  0xA1A2,     /* A1AE ? AiA2 */
    /*  61  a   */  0xA4B1,
    /*  62  b   */  0xA4D0,
    /*  63  c   */  0xA4BA,
    /*  64  d   */  0xA4B7,
    /*  65  e   */  0xA4A7,
    /*  66  f   */  0xA4A9,
    /*  67  g   */  0xA4BE,
    /*  68  h   */  0xA4C7,
    /*  69  i   */  0xA4C1,
    /*  6A  j   */  0xA4C3,
    /*  6B  k   */  0xA4BF,
    /*  6C  l   */  0xA4D3,
    /*  6D  m   */  0xA4D1,
    /*  6E  n   */  0xA4CC,
    /*  6F  o   */  0xA4C0,
    /*  70  p   */  0xA4C4,
    /*  71  q   */  0xA4B2,
    /*  72  r   */  0xA4A1,
    /*  73  s   */  0xA4A4,
    /*  74  t   */  0xA4B5,
    /*  75  u   */  0xA4C5,
    /*  76  v   */  0xA4BD,
    /*  77  w   */  0xA4B8,
    /*  78  x   */  0xA4BC,
    /*  79  y   */  0xA4CB,
    /*  7A  z   */  0xA4BB,
    /*  7B  {   */  0xA3FB,
    /*  7C  |   */  0xA3FC,
    /*  7D  }   */  0xA3FD,
    /*  7E  ~   */  0xA1AD,
                    0x0000
    },
// For KT390.
    {
    /*  Hex Code    KSC Code */
    /*  20  SP  */  0xA1A1,
    /*  21  !   */  0xA4B8,
    /*  22  "   */  0xA1A8,
    /*  23  #   */  0xA3A3,
    /*  24  $   */  0xA3A4,
    /*  25  %   */  0xA3A5,
    /*  26  &   */  0xA3A6,
    /*  27  `   */  0xA1AE,
    /*  28  (   */  0xA3A8,
    /*  29  )   */  0xA3A9,
    /*  2A  *   */  0xA3AA,
    /*  2B  +   */  0xA3AB,
    /*  2C  '   */  0xA4BC,
    /*  2D  -   */  0xA3AD,
    /*  2E  .   */  0xA3AE,
    /*  2F  /   */  0xA4C7,
    /*  30  0   */  0xA4BB,
    /*  31  1   */  0xA4BE,
    /*  32  2   */  0xA4B6,
    /*  33  3   */  0xA4B2,
    /*  34  4   */  0xA4CB,
    /*  35  5   */  0xA4D0,
    /*  36  6   */  0xA4C1,
    /*  37  7   */  0xA4C6,
    /*  38  8   */  0xA4D2,
    /*  39  9   */  0xA4CC,
    /*  3A  :   */  0xA3BA,
    /*  3B  ;   */  0xA4B2,
    /*  3C  <   */  0xA3B2,
    /*  3D  =   */  0xA3BD,
    /*  3E  >   */  0xA3B3,
    /*  3F  ?   */  0xA3BF,
    /*  40  @   */  0xA3C0,
    /*  41  A   */  0xA4A7,
    /*  42  B   */  0xA3A1,
    /*  43  C   */  0xA4AB,
    /*  44  D   */  0xA4AA,
    /*  45  E   */  0xA4BB,
    /*  46  F   */  0xA4A2,
    /*  47  G   */  0xA3AF,
    /*  48  H   */  0xA1AF,
    /*  49  I   */  0xA3B8,
    /*  4A  J   */  0xA3B4,
    /*  4B  K   */  0xA3B5,
    /*  4C  L   */  0xA3B6,
    /*  4D  M   */  0xA3B1,
    /*  4E  N   */  0xA3B0,
    /*  4F  O   */  0xA3B9,
    /*  50  P   */  0xA3BE,
    /*  51  Q   */  0xA4BD,
    /*  52  R   */  0xA4C2,
    /*  53  S   */  0xA4A6,
    /*  54  T   */  0xA4C3,
    /*  55  U   */  0xA3B7,
    /*  56  V   */  0xA4B0,
    /*  57  W   */  0xA4BC,
    /*  58  X   */  0xA4B4,
    /*  59  Y   */  0xA3BC,
    /*  5A  Z   */  0xA4BA,
    /*  5B  [   */  0xA3DB,
    /*  5C  \   */  0xA3DC,
    /*  5D  ]   */  0xA3DD,
    /*  5E  ^   */  0xA3DE,
    /*  5F  _   */  0xA3DF,
    /*  60  `   */  0xA1AE,
    /*  61  a   */  0xA4B7,
    /*  62  b   */  0xA4CC,
    /*  63  c   */  0xA4C4,
    /*  64  d   */  0xA4D3,
    /*  65  e   */  0xA4C5,
    /*  66  f   */  0xA4BF,
    /*  67  g   */  0xA4D1,
    /*  68  h   */  0xA4A4,
    /*  69  i   */  0xA4B1,
    /*  6A  j   */  0xA4B7,
    /*  6B  k   */  0xA4A1,
    /*  6C  l   */  0xA4B8,
    /*  6D  m   */  0xA4BE,
    /*  6E  n   */  0xA4B5,
    /*  6F  o   */  0xA4BA,
    /*  70  p   */  0xA4BD,
    /*  71  q   */  0xA4B5,
    /*  72  r   */  0xA4C0,
    /*  73  s   */  0xA4A4,
    /*  74  t   */  0xA4C3,
    /*  75  u   */  0xA4A7,
    /*  76  v   */  0xA4C7,
    /*  77  w   */  0xA4A9,
    /*  78  x   */  0xA4A1,
    /*  79  y   */  0xA4A9,
    /*  7A  z   */  0xA4B1,
    /*  7B  {   */  0xA3FB,
    /*  7C  |   */  0xA3FC,
    /*  7D  }   */  0xA3FD,
    /*  7E  ~   */  0xA1AD,
                    0x0000
    },
// For 3 Beolsik Final.
    {
    /*  Hex Code    KSC Code */
    /*  20  SP  */  0xA1A1,
    /*  21  !   */  0xA4A2,
    /*  22  "   */  0xA3AE,
    /*  23  #   */  0xA4B8,
    /*  24  $   */  0xA4AF,
    /*  25  %   */  0xA4AE,
    /*  26  &   */  0xA1B0,
    /*  27  `   */  0xA3AA,
    /*  28  (   */  0xA1A2,
    /*  29  )   */  0xA1AD,
    /*  2A  *   */  0xA1B1,
    /*  2B  +   */  0xA3AB,
    /*  2C  '   */  0xA4BC,
    /*  2D  -   */  0xA3A9,
    /*  2E  .   */  0xA3AE,
    /*  2F  /   */  0xA4C7,
    /*  30  0   */  0xA4BB,
    /*  31  1   */  0xA4BE,
    /*  32  2   */  0xA4B6,
    /*  33  3   */  0xA4B2,
    /*  34  4   */  0xA4CB,
    /*  35  5   */  0xA4D0,
    /*  36  6   */  0xA4C1,
    /*  37  7   */  0xA4C6,
    /*  38  8   */  0xA4D2,
    /*  39  9   */  0xA4CC,  //0x0000
    /*  3A  :   */  0xA3B4,
    /*  3B  ;   */  0xA4B2,
    /*  3C  <   */  0xA3A7,
    /*  3D  =   */  0xA1B5,
    /*  3E  >   */  0xA3AE,
    /*  3F  ?   */  0xA3A1,
    /*  40  @   */  0xA4AA,
    /*  41  A   */  0xA4A7,
    /*  42  B   */  0xA3BF,
    /*  43  C   */  0xA4BC,
    /*  44  D   */  0xA4AC,
    /*  45  E   */  0xA4A5,
    /*  46  F   */  0xA4AB,
    /*  47  G   */  0xA4C2,
    /*  48  H   */  0xA3B0,
    /*  49  I   */  0xA3B7,
    /*  4A  J   */  0xA3B1,
    /*  4B  K   */  0xA3B2,
    /*  4C  L   */  0xA3B3,
    /*  4D  M   */  0xA1A8,
    /*  4E  N   */  0xA3AD,
    /*  4F  O   */  0xA3B8,
    /*  50  P   */  0xA3B9,
    /*  51  Q   */  0xA4BD,
    /*  52  R   */  0xA4B0,
    /*  53  S   */  0xA4A6,
    /*  54  T   */  0xA4AD,
    /*  55  U   */  0xA3B6,
    /*  56  V   */  0xA4A3,
    /*  57  W   */  0xA4BC,
    /*  58  X   */  0xA4B4,
    /*  59  Y   */  0xA3B5,
    /*  5A  Z   */  0xA4BA,
    /*  5B  [   */  0xA3A8,
    /*  5C  \   */  0xA3BA,
    /*  5D  ]   */  0xA1B4,
    /*  5E  ^   */  0xA3BD,
    /*  5F  _   */  0xA3BB,
    /*  60  `   */  0xA3AA,
    /*  61  a   */  0xA4B7,
    /*  62  b   */  0xA4CC,
    /*  63  c   */  0xA4C4,
    /*  64  d   */  0xA4D3,
    /*  65  e   */  0xA4C5,
    /*  66  f   */  0xA4BF,
    /*  67  g   */  0xA4D1,
    /*  68  h   */  0xA4A4,
    /*  69  i   */  0xA4B1,
    /*  6A  j   */  0xA4B7,
    /*  6B  k   */  0xA4A1,
    /*  6C  l   */  0xA4B8,
    /*  6D  m   */  0xA4BE,
    /*  6E  n   */  0xA4B5,
    /*  6F  o   */  0xA4BA,
    /*  70  p   */  0xA4BD,
    /*  71  q   */  0xA4B5,
    /*  72  r   */  0xA4C0,
    /*  73  s   */  0xA4A4,
    /*  74  t   */  0xA4C3,
    /*  75  u   */  0xA4A7,
    /*  76  v   */  0xA4C7,
    /*  77  w   */  0xA4A9,
    /*  78  x   */  0xA4A1,
    /*  79  y   */  0xA4B1,
    /*  7A  z   */  0xA4B1,
    /*  7B  {   */  0xA3A5,
    /*  7C  |   */  0xA3CC,
    /*  7D  }   */  0xA3AF,
    /*  7E  ~   */  0xA1AD,
                    0x0000
    }
};

CONST WORD  wKSCompCode[51] =   // from 'GiYuk' to 'Yi'.
{
    0x8841,0x8C41,0x8444,0x9041,0x8446,0x8447,0x9441,0x9841,0x9C41,0x844A,
    0x844B,0x844C,0x844D,0x844E,0x844F,0x8450,0xA041,0xA441,0xA841,0x8454,
    0xAC41,0xB041,0xB441,0xB841,0xBC41,0xC041,0xC441,0xC841,0xCC41,0xD041,
    0x8461,0x8481,0x84A1,0x84C1,0x84E1,0x8541,0x8561,0x8581,0x85A1,0x85C1,
    0x85E1,0x8641,0x8661,0x8681,0x86A1,0x86C1,0x86E1,0x8741,0x8761,0x8781,
    0x87A1
};

CONST WORD  wKSCompCode2[30] =   // from 'GiYuk' to 'HiEut'.
{
    0x8442,0x8443,0x8444,0x8445,0x8446,0x8447,0x8448,0x9841,0x8449,0x844A,
    0x844B,0x844C,0x844D,0x844E,0x844F,0x8450,0x8451,0x8453,0xA841,0x8454,
    0x8455,0x8456,0x8457,0x8458,0xBC41,0x8459,0x845A,0x845B,0x845C,0x845D
};


WORD
JunjaToBanja(
    LPSTR lpSrc,
    LPSTR lpDest
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WANSUNG wsCode;
    WORD    wCount = 0;

    while (*lpSrc)
    {
        if ((BYTE)(*lpSrc) < (BYTE)0x80)
        {
            *lpDest++ = *lpSrc++;
            wCount++;
        }
        else
        {
            wsCode.e.high = *lpSrc++;
            wsCode.e.low = *lpSrc++;
            if (wsCode.w == 0xA1A1)
            {
                *lpDest++ = ' ';
                wCount++;
            }
            else if (wsCode.w >= 0xA3A1 && wsCode.w <= 0xA3FE)
            {
                *lpDest++ = wsCode.e.low - (BYTE)0x80;
                wCount++;
            }
            else
            {
                *lpDest++ = wsCode.e.high;
                *lpDest++ = wsCode.e.low;
                wCount += 2;
            }
        }
    }
    *lpDest = '\0';
    return (wCount);
}

WORD
BanjaToJunja(
    LPSTR lpSrc,
    LPSTR lpDest
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WORD    wCount = 0;

    while (*lpSrc)
    {
        if ((BYTE)(*lpSrc) < (BYTE)0x80)
        {
            if (*lpSrc++ == ' ')
            {
                *lpDest++ = (BYTE)0xA1;
                *lpDest++ = (BYTE)0xA1;
                wCount += 2;
            }
            else
            {
                *lpDest++ = (BYTE)0xA3;
                *lpDest++ = *(lpSrc - 1) + (BYTE)0x80;
                wCount += 2;
            }
        }
        else
        {
            *lpDest++ = *lpSrc++;
            *lpDest++ = *lpSrc++;
            wCount += 2;
        }
    }
    *lpDest = '\0';
    return (wCount);
}

WORD
JohabToKs(
    LPSTR lpSrc,
    LPSTR lpDest
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WORD    wCount = 0;
#if defined(OLD_CONV)
    WANSUNG wsSCode, wsDCode;
    int     iHead = 0, iTail = 2349, iMid;
    BYTE    bCount;
#endif

    while (*lpSrc)
    {
        if ((BYTE)(*lpSrc) < (BYTE)0x80)
        {
            *lpDest++ = *lpSrc++;
            wCount++;
        }
        else
#if defined(OLD_CONV)
        {
            wsSCode.e.high = *lpSrc++;
            wsSCode.e.low = *lpSrc++;
            for (bCount = 0; bCount < 51 && wKSCompCode[bCount] != wsSCode.w; bCount++)
                ;
            wsDCode.w = (bCount == 51)? 0: bCount + 0xA4A1;
            if (wsDCode.w)
            {
                *lpDest++ = wsDCode.e.high;
                *lpDest++ = wsDCode.e.low;
                wCount += 2;
                continue;
            }
            for (bCount = 0; bCount < 30 && wKSCompCode2[bCount] != wsSCode.w; bCount++)
                ;
            wsDCode.w = (bCount == 30)? 0: bCount + 0xA4A1;
            if (wsDCode.w)
            {
                *lpDest++ = wsDCode.e.high;
                *lpDest++ = wsDCode.e.low;
                wCount += 2;
                continue;
            }
            while (iHead <= iTail && !wsDCode.w)
            {
                iMid = (iHead + iTail) / 2;
                if (wKSCharCode[iMid] > wsSCode.w)
                    iTail = iMid - 1;
                else if (wKSCharCode[iMid] < wsSCode.w)
                    iHead = iMid + 1;
                else
                    wsDCode.w = ((iMid / 94 + 0xB0) << 8) | (iMid % 94 + 0xA1);
            }
            if (wsDCode.w)
            {
                *lpDest++ = wsDCode.e.high;
                *lpDest++ = wsDCode.e.low;
                wCount += 2;
            }
            else
            {
                *lpDest++ = wsSCode.e.high;
                *lpDest++ = wsSCode.e.low;
                wCount += 2;
            }
        }
#else
        {
                // for simple implementation, converting one character by character
                // we have to change it string to string conversion.
                WCHAR wUni;
                CHAR  chTmp[2];

                chTmp[0] = *lpSrc++;
                chTmp[1] = *lpSrc++;

                MultiByteToWideChar(JOHAB_CP, MB_PRECOMPOSED, chTmp, TWO_BYTE, &wUni, ONE_WORD);

                WideCharToMultiByte(WANSUNG_CP, 0, &wUni, ONE_WORD, chTmp, TWO_BYTE, NULL, NULL);

                *lpDest++ = chTmp[0];
                *lpDest++ = chTmp[1];

                wCount += 2;
        }
#endif
    }
    *lpDest = '\0';
    return (wCount);
}

WORD
KsToJohab(
    LPSTR lpSrc,
    LPSTR lpDest
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
#if defined(OLD_CONV)
    WANSUNG wsSCode, wsDCode;
    WORD    wCount = 0, wLoc;
#else
    WORD    wCount = 0;
#endif

    while (*lpSrc)
    {
        if ((BYTE)(*lpSrc) < (BYTE)0x80)
        {
            *lpDest++ = *lpSrc++;
            wCount++;
        }
        else
#if defined(OLD_CONV)
        {
            wsSCode.e.high = *lpSrc++;
            wsSCode.e.low = *lpSrc++;
            if (wsSCode.w >= (WORD)0xA4A1 && wsSCode.w <= (WORD)0xA4D3)
            {
                wsDCode.w = wKSCompCode[wsSCode.w - 0xA4A1];
                *lpDest++ = wsDCode.e.high;
                *lpDest++ = wsDCode.e.low;
            }
            else if (wsSCode.w >= (WORD)0xB0A1 && wsSCode.w <= (WORD)0xC8FE
                    && wsSCode.e.low != (BYTE)0xFF)
            {
                wLoc = (wsSCode.e.high - 176) * 94;
                wLoc += wsSCode.e.low  - 161;
                wsDCode.w = wKSCharCode[wLoc];
                *lpDest++ = wsDCode.e.high;
                *lpDest++ = wsDCode.e.low;
            }
            else
            {
                *lpDest++ = wsSCode.e.high;
                *lpDest++ = wsSCode.e.low;
            }
            wCount += 2;
        }
#else
        {
            WCHAR wUni;
            CHAR  chTmp[2];

            chTmp[0] = *lpSrc++;
            chTmp[1] = *lpSrc++;

            MultiByteToWideChar(WANSUNG_CP, MB_PRECOMPOSED, chTmp, TWO_BYTE, &wUni, ONE_WORD);

            WideCharToMultiByte(JOHAB_CP, 0, &wUni, ONE_WORD, chTmp, TWO_BYTE, NULL, NULL);

            *lpDest++ = chTmp[0];
            *lpDest++ = chTmp[1];

            wCount += 2;
        }
#endif
    }
    *lpDest = '\0';
    return (wCount);
}

LRESULT
TransCodeConvert(
    HIMC hIMC,
    LPIMESTRUCT lpIme
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    UNREFERENCED_PARAMETER(hIMC);

    switch (lpIme->wParam)
    {
        case IME_JUNJAtoBANJA:
            lpIme->wCount = JunjaToBanja(lpSource(lpIme), lpDest(lpIme));
            break;

        case IME_BANJAtoJUNJA:
            lpIme->wCount = BanjaToJunja(lpSource(lpIme), lpDest(lpIme));
            break;

        case IME_JOHABtoKS:
            lpIme->wCount = JohabToKs(lpSource(lpIme), lpDest(lpIme));
            break;

        case IME_KStoJOHAB:
            lpIme->wCount = KsToJohab(lpSource(lpIme), lpDest(lpIme));
            break;

        default:
            lpIme->wCount = 0;
    }
    return (lpIme->wCount);
}

LRESULT TransConvertList( HIMC hImc, LPIMESTRUCT lpIme)
{
    LPSTR           lpSrc;
    LPSTR           lpDst;
    HGLOBAL         hCandList;
    LPCANDIDATELIST lpCandList;
    LPSTR           lpCandStr;
    UINT            i, uBufLen;
    LRESULT         lRet = 0;

    lpSrc = lpSource(lpIme);
    lpDst = lpDest(lpIme);
    uBufLen = ImmGetConversionListA(GetKeyboardLayout(0), hImc, (LPCSTR)lpSrc,
            NULL, 0, GCL_CONVERSION);
    if (uBufLen)
    {
        hCandList = GlobalAlloc(GHND, uBufLen);
        lpCandList = (LPCANDIDATELIST)GlobalLock(hCandList);
        if (lpCandList == NULL) {
            return 0;
        }
        lRet = ImmGetConversionListA(GetKeyboardLayout(0), hImc, (LPCSTR)lpSrc,
                lpCandList, uBufLen, GCL_CONVERSION);
        for (i = 0; i < lpCandList->dwCount; i++)
        {
            lpCandStr = (LPSTR)lpCandList + lpCandList->dwOffset[i];
            *lpDst++ = *lpCandStr++;
            *lpDst++ = *lpCandStr++;
        }
        *lpDst = '\0';
        lpIme->wCount = (WORD)lpCandList->dwCount * 2;
        GlobalUnlock(hCandList);
        GlobalFree(hCandList);
    }
    return (lRet);
}

LRESULT TransGetMNTable( HIMC hImc, LPIMESTRUCT lpIme)
{
    LPSTR   lpMnemonic;
    int     iCount, iCIM;

    UNREFERENCED_PARAMETER(hImc);

    lpMnemonic = (LPSTR)(lpIme->lParam1);
    // Better place would be Registry instead of WIN.INI,
    // but leave it for now.
    iCIM = GetProfileInt(L"WANSUNG", L"InputMethod", IDD_2BEOL) - IDD_2BEOL;
    for (iCount = 0; iCount < 96; iCount++, lpMnemonic += 2)
        {
        *lpMnemonic = LOBYTE(HMNTable[iCIM][iCount]);
        *(lpMnemonic+1) = HIBYTE(HMNTable[iCIM][iCount]);
        }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\layime.c ===
/**************************************************************************\
* Module Name: layout.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* IMM User Mode Routines
*
* History:
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define VERSION_DLL       TEXT("version.dll")
#define VER_FILE_VERSION  TEXT("FileVersion")

#define SZ_BACKSLASH      TEXT("\\")

#define WCHAR_BACKSLASH   L'\\'
#define WCHAR_NULL        L'\0'

#define VERSION_GetFileVersionInfoW     "GetFileVersionInfoW"
#define VERSION_GetFileVersionInfoSizeW "GetFileVersionInfoSizeW"
#define VERSION_VerQueryValueW          "VerQueryValueW"

typedef BOOL  (WINAPI *LPFNGETFILEVERSIONINFOW)(PWSTR, DWORD, DWORD, LPVOID);
typedef DWORD (WINAPI *LPFNGETFILEVERSIONINFOSIZEW)(PWSTR, LPDWORD);
typedef BOOL  (WINAPI *LPFNVERQUERYVALUEW)(const LPVOID, PWSTR, LPVOID*, LPDWORD);
typedef VS_FIXEDFILEINFO *PFIXEDFILEINFO;

static LPFNGETFILEVERSIONINFOW     pfnGetFileVersionInfoW;
static LPFNGETFILEVERSIONINFOSIZEW pfnGetFileVersionInfoSizeW;
static LPFNVERQUERYVALUEW          pfnVerQueryValueW;


BOOL ImmLoadLayout(
    HKL        hKL,
    PIMEINFOEX piiex)
{
    UNICODE_STRING strIme;
    WCHAR    wszIme[MAX_PATH];
    HKEY     hKeyKbdLayout, hKeyIme;
    NTSTATUS Status;
    DWORD    dwTmp;
    LONG     lRet;

    hKeyKbdLayout = NULL;
    hKeyIme = NULL;

#ifdef CUAS_ENABLE
    if (! IS_IME_KBDLAYOUT(hKL) && IS_CICERO_ENABLED_AND_NOT16BIT()) {
        lRet = RegOpenKey(HKEY_LOCAL_MACHINE, gszRegCiceroIME, &hKeyIme);
        if ( lRet != ERROR_SUCCESS ) {
            return FALSE;
        }
    }
    else
#endif // CUAS_ENABLE
    {

        strIme.Buffer = wszIme;
        strIme.MaximumLength = sizeof(wszIme);

        Status = RtlIntegerToUnicodeString(HandleToUlong(hKL), 16, &strIme);
        if (!NT_SUCCESS(Status)) {
            return(FALSE);
        }

        lRet = RegOpenKey(HKEY_LOCAL_MACHINE, gszRegKbdLayout, &hKeyKbdLayout);
        if ( lRet != ERROR_SUCCESS ) {
            return(FALSE);
        }

        lRet = RegOpenKey(hKeyKbdLayout, strIme.Buffer, &hKeyIme);
        if ( lRet != ERROR_SUCCESS ) {
            RegCloseKey(hKeyKbdLayout);
            return(FALSE);
        }
    }

    dwTmp = IM_FILE_SIZE;
    lRet = RegQueryValueEx(hKeyIme,
                           gszValImeFile,
                           NULL,
                           NULL,
                           (LPBYTE)piiex->wszImeFile,
                           &dwTmp);

    if ( lRet != ERROR_SUCCESS ) {
        RegCloseKey(hKeyIme);
        RegCloseKey(hKeyKbdLayout);
        return(FALSE);
    }

    piiex->wszImeFile[IM_FILE_SIZE - 1] = L'\0';

    RegCloseKey(hKeyIme);
    RegCloseKey(hKeyKbdLayout);

    piiex->hkl = hKL;
    piiex->fLoadFlag = IMEF_NONLOAD;

    return LoadVersionInfo(piiex);
}

// GetSystemPathName()
// create "%windir%\system32\%filename"
VOID GetSystemPathName(PWSTR /*OUT*/ pwszPath, PWSTR pwszFileName, UINT maxChar)
{
    UINT fnLen = wcslen(pwszFileName);
    UINT i = GetSystemDirectoryW(pwszPath, maxChar);

    UserAssert(fnLen + 1 < maxChar);
    // avoid error condition
    if (fnLen + 1 >= maxChar) {
        *pwszPath = L'\0';
        return;
    }
    if (i > 0 || i < maxChar - fnLen - 1) {
        pwszPath += i;
        if (pwszPath[-1] != L'\\')
            *pwszPath++ = L'\\';
    }
    wcscpy(pwszPath, pwszFileName);
}

INT
ExtractColumn(
    LPWSTR lpSrc,
    WCHAR  cSeparator,
    UINT   uiColumn
    )

/*++

Routine Description:


Arguments:

    lpSrc - "YYYY.MM.DD" or "HH:MM:SS" or "MM.NN" pointer

Return Value:

    packed int

--*/

{
    UNICODE_STRING uStr;
    WCHAR *pSep, *pStr;
    INT i;

    if (!lpSrc) {
        return 0;
    }

    pStr = pSep = NULL;

    while (uiColumn--) {
        pStr = lpSrc;

        while (*lpSrc && *lpSrc != cSeparator) {
            lpSrc++;
        }

        if (*lpSrc == cSeparator) {
            pSep = lpSrc;
            lpSrc++;
        }
    }

    if (pStr) {
        if (pSep) {
            *pSep = TEXT('\0');
            uStr.Length = (USHORT)((pSep - pStr) * sizeof(WCHAR));
        }
        else {
            uStr.Length = (USHORT)(((lpSrc - pStr) + 1) * sizeof(WCHAR));
        }
        uStr.Buffer = pStr;
        uStr.MaximumLength = (USHORT)(uStr.Length + sizeof(WCHAR));
        RtlUnicodeStringToInteger(&uStr, 0, &i);
        if (pSep) {
            *pSep = cSeparator;
        }
    } else {
        i = 0;
    }

    return i;
}


PWSTR GetVersionDatum(
    PWSTR pszVersionBuffer,
    PWSTR pszVersionKey,
    PWSTR pszName)
{
    ULONG ulSize;
    DWORD cbValue = 0;
    PWSTR pValue;

    ulSize = wcslen(pszVersionKey);
    wcscat(pszVersionKey, pszName);

    (*pfnVerQueryValueW)(pszVersionBuffer,
                          pszVersionKey,
                          (LPVOID*)&pValue,
                          &cbValue);

    pszVersionKey[ulSize] = L'\0';
    return (cbValue != 0) ? pValue : (PWSTR)NULL;
}


BOOL LoadFixVersionInfo(
    PIMEINFOEX piiex,
    PWSTR      pszVersionBuffer)
{
    PFIXEDFILEINFO pFixedVersionInfo;
    BOOL           fResult;
    DWORD          cbValue;

    fResult = (*pfnVerQueryValueW)(pszVersionBuffer,
                                   SZ_BACKSLASH,
                                   &pFixedVersionInfo,
                                   &cbValue);

    if (!fResult || cbValue == 0)
        return FALSE;

    /*
     * Check for IME file type.
     */
    if (pFixedVersionInfo->dwFileType != VFT_DRV ||
        pFixedVersionInfo->dwFileSubtype != VFT2_DRV_INPUTMETHOD) {
        return FALSE;
    }

    piiex->dwProdVersion = pFixedVersionInfo->dwProductVersionMS;

    /*
     * Currently, we only support 4.0 DLL based IME.
     */
    piiex->dwImeWinVersion = IMEVER_0400;

    return TRUE;
}

BOOL LoadVarVersionInfo(
    PIMEINFOEX piiex,
    PWSTR      pszVersionBuffer)
{
    PWSTR   pDescription;
    WORD    wLangId;
    BOOL    fResult;
    PUSHORT puXlate;
    DWORD   cbValue;
    WCHAR   szVersionKey[80];

    fResult = (*pfnVerQueryValueW)(pszVersionBuffer,
                                   L"\\VarFileInfo\\Translation",
                                   (LPVOID *)&puXlate,
                                   &cbValue);

    if (!fResult || cbValue == 0)
        return FALSE;

    wLangId = *puXlate;

    if (piiex->hkl == 0) {
        /*
         * A newly installed IME, its HKL is not assigned yet.
         */
        piiex->hkl = (HKL)LongToHandle( MAKELONG(wLangId, 0) );
    }
#if 0	// let unlocalized IME to work.
    else if (LOWORD(HandleToUlong(piiex->hkl)) != wLangId){
        /*
         * Mismatch in Lang ID, blow out
         */
        return FALSE;
    }
#endif

    /*
     * First try the language we are currently in.
     */
    wsprintf(szVersionKey, L"\\StringFileInfo\\%04X04B0\\",
             LANGIDFROMLCID(GetThreadLocale()));

    pDescription = GetVersionDatum(pszVersionBuffer, szVersionKey,
            L"FileDescription");

    if (pDescription == NULL) {
        /*
         * Now try the first translation specified in IME
         */
        wsprintf(szVersionKey, L"\\StringFileInfo\\%04X%04X\\",
                 *puXlate, *(puXlate+1));

        pDescription = GetVersionDatum(pszVersionBuffer, szVersionKey,
                L"FileDescription");
    }

    if (pDescription != NULL) {
        wcscpy(piiex->wszImeDescription, pDescription);
    }
    else {
        piiex->wszImeDescription[0] = L'\0';
    }

    return TRUE;
}


BOOL LoadVersionInfo(
    PIMEINFOEX piiex)
{
    WCHAR   szPath[MAX_PATH];
    PWSTR   pszVersionBuffer;
    HANDLE  hVersion;
    DWORD   dwVersionSize;
    DWORD   dwHandle = 0;
    BOOL    fUnload, fReturn = FALSE;

    hVersion = GetModuleHandle(VERSION_DLL);
    if (hVersion != NULL) {
        fUnload = FALSE;
    }
    else {
        hVersion = LoadLibrary(VERSION_DLL);
        if (hVersion == NULL) {
            return FALSE;
        }
        fUnload = TRUE;
    }

#define GET_PROC(x) \
    if (!(pfn##x = (PVOID) GetProcAddress(hVersion, VERSION_##x))) { \
        goto LoadVerInfoUnload; }

    GET_PROC(GetFileVersionInfoW);
    GET_PROC(GetFileVersionInfoSizeW);
    GET_PROC(VerQueryValueW);

#undef GET_PROC

    // szPath = fully qualified IME file name
    GetSystemPathName(szPath, piiex->wszImeFile, ARRAY_SIZE(szPath));

    dwVersionSize = (*pfnGetFileVersionInfoSizeW)(szPath, &dwHandle);

    if (dwVersionSize == 0L)
        goto LoadVerInfoUnload;

    pszVersionBuffer = (PWSTR)ImmLocalAlloc(0, dwVersionSize);

    if (pszVersionBuffer == NULL)    // can't get memory for version info, blow out
        goto LoadVerInfoUnload;

    if (!(*pfnGetFileVersionInfoW)(szPath, dwHandle, dwVersionSize, pszVersionBuffer))
        goto LoadVerInfoFree;

    /*
     * Get the fixed block version information.
     */
    if (LoadFixVersionInfo(piiex, pszVersionBuffer)) {
        /*
         * Get the variable block version information.
         */
        fReturn = LoadVarVersionInfo(piiex, pszVersionBuffer);
    }

LoadVerInfoFree:
    ImmLocalFree((HLOCAL)pszVersionBuffer);

LoadVerInfoUnload:
    if (fUnload)
        FreeLibrary(hVersion);

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\imminit.c ===
/****************************** Module Header ******************************\
* Module Name: imminit.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module implements IMM32 initialization
*
* History:
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

// required for wow.obj in userrtl.lib
extern ULONG_PTR gHighestUserAddress;


BOOL ImmInitializeGlobals(HINSTANCE hmod)
{
    SYSTEM_BASIC_INFORMATION SystemInformation;

    if (hmod) {
        /*
         * Remember IMM32.DLL's hmodule so we can grab resources from it later.
         */
        ghInst = hmod;
    }
    if (gfInitialized) {
        return TRUE;
    }
    if (!NT_SUCCESS(RtlInitializeCriticalSection(&gcsImeDpi))) {
        RIPMSG0(RIP_WARNING, "ImmInitializeGlobals: failed to initialize critical section at startup. Just bail.");
        return FALSE;
    }
    if (!NT_SUCCESS(NtQuerySystemInformation(SystemBasicInformation,
            &SystemInformation,
            sizeof(SystemInformation),
            NULL))) {
        RIPMSG0(RIP_WARNING, "ImmInitializeGlobals: failed to query system information. Just bail.");
        return FALSE;
    }
    gHighestUserAddress = SystemInformation.MaximumUserModeAddress;

    gfInitialized = TRUE;

    return TRUE;
}


BOOL ImmRegisterClient(
    IN PSHAREDINFO psiClient, HINSTANCE hmod)
{
    gSharedInfo = *psiClient;
    gpsi = gSharedInfo.psi;
    /* Raid #97316
     * Dlls loaded earlier than imm32.dll could make
     * user32 call which calls back imm routines.
     * ImmRegisterClient() is called from User32's init routine,
     * so we can expect to reach here early enough.
     * We need to initialize globals as much as possible
     * here.
     */
    return ImmInitializeGlobals(hmod);
}

BOOL ImmDllInitialize(
    IN PVOID hmod,
    IN DWORD Reason,
    IN PCONTEXT pctx OPTIONAL)
{
    UNREFERENCED_PARAMETER(pctx);

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:
        UserAssert(!gfInitialized || hmod == ghInst);

        if (!ImmInitializeGlobals(hmod))
            return FALSE;

        UserAssert(hmod != NULL);

        // Initialize USER32.DLL in case if USER32 has not bound itself to IMM32
        if (!User32InitializeImmEntryTable(IMM_MAGIC_CALLER_ID))
            return FALSE;
        break;

    case DLL_PROCESS_DETACH:
        if (gfInitialized) {
            RtlDeleteCriticalSection(&gcsImeDpi);
        }
        break;

    case DLL_THREAD_DETACH:
        if (IS_IME_ENABLED() && NtCurrentTebShared()->Win32ThreadInfo) {
            DestroyInputContext(
                (HIMC)NtUserGetThreadState(UserThreadStateDefaultInputContext),
                GetKeyboardLayout(0),
                TRUE);
        }
        break;

    default:
        break;
    }

    return TRUE;
}


/***************************************************************************\
* Allocation routines for RTL functions.
*
*
\***************************************************************************/

PVOID UserRtlAllocMem(
    ULONG uBytes)
{
    return LocalAlloc(LPTR, uBytes);
}

VOID UserRtlFreeMem(
    PVOID pMem)
{
    LocalFree(pMem);
}

VOID UserRtlRaiseStatus(
    NTSTATUS Status)
{
    RtlRaiseStatus(Status);
}

DWORD GetRipComponent(VOID) { return RIP_IMM; }

DWORD GetDbgTagFlags(int tag)
{
#if DEBUGTAGS
    return (gpsi != NULL ? gpsi->adwDBGTAGFlags[tag] : 0);
#else
    return 0;
    UNREFERENCED_PARAMETER(tag);
#endif // DEBUGTAGS
}

DWORD GetRipPID(VOID) { return (gpsi != NULL ? gpsi->wRIPPID : 0); }
DWORD GetRipFlags(VOID) { return (gpsi != NULL ? gpsi->wRIPFlags : RIPF_DEFAULT); }

extern VOID NtUserSetRipFlags(DWORD, DWORD);

VOID SetRipFlags(DWORD dwRipFlags, DWORD dwRipPID)
{
    NtUserSetRipFlags(dwRipFlags, dwRipPID);
}

VOID SetDbgTag(int tag, DWORD dwBitFlags)
{
    RIPMSG0(RIP_ERROR, "SetDbgTag not available in imm32.dll");
    return;
    UNREFERENCED_PARAMETER(tag);
    UNREFERENCED_PARAMETER(dwBitFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\input.c ===
/**************************************************************************\
* Module Name: input.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* IME key input management routines for imm32 dll
*
* History:
* 01-Apr-1996 takaok       split from hotkey.c
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef HIRO_DEBUG
#define D(x)    x
#else
#define D(x)
#endif

/***************************************************************************\
* ImmProcessKey (Callback from Win32K.SYS)
*
* Call ImeProcessKey and IME hotkey handler
*
* History:
* 01-Mar-1996 TakaoK       Created
\***************************************************************************/

DWORD WINAPI ImmProcessKey(
    HWND    hWnd,
    HKL     hkl,
    UINT    uVKey,
    LPARAM  lParam,
    DWORD   dwHotKeyID)
{
    HIMC hIMC = ImmGetContext(hWnd);
    PIMEDPI pImeDpi = ImmLockImeDpi(hkl);
    DWORD dwReturn = 0;
#if DBG
    if (dwHotKeyID >= IME_KHOTKEY_FIRST && dwHotKeyID <= IME_KHOTKEY_LAST) {
        TAGMSG2(DBGTAG_IMM, "ImmProcessKey: Kor IME Hotkeys should not come here: dwHotKeyID=%x, uVKey=%x", dwHotKeyID, uVKey);
    }
#endif

    ImmAssert(dwHotKeyID != IME_KHOTKEY_ENGLISH &&
              dwHotKeyID != IME_KHOTKEY_SHAPE_TOGGLE &&
              dwHotKeyID != IME_KHOTKEY_HANJACONVERT);

    //
    // call ImeProcessKey
    //
    if (pImeDpi != NULL) {
        PINPUTCONTEXT pInputContext = ImmLockIMC(hIMC);

        if (pInputContext != NULL) {
            BOOLEAN fTruncateWideVK = FALSE;
            BOOLEAN fCallIme = TRUE;
            BOOLEAN fSkipThisKey = FALSE;

#ifdef LATER

            //
            // if the current imc is not open and IME doesn't need
            // keys when being closed, we don't pass any keyboard
            // input to ime except hotkey and keys that change
            // the keyboard status.
            //
            if ((pImeDpi->fdwProperty & IME_PROP_NO_KEYS_ON_CLOSE) &&
                    !pInputContext->fOpen &&
                    uVKey != VK_SHIFT &&
                    uVKey != VK_CONTROL &&
                    uVKey != VK_CAPITAL &&
                    uVKey != VK_KANA &&
                    uVKey != VK_NUMLOCK &&
                    uVKey != VK_SCROLL) {
                // Check if Korea Hanja conversion mode
                if(!(pimc->fdwConvMode & IME_CMODE_HANJACONVERT)) {
                    fCallIme = FALSE;
                }
            }
            else
#endif
            //
            // Protect IMEs which are unaware of wide virtual keys.
            //
            if ((BYTE)uVKey == VK_PACKET &&
                    (pImeDpi->ImeInfo.fdwProperty & IME_PROP_ACCEPT_WIDE_VKEY) == 0) {

                if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) {
                    //
                    // Since this IME is not ready to accept wide VKey, we should
                    // truncate it.
                    //
                    fTruncateWideVK = TRUE;
                }
                else {
                    //
                    // Hmm, this guy is ANSI IME, and does not declare Wide Vkey awareness.
                    // Let's guess this one is not ready to accept Wide Vkey, so let's not
                    // pass it to this guy.
                    // And if it is opened, we'd better skip this key for safety.
                    //
                    fCallIme = FALSE;
                    if (pInputContext->fOpen) {
                        fSkipThisKey = TRUE;
                    }
                }
            }

            if (fCallIme) {
                PBYTE pbKeyState = (PBYTE)ImmLocalAlloc(0, 256);

                ImmAssert(fSkipThisKey == FALSE);

                if (pbKeyState != NULL) {
                    if (GetKeyboardState(pbKeyState)) {
                        UINT uVKeyIme = uVKey;
                        if (fTruncateWideVK) {
                            uVKeyIme &= 0xffff;
                        }
                        if ( (*pImeDpi->pfn.ImeProcessKey)(hIMC, uVKeyIme, lParam, pbKeyState) ) {
                            //
                            // if the return value of ImeProcessKey is TRUE,
                            // it means the key is the one that the ime is
                            // waiting for.
                            //
                            pInputContext->fChgMsg = TRUE;
                            pInputContext->uSavedVKey = uVKey;
                            dwReturn |= IPHK_PROCESSBYIME;
                        }
                    }
                    ImmLocalFree(pbKeyState);
                }
            }
            else if (fSkipThisKey) {
                dwReturn |= IPHK_SKIPTHISKEY;
                ImmAssert((dwReturn & (IPHK_PROCESSBYIME | IPHK_HOTKEY)) == 0);
            }
            ImmUnlockIMC(hIMC);
        }
        ImmUnlockImeDpi(pImeDpi);
    }

    //
    // call hotkey handler
    //
#if !defined(CUAS_ENABLE)
    if (dwHotKeyID != IME_INVALID_HOTKEY && HotKeyIDDispatcher(hWnd, hIMC, hkl, dwHotKeyID)) {
        // Backward compat:
        // On Japanese system, some applications may want VK_KANJI.
        if ((uVKey != VK_KANJI) ||
                (dwHotKeyID != IME_JHOTKEY_CLOSE_OPEN)) {
            dwReturn |= IPHK_HOTKEY;
        }
    }
#else
    //
    // Check MSCTF's keyboard hook is running in this thread. 
    // We can use MSCTF's hotkey handler only when MSCTF's keyboard hook
    // is installed and running.
    //
    if (CtfImmIsCiceroStartedInThread()) {
        BOOL fHandled = FALSE;
        if (Internal_CtfImeProcessCicHotkey(hIMC, uVKey, lParam)) {
                // Backward compat:
                // On Japanese system, some applications may want VK_KANJI.
                if ((uVKey != VK_KANJI) ||
                        (dwHotKeyID != IME_JHOTKEY_CLOSE_OPEN)) {
                    dwReturn |= IPHK_HOTKEY;
                }
                fHandled = TRUE;
        }
        if (!fHandled && IS_IME_KBDLAYOUT(hkl))
        {
            goto TryIMEHotkey;
        }
    } else {
TryIMEHotkey:
        if (dwHotKeyID != IME_INVALID_HOTKEY) {
            if (HotKeyIDDispatcher(hWnd, hIMC, hkl, dwHotKeyID)) {
                // Backward compat:
                // On Japanese system, some applications may want VK_KANJI.
                if ((uVKey != VK_KANJI) ||
                        (dwHotKeyID != IME_JHOTKEY_CLOSE_OPEN)) {
                    dwReturn |= IPHK_HOTKEY;
                }
            }
        }
    }
#endif
    

    //
    // some 3.x application doesn't like to see
    // VK_PROCESSKEY.
    //
    if (dwReturn & IPHK_PROCESSBYIME) {

        DWORD dwImeCompat = ImmGetAppCompatFlags(hIMC);

        if (dwImeCompat & IMECOMPAT_NOVKPROCESSKEY) {

            // Korea 3.x application doesn't like to see dummy finalize VK_PROCESSKEY
            // and IME hot key.

            if ( PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID())) == LANG_KOREAN &&
                 ( (uVKey == VK_PROCESSKEY) || (dwReturn & IPHK_HOTKEY) ) ) {
                ImmReleaseContext(hWnd, hIMC);
                return dwReturn;
            }

            ImmTranslateMessage(hWnd, WM_KEYDOWN, VK_PROCESSKEY, lParam);
            dwReturn &= ~IPHK_PROCESSBYIME;
            dwReturn |= IPHK_SKIPTHISKEY;
        }
    }
    ImmReleaseContext(hWnd, hIMC);

    return dwReturn;
}

#define TRANSMSGCOUNT 256

/***************************************************************************\
* ImmTranslateMessage (Called from user\client\ntstubs.c\TranslateMessage())
*
* Call ImeToAsciiEx()
*
* History:
* 01-Mar-1996 TakaoK       Created
\***************************************************************************/
BOOL ImmTranslateMessage(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    HIMC hImc;
    PINPUTCONTEXT pInputContext;
    BOOL fReturn = FALSE;
    HKL  hkl;
    PIMEDPI pImeDpi = NULL;
    PBYTE pbKeyState;
    PTRANSMSG pTransMsg;
    PTRANSMSGLIST pTransMsgList;
    DWORD dwSize;
    UINT uVKey;
    INT iNum;

    UNREFERENCED_PARAMETER(wParam);

    //
    // we're interested in only those keyboard messages.
    //
    switch (message) {
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        break;
    default:
        return FALSE;
    }

    //
    // input context is necessary for further handling
    //
    hImc = ImmGetContext(hwnd);
    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        ImmReleaseContext(hwnd, hImc);
        return FALSE;
    }

    //
    // At first, handle VK_PROCESSKEY generated by IME.
    //
    if (!pInputContext->fChgMsg) {

        if ((iNum=pInputContext->dwNumMsgBuf) != 0) {

            pTransMsg = (PTRANSMSG)ImmLockIMCC(pInputContext->hMsgBuf);
            if (pTransMsg != NULL) {
                ImmPostMessages(hwnd, hImc, iNum, pTransMsg);
                ImmUnlockIMCC(pInputContext->hMsgBuf);
                fReturn = TRUE;
            }

            pInputContext->dwNumMsgBuf = 0;
        }
        goto ExitITM;
    }

    pInputContext->fChgMsg = FALSE;

    //
    // retrieve the keyboard layout and IME entry points
    //
    hkl = GetKeyboardLayout( GetWindowThreadProcessId(hwnd, NULL) );
    pImeDpi = ImmLockImeDpi(hkl);
    if (pImeDpi == NULL) {
        RIPMSG1(RIP_WARNING, "ImmTranslateMessage pImeDpi is NULL(hkl=%x)", hkl);
        goto ExitITM;
    }

    pbKeyState = ImmLocalAlloc(0, 256);
    if ( pbKeyState == NULL ) {
        RIPMSG0(RIP_WARNING, "ImmTranslateMessage out of memory" );
        goto ExitITM;
    }

    if (!GetKeyboardState(pbKeyState)) {
        RIPMSG0(RIP_WARNING, "ImmTranslateMessage GetKeyboardState() failed" );
        ImmLocalFree( pbKeyState );
        goto ExitITM;
    }

    //
    // Translate the saved vkey into character code if needed
    //
    uVKey = pInputContext->uSavedVKey;

    if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_KBD_CHAR_FIRST) {

        if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) {
            WCHAR wcTemp;

            iNum = ToUnicode(pInputContext->uSavedVKey, // virtual-key code
                             HIWORD(lParam),            // scan code
                             pbKeyState,                // key-state array
                             &wcTemp,                   // buffer for translated key
                             1,                         // size of buffer
                             0);
            if (iNum == 1) {
                //
                // hi word            : unicode character code
                // hi byte of lo word : zero
                // lo byte of lo word : virtual key
                //
                uVKey = (uVKey & 0x00ff) | ((UINT)wcTemp << 16);
            }

        } else {
            WORD wTemp = 0;

            iNum = ToAsciiEx(pInputContext->uSavedVKey, // virtual-key code
                             HIWORD(lParam),            // scan code
                             pbKeyState,                // key-state array
                             &wTemp,                    // buffer for translated key
                             0,                         // active-menu flag
                             hkl);
            ImmAssert(iNum <= 2);
            if (iNum > 0) {
                //
                // hi word            : should be zero
                // hi byte of lo word : character code
                // lo byte of lo word : virtual key
                //
                uVKey = (uVKey & 0x00FF) | ((UINT)wTemp << 8);

                if ((BYTE)uVKey == VK_PACKET) {
                    //
                    // If ANSI IME is wide vkey aware, its ImeToAsciiEx will receive the uVKey
                    // as follows:
                    //
                    //  31            24 23                         16 15                8 7             0
                    // +----------------+-----------------------------+-------------------+---------------+
                    // | 24~31:reserved | 16~23:trailing byte(if any) | 8~15:leading byte | 0~7:VK_PACKET |
                    // +----------------+-----------------------------+-------------------+---------------+
                    //
                    ImmAssert(pImeDpi->ImeInfo.fdwProperty & IME_PROP_ACCEPT_WIDE_VKEY);
                }
                else {
                    uVKey &= 0xffff;
                }
            }
        }
    }

    dwSize = FIELD_OFFSET(TRANSMSGLIST, TransMsg)
           + TRANSMSGCOUNT * sizeof(TRANSMSG);

    pTransMsgList = (PTRANSMSGLIST)ImmLocalAlloc(0, dwSize);

    if (pTransMsgList == NULL) {
        RIPMSG0(RIP_WARNING, "ImmTranslateMessage out of memory" );
        ImmLocalFree(pbKeyState);
        goto ExitITM;
    }

    pTransMsgList->uMsgCount = TRANSMSGCOUNT;
    iNum = (*pImeDpi->pfn.ImeToAsciiEx)(uVKey,
                                        HIWORD(lParam),
                                        pbKeyState,
                                        pTransMsgList,
                                        0,
                                        hImc);

    if (iNum > TRANSMSGCOUNT) {

        //
        // The message buffer is not big enough. IME put messages
        // into hMsgBuf in the input context.
        //

        pTransMsg = (PTRANSMSG)ImmLockIMCC(pInputContext->hMsgBuf);
        if (pTransMsg != NULL) {
            ImmPostMessages(hwnd, hImc, iNum, pTransMsg);
            ImmUnlockIMCC(pInputContext->hMsgBuf);
        }

#ifdef LATER
        // Shouldn't we need this ?
        fReturn = TRUE;
#endif

    } else if (iNum > 0) {
        ImmPostMessages(hwnd, hImc, iNum, &pTransMsgList->TransMsg[0]);
        fReturn = TRUE;
    }

    ImmLocalFree(pbKeyState);
    ImmLocalFree(pTransMsgList);

ExitITM:
    ImmUnlockImeDpi(pImeDpi);
    ImmUnlockIMC(hImc);
    ImmReleaseContext(hwnd, hImc);

    return fReturn;
}

/***************************************************************************\
* ImmPostMessages(Called from ImmTranslateMessage() )
*
*  Post IME messages to application. If application is 3.x, messages
*  are translated to old IME messages.
*
* History:
* 01-Mar-1996 TakaoK       Created
\***************************************************************************/

VOID
ImmPostMessages(
    HWND      hWnd,
    HIMC      hImc,
    INT       iNum,
    PTRANSMSG pTransMsg)
{
    INT i;
    BOOL fAnsiIME;
    PCLIENTIMC pClientImc;
    PTRANSMSG pTransMsgTemp, pTransMsgBuf = NULL;

    //
    // Check if the IME is unicode or not.
    // The message buffer contains unicode messages
    // if the IME is unicode.
    //
    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL) {
        RIPMSG1(RIP_WARNING,
                "ImmPostMessages: Invalid hImc %lx.", hImc);
        return;
    }

    fAnsiIME = ! TestICF(pClientImc, IMCF_UNICODE);
    ImmUnlockClientImc(pClientImc);

    //
    // translate messages to 3.x format if the App's version is 3.x.
    //
    pTransMsgTemp = pTransMsg;
    if (GetClientInfo()->dwExpWinVer < VER40) {
        DWORD dwLangId = PRIMARYLANGID(
                                      LANGIDFROMLCID(
                                                    GetSystemDefaultLCID()));
        if ( (dwLangId == LANG_KOREAN && TransGetLevel(hWnd) == 3) ||
             dwLangId == LANG_JAPANESE ) {

            pTransMsgBuf = ImmLocalAlloc(0, iNum * sizeof(TRANSMSG));
            if (pTransMsgBuf != NULL) {
                RtlCopyMemory(pTransMsgBuf, pTransMsg, iNum * sizeof(TRANSMSG));
                iNum = WINNLSTranslateMessage(iNum,
                                              pTransMsgBuf,
                                              hImc,
                                              fAnsiIME,
                                              dwLangId );
                pTransMsgTemp = pTransMsgBuf;
            }
        }
    }

    for (i = 0; i < iNum; i++) {
        if (fAnsiIME) {
            PostMessageA(hWnd,
                    pTransMsgTemp->message,
                    pTransMsgTemp->wParam,
                    pTransMsgTemp->lParam);
        } else {
            PostMessageW(hWnd,
                    pTransMsgTemp->message,
                    pTransMsgTemp->wParam,
                    pTransMsgTemp->lParam);
        }
        pTransMsgTemp++;
    }

    if (pTransMsgBuf != NULL) {
        ImmLocalFree(pTransMsgBuf);
    }
}

UINT WINNLSTranslateMessage(
    INT       iNum,        // number of messages in the source buffer
    PTRANSMSG pTransMsg,   // source buffer that contains 4.0 style messages
    HIMC      hImc,        // input context handle
    BOOL      fAnsi,       // TRUE if pdwt contains ANSI messages
    DWORD     dwLangId )   // language ID ( KOREAN or JAPANESE )
{
    LPINPUTCONTEXT      pInputContext;
    LPCOMPOSITIONSTRING pCompStr;
    UINT uiRet = 0;

    pInputContext = ImmLockIMC(hImc);
    if (pInputContext == NULL) {
        return uiRet;
    }

    pCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC( pInputContext->hCompStr );

    if (dwLangId == LANG_KOREAN) {
        uiRet = WINNLSTranslateMessageK((UINT)iNum,
                                        pTransMsg,
                                        pInputContext,
                                        pCompStr,
                                        fAnsi );
    } else if ( dwLangId == LANG_JAPANESE ) {
        uiRet = WINNLSTranslateMessageJ((UINT)iNum,
                                        pTransMsg,
                                        pInputContext,
                                        pCompStr,
                                        fAnsi );
    }

    if (pCompStr != NULL) {
        ImmUnlockIMCC(pInputContext->hCompStr);
    }

    ImmUnlockIMC(hImc);

    return uiRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\ktranmsg.c ===
/**************************************************************************\
* Module Name: ktranmsg.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the code for the Korean translation subroutine.
*
* History:
* 15-Jul-1995
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

typedef struct tagMYIMESTRUCT {
    // This is the same as IMESTRUCT
    UINT        fnc;                // function code
    WPARAM      wParam;             // word parameter
    UINT        wCount;             // word counter
    UINT        dchSource;          // offset to pbKeyState
    UINT        dchDest;            // offset to pdwTransBuf
    LPARAM      lParam1;
    LPARAM      lParam2;
    LPARAM      lParam3;
    // My additional buffer
    BYTE        pbKeyState[256];
    DWORD       pdwTransBuf[257];
} MYIMESTRUCT;

typedef MYIMESTRUCT *LPMYIMESTRUCT;

MYIMESTRUCT myIME = { 0, 0, 0, sizeof(IMESTRUCT), sizeof(IMESTRUCT) + 256, 0};

#ifdef KILL_THIS
LRESULT CALLBACK KBHookProc(int iCode, WPARAM wParam, LPARAM lParam)
{
    HKL                 hKL;
    HWND                hWnd;
    HIMC                hIMC = NULL;
    LPINPUTCONTEXT      lpIMC = NULL;
    LPCOMPOSITIONSTRING lpCompStr;
    HTASK               hTask;
    int                 iLoop;

    if (!IsWindow(hWndSub))
        WinExec("wnlssub.exe",SW_HIDE);

    hWnd = GetFocus();
    hKL = GetKeyboardLayout(0);
    if ((hKL & 0xF000FFFFL) != 0xE0000412L || iCode < 0 || iCode == HC_NOREMOVE
        || (HIWORD(lParam) & KF_MENUMODE))
        goto CNH;
    hIMC = ImmGetContext(hWnd);
    if (hIMC == NULL || (lpIMC = ImmLockIMC(hIMC)) == NULL || !lpIMC->fOpen)
        goto CNH;

    if (wParam != VK_MENU && wParam != VK_F10)
        goto DoNext;

    // Menu is press with interim character
    if (HIWORD(lParam) & KF_UP)
        goto CNH;
    SendMsg:
    GetKeyboardState((LPBYTE)myIME.pbKeyState);
    myIME.wParam = wParam;
    myIME.lParam1 = lParam;
    myIME.pdwTransBuf[0] = 255/3;
    if (ImmEscape(hKL, hIMC, IME_ESC_AUTOMATA, (LPIMESTRUCT)&myIME) && myIME.wCount) {
        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        StartStrSvr(lpIMC, lpCompStr, myIME.wCount, myIME.pdwTransBuf, TRUE);
        ImmUnlockIMCC(lpIMC->hCompStr, lpCompStr);
    }
    if (wParam == VK_PROCESSKEY) {
        ImmUnlockIMC(hIMC, lpIMC);
        return 0;
    }
    goto CNH;

    DoNext:
    if ((HIWORD(lParam) & KF_ALTDOWN) && wParam != VK_JUNJA)
        goto CNH;

    if (lpIMC->fOpen != FALSE)
        goto DoHook;

    if ((wParam != VK_HANGEUL && wParam != VK_JUNJA) || (HIWORD(lParam) & KF_UP))
        goto CNH;

    DoHook:
    for (iLoop = 0; iLoop < iIndexOfLevel; iLoop++)
        if (stSaveLevel[iLoop].hLevel == hWnd && stSaveLevel[iLoop].uLevel == 3)
            break;

    if (iLoop >= iIndexOfLevel)
        goto CNH;

    if (wParam == VK_PROCESSKEY)
        goto SendMsg;

    GetKeyboardState((LPBYTE)myIME.pbKeyState);
    myIME.wParam = wParam;
    myIME.lParam1 = lParam;
    myIME.pdwTransBuf[0] = 255/3;
    if (ImmEscape(hKL, hIMC, IME_ESC_AUTOMATA, (LPIMESTRUCT)&myIME) && myIME.wCount) {
        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        StartStrSvr(lpIMC, lpCompStr, myIME.wCount, myIME.pdwTransBuf, FALSE);
        ImmUnlockIMCC(lpIMC->hCompStr, lpCompStr);
        ImmUnlockIMC(hIMC, lpIMC);
    }
    return 1;
    CNH:
    if (lpIMC)
        ImmUnlockIMC(hIMC, lpIMC);

    hTask = (hWnd)? GetWindowTask(hWnd): GetCurrentTask();
    for (iLoop = 0; iLoop < iIndexOfLevel; iLoop++)
        if (stSaveLevel[iLoop].hTask == hTask && IsTask(hTask))
            return CallNextHookEx(stSaveLevel[iLoop].hHook, iCode, wParam, lParam);
    return 0;
}
#endif

/**********************************************************************/
/* WINNLSTranslateMessageK()                                          */
/* translate messages for 3.1 apps
/* Return Value:                                                      */
/*      number of translated message                                  */
/**********************************************************************/
UINT WINNLSTranslateMessageK(int                 iNumMsg,
                             PTRANSMSG           pTransMsg,
                             LPINPUTCONTEXT      lpIMC,
                             LPCOMPOSITIONSTRING lpCompStr,
                             BOOL bAnsiIMC)
{
    HWND    hDefIMEWnd;
    int     i, j;
    static  BYTE bp1stInterim = 0;
    static  BYTE bp2ndInterim = 0;
    BOOL    bAnsiWnd;
    HWND    hWnd;
    WCHAR   wchUni;
    CHAR    chAnsi[2];
    BYTE    bchLow, bchHi, bCh;
    BOOL (WINAPI* fpPostMessage)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
    LRESULT (WINAPI* fpSendMessage)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

    hWnd = (HWND)lpIMC->hWnd;

    hDefIMEWnd = ImmGetDefaultIMEWnd(hWnd);

    bAnsiWnd = !IsWindowUnicode(hWnd) ? TRUE : FALSE;
    if (bAnsiWnd) {
        fpPostMessage = PostMessageA;
        fpSendMessage = SendMessageA;
    } else {
        fpPostMessage = PostMessageW;
        fpSendMessage = SendMessageW;
    }

    for (i = 0; i < iNumMsg; i++) {

        switch (pTransMsg[i].message) {

        case WM_IME_COMPOSITION :

            if (pTransMsg[i].lParam & GCS_RESULTSTR) {

                fpPostMessage(hWnd, WM_IME_REPORT, IR_STRINGSTART, 0L);

                for (j = 0; j < (int)lpCompStr->dwResultStrLen; j++) {
                    LPARAM  lParam = 1L;
                    bCh = 0;
                    if (bAnsiIMC) {
                        bCh = *((LPSTR)lpCompStr + lpCompStr->dwResultStrOffset + j);
                        if (bAnsiWnd) {
                            if (IsDBCSLeadByte(bCh)) {
                                lParam = (bCh >= 0xB0 && bCh <= 0xC8)? 0xFFF10001L: 0xFFF20001L;
                                PostMessageA(hWnd, WM_CHAR, bCh, lParam);
                                bCh = *((LPSTR)lpCompStr + lpCompStr->dwResultStrOffset + ++j);
                            }
                            PostMessageA(hWnd, WM_CHAR, bCh, lParam);
                        } else {
                            chAnsi[0] = bCh;
                            chAnsi[1] = *((LPSTR)lpCompStr + lpCompStr->dwResultStrOffset + ++j);

                            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, chAnsi, 2, &wchUni, 1);

                            PostMessageW(hWnd, WM_CHAR, wchUni, lParam);
                        }
                    } else {    // !bAnsiIMC
                        bCh = *((LPSTR)lpCompStr + lpCompStr->dwResultStrOffset + j * sizeof(WCHAR));
                        wchUni = bCh | ( *((LPSTR)lpCompStr + lpCompStr->dwResultStrOffset +
                                           (j * sizeof(WCHAR) + 1)) << 8);

                        if (bAnsiWnd) {
                            WideCharToMultiByte(CP_ACP, 0, &wchUni, 1, chAnsi, 2, NULL, NULL);

                            bchLow = chAnsi[0];
                            bchHi  = chAnsi[0]; //(BYTE)chAnsi;

                            if (IsDBCSLeadByte(bchLow)) {
                                lParam = (bchLow >= 0xB0 && bchLow <= 0xC8) ? 0xFFF10001L: 0xFFF20001L;
                                PostMessageA(hWnd, WM_CHAR, bchLow, lParam);
                                bchHi = chAnsi[1];
                            }

                            PostMessageA(hWnd, WM_CHAR, bchHi, lParam);
                        } else {
                            PostMessageW(hWnd, WM_CHAR, wchUni, lParam);
                        }
                    }
                }

                fpPostMessage(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);

            } else {    // !(pTransMsg[i].lParam & GCS_RESULTSTR)

                if (pTransMsg[i].wParam) {

                    fpPostMessage(hWnd, WM_IME_REPORT, IR_STRINGSTART, 0L);

                    bp1stInterim = HIBYTE(LOWORD(pTransMsg[i].wParam));
                    bp2ndInterim = LOBYTE(LOWORD(pTransMsg[i].wParam));

                    if (bAnsiIMC) {
                        if (bAnsiWnd) {
                            PostMessageA(hWnd, WM_INTERIM, bp1stInterim, 0x00F00001L);
                            PostMessageA(hWnd, WM_INTERIM, bp2ndInterim, 0x00F00001L);
                            PostMessageA(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);
                        } else {
                            chAnsi[0] = bp1stInterim;
                            chAnsi[1] = bp2ndInterim;

                            if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, chAnsi, 2, &wchUni, 1))
                                PostMessageW(hWnd, WM_INTERIM, wchUni, 0x00F00001L);
                            PostMessageW(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);
                        }

                    } else {
                        if (bAnsiWnd) {
                            wchUni = (bp1stInterim << 8) | bp2ndInterim;  //(WORD)lpdwTransKey[i*3 + 1];
                            WideCharToMultiByte(CP_ACP, 0, &wchUni, 1, chAnsi, 2, NULL, NULL);

                            bchLow = chAnsi[0];
                            bchHi  = chAnsi[1];

                            PostMessageA(hWnd, WM_INTERIM, bchLow, 0x00F00001L);
                            PostMessageA(hWnd, WM_INTERIM, bchHi,  0x00F00001L);
                            PostMessageA(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);
                        } else {
                            PostMessageW(hWnd, WM_INTERIM, pTransMsg[i].wParam, 0x00F00001L);
                            PostMessageW(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);
                        }
                    }
                    fpSendMessage(hDefIMEWnd, WM_IME_ENDCOMPOSITION, 0, 0L);

                } else {    // !pTransMsg[i].wParam

                    fpPostMessage(hWnd, WM_IME_REPORT, IR_STRINGSTART, 0L);

                    if (bAnsiIMC) {
                        if (bAnsiWnd) {
                            PostMessageA(hWnd, WM_CHAR, bp1stInterim, 0xFFF10001L);
                            PostMessageA(hWnd, WM_CHAR, bp2ndInterim, 0xFFF10001L);
                            PostMessageA(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);
                            PostMessageA(hWnd, WM_KEYDOWN, VK_BACK, 0x000E0001L);
                        } else {
                            chAnsi[0] = bp1stInterim;
                            chAnsi[1] = bp2ndInterim;

                            if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, chAnsi, 2, &wchUni, 1))
                                PostMessageW(hWnd, WM_CHAR, wchUni, 0xFFF10001L);

                            PostMessageW(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);
                            PostMessageW(hWnd, WM_KEYDOWN, VK_BACK, 0x000E0001L);
                        }
                    } else {    // !bAnsiIMC
                        if (bAnsiWnd) {
                            wchUni = (bp1stInterim << 8 ) | bp2ndInterim;

                            WideCharToMultiByte(CP_ACP, 0, &wchUni, 1, chAnsi, 2, NULL, NULL);

                            bchLow = chAnsi[0];
                            bchHi  = chAnsi[1];

                            PostMessageA(hWnd, WM_CHAR, bchLow, 0xFFF10001L);
                            PostMessageA(hWnd, WM_CHAR, bchHi,  0xFFF10001L);
                            PostMessageA(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);
                            PostMessageA(hWnd, WM_KEYDOWN, VK_BACK, 0x000E0001L);
                        } else {
                            wchUni = bp1stInterim | (bp2ndInterim << 8);

                            PostMessageW(hWnd, WM_CHAR, wchUni, 0xFFF10001L);
                            PostMessageW(hWnd, WM_IME_REPORT, IR_STRINGEND, 0L);
                            PostMessageW(hWnd, WM_KEYDOWN, VK_BACK, 0x000E0001L);
                        }
                    }
                }
            }
            break;

        case WM_IME_STARTCOMPOSITION :
        case WM_IME_ENDCOMPOSITION :
            break;

        case WM_IME_KEYDOWN:
            fpPostMessage(hWnd, WM_KEYDOWN, LOWORD(pTransMsg[i].wParam),
                          pTransMsg[i].lParam);
            break;

        case WM_IME_KEYUP:
            fpPostMessage(hWnd, WM_KEYUP, LOWORD(pTransMsg[i].wParam),
                          pTransMsg[i].lParam);
            break;

        default :
            fpSendMessage(hDefIMEWnd, pTransMsg[i].message,
                          pTransMsg[i].wParam, pTransMsg[i].lParam);
            break;
        }
    }

    return 0;   // indicates all messages are post/sent within this function.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\layout.c ===
/**************************************************************************\
* Module Name: layout.c (corresponds to Win95 ime.c)
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* IME Keyboard Layout related functionality
*
* History:
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Local Defines.
 */
#define szLZOpenFileW "LZOpenFileW"
#define szLZCopy      "LZCopy"
#define szLZClose     "LZClose"

typedef HFILE (WINAPI *LPFNLZOPENFILEW)(LPTSTR, LPOFSTRUCT, WORD);
typedef LONG  (WINAPI *LPFNLZCOPY)(INT, INT);
typedef VOID  (WINAPI *LPFNLZCLOSE)(INT);

/*
 * Local Routines.
 */
UINT StrToUInt(LPWSTR);
VOID UIntToStr(UINT, ULONG, LPWSTR, USHORT);
BOOL CopyImeFile(LPWSTR, LPCWSTR);
INT  GetImeLayout(PIMELAYOUT, INT);
BOOL WriteImeLayout(HKL, LPCWSTR, LPCWSTR);
HKL  AssignNewLayout(INT, PIMELAYOUT, HKL);


/***************************************************************************\
* ImmGetIMEFileNameW
*
* Gets the description of the IME with the specified HKL.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

UINT WINAPI ImmGetDescriptionW(
    HKL    hKL,
    LPWSTR lpwszDescription,
    UINT   uBufLen)
{
    IMEINFOEX iiex;
    UINT uRet;

    if (!ImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayout, &hKL))
        return 0;

#if defined(CUAS_ENABLE)
    if (!IS_IME_KBDLAYOUT(hKL))
        return 0;
#endif

    uRet = wcslen(iiex.wszImeDescription);

    /*
     * ask buffer length
     */
    if (uBufLen == 0)
        return uRet;

    if (uBufLen > uRet) {
        wcscpy(lpwszDescription, iiex.wszImeDescription);
    }
    else {
        uRet = uBufLen - 1;
        wcsncpy(lpwszDescription, iiex.wszImeDescription, uRet);
        lpwszDescription[uRet] = L'\0';
    }

    return uRet;
}


/***************************************************************************\
* ImmGetIMEFileNameA
*
* Gets the description of the IME with the specified HKL.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

UINT WINAPI ImmGetDescriptionA(
    HKL   hKL,
    LPSTR lpszDescription,
    UINT  uBufLen)
{
    IMEINFOEX iiex;
    INT       i;
    BOOL      bUDC;

    if (!ImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayout, &hKL))
        return 0;

#if defined(CUAS_ENABLE)
    if (!IS_IME_KBDLAYOUT(hKL))
        return 0;
#endif

    i = WideCharToMultiByte(CP_ACP,
                            (DWORD)0,
                            (LPWSTR)iiex.wszImeDescription,       // src
                            wcslen(iiex.wszImeDescription),
                            lpszDescription,                      // dest
                            uBufLen,
                            (LPSTR)NULL,
                            (LPBOOL)&bUDC);

    if (uBufLen != 0)
        lpszDescription[i] = '\0';

    return (UINT)i;
}


/***************************************************************************\
* ImmGetIMEFileNameW
*
* Gets the file name of the IME with the specified HKL.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

UINT WINAPI ImmGetIMEFileNameW(
    HKL    hKL,
    LPWSTR lpwszFile,
    UINT   uBufLen)
{
    IMEINFOEX iiex;
    UINT uRet;

    if (!ImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayout, &hKL))
        return 0;

#if defined(CUAS_ENABLE)
    if (!IS_IME_KBDLAYOUT(hKL))
    {
        //
        // #602631
        //
        // Ichitaro12 ATOKLIB.DLL does not check the return value of
        // ImmGetIMEFileName()
        //
        if (uBufLen)
            *lpwszFile = L'\0';
        return 0;
    }
#endif

    uRet = wcslen(iiex.wszImeFile);

    /*
     * ask buffer length
     */
    if (uBufLen == 0)
        return uRet;

    if (uBufLen > uRet) {
        wcscpy(lpwszFile, iiex.wszImeFile);
    }
    else {
        uRet = uBufLen - 1;
        wcsncpy(lpwszFile, iiex.wszImeFile, uRet);
        lpwszFile[uRet] = L'\0';
    }

    return uRet;
}


/***************************************************************************\
* ImmGetIMEFileNameA
*
* Gets the file name of the IME with the specified HKL.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

UINT WINAPI ImmGetIMEFileNameA(
    HKL   hKL,
    LPSTR lpszFile,
    UINT  uBufLen)
{
    IMEINFOEX iiex;
    INT       i;
    BOOL      bUDC;

    if (!ImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayout, &hKL))
        return 0;

#if defined(CUAS_ENABLE)
    if (!IS_IME_KBDLAYOUT(hKL))
    {
        //
        // #602631
        //
        // Ichitaro12 ATOKLIB.DLL does not check the return value of
        // ImmGetIMEFileName()
        //
        if (uBufLen)
            *lpszFile = '\0';
        return 0;
    }
#endif

    i = WideCharToMultiByte(CP_ACP,
                            (DWORD)0,
                            (LPWSTR)iiex.wszImeFile,       // src
                            wcslen(iiex.wszImeFile),
                            lpszFile,                      // dest
                            uBufLen,
                            (LPSTR)NULL,
                            (LPBOOL)&bUDC);

    if (uBufLen != 0)
        lpszFile[i] = '\0';

    return i;
}


/***************************************************************************\
* ImmGetProperty
*
* Gets the property and capability of the IME with the specified HKL.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

DWORD WINAPI ImmGetProperty(
    HKL     hKL,
    DWORD   dwIndex)
{
    IMEINFOEX iiex;
    PIMEDPI   pImeDpi = NULL;
    PIMEINFO  pImeInfo;
    DWORD     dwRet;

    if (!ImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayout, &hKL))
        return 0;

    if (dwIndex == IGP_GETIMEVERSION)
        return iiex.dwImeWinVersion;

    if (iiex.fLoadFlag != IMEF_LOADED) {
        pImeDpi = FindOrLoadImeDpi(hKL);
        if (pImeDpi == NULL) {
            RIPMSG0(RIP_WARNING, "ImmGetProperty: load IME failure.");
            return 0;
        }
        pImeInfo = &pImeDpi->ImeInfo;
    }
    else {
        pImeInfo = &iiex.ImeInfo;
    }

    switch (dwIndex) {
    case IGP_PROPERTY:
        dwRet = pImeInfo->fdwProperty;
        break;

    case IGP_CONVERSION:
        dwRet = pImeInfo->fdwConversionCaps;
        break;

    case IGP_SENTENCE:
        dwRet = pImeInfo->fdwSentenceCaps;
        break;

    case IGP_UI:
        dwRet = pImeInfo->fdwUICaps;
        break;

    case IGP_SETCOMPSTR:
        dwRet = pImeInfo->fdwSCSCaps;
        break;

    case IGP_SELECT:
        dwRet = pImeInfo->fdwSelectCaps;
        break;

    default:
        RIPMSG1(RIP_WARNING, "ImmGetProperty: wrong index %lx.", dwIndex);
        dwRet = 0;
        break;
    }

    ImmUnlockImeDpi(pImeDpi);

    return dwRet;
}


HKL WINAPI ImmInstallIMEW(
    LPCWSTR lpszIMEFileName,
    LPCWSTR lpszLayoutText)
{
    LPWSTR     lpwszImeFileName;
    LPWSTR     lpwszImeFilePart;
    LPWSTR     lpwszImeCopiedPath;
    int        i, nIMEs;
    PIMELAYOUT pImeLayout = NULL;
    HKL        hImeKL, hLangKL;
    WCHAR      szKeyName[HEX_ASCII_SIZE];
    IMEINFOEX  iiex;

    lpwszImeFileName = ImmLocalAlloc(0, (MAX_PATH+1) * sizeof(WCHAR));
    if (lpwszImeFileName == NULL)
        return (HKL)0;

    lpwszImeCopiedPath = ImmLocalAlloc(0, (MAX_PATH+1) * sizeof(WCHAR));
    if (lpwszImeCopiedPath == NULL) {
        ImmLocalFree(lpwszImeFileName);
        return (HKL)0;
    }

    /*
     * Get the file name only into lpwszImeFilePart
     */
    GetFullPathNameW(lpszIMEFileName, MAX_PATH,
                lpwszImeFileName, &lpwszImeFilePart);

    CharUpper(lpwszImeFileName);

    if (lpwszImeFilePart == NULL) {
        ImmLocalFree(lpwszImeFileName);
        ImmLocalFree(lpwszImeCopiedPath);
        return (HKL)0;
    }

    hImeKL = hLangKL = iiex.hkl = (HKL)0;

    wcsncpy(iiex.wszImeFile, lpwszImeFilePart, IM_FILE_SIZE-1);
    iiex.wszImeFile[IM_FILE_SIZE - 1] = L'\0';

    if (LoadVersionInfo(&iiex) && iiex.hkl != (HKL)0) {
        hLangKL = iiex.hkl;
    }
    else {
        ImmLocalFree(lpwszImeFileName);
        ImmLocalFree(lpwszImeCopiedPath);
        return (HKL)0;
    }

    nIMEs = GetImeLayout(NULL, 0);
    if (nIMEs != 0) {
        pImeLayout = (PIMELAYOUT)ImmLocalAlloc(0, nIMEs * sizeof(IMELAYOUT));
        if (pImeLayout == NULL) {
            ImmLocalFree(lpwszImeFileName);
            ImmLocalFree(lpwszImeCopiedPath);
            return (HKL)0;
        }

        GetImeLayout(pImeLayout, nIMEs);

        for (i=0; i < nIMEs; i++) {
            if (_wcsicmp(pImeLayout[i].szImeName, lpwszImeFilePart) == 0) {
                /*
                 * We got the same IME name, ISV wants to upgrade.
                 */
                if (LOWORD(HandleToUlong(hLangKL)) != LOWORD(HandleToUlong(pImeLayout[i].hImeKL))) {
                    /*
                     * IME name conflict, blow out!
                     */
                    RIPMSG0(RIP_WARNING, "ImmInstallIME: different language!");
                    goto ImmInstallIMEWFailed;
                }

                hImeKL = pImeLayout[i].hImeKL;
                break;
            }
        }
    }

    if (ImmGetImeInfoEx(&iiex, ImeInfoExImeFileName, lpwszImeFilePart)) {
        /*
         * The specified IME has been activated. Unload it first.
         */
        if (!UnloadKeyboardLayout(iiex.hkl)) {
            hImeKL = (HKL)0;
            goto ImmInstallIMEWFailed;
        }
    }

    /*
     * We will copy to system directory
     */
#if 0
    i = (INT)GetSystemDirectory(lpwszImeCopiedPath, MAX_PATH);
    lpwszImeCopiedPath[i] = L'\0';
    AddBackslash(lpwszImeCopiedPath);
    wcscat(lpwszImeCopiedPath, lpwszImeFilePart);
#else
    GetSystemPathName(lpwszImeCopiedPath, lpwszImeFilePart, MAX_PATH);
#endif
    CharUpper(lpwszImeCopiedPath);

    if (_wcsicmp(lpwszImeFileName, lpwszImeCopiedPath) != 0) {
        /*
         * path is different, need to copy into system directory
         */
        if (!CopyImeFile(lpwszImeFileName, lpwszImeCopiedPath)) {
            hImeKL = (HKL)0;
            goto ImmInstallIMEWFailed;
        }
    }

    if (hImeKL == 0) {
        hImeKL = AssignNewLayout(nIMEs, pImeLayout, hLangKL);
    }

    if (hImeKL != 0) {
        /*
         * Write HKL under "keyboard layouts"
         */
        if (WriteImeLayout(hImeKL, lpwszImeFilePart, lpszLayoutText)) {
            UIntToStr(HandleToUlong(hImeKL), 16, szKeyName, sizeof(szKeyName));
            hImeKL = LoadKeyboardLayout(szKeyName, KLF_REPLACELANG);
        }
        else {
            hImeKL = (HKL)0;
        }
    }

ImmInstallIMEWFailed:
    if (pImeLayout != NULL)
        ImmLocalFree(pImeLayout);
    ImmLocalFree(lpwszImeFileName);
    ImmLocalFree(lpwszImeCopiedPath);

    return (HKL)hImeKL;
}


HKL WINAPI ImmInstallIMEA(
    LPCSTR lpszIMEFileName,
    LPCSTR lpszLayoutText)
{
    HKL    hKL;
    LPWSTR lpwszIMEFileName;
    LPWSTR lpwszLayoutText;
    DWORD  cbIMEFileName;
    DWORD  cbLayoutText;
    INT    i;

    cbIMEFileName = strlen(lpszIMEFileName) + sizeof(CHAR);
    cbLayoutText  = strlen(lpszLayoutText)  + sizeof(CHAR);

    lpwszIMEFileName = ImmLocalAlloc(0, cbIMEFileName * sizeof(WCHAR));
    if (lpwszIMEFileName == NULL) {
        RIPMSG0(RIP_WARNING, "ImmInstallIMEA: memory failure!");
        return (HKL)0;
    }

    lpwszLayoutText = ImmLocalAlloc(0, cbLayoutText * sizeof(WCHAR));
    if (lpwszLayoutText == NULL) {
        RIPMSG0(RIP_WARNING, "ImmInstallIMEA: memory failure!");
        ImmLocalFree(lpwszIMEFileName);
        return (HKL)0;
    }

    i = MultiByteToWideChar(CP_ACP,
                            (DWORD)MB_PRECOMPOSED,
                            (LPSTR)lpszIMEFileName,              // src
                            (INT)strlen(lpszIMEFileName),
                            (LPWSTR)lpwszIMEFileName,            // dest
                            (INT)cbIMEFileName);
    lpwszIMEFileName[i] = L'\0';

    i = MultiByteToWideChar(CP_ACP,
                            (DWORD)MB_PRECOMPOSED,
                            (LPSTR)lpszLayoutText,              // src
                            (INT)strlen(lpszLayoutText),
                            (LPWSTR)lpwszLayoutText,            // dest
                            (INT)cbLayoutText);
    lpwszLayoutText[i] = L'\0';

    hKL = ImmInstallIMEW(lpwszIMEFileName, lpwszLayoutText);

    ImmLocalFree(lpwszLayoutText);
    ImmLocalFree(lpwszIMEFileName);

    return hKL;
}


/***************************************************************************\
* ImmIsIME
*
* Checks whether the specified hKL is a HKL of an IME or not.
*
* History:
* 28-Feb-1995   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmIsIME(
    HKL hKL)
{
    IMEINFOEX iiex;

#if !defined(CUAS_ENABLE)
    if (!ImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayout, &hKL))
        return FALSE;
#else
    if (!ImmGetImeInfoEx(&iiex, ImeInfoExKeyboardLayoutWithCUAS, &hKL))
        return FALSE;
#endif

    return TRUE;
}


UINT StrToUInt(
    LPWSTR lpsz)
{
    UNICODE_STRING Value;
    UINT ReturnValue;

    Value.Length = wcslen(lpsz) * sizeof(WCHAR);
    Value.Buffer = lpsz;

    /*
     * Convert string to int.
     */
    RtlUnicodeStringToInteger(&Value, 16, &ReturnValue);
    return(ReturnValue);
}


VOID UIntToStr(
    UINT   Value,
    ULONG  Base,
    LPWSTR lpsz,
    USHORT dwBufLen)
{
    UNICODE_STRING String;

    String.Length = dwBufLen;
    String.MaximumLength = dwBufLen;
    String.Buffer = lpsz;

    /*
     * Convert int to string.
     */
    RtlIntegerToUnicodeString(Value, Base, &String);
}


BOOL CopyImeFile(
    LPWSTR lpwszImeFileName,
    LPCWSTR lpwszImeCopiedPath)
{
    HMODULE         hLzExpandDll;
    BOOL            fUnloadExpandDll;
    LPFNLZOPENFILEW lpfnLZOpenFileW;
    LPFNLZCOPY      lpfnLZCopy;
    LPFNLZCLOSE     lpfnLZClose;
    OFSTRUCT        ofStruc;
    HFILE           hfSource, hfDest;
    LPSTR           lpszImeCopiedPath;
    INT             i, cbBuffer;
    BOOL            fRet = FALSE;

    hLzExpandDll = GetModuleHandle(L"LZ32");
    if (hLzExpandDll) {
        fUnloadExpandDll = FALSE;
    } else {
        WCHAR szLzExpand[MAX_PATH];

        GetSystemPathName(szLzExpand, L"LZ32", MAX_PATH);
        hLzExpandDll = LoadLibrary(szLzExpand);
        if (!hLzExpandDll) {
            return FALSE;
        }

        fUnloadExpandDll = TRUE;
    }

#define GET_PROC(x) \
    if (!(lpfn##x = (PVOID) GetProcAddress(hLzExpandDll, sz##x))) { \
        goto CopyImeFileFailed; }

    GET_PROC(LZOpenFileW);
    GET_PROC(LZCopy);
    GET_PROC(LZClose);

#undef GET_PROC

    cbBuffer = (wcslen(lpwszImeCopiedPath) + 1) * sizeof(WCHAR);

    if ((lpszImeCopiedPath = ImmLocalAlloc(0, cbBuffer)) == NULL)
        goto CopyImeFileFailed;

    i = WideCharToMultiByte(CP_ACP,
                            (DWORD)0,
                            lpwszImeCopiedPath,          // src
                            wcslen(lpwszImeCopiedPath),
                            lpszImeCopiedPath,           // dest
                            cbBuffer,
                            (LPSTR)NULL,
                            (LPBOOL)NULL);
    if (i == 0) {
        ImmLocalFree(lpszImeCopiedPath);
        goto CopyImeFileFailed;
    }

    lpszImeCopiedPath[i] = '\0';

    hfSource = (*lpfnLZOpenFileW)(lpwszImeFileName, &ofStruc, OF_READ);
    if (hfSource < 0) {
        ImmLocalFree(lpszImeCopiedPath);
        goto CopyImeFileFailed;
    }

    hfDest = OpenFile(lpszImeCopiedPath, &ofStruc, OF_CREATE);
    if (hfDest != HFILE_ERROR) {
        if ((*lpfnLZCopy)(hfSource, hfDest) >= 0) {
            fRet = TRUE;
        }
        _lclose(hfDest);
    }

    (*lpfnLZClose)(hfSource);

    ImmLocalFree(lpszImeCopiedPath);

CopyImeFileFailed:
    if (fUnloadExpandDll)
        FreeLibrary(hLzExpandDll);

    return fRet;
}


INT GetImeLayout(
    PIMELAYOUT pImeLayout,
    INT        cEntery)
{
    int      i, nIMEs;
    HKEY     hKeyKbdLayout;
    HKEY     hKeyOneIME;
    WCHAR    szKeyName[HEX_ASCII_SIZE];
    WCHAR    szImeFileName[IM_FILE_SIZE];
    CONST DWORD dwKeyNameSize = ARRAY_SIZE(szKeyName);
    DWORD    dwTmp;

    RegOpenKey(HKEY_LOCAL_MACHINE, gszRegKbdLayout, &hKeyKbdLayout);

    for (i = 0, nIMEs = 0;
         RegEnumKey(hKeyKbdLayout, i, szKeyName, dwKeyNameSize) == ERROR_SUCCESS;
         i++)
    {
        if (szKeyName[0] != L'E' && szKeyName[0] != L'e')
            continue;   // this is not an IME based keyboard layout.

        if (pImeLayout != NULL) {

            if (nIMEs >= cEntery)
                break;

            RegOpenKey(hKeyKbdLayout, szKeyName, &hKeyOneIME);

            dwTmp = IM_FILE_SIZE;

            RegQueryValueEx(hKeyOneIME,
                    gszValImeFile,
                    NULL,
                    NULL,
                    (LPBYTE)szImeFileName,
                    &dwTmp);

            // avoid length problem
            szImeFileName[IM_FILE_SIZE - 1] = L'\0';

            RegCloseKey(hKeyOneIME);

            CharUpper(szImeFileName);

            pImeLayout[nIMEs].hImeKL = (HKL)IntToPtr( StrToUInt(szKeyName) );
            wcscpy(pImeLayout[nIMEs].szKeyName, szKeyName);
            wcscpy(pImeLayout[nIMEs].szImeName, szImeFileName);
        }

        nIMEs++;
    }

    RegCloseKey(hKeyKbdLayout);

    return nIMEs;
}


BOOL WriteImeLayout(
    HKL     hImeKL,
    LPCWSTR lpwszImeFilePart,
    LPCWSTR lpszLayoutText)
{
    int      i;
    HKEY     hKeyKbdLayout;
    HKEY     hKeyOneIME;
    HKEY     hKeyKbdOrder;
    WCHAR    szKeyName[HEX_ASCII_SIZE];
    WCHAR    szImeFileName[IM_FILE_SIZE];
    WCHAR    szOrderNum[HEX_ASCII_SIZE];
    WCHAR    szOrderKeyName[HEX_ASCII_SIZE];
    DWORD    dwTmp;

    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   gszRegKbdLayout,
                   &hKeyKbdLayout) != ERROR_SUCCESS) {
        RIPMSG0(RIP_WARNING, "WriteImeLayout: RegOpenKey() failed!");
        return FALSE;
    }

    UIntToStr(HandleToUlong(hImeKL), 16, szKeyName, sizeof(szKeyName));

    if (RegCreateKey(hKeyKbdLayout,
                szKeyName,
                &hKeyOneIME) != ERROR_SUCCESS) {
        RIPMSG0(RIP_WARNING, "WriteImeLayout: RegCreateKey() failed!");
        RegCloseKey(hKeyKbdLayout);
        return FALSE;
    }

    if (RegSetValueExW(hKeyOneIME,
                gszValImeFile,
                0,
                REG_SZ,
                (CONST BYTE*)lpwszImeFilePart,
                (wcslen(lpwszImeFilePart) + 1) * sizeof(WCHAR)) != ERROR_SUCCESS) {
        goto WriteImeLayoutFail;
    }

    if (RegSetValueExW(hKeyOneIME,
                gszValLayoutText,
                0,
                REG_SZ,
                (CONST BYTE*)lpszLayoutText,
                (wcslen(lpszLayoutText) + 1) * sizeof(WCHAR)) != ERROR_SUCCESS) {
        goto WriteImeLayoutFail;
    }

    switch (LANGIDFROMHKL(hImeKL)) {
        case LANG_JAPANESE:
            wcscpy(szImeFileName, L"kbdjpn.dll");
            break;
        case LANG_KOREAN:
            wcscpy(szImeFileName, L"kbdkor.dll");
            break;
        case LANG_CHINESE:
        default:
            wcscpy(szImeFileName, L"kbdus.dll");
            break;
    }

    if (RegSetValueExW(hKeyOneIME,
                gszValLayoutFile,
                0,
                REG_SZ,
                (CONST BYTE*)szImeFileName,
                (wcslen(szImeFileName) + 1) * sizeof(WCHAR)) != ERROR_SUCCESS) {
        goto WriteImeLayoutFail;
    }

    RegCloseKey(hKeyOneIME);
    RegCloseKey(hKeyKbdLayout);

    /*
     * Update CurrentUser's preload keyboard layout setting
     */
    RegCreateKey(HKEY_CURRENT_USER, gszRegKbdOrder, &hKeyKbdOrder);

    for (i = 1; i < 1024; i++) {
        UIntToStr(i, 10, szOrderNum, sizeof(szOrderNum));

        dwTmp = sizeof(szOrderKeyName);
        if (RegQueryValueEx(hKeyKbdOrder,
                    szOrderNum,
                    NULL,
                    NULL,
                    (LPBYTE)szOrderKeyName,
                    &dwTmp) != ERROR_SUCCESS) {
            break;
        }

        if (_wcsicmp(szKeyName, szOrderKeyName) == 0) {
            /*
             * We have the same value in the preload!
             * OK, ISV is developing their IMEs
             * so even it is in preload, but it can not be loaded
             */
            break;
        }
    }

    if (i < 1024) {
        /*
         * Write a subkey under "preload"
         */
        RegSetValueExW(hKeyKbdOrder,
                       szOrderNum,
                       0,
                       REG_SZ,
                       (CONST BYTE*)szKeyName,
                       (lstrlen(szKeyName) + 1) * sizeof(WCHAR));
        RegCloseKey(hKeyKbdOrder);
    }
    else {
        RegCloseKey(hKeyKbdOrder);
        return FALSE;
    }

    return TRUE;

WriteImeLayoutFail:
    RegCloseKey(hKeyOneIME);
    RegDeleteKey(hKeyKbdLayout, szKeyName);
    RegCloseKey(hKeyKbdLayout);

    return FALSE;
}

#define IMELANGID(hkl) \
    LOWORD(HandleToUlong(hkl))

#define IMELAYOUTID(hkl) \
    HIWORD(HandleToUlong(hkl))

HKL AssignNewLayout(
    INT         nIMEs,
    PIMELAYOUT  pImeLayout,
    HKL         hLangKL)
{
    DWORD   dwNewId  = 0;
    DWORD   dwHighId = 0xE01F;
    DWORD   dwLowId  = 0xE0FF;
    INT     i;

    /*
     * We prefer the value higher than E01F for ISVs, we will use
     * E001 ~ E01F in Microsoft .INF file
     */

    /*
     * Find out the high and low one
     */
    for (i = 0; i < nIMEs; ++i) {
        /*
         * Let's try to keep the previous behavior, not to
         * have the duplicated hiword in hkl.
         */
        if (IMELAYOUTID(pImeLayout[i].hImeKL) > dwHighId) {
            dwHighId = IMELAYOUTID(pImeLayout[i].hImeKL);
        }
        if (IMELAYOUTID(pImeLayout[i].hImeKL) < dwLowId) {
            dwLowId = IMELAYOUTID(pImeLayout[i].hImeKL);
        }
    }

    if (dwHighId < 0xE0FF) {
        dwNewId = dwHighId + 1;
    } else if (dwLowId > 0xE001) {
        dwNewId = dwLowId - 1;
    } else {
        /*
         * Need to find out unused hKL using full search.
         * Find it one by one.
         */
        DWORD dwId;

        for (dwId = 0xE020; dwId < 0xE100; ++dwId) {
            for (i = 0; i < nIMEs; ++i) {
                if (IMELAYOUTID(pImeLayout[i].hImeKL) == dwId &&
                    IMELANGID(pImeLayout[i].hImeKL) == IMELANGID(hLangKL)) {
                    // conflicts with existing IME, try the next dwLowId
                    break;
                }
            }

            if (i >= nIMEs) {
                break;
            }

        }

        if (dwId < 0xE100) {
            dwNewId = dwId;
        }
    }

    if (dwNewId == 0) {
        return NULL;
    }

    return (HKL)UIntToPtr(MAKELONG(IMELANGID(hLangKL), dwNewId));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\makefile.inc ===
$(PRIVLIB) $(PRIVLIB:.lib=.exp): \
!if "$(BUILD_PASS)" != "PASS2"
    $(LIBRARY_OBJS) \
!endif    
    $(O)\$(TARGETNAMEP).def
   -$(LIB_NAME) -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\$(TARGETNAMEP).def
$(LIBRARY_OBJS)
<<NOKEEP


C_DEFINES=$(C_DEFINES) -DPRIVATE=
$(O)\$(TARGETNAMEP).def: $(DLLDEF)
    $(C_PREPROCESSOR) $(DLLDEF) > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrdll.h>
#include <ntcsrsrv.h>
#define NONTOSPINTERLOCK
#include <ntosp.h>

#include <stdarg.h>
#include <stdio.h>
#include <excpt.h>
#include <string.h>
#include <limits.h>
#include "immcli.h"
#include <ntsdexts.h>
#include <stdlib.h>
#include <windowsx.h>
#include <newres.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\regword.c ===
/**************************************************************************\
* Module Name: regword.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Word registration into IME dictionary
*
* History:
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* ImmRegisterWordA
*
* Registers a string into the dictionary of the IME with the specified hKL.
*
* History:
* 01-Mar-1996   wkwok   Created
\***************************************************************************/

BOOL WINAPI ImmRegisterWordA(
    HKL    hKL,
    LPCSTR lpszReading,
    DWORD  dwStyle,
    LPCSTR lpszString)
{
    PIMEDPI pImeDpi;
    LPWSTR  lpwszReading;
    LPWSTR  lpwszString;
    INT     cchReading;
    INT     cchString;
    INT     i;
    BOOL    fRet;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmRegisterWordA: no pImeDpi entry.");
        return FALSE;
    }

    if (!(pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)) {
        /*
         * Doesn't need A/W conversion. Calls directly to IME to
         * register the string.
         */
        fRet = (*pImeDpi->pfn.ImeRegisterWord.a)(lpszReading, dwStyle, lpszString);
        ImmUnlockImeDpi(pImeDpi);
        return fRet;
    }

    /*
     * ANSI caller, Unicode IME. Needs A/W conversion on
     * lpszReading and lpszString.
     */
    if (lpszReading != NULL) {
        cchReading = strlen(lpszReading) + sizeof(CHAR);
        lpwszReading = ImmLocalAlloc(0, cchReading * sizeof(WCHAR));
        if (lpwszReading == NULL) {
            RIPMSG0(RIP_WARNING, "ImmRegisterWordA: memory failure.");
            ImmUnlockImeDpi(pImeDpi);
            return FALSE;
        }

        i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszReading,              // src
                                (INT)strlen(lpszReading),
                                (LPWSTR)lpwszReading,            // dest
                                cchReading);
        lpwszReading[i] = L'\0';
    }
    else {
        lpwszReading = NULL;
    }

    if (lpszString != NULL) {
        cchString  = strlen(lpszString)  + sizeof(CHAR);
        lpwszString = ImmLocalAlloc(0, cchString * sizeof(WCHAR));
        if (lpwszString == NULL) {
            RIPMSG0(RIP_WARNING, "ImmRegisterWordA: memory failure.");
            if (lpwszReading != NULL)
                ImmLocalFree(lpwszReading);
            ImmUnlockImeDpi(pImeDpi);
            return FALSE;
        }

        i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszString,              // src
                                (INT)strlen(lpszString),
                                (LPWSTR)lpwszString,            // dest
                                cchString);
        lpwszString[i] = L'\0';
    }
    else {
        lpwszString = NULL;
    }

    fRet = ImmRegisterWordW(hKL, lpwszReading, dwStyle, lpwszString);

    if (lpwszReading != NULL)
        ImmLocalFree(lpwszReading);

    if (lpwszString != NULL)
        ImmLocalFree(lpwszString);

    ImmUnlockImeDpi(pImeDpi);
    return fRet;
}


BOOL WINAPI ImmRegisterWordW(
    HKL     hKL,
    LPCWSTR lpwszReading,
    DWORD   dwStyle,
    LPCWSTR lpwszString)
{
    PIMEDPI pImeDpi;
    LPSTR   lpszReading;
    LPSTR   lpszString;
    INT     cchReading;
    INT     cchString;
    INT     i;
    BOOL    fRet;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmRegisterWordW: no pImeDpi entry.");
        return FALSE;
    }

    if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) {
        /*
         * Doesn't need W/A conversion. Calls directly to IME to
         * register the string.
         */
        fRet = (*pImeDpi->pfn.ImeRegisterWord.w)(lpwszReading, dwStyle, lpwszString);
        ImmUnlockImeDpi(pImeDpi);
        return fRet;
    }

    /*
     * Unicode caller, ANSI IME. Needs W/A conversion on
     * lpwszReading and lpwszString.
     */
    if (lpwszReading != NULL) {
        cchReading = (wcslen(lpwszReading) + 1) * sizeof(WCHAR);
        lpszReading = ImmLocalAlloc(0, cchReading);
        if (lpszReading == NULL) {
            RIPMSG0(RIP_WARNING, "ImmRegisterWordW: memory failure.");
            ImmUnlockImeDpi(pImeDpi);
            return FALSE;
        }

        i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                (DWORD)0,
                                (LPWSTR)lpwszReading,          // src
                                (INT)wcslen(lpwszReading),
                                (LPSTR)lpszReading,            // dest
                                cchReading,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpszReading[i] = '\0';
    }
    else {
        lpszReading = NULL;
    }

    if (lpwszString != NULL) {
        cchString  = (wcslen(lpwszString) + 1) * sizeof(WCHAR);
        lpszString = ImmLocalAlloc(0, cchString);
        if (lpszString == NULL) {
            RIPMSG0(RIP_WARNING, "ImmRegisterWordW: memory failure.");
            if (lpszReading != NULL)
                ImmLocalFree(lpszReading);
            ImmUnlockImeDpi(pImeDpi);
            return FALSE;
        }

        i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                (DWORD)0,
                                (LPWSTR)lpwszString,          // src
                                (INT)wcslen(lpwszString),
                                (LPSTR)lpszString,            // dest
                                cchString,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpszString[i] = '\0';
    }
    else {
        lpszString = NULL;
    }

    fRet = ImmRegisterWordA(hKL, lpszReading, dwStyle, lpszString);

    if (lpszReading != NULL)
        ImmLocalFree(lpszReading);

    if (lpszString != NULL)
        ImmLocalFree(lpszString);

    ImmUnlockImeDpi(pImeDpi);
    return fRet;
}


BOOL WINAPI ImmUnregisterWordA(
    HKL    hKL,
    LPCSTR lpszReading,
    DWORD  dwStyle,
    LPCSTR lpszString)
{
    PIMEDPI pImeDpi;
    LPWSTR  lpwszReading;
    LPWSTR  lpwszString;
    INT     cchReading;
    INT     cchString;
    INT     i;
    BOOL    fRet;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmUnregisterWordA: no pImeDpi entry.");
        return FALSE;
    }

    if (!(pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)) {
        /*
         * Doesn't need A/W conversion. Calls directly to IME to
         * un-register the string.
         */
        fRet = (*pImeDpi->pfn.ImeUnregisterWord.a)(lpszReading, dwStyle, lpszString);
        ImmUnlockImeDpi(pImeDpi);
        return fRet;
    }

    /*
     * ANSI caller, Unicode IME. Needs A/W conversion on
     * lpszReading and lpszString.
     */
    if (lpszReading != NULL) {
        cchReading = strlen(lpszReading) + sizeof(CHAR);
        lpwszReading = ImmLocalAlloc(0, cchReading * sizeof(WCHAR));
        if (lpwszReading == NULL) {
            RIPMSG0(RIP_WARNING, "ImmUnregisterWordA: memory failure.");
            ImmUnlockImeDpi(pImeDpi);
            return FALSE;
        }

        i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszReading,              // src
                                (INT)strlen(lpszReading),
                                (LPWSTR)lpwszReading,            // dest
                                cchReading);
        lpwszReading[i] = L'\0';
    }
    else {
        lpwszReading = NULL;
    }

    if (lpszString != NULL) {
        cchString  = strlen(lpszString)  + sizeof(CHAR);
        lpwszString = ImmLocalAlloc(0, cchString * sizeof(WCHAR));
        if (lpwszString == NULL) {
            RIPMSG0(RIP_WARNING, "ImmUnregisterWordA: memory failure.");
            if (lpwszReading != NULL)
                ImmLocalFree(lpwszReading);
            ImmUnlockImeDpi(pImeDpi);
            return FALSE;
        }

        i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszString,              // src
                                (INT)strlen(lpszString),
                                (LPWSTR)lpwszString,            // dest
                                cchString);
        lpwszString[i] = L'\0';
    }
    else {
        lpwszString = NULL;
    }

    fRet = ImmUnregisterWordW(hKL, lpwszReading, dwStyle, lpwszString);

    if (lpwszReading != NULL)
        ImmLocalFree(lpwszReading);

    if (lpwszString != NULL)
        ImmLocalFree(lpwszString);

    ImmUnlockImeDpi(pImeDpi);
    return fRet;
}


BOOL WINAPI ImmUnregisterWordW(
    HKL     hKL,
    LPCWSTR lpwszReading,
    DWORD   dwStyle,
    LPCWSTR lpwszString)
{
    PIMEDPI pImeDpi;
    LPSTR   lpszReading;
    LPSTR   lpszString;
    INT     cchReading;
    INT     cchString;
    INT     i;
    BOOL    fRet;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmUnregisterWordW: no pImeDpi entry.");
        return FALSE;
    }

    if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) {
        /*
         * Doesn't need W/A conversion. Calls directly to IME to
         * register the string.
         */
        fRet = (*pImeDpi->pfn.ImeUnregisterWord.w)(lpwszReading, dwStyle, lpwszString);
        ImmUnlockImeDpi(pImeDpi);
        return fRet;
    }

    /*
     * Unicode caller, ANSI IME. Needs W/A conversion on
     * lpwszReading and lpwszString.
     */
    if (lpwszReading != NULL) {
        cchReading = (wcslen(lpwszReading) + 1) * sizeof(WCHAR);
        lpszReading = ImmLocalAlloc(0, cchReading);
        if (lpszReading == NULL) {
            RIPMSG0(RIP_WARNING, "ImmUnregisterWordW: memory failure.");
            ImmUnlockImeDpi(pImeDpi);
            return FALSE;
        }

        i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                (DWORD)0,
                                (LPWSTR)lpwszReading,          // src
                                (INT)wcslen(lpwszReading),
                                (LPSTR)lpszReading,            // dest
                                cchReading,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpszReading[i] = '\0';
    }
    else {
        lpszReading = NULL;
    }

    if (lpwszString != NULL) {
        cchString  = (wcslen(lpwszString) + 1) * sizeof(WCHAR);
        lpszString = ImmLocalAlloc(0, cchString);
        if (lpszString == NULL) {
            RIPMSG0(RIP_WARNING, "ImmUnregisterWordW: memory failure.");
            if (lpszReading != NULL)
                ImmLocalFree(lpszReading);
            ImmUnlockImeDpi(pImeDpi);
            return FALSE;
        }

        i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                (DWORD)0,
                                (LPWSTR)lpwszString,          // src
                                (INT)wcslen(lpwszString),
                                (LPSTR)lpszString,            // dest
                                cchString,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpszString[i] = '\0';
    }
    else {
        lpszString = NULL;
    }

    fRet = ImmUnregisterWordA(hKL, lpszReading, dwStyle, lpszString);

    if (lpszReading != NULL)
        ImmLocalFree(lpszReading);

    if (lpszString != NULL)
        ImmLocalFree(lpszString);

    ImmUnlockImeDpi(pImeDpi);
    return fRet;
}


UINT WINAPI ImmGetRegisterWordStyleA(
    HKL         hKL,
    UINT        nItem,
    LPSTYLEBUFA lpStyleBufA)
{
    PIMEDPI     pImeDpi;
    LPSTYLEBUFW lpStyleBufW;
    UINT        uRet;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmGetRegisterWordStyleA: no pImeDpi entry.");
        return 0;
    }

    if (!(pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)) {
        /*
         * Doesn't need A/W conversion. Calls directly to IME to
         * get the available style.
         */
        uRet = (*pImeDpi->pfn.ImeGetRegisterWordStyle.a)(nItem, lpStyleBufA);
        ImmUnlockImeDpi(pImeDpi);
        return uRet;
    }

    /*
     * ANSI caller, Unicode IME. Needs A/W conversion on
     * lpStyleBufA.
     */
    lpStyleBufW = NULL;

    if (nItem != 0) {
        lpStyleBufW = ImmLocalAlloc(0, nItem * sizeof(STYLEBUFW));
        if (lpStyleBufW == NULL) {
            RIPMSG0(RIP_WARNING, "ImmGetRegisterWordStyleA: memory failure.");
            ImmUnlockImeDpi(pImeDpi);
            return 0;
        }
    }

    uRet = ImmGetRegisterWordStyleW(hKL, nItem, lpStyleBufW);

    if (nItem != 0) {
        LPSTYLEBUFW lpsbw;
        INT i, j;

        for (i = 0, lpsbw = lpStyleBufW; i < (INT)uRet; i++, lpsbw++) {

            lpStyleBufA->dwStyle = lpsbw->dwStyle;

            j = WideCharToMultiByte(IMECodePage(pImeDpi),
                                    (DWORD)0,
                                    (LPWSTR)lpsbw->szDescription,          // src
                                    (INT)wcslen(lpsbw->szDescription),
                                    (LPSTR)lpStyleBufA->szDescription,     // dest
                                    (INT)sizeof(lpStyleBufA->szDescription),
                                    (LPSTR)NULL,
                                    (LPBOOL)NULL);
            lpStyleBufA->szDescription[j] = '\0';
            lpStyleBufA++;
        }
    }

    if (lpStyleBufW != NULL)
        ImmLocalFree(lpStyleBufW);

    ImmUnlockImeDpi(pImeDpi);

    return uRet;
}


UINT WINAPI ImmGetRegisterWordStyleW(
    HKL         hKL,
    UINT        nItem,
    LPSTYLEBUFW lpStyleBufW)
{
    PIMEDPI     pImeDpi;
    LPSTYLEBUFA lpStyleBufA;
    UINT        uRet;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmGetRegisterWordStyleA: no pImeDpi entry.");
        return 0;
    }

    if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) {
        /*
         * Doesn't need W/A conversion. Calls directly to IME to
         * get the available style.
         */
        uRet = (*pImeDpi->pfn.ImeGetRegisterWordStyle.w)(nItem, lpStyleBufW);
        ImmUnlockImeDpi(pImeDpi);
        return uRet;
    }

    /*
     * Unicode caller, ANSI IME. Needs W/A conversion on
     * lpStyleBufW.
     */
    lpStyleBufA = NULL;

    if (nItem != 0) {
        lpStyleBufA = ImmLocalAlloc(0, nItem * sizeof(STYLEBUFA));
        if (lpStyleBufA == NULL) {
            RIPMSG0(RIP_WARNING, "ImmGetRegisterWordStyleW: memory failure.");
            ImmUnlockImeDpi(pImeDpi);
            return 0;
        }
    }

    uRet = ImmGetRegisterWordStyleA(hKL, nItem, lpStyleBufA);

    if (nItem != 0) {
        LPSTYLEBUFA lpsba;
        INT i, j;

        for (i = 0, lpsba = lpStyleBufA; i < (INT)uRet; i++, lpsba++) {

            lpStyleBufW->dwStyle = lpsba->dwStyle;

            j = MultiByteToWideChar(IMECodePage(pImeDpi),
                        (DWORD)MB_PRECOMPOSED,
                        (LPSTR)lpsba->szDescription,             // src
                        (INT)strlen(lpsba->szDescription),
                        (LPWSTR)lpStyleBufW->szDescription,      // dest
                        (INT)(sizeof(lpStyleBufW->szDescription)/sizeof(WCHAR)));
            lpStyleBufW->szDescription[j] = L'\0';
            lpStyleBufW++;
        }
    }

    if (lpStyleBufA != NULL)
        ImmLocalFree(lpStyleBufA);

    ImmUnlockImeDpi(pImeDpi);

    return uRet;
}


UINT WINAPI ImmEnumRegisterWordA(
    HKL                   hKL,
    REGISTERWORDENUMPROCA lpfnRegisterWordEnumProcA,
    LPCSTR                lpszReading,
    DWORD                 dwStyle,
    LPCSTR                lpszString,
    LPVOID                lpData)
{
    PIMEDPI         pImeDpi;
    LPWSTR          lpwszReading;
    LPWSTR          lpwszString;
    INT             cchReading;
    INT             cchString;
    INT             i;
    ENUMREGWORDDATA erwData;
    UINT            uRet;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmEnumRegisterWordA: no pImeDpi entry.");
        return 0;
    }

    if (!(pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE)) {
        /*
         * Doesn't need A/W conversion. Calls directly to IME to
         * enumerate registered strings.
         */
        uRet = (*pImeDpi->pfn.ImeEnumRegisterWord.a)(lpfnRegisterWordEnumProcA,
                                                     lpszReading,
                                                     dwStyle,
                                                     lpszString,
                                                     lpData);
        ImmUnlockImeDpi(pImeDpi);
        return uRet;
    }

    /*
     * ANSI caller, Unicode IME. Needs A/W conversion on
     * lpszReading and lpszString.
     */
    if (lpszReading != NULL) {
        cchReading = strlen(lpszReading) + sizeof(CHAR);
        lpwszReading = ImmLocalAlloc(0, cchReading * sizeof(WCHAR));
        if (lpwszReading == NULL) {
            RIPMSG0(RIP_WARNING, "ImmEnumRegisterWordA: memory failure.");
            ImmUnlockImeDpi(pImeDpi);
            return 0;
        }

        i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszReading,              // src
                                (INT)strlen(lpszReading),
                                (LPWSTR)lpwszReading,            // dest
                                cchReading);
        lpwszReading[i] = L'\0';
    }
    else {
        lpwszReading = NULL;
    }

    if (lpszString != NULL) {
        cchString  = strlen(lpszString)  + sizeof(CHAR);
        lpwszString = ImmLocalAlloc(0, cchString * sizeof(WCHAR));
        if (lpwszString == NULL) {
            RIPMSG0(RIP_WARNING, "ImmEnumRegisterWordA: memory failure.");
            if (lpwszReading != NULL)
                ImmLocalFree(lpwszReading);
            ImmUnlockImeDpi(pImeDpi);
            return 0;
        }

        i = MultiByteToWideChar(IMECodePage(pImeDpi),
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszString,              // src
                                (INT)strlen(lpszString),
                                (LPWSTR)lpwszString,            // dest
                                cchString);
        lpwszString[i] = L'\0';
    }
    else {
        lpwszString = NULL;
    }

    erwData.lpfn.a = lpfnRegisterWordEnumProcA;
    erwData.lpData = lpData;
    erwData.dwCodePage = IMECodePage(pImeDpi);

    uRet = ImmEnumRegisterWordW(hKL, EnumRegisterWordProcW,
                    lpwszReading, dwStyle, lpwszString, (LPVOID)&erwData);

    if (lpwszReading != NULL)
        ImmLocalFree(lpwszReading);

    if (lpwszString != NULL)
        ImmLocalFree(lpwszString);

    ImmUnlockImeDpi(pImeDpi);
    return uRet;
}


UINT WINAPI ImmEnumRegisterWordW(
    HKL                   hKL,
    REGISTERWORDENUMPROCW lpfnRegisterWordEnumProcW,
    LPCWSTR               lpwszReading,
    DWORD                 dwStyle,
    LPCWSTR               lpwszString,
    LPVOID                lpData)
{
    PIMEDPI         pImeDpi;
    LPSTR           lpszReading;
    LPSTR           lpszString;
    INT             cchReading;
    INT             cchString;
    INT             i;
    ENUMREGWORDDATA erwData;
    UINT            uRet;

    pImeDpi = FindOrLoadImeDpi(hKL);
    if (pImeDpi == NULL) {
        RIPMSG0(RIP_WARNING, "ImmEnumRegisterWordW: no pImeDpi entry.");
        return FALSE;
    }

    if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) {
        /*
         * Doesn't need W/A conversion. Calls directly to IME to
         * enumerate registered strings.
         */
        uRet = (*pImeDpi->pfn.ImeEnumRegisterWord.w)(lpfnRegisterWordEnumProcW,
                                                     lpwszReading,
                                                     dwStyle,
                                                     lpwszString,
                                                     lpData);
        ImmUnlockImeDpi(pImeDpi);
        return uRet;
    }

    /*
     * Unicode caller, ANSI IME. Needs W/A conversion on
     * lpwszReading and lpwszString.
     */
    if (lpwszReading != NULL) {
        cchReading = (wcslen(lpwszReading) + 1) * sizeof(WCHAR);
        lpszReading = ImmLocalAlloc(0, cchReading);
        if (lpszReading == NULL) {
            RIPMSG0(RIP_WARNING, "ImmEnumRegisterWordW: memory failure.");
            ImmUnlockImeDpi(pImeDpi);
            return 0;
        }

        i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                (DWORD)0,
                                (LPWSTR)lpwszReading,          // src
                                (INT)wcslen(lpwszReading),
                                (LPSTR)lpszReading,            // dest
                                cchReading,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpszReading[i] = '\0';
    }
    else {
        lpszReading = NULL;
    }

    if (lpwszString != NULL) {
        cchString  = (wcslen(lpwszString) + 1) * sizeof(WCHAR);
        lpszString = ImmLocalAlloc(0, cchString);
        if (lpszString == NULL) {
            RIPMSG0(RIP_WARNING, "ImmEnumRegisterWordW: memory failure.");
            if (lpszReading != NULL)
                ImmLocalFree(lpszReading);
            ImmUnlockImeDpi(pImeDpi);
            return 0;
        }

        i = WideCharToMultiByte(IMECodePage(pImeDpi),
                                (DWORD)0,
                                (LPWSTR)lpwszString,          // src
                                (INT)wcslen(lpwszString),
                                (LPSTR)lpszString,            // dest
                                cchString,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpszString[i] = '\0';
    }
    else {
        lpszString = NULL;
    }

    erwData.lpfn.w = lpfnRegisterWordEnumProcW;
    erwData.lpData = lpData;
    erwData.dwCodePage = IMECodePage(pImeDpi);

    uRet = ImmEnumRegisterWordA(hKL, EnumRegisterWordProcA,
                    lpszReading, dwStyle, lpszString, (LPVOID)&erwData);

    if (lpszReading != NULL)
        ImmLocalFree(lpszReading);

    if (lpszString != NULL)
        ImmLocalFree(lpszString);

    ImmUnlockImeDpi(pImeDpi);
    return uRet;
}


UINT CALLBACK EnumRegisterWordProcA(
    LPCSTR            lpszReading,
    DWORD             dwStyle,
    LPCSTR            lpszString,
    PENUMREGWORDDATA  pEnumRegWordData)
{
    LPWSTR lpwszReading;
    LPWSTR lpwszString;
    INT    cchReading;
    INT    cchString;
    INT    i;
    UINT   uRet;

    ImmAssert(pEnumRegWordData != NULL);

    if (lpszReading != NULL) {
        cchReading = strlen(lpszReading) + sizeof(CHAR);
        lpwszReading = ImmLocalAlloc(0, cchReading * sizeof(WCHAR));
        if (lpwszReading == NULL) {
            RIPMSG0(RIP_WARNING, "EnumRegisterWordProcA: memory failure.");
            return 0;
        }

        i = MultiByteToWideChar(pEnumRegWordData->dwCodePage,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszReading,              // src
                                (INT)strlen(lpszReading),
                                (LPWSTR)lpwszReading,            // dest
                                cchReading);
        lpwszReading[i] = L'\0';
    }
    else {
        lpwszReading = NULL;
    }

    if (lpszString != NULL) {
        cchString  = strlen(lpszString) + sizeof(CHAR);
        lpwszString = ImmLocalAlloc(0, cchString * sizeof(WCHAR));
        if (lpwszString == NULL) {
            RIPMSG0(RIP_WARNING, "EnumRegisterWordProcA: memory failure.");
            if (lpwszReading != NULL)
                ImmLocalFree(lpwszReading);
            return 0;
        }

        i = MultiByteToWideChar(pEnumRegWordData->dwCodePage,
                                (DWORD)MB_PRECOMPOSED,
                                (LPSTR)lpszString,              // src
                                (INT)strlen(lpszString),
                                (LPWSTR)lpwszString,            // dest
                                cchString);
        lpwszString[i] = L'\0';
    }
    else {
        lpwszString = NULL;
    }

    uRet = (*pEnumRegWordData->lpfn.w)(lpwszReading, dwStyle,
                            lpwszString, pEnumRegWordData->lpData);

    if (lpwszReading != NULL)
        ImmLocalFree(lpwszReading);

    if (lpwszString != NULL)
        ImmLocalFree(lpwszString);

    return uRet;
}


UINT CALLBACK EnumRegisterWordProcW(
    LPCWSTR          lpwszReading,
    DWORD            dwStyle,
    LPCWSTR          lpwszString,
    PENUMREGWORDDATA pEnumRegWordData)
{
    LPSTR lpszReading;
    LPSTR lpszString;
    INT   cchReading;
    INT   cchString;
    INT   i;
    UINT  uRet;

    ImmAssert(pEnumRegWordData != NULL);

    if (lpwszReading != NULL) {
        cchReading = (wcslen(lpwszReading) + 1) * sizeof(WCHAR);
        lpszReading = ImmLocalAlloc(0, cchReading);
        if (lpszReading == NULL) {
            RIPMSG0(RIP_WARNING, "ImmRegisterWordW: memory failure.");
            return 0;
        }

        i = WideCharToMultiByte(pEnumRegWordData->dwCodePage,
                                (DWORD)0,
                                (LPWSTR)lpwszReading,          // src
                                (INT)wcslen(lpwszReading),
                                (LPSTR)lpszReading,            // dest
                                cchReading,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpszReading[i] = '\0';
    }
    else {
        lpszReading = NULL;
    }

    if (lpwszString != NULL) {
        cchString  = (wcslen(lpwszString) + 1) * sizeof(WCHAR);
        lpszString = ImmLocalAlloc(0, cchString);
        if (lpszString == NULL) {
            RIPMSG0(RIP_WARNING, "ImmRegisterWordW: memory failure.");
            if (lpszReading != NULL)
                ImmLocalFree(lpszReading);
            return 0;
        }

        i = WideCharToMultiByte(pEnumRegWordData->dwCodePage,
                                (DWORD)0,
                                (LPWSTR)lpwszString,          // src
                                (INT)wcslen(lpwszString),
                                (LPSTR)lpszString,            // dest
                                cchString,
                                (LPSTR)NULL,
                                (LPBOOL)NULL);
        lpszString[i] = '\0';
    }
    else {
        lpszString = NULL;
    }

    uRet = (*pEnumRegWordData->lpfn.a)(lpszReading, dwStyle,
                            lpszString, pEnumRegWordData->lpData);

    if (lpszReading != NULL)
        ImmLocalFree(lpszReading);

    if (lpszString != NULL)
        ImmLocalFree(lpszString);

    return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\wow6432\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\misc.c ===
/**************************************************************************\
* Module Name: misc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*
* History:
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef HIRO_DEBUG
#define D(x)    x
#else
#define D(x)
#endif


/**************************************************************************\
* ImmGetDefaultIMEWnd
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

HWND WINAPI ImmGetDefaultIMEWnd(
    HWND hWnd)
{
    if (!IS_IME_ENABLED()) {
        return NULL;
    }
    if (hWnd == NULL) {
        /*
         * Query default IME window of current thread.
         */
        return (HWND)NtUserGetThreadState(UserThreadStateDefaultImeWindow);
    }

    return (HWND)NtUserQueryWindow(hWnd, WindowDefaultImeWindow);
}


/**************************************************************************\
* ImmDisableIME
*
* 13-Sep-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmDisableIME(DWORD dwThreadId)
{
#ifdef LATER    // hiro
    if (dwThreadId == -1) {
        // Unload all IMEs
        RtlEnterCriticalSection(&gcsImeDpi);
        while (gpImeDpi) {
            PIMEDPI pImeDpi = gpImeDpi;
            gpImeDpi = gpImeDpi->pNext;
            UnloadIME(pImeDpi, TRUE);
            ImmLocalFree(pImeDpi);
        }
        RtlLeaveCriticalSection(&gcsImeDpi);
    }
#endif
    return (BOOL)NtUserDisableThreadIme(dwThreadId);
}

/**************************************************************************\
* ImmIsUIMessageA
*
* Filter messages needed for IME window.
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmIsUIMessageA(
    HWND   hIMEWnd,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    return ImmIsUIMessageWorker(hIMEWnd, message, wParam, lParam, TRUE);
}


/**************************************************************************\
* ImmIsUIMessageW
*
* Filter messages needed for IME window.
*
* 29-Feb-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmIsUIMessageW(
    HWND   hIMEWnd,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    return ImmIsUIMessageWorker(hIMEWnd, message, wParam, lParam, FALSE);
}


/**************************************************************************\
* ImmIsUIMessageWorker
*
* Worker function of ImmIsUIMessageA/ImmIsUIMessageW.
*
* Return: True if message is processed by IME UI.
*         False otherwise.
*
* 29-Feb-1996 wkwok       Created
\**************************************************************************/

BOOL ImmIsUIMessageWorker(
    HWND   hIMEWnd,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam,
    BOOL   fAnsi)
{
    D(DbgPrint("ImmIsUIMessageWorker(wnd[%08X], msg[%04X], wp[%08X], lp[%08X], Ansi[%d]\n",
      hIMEWnd, message, wParam, lParam, fAnsi));

    switch (message) {
    case WM_IME_STARTCOMPOSITION:
    case WM_IME_ENDCOMPOSITION:
    case WM_IME_COMPOSITION:
    case WM_IME_SETCONTEXT:
    case WM_IME_COMPOSITIONFULL:
    case WM_IME_SELECT:
    case WM_IME_NOTIFY:
    case WM_IME_SYSTEM:

        if (!hIMEWnd)
            return TRUE;

#if DBG
        if (!IsWindow(hIMEWnd)) {
            RIPMSG1(RIP_WARNING,
                  "ImmIsUIMessage: Invalid window handle %x", hIMEWnd);
            return FALSE;
        }
#endif

        if (fAnsi) {
            SendMessageA(hIMEWnd, message, wParam, lParam);
        }
        else {
            SendMessageW(hIMEWnd, message, wParam, lParam);
        }

        return TRUE;

    default:
        break;
    }

    return FALSE;
}


/**************************************************************************\
* ImmGenerateMessage
*
* Sends message(s) that are stored in hMsgBuf of hImc to hWnd of hImc.
*
* 29-Feb-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmGenerateMessage(
    HIMC hImc)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    PTRANSMSG     pTransMsg;
    INT           iNum;
    INT           i;
    BOOL          fUnicodeImc;

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmGenerateMessage: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL)
        return FALSE;

    fUnicodeImc = TestICF(pClientImc, IMCF_UNICODE);

    ImmUnlockClientImc(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmGenerateMessage: Lock hImc %lx failed.", hImc);
        return FALSE;
    }

    iNum = (int)pInputContext->dwNumMsgBuf;

    if (iNum && (pTransMsg = (PTRANSMSG)ImmLockIMCC(pInputContext->hMsgBuf))) {
        PTRANSMSG pTransMsgBuf, pTransMsgTemp;

        pTransMsgBuf = (PTRANSMSG)ImmLocalAlloc(0, iNum * sizeof(TRANSMSG));

        if (pTransMsgBuf != NULL) {

            RtlCopyMemory(pTransMsgBuf, pTransMsg, iNum * sizeof(TRANSMSG));

            if (GetClientInfo()->dwExpWinVer < VER40) {
                /*
                 * translate messages for those applications that expect
                 * old style IME messages.
                 */
                DWORD dwLangId;
                dwLangId = PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID()));
                if ( (dwLangId == LANG_KOREAN && TransGetLevel(pInputContext->hWnd) == 3) ||
                     (dwLangId == LANG_JAPANESE) ) {
                    iNum = WINNLSTranslateMessage(iNum,
                                                  pTransMsgBuf,
                                                  hImc,
                                                  !fUnicodeImc,
                                                  dwLangId );
                }
            }

            pTransMsgTemp = pTransMsgBuf;

            for (i = 0; i < iNum; i++) {
                if (fUnicodeImc) {
                    SendMessageW( pInputContext->hWnd,
                                  pTransMsgTemp->message,
                                  pTransMsgTemp->wParam,
                                  pTransMsgTemp->lParam );
                } else {
                    SendMessageW( pInputContext->hWnd,
                                  pTransMsgTemp->message,
                                  pTransMsgTemp->wParam,
                                  pTransMsgTemp->lParam );
                }
                pTransMsgTemp++;
            }

            ImmLocalFree(pTransMsgBuf);
        }

        ImmUnlockIMCC(pInputContext->hMsgBuf);
    }

    /*
     * We should not reallocate the message buffer
     */
    pInputContext->dwNumMsgBuf = 0L;

    ImmUnlockIMC(hImc);

    return TRUE;
}


#ifdef CUAS_ENABLE
BOOL WINAPI CtfImmGenerateMessage(
    HIMC hImc,
    BOOL fSendMsg)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    PTRANSMSG     pTransMsg;
    INT           iNum;
    INT           i;
    BOOL          fUnicodeImc;

    if (GetInputContextThread(hImc) != GetCurrentThreadId()) {
        RIPMSG1(RIP_WARNING,
              "ImmGenerateMessage: Invalid input context access %lx.", hImc);
        return FALSE;
    }

    pClientImc = ImmLockClientImc(hImc);
    if (pClientImc == NULL)
        return FALSE;

    fUnicodeImc = TestICF(pClientImc, IMCF_UNICODE);

    ImmUnlockClientImc(pClientImc);

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmGenerateMessage: Lock hImc %lx failed.", hImc);
        return FALSE;
    }

    iNum = (int)pInputContext->dwNumMsgBuf;

    if (iNum && (pTransMsg = (PTRANSMSG)ImmLockIMCC(pInputContext->hMsgBuf))) {
        PTRANSMSG pTransMsgBuf, pTransMsgTemp;

        pTransMsgBuf = (PTRANSMSG)ImmLocalAlloc(0, iNum * sizeof(TRANSMSG));

        if (pTransMsgBuf != NULL) {

            RtlCopyMemory(pTransMsgBuf, pTransMsg, iNum * sizeof(TRANSMSG));

            pTransMsgTemp = pTransMsgBuf;

            for (i = 0; i < iNum; i++) {
                if (fSendMsg)
                {
                    if (fUnicodeImc) {
                        SendMessageW( pInputContext->hWnd,
                                      pTransMsgTemp->message,
                                      pTransMsgTemp->wParam,
                                      pTransMsgTemp->lParam );
                    } else {
                        SendMessageA( pInputContext->hWnd,
                                      pTransMsgTemp->message,
                                      pTransMsgTemp->wParam,
                                      pTransMsgTemp->lParam );
                    }
                }
                else
                {
                    if (fUnicodeImc) {
                        PostMessageW( pInputContext->hWnd,
                                      pTransMsgTemp->message,
                                      pTransMsgTemp->wParam,
                                      pTransMsgTemp->lParam );
                    } else {
                        PostMessageA( pInputContext->hWnd,
                                      pTransMsgTemp->message,
                                      pTransMsgTemp->wParam,
                                      pTransMsgTemp->lParam );
                    }
                }
                pTransMsgTemp++;
            }

            ImmLocalFree(pTransMsgBuf);
        }

        ImmUnlockIMCC(pInputContext->hMsgBuf);
    }

    /*
     * We should not reallocate the message buffer
     */
    pInputContext->dwNumMsgBuf = 0L;

    ImmUnlockIMC(hImc);

    return TRUE;
}
#endif // CUAS_ENABLE


/**************************************************************************\
* ImmGetVirtualKey
*
* Gets the actual virtual key which is preprocessed by an IME.
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

UINT WINAPI ImmGetVirtualKey(
    HWND hWnd)
{
    HIMC          hImc;
    PINPUTCONTEXT pInputContext;
    UINT          uVirtKey;

    hImc = ImmGetContext(hWnd);

    pInputContext = ImmLockIMC(hImc);
    if (!pInputContext) {
        RIPMSG1(RIP_WARNING, "ImmGetVirtualKey: lock IMC %x failure", hImc);
        return (VK_PROCESSKEY);
    }

    if (pInputContext->fChgMsg) {
        uVirtKey = pInputContext->uSavedVKey;
    } else {
        uVirtKey = VK_PROCESSKEY;
    }

    ImmUnlockIMC(hImc);
    return (uVirtKey);
}


/**************************************************************************\
* ImmLockIMC
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

PINPUTCONTEXT WINAPI InternalImmLockIMC(
    HIMC hImc,
    BOOL fCanCallImeSelect)
{
    PCLIENTIMC    pClientImc;
    PINPUTCONTEXT pInputContext;
    DWORD         dwImcThreadId;

    if ((pClientImc = ImmLockClientImc(hImc)) == NULL)
        return NULL;

    EnterImcCrit(pClientImc);

    if (pClientImc->hInputContext == NULL) {

#ifdef CUAS_ENABLE
        dwImcThreadId = (DWORD)NtUserQueryInputContext(hImc, InputContextThread);
#endif // CUAS_ENABLE

#ifdef CUAS_ENABLE

        if (dwImcThreadId == GetCurrentThreadId() &&
           IS_CICERO_ENABLED_AND_NOT16BIT()) {
            /*
             * Cicero IME. Activate Thread Input Manager.
             */
            PIMEDPI pImeDpi;
            LANGID  lg = LOWORD(HandleToUlong(GetKeyboardLayout(0)));
            DWORD   dwKL = MAKELONG(lg, lg);

            pImeDpi = FindOrLoadImeDpi(UlongToHandle(dwKL));
            if (pImeDpi == NULL) {
                RIPMSG0(RIP_WARNING, "InternalImmLockIMC: no pImeDpi entry.");
            }
            else
            {
                /*
                 * Activate TIM
                 *   For this call, CTFIME's tim->Activate retreive TfClientId value
                 *   when user32!LoadThreadLayout calls ImmTIMActivate with non-IME hKL.
                 *   Because tim->Activate calls keyboard layout change and it occurred
                 *   InternalImmLockIMC via IMS_ACTIVATETHREADLAYOUT.
                 *   Also this hIMC is used at first time.
                 *   In this case, this code block calls ImmTIMCreateInputContext and
                 *   create IC by dim->CreateContext(TfClientId).
                 *   If this code is disabled, TfClientId is not yet ready and
                 *   doesn't create IC.
                 */
                CtfImmTIMActivate(UlongToHandle(dwKL));
            }
        }
#endif // CUAS_ENABLE

        /*
         * If the owner thread of this hImc does not have
         * default IME window, don't bother to create the
         * INPUTCONTEXT. It could happen when some other
         * thread which call ImmGetContext() to retrieve
         * the associate hImc before the default IME window
         * is created.
         */
        if ((HWND)NtUserQueryInputContext(hImc,
                InputContextDefaultImeWindow) == NULL) {
            LeaveImcCrit(pClientImc);
            ImmUnlockClientImc(pClientImc);
            return NULL;
        }

        /*
         * This is a delay creation of INPUTCONTEXT structure. Create
         * it now for this hImc.
         */
        pClientImc->hInputContext = LocalAlloc(LHND, sizeof(INPUTCONTEXT));

        if (pClientImc->hInputContext == NULL) {
            LeaveImcCrit(pClientImc);
            ImmUnlockClientImc(pClientImc);
            return NULL;
        }

#ifndef CUAS_ENABLE
        dwImcThreadId = (DWORD)NtUserQueryInputContext(hImc, InputContextThread);
#endif // CUAS_ENABLE

        if (!CreateInputContext(hImc, GetKeyboardLayout(dwImcThreadId), fCanCallImeSelect)) {
            RIPMSG0(RIP_WARNING, "ImmLockIMC: CreateInputContext failed");
            LocalFree(pClientImc->hInputContext);
            pClientImc->hInputContext = NULL;
            LeaveImcCrit(pClientImc);
            ImmUnlockClientImc(pClientImc);
            return NULL;
        }
    }

#ifdef CUAS_ENABLE
    /*
     * Create Cicero Input Context.
     */
    CtfImmTIMCreateInputContext(hImc);
#endif // CUAS_ENABLE


    LeaveImcCrit(pClientImc);

    pInputContext = (PINPUTCONTEXT)LocalLock(pClientImc->hInputContext);

    /*
     * Increment lock count so that the ImmUnlockClientImc() won't
     * free up the pClientImc->hInputContext.
     */
    InterlockedIncrement(&pClientImc->cLockObj);


    ImmUnlockClientImc(pClientImc);

    return pInputContext;
}

PINPUTCONTEXT WINAPI ImmLockIMC(
    HIMC hImc)
{
    return InternalImmLockIMC(hImc, TRUE);
}

/**************************************************************************\
* ImmUnlockIMC
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmUnlockIMC(
    HIMC hImc)
{
    PCLIENTIMC pClientImc;

    if ((pClientImc = ImmLockClientImc(hImc)) == NULL)
        return FALSE;

    if (pClientImc->hInputContext != NULL)
        LocalUnlock(pClientImc->hInputContext);

    /*
     * Decrement lock count so that the ImmUnlockClientImc() can
     * free up the pClientImc->hInputContext if required.
     */
    InterlockedDecrement(&pClientImc->cLockObj);

    ImmUnlockClientImc(pClientImc);

    return TRUE;
}


/**************************************************************************\
* ImmGetIMCLockCount
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

DWORD WINAPI ImmGetIMCLockCount(
    HIMC hImc)
{
    PCLIENTIMC pClientImc;
    DWORD      dwRet = 0;

    if ((pClientImc = ImmLockClientImc(hImc)) == NULL)
        return dwRet;

    if (pClientImc->hInputContext != NULL)
        dwRet = (DWORD)(LocalFlags(pClientImc->hInputContext) & LMEM_LOCKCOUNT);

    ImmUnlockClientImc(pClientImc);

    return dwRet;
}


/**************************************************************************\
* ImmCreateIMCC
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

HIMCC WINAPI ImmCreateIMCC(
    DWORD dwSize)
{
    // At least size should be DWORD.
    if (dwSize < sizeof(DWORD)) {
        dwSize = sizeof(DWORD);
    }

    return (HIMCC)LocalAlloc(LHND, dwSize);
}


/**************************************************************************\
* ImmDestroyIMCC
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

HIMCC WINAPI ImmDestroyIMCC(
    HIMCC hIMCC)
{
    if (hIMCC == NULL) {
        return NULL;
    }

    return (HIMCC)LocalFree(hIMCC);
}


/**************************************************************************\
* ImmLockIMCC
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

LPVOID WINAPI ImmLockIMCC(
    HIMCC hIMCC)
{
    if (hIMCC == NULL) {
        return NULL;
    }

    return LocalLock(hIMCC);
}


/**************************************************************************\
* ImmUnlockIMCC
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmUnlockIMCC(
    HIMCC hIMCC)
{
    if (hIMCC == NULL) {
        return FALSE;
    }

    return LocalUnlock(hIMCC);
}


/**************************************************************************\
* ImmGetIMCCLockCount
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

DWORD WINAPI ImmGetIMCCLockCount(
    HIMCC hIMCC)
{
    if (hIMCC == NULL) {
        return 0;
    }

    return (DWORD)(LocalFlags(hIMCC) & LMEM_LOCKCOUNT);
}


/**************************************************************************\
* ImmReSizeIMCC
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

HIMCC WINAPI ImmReSizeIMCC(
    HIMCC hIMCC,
    DWORD dwSize)
{
    if (hIMCC == NULL) {
        return NULL;
    }

    return (HIMCC)LocalReAlloc(hIMCC, dwSize, LHND);
}


/**************************************************************************\
* ImmGetIMCCSize
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

DWORD WINAPI ImmGetIMCCSize(
    HIMCC hIMCC)
{
    if (hIMCC == NULL) {
        return 0;
    }

    return (DWORD)LocalSize(hIMCC);
}


/**************************************************************************\
* ImmLocalAlloc
*
* 18-Jun-1996 wkwok       Created
\**************************************************************************/

LPVOID ImmLocalAlloc(
    DWORD uFlag,
    DWORD uBytes)
{
    if (pImmHeap == NULL) {
        pImmHeap = RtlProcessHeap();
        if (pImmHeap == NULL) {
            RIPMSG0(RIP_WARNING, "ImmLocalAlloc: NULL pImmHeap!");
            return NULL;
        }
    }

    return HeapAlloc(pImmHeap, uFlag, uBytes);
}


/***************************************************************************\
* PtiCurrent
*
* Returns the THREADINFO structure for the current thread.
* LATER: Get DLL_THREAD_ATTACH initialization working right and we won't
*        need this connect code.
*
* History:
* 10-28-90 DavidPe      Created.
* 02-21-96 wkwok        Copied from USER32.DLL
\***************************************************************************/

PTHREADINFO PtiCurrent(VOID)
{
    ConnectIfNecessary(0);
    return (PTHREADINFO)NtCurrentTebShared()->Win32ThreadInfo;
}


/**************************************************************************\
* TestInputContextProcess
*
* 02-21-96 wkwok        Created
\**************************************************************************/

BOOL TestInputContextProcess(
    PIMC pImc)
{
    /*
     * If the threads are the same, don't bother going to the kernel
     * to get the input context's process id.
     */
    if (GETPTI(pImc) == PtiCurrent()) {
        return TRUE;
    }

    return (GetInputContextProcess(PtoH(pImc)) == GETPROCESSID());
}

/**************************************************************************\
* TestWindowProcess
*
* 11-14-94 JimA         Created.
* 02-29-96 wkwok        Copied from USER32.DLL
\**************************************************************************/

BOOL TestWindowProcess(
    PWND pwnd)
{
    /*
     * If the threads are the same, don't bother going to the kernel
     * to get the window's process id.
     */
    if (GETPTI(pwnd) == PtiCurrent()) {
        return TRUE;
    }

    return (GetWindowProcess(HW(pwnd)) == GETPROCESSID());
}


/**************************************************************************\
* GetKeyboardLayoutCP
*
* 12-Mar-1996 wkwok       Created
\**************************************************************************/

static LCID CachedLCID = 0;
static UINT CachedCP = CP_ACP;

UINT GetKeyboardLayoutCP(
    HKL hKL)
{
    #define LOCALE_CPDATA 7
    WCHAR wszCodePage[LOCALE_CPDATA];
    LCID  lcid;

    lcid = MAKELCID(LOWORD(HandleToUlong(hKL)), SORT_DEFAULT);

    if (lcid == CachedLCID)
        return CachedCP;

    if (!GetLocaleInfoW(lcid, LOCALE_IDEFAULTANSICODEPAGE,
                wszCodePage, LOCALE_CPDATA))
        return CP_ACP;

    CachedLCID = lcid;
    CachedCP = (UINT)wcstol(wszCodePage, NULL, 10);

    return CachedCP;
}


/**************************************************************************\
* GetKeyboardLayoutCP
*
* 12-Mar-1996 wkwok       Created
\**************************************************************************/

UINT GetThreadKeyboardLayoutCP(
    DWORD dwThreadId)
{
    HKL hKL;

    hKL = GetKeyboardLayout(dwThreadId);

    return GetKeyboardLayoutCP(hKL);
}


/**************************************************************************\
* ImmLockClientImc
*
* 13-Mar-1996 wkwok       Created
\**************************************************************************/

PCLIENTIMC WINAPI ImmLockClientImc(
    HIMC hImc)
{
    PIMC       pImc;
    PCLIENTIMC pClientImc;

    if (hImc == NULL_HIMC)
        return NULL;

    pImc = HMValidateHandle((HANDLE)hImc, TYPE_INPUTCONTEXT);

    /*
     * Cannot access input context from other process.
     */
    if (pImc == NULL || !TestInputContextProcess(pImc))
        return NULL;

    pClientImc = (PCLIENTIMC)pImc->dwClientImcData;

    if (pClientImc == NULL) {
        /*
         * We delay the creation of client side per-thread default Imc.
         * Now, this is the time to create it.
         */
        pClientImc = ImmLocalAlloc(HEAP_ZERO_MEMORY, sizeof(CLIENTIMC));
        if (pClientImc == NULL)
            return NULL;

        InitImcCrit(pClientImc);
        pClientImc->dwImeCompatFlags = (DWORD)NtUserGetThreadState(UserThreadStateImeCompatFlags);

        /*
         * Update the kernel side input context.
         */
        if (!NtUserUpdateInputContext(hImc,
                UpdateClientInputContext, (ULONG_PTR)pClientImc)) {
            ImmLocalFree(pClientImc);
            return NULL;
        }

        /*
         * Marks with default input context signature.
         */
        SetICF(pClientImc, IMCF_DEFAULTIMC);
    }
    else if (TestICF(pClientImc, IMCF_INDESTROY)) {
        /*
         * Cannot access destroyed input context.
         */
        return NULL;
    }

    InterlockedIncrement(&pClientImc->cLockObj);

    return pClientImc;
}


VOID WINAPI ImmUnlockClientImc(
    PCLIENTIMC pClientImc)
{
    if (InterlockedDecrement(&pClientImc->cLockObj) == 0) {
        if (TestICF(pClientImc, IMCF_INDESTROY)) {
            if (pClientImc->hInputContext != NULL)
                LocalFree(pClientImc->hInputContext);

            DeleteImcCrit(pClientImc);
            ImmLocalFree(pClientImc);
        }
    }

    return;
}

/**************************************************************************\
* ImmGetImeDpi
*
* 08-Jan-1996 wkwok       Created
\**************************************************************************/

PIMEDPI WINAPI ImmGetImeDpi(
    HKL hKL)
{
    PIMEDPI pImeDpi;

    RtlEnterCriticalSection(&gcsImeDpi);

    pImeDpi = gpImeDpi;

    while (pImeDpi != NULL && pImeDpi->hKL != hKL)
        pImeDpi = pImeDpi->pNext;

    RtlLeaveCriticalSection(&gcsImeDpi);

    return (PIMEDPI)pImeDpi;
}


/**************************************************************************\
* ImmLockImeDpi
*
* 08-Jan-1996 wkwok       Created
\**************************************************************************/

PIMEDPI WINAPI ImmLockImeDpi(
    HKL hKL)
{
    PIMEDPI pImeDpi;

    RtlEnterCriticalSection(&gcsImeDpi);

    pImeDpi = gpImeDpi;

    while (pImeDpi != NULL && pImeDpi->hKL != hKL)
        pImeDpi = pImeDpi->pNext;

    if (pImeDpi != NULL) {
        if (pImeDpi->dwFlag & IMEDPI_UNLOADED)
            pImeDpi = NULL;
        else
            pImeDpi->cLock++;
    }

    RtlLeaveCriticalSection(&gcsImeDpi);

    return (PIMEDPI)pImeDpi;
}


/**************************************************************************\
* ImmUnlockImeDpi
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

VOID WINAPI ImmUnlockImeDpi(
    PIMEDPI pImeDpi)
{
    PIMEDPI pImeDpiT;

    if (pImeDpi == NULL)
        return;

    RtlEnterCriticalSection(&gcsImeDpi);

    if (--pImeDpi->cLock == 0) {

        if ((pImeDpi->dwFlag & IMEDPI_UNLOADED) ||
            ((pImeDpi->dwFlag & IMEDPI_UNLOCKUNLOAD) &&
             (pImeDpi->ImeInfo.fdwProperty & IME_PROP_END_UNLOAD)))
        {
            /*
             * Unlink it.
             */
            if (gpImeDpi == pImeDpi) {
                gpImeDpi = pImeDpi->pNext;
            }
            else {
                pImeDpiT = gpImeDpi;

                while (pImeDpiT != NULL && pImeDpiT->pNext != pImeDpi)
                    pImeDpiT = pImeDpiT->pNext;

                if (pImeDpiT != NULL)
                    pImeDpiT->pNext = pImeDpi->pNext;
            }

            /*
             * Unload the IME DLL.
             */
            UnloadIME(pImeDpi, TRUE);
            ImmLocalFree(pImeDpi);
        }
    }

    RtlLeaveCriticalSection(&gcsImeDpi);

    return;
}


/**************************************************************************\
* ImmGetImeInfoEx
*
* 03-Jan-1996 wkwok       Created
\**************************************************************************/

BOOL WINAPI ImmGetImeInfoEx(
    PIMEINFOEX piiex,
    IMEINFOEXCLASS SearchType,
    PVOID pvSearchKey)
{
#if defined(CUAS_ENABLE)
    BOOL fCUAS_OFF = FALSE;
#endif
    ImmAssert(piiex != NULL && pvSearchKey != NULL);

    switch (SearchType) {
#if defined(CUAS_ENABLE)
    case ImeInfoExKeyboardLayoutWithCUAS:
        fCUAS_OFF = CtfImmIsTextFrameServiceDisabled();
        SearchType = ImeInfoExKeyboardLayout;
#endif
    case ImeInfoExKeyboardLayout:
        piiex->hkl = *((HKL *)pvSearchKey);
        /*
         * Quick return for non-IME based keyboard layout
         */
#if !defined(CUAS_ENABLE)
        if (!IS_IME_KBDLAYOUT(piiex->hkl))
            return FALSE;
#else
        if (! IS_IME_KBDLAYOUT(piiex->hkl) &&
            (! IS_CICERO_ENABLED_AND_NOT16BIT() || fCUAS_OFF))
            return FALSE;
#endif
        break;

    case ImeInfoExImeFileName:
        wcscpy(piiex->wszImeFile, (PWSTR)pvSearchKey);

        break;

    default:
        return FALSE;
    }

    return NtUserGetImeInfoEx(piiex, SearchType);
}

/**************************************************************************\
* ImmGetAppCompatFlags
*
* private function
* returns Win95 compatible IME Compatibility flags
*
* 02-July-1996 takaok       Created
\**************************************************************************/
DWORD ImmGetAppCompatFlags( HIMC hImc )
{
    PCLIENTIMC    pClientImc;
    DWORD         dwImeCompat = 0;

    pClientImc = ImmLockClientImc( hImc );
    if ( pClientImc != NULL ) {
        dwImeCompat = pClientImc->dwImeCompatFlags;
        ImmUnlockClientImc( pClientImc );
    }
#ifdef CUAS_ENABLE
    dwImeCompat |= g_aimm_compat_flags;
#endif // CUAS_ENABLE
    return dwImeCompat;
}

/**************************************************************************\
* ImmPtInRect
*
* private function
*
* 02-July-1997 hiroyama     Created
\**************************************************************************/

BOOL ImmPtInRect(
    int left,
    int top,
    int width,
    int height,
    LPPOINT lppt)
{
    return (lppt->x >= left && lppt->x < (left + width) &&
            lppt->y >= top  && lppt->y < (top + height));
}


/**************************************************************************\
* ImmSystemHandler
*
* private function
*
* IMM bulk helper to handle WM_IME_SYSTEM message
*
* 02-July-1997 hiroyama     Created
\**************************************************************************/

LRESULT ImmSystemHandler(
    HIMC hImc,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT lRet = 0;

    switch (wParam) {
    case IMS_SENDNOTIFICATION:
        ImmSendNotification((BOOL)lParam);
        break;
    case IMS_FINALIZE_COMPSTR:
        ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
        break;
#ifdef CUAS_ENABLE
    case IMS_SETLANGBAND:
    case IMS_RESETLANGBAND:
        lRet = CtfImmSetLangBand((HWND)lParam, wParam == IMS_SETLANGBAND ? TRUE : FALSE);
        break;
#endif // CUAS_ENABLE
    }

    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\sftkbdc1.c ===
/**************************************************************************\
* Module Name: sftkbdc1.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Softkeyboard support for Simplified Chinese
*
* History:
* 03-Jan-1996 wkwok    Ported from Win95
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#include "softkbd.h"

// Virtual Key for Letter Buttons
CONST BYTE SKC1VirtKey[BUTTON_NUM_C1] = {
   VK_OEM_3, '1', '2', '3', '4', '5', '6','7', '8', '9', '0', VK_OEM_MINUS, VK_OEM_EQUAL,
   'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', VK_OEM_LBRACKET, VK_OEM_RBRACKET, VK_OEM_BSLASH,
   'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', VK_OEM_SEMICLN, VK_OEM_QUOTE,
   'Z', 'X', 'C', 'V', 'B', 'N', 'M', VK_OEM_COMMA, VK_OEM_PERIOD, VK_OEM_SLASH,
   VK_BACK, VK_TAB, VK_CAPITAL, VK_RETURN, VK_SHIFT, VK_INSERT, VK_DELETE, VK_SPACE,
   VK_ESCAPE
};

POINT gptButtonPos[BUTTON_NUM_C1]; // button point array, in the client area
BOOL  gfSoftKbdC1Init = FALSE;              // init flag

/**********************************************************************\
* InitSKC1ButtonPos -- init gptButtonPos
*
\**********************************************************************/
VOID InitSKC1ButtonPos()
{
    int  i, x, y;

    // init the first row
    y = 0;
    for (i=0, x=X_ROW_LETTER_C1; i < COL_LETTER_C1; i++, x += W_LETTER_BTN_C1) {
      gptButtonPos[i].x = x;
      gptButtonPos[i].y = y;
    }
    gptButtonPos[BACKSP_TYPE_C1].x = x;
    gptButtonPos[BACKSP_TYPE_C1].y = y;

    // init the second row
    y += H_LETTER_BTN_C1;
    x = 0;
    gptButtonPos[TAB_TYPE_C1].x = x;
    gptButtonPos[TAB_TYPE_C1].y = y;
    for (i=0, x=X_ROW2_LETTER_C1; i < COL2_LETTER_C1; i++, x += W_LETTER_BTN_C1) {
      gptButtonPos[i + COL_LETTER_C1].x = x;
      gptButtonPos[i + COL_LETTER_C1].y = y;
    }

    // init the third row
    y += H_LETTER_BTN_C1;
    x = 0;
    gptButtonPos[CAPS_TYPE_C1].x = x;
    gptButtonPos[CAPS_TYPE_C1].y = y;
    for (i=0, x=X_ROW3_LETTER_C1; i < COL3_LETTER_C1; i++, x += W_LETTER_BTN_C1) {
      gptButtonPos[i + COL_LETTER_C1 + COL2_LETTER_C1].x = x;
      gptButtonPos[i + COL_LETTER_C1 + COL2_LETTER_C1].y = y;
    }
    gptButtonPos[ENTER_TYPE_C1].x = x;
    gptButtonPos[ENTER_TYPE_C1].y = y;

    // init the forth row
    y += H_LETTER_BTN_C1;
    x = 0;
    gptButtonPos[SHIFT_TYPE_C1].x = x;
    gptButtonPos[SHIFT_TYPE_C1].y = y;
    for (i=0, x=X_ROW4_LETTER_C1; i < COL4_LETTER_C1; i++, x += W_LETTER_BTN_C1) {
      gptButtonPos[i + COL_LETTER_C1 + COL2_LETTER_C1 + COL3_LETTER_C1].x = x;
      gptButtonPos[i + COL_LETTER_C1 + COL2_LETTER_C1 + COL3_LETTER_C1].y = y;
    }

    // init the bottom row
    y += H_LETTER_BTN_C1;
    x = 0;
    gptButtonPos[INS_TYPE_C1].x = x;
    gptButtonPos[INS_TYPE_C1].y = y;
    x = X_DEL_C1;
    gptButtonPos[DEL_TYPE_C1].x = x;
    gptButtonPos[DEL_TYPE_C1].y = y;
    x += W_DEL_C1 + 2 * BORDER_C1;
    gptButtonPos[SPACE_TYPE_C1].x = x;
    gptButtonPos[SPACE_TYPE_C1].y = y;
    x = X_ESC_C1;
    gptButtonPos[ESC_TYPE_C1].x = x;
    gptButtonPos[ESC_TYPE_C1].y = y;

    return;
}


/**********************************************************************\
* SKC1DrawConvexRect --- draw button
*
*              (x1,y1)     x2-1
*               +----3------>^
*               |+----3-----||y1+1
*               ||          ||
*               33    1     42
*               ||          ||
*               |V          ||
*               |<----4-----+|
*         y2-1  ------2------+
*                             (x2,y2)
*
*  1 - light gray
*  2 - black
*  3 - white
*  4 - dark gray
*
\**********************************************************************/
VOID SKC1DrawConvexRect(
    HDC  hDC,
    int  x,
    int  y,
    int  nWidth,
    int  nHeight)
{
    // paint background
    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));
    SelectObject(hDC, GetStockObject(BLACK_PEN));
    Rectangle(hDC, x, y, x + nWidth, y + nHeight);

    // paint white border
    SelectObject(hDC, GetStockObject(WHITE_BRUSH));
    PatBlt(hDC, x, y + nHeight - 1, BORDER_C1, -nHeight + 1, PATCOPY);
    PatBlt(hDC, x, y, nWidth - 1 , BORDER_C1, PATCOPY);

    // paint dark gray border
    SelectObject(hDC, GetStockObject(GRAY_BRUSH));
    PatBlt(hDC, x + 1, y + nHeight -1, nWidth - BORDER_C1, -1, PATCOPY);
    PatBlt(hDC, x + nWidth - 1, y + nHeight - 1, -1, -nHeight + BORDER_C1, PATCOPY);

    return;
}


/**********************************************************************\
* SKC1InvertButton --- Invert Button
*
\**********************************************************************/
VOID SKC1InvertButton(
    HDC  hDC,
    int  uKeyIndex)
{
    int  nWidth, nHeight;

    if (uKeyIndex < 0) return;

    if (uKeyIndex < LETTER_NUM_C1) {
      nWidth = W_LETTER_BTN_C1;
      nHeight = H_LETTER_BTN_C1;
    } else {
      switch (uKeyIndex) {
        case BACKSP_TYPE_C1:
             nWidth = W_BACKSP_C1 + 2 * BORDER_C1;
             nHeight = H_LETTER_BTN_C1;
             break;
        case TAB_TYPE_C1:
             nWidth = W_TAB_C1 + 2 * BORDER_C1;
             nHeight = H_LETTER_BTN_C1;
             break;
        case CAPS_TYPE_C1:
             nWidth = W_CAPS_C1 + 2 * BORDER_C1;
             nHeight = H_LETTER_BTN_C1;
             break;
        case ENTER_TYPE_C1:
             nWidth = W_ENTER_C1 + 2 * BORDER_C1;
             nHeight = H_LETTER_BTN_C1;
             break;
        case SHIFT_TYPE_C1:
             nWidth = W_SHIFT_C1 + 2 * BORDER_C1;
             nHeight = H_LETTER_BTN_C1;
             break;
        case INS_TYPE_C1:
             nWidth = W_INS_C1 + 2 * BORDER_C1;
             nHeight = H_BOTTOM_BTN_C1;
             break;
        case DEL_TYPE_C1:
             nWidth = W_DEL_C1 + 2 * BORDER_C1;
             nHeight = H_BOTTOM_BTN_C1;
             break;
        case SPACE_TYPE_C1:
             nWidth = W_SPACE_C1 + 2 * BORDER_C1;
             nHeight = H_BOTTOM_BTN_C1;
             break;
        case ESC_TYPE_C1:
             nWidth = W_ESC_C1 + 2 * BORDER_C1;
             nHeight = H_BOTTOM_BTN_C1;
             break;
      }
    }

    BitBlt(hDC, gptButtonPos[uKeyIndex].x, gptButtonPos[uKeyIndex].y,
           nWidth, nHeight, hDC, gptButtonPos[uKeyIndex].x , gptButtonPos[uKeyIndex].y,
           DSTINVERT);

    return;
}


/**********************************************************************\
* SKC1DrawBitmap --- Draw bitmap within rectangle
*
\**********************************************************************/
VOID SKC1DrawBitmap(
    HDC hDC,
    int x,
    int y,
    int nWidth,
    int nHeight,
    LPWSTR lpszBitmap)
{
    HDC     hMemDC;
    HBITMAP hBitmap, hOldBmp;

    hBitmap = LoadBitmap(ghInst, lpszBitmap);
    hMemDC = CreateCompatibleDC(hDC);
    hOldBmp = SelectObject(hMemDC, hBitmap);

    BitBlt(hDC, x, y, nWidth, nHeight, hMemDC, 0 , 0, SRCCOPY);

    SelectObject(hMemDC, hOldBmp);
    DeleteDC(hMemDC);
    DeleteObject(hBitmap);

    return;
}


/**********************************************************************\
* SKC1DrawLabel -- Draw the label of button
*
\**********************************************************************/
VOID SKC1DrawLabel(
    HDC hDC,
    LPWSTR lpszLabel)
{
    HDC     hMemDC;
    HBITMAP hBitmap, hOldBmp;
    int     i, x;

    hBitmap = LoadBitmap(ghInst, lpszLabel);
    hMemDC = CreateCompatibleDC(hDC);
    hOldBmp = SelectObject(hMemDC, hBitmap);

    for (i=x=0; i < LETTER_NUM_C1; i++, x += SIZELABEL_C1){
     BitBlt(hDC, gptButtonPos[i].x + X_LABEL_C1, gptButtonPos[i].y + Y_LABEL_C1,
            SIZELABEL_C1, SIZELABEL_C1, hMemDC, x , 0, SRCCOPY);
    }

    SelectObject(hMemDC, hOldBmp);
    DeleteDC(hMemDC);
    DeleteObject(hBitmap);

    return;
}


/**********************************************************************\
* InitSKC1Bitmap -- init bitmap
*
\**********************************************************************/
VOID InitSKC1Bitmap(
    HDC  hDC,
    RECT rcClient)
{
    int  i;

    // draw softkbd rectangle
    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));
    SelectObject(hDC, GetStockObject(NULL_PEN));
    Rectangle(hDC, rcClient.left, rcClient.top, rcClient.right + 1, rcClient.bottom + 1);

    // draw letter buttons
    for (i = 0; i < LETTER_NUM_C1; i++) {
      SKC1DrawConvexRect(hDC, gptButtonPos[i].x, gptButtonPos[i].y,
                         W_LETTER_BTN_C1, H_LETTER_BTN_C1);
    }
    // draw letter label
    SKC1DrawLabel(hDC, MAKEINTRESOURCEW(LABEL_C1));

    // draw other buttons
    SKC1DrawConvexRect(hDC, gptButtonPos[BACKSP_TYPE_C1].x, gptButtonPos[BACKSP_TYPE_C1].y,
                       W_BACKSP_C1 + 2 * BORDER_C1, H_LETTER_BTN_C1);
    SKC1DrawBitmap(hDC, gptButtonPos[BACKSP_TYPE_C1].x + BORDER_C1, gptButtonPos[BACKSP_TYPE_C1].y + BORDER_C1,
                   W_BACKSP_C1, H_BACKSP_C1, MAKEINTRESOURCEW(BACKSP_C1));

    SKC1DrawConvexRect(hDC, gptButtonPos[TAB_TYPE_C1].x, gptButtonPos[TAB_TYPE_C1].y,
                       W_TAB_C1 + 2 * BORDER_C1, H_LETTER_BTN_C1);
    SKC1DrawBitmap(hDC, gptButtonPos[TAB_TYPE_C1].x + BORDER_C1, gptButtonPos[TAB_TYPE_C1].y + BORDER_C1,
                   W_TAB_C1, H_TAB_C1, MAKEINTRESOURCEW(TAB_C1));

    SKC1DrawConvexRect(hDC, gptButtonPos[CAPS_TYPE_C1].x, gptButtonPos[CAPS_TYPE_C1].y,
                       W_CAPS_C1 + 2 * BORDER_C1, H_LETTER_BTN_C1);
    SKC1DrawBitmap(hDC, gptButtonPos[CAPS_TYPE_C1].x + BORDER_C1, gptButtonPos[CAPS_TYPE_C1].y + BORDER_C1,
                   W_CAPS_C1, H_CAPS_C1, MAKEINTRESOURCEW(CAPS_C1));

    SKC1DrawConvexRect(hDC, gptButtonPos[ENTER_TYPE_C1].x, gptButtonPos[ENTER_TYPE_C1].y,
                       W_ENTER_C1 + 2 * BORDER_C1, H_LETTER_BTN_C1);
    SKC1DrawBitmap(hDC, gptButtonPos[ENTER_TYPE_C1].x + BORDER_C1, gptButtonPos[ENTER_TYPE_C1].y + BORDER_C1,
                   W_ENTER_C1, H_ENTER_C1, MAKEINTRESOURCEW(ENTER_C1));

    SKC1DrawConvexRect(hDC, gptButtonPos[SHIFT_TYPE_C1].x, gptButtonPos[SHIFT_TYPE_C1].y,
                       W_SHIFT_C1 + 2 * BORDER_C1, H_LETTER_BTN_C1);
    SKC1DrawBitmap(hDC, gptButtonPos[SHIFT_TYPE_C1].x + BORDER_C1, gptButtonPos[SHIFT_TYPE_C1].y + BORDER_C1,
                   W_SHIFT_C1, H_SHIFT_C1, MAKEINTRESOURCEW(SHIFT_C1));

    SKC1DrawConvexRect(hDC, gptButtonPos[INS_TYPE_C1].x, gptButtonPos[INS_TYPE_C1].y,
                       W_INS_C1 + 2 * BORDER_C1, H_BOTTOM_BTN_C1);
    SKC1DrawBitmap(hDC, gptButtonPos[INS_TYPE_C1].x + BORDER_C1, gptButtonPos[INS_TYPE_C1].y + BORDER_C1,
                   W_INS_C1, H_INS_C1, MAKEINTRESOURCEW(INS_C1));

    SKC1DrawConvexRect(hDC, gptButtonPos[DEL_TYPE_C1].x, gptButtonPos[DEL_TYPE_C1].y,
                       W_DEL_C1 + 2 * BORDER_C1, H_BOTTOM_BTN_C1);
    SKC1DrawBitmap(hDC, gptButtonPos[DEL_TYPE_C1].x + BORDER_C1, gptButtonPos[DEL_TYPE_C1].y + BORDER_C1,
                   W_DEL_C1, H_DEL_C1, MAKEINTRESOURCEW(DEL_C1));

    SKC1DrawConvexRect(hDC, gptButtonPos[SPACE_TYPE_C1].x, gptButtonPos[SPACE_TYPE_C1].y,
                       W_SPACE_C1 + 2 * BORDER_C1, H_BOTTOM_BTN_C1);

    SKC1DrawConvexRect(hDC, gptButtonPos[ESC_TYPE_C1].x, gptButtonPos[ESC_TYPE_C1].y,
                       W_ESC_C1 + 2 * BORDER_C1, H_BOTTOM_BTN_C1);
    SKC1DrawBitmap(hDC, gptButtonPos[ESC_TYPE_C1].x + BORDER_C1, gptButtonPos[ESC_TYPE_C1].y + BORDER_C1,
                   W_ESC_C1, H_ESC_C1, MAKEINTRESOURCEW(ESC_C1));

    return;
}


/**********************************************************************\
* CreateC1Window
*
* Init softkeyboard gloabl variabls, context and bitmap
*
\**********************************************************************/
LRESULT CreateC1Window(
    HWND hSKWnd)
{
    HGLOBAL   hSKC1Ctxt;
    PSKC1CTXT pSKC1Ctxt;

    // alloc and lock hSKC1CTxt
    hSKC1Ctxt = GlobalAlloc(GHND, sizeof(SKC1CTXT));
    if (!hSKC1Ctxt) {
        return (-1L);
    }

    pSKC1Ctxt = (PSKC1CTXT)GlobalLock(hSKC1Ctxt);
    if (!pSKC1Ctxt) {
        GlobalFree(hSKC1Ctxt);
        return (-1L);
    }

    // save handle in SKC1_CONTEXT
    SetWindowLongPtr(hSKWnd, SKC1_CONTEXT, (LONG_PTR)hSKC1Ctxt);

    // init global varialbles
    if (!gfSoftKbdC1Init){
      InitSKC1ButtonPos();
      gfSoftKbdC1Init = TRUE;
    }

    // no index and default char set
    pSKC1Ctxt->uKeyIndex = -1;
    pSKC1Ctxt->lfCharSet = GB2312_CHARSET;

    // init softkeyboard
    {
      HDC        hDC, hMemDC;
      HBITMAP    hBitmap, hOldBmp;
      RECT       rcClient;

      GetClientRect(hSKWnd, &rcClient);

      hDC = GetDC(hSKWnd);
      hMemDC = CreateCompatibleDC(hDC);
      hBitmap = CreateCompatibleBitmap(hDC, rcClient.right - rcClient.left,
                                       rcClient.bottom - rcClient.top);
      ReleaseDC(hSKWnd, hDC);

      hOldBmp = SelectObject(hMemDC, hBitmap);

      InitSKC1Bitmap(hMemDC, rcClient);

      SelectObject(hMemDC, hOldBmp);
      pSKC1Ctxt->hSoftkbd = hBitmap; // save hBitmap in SKC1CTXT

      DeleteDC(hMemDC);
    }

    // unlock hSKC1CTxt
    GlobalUnlock(hSKC1Ctxt);

    return (0L);
}


/**********************************************************************\
* DestroyC1Window
*
* Destroy softkeyboard context and bitmap
*
\**********************************************************************/
VOID DestroyC1Window(
    HWND hSKWnd)
{
    HGLOBAL   hSKC1Ctxt;
    PSKC1CTXT pSKC1Ctxt;
    HWND      hUIWnd;

    // Get and Lock hSKC1Ctxt
    hSKC1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKC1_CONTEXT);
    if (!hSKC1Ctxt) return;

    pSKC1Ctxt = (PSKC1CTXT)GlobalLock(hSKC1Ctxt);
    if (!pSKC1Ctxt) return;

    if (pSKC1Ctxt->uState & FLAG_DRAG_C1) {
       SKC1DrawDragBorder(hSKWnd, &pSKC1Ctxt->ptSkCursor,
                          &pSKC1Ctxt->ptSkOffset);
    }

    DeleteObject(pSKC1Ctxt->hSoftkbd); // delete hBitmap

    // Unlock and Free hSKC1Ctxt
    GlobalUnlock(hSKC1Ctxt);
    GlobalFree(hSKC1Ctxt);

    // send message to parent window
    hUIWnd = GetWindow(hSKWnd, GW_OWNER);
    if (hUIWnd) {
      SendMessage(hUIWnd, WM_IME_NOTIFY, IMN_SOFTKBDDESTROYED, 0);\
    }

    return;
}


/**********************************************************************\
* ShowSKC1Window -- Show softkeyboard
*
\**********************************************************************/
VOID ShowSKC1Window(
    HDC  hDC,
    HWND hSKWnd)
{
    HGLOBAL   hSKC1Ctxt;
    PSKC1CTXT pSKC1Ctxt;

    // Get and Lock hSKC1Ctxt
    hSKC1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKC1_CONTEXT);
    if (!hSKC1Ctxt) return;

    pSKC1Ctxt = (PSKC1CTXT)GlobalLock(hSKC1Ctxt);
    if (!pSKC1Ctxt) return;

    // create mem dc to show softkeyboard
    {
       HDC      hMemDC;
       HBITMAP  hOldBmp;
       RECT     rcClient;

       hMemDC = CreateCompatibleDC(hDC);
       hOldBmp = SelectObject(hMemDC, pSKC1Ctxt->hSoftkbd);
       GetClientRect(hSKWnd, &rcClient);
       BitBlt(hDC, 0, 0, rcClient.right - rcClient.left, rcClient.bottom - rcClient.top,
              hMemDC, 0, 0, SRCCOPY);
       SelectObject(hMemDC, hOldBmp);
       DeleteDC(hMemDC);
    }

    // Unlock hSKC1Ctxt
    GlobalUnlock(hSKC1Ctxt);

    return;
}


/**********************************************************************\
* UpdateSKC1Window -- update softkeyboard
*
\**********************************************************************/
BOOL UpdateSKC1Window(
    HWND          hSKWnd,
    LPSOFTKBDDATA lpSoftKbdData)
{
    HGLOBAL   hSKC1Ctxt;
    PSKC1CTXT pSKC1Ctxt;
    LOGFONT   lfFont;
    HFONT     hOldFont, hFont;
    HDC       hDC, hMemDC;
    HBITMAP   hOldBmp;
    int       i;

    // check the lpSoftKbdData
    if (lpSoftKbdData->uCount!=2) return FALSE;

    // Get and Lock hSKC1Ctxt
    hSKC1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKC1_CONTEXT);
    if (!hSKC1Ctxt) return FALSE;

    pSKC1Ctxt = (PSKC1CTXT)GlobalLock(hSKC1Ctxt);
    if (!pSKC1Ctxt) return FALSE;

    // create font
    hDC = GetDC(hSKWnd);
    hMemDC = CreateCompatibleDC(hDC);
    hOldBmp = SelectObject(hMemDC, pSKC1Ctxt->hSoftkbd);

    GetObject(GetStockObject(DEFAULT_GUI_FONT), sizeof(lfFont), &lfFont);
    lfFont.lfHeight = -SIZEFONT_C1;
    if (pSKC1Ctxt->lfCharSet != DEFAULT_CHARSET) {
        lfFont.lfCharSet = (BYTE)pSKC1Ctxt->lfCharSet;
    }

    hFont = CreateFontIndirect(&lfFont);
    hOldFont = SelectObject(hMemDC, hFont);


    // update shift/non-shift chars
    for (i=0; i < LETTER_NUM_C1; i++) {
        pSKC1Ctxt->wNonShiftCode[i] = lpSoftKbdData->wCode[0][SKC1VirtKey[i]];
        pSKC1Ctxt->wShiftCode[i] = lpSoftKbdData->wCode[1][SKC1VirtKey[i]];
    }

    SetBkColor(hMemDC, 0x00BFBFBF);  // set text bk color ??

    for (i=0; i < LETTER_NUM_C1; i++) {
        int  nchar;
        RECT rc;

        // draw shift char.
        rc.left = gptButtonPos[i].x + X_SHIFT_CHAR_C1;
        rc.top = gptButtonPos[i].y + Y_SHIFT_CHAR_C1;
        rc.right = rc.left + SIZEFONT_C1;
        rc.bottom = rc.top + SIZEFONT_C1;

        nchar = (pSKC1Ctxt->wShiftCode[i] == 0) ? 0 : 1;

#if (WINVER >= 0x0400)
        DrawTextEx(hMemDC, (LPWSTR)&pSKC1Ctxt->wShiftCode[i],
                   nchar, &rc, DT_CENTER, NULL);
#else
        ExtTextOut(hMemDC,
            rc.left,
            rc.top,
            ETO_OPAQUE, &rc,
            (LPWSTR)&pSKC1Ctxt->wShiftCode[i], nchar, NULL);
#endif

        // draw non-shift char.
        rc.left = gptButtonPos[i].x + X_NONSHIFT_CHAR_C1;
        rc.top = gptButtonPos[i].y + Y_NONSHIFT_CHAR_C1;
        rc.right = rc.left + SIZEFONT_C1;
        rc.bottom = rc.top + SIZEFONT_C1;

        nchar = (pSKC1Ctxt->wNonShiftCode[i] == 0) ? 0 : 1;

#if (WINVER >= 0x0400)
        DrawTextEx(hMemDC, (LPWSTR)&pSKC1Ctxt->wNonShiftCode[i],
                   nchar, &rc, DT_CENTER, NULL);
#else
        ExtTextOut(hMemDC,
            rc.left,
            rc.top,
            ETO_OPAQUE, &rc,
            (LPWSTR)&pSKC1Ctxt->wNonShiftCode[i], nchar, NULL);
#endif
    }

    // init states
    if (pSKC1Ctxt->uState & FLAG_SHIFT_C1){
       SKC1InvertButton(hMemDC, SHIFT_TYPE_C1);
    }
    pSKC1Ctxt->uState = 0;

    SelectObject(hMemDC, hOldBmp);
    SelectObject(hMemDC, hOldFont);
    DeleteDC(hMemDC);

    DeleteObject(hFont);
    ReleaseDC(hSKWnd,hDC);

    // Unlock hSKC1Ctxt
    GlobalUnlock(hSKC1Ctxt);

    return TRUE;
}


/**********************************************************************\
* SKC1DrawDragBorder() -- Draw Drag Border
*
\**********************************************************************/
VOID SKC1DrawDragBorder(
    HWND    hWnd,               // window is dragged
    LPPOINT lpptCursor,         // the cursor position
    LPPOINT lpptOffset)         // the offset form cursor to window org
{
    HDC     hDC;
    RECT    rcWnd, rcWorkArea;
    int     cxBorder, cyBorder;
    int     x, y;
    extern void GetAllMonitorSize(LPRECT lprc);

    // get rectangle of work area
    GetAllMonitorSize(&rcWorkArea);

    cxBorder = GetSystemMetrics(SM_CXBORDER);   // width of border
    cyBorder = GetSystemMetrics(SM_CYBORDER);   // height of border

    // create DISPLAY dc to draw track
    hDC = CreateDC(L"DISPLAY", NULL, NULL, NULL);
    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    // start point (left,top)
    x = lpptCursor->x - lpptOffset->x;
    y = lpptCursor->y - lpptOffset->y;

    // check for the min boundary of the display
    if (x < rcWorkArea.left) {
        x = rcWorkArea.left;
    }

    if (y < rcWorkArea.top) {
        y = rcWorkArea.top;
    }

    // check for the max boundary of the display
    GetWindowRect(hWnd, &rcWnd);

    if (x + rcWnd.right - rcWnd.left > rcWorkArea.right) {
        x = rcWorkArea.right - (rcWnd.right - rcWnd.left);
    }

    if (y + rcWnd.bottom - rcWnd.top > rcWorkArea.bottom) {
        y = rcWorkArea.bottom - (rcWnd.bottom - rcWnd.top);
    }

    // adjust Offset
    lpptOffset->x = lpptCursor->x - x;
    lpptOffset->y = lpptCursor->y - y;

    // draw rectangle
    PatBlt(hDC, x, y, rcWnd.right - rcWnd.left - cxBorder, cyBorder, PATINVERT);
    PatBlt(hDC, x, y + cyBorder, cxBorder, rcWnd.bottom - rcWnd.top - cyBorder, PATINVERT);
    PatBlt(hDC, x + cxBorder, y + rcWnd.bottom - rcWnd.top, rcWnd.right -
           rcWnd.left - cxBorder, -cyBorder, PATINVERT);
    PatBlt(hDC, x + rcWnd.right - rcWnd.left, y, - cxBorder, rcWnd.bottom -
           rcWnd.top - cyBorder, PATINVERT);

    // delete DISPLAY DC
    DeleteDC(hDC);

    return;
}


/**********************************************************************\
* SKC1MousePosition() -- judge the cursor position
*
\**********************************************************************/

#define CHECK_RECT(name)  \
    if (ImmPtInRect(gptButtonPos[name ## _TYPE_C1].x,   \
            gptButtonPos[name ## _TYPE_C1].y,           \
            W_ ## name ## _C1 + 2 * BORDER_C1,          \
            H_ ## name ## _C1 + 2 * BORDER_C1,          \
            lpptCursor)) {                              \
        return name ## _TYPE_C1;                        \
    }

INT SKC1MousePosition(
    LPPOINT lpptCursor)
{
    int   i;

    // letter buttons
    for (i = 0; i < LETTER_NUM_C1; i++){

       if (ImmPtInRect(gptButtonPos[i].x,
                gptButtonPos[i].y,
                W_LETTER_BTN_C1,
                H_LETTER_BTN_C1,
                lpptCursor)) {
           return i;
       }
    }

    CHECK_RECT(BACKSP);
    CHECK_RECT(TAB);
    CHECK_RECT(CAPS);
    CHECK_RECT(ENTER);
    CHECK_RECT(SHIFT);
    CHECK_RECT(ESC);
    CHECK_RECT(SPACE);
    CHECK_RECT(INS);
    CHECK_RECT(DEL);

    return -1;
}

#undef CHECK_RECT


/**********************************************************************\
* SKC1ButtonDown
*
\**********************************************************************/
VOID SKC1ButtonDown(
    HWND      hSKWnd,
    PSKC1CTXT pSKC1Ctxt)
{
    // capture the mouse activity
    SetCapture(hSKWnd);

    // in drag area
    if (pSKC1Ctxt->uKeyIndex == -1) {
       pSKC1Ctxt->uState |= FLAG_DRAG_C1;

       SKC1DrawDragBorder(hSKWnd, &pSKC1Ctxt->ptSkCursor, &pSKC1Ctxt->ptSkOffset);
    } else {
       UINT uVirtKey = 0xff;
       BOOL bRet = FALSE;

       if (pSKC1Ctxt->uKeyIndex == SHIFT_TYPE_C1) {
          if (!(pSKC1Ctxt->uState & FLAG_SHIFT_C1)) {
             bRet = TRUE;
          }
       } else if (pSKC1Ctxt->uKeyIndex < LETTER_NUM_C1) {
          if (pSKC1Ctxt->uState & FLAG_SHIFT_C1) {
             uVirtKey = pSKC1Ctxt->wShiftCode[pSKC1Ctxt->uKeyIndex];
          }
          else {
             uVirtKey = pSKC1Ctxt->wNonShiftCode[pSKC1Ctxt->uKeyIndex];
          }

          if (uVirtKey) {
             bRet = TRUE;
          } else {
             MessageBeep(0xFFFFFFFF);
             pSKC1Ctxt->uKeyIndex = -1;
          }
       } else {
          bRet = TRUE;
       }

       if (bRet) {
          HDC      hDC, hMemDC;
          HBITMAP  hOldBmp;

          hDC = GetDC(hSKWnd);
          hMemDC = CreateCompatibleDC(hDC);
          hOldBmp = SelectObject(hMemDC, pSKC1Ctxt->hSoftkbd);

          SKC1InvertButton(hDC, pSKC1Ctxt->uKeyIndex);
          SKC1InvertButton(hMemDC, pSKC1Ctxt->uKeyIndex);

          SelectObject(hMemDC, hOldBmp);
          DeleteDC(hMemDC);
          ReleaseDC(hSKWnd,hDC);
       }

       if(uVirtKey) {
          pSKC1Ctxt->uState |= FLAG_FOCUS_C1;
       }
    }

    return;
}


/**********************************************************************\
* SKC1SetCursor
*
\**********************************************************************/
BOOL SKC1SetCursor(
   HWND   hSKWnd,
   LPARAM lParam)
{
    HGLOBAL   hSKC1Ctxt;
    PSKC1CTXT pSKC1Ctxt;
    POINT     ptSkCursor, ptSkOffset;
    int       uKeyIndex;

    // Get and lock hSKC1Ctxt
    hSKC1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKC1_CONTEXT);
    if (!hSKC1Ctxt) {
        return (FALSE);
    }

    pSKC1Ctxt = (PSKC1CTXT)GlobalLock(hSKC1Ctxt);
    if (!pSKC1Ctxt) {
        return (FALSE);
    }

    if (pSKC1Ctxt->uState & FLAG_DRAG_C1){
        // in drag operation
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        GlobalUnlock(hSKC1Ctxt);
        return (TRUE);
    }

    GetCursorPos(&ptSkCursor);
    ptSkOffset = ptSkCursor;
    ScreenToClient(hSKWnd, &ptSkOffset);

    uKeyIndex = SKC1MousePosition(&ptSkOffset);

    if (uKeyIndex != -1) {
       SetCursor(LoadCursor(NULL, IDC_HAND));
    } else {
       SetCursor(LoadCursor(NULL, IDC_SIZEALL));
    }

    if (HIWORD(lParam) != WM_LBUTTONDOWN){
       // unlock hSKC1Ctxt
       GlobalUnlock(hSKC1Ctxt);
       return (TRUE);
    }

    pSKC1Ctxt->ptSkCursor = ptSkCursor;
    pSKC1Ctxt->ptSkOffset = ptSkOffset;
    pSKC1Ctxt->uKeyIndex = uKeyIndex;

    SKC1ButtonDown(hSKWnd, pSKC1Ctxt);

    // unlock hSKC1Ctxt
    GlobalUnlock(hSKC1Ctxt);
    return (TRUE);
}


/**********************************************************************\
* SKC1MouseMove
*
\**********************************************************************/
BOOL SKC1MouseMove(
    HWND   hSKWnd,
    WPARAM wParam,
    LPARAM lParam)
{
    HGLOBAL   hSKC1Ctxt;
    PSKC1CTXT pSKC1Ctxt;

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);

    // get and lock hSKC1Ctxt
    hSKC1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKC1_CONTEXT);
    if (!hSKC1Ctxt) {
       return (FALSE);
    }

    pSKC1Ctxt = (PSKC1CTXT)GlobalLock(hSKC1Ctxt);
    if (!pSKC1Ctxt) {
       return (FALSE);
    }

    if (pSKC1Ctxt->uState & FLAG_DRAG_C1) {
       SKC1DrawDragBorder(hSKWnd, &pSKC1Ctxt->ptSkCursor,
                          &pSKC1Ctxt->ptSkOffset);

       GetCursorPos(&pSKC1Ctxt->ptSkCursor);

       SKC1DrawDragBorder(hSKWnd, &pSKC1Ctxt->ptSkCursor,
                          &pSKC1Ctxt->ptSkOffset);
    } else if (pSKC1Ctxt->uKeyIndex != -1) {
       HDC      hDC, hMemDC;
       HBITMAP  hOldBmp;
       POINT    ptSkOffset;
       int      uKeyIndex;

       GetCursorPos(&ptSkOffset);
       ScreenToClient(hSKWnd, &ptSkOffset);
       uKeyIndex = SKC1MousePosition(&ptSkOffset);

       hDC = GetDC(hSKWnd);
       hMemDC = CreateCompatibleDC(hDC);
       hOldBmp = SelectObject(hMemDC, pSKC1Ctxt->hSoftkbd);

       if (((pSKC1Ctxt->uState & FLAG_FOCUS_C1) && (uKeyIndex != pSKC1Ctxt->uKeyIndex)) ||
           (!(pSKC1Ctxt->uState & FLAG_FOCUS_C1) && (uKeyIndex == pSKC1Ctxt->uKeyIndex))) {
          if ((pSKC1Ctxt->uKeyIndex != SHIFT_TYPE_C1) ||
              !(pSKC1Ctxt->uState & FLAG_SHIFT_C1)) {
             SKC1InvertButton(hDC, pSKC1Ctxt->uKeyIndex);
             SKC1InvertButton(hMemDC, pSKC1Ctxt->uKeyIndex);
          }
          pSKC1Ctxt->uState ^= FLAG_FOCUS_C1;
       }

       SelectObject(hMemDC, hOldBmp);
       DeleteDC(hMemDC);
       ReleaseDC(hSKWnd,hDC);
    }

    // unlock hSKC1Ctxt
    GlobalUnlock(hSKC1Ctxt);

    return (TRUE);
}


/**********************************************************************\
* SKC1ButtonUp
*
\**********************************************************************/
BOOL SKC1ButtonUp(
    HWND       hSKWnd,
    WPARAM     wParam,
    LPARAM     lParam)
{
    HGLOBAL   hSKC1Ctxt;
    PSKC1CTXT pSKC1Ctxt;
    POINT     pt;
    UINT      uVirtKey;
    BOOL      bRet = FALSE;

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);

    // Get and lock hSKC1Ctxt
    hSKC1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKC1_CONTEXT);
    if (!hSKC1Ctxt) {
        return (bRet);
    }

    pSKC1Ctxt = (PSKC1CTXT)GlobalLock(hSKC1Ctxt);
    if (!pSKC1Ctxt) {
        return (bRet);
    }

    ReleaseCapture();

    if (pSKC1Ctxt->uState & FLAG_DRAG_C1) {
       pSKC1Ctxt->uState &= ~(FLAG_DRAG_C1);

       SKC1DrawDragBorder(hSKWnd, &pSKC1Ctxt->ptSkCursor, &pSKC1Ctxt->ptSkOffset);

       pt.x = pSKC1Ctxt->ptSkCursor.x - pSKC1Ctxt->ptSkOffset.x;
       pt.y = pSKC1Ctxt->ptSkCursor.y - pSKC1Ctxt->ptSkOffset.y;

       SetWindowPos(hSKWnd, (HWND)NULL, pt.x, pt.y,
                     0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

       // update IMC
       bRet = TRUE;
       {
          HWND          hUIWnd;
          HIMC          hImc;
          PINPUTCONTEXT pInputContext;

          hUIWnd = GetWindow(hSKWnd, GW_OWNER);
          hImc = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
          if (hImc) {
             pInputContext = ImmLockIMC(hImc);
             if (pInputContext) {
                pInputContext->ptSoftKbdPos = pt;
                pInputContext->fdwInit |= INIT_SOFTKBDPOS;
                ImmUnlockIMC(hImc);
             }
          }
       }
    } else if (pSKC1Ctxt->uKeyIndex != -1) {
       if (pSKC1Ctxt->uState & FLAG_FOCUS_C1) {
          if (pSKC1Ctxt->uKeyIndex == SHIFT_TYPE_C1) {
             if (pSKC1Ctxt->uState & FLAG_SHIFT_C1) {
                bRet = TRUE;
             } else {
                pSKC1Ctxt->uState |= FLAG_SHIFT_C1;
             }
          } else if ((pSKC1Ctxt->uKeyIndex < LETTER_NUM_C1) &&
                     (pSKC1Ctxt->uState & FLAG_SHIFT_C1)) {
                keybd_event((BYTE)VK_SHIFT, (BYTE)guScanCode[VK_SHIFT],
                            0, 0);
                uVirtKey = SKC1VirtKey[pSKC1Ctxt->uKeyIndex];
                keybd_event((BYTE)uVirtKey, (BYTE)guScanCode[uVirtKey],
                           0, 0);
                keybd_event((BYTE)uVirtKey, (BYTE)guScanCode[uVirtKey],
                           (DWORD)KEYEVENTF_KEYUP, 0);
                keybd_event((BYTE)VK_SHIFT, (BYTE)guScanCode[VK_SHIFT],
                            (DWORD)KEYEVENTF_KEYUP, 0);
                bRet = TRUE;
          } else {
                uVirtKey = SKC1VirtKey[pSKC1Ctxt->uKeyIndex];
                keybd_event((BYTE)uVirtKey, (BYTE)guScanCode[uVirtKey],
                         0, 0);
                keybd_event((BYTE)uVirtKey, (BYTE)guScanCode[uVirtKey],
                         (DWORD)KEYEVENTF_KEYUP, 0);
                bRet = TRUE;
          }

          if (bRet){
             HDC      hDC, hMemDC;
             HBITMAP  hOldBmp;

             hDC = GetDC(hSKWnd);
             hMemDC = CreateCompatibleDC(hDC);
             hOldBmp = SelectObject(hMemDC, pSKC1Ctxt->hSoftkbd);

             SKC1InvertButton(hDC, pSKC1Ctxt->uKeyIndex);
             SKC1InvertButton(hMemDC, pSKC1Ctxt->uKeyIndex);

             if ((pSKC1Ctxt->uKeyIndex != SHIFT_TYPE_C1) &&
                 (pSKC1Ctxt->uKeyIndex < LETTER_NUM_C1) &&
                 (pSKC1Ctxt->uState & FLAG_SHIFT_C1)) {
                SKC1InvertButton(hDC, SHIFT_TYPE_C1);
                SKC1InvertButton(hMemDC, SHIFT_TYPE_C1);
             }

             if ((pSKC1Ctxt->uKeyIndex < LETTER_NUM_C1) ||
                 (pSKC1Ctxt->uKeyIndex == SHIFT_TYPE_C1)) {
                pSKC1Ctxt->uState &= ~(FLAG_SHIFT_C1);
             }

             SelectObject(hMemDC, hOldBmp);
             DeleteDC(hMemDC);
             ReleaseDC(hSKWnd,hDC);
          }
          pSKC1Ctxt->uState &= ~ (FLAG_FOCUS_C1);
       }
       pSKC1Ctxt->uKeyIndex = -1;
    }

    // unlock hSKC1Ctxt
    GlobalUnlock(hSKC1Ctxt);

    return (bRet);
}


/**********************************************************************\
* SKWndProcC1 -- softkeyboard window procedure
*
\**********************************************************************/
LRESULT SKWndProcC1(
    HWND   hSKWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT    lRet = 0L;

    switch (uMsg) {
       case WM_CREATE:
            lRet = CreateC1Window(hSKWnd);
            break;

       case WM_DESTROY:
            DestroyC1Window(hSKWnd);
            break;

       case WM_PAINT:
            {
               HDC         hDC;
               PAINTSTRUCT ps;

               hDC = BeginPaint(hSKWnd, &ps);
               ShowSKC1Window(hDC, hSKWnd);
               EndPaint(hSKWnd, &ps);
            }
            break;

       case WM_MOUSEACTIVATE:
            lRet = MA_NOACTIVATE;
            break;

       case WM_SETCURSOR:
            if (!SKC1SetCursor(hSKWnd, lParam)) {
               lRet = DefWindowProc(hSKWnd, uMsg, wParam, lParam);
            }
            break;

       case WM_MOUSEMOVE:
            if (!SKC1MouseMove(hSKWnd, wParam, lParam)) {
               lRet = DefWindowProc(hSKWnd, uMsg, wParam, lParam);
            }
            break;

       case WM_LBUTTONUP:
            if (!SKC1ButtonUp(hSKWnd, wParam, lParam)) {
               lRet = DefWindowProc(hSKWnd, uMsg, wParam, lParam);
            }
            break;

       case WM_IME_CONTROL:
            switch (wParam) {
               case IMC_GETSOFTKBDFONT:
                    {
                       HDC        hDC;
                       LOGFONT    lfFont;

                       hDC = GetDC(hSKWnd);
                       GetObject(GetStockObject(DEFAULT_GUI_FONT),
                                 sizeof(lfFont), &lfFont);
                       ReleaseDC(hSKWnd, hDC);
                       *(LPLOGFONT)lParam = lfFont;
                    }
                    break;

               case IMC_SETSOFTKBDFONT:
                    {
                       LOGFONT lfFont;

                       GetObject(GetStockObject(DEFAULT_GUI_FONT),
                           sizeof(lfFont), &lfFont);

                       // in differet version of Windows
                       if (lfFont.lfCharSet != ((LPLOGFONT)lParam)->lfCharSet) {
                           HGLOBAL    hSKC1Ctxt;
                           LPSKC1CTXT lpSKC1Ctxt;

                           hSKC1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd,
                               SKC1_CONTEXT);
                           if (!hSKC1Ctxt) {
                               return 1;
                           }

                           lpSKC1Ctxt = (LPSKC1CTXT)GlobalLock(hSKC1Ctxt);
                           if (!lpSKC1Ctxt) {
                               return 1;
                           }

                           lpSKC1Ctxt->lfCharSet =
                               ((LPLOGFONT)lParam)->lfCharSet;

                           GlobalUnlock(hSKC1Ctxt);
                       }
                    }
                    break;

               case IMC_GETSOFTKBDPOS:
                    {
                       RECT rcWnd;

                       GetWindowRect(hSKWnd, &rcWnd);

                       return MAKELRESULT(rcWnd.left, rcWnd.top);
                    }
                    break;

               case IMC_SETSOFTKBDPOS:
                    {
                       SetWindowPos(hSKWnd, NULL,
                            ((LPPOINTS)lParam)->x, ((LPPOINTS)lParam)->y,
                            0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
                       return (0);
                    }
                    break;

               case IMC_SETSOFTKBDDATA:
                    if (UpdateSKC1Window(hSKWnd, (LPSOFTKBDDATA)lParam)) {
                       InvalidateRect(hSKWnd, NULL, FALSE);
                    } else lRet = -1L;
                    break;

               case IMC_GETSOFTKBDSUBTYPE:
               case IMC_SETSOFTKBDSUBTYPE:
                    {
                       HGLOBAL   hSKC1Ctxt;
                       PSKC1CTXT pSKC1Ctxt;

                       lRet = -1L;

                       hSKC1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKC1_CONTEXT);
                       if (!hSKC1Ctxt) break;

                       pSKC1Ctxt = (PSKC1CTXT)GlobalLock(hSKC1Ctxt);
                       if (!pSKC1Ctxt) break;

                       if (wParam == IMC_GETSOFTKBDSUBTYPE) {
                          lRet = pSKC1Ctxt->uSubtype;
                       } else {
                          lRet = pSKC1Ctxt->uSubtype;
                          pSKC1Ctxt->uSubtype = (UINT)lParam;
                       }

                       GlobalUnlock(hSKC1Ctxt);
                    }
                    break;
            }
            break;

       default:
            lRet = DefWindowProc(hSKWnd, uMsg, wParam, lParam);
    }

    return (lRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF
!include $(WINCORE_PATH)\core.inc

TARGETNAME=imm32
TARGETNAMEP=imm32p
TARGETTYPE=DYNLINK
DLLENTRY=ImmDllInitialize

TARGETPATH=$(_OBJ_DIR)
PASS1_PUBLISH=\
    {$(DYNLINK_LIB)=$(SDK_LIB_DEST)\$(DYNLINK_LIBDIR)}        \
    {$(DYNLINK_LIBP)=$(WINDOWS_LIB_DEST)\$(DYNLINK_LIBPDIR)}

TARGETLIBS=$(SDK_LIB_PATH)\kernl32p.lib                       \
           $(WINDOWS_LIB_PATH)\gdi32p.lib                     \
           $(SDK_LIB_PATH)\advapi32.lib                       \
           $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\user32p.lib


LINKLIBS = $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\w32umode.lib    \
           $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\user32p.lib     \
           $(NTUSER_PATH)\rtl\client\$(ALT_PROJECT)\$(O)\userrtl.lib   \
           $(WINCORE_PATH)\rtl\client\$(O)\w32crtl.lib \
           $(SDK_LIB_PATH)\uuid.lib

PRIVLIB=$(O)\$(TARGETNAMEP).lib
NTTARGETFILE1=$(PRIVLIB)

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -DUNICODE

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..;..\..\inc;                \
         ..\..\inc\$(ALT_PROJECT);    \
         $(WINCORE_PATH)\w32inc;      \
         $(WINCORE_PATH)\w32inc\$(O); \
         $(ADVCORE_PATH)\ctf\inc;     \
         $(BASE_INC_PATH)
#
NTPROFILEINPUT=yes

NT_UP=0
USE_NTDLL=1
DLLDEF=..\$(TARGETNAME).def
DLLORDER=..\$(TARGETNAME).prf

SOURCES=..\res.rc     \
        ..\context.c  \
        ..\ctxtinfo.c \
        ..\globals.c  \
        ..\hotkey.c   \
        ..\immime.c   \
        ..\imminit.c  \
        ..\layime.c   \
        ..\layout.c   \
        ..\misc.c     \
        ..\regword.c  \
        ..\sftkbdc1.c \
        ..\sftkbdt1.c \
        ..\softkbd.c  \
        ..\input.c    \
        ..\clwinnls.c \
        ..\transsub.c \
        ..\kcodecnv.c \
        ..\jtranmsg.c \
        ..\ktranmsg.c \
        ..\conime.c \
        ..\imemenu.c \
        ..\com.c

UMTYPE=windows

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc $(WINCORE_PATH)\core.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\softkbd.h ===
/**************************************************************************\
* Module Name: softkbd.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Declarations of soft keyboard related data structures and constants
*
* History:
* 02-Dec-1995 wkwok    Ported from Win95
\**************************************************************************/
#ifndef _SOFTKBD_
#define _SOFTKBD_


#define UI_MARGIN               4


// T1 part
#define SKT1_XIN                            3
#define SKT1_YIN                            3
#define SKT1_XOUT                           1
#define SKT1_YOUT                           1
#define SKT1_TOTAL_ROW_NUM                  5
#define SKT1_TOTAL_COLUMN_NUM               15
#define SKT1_ENTER_ROW_NUM                  2
#define SKT1_XOVERLAP                       2

#define SKT1_CONTEXT                        0

enum SKT1_BUTTON_TYPE {
    SKT1_LETTER_TYPE,
    SKT1_BACKSPACE_TYPE,
    SKT1_TAB_TYPE,
    SKT1_CAPS_TYPE,
    SKT1_ENTER_TYPE,
    SKT1_SHIFT_TYPE,
    SKT1_CTRL_TYPE,
    SKT1_ALT_TYPE,
    SKT1_ESC_TYPE,
    SKT1_SPACE_TYPE,
};

#define SKT1_TOTAL_TYPE                     (SKT1_SPACE_TYPE + 1)

#define SKT1_LETTER_WIDTH_TIMES             2
#define SKT1_BACKSPACE_WIDTH_TIMES          2
#define SKT1_TAB_WIDTH_TIMES                3
#define SKT1_CAPS_WIDTH_TIMES               4
#define SKT1_ENTER_WIDTH_TIMES              3
#define SKT1_SHIFT_WIDTH_TIMES              5
#define SKT1_CTRL_WIDTH_TIMES               3
#define SKT1_ALT_WIDTH_TIMES                3
#define SKT1_ESC_WIDTH_TIMES                3
#define SKT1_SPACE_WIDTH_TIMES              12

#define SKT1_LETTER_KEY_NUM                 47
#define SKT1_BACKSPACE_INDEX                (SKT1_LETTER_KEY_NUM)
#define SKT1_BACKSPACE_KEY_NUM              1
#define SKT1_TAB_INDEX                      (SKT1_BACKSPACE_INDEX + SKT1_BACKSPACE_KEY_NUM)
#define SKT1_TAB_KEY_NUM                    1
#define SKT1_CAPS_INDEX                     (SKT1_TAB_INDEX + SKT1_TAB_KEY_NUM)
#define SKT1_CAPS_KEY_NUM                   1
#define SKT1_ENTER_INDEX                    (SKT1_CAPS_INDEX + SKT1_CAPS_KEY_NUM)
#define SKT1_ENTER_KEY_NUM                  1
#define SKT1_SHIFT_INDEX                    (SKT1_ENTER_INDEX + SKT1_ENTER_KEY_NUM)
#define SKT1_SHIFT_KEY_NUM                  2
#define SKT1_CTRL_INDEX                     (SKT1_SHIFT_INDEX + SKT1_SHIFT_KEY_NUM)
#define SKT1_CTRL_KEY_NUM                   2
#define SKT1_ALT_INDEX                      (SKT1_CTRL_INDEX + SKT1_CTRL_KEY_NUM)
#define SKT1_ALT_KEY_NUM                    2
#define SKT1_ESC_INDEX                      (SKT1_ALT_INDEX + SKT1_ALT_KEY_NUM)
#define SKT1_ESC_KEY_NUM                    1
#define SKT1_SPACE_INDEX                    (SKT1_ESC_INDEX + SKT1_ESC_KEY_NUM)
#define SKT1_SPACE_KEY_NUM                  1
#define SKT1_TOTAL_INDEX                    (SKT1_SPACE_INDEX + SKT1_SPACE_KEY_NUM)
#define SKT1_TOTAL_KEY_NUM                  (SKT1_TOTAL_INDEX + 1)

#define SKT1_ROW1_LETTER_NUM                14
#define SKT1_ROW2_LETTER_NUM                12
#define SKT1_ROW3_LETTER_NUM                11
#define SKT1_ROW4_LETTER_NUM                10

#define SKT1_LABEL_BMP_X                    8
#define SKT1_LABEL_BMP_Y                    8

#define SKT1_BACKSPACE_BMP_X                16
#define SKT1_BACKSPACE_BMP_Y                9
#define SKT1_TAB_BMP_X                      16
#define SKT1_TAB_BMP_Y                      9
#define SKT1_CAPS_BMP_X                     22
#define SKT1_CAPS_BMP_Y                     9
#define SKT1_ENTER_BMP_X                    26
#define SKT1_ENTER_BMP_Y                    9
#define SKT1_SHIFT_BMP_X                    23
#define SKT1_SHIFT_BMP_Y                    9
#define SKT1_CTRL_BMP_X                     16
#define SKT1_CTRL_BMP_Y                     9
#define SKT1_ESC_BMP_X                      18
#define SKT1_ESC_BMP_Y                      9
#define SKT1_ALT_BMP_X                      16
#define SKT1_ALT_BMP_Y                      9

#if 0
#define VK_OEM_SEMICLN                  0xba    //  ;    :
#define VK_OEM_EQUAL                    0xbb    //  =    +
#define VK_OEM_COMMA                    0xbc    //  ,    <
#define VK_OEM_MINUS                    0xbd    //  -    _
#define VK_OEM_PERIOD                   0xbe    //  .    >
#define VK_OEM_SLASH                    0xbf    //  /    ?
#define VK_OEM_3                        0xc0    //  `    ~
#define VK_OEM_LBRACKET                 0xdb    //  [    {
#define VK_OEM_BSLASH                   0xdc    //  \    |
#define VK_OEM_RBRACKET                 0xdd    //  ]    }
#define VK_OEM_QUOTE                    0xde    //  '    "
#endif

#define SKT1_NOT_DRAG                   0xFFFFFFFF

typedef struct _tagSKT1CTXT {
    int     nButtonWidth[SKT1_TOTAL_TYPE];
    int     nButtonHeight[2];
    POINT   ptButtonPos[SKT1_TOTAL_KEY_NUM];
    WORD    wCodeTable[SKT1_LETTER_KEY_NUM];
    HBITMAP hSKBitmap;
    UINT    lfCharSet;
    UINT    uKeyIndex;
    POINT   ptSkCursor;
    POINT   ptSkOffset;
    UINT    uSubType;
} SKT1CTXT, *PSKT1CTXT, FAR *LPSKT1CTXT, NEAR *NPSKT1CTXT;

void GetSKT1TextMetric(LPTEXTMETRIC);

LRESULT SKWndProcT1(HWND, UINT, WPARAM, LPARAM);

// T2 part

// C1 part

// button constants
#define ROW_LETTER_C1              4    // number of rows of letter button
#define COL_LETTER_C1             13    // number of column of letter button in first row
#define COL2_LETTER_C1 COL_LETTER_C1    // number of column of letter button in second row
#define COL3_LETTER_C1 (COL2_LETTER_C1 - 2)  // number of column of letter button in third row
#define COL4_LETTER_C1 (COL3_LETTER_C1 - 1)  // number of column of letter button in forth row

#define W_LETTER_C1               20  // width of letter button face
#define H_LETTER_C1               24  // height of letter button face
#define BORDER_C1                  2  // the width/height of button border
#define W_LETTER_BTN_C1     (W_LETTER_C1 + 2 * BORDER_C1)
#define H_LETTER_BTN_C1     (H_LETTER_C1 + 2 * BORDER_C1)

#define H_BOTTOM_C1               20  // the height of bottom button face
#define H_BOTTOM_BTN_C1     (H_BOTTOM_C1 + 2 * BORDER_C1)


// bitmap have the same size
#define W_BACKSP_C1               32  // width of Backspace button face
#define H_BACKSP_C1      H_LETTER_C1  // height of Backspace button face
#define W_TAB_C1                  32  // width of Tab button face
#define H_TAB_C1         H_LETTER_C1  // height of Tab button face
#define W_CAPS_C1                 38  // width of Caps button face
#define H_CAPS_C1        H_LETTER_C1  // height of Caps button face
#define W_ENTER_C1                38  // width of Enter button face
#define H_ENTER_C1       H_LETTER_C1  // height of Enter button face
#define W_SHIFT_C1                56  // width of Shift button face
#define H_SHIFT_C1       H_LETTER_C1  // height of Shift button face
#define W_INS_C1                  34  // width of Ins button face
#define H_INS_C1         H_BOTTOM_C1  // height of Ins button face
#define W_DEL_C1                  34  // width of Del button face
#define H_DEL_C1         H_BOTTOM_C1  // height of Del button face
#define W_SPACE_C1               168  // width of Space button face
#define H_SPACE_C1       H_BOTTOM_C1  // height of Space button face
#define W_ESC_C1                  34  // width of Esc button face
#define H_ESC_C1         H_BOTTOM_C1  // height of Esc button face

#define X_ROW_LETTER_C1            0
#define X_ROW2_LETTER_C1           (W_TAB_C1 + 2 * BORDER_C1)
#define X_ROW3_LETTER_C1           (W_CAPS_C1 + 2 * BORDER_C1)
#define X_ROW4_LETTER_C1           (W_SHIFT_C1 + 2 * BORDER_C1)
#define X_DEL_C1                  58
#define X_ESC_C1                 310

#define LETTER_NUM_C1             47  // number of letter buttons
#define OTHER_NUM_C1               9  // number of other buttons
#define BUTTON_NUM_C1      (LETTER_NUM_C1 + OTHER_NUM_C1) // number of buttons

#define WIDTH_SOFTKBD_C1   (COL_LETTER_C1 * W_LETTER_BTN_C1 \
                            + W_BACKSP_C1 + 2 * BORDER_C1)
#define HEIGHT_SOFTKBD_C1  (ROW_LETTER_C1 * H_LETTER_BTN_C1 + H_BOTTOM_BTN_C1)

#define BACKSP_TYPE_C1     LETTER_NUM_C1
#define TAB_TYPE_C1        (BACKSP_TYPE_C1 + 1)
#define CAPS_TYPE_C1       (BACKSP_TYPE_C1 + 2)
#define ENTER_TYPE_C1      (BACKSP_TYPE_C1 + 3)
#define SHIFT_TYPE_C1      (BACKSP_TYPE_C1 + 4)
#define INS_TYPE_C1        (BACKSP_TYPE_C1 + 5)
#define DEL_TYPE_C1        (BACKSP_TYPE_C1 + 6)
#define SPACE_TYPE_C1      (BACKSP_TYPE_C1 + 7)
#define ESC_TYPE_C1        (BACKSP_TYPE_C1 + 8)

// font constants
#define SIZEFONT_C1               12  // 12 x 12 pixels font
#define SIZELABEL_C1               8  // 8 x 8 button label

#define X_LABEL_C1                 2  // from the button org
#define Y_LABEL_C1                 2
#define X_SHIFT_CHAR_C1           10
#define Y_SHIFT_CHAR_C1            2
#define X_NONSHIFT_CHAR_C1         2
#define Y_NONSHIFT_CHAR_C1        14


// SoftKbd context
#define SKC1_CONTEXT               0

#define FLAG_SHIFT_C1             0x01
#define FLAG_DRAG_C1              0x02
#define FLAG_FOCUS_C1             0x04

typedef struct _tagSKC1CTXT {
     WORD     wShiftCode[LETTER_NUM_C1];
     WORD     wNonShiftCode[LETTER_NUM_C1];
     UINT     uState;
     HBITMAP  hSoftkbd;
     UINT     uSubtype;
     int      uKeyIndex;
     POINT    ptSkCursor;
     POINT    ptSkOffset;
     UINT     lfCharSet;
} SKC1CTXT, *PSKC1CTXT, FAR *LPSKC1CTXT, NEAR *NPSKC1CTXT;

LRESULT SKWndProcC1(HWND, UINT, WPARAM, LPARAM);
VOID SKC1DrawDragBorder(HWND, LPPOINT, LPPOINT);

#endif // _SOFTKBD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\sftkbdt1.c ===
/**************************************************************************\
* Module Name: sftkbdt1.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Soft keyboard support for Traditional Chinese
*
* History:
* 02-Jan-1996 wkwok    - ported from Win95
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#include "softkbd.h"


CONST BYTE bSKT1VirtKey[SKT1_TOTAL_KEY_NUM] = {     // Virtual Key for Letter Buttons
//  `          1    2    3    4    5    6    7    8    9    0
    VK_OEM_3, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
//  -             =             \\                line 1 letter above
    VK_OEM_MINUS, VK_OEM_EQUAL, VK_OEM_BSLASH,
//   q    w    e    r    t    y    u    i    o    p
    'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P',
//  [                ]                            line 2 letter above
    VK_OEM_LBRACKET, VK_OEM_RBRACKET,
//   a    s    d    f    g    h    j    k    l
    'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L',
//   ;               '                            line 3 letter above
    VK_OEM_SEMICLN, VK_OEM_QUOTE,
//   z    x    c    v    b    n    m
    'Z', 'X', 'C', 'V', 'B', 'N', 'M',
//  ,              .              /               line 4 letter above
    VK_OEM_COMMA,  VK_OEM_PERIOD, VK_OEM_SLASH,
//  <-       tab     caps        enter
    VK_BACK, VK_TAB, VK_CAPITAL, VK_RETURN,
//  shift1    shift2    ctrl1       ctrl2
    VK_SHIFT, VK_SHIFT, VK_CONTROL, VK_CONTROL,
//  alt1     alt2     esc        space            special key above
    VK_MENU, VK_MENU, VK_ESCAPE, VK_SPACE
};


LOGFONT lfSKT1Font;


/**********************************************************************/
/* GetSKT1TextMetric                                                  */
/**********************************************************************/

void GetSKT1TextMetric(
     LPTEXTMETRIC   lptm)
{
    HDC     hDC;
    HFONT   hOldFont;
    SIZE    szDbcs;
    const WCHAR wcDbcs = 0x4e11;

    hDC = GetDC((HWND)NULL);

    // get the 9 pixels font
    RtlZeroMemory(&lfSKT1Font, sizeof lfSKT1Font);
    lfSKT1Font.lfHeight = -12;
    lfSKT1Font.lfWeight = FW_NORMAL;

    lfSKT1Font.lfCharSet = CHINESEBIG5_CHARSET;

    lfSKT1Font.lfOutPrecision = OUT_TT_ONLY_PRECIS;
    lfSKT1Font.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lfSKT1Font.lfQuality = PROOF_QUALITY;
    lfSKT1Font.lfPitchAndFamily = FIXED_PITCH|FF_MODERN;

    hOldFont = (HFONT)SelectObject(hDC, CreateFontIndirect(&lfSKT1Font));

    GetTextMetrics(hDC, lptm);

    /*
     * NT5: Dirty hack for "Lucida Console" which was "font linked" on NT5, and
     * GetTextMetrics API does not return correct text metrics.
     */
    if (GetTextExtentPoint32(hDC, &wcDbcs, 1, &szDbcs) && lptm->tmMaxCharWidth < szDbcs.cx) {
        TAGMSG2(DBGTAG_IMM, "GetSKT1TextMetric: tmMaxCharWidth(%d) is smaller than real width(%d).",
                lptm->tmMaxCharWidth, szDbcs.cx);
        lptm->tmMaxCharWidth = szDbcs.cx;
    }

    DeleteObject(SelectObject(hDC, hOldFont));

    ReleaseDC((HWND)NULL, hDC);

    return;
}

/**********************************************************************/
/* InitSKT1ButtonPos                                                  */
/**********************************************************************/
void InitSKT1ButtonPos(
    LPSKT1CTXT lpSKT1Ctxt)
{
    TEXTMETRIC  tm;
    int         nButtonWidthUnit, nButtonHeightUnit;
    int         i, nLetterButtonStart, nLetterButtonEnd, xStartPos, yStartPos;

    GetSKT1TextMetric(&tm);

    nButtonWidthUnit = tm.tmMaxCharWidth + SKT1_LABEL_BMP_X - SKT1_XOVERLAP;

#define INIT_WIDTH(name, width) \
            lpSKT1Ctxt->nButtonWidth[SKT1_ ## name ## _TYPE] = (width)

    INIT_WIDTH(LETTER,      nButtonWidthUnit * SKT1_LETTER_WIDTH_TIMES / 2);
    INIT_WIDTH(BACKSPACE,   nButtonWidthUnit * SKT1_BACKSPACE_WIDTH_TIMES / 2 + 1);
    INIT_WIDTH(TAB,         nButtonWidthUnit * SKT1_TAB_WIDTH_TIMES / 2 + (SKT1_XIN + 1) / 2);
    INIT_WIDTH(CAPS,        nButtonWidthUnit * SKT1_CAPS_WIDTH_TIMES / 2 + SKT1_XIN);
    INIT_WIDTH(ENTER,       nButtonWidthUnit * SKT1_ENTER_WIDTH_TIMES / 2 + (SKT1_XIN + 1) / 2);
    INIT_WIDTH(SHIFT,       nButtonWidthUnit * SKT1_SHIFT_WIDTH_TIMES / 2 + SKT1_XIN + (SKT1_XIN + 1) / 2);
    INIT_WIDTH(CTRL,        nButtonWidthUnit * SKT1_CTRL_WIDTH_TIMES / 2 + (SKT1_XIN + 1) / 2);
    INIT_WIDTH(ALT,         nButtonWidthUnit * SKT1_ALT_WIDTH_TIMES / 2 + (SKT1_XIN + 1) / 2);
    INIT_WIDTH(ESC,         nButtonWidthUnit * SKT1_ESC_WIDTH_TIMES / 2 + SKT1_XIN / 2);
    INIT_WIDTH(SPACE,       nButtonWidthUnit * SKT1_SPACE_WIDTH_TIMES / 2 + SKT1_XIN * 5);

#undef INIT_WIDTH

    nButtonHeightUnit = tm.tmHeight + SKT1_LABEL_BMP_Y;
    lpSKT1Ctxt->nButtonHeight[0] = nButtonHeightUnit;
    lpSKT1Ctxt->nButtonHeight[1] = nButtonHeightUnit * 2 + SKT1_YIN; // enter

    // init first row attribute
    xStartPos = gptRaiseEdge.x + SKT1_XOUT + (SKT1_XIN + 1) / 2;
    yStartPos = gptRaiseEdge.y + SKT1_YOUT + (SKT1_YIN + 1) / 2;

    nLetterButtonStart = 0;
    nLetterButtonEnd = nLetterButtonStart + SKT1_ROW1_LETTER_NUM;

    for (i = nLetterButtonStart; i < nLetterButtonEnd; i++) {
        lpSKT1Ctxt->ptButtonPos[i].x = xStartPos;
        lpSKT1Ctxt->ptButtonPos[i].y = yStartPos;
        xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_LETTER_TYPE] + SKT1_XIN);
    }
    // backspace
    lpSKT1Ctxt->ptButtonPos[SKT1_BACKSPACE_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_BACKSPACE_INDEX].y = yStartPos;

    // init second row attribute
    xStartPos = gptRaiseEdge.x + SKT1_XOUT + (SKT1_XIN + 1) / 2;
    yStartPos += (nButtonHeightUnit + SKT1_YIN);
    // tab
    lpSKT1Ctxt->ptButtonPos[SKT1_TAB_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_TAB_INDEX].y = yStartPos;
    xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_TAB_TYPE] + SKT1_XIN);
    // letter
    nLetterButtonStart = nLetterButtonEnd;
    nLetterButtonEnd = nLetterButtonStart + SKT1_ROW2_LETTER_NUM;
    for (i = nLetterButtonStart; i < nLetterButtonEnd; i++) {
        lpSKT1Ctxt->ptButtonPos[i].x = xStartPos;
        lpSKT1Ctxt->ptButtonPos[i].y = yStartPos;
        xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_LETTER_TYPE] + SKT1_XIN);
    }
    // enter
    lpSKT1Ctxt->ptButtonPos[SKT1_ENTER_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_ENTER_INDEX].y = yStartPos;

    // init third row
    xStartPos = gptRaiseEdge.x + SKT1_XOUT + (SKT1_XIN + 1) / 2;
    yStartPos += (nButtonHeightUnit + SKT1_YIN);
    // caps
    lpSKT1Ctxt->ptButtonPos[SKT1_CAPS_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_CAPS_INDEX].y = yStartPos;
    xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_CAPS_TYPE] + SKT1_XIN);
    // letter
    nLetterButtonStart = nLetterButtonEnd;
    nLetterButtonEnd = nLetterButtonStart + SKT1_ROW3_LETTER_NUM;
    for (i = nLetterButtonStart; i < nLetterButtonEnd; i++) {
        lpSKT1Ctxt->ptButtonPos[i].x = xStartPos;
        lpSKT1Ctxt->ptButtonPos[i].y = yStartPos;
        xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_LETTER_TYPE] + SKT1_XIN);
    }

    // init fourth row
    xStartPos = gptRaiseEdge.x + SKT1_XOUT + (SKT1_XIN + 1) / 2;
    yStartPos += (nButtonHeightUnit + SKT1_YIN);
    // shift 1
    lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX].y = yStartPos;
    xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_SHIFT_TYPE] + SKT1_XIN);
    // letter
    nLetterButtonStart = nLetterButtonEnd;
    nLetterButtonEnd = nLetterButtonStart + SKT1_ROW4_LETTER_NUM;
    for (i = nLetterButtonStart; i < nLetterButtonEnd; i++) {
        lpSKT1Ctxt->ptButtonPos[i].x = xStartPos;
        lpSKT1Ctxt->ptButtonPos[i].y = yStartPos;
        xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_LETTER_TYPE] + SKT1_XIN);
    }
    // shift 2
    lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX + 1].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX + 1].y = yStartPos;

    // init fifth row
    xStartPos = gptRaiseEdge.x + SKT1_XOUT + (SKT1_XIN + 1) / 2;
    yStartPos += (nButtonHeightUnit + SKT1_YIN);
    // ctrl 1
    lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX].y = yStartPos;
    xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_CTRL_TYPE] + SKT1_XIN);
    // esc
    lpSKT1Ctxt->ptButtonPos[SKT1_ESC_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_ESC_INDEX].y = yStartPos;
    xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_ESC_TYPE] + SKT1_XIN);
    // alt 1
    lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX].y = yStartPos;
    xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_ALT_TYPE] + SKT1_XIN);
    // space
    lpSKT1Ctxt->ptButtonPos[SKT1_SPACE_INDEX].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_SPACE_INDEX].y = yStartPos;
    xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_SPACE_TYPE] + SKT1_XIN);
    // alt 2 .. skip blank
    lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX + 1].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX + 1].y = yStartPos;
    xStartPos += (lpSKT1Ctxt->nButtonWidth[SKT1_ALT_TYPE] + SKT1_XIN) +
        (lpSKT1Ctxt->nButtonWidth[SKT1_ESC_TYPE] + SKT1_XIN);
    // ctrl 2
    lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX + 1].x = xStartPos;
    lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX + 1].y = yStartPos;

    return;
}

/**********************************************************************/
/* SKT1DrawConvexRect                                                 */
/*     draw a convex rectangle                                        */
/*              (x,y)     x+nWidth+1                                  */
/*               +-----1------+                                       */
/*               |+----2-----||                                       */
/*               ||          ||                                       */
/*               ||          3|                                       */
/*               ||          ||                                       */
/*               |V          || <---- Rectangle                       */
/*               |<----------+|                                       */
/*  y+nHeight+1  +------------+                                       */
/*  1 - black                                                         */
/*  2 - while                                                         */
/*  3 - dark gray                                                     */
/**********************************************************************/
void SKT1DrawConvexRect(
    HDC hDC,
    int x,
    int y,
    int nWidth,
    int nHeight)
{
    // extend the context rect size
    x -= (SKT1_XIN + 1) / 2;
    y -= (SKT1_YIN + 1) / 2;
    nWidth += (SKT1_XIN + 1);
    nHeight += (SKT1_XIN + 1);

    // 1
    SelectObject(hDC, GetStockObject(BLACK_PEN));
    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));
    Rectangle(hDC, x, y, x + nWidth, y + nHeight);
    PatBlt(hDC, x, y, 1, 1, PATCOPY);
    PatBlt(hDC, x + nWidth, y, -1, 1, PATCOPY);
    PatBlt(hDC, x, y + nHeight, 1, -1, PATCOPY);
    PatBlt(hDC, x + nWidth, y + nHeight, -1, -1, PATCOPY);

    x++;
    y++;
    nWidth -= 2;
    nHeight -= 2;

    // 2
    PatBlt(hDC, x, y + nHeight, 1, -nHeight, WHITENESS);
    PatBlt(hDC, x, y, nWidth , 1, WHITENESS);
    // 3
    SelectObject(hDC, GetStockObject(GRAY_BRUSH));
    PatBlt(hDC, x, y + nHeight, nWidth, -1, PATCOPY);
    PatBlt(hDC, x + nWidth, y + nHeight, -1, -nHeight, PATCOPY);

    return;
}

/**********************************************************************/
/* SKT1DrawBitmap                                                     */
/**********************************************************************/
void SKT1DrawBitmap(
    HDC hDC,
    int x,
    int y,
    int nWidth,
    int nHeight,
    LPCWSTR lpszBitmap)
{
    HDC     hMemDC;
    HBITMAP hBitmap, hOldBmp;

    hBitmap = (HBITMAP)LoadBitmap(ghInst, lpszBitmap);

    hMemDC = CreateCompatibleDC(hDC);

    hOldBmp = (HBITMAP)SelectObject(hMemDC, hBitmap);

    BitBlt(hDC, x, y, nWidth, nHeight, hMemDC, 0 , 0, SRCCOPY);

    SelectObject(hMemDC, hOldBmp);

    DeleteObject(hBitmap);

    DeleteDC(hMemDC);

    return;
}

/**********************************************************************/
/* SKT1DrawLabel                                                      */
/**********************************************************************/
void SKT1DrawLabel(
    HDC        hDC,
    LPSKT1CTXT lpSKT1Ctxt,
    LPCWSTR     lpszLabel)
{
    HDC     hMemDC;
    HBITMAP hBitmap, hOldBmp;
    int     i;

    hBitmap = LoadBitmap(ghInst, lpszLabel);
    hMemDC = CreateCompatibleDC(hDC);
    hOldBmp = (HBITMAP)SelectObject(hMemDC, hBitmap);

    for (i = 0; i < SKT1_LETTER_KEY_NUM; i++) {
        BitBlt(hDC,
            lpSKT1Ctxt->ptButtonPos[i].x, lpSKT1Ctxt->ptButtonPos[i].y,
            SKT1_LABEL_BMP_X, SKT1_LABEL_BMP_Y,
            hMemDC, i * SKT1_LABEL_BMP_X, 0, SRCCOPY);
    }

    SelectObject(hMemDC, hOldBmp);
    DeleteDC(hMemDC);
    DeleteObject(hBitmap);

    return;
}


/**********************************************************************/
/* InitSKT1Bitmap                                                     */
/**********************************************************************/
void InitSKT1Bitmap(
    HWND hSKWnd,
    LPSKT1CTXT lpSKT1Ctxt)
{
    HDC  hDC, hMemDC;
    RECT rcClient;
    int  i;

    hDC = GetDC(hSKWnd);
    hMemDC = CreateCompatibleDC(hDC);
    GetClientRect(hSKWnd, &rcClient);
    lpSKT1Ctxt->hSKBitmap = CreateCompatibleBitmap(hDC,
        rcClient.right - rcClient.left,
        rcClient.bottom - rcClient.top);
    ReleaseDC(hSKWnd, hDC);
    SelectObject(hMemDC, lpSKT1Ctxt->hSKBitmap);

    // draw SK rectangle
    SelectObject(hMemDC, GetStockObject(NULL_PEN));
    SelectObject(hMemDC, GetStockObject(LTGRAY_BRUSH));
    Rectangle(hMemDC, rcClient.left, rcClient.top,
        rcClient.right + 1, rcClient.bottom + 1);

    DrawEdge(hMemDC, &rcClient, BDR_RAISED, BF_RECT);

    // draw the button from the last line
    // ctrl 1   -> line 5 special key
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_CTRL_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_CTRL_TYPE] / 2 - SKT1_CTRL_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_CTRL_BMP_Y / 2,
        SKT1_CTRL_BMP_X,
        SKT1_CTRL_BMP_Y,
        MAKEINTRESOURCEW(CTRL_T1));

    // ctrl 2
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX + 1].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX + 1].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_CTRL_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX + 1].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_CTRL_TYPE] / 2 - SKT1_CTRL_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX + 1].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_CTRL_BMP_Y / 2,
        SKT1_CTRL_BMP_X, SKT1_CTRL_BMP_Y,
        MAKEINTRESOURCEW(CTRL_T1));

    // esc
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_ESC_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_ESC_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_ESC_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_ESC_INDEX].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_ESC_TYPE] / 2 - SKT1_ESC_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_ESC_INDEX].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_ESC_BMP_Y / 2,
        SKT1_ESC_BMP_X, SKT1_ESC_BMP_Y,
        MAKEINTRESOURCEW(ESC_T1));

    // alt 1
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_ALT_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_ALT_TYPE] / 2 - SKT1_ALT_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_ALT_BMP_Y / 2,
        SKT1_ALT_BMP_X, SKT1_ALT_BMP_Y,
        MAKEINTRESOURCEW(ALT_T1));

    // alt 2
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX + 1].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX + 1].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_ALT_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX + 1].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_ALT_TYPE] / 2 - SKT1_ALT_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX + 1].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_ALT_BMP_Y / 2,
        SKT1_ALT_BMP_X, SKT1_ALT_BMP_Y,
        MAKEINTRESOURCEW(ALT_T1));

    // space
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_SPACE_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_SPACE_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_SPACE_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);

    // line 4
    // shift 1
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_SHIFT_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_SHIFT_TYPE] / 2 - SKT1_SHIFT_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_SHIFT_BMP_Y / 2,
        SKT1_SHIFT_BMP_X, SKT1_SHIFT_BMP_Y,
        MAKEINTRESOURCEW(SHIFT_T1));

    // shift 2
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX + 1].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX + 1].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_SHIFT_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX + 1].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_SHIFT_TYPE] / 2 - SKT1_SHIFT_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX + 1].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_SHIFT_BMP_Y / 2,
        SKT1_SHIFT_BMP_X, SKT1_SHIFT_BMP_Y,
        MAKEINTRESOURCEW(SHIFT_T1));

    // line 3
    // caps
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_CAPS_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_CAPS_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_CAPS_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_CAPS_INDEX].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_CAPS_TYPE] / 2 - SKT1_CAPS_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_CAPS_INDEX].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_CAPS_BMP_Y / 2,
        SKT1_CAPS_BMP_X, SKT1_CAPS_BMP_Y,
        MAKEINTRESOURCEW(CAPS_T1));

    // line 2
    // tab
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_TAB_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_TAB_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_TAB_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_TAB_INDEX].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_TAB_TYPE] / 2 - SKT1_TAB_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_TAB_INDEX].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_TAB_BMP_Y / 2,
        SKT1_TAB_BMP_X, SKT1_TAB_BMP_Y,
        MAKEINTRESOURCEW(TAB_T1));

    // enter
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_ENTER_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_ENTER_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_ENTER_TYPE],
        lpSKT1Ctxt->nButtonHeight[1]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_ENTER_INDEX].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_ENTER_TYPE] / 2 - SKT1_ENTER_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_ENTER_INDEX].y +
        lpSKT1Ctxt->nButtonHeight[1] / 2 - SKT1_ENTER_BMP_Y / 2,
        SKT1_ENTER_BMP_X, SKT1_ENTER_BMP_Y,
        MAKEINTRESOURCEW(ENTER_T1));

    // line 1
    // backspace
    SKT1DrawConvexRect(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_BACKSPACE_INDEX].x,
        lpSKT1Ctxt->ptButtonPos[SKT1_BACKSPACE_INDEX].y,
        lpSKT1Ctxt->nButtonWidth[SKT1_BACKSPACE_TYPE],
        lpSKT1Ctxt->nButtonHeight[0]);
    SKT1DrawBitmap(hMemDC,
        lpSKT1Ctxt->ptButtonPos[SKT1_BACKSPACE_INDEX].x +
        lpSKT1Ctxt->nButtonWidth[SKT1_BACKSPACE_TYPE] / 2 - SKT1_BACKSPACE_BMP_X / 2,
        lpSKT1Ctxt->ptButtonPos[SKT1_BACKSPACE_INDEX].y +
        lpSKT1Ctxt->nButtonHeight[0] / 2 - SKT1_BACKSPACE_BMP_Y / 2,
        SKT1_BACKSPACE_BMP_X, SKT1_BACKSPACE_BMP_Y,
        MAKEINTRESOURCEW(BACK_T1));

    // draw letter buttons
    for (i = SKT1_LETTER_KEY_NUM - 1; i >= 0 ; i--) {
        SKT1DrawConvexRect(hMemDC,
            lpSKT1Ctxt->ptButtonPos[i].x,
            lpSKT1Ctxt->ptButtonPos[i].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_LETTER_TYPE],
            lpSKT1Ctxt->nButtonHeight[0]);
    }

    // draw latter label
    SKT1DrawLabel(hMemDC, lpSKT1Ctxt, MAKEINTRESOURCEW(LABEL_T1));

    DeleteDC(hMemDC);

    return;
}


/**********************************************************************/
/* CreateT1Window                                                     */
/**********************************************************************/
LRESULT CreateT1Window(
    HWND hSKWnd)
{
    HGLOBAL    hSKT1Ctxt;
    LPSKT1CTXT lpSKT1Ctxt;

    hSKT1Ctxt = GlobalAlloc(GHND, sizeof(SKT1CTXT));
    if (!hSKT1Ctxt) {
        return (-1);
    }

    lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
    if (!lpSKT1Ctxt) {
        GlobalFree(hSKT1Ctxt);
        return (-1);
    }

    SetWindowLongPtr(hSKWnd, SKT1_CONTEXT, (LONG_PTR)hSKT1Ctxt);

    lpSKT1Ctxt->uKeyIndex = SKT1_TOTAL_INDEX;
    lpSKT1Ctxt->ptSkOffset.x = SKT1_NOT_DRAG;
    lpSKT1Ctxt->ptSkOffset.y = SKT1_NOT_DRAG;
    lpSKT1Ctxt->lfCharSet = CHINESEBIG5_CHARSET;

    InitSKT1ButtonPos(lpSKT1Ctxt);

    InitSKT1Bitmap(hSKWnd, lpSKT1Ctxt);

    GlobalUnlock(hSKT1Ctxt);

    return (0L);
}

/**********************************************************************/
/* SKT1DrawDragBorder()                                               */
/**********************************************************************/
void SKT1DrawDragBorder(
    HWND    hWnd,               // window of IME is dragged
    LPPOINT lpptCursor,         // the cursor position
    LPPOINT lpptOffset)         // the offset form cursor to window org
{
    HDC  hDC;
    int  cxBorder, cyBorder;
    int  x, y;
    RECT rcWnd;

    cxBorder = GetSystemMetrics(SM_CXBORDER);   // width of border
    cyBorder = GetSystemMetrics(SM_CYBORDER);   // height of border

    x = lpptCursor->x - lpptOffset->x;
    y = lpptCursor->y - lpptOffset->y;

    // check for the max boundary of the display
    GetWindowRect(hWnd, &rcWnd);

    // draw the moving track
    hDC = CreateDC(L"DISPLAY", NULL, NULL, NULL);
    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    // ->
    PatBlt(hDC, x, y, rcWnd.right - rcWnd.left - cxBorder, cyBorder,
        PATINVERT);
    // v
    PatBlt(hDC, x, y + cyBorder, cxBorder, rcWnd.bottom - rcWnd.top -
        cyBorder, PATINVERT);
    // _>
    PatBlt(hDC, x + cxBorder, y + rcWnd.bottom - rcWnd.top,
        rcWnd.right - rcWnd.left - cxBorder, -cyBorder, PATINVERT);
    //  v
    PatBlt(hDC, x + rcWnd.right - rcWnd.left, y,
        - cxBorder, rcWnd.bottom - rcWnd.top - cyBorder, PATINVERT);

    DeleteDC(hDC);
    return;
}

/**********************************************************************/
/* DestroyT1Window                                                    */
/**********************************************************************/
void DestroyT1Window(
    HWND hSKWnd)
{
    HGLOBAL    hSKT1Ctxt;
    LPSKT1CTXT lpSKT1Ctxt;
    HWND       hUIWnd;

    hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKT1_CONTEXT);
    if (!hSKT1Ctxt) {
        return;
    }

    lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
    if (!lpSKT1Ctxt) {
        return;
    }

    if (lpSKT1Ctxt->ptSkOffset.x != SKT1_NOT_DRAG &&
            lpSKT1Ctxt->ptSkOffset.y != SKT1_NOT_DRAG) {
        SKT1DrawDragBorder(hSKWnd, &lpSKT1Ctxt->ptSkCursor,
            &lpSKT1Ctxt->ptSkOffset);
    }

    DeleteObject(lpSKT1Ctxt->hSKBitmap);

    GlobalUnlock(hSKT1Ctxt);
    GlobalFree(hSKT1Ctxt);

    hUIWnd = GetWindow(hSKWnd, GW_OWNER);
    if (!hUIWnd) {
        return;
    }

    SendMessage(hUIWnd, WM_IME_NOTIFY, IMN_SOFTKBDDESTROYED, 0);

    return;
}

/**********************************************************************/
/* SKT1InvertButton                                                   */
/**********************************************************************/
void SKT1InvertButton(
    HWND       hSKWnd,
    HDC        hPaintDC,
    LPSKT1CTXT lpSKT1Ctxt,
    UINT       uKeyIndex)
{
    HDC hDC;
    int nWidth, nHeight;

    if (uKeyIndex >= SKT1_TOTAL_INDEX) {
        return;
    }

    nWidth = 0;
    if (hPaintDC) {
        hDC = hPaintDC;
    } else {
        hDC = GetDC(hSKWnd);
    }

    if (uKeyIndex < SKT1_LETTER_KEY_NUM) {
        nWidth = lpSKT1Ctxt->nButtonWidth[SKT1_LETTER_TYPE];
    } else {
        switch (uKeyIndex) {
        case SKT1_BACKSPACE_INDEX:
            nWidth = lpSKT1Ctxt->nButtonWidth[SKT1_BACKSPACE_TYPE];
            break;
        case SKT1_TAB_INDEX:
            nWidth = lpSKT1Ctxt->nButtonWidth[SKT1_TAB_TYPE];
            break;
        case SKT1_CAPS_INDEX:
            nWidth = 0;
            MessageBeep((UINT) -1);
            break;
        case SKT1_ENTER_INDEX:
            nWidth = lpSKT1Ctxt->nButtonWidth[SKT1_ENTER_TYPE];
            break;
        case SKT1_SHIFT_INDEX:
        case SKT1_SHIFT_INDEX + 1:
        case SKT1_CTRL_INDEX:
        case SKT1_CTRL_INDEX + 1:
        case SKT1_ALT_INDEX:
        case SKT1_ALT_INDEX + 1:
            nWidth = 0;
            MessageBeep((UINT) -1);
            break;
        case SKT1_ESC_INDEX:
            nWidth = lpSKT1Ctxt->nButtonWidth[SKT1_ESC_TYPE];
            break;
        case SKT1_SPACE_INDEX:
            nWidth = lpSKT1Ctxt->nButtonWidth[SKT1_SPACE_TYPE];
            break;
        default:
            break;
        }
    }

    if (uKeyIndex == SKT1_ENTER_INDEX) {
        nHeight = lpSKT1Ctxt->nButtonHeight[1];
    } else {
        nHeight = lpSKT1Ctxt->nButtonHeight[0];
    }

    if (nWidth) {
        // do not reverse border
        PatBlt(hDC, lpSKT1Ctxt->ptButtonPos[uKeyIndex].x - 1,
            lpSKT1Ctxt->ptButtonPos[uKeyIndex].y - 1,
            nWidth + 2, nHeight + 2, DSTINVERT);
    }

    if (!hPaintDC) {
        ReleaseDC(hSKWnd, hDC);
    }

    return;
}

/**********************************************************************/
/* UpdateSKT1Window                                                   */
/**********************************************************************/
void UpdateSKT1Window(
    HDC  hDC,
    HWND hSKWnd)
{
    HGLOBAL    hSKT1Ctxt;
    LPSKT1CTXT lpSKT1Ctxt;
    HDC        hMemDC;
    RECT       rcClient;

    hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKT1_CONTEXT);
    if (!hSKT1Ctxt) {
        return;
    }

    lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
    if (!lpSKT1Ctxt) {
        return;
    }

    hMemDC = CreateCompatibleDC(hDC);

    SelectObject(hMemDC, lpSKT1Ctxt->hSKBitmap);

    GetClientRect(hSKWnd, &rcClient);

    BitBlt(hDC, 0, 0, rcClient.right - rcClient.left,
        rcClient.bottom - rcClient.top,
        hMemDC, 0, 0, SRCCOPY);

    DeleteDC(hMemDC);

    if (lpSKT1Ctxt->uKeyIndex < SKT1_TOTAL_INDEX) {
        SKT1InvertButton(hSKWnd, hDC, lpSKT1Ctxt, lpSKT1Ctxt->uKeyIndex);
    }

    GlobalUnlock(hSKT1Ctxt);

    return;
}

/**********************************************************************/
/* SKT1MousePosition()                                                */
/**********************************************************************/
UINT SKT1MousePosition(
    LPSKT1CTXT lpSKT1Ctxt,
    LPPOINT    lpptCursor)
{
    int   i;

    // check letter button
    for (i = 0; i < SKT1_LETTER_KEY_NUM; i++) {
        if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[i].x,
                lpSKT1Ctxt->ptButtonPos[i].y,
                lpSKT1Ctxt->nButtonWidth[SKT1_LETTER_TYPE],
                lpSKT1Ctxt->nButtonHeight[0],
                lpptCursor)) {
            return i;
        }
    }

    // backSapce
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_BACKSPACE_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_BACKSPACE_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_BACKSPACE_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_BACKSPACE_INDEX;
    }

    // tab
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_TAB_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_TAB_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_TAB_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_TAB_INDEX;
    }

    // caps
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_CAPS_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_CAPS_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_CAPS_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_CAPS_INDEX;
    }

    // enter
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_ENTER_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_ENTER_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_ENTER_TYPE],
            lpSKT1Ctxt->nButtonHeight[1],
            lpptCursor)) {
        return SKT1_ENTER_INDEX;
    }

    // shift 1
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_SHIFT_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_SHIFT_INDEX;
    }

    // shift 2
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX + 1].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_SHIFT_INDEX + 1].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_SHIFT_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_SHIFT_INDEX;
    }

    // ctrl 1
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_CTRL_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_CTRL_INDEX;
    }

    // ctrl 2
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX + 1].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_CTRL_INDEX + 1].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_CTRL_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_CTRL_INDEX;
    }

    // alt 1
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_ALT_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_ALT_INDEX;
    }

    // alt 2
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX + 1].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_ALT_INDEX + 1].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_ALT_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_ALT_INDEX;
    }

    // esc
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_ESC_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_ESC_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_ESC_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_ESC_INDEX;
    }

    // space
    if (ImmPtInRect(lpSKT1Ctxt->ptButtonPos[SKT1_SPACE_INDEX].x,
            lpSKT1Ctxt->ptButtonPos[SKT1_SPACE_INDEX].y,
            lpSKT1Ctxt->nButtonWidth[SKT1_SPACE_TYPE],
            lpSKT1Ctxt->nButtonHeight[0],
            lpptCursor)) {
        return SKT1_SPACE_INDEX;
    }

    return SKT1_TOTAL_INDEX;      // This means out of range
}

/**********************************************************************/
/* SKT1IsValidButton                                                  */
/**********************************************************************/
BOOL SKT1IsValidButton(
    UINT       uKeyIndex,
    LPSKT1CTXT lpSKT1Ctxt)
{
    BOOL fRet;

    if (uKeyIndex < SKT1_LETTER_KEY_NUM) {
        if (lpSKT1Ctxt->wCodeTable[uKeyIndex]) {
            return TRUE;
        } else {
            return FALSE;
        }
    }

    // special key
    switch (uKeyIndex) {
    case SKT1_BACKSPACE_INDEX:
    case SKT1_TAB_INDEX:
    case SKT1_ENTER_INDEX:
    case SKT1_ESC_INDEX:
    case SKT1_SPACE_INDEX:
        fRet = TRUE;
        break;
    default:
        fRet = FALSE;
        break;
    }

    return fRet;
}

/**********************************************************************/
/* SKT1SetCursor                                                      */
/**********************************************************************/
BOOL SKT1SetCursor(
    HWND   hSKWnd,
    LPARAM lParam)
{
    HGLOBAL    hSKT1Ctxt;
    LPSKT1CTXT lpSKT1Ctxt;
    UINT       uKeyIndex;
    RECT       rcWnd;
    RECT       rcWork;
    SIZE       szWork;
    extern     void GetAllMonitorSize(LPRECT lprc);

    hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKT1_CONTEXT);
    if (!hSKT1Ctxt) {
        return (FALSE);
    }

    lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
    if (!lpSKT1Ctxt) {
        return (FALSE);
    }

    if (lpSKT1Ctxt->ptSkOffset.x != SKT1_NOT_DRAG &&
            lpSKT1Ctxt->ptSkOffset.y != SKT1_NOT_DRAG) {
        // in drag operation
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        goto UnlockSKT1Ctxt;
    }

    GetCursorPos(&lpSKT1Ctxt->ptSkCursor);
    ScreenToClient(hSKWnd, &lpSKT1Ctxt->ptSkCursor);

    uKeyIndex = SKT1MousePosition(lpSKT1Ctxt, &lpSKT1Ctxt->ptSkCursor);

    if (uKeyIndex < SKT1_TOTAL_INDEX) {
        SetCursor(LoadCursor(NULL, IDC_HAND));
    } else {
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
    }


    if (HIWORD(lParam) != WM_LBUTTONDOWN) {
        goto UnlockSKT1Ctxt;
    }

    SetCapture(hSKWnd);

    if (lpSKT1Ctxt->uKeyIndex < SKT1_TOTAL_INDEX) {
        UINT uVirtKey;

        uVirtKey = bSKT1VirtKey[lpSKT1Ctxt->uKeyIndex];
        keybd_event((BYTE)uVirtKey, (BYTE)guScanCode[uVirtKey],
            (DWORD)KEYEVENTF_KEYUP, 0);
        SKT1InvertButton(hSKWnd, NULL, lpSKT1Ctxt, lpSKT1Ctxt->uKeyIndex);
        lpSKT1Ctxt->uKeyIndex = SKT1_TOTAL_INDEX;
    }

    if (uKeyIndex < SKT1_TOTAL_INDEX) {
        UINT uVirtKey;

        if (SKT1IsValidButton(uKeyIndex, lpSKT1Ctxt)) {
            uVirtKey = bSKT1VirtKey[uKeyIndex];
            keybd_event((BYTE)uVirtKey, (BYTE)guScanCode[uVirtKey],
                0, 0);
            lpSKT1Ctxt->uKeyIndex = uKeyIndex;
            SKT1InvertButton(hSKWnd, NULL, lpSKT1Ctxt, lpSKT1Ctxt->uKeyIndex);
        } else {
            MessageBeep((UINT)-1);
        }
        goto UnlockSKT1Ctxt;
    }

    GetAllMonitorSize(&rcWork);
    szWork.cx = rcWork.right - rcWork.left;
    szWork.cy = rcWork.bottom - rcWork.top;

    GetCursorPos(&lpSKT1Ctxt->ptSkCursor);
    GetWindowRect(hSKWnd, &rcWnd);
    lpSKT1Ctxt->ptSkOffset.x = lpSKT1Ctxt->ptSkCursor.x - rcWnd.left;
    lpSKT1Ctxt->ptSkOffset.y = lpSKT1Ctxt->ptSkCursor.y - rcWnd.top;

    SKT1DrawDragBorder(hSKWnd, &lpSKT1Ctxt->ptSkCursor,
        &lpSKT1Ctxt->ptSkOffset);

UnlockSKT1Ctxt:
    GlobalUnlock(hSKT1Ctxt);

    return (TRUE);
}

/**********************************************************************/
/* SKT1MouseMove                                                      */
/**********************************************************************/
BOOL SKT1MouseMove(
    HWND hSKWnd)
{
    HGLOBAL    hSKT1Ctxt;
    LPSKT1CTXT lpSKT1Ctxt;

    hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKT1_CONTEXT);
    if (!hSKT1Ctxt) {
        return FALSE;
    }

    lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
    if (!lpSKT1Ctxt) {
        return FALSE;
    }

    if (lpSKT1Ctxt->ptSkOffset.x == SKT1_NOT_DRAG ||
            lpSKT1Ctxt->ptSkOffset.y == SKT1_NOT_DRAG) {
        GlobalUnlock(hSKT1Ctxt);
        return FALSE;
    }

    SKT1DrawDragBorder(hSKWnd, &lpSKT1Ctxt->ptSkCursor,
        &lpSKT1Ctxt->ptSkOffset);

    GetCursorPos(&lpSKT1Ctxt->ptSkCursor);

    SKT1DrawDragBorder(hSKWnd, &lpSKT1Ctxt->ptSkCursor,
        &lpSKT1Ctxt->ptSkOffset);

    GlobalUnlock(hSKT1Ctxt);

    return TRUE;
}

/**********************************************************************/
/* SKT1ButtonUp                                                       */
/**********************************************************************/
BOOL SKT1ButtonUp(
    HWND hSKWnd)
{
    HGLOBAL        hSKT1Ctxt;
    LPSKT1CTXT     lpSKT1Ctxt;
    BOOL           fRet;
    POINT          pt;
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;

    fRet = FALSE;

    if (IsWndEqual(GetCapture(), hSKWnd)) {
        ReleaseCapture();
    }

    hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKT1_CONTEXT);
    if (!hSKT1Ctxt) {
        return (fRet);
    }

    lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
    if (!lpSKT1Ctxt) {
        return (fRet);
    }

    if (lpSKT1Ctxt->uKeyIndex < SKT1_TOTAL_INDEX) {
        UINT uVirtKey;

        uVirtKey = bSKT1VirtKey[lpSKT1Ctxt->uKeyIndex];
        keybd_event((BYTE)uVirtKey, (BYTE)guScanCode[uVirtKey],
            (DWORD)KEYEVENTF_KEYUP, 0);
        SKT1InvertButton(hSKWnd, NULL, lpSKT1Ctxt, lpSKT1Ctxt->uKeyIndex);
        lpSKT1Ctxt->uKeyIndex = SKT1_TOTAL_INDEX;
        fRet = TRUE;
        goto UnlockSKT1Context;
    }

    if (lpSKT1Ctxt->ptSkOffset.x == SKT1_NOT_DRAG ||
            lpSKT1Ctxt->ptSkOffset.y == SKT1_NOT_DRAG) {
        goto UnlockSKT1Context;
    }

    SKT1DrawDragBorder(hSKWnd, &lpSKT1Ctxt->ptSkCursor,
        &lpSKT1Ctxt->ptSkOffset);

    pt.x = lpSKT1Ctxt->ptSkCursor.x - lpSKT1Ctxt->ptSkOffset.x,
    pt.y = lpSKT1Ctxt->ptSkCursor.y - lpSKT1Ctxt->ptSkOffset.y,

    SetWindowPos(hSKWnd, (HWND)NULL, pt.x, pt.y,
        0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

    lpSKT1Ctxt->ptSkOffset.x = SKT1_NOT_DRAG;
    lpSKT1Ctxt->ptSkOffset.y = SKT1_NOT_DRAG;

    lpSKT1Ctxt->uKeyIndex = SKT1_TOTAL_INDEX;

    fRet = TRUE;

    hUIWnd = GetWindow(hSKWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        goto UnlockSKT1Context;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        goto UnlockSKT1Context;
    }

    lpIMC->ptSoftKbdPos.x = pt.x;
    lpIMC->ptSoftKbdPos.y = pt.y;
    lpIMC->fdwInit |= INIT_SOFTKBDPOS;

    ImmUnlockIMC(hIMC);

UnlockSKT1Context:
    GlobalUnlock(hSKT1Ctxt);

    return (fRet);
}

/**********************************************************************/
/* SetSKT1Data                                                        */
/**********************************************************************/
LRESULT SetSKT1Data(
    HWND          hSKWnd,
    LPSOFTKBDDATA lpSoftKbdData)
{
    HGLOBAL    hSKT1Ctxt;
    LPSKT1CTXT lpSKT1Ctxt;
    HDC        hDC, hMemDC;
    HGDIOBJ    hOldFont;
    int        i;

    hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKT1_CONTEXT);
    if (!hSKT1Ctxt) {
        return (1);
    }

    lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
    if (!lpSKT1Ctxt) {
        return (1);
    }

    hDC = GetDC(hSKWnd);
    hMemDC = CreateCompatibleDC(hDC);
    ReleaseDC(hSKWnd, hDC);
    SelectObject(hMemDC, lpSKT1Ctxt->hSKBitmap);

    SetBkColor(hMemDC, RGB(0xC0, 0xC0, 0xC0));

    if (lpSKT1Ctxt->lfCharSet != DEFAULT_CHARSET) {
        LOGFONT lfFont;
        CopyMemory(&lfFont, &lfSKT1Font, sizeof (LOGFONT));
        lfFont.lfCharSet = (BYTE)lpSKT1Ctxt->lfCharSet;
        hOldFont = (HFONT)SelectObject(hMemDC, CreateFontIndirect(&lfFont));
    }
    else {
        hOldFont = (HFONT)SelectObject(hMemDC, CreateFontIndirect(&lfSKT1Font));
    }

    for (i = 0; i < SKT1_LETTER_KEY_NUM; i++) {
        int  cbCount;
        RECT rcOpaque;

        lpSKT1Ctxt->wCodeTable[i] = lpSoftKbdData->wCode[0][bSKT1VirtKey[i]];

        cbCount = (lpSKT1Ctxt->wCodeTable[i] == 0) ? 0 : 1;

        rcOpaque.left = lpSKT1Ctxt->ptButtonPos[i].x + SKT1_LABEL_BMP_X -
            SKT1_XOVERLAP;
        rcOpaque.top = lpSKT1Ctxt->ptButtonPos[i].y + SKT1_LABEL_BMP_Y;

        rcOpaque.right = rcOpaque.left +
            lpSKT1Ctxt->nButtonWidth[SKT1_LETTER_TYPE] - SKT1_LABEL_BMP_X +
            SKT1_XOVERLAP;
        rcOpaque.bottom = rcOpaque.top + lpSKT1Ctxt->nButtonHeight[0] -
            SKT1_LABEL_BMP_Y;

        ExtTextOut(hMemDC, rcOpaque.left, rcOpaque.top,
            ETO_OPAQUE, &rcOpaque,
            (LPWSTR)&lpSKT1Ctxt->wCodeTable[i], cbCount, NULL);
    }

    DeleteObject(SelectObject(hMemDC, hOldFont));

    DeleteDC(hMemDC);

    GlobalUnlock(hSKT1Ctxt);

    return (0);
}

/**********************************************************************/
/* SKWndProcT1                                                        */
/**********************************************************************/
LRESULT CALLBACK SKWndProcT1(
    HWND   hSKWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
    case WM_CREATE:
        return CreateT1Window(hSKWnd);
    case WM_DESTROY:
        DestroyT1Window(hSKWnd);
        break;
    case WM_PAINT:
        {
            HDC         hDC;
            PAINTSTRUCT ps;

            hDC = BeginPaint(hSKWnd, &ps);
            UpdateSKT1Window(hDC, hSKWnd);
            EndPaint(hSKWnd, &ps);
        }
        break;
    case WM_SETCURSOR:
        if (!SKT1SetCursor(hSKWnd, lParam)) {
            return DefWindowProc(hSKWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_MOUSEMOVE:
        if (!SKT1MouseMove(hSKWnd)) {
            return DefWindowProc(hSKWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_LBUTTONUP:
        if (!SKT1ButtonUp(hSKWnd)) {
            return DefWindowProc(hSKWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);
    case WM_SHOWWINDOW:
        if (lParam != 0) {
        } else if ((BOOL)wParam == TRUE) {
        } else {
            // we want to hide the soft keyboard on mouse button down
            SKT1ButtonUp(hSKWnd);
        }

        return DefWindowProc(hSKWnd, uMsg, wParam, lParam);

    case WM_IME_CONTROL:
        switch (wParam) {
        case IMC_GETSOFTKBDFONT:
            {
                HGLOBAL    hSKT1Ctxt;
                LPSKT1CTXT lpSKT1Ctxt;
                BYTE       lfCharSet;

                hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKT1_CONTEXT);
                if (!hSKT1Ctxt) {
                    return (1);
                }

                lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
                if (!lpSKT1Ctxt) {
                    return (1);
                }

                lfCharSet = (BYTE)lpSKT1Ctxt->lfCharSet;

                GlobalUnlock(hSKT1Ctxt);

                *(LPLOGFONT)lParam = lfSKT1Font;

                if (lfCharSet != DEFAULT_CHARSET) {
                    ((LPLOGFONT)lParam)->lfCharSet = lfCharSet;
                }

                return (0);
            }
            break;
        case IMC_SETSOFTKBDFONT:
            {
                // in differet version of Windows
                if (lfSKT1Font.lfCharSet != ((LPLOGFONT)lParam)->lfCharSet) {
                    HGLOBAL    hSKT1Ctxt;
                    LPSKT1CTXT lpSKT1Ctxt;

                    hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd,
                        SKT1_CONTEXT);
                    if (!hSKT1Ctxt) {
                        return 1;
                    }

                    lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
                    if (!lpSKT1Ctxt) {
                        return 1;
                    }

                    lpSKT1Ctxt->lfCharSet = ((LPLOGFONT)lParam)->lfCharSet;

                    GlobalUnlock(hSKT1Ctxt);
                }
            }
            break;
        case IMC_GETSOFTKBDPOS:
            {
                RECT rcWnd;

                GetWindowRect(hSKWnd, &rcWnd);

                return MAKELRESULT(rcWnd.left, rcWnd.top);
            }
            break;
        case IMC_SETSOFTKBDPOS:
            {
                POINT          ptSoftKbdPos;
                HWND           hUIWnd;
                HIMC           hIMC;
                LPINPUTCONTEXT lpIMC;

                ptSoftKbdPos.x = ((LPPOINTS)lParam)->x;
                ptSoftKbdPos.y = ((LPPOINTS)lParam)->y;

                SetWindowPos(hSKWnd, NULL,
                    ptSoftKbdPos.x, ptSoftKbdPos.y,
                    0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

                // Here we want to get - the owner or parent window
                hUIWnd = GetParent(hSKWnd);

                if (!hUIWnd) {
                    return (1);
                }

                hIMC = (HIMC) GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);

                if (!hIMC) {
                    return (1);
                }

                lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);

                if (!lpIMC) {
                    return (1);
                }

                lpIMC->ptSoftKbdPos = ptSoftKbdPos;

                ImmUnlockIMC(hIMC);

                return (0);
            }
            break;
        case IMC_SETSOFTKBDDATA:
            {
                LRESULT lRet;

                lRet = SetSKT1Data(hSKWnd, (LPSOFTKBDDATA)lParam);
                if (!lRet) {
                    InvalidateRect(hSKWnd, NULL, FALSE);
                    PostMessage(hSKWnd, WM_PAINT, 0, 0);
                }
                return (lRet);
            }
            break;
        case IMC_GETSOFTKBDSUBTYPE:
        case IMC_SETSOFTKBDSUBTYPE:
            {
                HGLOBAL    hSKT1Ctxt;
                LPSKT1CTXT lpSKT1Ctxt;
                LRESULT    lRet;

                lRet = -1;

                hSKT1Ctxt = (HGLOBAL)GetWindowLongPtr(hSKWnd, SKT1_CONTEXT);
                if (!hSKT1Ctxt) {
                    return (lRet);
                }

                lpSKT1Ctxt = (LPSKT1CTXT)GlobalLock(hSKT1Ctxt);
                if (!lpSKT1Ctxt) {
                    return (lRet);
                }

                if (wParam == IMC_GETSOFTKBDSUBTYPE) {
                    lRet = lpSKT1Ctxt->uSubType;
                } else if (wParam == IMC_SETSOFTKBDSUBTYPE) {
                    lRet = lpSKT1Ctxt->uSubType;
                    lpSKT1Ctxt->uSubType = (UINT)lParam;
                } else {
                    lRet = -1;
                }

                GlobalUnlock(hSKT1Ctxt);
                return (lRet);
            }
            break;
        default:
            break;
        }
        break;
    default:
        return DefWindowProc(hSKWnd, uMsg, wParam, lParam);
    }

    return (0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\softkbd.c ===
/**************************************************************************\
* Module Name: softkbd.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Soft keyboard APIs
*
* History:
* 03-Jan-1996 wkwok    Ported from Win95
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#include "softkbd.h"


CONST LPCWSTR SoftKeyboardClassName[] = {
    L"",
    L"SoftKBDClsT1",
    L"SoftKBDClsC1"
};


BOOL RegisterSoftKeyboard(
    UINT uType)
{
    WNDCLASSEX wcWndCls;

    if (GetClassInfoEx(ghInst, SoftKeyboardClassName[uType], &wcWndCls)) {
        return (TRUE);
    }

    wcWndCls.cbSize        = sizeof(WNDCLASSEX);
    wcWndCls.style         = CS_IME;
    wcWndCls.cbClsExtra    = 0;
    wcWndCls.cbWndExtra    = sizeof(HGLOBAL);
    wcWndCls.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
    wcWndCls.hInstance     = ghInst;
    wcWndCls.hCursor       = LoadCursor(NULL, IDC_SIZEALL);
    wcWndCls.lpszMenuName  = (LPWSTR)NULL;
    wcWndCls.lpszClassName = SoftKeyboardClassName[uType];
    wcWndCls.hIconSm       = NULL;

    switch (uType) {
    case SOFTKEYBOARD_TYPE_T1:
        wcWndCls.lpfnWndProc   = SKWndProcT1;
        wcWndCls.hbrBackground = GetStockObject(NULL_BRUSH);
        break;
    case SOFTKEYBOARD_TYPE_C1:
        wcWndCls.lpfnWndProc   = SKWndProcC1;
        wcWndCls.hbrBackground = GetStockObject(LTGRAY_BRUSH);
        break;
    default:
        return (TRUE);
    }

    if (RegisterClassEx(&wcWndCls)) {
        return (TRUE);
    } else {
        return (FALSE);
    }
}


VOID GetSoftKeyboardDimension(
    UINT  uType,
    LPINT lpnWidth,
    LPINT lpnHeight)
{
    switch (uType) {
    case SOFTKEYBOARD_TYPE_T1:
        {
            TEXTMETRIC  tm;

            GetSKT1TextMetric(&tm);

            *lpnWidth = 2 * SKT1_XOUT + 2 * gptRaiseEdge.x +
                (tm.tmMaxCharWidth + SKT1_LABEL_BMP_X - SKT1_XOVERLAP +
                SKT1_XIN) * SKT1_TOTAL_COLUMN_NUM + 1 + 1;

            *lpnHeight = 2 * SKT1_YOUT + 2 * gptRaiseEdge.y +
                (tm.tmHeight + SKT1_LABEL_BMP_Y + SKT1_YIN) *
                SKT1_TOTAL_ROW_NUM + 1;
        }
        break;
    case SOFTKEYBOARD_TYPE_C1:
        {
            *lpnWidth = WIDTH_SOFTKBD_C1 +
                2 * GetSystemMetrics(SM_CXBORDER) +
                2 * GetSystemMetrics(SM_CXEDGE);

            *lpnHeight = HEIGHT_SOFTKBD_C1 +
                2 * GetSystemMetrics(SM_CXBORDER) +
                2 * GetSystemMetrics(SM_CXEDGE);
        }
        break;
    default:
        return;
    }
}


void GetAllMonitorSize(LPRECT lprc)
{
    if (GetSystemMetrics(SM_CMONITORS) == 1) {
         SystemParametersInfo(SPI_GETWORKAREA, 0, lprc, 0);
     } else {
        // We have multi-monitor !
        lprc->left = GetSystemMetrics(SM_XVIRTUALSCREEN);
        lprc->top =  GetSystemMetrics(SM_YVIRTUALSCREEN);
        lprc->right = lprc->left + GetSystemMetrics(SM_CXVIRTUALSCREEN);
        lprc->bottom = lprc->top + GetSystemMetrics(SM_CYVIRTUALSCREEN);
    }
}

BOOL GetNearestMonitorSize(HWND hwndOwner, LPRECT lprc)
{
    if (GetSystemMetrics(SM_CMONITORS) == 1) {
        GetAllMonitorSize(lprc);
    }
    else {
        HMONITOR hmonitor = MonitorFromWindow(hwndOwner, MONITOR_DEFAULTTONEAREST);
        MONITORINFO mInfo = {
            sizeof(MONITORINFO),
        };

        if (hmonitor == NULL) {
            return FALSE;
        }
        GetMonitorInfoW(hmonitor, &mInfo);
        *lprc = mInfo.rcWork;
    }
    return TRUE;
}

HWND WINAPI
ImmCreateSoftKeyboard(
    UINT uType,
    HWND hOwner,
    int  x,
    int  y)
{
    static BOOL fFirstSoftKeyboard = TRUE;
    PIMEDPI     pImeDpi;
    DWORD       fdwUICaps;
    int         nWidth, nHeight;
    HKL         hCurrentKL;
    UINT        i;
    HWND        hSKWnd;
    RECT        rcWork;
    SIZE        szWork;

    if (!uType) {
        return (HWND)NULL;
    }

    if (uType >= sizeof(SoftKeyboardClassName) / sizeof(LPWSTR)) {
        return (HWND)NULL;
    }

    hCurrentKL = GetKeyboardLayout(0);

    pImeDpi = ImmLockImeDpi(hCurrentKL);
    if (pImeDpi == NULL) {
        RIPMSG1(RIP_WARNING,
              "ImmCreateSoftKeyboard, pImeDpi = NULL (hkl = 0x%x).\n", hCurrentKL);
        return (HWND)NULL;
    }

    fdwUICaps = pImeDpi->ImeInfo.fdwUICaps;
    ImmUnlockImeDpi(pImeDpi);

    if (!(fdwUICaps & UI_CAP_SOFTKBD)) {
        return (HWND)NULL;
    }

    if (fFirstSoftKeyboard) {
        if (!GetNearestMonitorSize(hOwner, &rcWork)) {
            // failed
            return NULL;
        }

        for (i = 0; i < sizeof(guScanCode) / sizeof(UINT); i++) {
            guScanCode[i] = MapVirtualKey(i, 0);
        }


        // LATER: have to consider the dynamic resolution change

        szWork.cx = rcWork.right - rcWork.left;

        UserAssert(szWork.cx > UI_MARGIN * 2);
        szWork.cy = rcWork.bottom - rcWork.top;
        UserAssert(szWork.cy > UI_MARGIN * 2);

        gptRaiseEdge.x = GetSystemMetrics(SM_CXEDGE) +
            GetSystemMetrics(SM_CXBORDER);
        gptRaiseEdge.y = GetSystemMetrics(SM_CYEDGE) +
            GetSystemMetrics(SM_CYBORDER);

        fFirstSoftKeyboard = FALSE;
    }

    if (!RegisterSoftKeyboard(uType)) {
        return (HWND)NULL;
    }

    GetSoftKeyboardDimension(uType, &nWidth, &nHeight);

    // boundry check
    if (x < 0) {
        x = 0;
    } else if (x + nWidth > szWork.cx) {
        x = szWork.cx - nWidth;
    }

    if (y < 0) {
        y = 0;
    } else if (y + nHeight > szWork.cy) {
        y = szWork.cy - nHeight;
    }

    switch (uType) {
    case SOFTKEYBOARD_TYPE_T1:
        hSKWnd = CreateWindowEx(0,
                                SoftKeyboardClassName[uType],
                                (LPCWSTR)NULL,
                                WS_POPUP|WS_DISABLED,
                                x, y, nWidth, nHeight,
                                (HWND)hOwner, (HMENU)NULL, ghInst, NULL);
        break;
    case SOFTKEYBOARD_TYPE_C1:
        hSKWnd = CreateWindowEx(WS_EX_WINDOWEDGE|WS_EX_DLGMODALFRAME,
                                SoftKeyboardClassName[uType],
                                (LPCWSTR)NULL,
                                WS_POPUP|WS_DISABLED|WS_BORDER,
                                x, y, nWidth, nHeight,
                                (HWND)hOwner, (HMENU)NULL, ghInst, NULL);
        break;
    default:
        return (HWND)NULL;
    }

    ShowWindow(hSKWnd, SW_HIDE);
    UpdateWindow(hSKWnd);

    return (hSKWnd);
}


BOOL WINAPI
ImmDestroySoftKeyboard(
    HWND hSKWnd)
{
    return DestroyWindow(hSKWnd);
}


BOOL WINAPI
ImmShowSoftKeyboard(
    HWND hSKWnd,
    int  nCmdShow)
{
    if (!hSKWnd) {
        return (FALSE);
    }
    return ShowWindow(hSKWnd, nCmdShow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\imm\transsub.c ===
/****************************** Module Header ******************************\
* Module Name: transsub.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the translation layer functions
* of the sub functions of SendImeMessageEx.
*
* History:
* 21-May-1996 takaok      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

LRESULT TransSetOpenK( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme );
LRESULT TransSetOpenJ( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme );
LRESULT TransGetOpenK( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme, BOOL fAnsi );
LRESULT TransGetOpenJ( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme, BOOL fAnsi );
LRESULT TransMoveImeWindow( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme);
LRESULT TransSetConversionWindow(  HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme );
LRESULT TransSetConversionMode( HIMC hImc, LPIMESTRUCT lpIme );
LRESULT TransGetMode( HIMC hImc );
LRESULT TransGetConversionMode( HIMC hImc );
LRESULT TransSetMode( HIMC hImc, LPIMESTRUCT lpIme );
LRESULT TransSendVKey( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme, BOOL fAnsi );
LRESULT TransEnterWordRegisterMode( HWND hWndApp, LPIMESTRUCT lpIme, BOOL fAnsi);
LRESULT TransSetConversionFontEx( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme, BOOL fAnsi);
LRESULT TransHanjaMode( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme);
UINT Get31ModeFrom40ModeJ( DWORD fdwConversion );
UINT Get31ModeFrom40ModeK( DWORD fdwConversion );
LRESULT TransVKDBEMode( HIMC hImc, WPARAM wVKDBE );

BOOL  SetFontForMCWVERTICAL( HWND hWndApp, HIMC hImc, LPINPUTCONTEXT pInputContext, BOOL fVert );
BOOL IsForegroundThread( HWND );
BOOL FixLogfont( LPLOGFONTW lplfW, BOOL fVert );

BOOL MySetCompFont( HWND, HIMC, LPLOGFONTW );
BOOL MySetCompWindow( HWND, HIMC, LPCOMPOSITIONFORM );
BOOL MySetCandidateWindow( HWND, HIMC, LPCANDIDATEFORM );
BOOL MyPostImsMessage( HWND hWndApp, WPARAM wParam, LPARAM lParam);

//===================================================================
// TranslateIMESubFunctions
//==========================
//
// KOREAN and JAPANESE common translate routine for the
// sub functions of SendImeMessageEx.
//
// History:
// 21-May-1996 takaok      Created.
//
//===================================================================
LRESULT TranslateIMESubFunctions(
    HWND hWndApp,
    LPIMESTRUCT lpIme,
    BOOL fAnsi)
{
    HIMC        hImc;
    LRESULT     lRet;
    DWORD       dwLangID;

    hImc = ImmGetSaveContext( hWndApp, IGSC_DEFIMCFALLBACK );
    if ( hImc == NULL_HIMC ) {
        return FALSE;
    }

    dwLangID = PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID()));

    switch (lpIme->fnc) {
    case 0x03:  // IME_QUERY, IME_GETIMECAPS: KOREAN & JAPANESE
        lRet = TRUE;
        break;

    case 0x04:  // IME_SETOPEN: KOREAN & JAPANESE
        if ( dwLangID == LANG_KOREAN )
            lRet = TransSetOpenK( hWndApp, hImc, lpIme );
        else
            lRet = TransSetOpenJ( hWndApp, hImc, lpIme );
        break;

    case 0x05:  // IME_GETOPEN: KOREAN & JAPANESE
        if ( dwLangID == LANG_KOREAN )
            lRet = TransGetOpenK( hWndApp, hImc, lpIme, fAnsi );
        else
            lRet = TransGetOpenJ( hWndApp, hImc, lpIme, fAnsi );
        break;

    case 0x06:  // IME_ENABLEDOSIME, IME_ENABLE
    // internal functions are not supported
        lRet = FALSE;
        break;

    case 0x07:  // IME_GETVERSION: KOREAN & JAPANESE
        lRet = IMEVER_31;
        break;

    case 0x08:  // IME_MOVEIMEWINDOW, IME_SETCONVERSIONWINDOW: KOREAN & JAPANESE

        if ( dwLangID == LANG_KOREAN ) {
            //
            // IME_MOVEIMEWINDOW for KOREAN
            //
            lRet = TransMoveImeWindow(hWndApp, hImc, lpIme);
        } else {
            //
            // IME_MOVECONVERTWINDOW or IME_SETCONVERSIONWINDOW for JAPANESE
            //
            lRet = TransSetConversionWindow( hWndApp, hImc, lpIme );
        }
        break;

//  case 0x09:  // undefined

    case 0x10:  // IME_SETCONVERSIONMODE: JAPANESE
        if ( dwLangID == LANG_JAPANESE ) {
            lRet = TransSetConversionMode( hImc, lpIme );
        } else {
            lRet = FALSE;
        }
        break;

    case 0x11:  // IME_GETCONVERSIONMODE, IME_GETMODE: // KOREAN & JAPANESE
        // Use hSaveIMC, If WINNSEnableIME(FALSE).
        if ( dwLangID == LANG_KOREAN ) {
        //
        // IME_GETMODE for KOREAN
        //
            lRet = TransGetMode( hImc );
        } else {
        //
        // IME_GETCONVERSIONMODE for JAPANESE
        //
            lRet = TransGetConversionMode( hImc );
        }
        break;

    case 0x12:  // IME_SET_MODE, IME_SETFONT, IME_SETCONVERSIONFONT: KOREAN & JAPANESE
        if ( dwLangID == LANG_KOREAN ) {
            //
            // IME_SET_MODE for KOREAN
            //
            lRet = TransSetMode( hImc, lpIme );
        } else {
            //
            // IME_SETCONVERSIONFONT for JAPANESE
            //
            lRet = FALSE;   // should not be called. use SETCONVERSIONFONTEX instead
        }
        break;

    case 0x13:  // IME_SENDVKEY, IME_SENDKEY: JAPANESE only
        if ( dwLangID == LANG_JAPANESE ) {
            lRet = TransSendVKey( hWndApp, hImc, lpIme, fAnsi );
        } else {
            lRet = FALSE;
        }
        break;

//
// internal sub functions are not supported
//
//  case 0x14: // IME_DESTROY, IME_DESTROYIME
//  case 0x15: // IME_PRIVATE
//  case 0x16: // IME_WINDOWUPDATE
//  case 0x17: // IME_SELECT

    case 0x18: // IME_ENTERWORDREGISTERMODE: JAPANESE only
        if ( dwLangID == LANG_JAPANESE ) {
            lRet = TransEnterWordRegisterMode( hWndApp, lpIme, fAnsi);
        } else {
            lRet = FALSE;
        }
        break;

    case 0x19:  // IME_SETCONVERSIONFONTEX: JAPANESE only
        if ( dwLangID == LANG_JAPANESE ) {
            lRet = TransSetConversionFontEx( hWndApp, hImc, lpIme, fAnsi);
        } else {
            lRet = FALSE;
        }
        break;

//
// internal sub functions are not supported
//
//  case 0x1A: // IME_DBCSNAME
//  case 0x1B: // IME_MAXKEY
//  case 0x1C: // IME_WINNLS_SK

    case 0x20:  // IME_CODECONVERT: KOREAN only
        if ( dwLangID == LANG_KOREAN ) {
            if (TransCodeConvert( hImc, lpIme))
                lRet = lpIme->wParam;
            else
                lRet = 0;
        } else {
            lRet = 0;
        }
        break;

    case 0x21:  // IME_CONVERTLIST: KOREAN only
        if ( dwLangID == LANG_KOREAN ) {
            lRet = TransConvertList( hImc, lpIme);
        } else {
            lRet = FALSE;
        }
        break;

//
// internal sub functions and undefined sub functions are not supported
//
//  case 0x22:  // IME_INPUTKEYTOSEQUENCE
//  case 0x23:  // IME_SEQUENCETOINTERNAL
//  case 0x24:  // IME_QUERYIMEINFO
//  case 0x25:  // IME_DIALOG
//  case 0x26 - 0x2f:   // undefined

    case 0x30:  // IME_AUTOMATA: KOREAN only
        if ( dwLangID == LANG_KOREAN ) {
            lRet = ImmEscape(GetKeyboardLayout(0), hImc, IME_AUTOMATA, lpIme);
        } else {
            lRet = FALSE;
        }
        break;

    case 0x31:  // IME_HANJAMODE: KOREAN only
        if ( dwLangID == LANG_KOREAN ) {
            lRet = TransHanjaMode( hWndApp,  hImc, lpIme);
        } else {
            lRet = FALSE;
        }
        break;
//
//  case 0x32 - 0x3f: // undefined
//
    case 0x40:  // IME_GETLEVEL: KOREAN only
        if ( dwLangID == LANG_KOREAN ) {
            lRet = TransGetLevel( hWndApp );
        } else {
            lRet = FALSE;
        }
        break;

    case 0x41:  // IME_SETLEVEL: KOREAN only
        if ( dwLangID == LANG_KOREAN ) {
            lRet = TransSetLevel( hWndApp, lpIme);
        } else {
            lRet = FALSE;
        }
        break;

    case 0x42:  // IME_GETMNTABLE: KOREAN only
        if ( dwLangID == LANG_KOREAN ) {
            lRet = TransGetMNTable( hImc, lpIme);
        } else {
            lRet = FALSE;
        }
        break;

#if defined(PENAPI)
    case IME_SETUNDETERMINESTRING:
        lRet = FSetUndetermine( hImc, (HGLOBAL)lpIME->lParam1);
        break;

    case IME_SETCAPTURE:
        lRet = FEnablePenUi((HWND)lpIME->wParam, (lpIME->wParam != NULL));
        break;
#endif

#ifdef LATER // IME_NOTIFYWOWTASKEXIT
    case IME_NOTIFYWOWTASKEXIT:
      //
      // Destroy the default IME window of WOW 16bit
      // applications now. We should not wait for the
      // server wow thread clean up that will destroy the
      // IME window because usrsrv won't send WM_DESTROY
      // to non-server side window procedures. Some IMEs
      // must receive WM_DESTROY to free up 32 bit objects.
      //
      //  kksuzuka #7982:IME memory leak on WOW16 applications.
      //
      PIMMTHREADINFO piti = PitiCurrent();

      if ( piti != NULL && IsWindow( piti->hwndDefaultIme ) ) {
          DestroyWindow( piti->hwndDefaultIme );
      }
      return TRUE;
#endif
    default:
        //
        // private/internal/undefined functions are not supported
        //
        lRet = FALSE;
        break;
    }

    return (lRet);
}

//===================================================================
// TransSetOpenK
//===============
//
// KOREAN only
//
// History:
// xx-xx-1995     xxx      Created
//
//===================================================================
LRESULT TransSetOpenK( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme )
{
    // NOTE: We will use this function instead of ImmEscape().
    LRESULT lRet;

    lRet = ImmEscape(GetKeyboardLayout(0), hImc, IME_SETOPEN, lpIme);
    return (lRet);
    UNREFERENCED_PARAMETER(hWndApp);
}

//===================================================================
// TransSetOpenJ
//===============
//
// Japanese only
//
// History:
// 20-May-1996     takaok      Created
//
//===================================================================
LRESULT TransSetOpenJ( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme )
{
    LRESULT lRet;

    lRet = ImmGetOpenStatus( hImc );
    //
    // if the owner thread of hIMC doesn't have the input focus,
    // we won't call UI.
    //
    if ( !IsForegroundThread( NULL ) && !GetFocus() ) {
        //
        // this thread doesn't have focus.
        // let's update the input context and return without calling UI
        //
        PINPUTCONTEXT pInputContext;

        if ( (pInputContext = ImmLockIMC(hImc)) != NULL ) {
            if ( (pInputContext->fOpen && ! lpIme->wParam ) ||
                 (!pInputContext->fOpen &&  lpIme->wParam ) )
            {
                pInputContext->fOpen = (BOOL)lpIme->wParam;
                ImmNotifyIME( hImc, NI_CONTEXTUPDATED, 0, IMC_SETOPENSTATUS);
            }
            ImmUnlockIMC( hImc );
        }
    } else {
        ImmSetOpenStatus( hImc, (BOOL)lpIme->wParam );
    }
    return lRet;
    UNREFERENCED_PARAMETER(hWndApp);
}

//===================================================================
// TransGetOpenK
//===============
//
// KOREAN only
//
// History:
// xx-xx-1995     xxx      Created
//
//===================================================================
LRESULT TransGetOpenK( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme, BOOL fAnsi )
{
    // NOTE: We will use this function instead of ImmEscape().
    RECT    rc;
    LPARAM  lTemp;
    LRESULT lRet;

    lTemp = lpIme->lParam2;
    GetWindowRect(hWndApp, &rc);
    lpIme->lParam2 = MAKELONG(rc.top, rc.left);
    lRet = ImmEscape(GetKeyboardLayout(0), hImc, IME_GETOPEN, lpIme);
    lpIme->lParam2 = lTemp;
    return (lRet);
    UNREFERENCED_PARAMETER(fAnsi);
}

//===================================================================
// TransGetOpenJ
//===============
//
// Japanese only
//
// History:
// 20-May-1996     takaok      Created
//
//===================================================================
LRESULT TransGetOpenJ( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme, BOOL fAnsi )
{
    INT Count;
    LRESULT lRet;

    lRet = ImmGetOpenStatus( hImc );

    // lpIME->wCount is the length of the composition string.
    if ( fAnsi ) {
        Count= ImmGetCompositionStringA( hImc, GCS_COMPSTR, NULL, 0L );
    } else {
        Count= ImmGetCompositionStringW( hImc, GCS_COMPSTR, NULL, 0L );
    }
    lpIme->wCount = ( Count > 0 ) ? Count : 0;

    return lRet;
    UNREFERENCED_PARAMETER(hWndApp);
}

//===================================================================
// TransMoveImeWindow
//====================
//
// Korean only
//
//===================================================================
LRESULT TransMoveImeWindow( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme)
{
    // NOTE: We will use this function instead of ImmEscape().
    POINT   pt;
    LRESULT lRet;

    if (lpIme->wParam == MCW_WINDOW)
    {
        pt.x = GET_X_LPARAM(lpIme->lParam1);
        pt.y = GET_Y_LPARAM(lpIme->lParam1);
        ClientToScreen(hWndApp, &pt);
        lpIme->lParam1 = MAKELONG(pt.x, pt.y);
    }
    lRet = ImmEscape(GetKeyboardLayout(0), hImc, IME_MOVEIMEWINDOW, lpIme);
    return (lRet);
}


//===================================================================
// TransSetConversionWindow
//=========================
//
// Japanese only
//
//===================================================================
LRESULT TransSetConversionWindow(  HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme )
{
    LPINPUTCONTEXT pInputContext;
    COMPOSITIONFORM cof;
    CANDIDATEFORM   caf;
    POINT pt;
    RECT  rt;
    INT   i;

    if ( ! IsForegroundThread(NULL) && !GetFocus() ) {
        //
        // For win95 compatibility, we need to return TRUE though we
        // didn't really succeed. PP4 calls us when it doesn't have
        // the input focus to check if IME is capable to do the specfied
        // MCW_xxx. Returning TRUE here will make such application happy.
        //
        return ( TRUE );
    }

    pInputContext = ImmLockIMC( hImc );
    if ( pInputContext == NULL ) {
        return ( FALSE );
    }

    pt.x      = GET_X_LPARAM(lpIme->lParam1);
    pt.y      = GET_Y_LPARAM(lpIme->lParam1);
    rt.left   = GET_X_LPARAM(lpIme->lParam2);
    rt.top    = GET_Y_LPARAM(lpIme->lParam2);
    rt.right  = GET_X_LPARAM(lpIme->lParam3);
    rt.bottom = GET_Y_LPARAM(lpIme->lParam3);

    cof.dwStyle = CFS_DEFAULT;

    if ( lpIme->wParam & MCW_HIDDEN ) {
        pInputContext->fdw31Compat |= F31COMPAT_MCWHIDDEN;
        ScreenToClient( pInputContext->hWnd, &pt );
        MapWindowPoints( HWND_DESKTOP, pInputContext->hWnd, (LPPOINT)&rt, 2);
    } else {
        pInputContext->fdw31Compat &= ~F31COMPAT_MCWHIDDEN;
    }

    if ( lpIme->wParam & MCW_WINDOW) {
        if ( !IsWndEqual(hWndApp, pInputContext->hWnd)) {
            ClientToScreen(hWndApp, &pt);
            ScreenToClient(pInputContext->hWnd, &pt);
            if (lpIme->wParam & MCW_RECT) {
                cof.dwStyle = CFS_RECT;
                MapWindowPoints(hWndApp, HWND_DESKTOP, (LPPOINT)&rt, 2);
                MapWindowPoints(HWND_DESKTOP, pInputContext->hWnd, (LPPOINT)&rt, 2);
            } else {
                cof.dwStyle = CFS_POINT;
            }
        } else {
            if ( lpIme->wParam & MCW_RECT) {
                cof.dwStyle = CFS_RECT;
            } else {
                cof.dwStyle = CFS_POINT;
            }
        }
    }

    // Because Chicago IME can not handle CFS_SCREEN. The points should be
    // converted to client point.
    // If these points are out of Client, HOW SHOULD WE DO????

    if ( lpIme->wParam & MCW_SCREEN ) {
        ScreenToClient( pInputContext->hWnd, &pt );
        if ( lpIme->wParam & CFS_RECT ) {
            cof.dwStyle = CFS_RECT;
            MapWindowPoints( HWND_DESKTOP, pInputContext->hWnd, (LPPOINT)&rt, 2 );
        }
        else {
            cof.dwStyle = CFS_POINT;
        }
    }

    if ( lpIme->wParam & MCW_VERTICAL) {
        if ( !(pInputContext->fdw31Compat & F31COMPAT_MCWVERTICAL) ) {
            pInputContext->fdw31Compat |= F31COMPAT_MCWVERTICAL;
            SetFontForMCWVERTICAL( hWndApp, hImc, pInputContext, TRUE);
        }
    } else {
        if (pInputContext->fdw31Compat & F31COMPAT_MCWVERTICAL) {
            pInputContext->fdw31Compat &= ~F31COMPAT_MCWVERTICAL;
            SetFontForMCWVERTICAL( hWndApp, hImc, pInputContext, FALSE);
        }
    }
    cof.ptCurrentPos = pt;
    cof.rcArea       = rt;

#if defined(PENAPI)
    if ( !FSetPosPenUi(&cof) )
#endif
    if ( !(pInputContext->fdw31Compat & F31COMPAT_MCWHIDDEN) ) {
        MySetCompWindow( hWndApp, hImc, (LPCOMPOSITIONFORM)&cof );
    } else {
        // Hack for 3.1 Apps. We save the exlude area into IMC.
        pInputContext->cfCompForm.ptCurrentPos = cof.ptCurrentPos;
        pInputContext->cfCompForm.rcArea       = cof.rcArea;

        for ( i=0; i < 4; i++ ) {
            if ( pInputContext->cfCandForm[i].dwIndex != -1)
            {
                caf.dwIndex = i;
                caf.dwStyle = CFS_EXCLUDE;
                caf.ptCurrentPos = pt;
                caf.rcArea       = rt;
                MySetCandidateWindow( hWndApp, hImc, (LPCANDIDATEFORM)&caf );
            }
        }
    }
    ImmUnlockIMC( hImc );
    return ( TRUE );
}

//===================================================================
// TransSetConversionMode
//=======================
//
// Japanese only
//
// History:
// 31-May-1996 takaok      Created.
//
//===================================================================
LRESULT TransSetConversionMode( HIMC hImc, LPIMESTRUCT lpIme )
{
    DWORD fdwConversion = 0, fdwSentence, fdwNewConversion, fdwMask;
    UINT  uPrevMode;
    UINT  u31Mode;

    //
    // Get current conversion mode and translate it to
    // the 3.1 style conversion mode.
    //
    ImmGetConversionStatus( hImc, &fdwConversion, &fdwSentence);
    uPrevMode = Get31ModeFrom40ModeJ( fdwConversion );

    //
    // translate requested 3.1 conversion mode to 4.0 conversion mode
    //
    fdwNewConversion = 0;
    u31Mode = (UINT)lpIme->wParam;

    switch ( u31Mode & 0x07 ) {
    case IME_MODE_ALPHANUMERIC:
        fdwNewConversion &= ~IME_CMODE_LANGUAGE;
        break;
    case IME_MODE_KATAKANA:
        fdwNewConversion |= IME_CMODE_NATIVE|IME_CMODE_KATAKANA;
        break;
    case IME_MODE_HIRAGANA:
        fdwNewConversion |= IME_CMODE_NATIVE;
        break;
    }
    if ( !(u31Mode & JAPAN_IME_MODE_SBCSCHAR) )
        fdwNewConversion |= IME_CMODE_FULLSHAPE;

    if ( u31Mode & IME_MODE_ROMAN )
        fdwNewConversion |= IME_CMODE_ROMAN;

    if ( u31Mode & IME_MODE_CODEINPUT )
        fdwNewConversion |= IME_CMODE_CHARCODE;

    //
    // compute the mask bit. we need to compute this because
    // application may set only bit needed to be changed.
    //
    fdwMask = 0;
    if ( u31Mode & (IME_MODE_ROMAN | IME_MODE_NOROMAN) )
        fdwMask |= IME_CMODE_ROMAN;

    if ( u31Mode & (IME_MODE_CODEINPUT|IME_MODE_NOCODEINPUT) )
        fdwMask |= IME_CMODE_CHARCODE;

    if ( u31Mode & 0x07 )
        fdwMask |= IME_CMODE_LANGUAGE;

    if ( u31Mode & (IME_MODE_DBCSCHAR|JAPAN_IME_MODE_SBCSCHAR) )
        fdwMask |= IME_CMODE_FULLSHAPE;

    //
    // set the new mode
    //
    fdwNewConversion = (fdwNewConversion & fdwMask) | (fdwConversion & ~fdwMask);
    if ( ImmSetConversionStatus( hImc, fdwNewConversion, fdwSentence) ) {
        return (LRESULT)uPrevMode;
    } else {
        return (LRESULT)0;
    }
}

//===================================================================
// TransGetMode
//==============
//
// Korean only
//
// translate 4.0 conversion mode into 3.1 conversion mode
//
// History:
// 31-May-1996 takaok      Created.
//
//===================================================================
LRESULT TransGetMode( HIMC hImc )
{
    DWORD fdwConversion = 0, fdwSentence;
    UINT u31Mode = 0;

    ImmGetConversionStatus( hImc, &fdwConversion, &fdwSentence);
    u31Mode= Get31ModeFrom40ModeK( fdwConversion );
    // HACK: To prevent 0 result from treating FALSE, we always set MSB
    return ( u31Mode | 0x80000000 );
}

//===================================================================
// Get31ModeFrom40ModeK
//=====================
//
// Korean only
//
// translate 4.0 conversion mode into 3.1 conversion mode
//
// History:
// 31-May-1996 takaok      Created.
//
//===================================================================
UINT Get31ModeFrom40ModeK( DWORD fdwConversion )
{
    UINT u31Mode = 0;

    if ( !(fdwConversion & IME_CMODE_NATIVE) ) {

        u31Mode |= IME_MODE_ALPHANUMERIC;
    }

    if ( !(fdwConversion & IME_CMODE_FULLSHAPE) ) {

        u31Mode |= KOREA_IME_MODE_SBCSCHAR;
    }

    if ( fdwConversion & IME_CMODE_HANJACONVERT ) {
        u31Mode |= IME_MODE_HANJACONVERT;
    }

    return u31Mode;
}

//===================================================================
// TransGetConversionMode
//========================
//
// Japanese only
//
// 4.0 conversion mode => 3.1 conversion mode
//
// History:
// 31-May-1996 takaok      Created.
//
//===================================================================
LRESULT TransGetConversionMode( HIMC hImc )
{
    DWORD fdwConversion = 0, fdwSentence;
    UINT u31Mode = 0;

    //
    // get the 4.0 style conversion mode
    //
    ImmGetConversionStatus( hImc, &fdwConversion, &fdwSentence);
    return Get31ModeFrom40ModeJ( fdwConversion );
}

//===================================================================
// Get31ModeFrom40ModeJ
//======================
//
// Japanese only
//
// 4.0 conversion mode => 3.1 conversion mode
//
// History:
// 31-May-1996 takaok      Created.
//
//===================================================================
UINT Get31ModeFrom40ModeJ( DWORD fdwConversion )
{
    UINT u31Mode = 0;

    //
    // translate the 4.0 style mode to the 3.x style conversion mode
    //
    if (fdwConversion & IME_CMODE_NATIVE) {
        if (fdwConversion & IME_CMODE_KATAKANA) {
            u31Mode |= IME_MODE_KATAKANA;
        } else {
            u31Mode |= IME_MODE_HIRAGANA;
        }
    } else {
        u31Mode |= IME_MODE_ALPHANUMERIC;
    }

    if (fdwConversion & IME_CMODE_FULLSHAPE) {
        u31Mode |= IME_MODE_DBCSCHAR;
    } else {
        u31Mode |= JAPAN_IME_MODE_SBCSCHAR;
    }

    if (fdwConversion & IME_CMODE_ROMAN) {
        u31Mode |= IME_MODE_ROMAN;
    } else {
        u31Mode |= IME_MODE_NOROMAN;
    }

    if (fdwConversion & IME_CMODE_CHARCODE) {
        u31Mode |= IME_MODE_CODEINPUT;
    } else {
        u31Mode |= IME_MODE_NOCODEINPUT;
    }

    return (u31Mode);
}


//===================================================================
// TransSetMode
//==============
//
// KOREAN only
//
//===================================================================
LRESULT TransSetMode( HIMC hImc, LPIMESTRUCT lpIme )
{
    DWORD fdwConversion = 0, fdwSentence, fdwNewConversion, fdwMask;
    UINT  uPrevMode;
    UINT  u31Mode;

    //
    // Get current conversion mode and translate it to
    // the 3.1 style conversion mode.
    //
    ImmGetConversionStatus( hImc, &fdwConversion, &fdwSentence);
    uPrevMode = Get31ModeFrom40ModeK( fdwConversion );

    //
    // translate requested 3.1 conversion mode to 4.0 conversion mode
    //
    fdwNewConversion = 0;
    u31Mode = (UINT)lpIme->wParam;

    if ( !(u31Mode & IME_MODE_ALPHANUMERIC) )
        fdwNewConversion |= IME_CMODE_HANGEUL;
    if ( !(u31Mode & KOREA_IME_MODE_SBCSCHAR) )
        fdwConversion |= IME_CMODE_FULLSHAPE;

    //
    // In HWin3.1 there is no "not modification mode"
    //
    fdwMask = IME_CMODE_LANGUAGE|IME_CMODE_FULLSHAPE|IME_CMODE_HANJACONVERT;

    //
    // set the new mode
    //
    fdwNewConversion = (fdwNewConversion & fdwMask) | (fdwConversion & ~fdwMask);
    if ( ImmSetConversionStatus( hImc, fdwNewConversion, fdwSentence) ) {
        return (LRESULT)uPrevMode;
    } else {
        return (LRESULT)0;
    }
    return FALSE;
}

//===================================================================
// TransSendVKey
//===============
//
// Japanese only
//
//===================================================================
LRESULT TransSendVKey( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme, BOOL fAnsi )
{
    LRESULT lRet;

    switch (lpIme->wParam)
    {
        // VK_DBE_xxx Support Check.
        case (DWORD)(-1):
        case (DWORD)(0x0000ffff):   // from WOW16
            switch (lpIme->wCount)
            {
                case VK_DBE_ALPHANUMERIC:
                case VK_DBE_KATAKANA:
                case VK_DBE_HIRAGANA:
                case VK_DBE_SBCSCHAR:
                case VK_DBE_DBCSCHAR:
                case VK_DBE_ROMAN:
                case VK_DBE_NOROMAN:
                case VK_DBE_CODEINPUT:
                case VK_DBE_NOCODEINPUT:
                case VK_DBE_ENTERWORDREGISTERMODE:
                case VK_DBE_ENTERIMECONFIGMODE:
                case VK_DBE_ENTERDLGCONVERSIONMODE:
                case VK_DBE_DETERMINESTRING:
                case VK_DBE_FLUSHSTRING:
                case VK_CONVERT:
                    lRet = TRUE;
                    break;

                default:
                    lRet = FALSE;
                    break;
            }
            break;

        case VK_DBE_ALPHANUMERIC:
        case VK_DBE_KATAKANA:
        case VK_DBE_HIRAGANA:
        case VK_DBE_SBCSCHAR:
        case VK_DBE_DBCSCHAR:
        case VK_DBE_ROMAN:
        case VK_DBE_NOROMAN:
        case VK_DBE_CODEINPUT:
        case VK_DBE_NOCODEINPUT:
            lRet = TransVKDBEMode(hImc, lpIme->wParam);
            break;

        case VK_DBE_ENTERWORDREGISTERMODE:
            {
            HKL hkl = GetKeyboardLayout(0L);

            if ( fAnsi )
                lRet = ImmConfigureIMEA(hkl, hWndApp, IME_CONFIG_REGISTERWORD, NULL);
            else
                lRet = ImmConfigureIMEW(hkl, hWndApp, IME_CONFIG_REGISTERWORD, NULL);
            }
            break;

        case VK_DBE_ENTERIMECONFIGMODE:
            {
                HKL hkl = GetKeyboardLayout(0L);
                if (fAnsi)
                    lRet = ImmConfigureIMEA(hkl, hWndApp, IME_CONFIG_GENERAL, NULL);
                else
                    lRet = ImmConfigureIMEW(hkl, hWndApp, IME_CONFIG_GENERAL, NULL);
            }
            break;

        case VK_DBE_ENTERDLGCONVERSIONMODE:
#if defined(PENAPI)
            FInitPenUi(hIMC);
#endif
            lRet = FALSE;
            break;

        case VK_DBE_DETERMINESTRING:
            // Check there is the composition string or not.
            lRet = ImmNotifyIME( ImmGetContext(hWndApp),
                                 NI_COMPOSITIONSTR,
                                 CPS_COMPLETE,
                                 0L);
            break;

        case VK_DBE_FLUSHSTRING:
            lRet = ImmNotifyIME( hImc, NI_COMPOSITIONSTR,CPS_CANCEL,0L);
            break;

        case VK_CONVERT:
            lRet = ImmNotifyIME( hImc, NI_COMPOSITIONSTR, CPS_CONVERT, 0L);
            break;

        default:
            lRet = FALSE;
            break;
    }
    return lRet;
}

//===================================================================
// TransEnterWordRegisterMode
//===========================
//
// Japanese only
//
//===================================================================
LRESULT TransEnterWordRegisterMode( HWND hWndApp, LPIMESTRUCT lpIme, BOOL fAnsi)
{
    LRESULT lRet;
    HKL hkl = GetKeyboardLayout(0L);

    if ( ! ImmIsIME(hkl) ) {
        return FALSE;
    }

    if ( fAnsi ) {
    //
    // ANSI
    //
        REGISTERWORDA stReg = {NULL, NULL};
        LPSTR lpsz1, lpsz2;

        if (lpIme->lParam1&&(lpsz1=GlobalLock((HGLOBAL)lpIme->lParam1))) {
            stReg.lpWord = lpsz1;
        }
        if (lpIme->lParam2&&(lpsz2=GlobalLock((HGLOBAL)lpIme->lParam2))) {
            stReg.lpReading = lpsz2;
        }
        lRet = ImmConfigureIMEA(hkl,hWndApp,IME_CONFIG_REGISTERWORD, (LPVOID)&stReg);
        if (lpIme->lParam1 && lpsz1)
            GlobalUnlock((HGLOBAL)lpIme->lParam1);
        if (lpIme->lParam2 && lpsz2)
            GlobalUnlock((HGLOBAL)lpIme->lParam2);
    } else {
    //
    // UNICODE
    //
        REGISTERWORDW stReg = {NULL, NULL};
        LPWSTR lpsz1, lpsz2;

        if (lpIme->lParam1&&(lpsz1=GlobalLock((HGLOBAL)lpIme->lParam1))) {
            stReg.lpWord = lpsz1;
        }
        if (lpIme->lParam2&&(lpsz2=GlobalLock((HGLOBAL)lpIme->lParam2))) {
            stReg.lpReading = lpsz2;
        }
        lRet = ImmConfigureIMEW(hkl,hWndApp,IME_CONFIG_REGISTERWORD, (LPVOID)&stReg);
        if (lpIme->lParam1 && lpsz1)
            GlobalUnlock((HGLOBAL)lpIme->lParam1);
        if (lpIme->lParam2 && lpsz2)
            GlobalUnlock((HGLOBAL)lpIme->lParam2);
    }
    return lRet;
}


//===================================================================
// TransSetConversionFontEx
//==========================
//
// Japanese only
//
//===================================================================
LRESULT TransSetConversionFontEx( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme, BOOL fAnsi)
{
    LPINPUTCONTEXT pInputContext;
    LRESULT lRet;
    LPLOGFONTW lplf;
    LOGFONTW  lfw;

    pInputContext = ImmLockIMC( hImc );
    if ( pInputContext == NULL ) {
        return 0L;
    }

    lplf = (LPLOGFONTW)GlobalLock((HGLOBAL)lpIme->lParam1);
    if ( lplf == NULL )
    {
        ImmUnlockIMC( hImc );
        return 0L;
    }
    if ( fAnsi ) {
        memcpy( &lfw, lplf, sizeof(LOGFONTA) );
        MultiByteToWideChar( CP_ACP,
                             0,
                             (LPCSTR)lplf->lfFaceName,     // src
                             LF_FACESIZE,          // size of src
                             lfw.lfFaceName,       // destination buffer
                             LF_FACESIZE );        // size of destination buffer
    } else {
        memcpy( &lfw, lplf, sizeof(LOGFONTW));
    }
    GlobalUnlock((HGLOBAL)lpIme->lParam1);

    if (( pInputContext->fdw31Compat & F31COMPAT_MCWVERTICAL)) {
        lRet = FixLogfont( &lfw, TRUE);
    } else {
        lRet = FixLogfont( &lfw, FALSE);
    }
    ImmUnlockIMC( hImc );

    if (lRet == FALSE ) {
        return FALSE;
    }

    return MySetCompFont( hWndApp, hImc, &lfw );
}


//===================================================================
// TransHanjaMode
//================
//
// Korean only
//
//===================================================================
LRESULT TransHanjaMode( HWND hWndApp, HIMC hImc, LPIMESTRUCT lpIme)
{
    // NOTE We will use this function instead of ImmEscape().
    LRESULT lRet;
    PIMEDPI pImeDpi;
    DWORD   dwThreadId = GetInputContextThread(hImc);

    if (dwThreadId == 0) {
        RIPMSG1(RIP_WARNING,
              "TransHanjaMode: GetInputContextThread(%lx) failed.", hImc);
        return FALSE;
    }

    pImeDpi = ImmLockImeDpi(GetKeyboardLayout(dwThreadId));
    if (pImeDpi == NULL)
        return FALSE;

    /*
     * Check if we need ANSI/Unicode conversion
     */
    if (pImeDpi->ImeInfo.fdwProperty & IME_PROP_UNICODE) {
        WCHAR wUni;
        CHAR  chAnsi[2];
        UINT  i, dchSource;

        //The 4th word of imestruct32 contains dchSource
        dchSource = *((LPSTR)lpIme + 3 * sizeof(WORD));

        chAnsi[0] = *((LPSTR)lpIme + dchSource);
        chAnsi[1] = *((LPSTR)lpIme + dchSource + 1);

        i = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, chAnsi, 2, &wUni, 1);

        if (i)  {
           *((LPSTR)lpIme + dchSource)   = (CHAR)LOWORD(LOBYTE(wUni));
           *((LPSTR)lpIme + dchSource+1) = (CHAR)LOWORD(HIBYTE(wUni));
        }
        else {
           ImmUnlockImeDpi(pImeDpi);
           return FALSE;
        }
    }

    ImmUnlockImeDpi(pImeDpi);

    if (lRet = ImmEscape(GetKeyboardLayout(0), hImc, IME_HANJAMODE, lpIme))
        SendMessage(hWndApp, WM_IME_NOTIFY, IMN_OPENCANDIDATE, 1L);
    return (lRet);
}

//===================================================================
// TransGetLevel
//===============
//
// Korean only
//
//===================================================================
LRESULT TransGetLevel( HWND hWndApp )
{
    UINT lRet;

    if ( (lRet = NtUserGetAppImeLevel( hWndApp )) == 0 )
        lRet = 1;       // default level

    return lRet;
}

//===================================================================
// TransSetLevel
//===============
//
// Korean only
//
//===================================================================
LRESULT TransSetLevel( HWND hWndApp, LPIMESTRUCT lpIme)
{
    DWORD dwLevel;

    dwLevel = (DWORD)lpIme->wParam;
    if ( dwLevel >= 1 && dwLevel <= 5 ) {
        if ( NtUserSetAppImeLevel(hWndApp, dwLevel) ) {
            return TRUE;
        }
    }
    return FALSE;
}

//===================================================================
// TransVKDBEMode
//================
//
// Japanese only
//
//===================================================================
LRESULT TransVKDBEMode( HIMC hImc, WPARAM wVKDBE )
{
    DWORD fdwConversion,fdwSentence;

    if (!ImmGetConversionStatus(hImc, &fdwConversion, &fdwSentence)) {
        return FALSE;
    }

    switch (wVKDBE)
    {
        case VK_DBE_ALPHANUMERIC:
            fdwConversion &= ~IME_CMODE_LANGUAGE;
            break;

        case VK_DBE_KATAKANA:
            fdwConversion |= (IME_CMODE_JAPANESE | IME_CMODE_KATAKANA);
            break;

        case VK_DBE_HIRAGANA:
            fdwConversion &= ~IME_CMODE_KATAKANA;
            fdwConversion |= IME_CMODE_JAPANESE;
            break;

        case VK_DBE_SBCSCHAR:
            fdwConversion &= ~IME_CMODE_FULLSHAPE;
            break;

        case VK_DBE_DBCSCHAR:
            fdwConversion |= IME_CMODE_FULLSHAPE;
            break;

        case VK_DBE_ROMAN:
            fdwConversion |= IME_CMODE_ROMAN;
            break;

        case VK_DBE_NOROMAN:
            fdwConversion &= ~IME_CMODE_ROMAN;
            break;

        case VK_DBE_CODEINPUT:
            fdwConversion |= IME_CMODE_CHARCODE;
            break;

        case VK_DBE_NOCODEINPUT:
            fdwConversion &= ~IME_CMODE_CHARCODE;
            break;

        default:
            break;

    }

    return ImmSetConversionStatus(hImc, fdwConversion, fdwSentence);
}

//===================================================================
// IsForegroundThread
//===================
//
// Check if the caller thread has the foreground window.
// If hwnd is specified, the function checks if the creator
// thread of the specified window has the foreground window.
//
//===================================================================
BOOL    IsForegroundThread(HWND hwnd)
{
    HWND  hwndFG;
    DWORD dwThreadId;

    hwndFG = GetForegroundWindow();
    if ( IsWindow( hwnd ) ) {
        dwThreadId = GetWindowThreadProcessId( hwnd, NULL );
    } else {
        dwThreadId = GetCurrentThreadId();
    }
    return ( GetWindowThreadProcessId(hwndFG,NULL) == dwThreadId );
}


//===================================================================
// SetFontForMCWVERTICAL
//======================
//
// Japanese only
//
// set/reset vertical writing font
//
//===================================================================
BOOL  SetFontForMCWVERTICAL( HWND hWndApp, HIMC hImc, LPINPUTCONTEXT pInputContext, BOOL fVert )
{
    LOGFONTW lf;
    PCLIENTIMC pClientImc;

    if ( pInputContext->fdwInit & INIT_LOGFONT) {
    //
    // If a font has ever been set, use it
    //
        BOOL fAnsi;

        memcpy(&lf,&pInputContext->lfFont.W,sizeof(LOGFONTW));
        //
        // check if the input context is unicode
        //
        pClientImc = ImmLockClientImc( hImc );
        if (pClientImc == NULL) {
            return FALSE;
        }
        fAnsi = ! TestICF( pClientImc, IMCF_UNICODE );
        ImmUnlockClientImc( pClientImc );

        if ( fAnsi ) {
            CHAR FaceNameA[ LF_FACESIZE ];

            //
            // we need a temporary buffer because MultiByteToWideChar
            // doesn't allow us to specify src==dest.
            //
            memcpy( FaceNameA, &lf.lfFaceName, LF_FACESIZE );
            MultiByteToWideChar( CP_ACP,
                                 0,
                                 FaceNameA,     // src
                                 LF_FACESIZE,   // size of src
                                 lf.lfFaceName, // destination buffer
                                 LF_FACESIZE ); // size of destination buffer
        }
    } else {
    //
    // system font should be used as the default font
    //
        GetObjectW( GetStockObject(SYSTEM_FONT), sizeof(lf), (LPVOID)&lf );
    }

    //
    // put/remove '@' from the font facename.
    // "@facename" means vertical writing font
    //
    if ( FixLogfont( &lf, fVert ) == FALSE ) {
       return FALSE;
    }

    return MySetCompFont( hWndApp, hImc, &lf );
}

//===================================================================
// FixLogfont
//============
//
// Japanese only
//
// put/remove '@' from the font facename.
// "@facename" means vertical writing font
//
//===================================================================
BOOL FixLogfont(  LPLOGFONTW lplfW, BOOL fVert )
{
    int i;

    if ( fVert ) {
    //
    // convert the specified font to vertical writing font
    //
        lplfW->lfEscapement = 2700;
        lplfW->lfOrientation = 2700;
        if ((lplfW->lfCharSet == SHIFTJIS_CHARSET) && (lplfW->lfFaceName[0] != L'@')) {
            for(i=0;lplfW->lfFaceName[i];++i)    // Search NULL
            if (i > (LF_FACESIZE-2))         // if not remain 2 char
                return FALSE;                // then error
                                         // Because insert @ char

            for( ; i>=0 ; --i )                  // Copy facename from tail
                lplfW->lfFaceName[i+1] = lplfW->lfFaceName[i];

            lplfW->lfFaceName[0] = L'@';         // insert @ character
        }
    } else {
    //
    // convert the specified font to normal font
    //
        lplfW->lfEscapement = 0;
        lplfW->lfOrientation = 0;
        if ((lplfW->lfCharSet == SHIFTJIS_CHARSET) && (lplfW->lfFaceName[0] == L'@'))
            lstrcpynW(lplfW->lfFaceName,&(lplfW->lfFaceName[1]),LF_FACESIZE-1);
    }
    return TRUE;
}


//===================================================================
// MySetCompFont
//==============
//
// Japanese only
//
//===================================================================
BOOL MySetCompFont( HWND hWndApp, HIMC hImc, LPLOGFONTW lplf )
{
    BOOL lRet = FALSE;
    DWORD dwCompat;
    PINPUTCONTEXT pInputContext;
    PCLIENTIMC pClientImc;
    LOGFONTW lfw;
    LPLOGFONTW lplfw = &lfw;
    BOOL fUnicode;

    // BOGUS!!
    // Some application call SendIMEMessage(IME_SETCONVERSIONFONT)
    // when the apps is handling WM_PAINT.
    // New Win95 IME try to draw the UI during calling ImmSetCompositionFont,
    // and WM_PAINT will be sent in the API....
    // To avoid this thing, WINNLS makes the notification to IME and APPS later.
    // ........

    if ( (pInputContext = ImmLockIMC(hImc)) != NULL ) {
        dwCompat = ImmGetAppCompatFlags( hImc );
        pClientImc = ImmLockClientImc(hImc);
        if (pClientImc != NULL) {
            fUnicode = TestICF(pClientImc, IMCF_UNICODE);

            ImmUnlockClientImc(pClientImc);

            if ( fUnicode )
                lplfw = &(pInputContext->lfFont.W);
            else
                LFontAtoLFontW( &(pInputContext->lfFont.A), lplfw );

            if ( RtlEqualMemory(lplfw, lplf, sizeof(LOGFONTA)-LF_FACESIZE)
                 && !lstrcmp(lplfw->lfFaceName, lplf->lfFaceName) ) {

                /*
                 * Don't inform IME ahd UI when logfont is not changed.
                 */
                lRet = TRUE;

            } else if ( dwCompat & IMECOMPAT_UNSYNC31IMEMSG ) {

                memcpy( &(pInputContext->lfFont.W), lplf, sizeof(LOGFONT));
                if ( dwCompat & IMECOMPAT_UNSYNC31IMEMSG2 )
                    /*
                     * BOGUS!! for PageMaker5J
                     */
                    lRet = PostMessage( hWndApp, WM_IME_SYSTEM, IMS_SETCOMPOSITIONFONT, 0 );
                else
                    lRet = MyPostImsMessage( hWndApp, IMS_SETCOMPOSITIONFONT, 0);

            } else {

                lRet = ImmSetCompositionFont( hImc, lplf );

            }
        }
        ImmUnlockIMC( hImc );
    }
    return lRet;
}

//===================================================================
// MySetCompWindow
//================
//
// Japanese only
//
//===================================================================
BOOL MySetCompWindow(
    HWND              hWndApp,
    HIMC              hImc,
    LPCOMPOSITIONFORM lpcof
    )
{
    BOOL fRet = FALSE;
    DWORD dwCompat;
    PINPUTCONTEXT pInputContext;

    // BOGUS!!
    // Some application call SendIMEMessage(IME_SETCONVERSIONWINDOW)
    // when the apps is handling WM_PAINT.
    // New Win95 IME try to draw the UI during calling ImmSetCompositionWindow,
    // and WM_PAINT will be sent in the API....
    // To avoid this thing, WINNLS makes the notification to IME and APPS later.
    // ........
    if ( (pInputContext = ImmLockIMC(hImc)) != NULL ) {
        dwCompat = ImmGetAppCompatFlags( hImc );
        if ( dwCompat & IMECOMPAT_UNSYNC31IMEMSG ) {
            memcpy( &(pInputContext->cfCompForm), lpcof, sizeof(COMPOSITIONFORM));
            if ( dwCompat & IMECOMPAT_UNSYNC31IMEMSG2 ) {
                /*
                 * BOGUS!! for PageMaker5J
                 */
                fRet = PostMessage( hWndApp, WM_IME_SYSTEM, IMS_SETCOMPOSITIONWINDOW, 0 );
            } else {
                fRet = MyPostImsMessage( hWndApp, IMS_SETCOMPOSITIONWINDOW, 0 );
            }
        } else {
            pInputContext->fdw31Compat |= F31COMPAT_CALLFROMWINNLS;
            fRet = ImmSetCompositionWindow( hImc, lpcof );
        }
        ImmUnlockIMC( hImc );
    }
    return fRet;
}

//===================================================================
// MySetCandidateWindow
//=====================
//
// Japanese only
//
//===================================================================
BOOL MySetCandidateWindow( HWND hWndApp, HIMC hImc, LPCANDIDATEFORM lpcaf)
{
    BOOL fRet = FALSE;
    DWORD dwCompat;
    PINPUTCONTEXT pInputContext;

    // BOGUS!!
    // Some application call SendIMEMessage(IME_SETCONVERSIONWINDOW)
    // when the apps is handling WM_PAINT.
    // New Win95 IME try to draw the UI during calling ImmSetCandidateWindow,
    // and WM_PAINT will be sent in the API....
    // To avoid this thing, WINNLS makes the notification to IME and APPS later.
    // ........
    if ( (pInputContext = ImmLockIMC(hImc)) != NULL ) {
        dwCompat = ImmGetAppCompatFlags( hImc );
        if ( dwCompat & IMECOMPAT_UNSYNC31IMEMSG ) {
            memcpy( &(pInputContext->cfCandForm[lpcaf->dwIndex]), lpcaf, sizeof(CANDIDATEFORM));
            fRet = MyPostImsMessage( hWndApp, IMS_SETCANDIDATEPOS, lpcaf->dwIndex );
        } else {
            fRet = ImmSetCandidateWindow( hImc, lpcaf );
        }
        ImmUnlockIMC( hImc );
    }
    return fRet;
}

//===================================================================
// MyPostImsMessage
//==================
//
// Japanese only
//
// BOGUS!!
// Some application call SendIMEMessage(IME_SETCONVERSIONWINDOW)
// when the apps is handling WM_PAINT.
// New Win95 IME try to draw the UI during calling ImmSetCompositionWindow,
// and WM_PAINT will be sent in the API....
// To avoid this thing, WINNLS makes the notification to IME and APPS later.
// ........
//===================================================================
BOOL MyPostImsMessage( HWND hWndApp, WPARAM wParam, LPARAM lParam )
{
    HWND   hDefIMEWnd;
    BOOL   fRet = FALSE;

    hDefIMEWnd = ImmGetDefaultIMEWnd(hWndApp);
    if ( hDefIMEWnd != NULL ) {
        if ( PostMessage( hDefIMEWnd, WM_IME_SYSTEM, wParam, lParam) ) {
            fRet = TRUE;
        }
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\inc\csrmsg.h ===
/***************************** Module Header ******************************\
* Module Name: csrmsg.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* User CSR messages
*
* 02-27-95 JimA         Created.
\**************************************************************************/

#ifndef _CSRMSG_H_
#define _CSRMSG_H_

#include <ntcsrmsg.h>

typedef enum _USER_API_NUMBER {
    UserpExitWindowsEx = USERSRV_FIRST_API_NUMBER,
    UserpEndTask,
    UserpLogon,
    UserpRegisterServicesProcess,
    UserpActivateDebugger,
    UserpGetThreadConsoleDesktop,
    UserpDeviceEvent,
    UserpRegisterLogonProcess,
    UserpWin32HeapFail,
    UserpWin32HeapStat,
    UserpCreateSystemThreads,
    UserpMaxApiNumber
} USER_API_NUMBER, *PUSER_API_NUMBER;

typedef struct _EXITWINDOWSEXMSG {
    DWORD dwLastError;
    UINT uFlags;
    BOOL fSuccess;
} EXITWINDOWSEXMSG, *PEXITWINDOWSEXMSG;

typedef struct _ENDTASKMSG {
    DWORD dwLastError;
    HWND hwnd;
    BOOL fForce;
    BOOL fSuccess;
} ENDTASKMSG, *PENDTASKMSG;

typedef struct _LOGONMSG {
    BOOL fLogon;
} LOGONMSG, *PLOGONMSG;

typedef struct _ADDFONTMSG {
    PWCHAR pwchName;
    DWORD dwFlags;
} ADDFONTMSG, *PADDFONTMSG;

typedef struct _REGISTERSERVICESPROCESSMSG {
    DWORD dwLastError;
    DWORD dwProcessId;
    BOOL fSuccess;
} REGISTERSERVICESPROCESSMSG, *PREGISTERSERVICESPROCESSMSG;

typedef struct _ACTIVATEDEBUGGERMSG {
    CLIENT_ID ClientId;
} ACTIVATEDEBUGGERMSG, *PACTIVATEDEBUGGERMSG;

typedef struct _GETTHREADCONSOLEDESKTOPMSG {
    DWORD dwThreadId;
    HDESK hdeskConsole;
} GETTHREADCONSOLEDESKTOPMSG, *PGETTHREADCONSOLEDESKTOPMSG;

typedef struct _WIN32HEAPFAILMSG {
    DWORD dwFlags;
    BOOL  bFail;
} WIN32HEAPFAILMSG, *PWIN32HEAPFAILMSG;

typedef struct _WIN32HEAPSTATMSG {
    PVOID   phs;
    DWORD   dwLen;
    DWORD   dwMaxTag;
} WIN32HEAPSTATMSG, *PWIN32HEAPSTATMSG;

typedef struct _DEVICEEVENTMSG {
    HWND   hWnd;
    WPARAM wParam;
    LPARAM lParam;
    DWORD  dwFlags;
    ULONG_PTR dwResult;
} DEVICEEVENTMSG, *PDEVICEEVENTMSG;

typedef struct _CREATESYSTEMTHREADSMSG {
    BOOL bRemoteThread;
} CREATESYSTEMTHREADSMSG, *PCREATESYSTEMTHREADSMSG;


typedef struct _USER_API_MSG {
    PORT_MESSAGE h;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CSR_API_NUMBER ApiNumber;
    ULONG ReturnValue;
    ULONG Reserved;
    union {
        EXITWINDOWSEXMSG ExitWindowsEx;
        ENDTASKMSG EndTask;
        LOGONMSG Logon;
        REGISTERSERVICESPROCESSMSG RegisterServicesProcess;
        ACTIVATEDEBUGGERMSG ActivateDebugger;
        GETTHREADCONSOLEDESKTOPMSG GetThreadConsoleDesktop;
        WIN32HEAPFAILMSG Win32HeapFail;
        WIN32HEAPSTATMSG Win32HeapStat;
        DEVICEEVENTMSG DeviceEvent;
        CREATESYSTEMTHREADSMSG CreateSystemThreads;        
        DWORD IdLogon;
    } u;
} USER_API_MSG, *PUSER_API_MSG;

#endif // _CSRMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\inc\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Inference rules to build generated header files
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
$(O)\cscall.h: ..\cscall.tpl $(O)\scf.lst
    listmung $(O)\scf.lst ..\cscall.tpl >$@

$(O)\callback.h: ..\callback.tpl $(O)\cb.lst
    listmung $(O)\cb.lst ..\callback.tpl >$@

$(O)\msgdef.h: ..\msgdef.tpl $(O)\msgdef.lst
    listmung $(O)\msgdef.lst ..\msgdef.tpl >$@

$(O)\scf.lst: ..\scf.lst
    @echo Creating $@ from $**
    $(C_PREPROCESSOR)  $** > $@

$(O)\cb.lst: ..\cb.lst
    @echo Creating $@ from $**
    $(C_PREPROCESSOR)  $** > $@

$(O)\msgdef.lst: ..\msgdef.lst
    @echo Creating $@ from $**
    $(C_PREPROCESSOR)  $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\inc\messages.h ===
/****************************** Module Header ******************************\
* Module Name: messages.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contains the message indirection table. This is included in both the client
* and server code.
*
* 04-11-91 ScottLu      Created.
\***************************************************************************/

#include "msgdef.h"

#define IMSG_EMPTY      IMSG_DWORD
#define IMSG_RESERVED   IMSG_DWORD

/*
 * Allow posting of LB_DIR and CB_DIR because DlgDirList allows a DDL_POSTMSGS
 * flag that makes the API post the messages.  This should be as long as we
 * don't handle these messages in the kernel.  NT 3.51 allowed posting these.
 */

CONST MSG_TABLE_ENTRY MessageTable[] = {
    //iFunction,
    //           bThunkMessage,
    //                  bSyncOnlyMessage
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NULL                  0x0000
    {IMSG_INLPCREATESTRUCT,  TRUE,  TRUE},        // WM_CREATE                0x0001
    {IMSG_DWORD, FALSE, FALSE},                   // WM_DESTROY               0x0002
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MOVE                  0x0003
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SIZEWAIT              0x0004
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SIZE                  0x0005
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ACTIVATE              0x0006
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SETFOCUS              0x0007
    {IMSG_DWORD, FALSE, FALSE},                   // WM_KILLFOCUS             0x0008
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SETVISIBLE            0x0009
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ENABLE                0x000A
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SETREDRAW             0x000B
    {IMSG_INSTRINGNULL,  TRUE,  TRUE},            // WM_SETTEXT               0x000C
    {IMSG_OUTSTRING,  TRUE,  TRUE},               // WM_GETTEXT               0x000D
    {IMSG_GETDBCSTEXTLENGTHS,  TRUE,  TRUE},      // WM_GETTEXTLENGTH         0x000E
    {IMSG_DWORD, FALSE, FALSE},                   // WM_PAINT                 0x000F

    {IMSG_DWORD, FALSE, FALSE},                   // WM_CLOSE                 0x0010
    {IMSG_DWORD, FALSE, FALSE},                   // WM_QUERYENDSESSION       0x0011
    {IMSG_DWORD, FALSE, FALSE},                   // WM_QUIT                  0x0012
    {IMSG_DWORD, FALSE, FALSE},                   // WM_QUERYOPEN             0x0013
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_ERASEBKGND            0x0014
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SYSCOLORCHANGE        0x0015
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ENDSESSION            0x0016
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SYSTEMERROR           0x0017
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SHOWWINDOW            0x0018
    {IMSG_RESERVED, FALSE, FALSE},                // WM_CTLCOLOR              0x0019
    {IMSG_INSTRINGNULL,  TRUE,  TRUE},            // WM_WININICHANGE          0x001A
    {IMSG_INSTRING,  TRUE,  TRUE},                // WM_DEVMODECHANGE         0x001B
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ACTIVATEAPP           0x001C
    {IMSG_DWORD, FALSE, FALSE},                   // WM_FONTCHANGE            0x001D
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TIMECHANGE            0x001E
    {IMSG_DWORD, FALSE, FALSE},                   // WM_CANCELMODE            0x001F

    {IMSG_DWORD, FALSE, FALSE},                   // WM_SETCURSOR             0x0020
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MOUSEACTIVATE         0x0021
    {IMSG_DWORD, FALSE, FALSE},                   // WM_CHILDACTIVATE         0x0022
    {IMSG_DWORD, FALSE, FALSE},                   // WM_QUEUESYNC             0x0023
    {IMSG_INOUTLPPOINT5, FALSE,  TRUE},           // WM_GETMINMAXINFO         0x0024
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x0025
    {IMSG_DWORD, FALSE, FALSE},                   // WM_PAINTICON             0x0026
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_ICONERASEBKGND        0x0027
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NEXTDLGCTL            0x0028
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ALTTABACTIVE          0x0029
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SPOOLERSTATUS         0x002A
    {IMSG_INLPDRAWITEMSTRUCT, FALSE,  TRUE},      // WM_DRAWITEM              0x002B
    {IMSG_INOUTLPMEASUREITEMSTRUCT, FALSE,  TRUE},// WM_MEASUREITEM           0x002C
    {IMSG_INLPDELETEITEMSTRUCT, FALSE,  TRUE},    // WM_DELETEITEM            0x002D
    {IMSG_DWORD, FALSE, FALSE},                   // WM_VKEYTOITEM            0x002E
    {IMSG_INWPARAMCHAR,  TRUE, FALSE},            // WM_CHARTOITEM            0x002F

    {IMSG_DWORD, FALSE, FALSE},                   // WM_SETFONT               0x0030
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_GETFONT               0x0031
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SETHOTKEY             0x0032
    {IMSG_DWORD, FALSE, FALSE},                   // WM_GETHOTKEY             0x0033
    {IMSG_DWORD, FALSE, FALSE},                   // WM_FILESYSCHANGE         0x0034
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ISACTIVEICON          0x0035
    {IMSG_DWORD, FALSE, FALSE},                   // WM_QUERYPARKICON         0x0036
    {IMSG_DWORD, FALSE, FALSE},                   // WM_QUERYDRAGICON         0x0037
    {IMSG_INLPHLPSTRUCT, FALSE,  TRUE},           // WM_WINHELP               0x0038
    {IMSG_INLPCOMPAREITEMSTRUCT, FALSE,  TRUE},   // WM_COMPAREITEM           0x0039
    {IMSG_KERNELONLY, FALSE, FALSE},              // WM_FULLSCREEN            0x003A
    {IMSG_DWORD, FALSE, FALSE},                   // WM_CLIENTSHUTDOWN        0x003B
    {IMSG_KERNELONLY, FALSE, TRUE},               // WM_DDEMLEVENT            0x003C
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x003D
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x003E
    {IMSG_DWORD, FALSE, FALSE},                   // MM_CALCSCROLL            0x003F

    {IMSG_RESERVED, FALSE, FALSE},                // WM_TESTING               0x0040
    {IMSG_DWORD, FALSE, FALSE},                   // WM_COMPACTING            0x0041

    {IMSG_RESERVED, FALSE, FALSE},                // WM_OTHERWINDOWCREATED    0x0042
    {IMSG_RESERVED, FALSE, FALSE},                // WM_OTHERWINDOWDESTROYED  0x0043
    {IMSG_RESERVED, FALSE, FALSE},                // WM_COMMNOTIFY            0x0044
    {IMSG_RESERVED, FALSE, FALSE},                // WM_MEDIASTATUSCHANGE     0x0045
    {IMSG_INOUTLPWINDOWPOS, FALSE,  TRUE},        // WM_WINDOWPOSCHANGING     0x0046
    {IMSG_INLPWINDOWPOS, FALSE,  TRUE},           // WM_WINDOWPOSCHANGED      0x0047

    {IMSG_RESERVED, FALSE, FALSE},                // WM_POWER                 0x0048
    {IMSG_COPYGLOBALDATA,  TRUE,  TRUE},          // WM_COPYGLOBALDATA        0x0049
    {IMSG_COPYDATA, FALSE,  TRUE},                // WM_COPYDATA              0x004A
    {IMSG_RESERVED, FALSE, FALSE},                // WM_CANCELJOURNAL         0x004B
    {IMSG_LOGONNOTIFY, FALSE, FALSE},             // WM_LOGONNOTIFY           0x004C
    {IMSG_DWORD, FALSE, FALSE},                   // WM_KEYF1                 0x004D
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NOTIFY                0x004E
    {IMSG_RESERVED, FALSE, FALSE},                // WM_ACCESS_WINDOW         0x004f

    {IMSG_DWORD, FALSE, FALSE},                   // WM_INPUTLANGCHANGEREQUEST 0x0050
    {IMSG_DWORD, FALSE, FALSE},                   // WM_INPUTLANGCHANGE       0x0051
    {IMSG_EMPTY, FALSE, FALSE},                   // WM_TCARD                 0x0052
    {IMSG_INLPHELPINFOSTRUCT, FALSE,  TRUE},      // WM_HELP                  0x0053 WINHELP4
    {IMSG_EMPTY, FALSE, FALSE},                   // WM_USERCHANGED           0x0054
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NOTIFYFORMAT          0x0055
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0059-0x005F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0060-0x0067
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0068-0x006F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_KERNELONLY, FALSE, TRUE},               // WM_FINALDESTROY          0x0070
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TASKACTIVATED         0x0072
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TASKDEACTIVATED       0x0073
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TASKCREATED           0x0074
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TASKDESTROYED         0x0075
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TASKUICHANGED         0x0076
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TASKVISIBLE           0x0077
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TASKNOTVISIBLE        0x0078
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SETCURSORINFO         0x0079
    {IMSG_EMPTY, FALSE, FALSE},                   //                          0x007A
    {IMSG_DWORD, FALSE, FALSE},                   // WM_CONTEXTMENU           0x007B
    {IMSG_INOUTSTYLECHANGE, FALSE,  TRUE},        // WM_STYLECHANGING         0x007C
    {IMSG_INOUTSTYLECHANGE, FALSE,  TRUE},        // WM_STYLECHANGED          0x007D
    {IMSG_EMPTY, FALSE, FALSE},                   //                          0x007E
    {IMSG_DWORD, FALSE, FALSE},                   // WM_GETICON               0x007f

    {IMSG_DWORD, FALSE, FALSE},                   // WM_SETICON               0x0080
    {IMSG_INLPCREATESTRUCT,  TRUE,  TRUE},        // WM_NCCREATE              0x0081
    {IMSG_NCDESTROY, FALSE, FALSE},               // WM_NCDESTROY             0x0082
    {IMSG_INOUTNCCALCSIZE, FALSE,  TRUE},         // WM_NCCALCSIZE            0x0083

    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCHITTEST             0x0084
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_NCPAINT               0x0085
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCACTIVATE            0x0086
    {IMSG_DWORDOPTINLPMSG, FALSE,  TRUE},         // WM_GETDLGCODE            0x0087

    {IMSG_DWORD, FALSE, FALSE},                   // WM_SYNCPAINT             0x0088
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SYNCTASK              0x0089

    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_INOUTLPRECT, FALSE,  TRUE},             // WM_KLUDGEMINRECT         0x008B
    {IMSG_INLPKDRAWSWITCHWND, FALSE, TRUE},       // WM_LPKDRAWSWITCHWND      0x008C
    {IMSG_EMPTY, FALSE, FALSE},                   // 0x008D-0x008F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0090-0x0097
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0098-0x009F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCMOUSEMOVE           0x00A0
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCLBUTTONDOWN         0x00A1
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCLBUTTONUP           0x00A2
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCLBUTTONDBLCLK       0x00A3
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCRBUTTONDOWN         0x00A4
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCRBUTTONUP           0x00A5
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCRBUTTONDBLCLK       0x00A6
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCMBUTTONDOWN         0x00A7
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCMBUTTONUP           0x00A8
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCMBUTTONDBLCLK       0x00A9
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x00AA
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCXBUTTONDOWN         0x00AB
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCXBUTTONUP           0x00AC
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCXBUTTONDBLCLK       0x00AD
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCUAHDRAWCAPTION      0x00AE
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCUAHDRAWFRAME        0x00AF

    {IMSG_EMGETSEL, FALSE,  TRUE},                // EM_GETSEL                0x00B0
    {IMSG_EMSETSEL, FALSE, FALSE},                // EM_SETSEL                0x00B1
    {IMSG_OUTLPRECT, FALSE,  TRUE},               // EM_GETRECT               0x00B2
    {IMSG_INOUTLPRECT, FALSE,  TRUE},             // EM_SETRECT               0x00B3
    {IMSG_INOUTLPRECT, FALSE,  TRUE},             // EM_SETRECTNP             0x00B4
    {IMSG_DWORD, FALSE, FALSE},                   // EM_SCROLL                0x00B5
    {IMSG_DWORD, FALSE, FALSE},                   // EM_LINESCROLL            0x00B6
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x00B7
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETMODIFY             0x00B8
    {IMSG_DWORD, FALSE, FALSE},                   // EM_SETMODIFY             0x00B9
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETLINECOUNT          0x00BA
    {IMSG_DWORD, FALSE, FALSE},                   // EM_LINEINDEX             0x00BB
    {IMSG_DWORD, FALSE, FALSE},                   // EM_SETHANDLE             0x00BC
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETHANDLE             0x00BD
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETTHUMB              0x00BE
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x00BF

    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x00C0
    {IMSG_DWORD, FALSE, FALSE},                   // EM_LINELENGTH            0x00C1
    {IMSG_INSTRINGNULL,  TRUE,  TRUE},            // EM_REPLACESEL            0x00C2
    {IMSG_DWORD, FALSE, FALSE},                   // EM_SETFONT               0x00C3
    {IMSG_INCNTOUTSTRING,  TRUE,  TRUE},          // EM_GETLINE               0x00C4
    {IMSG_DWORD, FALSE, FALSE},                   // EM_LIMITTEXT             0x00C5
    {IMSG_DWORD, FALSE, FALSE},                   // EM_CANUNDO               0x00C6
    {IMSG_DWORD, FALSE, FALSE},                   // EM_UNDO                  0x00C7
    {IMSG_DWORD, FALSE, FALSE},                   // EM_FMTLINES              0x00C8
    {IMSG_DWORD, FALSE, FALSE},                   // EM_LINEFROMCHAR          0x00C9
    {IMSG_DWORD, FALSE, FALSE},                   // EM_SETWORDBREAK          0x00CA
    {IMSG_POPTINLPUINT, FALSE,  TRUE},            // EM_SETTABSTOPS           0x00CB
    {IMSG_INWPARAMDBCSCHAR,  TRUE, FALSE},        // EM_SETPASSWORDCHAR       0x00CC
    {IMSG_DWORD, FALSE, FALSE},                   // EM_EMPTYUNDOBUFFER       0x00CD
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETFIRSTVISIBLELINE   0x00CE
    {IMSG_DWORD, FALSE, FALSE},                   // EM_SETREADONLY           0x00CF

    {IMSG_DWORD, FALSE, FALSE},                   // EM_SETWORDBREAKPROC      0x00D0
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETWORDBREAKPROC      0x00D1
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETPASSWORDCHAR       0x00D2
    {IMSG_DWORD, FALSE, FALSE},                   // EM_SETMARGINS            0x00D3
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETMARGINS            0x00D4
    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETLIMITTEXT          0x00D5
    {IMSG_DWORD, FALSE, FALSE},                   // EM_POSFROMCHAR           0x00D6
    {IMSG_DWORD, FALSE, FALSE},                   // EM_CHARFROMPOS           0x00D7
    {IMSG_DWORD, FALSE, FALSE},                   // EM_SETIMESTATUS          0x00D8

    {IMSG_DWORD, FALSE, FALSE},                   // EM_GETIMESTATUS          0x00D9
    {IMSG_RESERVED, FALSE, FALSE},                // EM_MSGMAX                0x00DA
    {IMSG_EMPTY, FALSE, FALSE},                   // 0x00DB-0x00DF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // SBM_SETPOS               0x00E0
    {IMSG_DWORD, FALSE, FALSE},                   // SBM_GETPOS               0x00E1
    {IMSG_DWORD, FALSE, FALSE},                   // SBM_SETRANGE             0x00E2
    {IMSG_OPTOUTLPDWORDOPTOUTLPDWORD, FALSE,  TRUE}, // SBM_GETRANGE          0x00E3
    {IMSG_DWORD, FALSE, FALSE},                   // SBM_ENABLE_ARROWS        0x00E4
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},                   // SBM_SETRANGEREDRAW       0x00E6
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_INOUTLPSCROLLINFO, FALSE,  TRUE},       // SBM_SETSCROLLINFO        0x00E9
    {IMSG_INOUTLPSCROLLINFO, FALSE,  TRUE},       // SBM_GETSCROLLINFO        0x00EA
    {IMSG_OUTLPSCROLLBARINFO, FALSE, TRUE},       // CB_GETSCROLLBARINFO      0x00EB
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // BM_GETCHECK              0x00F0
    {IMSG_DWORD, FALSE, FALSE},                   // BM_SETCHECK              0x00F1
    {IMSG_DWORD, FALSE, FALSE},                   // BM_GETSTATE              0x00F2
    {IMSG_DWORD, FALSE, FALSE},                   // BM_SETSTATE              0x00F3
    {IMSG_DWORD, FALSE, FALSE},                   // BM_SETSTYLE              0x00F4
    {IMSG_DWORD, FALSE, FALSE},                   // BM_CLICK                 0x00F5
    {IMSG_DWORD, FALSE, FALSE},                   // BM_GETIMAGE              0x00F6
    {IMSG_DWORD, FALSE, FALSE},                   // BM_SETIMAGE              0x00F7

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x00F8-0x00FE
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // WM_INPUT                 0x00FF
    {IMSG_DWORD, FALSE, FALSE},                   // WM_KEYDOWN               0x0100
    {IMSG_DWORD, FALSE, FALSE},                   // WM_KEYUP                 0x0101
    {IMSG_INWPARAMDBCSCHAR,  TRUE, FALSE},        // WM_CHAR                  0x0102
    {IMSG_INWPARAMCHAR,  TRUE, FALSE},            // WM_DEADCHAR              0x0103
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SYSKEYDOWN            0x0104
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SYSKEYUP              0x0105
    {IMSG_INWPARAMCHAR,  TRUE, FALSE},            // WM_SYSCHAR               0x0106
    {IMSG_INWPARAMCHAR,  TRUE, FALSE},            // WM_SYSDEADCHAR           0x0107
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_YOMICHAR              0x0108
    {IMSG_DWORD, FALSE, FALSE},                   // WM_UNICHAR               0x0109
    {IMSG_RESERVED, FALSE,  TRUE},                // WM_CONVERTREQUEST        0x010A
    {IMSG_RESERVED, FALSE, FALSE},                // WM_CONVERTRESULT         0x010B
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x010C
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x010D
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x010E
    {IMSG_INWPARAMCHAR,  TRUE, FALSE},            // WM_IME_COMPOSITION       0x010F

    {IMSG_DWORD, FALSE, FALSE},                   // WM_INITDIALOG            0x0110
    {IMSG_DWORD, FALSE, FALSE},                   // WM_COMMAND               0x0111
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SYSCOMMAND            0x0112
    {IMSG_DWORD, FALSE, FALSE},                   // WM_TIMER                 0x0113
    {IMSG_DWORD, FALSE, FALSE},                   // WM_HSCROLL               0x0114
    {IMSG_DWORD, FALSE, FALSE},                   // WM_VSCROLL               0x0115
    {IMSG_DWORD, FALSE, FALSE},                   // WM_INITMENU              0x0116
    {IMSG_DWORD, FALSE, FALSE},                   // WM_INITMENUPOPUP         0x0117
    {IMSG_DWORD, FALSE, FALSE},                   // WM_SYSTIMER              0x0118
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x0119
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x011A
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x011B
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x011C
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x011D
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x011E
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MENUSELECT            0x011F

    {IMSG_INWPARAMCHAR,  TRUE, FALSE},            // WM_MENUCHAR              0x0120
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ENTERIDLE             0x0121
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MENURBUTTONUP         0x0122
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MENUDRAG              0x0123
    {IMSG_INOUTMENUGETOBJECT, TRUE, TRUE},        // WM_MENUGETOBJECT         0x0124
    {IMSG_DWORD, FALSE, FALSE},                   // WM_UNINITMENUPOPUP       0x0125
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MENUCOMMAND           0x0126
    {IMSG_DWORD, FALSE, FALSE},                   // WM_CHANGEUISTATE         0x0127
    {IMSG_DWORD, FALSE, FALSE},                   // WM_UPDATEUISTATE         0x0128
    {IMSG_DWORD, FALSE, FALSE},                   // WM_QUERYUISTATE          0x0129

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x012A-0x012F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x0130
    {IMSG_DWORD, FALSE, FALSE},                   // WM_LBTRACKPOINT          0x0131
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_CTLCOLORMSGBOX        0x0132
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_CTLCOLOREDIT          0x0133
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_CTLCOLORLISTBOX       0x0134
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_CTLCOLORBTN           0x0135
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_CTLCOLORDLG           0x0136
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_CTLCOLORSCROLLBAR     0x0137
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_CTLCOLORSTATIC        0x0138
    {IMSG_EMPTY, FALSE, FALSE},                   //                          0x0139

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x013A-0x013F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_CBGETEDITSEL, FALSE,  TRUE},            // CB_GETEDITSEL            0x0140
    {IMSG_DWORD, FALSE, FALSE},                   // CB_LIMITTEXT             0x0141
    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETEDITSEL            0x0142
    {IMSG_INCBOXSTRING,  TRUE,  TRUE},            // CB_ADDSTRING             0x0143
    {IMSG_DWORD, FALSE, FALSE},                   // CB_DELETESTRING          0x0144
    {IMSG_INSTRING,  TRUE,  FALSE},               // CB_DIR                   0x0145
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETCOUNT              0x0146
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETCURSEL             0x0147
    {IMSG_OUTCBOXSTRING,  TRUE,  TRUE},           // CB_GETLBTEXT             0x0148
    {IMSG_GETDBCSTEXTLENGTHS,  TRUE,  TRUE},      // CB_GETLBTEXTLEN          0x0149
    {IMSG_INCBOXSTRING,  TRUE,  TRUE},            // CB_INSERTSTRING          0x014A
    {IMSG_DWORD, FALSE, FALSE},                   // CB_RESETCONTENT          0x014B
    {IMSG_INCBOXSTRING,  TRUE,  TRUE},            // CB_FINDSTRING            0x014C
    {IMSG_INCBOXSTRING,  TRUE,  TRUE},            // CB_SELECTSTRING          0x014D
    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETCURSEL             0x014E
    {IMSG_DWORD, FALSE, FALSE},                   // CB_SHOWDROPDOWN          0x014F

    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETITEMDATA           0x0150
    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETITEMDATA           0x0151
    {IMSG_OUTLPRECT, FALSE,  TRUE},               // CB_GETDROPPEDCONTROLRECT 0x0152
    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETITEMHEIGHT         0x0153
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETITEMHEIGHT         0x0154
    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETEXTENDEDUI         0x0155
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETEXTENDEDUI         0x0156
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETDROPPEDSTATE       0x0157
    {IMSG_INCBOXSTRING,  TRUE,  TRUE},            // CB_FINDSTRINGEXACT       0x0158
    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETLOCALE             0x0159
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETLOCALE             0x015A
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETTOPINDEX           0x015b

    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETTOPINDEX           0x015c
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETHORIZONTALEXTENT   0x015d
    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETHORIZONTALEXTENT   0x015e
    {IMSG_DWORD, FALSE, FALSE},                   // CB_GETDROPPEDWIDTH       0x015F

    {IMSG_DWORD, FALSE, FALSE},                   // CB_SETDROPPEDWIDTH       0x0160
    {IMSG_DWORD, FALSE, FALSE},                   // CB_INITSTORAGE           0x0161
    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0162
    {IMSG_EMPTY, FALSE, FALSE},                   // CB_MULTIPLEADDSTRING     0x0163
    {IMSG_OUTLPCOMBOBOXINFO,  FALSE, TRUE},       // CB_GETCOMBOBOXINFO       0x0164
    {IMSG_RESERVED, FALSE, FALSE},                // CB_MSGMAX                0x0165
    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0166-0x0167
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0168-0x016F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // STM_SETICON              0x0170
    {IMSG_DWORD, FALSE, FALSE},                   // STM_GETICON              0x0171
    {IMSG_DWORD, FALSE, FALSE},                   // STM_SETIMAGE             0x0172
    {IMSG_DWORD, FALSE, FALSE},                   // STM_GETIMAGE             0x0173
    {IMSG_DWORD, FALSE, FALSE},                   // STM_MSGMAX               0x0174
    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0175-0x0177
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0178-0x017F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_ADDSTRING             0x0180
    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_INSERTSTRING          0x0181
    {IMSG_DWORD, FALSE, FALSE},                   // LB_DELETESTRING          0x0182
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x0183
    {IMSG_DWORD, FALSE, FALSE},                   // LB_RESETCONTENT          0x0184
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETSEL                0x0185
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETCURSEL             0x0186
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETSEL                0x0187
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETCURSEL             0x0188
    {IMSG_OUTLBOXSTRING,  TRUE,  TRUE},           // LB_GETTEXT               0x0189
    {IMSG_GETDBCSTEXTLENGTHS,  TRUE,  TRUE},      // LB_GETTEXTLEN            0x018A
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETCOUNT              0x018B
    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_SELECTSTRING          0x018C
    {IMSG_INSTRING,  TRUE,  FALSE},               // LB_DIR                   0x018D
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETTOPINDEX           0x018E
    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_FINDSTRING            0x018F

    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETSELCOUNT           0x0190
    {IMSG_POUTLPINT, FALSE,  TRUE},               // LB_GETSELITEMS           0x0191
    {IMSG_POPTINLPUINT, FALSE,  TRUE},            // LB_SETTABSTOPS           0x0192
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETHORIZONTALEXTENT   0x0193
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETHORIZONTALEXTENT   0x0194
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETCOLUMNWIDTH        0x0195
    {IMSG_INSTRING,  TRUE,  TRUE},                // LB_ADDFILE               0x0196
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETTOPINDEX           0x0197
    {IMSG_INOUTLPRECT, FALSE,  TRUE},             // LB_GETITEMRECT           0x0198
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETITEMDATA           0x0199
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETITEMDATA           0x019A
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SELITEMRANGE          0x019B
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETANCHORINDEX        0x019C
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETANCHORINDEX        0x019D
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETCARETINDEX         0x019E
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETCARETINDEX         0x019F

    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETITEMHEIGHT         0x01A0
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETITEMHEIGHT         0x01A1
    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_FINDSTRINGEXACT       0x01A2
    {IMSG_DWORD, FALSE, FALSE},                   // LBCB_CARETON             0x01A3
    {IMSG_DWORD, FALSE, FALSE},                   // LBCB_CARETOFF            0x01A4
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETLOCALE             0x01A5
    {IMSG_DWORD, FALSE, FALSE},                   // LB_GETLOCALE             0x01A6
    {IMSG_DWORD, FALSE, FALSE},                   // LB_SETCOUNT              0x01A7

    {IMSG_DWORD, FALSE, FALSE},                   // LB_INITSTORAGE           0x01A8

    {IMSG_DWORD, FALSE, FALSE},                   // LB_ITEMFROMPOINT         0x01A9
    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_INSERTSTRINGUPPER     0x01AA
    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_INSERTSTRINGLOWER     0x01AB
    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_ADDSTRINGUPPER        0x01AC
    {IMSG_INLBOXSTRING,  TRUE,  TRUE},            // LB_ADDSTRINGLOWER        0x01AD
    {IMSG_DWORD, FALSE, FALSE},                   // LBCB_STARTTRACK          0x01AE
    {IMSG_DWORD, FALSE, FALSE},                   // LBCB_ENDTRACK            0x01AF

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01B0
    {IMSG_EMPTY, FALSE, FALSE},                   // LB_MULTIPLEADDSTRING     0x01B1
    {IMSG_DWORD, FALSE,  TRUE},                   // LB_GETLISTBOXINFO        0x01B2
    {IMSG_RESERVED, FALSE, FALSE},                // LB_MSGMAX                0x01B3
    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01B4-0x01B7
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01B8-0x01BF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01C0-0x01C7
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01C8-0x01CF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01D0-0x01D7
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01D8-0x01DF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // MN_SETHMENU              0x01E0
    {IMSG_DWORD, FALSE, FALSE},                   // MN_GETHMENU              0x01E1
    {IMSG_DWORD, FALSE, FALSE},                   // MN_SIZEWINDOW            0x01E2
    {IMSG_DWORD, FALSE, FALSE},                   // MN_OPENHIERARCHY         0x01E3
    {IMSG_DWORD, FALSE, FALSE},                   // MN_CLOSEHIERARCHY        0x01E4
    {IMSG_DWORD, FALSE, FALSE},                   // MN_SELECTITEM            0x01E5
    {IMSG_DWORD, FALSE, FALSE},                   // MN_CANCELMENUS           0x01E6
    {IMSG_DWORD, FALSE, FALSE},                   // MN_SELECTFIRSTVALIDITEM  0x01E7

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x1E8 - 0x1E9
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},                   // MN_GETPPOPUPMENU(obsolete) 0x01EA
    {IMSG_OUTDWORDINDWORD, FALSE,  TRUE},         // MN_FINDMENUWINDOWFROMPOINT 0x01EB
    {IMSG_DWORD, FALSE, FALSE},                   // MN_SHOWPOPUPWINDOW         0x01EC
    {IMSG_DWORD, FALSE, FALSE},                   // MN_BUTTONDOWN              0x01ED
    {IMSG_DWORD, FALSE, FALSE},                   // MN_MOUSEMOVE               0x01EE
    {IMSG_DWORD, FALSE, FALSE},                   // MN_BUTTONUP                0x01EF
    {IMSG_DWORD, FALSE, FALSE},                   // MN_SETTIMERTOOPENHIERARCHY 0x01F0

    {IMSG_DWORD, FALSE, FALSE},                   // MN_DBLCLK                  0x01F1
    {IMSG_DWORD, FALSE, FALSE},                   // MN_ENDMENU                 0x01F2
    {IMSG_DWORD, FALSE, FALSE},                   // MN_DODRAGDROP              0x01F3
    {IMSG_DWORD, FALSE, FALSE},                   // MN_ENDMENU                 0x01F4

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01F5-0x01F7
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x01F8-0x01FF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // WM_MOUSEMOVE             0x0200
    {IMSG_DWORD, FALSE, FALSE},                   // WM_LBUTTONDOWN           0x0201
    {IMSG_DWORD, FALSE, FALSE},                   // WM_LBUTTONUP             0x0202
    {IMSG_DWORD, FALSE, FALSE},                   // WM_LBUTTONDBLCLK         0x0203
    {IMSG_DWORD, FALSE, FALSE},                   // WM_RBUTTONDOWN           0x0204
    {IMSG_DWORD, FALSE, FALSE},                   // WM_RBUTTONUP             0x0205
    {IMSG_DWORD, FALSE, FALSE},                   // WM_RBUTTONDBLCLK         0x0206
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MBUTTONDOWN           0x0207
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MBUTTONUP             0x0208
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MBUTTONDBLCLK         0x0209
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MOUSEWHEEL            0x020A
    {IMSG_DWORD, FALSE, FALSE},                   // WM_XBUTTONDOWN           0x020B
    {IMSG_DWORD, FALSE, FALSE},                   // WM_XBUTTONUP             0x020C
    {IMSG_DWORD, FALSE, FALSE},                   // WM_XBUTTONDBLCLK         0x020D
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x020E
    {IMSG_EMPTY, FALSE, FALSE},                   // empty                    0x020F

    {IMSG_DWORD, FALSE,  TRUE},                   // WM_PARENTNOTIFY          0x0210
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ENTERMENULOOP         0x0211
    {IMSG_DWORD, FALSE, FALSE},                   // WM_EXITMENULOOP          0x0212
    {IMSG_INOUTNEXTMENU, FALSE,  TRUE},           // WM_NEXTMENU              0x0213

    {IMSG_INOUTLPRECT, FALSE,  TRUE},             // WM_SIZING                0x0214
    {IMSG_DWORD, FALSE, FALSE},                   // WM_CAPTURECHANGED        0x0215
    {IMSG_INOUTLPRECT, FALSE,  TRUE},             // WM_MOVING                0x0216
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_POWERBROADCAST, FALSE, FALSE},          // WM_POWERBROADCAST        0x0218
    {IMSG_INDEVICECHANGE, FALSE, FALSE},          // WM_DEVICECHANGE          0x0219
    {IMSG_EMPTY, FALSE, FALSE},                   // 0x021A-0x021F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_INLPMDICREATESTRUCT,  TRUE,  TRUE},     // WM_MDICREATE             0x0220
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDIDESTROY            0x0221
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDIACTIVATE           0x0222
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDIRESTORE            0x0223
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDINEXT               0x0224
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDIMAXIMIZE           0x0225
    {IMSG_RESERVED, FALSE, FALSE},                // WM_MDITILE               0x0226
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDICASCADE            0x0227
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDIICONARRANGE        0x0228
    {IMSG_OPTOUTLPDWORDOPTOUTLPDWORD, FALSE,  TRUE}, // WM_MDIGETACTIVE       0x0229
    {IMSG_INOUTDRAG, FALSE,  TRUE},               // WM_DROPOBJECT            0x022A
    {IMSG_INOUTDRAG, FALSE,  TRUE},               // WM_QUERYDROPOBJECT       0x022B
    {IMSG_DWORD, FALSE, FALSE},                   // WM_BEGINDRAG             0x022C
    {IMSG_INOUTDRAG, FALSE,  TRUE},               // WM_DRAGLOOP              0x022D
    {IMSG_INOUTDRAG, FALSE,  TRUE},               // WM_DRAGSELECT            0x022E
    {IMSG_INOUTDRAG, FALSE,  TRUE},               // WM_DRAGMOVE              0x022F

    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDISETMENU            0x0230
    {IMSG_DWORD, FALSE, FALSE},                   // WM_ENTERSIZEMOVE         0x0231
    {IMSG_DWORD, FALSE, FALSE},                   // WM_EXITSIZEMOVE          0x0232

    {IMSG_EMPTY, FALSE, FALSE},                   // WM_DROPFILES             0x0233
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MDIREFRESHMENU        0x0234
    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0235-0x0237
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0238-0x023F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0240-0x0247
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0248-0x024F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0250-0x0257
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0258-0x025F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0260-0x0267
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0268-0x026F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0270-0x0277
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0278-0x027F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // WM_IME_REPORT            0x0280
    {IMSG_DWORD, FALSE,  TRUE},                   // WM_IME_SETCONTEXT        0x0281
    {IMSG_DWORD, FALSE, FALSE},                   // WM_IME_NOTIFY            0x0282
    {IMSG_IMECONTROL,  TRUE,  TRUE},              // WM_IME_CONTROL           0x0283
    {IMSG_DWORD, FALSE, FALSE},                   // WM_IME_COMPOSITIONFULL   0x0284
    {IMSG_DWORD, FALSE, FALSE},                   // WM_IME_SELECT            0x0285
    {IMSG_INWPARAMCHAR,  TRUE, FALSE},            // WM_IME_CHAR              0x0286
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x0288
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x0290
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x0298
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},                // WM_KANJILAST             0x029F

    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCMOUSEHOVER          0x02Ao
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MOUSEHOVER            0x02A1
    {IMSG_DWORD, FALSE, FALSE},                   // WM_NCMOUSELEAVE          0x02A2
    {IMSG_DWORD, FALSE, FALSE},                   // WM_MOUSELEAVE            0x02A3

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x02A4-0x02A7
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x02A8-0x02AF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x02B0-0x02B7
    {IMSG_DWORD, FALSE, FALSE},                   // WM_WTSSESSION_CHANGE
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x02B8-0x02BF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // 0x02C0-0x02DF
    {IMSG_DWORD, FALSE, FALSE},                   // reserved for WM_TABLET_xxx
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // 0x02C8-0x02CF
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // 0x02D0-0x02D7
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // 0x02D8-0x02DF
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},
    {IMSG_DWORD, FALSE, FALSE},                   // 0x02DF

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x02E0-0x02E7
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x02E8-0x02EF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x02F0-0x02F7
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x02F8-0x02FF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_DWORD, FALSE, FALSE},                   // WM_CUT                   0x0300
    {IMSG_DWORD, FALSE, FALSE},                   // WM_COPY                  0x0301
    {IMSG_DWORD, FALSE, FALSE},                   // WM_PASTE                 0x0302
    {IMSG_DWORD, FALSE, FALSE},                   // WM_CLEAR                 0x0303
    {IMSG_DWORD, FALSE, FALSE},                   // WM_UNDO                  0x0304
    {IMSG_DWORD, FALSE, FALSE},                   // WM_RENDERFORMAT          0x0305
    {IMSG_INDESTROYCLIPBRD,  TRUE, FALSE},        // WM_RENDERALLFORMATS      0x0306
    {IMSG_INDESTROYCLIPBRD,  TRUE, FALSE},        // WM_DESTROYCLIPBOARD      0x0307
    {IMSG_DWORD, FALSE, FALSE},                   // WM_DRAWCLIPBOARD         0x0308
    {IMSG_INPAINTCLIPBRD,  TRUE,  TRUE},          // WM_PAINTCLIPBOARD        0x0309
    {IMSG_DWORD, FALSE, FALSE},                   // WM_VSCROLLCLIPBOARD      0x030A
    {IMSG_INSIZECLIPBRD,  TRUE,  TRUE},           // WM_SIZECLIPBOARD         0x030B
    {IMSG_INCNTOUTSTRINGNULL,  TRUE,  TRUE},      // WM_ASKCBFORMATNAME       0x030C
    {IMSG_DWORD, FALSE, FALSE},                   // WM_CHANGECBCHAIN         0x030D
    {IMSG_DWORD, FALSE, FALSE},                   // WM_HSCROLLCLIPBOARD      0x030E
    {IMSG_DWORD, FALSE, FALSE},                   // WM_QUERYNEWPALETTE       0x030F

    {IMSG_DWORD, FALSE, FALSE},                   // WM_PALETTEISCHANGING     0x0310
    {IMSG_DWORD, FALSE, FALSE},                   // WM_PALETTECHANGED        0x0311
    {IMSG_DWORD, FALSE, FALSE},                   // WM_HOTKEY                0x0312

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0313-0x0316
    {IMSG_KERNELONLY, FALSE,  TRUE},              // WM_HOOKMSG               0x0314
    {IMSG_EMPTY, FALSE, FALSE},                   // WM_EXITPROCESS           0x0315
    {IMSG_EMPTY, FALSE, FALSE},                   // WM_WAKETHREAD            0x0316
    {IMSG_DWORD, FALSE, FALSE},                   // WM_PRINT                 0x0317

    {IMSG_DWORD, FALSE, FALSE},                   // WM_PRINTCLIENT           0x0318
    {IMSG_DWORD, FALSE, FALSE},                   // WM_APPCOMMAND            0x0319
    {IMSG_DWORD, FALSE, FALSE},                   // WM_THEMECHANGED          0x031A
    {IMSG_DWORD, FALSE, FALSE},                   // WM_UAHINIT               0x031B
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0320-0x0327
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0328-0x032F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0330-0x0337
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0338-0x033F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0340-0x0347
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0348-0x034F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0350-0x0357
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // reserved pen windows      0x0358-0x035F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0360-0x0367
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0368-0x036F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0370-0x0377
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0378-0x037F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0380-0x0387
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0388-0x038F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0390-0x0397
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x0398-0x039F
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // WM_MM_RESERVED_FIRST      0x03A0
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x03A8
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x03B0
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x03B7
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x03C0
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x03C7
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x03D0
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x03D7
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},                // WM_MM_RESERVED_LAST      0x03DF

    {IMSG_DDEINIT,  TRUE, FALSE},                 // WM_DDE_INITIATE          0x03E0
    {IMSG_DWORD,  TRUE, FALSE},                   // WM_DDE_TERMINATE         0x03E1
    {IMSG_SENTDDEMSG,  TRUE, FALSE},              // WM_DDE_ADVISE            0x03E2
    {IMSG_SENTDDEMSG,  TRUE, FALSE},              // WM_DDE_UNADVISE          0x03E3
    {IMSG_DWORD,  TRUE, FALSE},                   // WM_DDE_ACK               0x03E4
    {IMSG_SENTDDEMSG,  TRUE, FALSE},              // WM_DDE_DATA              0x03E5
    {IMSG_SENTDDEMSG,  TRUE, FALSE},              // WM_DDE_REQUEST           0x03E6
    {IMSG_SENTDDEMSG,  TRUE, FALSE},              // WM_DDE_POKE              0x03E7
    {IMSG_SENTDDEMSG,  TRUE, FALSE},              // WM_DDE_EXECUTE           0x03E8

    {IMSG_EMPTY, FALSE, FALSE},                   // 0x03E9-0x03EF
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},
    {IMSG_EMPTY, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // WM_CBT_RESERVED_FIRST     0x03F0
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},

    {IMSG_RESERVED, FALSE, FALSE},                // 0x03F8
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},
    {IMSG_RESERVED, FALSE, FALSE},                // WM_CBT_RESERVED_LAST      0x03FF
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\inc\csrhlpr.h ===
/****************************** Module Header ******************************\
* Module Name: csrhlpr.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains the prototypes for functions that marshel data
* for LPC from USER32 to CSR and are not found anywhere else.
*
* History:
* 10-21-98 mzoran     Created.
\***************************************************************************/

NTSTATUS
APIENTRY
CallUserpExitWindowsEx(
    IN UINT uFlags,
    OUT PBOOL pfSuccess);

NTSTATUS
APIENTRY
CallUserpRegisterLogonProcess(
    IN DWORD dwProcessId);

VOID
APIENTRY
Logon(
    IN BOOL fLogon);

VOID
APIENTRY
CsrWin32HeapFail(
    IN DWORD dwFlags,
    IN BOOL  bFail);

UINT
APIENTRY
CsrWin32HeapStat(
    PDBGHEAPSTAT    phs,
    DWORD   dwLen);

NTSTATUS
APIENTRY
UserConnectToServer(
    IN PWSTR ObjectDirectory,
    IN OUT PUSERCONNECT ConnectionInformation,
    IN OUT PULONG ConnectionInformationLength OPTIONAL,
    OUT PBOOLEAN CalledFromServer OPTIONAL
    );

#if !defined(BUILD_WOW6432) || defined(_WIN64)

_inline
NTSTATUS
UserConnectToServer(
    IN PWSTR ObjectDirectory,
    IN OUT PUSERCONNECT ConnectionInformation,
    IN OUT PULONG ConnectionInformationLength OPTIONAL,
    OUT PBOOLEAN CalledFromServer OPTIONAL
    ) {

    return CsrClientConnectToServer(ObjectDirectory,
                                    USERSRV_SERVERDLL_INDEX,
                                    ConnectionInformation,
                                    ConnectionInformationLength,
                                    CalledFromServer);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\inc\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\inc\ntsend.h ===
/**************************************************************************\
* Module Name: ntsend.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* client-side macros for kernel-mode
*
* 03-21-95 JimA             Created.
\**************************************************************************/

/*
 * The BEGINCALLCONNECT macro ensures that the thread is set up correctly.
 */
#define BEGINCALLCONNECT()                              \
    {                                                   \
    ULONG_PTR retval;                                    \
    {                                                   \
        if (NtCurrentTeb()->Win32ThreadInfo == NULL) {  \
            if (!USERTHREADCONNECT()) { \
                MSGERROR();                             \
            }                                           \
        }

/*
 * Use this macro if you don't need to access shared memory.
 */
#define BEGINCALL()       \
    {                     \
    ULONG_PTR retval;      \
    {

#define BEGINCALL_CLASSV()                                                              \
    {                                                                                   \
    ULONG_PTR retval;                                                                   \
    TCHAR ClassNameVer[MAX_ATOM_LEN];                                                   \
    LPTSTR lpClassNameVer;                                                              \
    {                                                                                   \
        lpClassNameVer = (LPTSTR)ClassNameToVersion((LPCWSTR)pszClassName,              \
                                          (LPWSTR)ClassNameVer, NULL, IS_ANSI);         \
        if (lpClassNameVer == NULL) {                                                   \
            RIPMSG0(RIP_WARNING, "Couldn't resolve class name");                        \
            MSGERROR();                                                                 \
        }

#define BEGINCALLVOID()   \
    {

#define ERRORTRAP(error) \
       goto cleanup;        \
    }                       \
    goto errorexit;         \
errorexit:                  \
    retval = (ULONG_PTR)error; \
cleanup:

#define ERRORTRAPVOID()     \
    goto errorexit;         \
errorexit:

#define ENDCALL(type)     \
    return (type)retval;  \
    }

#define ENDCALLVOID() \
    return;           \
    }

#define MSGERROR() goto errorexit

#define MSGERRORCODE(code) { \
    RIPERR0(code, RIP_WARNING, "Unspecified error"); \
    goto errorexit; }

#define MSGNTERRORCODE(code) { \
    RIPNTERR0(code, RIP_WARNING, "Unspecified error"); \
    goto errorexit; }

#define MESSAGECALL(api) \
LRESULT api(             \
    HWND hwnd,           \
    UINT msg,            \
    WPARAM wParam,       \
    LPARAM lParam,       \
    ULONG_PTR xParam,     \
    DWORD xpfnProc,      \
    BOOL bAnsi)

/*
 * Copy optional string/Ordinal where if hiword is FF/FFFF then new WORD is a
 * resource oridinal ID
 * Sources is Unicode
 */
#define OrdinalLPSTR(src)   (MAKELONG(0xFFFF,((*(DWORD UNALIGNED *)src) >> 8)))
#define OrdinalLPSTRW(src)  (MAKELONG(0xFFFF,((*(DWORD UNALIGNED *)src) >> 8)))
#define OrdinalLPWSTR(src)  (*(DWORD UNALIGNED *)src)
#define OrdinalLPWSTRA(src) (*(DWORD UNALIGNED *)((PBYTE)src + 1))

/*
 * Ansi->Unicode macros
 */
#define COPYLPSTRW(pinstr, psz) \
    if (!RtlCaptureAnsiString((pinstr), (LPCSTR)(psz), TRUE))     \
        MSGERROR();

#define COPYLPSTRIDW(pinstr, psz) \
    if (IS_PTR(psz)) {                                      \
        if (!RtlCaptureAnsiString((pinstr), (LPCSTR)(psz), TRUE))   \
            MSGERROR();                                     \
    }                                                       \
    else {                                                  \
        (pinstr)->fAllocated = FALSE;                       \
        (pinstr)->pstr = &(pinstr)->strCapture;             \
        (pinstr)->strCapture.Length =                       \
                (pinstr)->strCapture.MaximumLength = 0;     \
        (pinstr)->strCapture.Buffer = (LPWSTR)(psz);        \
    }

#define COPYLPSTRIDOPTW     COPYLPSTRIDW
#define COPYLPSTROPTW       COPYLPSTRW

#define LARGECOPYLPSTRW(pinstr, psz) \
    if(!RtlCaptureLargeAnsiString((pinstr), (LPCSTR)(psz), TRUE)) \
        MSGERROR();

#define LARGECOPYLPSTROPTW  LARGECOPYLPSTRW

#define LARGECOPYLPSTRORDINALOPTW(pinstr, psz) \
    (pinstr)->pstr = &(pinstr)->strCapture;                                         \
    (pinstr)->fAllocated = FALSE;                                                   \
    if (psz) {                                                                      \
        if (*(LPBYTE)(psz) != 0xff) {                                               \
            if (!RtlCaptureLargeAnsiString((pinstr), (LPCSTR)(psz), TRUE))          \
                MSGERROR();                                                         \
        } else {                                                                    \
            (pinstr)->strCapture.Length =                                           \
                    (pinstr)->strCapture.MaximumLength = sizeof(DWORD);             \
            dwOrdinal = OrdinalLPSTRW(psz);                                         \
            (pinstr)->strCapture.Buffer = (LPWSTR)&dwOrdinal;                       \
        }                                                                           \
    } else {                                                                        \
        (pinstr)->strCapture.Length =                                               \
                (pinstr)->strCapture.MaximumLength = 0;                             \
        (pinstr)->strCapture.Buffer = NULL;                                         \
    }

#define FIRSTCOPYLPSTRW(pinstr, psz) \
    if (!RtlCaptureAnsiString((pinstr), (LPCSTR)(psz), FALSE))    \
        MSGERROR();

#define FIRSTCOPYLPSTRIDW(pinstr, psz) \
    if (IS_PTR(psz)) {                                      \
        if (!RtlCaptureAnsiString((pinstr), (LPCSTR)(psz), FALSE))  \
            MSGERROR();                                     \
    } else {                                                \
        (pinstr)->fAllocated = FALSE;                       \
        (pinstr)->pstr = &(pinstr)->strCapture;             \
        (pinstr)->strCapture.Length =                       \
                (pinstr)->strCapture.MaximumLength = 0;     \
        (pinstr)->strCapture.Buffer = (LPWSTR)(psz);        \
    }

#define FIRSTCOPYLPSTRIDOPTW     FIRSTCOPYLPSTRIDW
#define FIRSTCOPYLPSTROPTW       FIRSTCOPYLPSTRW

#define FIRSTLARGECOPYLPSTRW(pinstr, psz) \
    if (!RtlCaptureLargeAnsiString((pinstr), (LPCSTR)(psz), FALSE))   \
        MSGERROR();

#define FIRSTLARGECOPYLPSTROPTW  FIRSTLARGECOPYLPSTRW

#define FIRSTLARGECOPYLPSTRORDINALOPTW(pinstr, psz) \
    (pinstr)->pstr = &(pinstr)->strCapture;                                             \
    (pinstr)->fAllocated = FALSE;                                                       \
    if (psz) {                                                                          \
        if (*(LPBYTE)(psz) != 0xff) {                                                   \
            if (!RtlCaptureLargeAnsiString((pinstr), (LPCSTR)(psz), FALSE))             \
                MSGERROR();                                                             \
        } else {                                                                        \
            (pinstr)->strCapture.Length =                                               \
                    (pinstr)->strCapture.MaximumLength = sizeof(DWORD);                 \
            dwOrdinal = OrdinalLPSTRW(psz);                                             \
            (pinstr)->strCapture.Buffer = (LPWSTR)&dwOrdinal;                           \
        }                                                                               \
    } else {                                                                            \
        (pinstr)->strCapture.Length =                                                   \
                (pinstr)->strCapture.MaximumLength = 0;                                 \
        (pinstr)->strCapture.Buffer = NULL;                                             \
    }

#define CLEANUPLPSTRW(instr) \
    if (instr.fAllocated)                     \
        RtlFreeHeap(pUserHeap, 0, KPVOID_TO_PVOID(instr.strCapture.Buffer));

/*
 * Unicode->Unicode macros
 */
#define COPYLPWSTR(pinstr, psz) \
    (pinstr)->fAllocated = FALSE;                           \
    (pinstr)->pstr = &(pinstr)->strCapture;                 \
    RtlInitUnicodeString(&(pinstr)->strCapture, (psz));

#define COPYLPWSTRID(pinstr, psz) \
    (pinstr)->fAllocated = FALSE;                           \
    (pinstr)->pstr = &(pinstr)->strCapture;                 \
    if (IS_PTR(psz))                                        \
        RtlInitUnicodeString(&(pinstr)->strCapture, (psz)); \
    else {                                                  \
        (pinstr)->strCapture.Length =                       \
                (pinstr)->strCapture.MaximumLength = 0;     \
        (pinstr)->strCapture.Buffer = (LPWSTR)(psz);        \
    }

#define COPYLPWSTRIDOPT     COPYLPWSTRID
#define COPYLPWSTROPT       COPYLPWSTR

#define LARGECOPYLPWSTR(pinstr, psz) \
    (pinstr)->fAllocated = FALSE;                           \
    (pinstr)->pstr = &(pinstr)->strCapture;                         \
    RtlInitLargeUnicodeString(&(pinstr)->strCapture, (psz), (UINT)-1);

#define LARGECOPYLPWSTROPT  LARGECOPYLPWSTR

#define LARGECOPYLPWSTRORDINALOPT(pinstr, psz) \
    (pinstr)->fAllocated = FALSE;                           \
    (pinstr)->pstr = &(pinstr)->strCapture;                                     \
    if (psz) {                                                                  \
        if (*(LPWORD)(psz) != 0xffff)                                           \
            RtlInitLargeUnicodeString(&(pinstr)->strCapture, (psz), (UINT)-1);  \
        else {                                                                  \
            (pinstr)->strCapture.Length =                                       \
                    (pinstr)->strCapture.MaximumLength = sizeof(DWORD);         \
            dwOrdinal = OrdinalLPWSTR(psz);                                     \
            (pinstr)->strCapture.Buffer = (LPWSTR)&dwOrdinal;                   \
        }                                                                       \
    } else {                                                                    \
        (pinstr)->strCapture.Length =                                           \
                (pinstr)->strCapture.MaximumLength = 0;                         \
        (pinstr)->strCapture.Buffer = NULL;                                     \
    }

#define FIRSTCOPYLPWSTR                 COPYLPWSTR
#define FIRSTCOPYLPWSTRID               COPYLPWSTRID
#define FIRSTCOPYLPWSTRIDOPT            COPYLPWSTRIDOPT
#define FIRSTCOPYLPWSTROPT              COPYLPWSTROPT
#define FIRSTLARGECOPYLPWSTR            LARGECOPYLPWSTR
#define FIRSTLARGECOPYLPWSTROPT         LARGECOPYLPWSTROPT
#define FIRSTLARGECOPYLPWSTRORDINALOPT  LARGECOPYLPWSTRORDINALOPT

#define CLEANUPLPWSTR(instr)

/*
 * Type-neutral macros
 */
#ifdef UNICODE

#define COPYLPTSTR                  COPYLPWSTR
#define COPYLPTSTRID                COPYLPWSTRID
#define COPYLPTSTRIDOPT             COPYLPWSTRIDOPT
#define COPYLPTSTROPT               COPYLPWSTROPT
#define FIRSTCOPYLPTSTR             COPYLPWSTR
#define FIRSTCOPYLPTSTRID           COPYLPWSTRID
#define FIRSTCOPYLPTSTRIDOPT        COPYLPWSTRIDOPT
#define LARGECOPYLPTSTR             LARGECOPYLPWSTR
#define LARGECOPYLPTSTROPT          LARGECOPYLPWSTROPT
#define FIRSTLARGECOPYLPTSTROPT     LARGECOPYLPWSTROPT
#define CLEANUPLPTSTR               CLEANUPLPWSTR

#else

#define COPYLPTSTR                  COPYLPSTRW
#define COPYLPTSTRID                COPYLPSTRIDW
#define COPYLPTSTRIDOPT             COPYLPSTRIDOPTW
#define COPYLPTSTROPT               COPYLPSTROPTW
#define FIRSTCOPYLPTSTR             COPYLPSTRW
#define FIRSTCOPYLPTSTRID           COPYLPSTRIDW
#define FIRSTCOPYLPTSTRIDOPT        COPYLPSTRIDOPTW
#define LARGECOPYLPTSTR             LARGECOPYLPSTRW
#define LARGECOPYLPTSTROPT          LARGECOPYLPSTROPTW
#define FIRSTLARGECOPYLPTSTROPT     LARGECOPYLPSTROPTW
#define CLEANUPLPTSTR               CLEANUPLPSTRW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\inc\sources.inc ===
#****************************** File Header ******************************\
# File Name: Sources.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# This file is used to build generated header files (specifed in NTTARGETFILE0).
#  Building rules are specified in MAKEFILE.INC.
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include $(WINCORE_PATH)\core.inc

PASS0ONLY=1
NOPASS0=1

TARGETTYPE=NOTARGET
SOURCES=
TARGETPATH=

NTTARGETFILE0=$(O)\cscall.h $(O)\scf.lst $(O)\callback.h $(O)\cb.lst $(O)\msgdef.h $(O)\msgdef.lst

SYNCHRONIZE_BLOCK=1

SOURCES_USED=..\sources.inc $(WINCORE_PATH)\core.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\inc\keizon\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\inc\wow6432\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\inc\ntcb.h ===
/****************************** Module Header ******************************\
* Module Name: ntcb.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Kernel mode sending stubs
*
* 07-06-91 ScottLu      Created.
\***************************************************************************/

/*
 * Reserved bit in the Drive Letter bit mask of a
 * WM_DEVICECHANGE message for the following wParam
 * (DBT_DEVICEREMOVECOMPLETE or DBT_DEVICEARRIVAL)
 * If this bit is set, then this message describes a change with
 * global drive letters and we should check if the drive letters
 * already exist in the receiver's LUID DosDevices.
 * If drive letter exists in the user's LUID DosDevices, then
 * un-set this drive letter in the msg's bitmask.
 */
#define DBV_FILTER_MSG 0x40000000

// If SERVER is UNICODE
//   Copy UNICODE -> UNICODE
//   or Copy ANSI -> UNICODE

// prototypes to client side functions only called by these stubs

// ddetrack.c

DWORD   _ClientCopyDDEIn1(HANDLE hClient, PINTDDEINFO pi);
VOID   _ClientCopyDDEIn2(PINTDDEINFO pi);
HANDLE _ClientCopyDDEOut1(PINTDDEINFO pi);
BOOL xxxClientCopyDDEIn2(PINTDDEINFO pi);
BOOL FixupDdeExecuteIfNecessary(HGLOBAL *phCommands, BOOL fNeedUnicode);
BOOL   _ClientCopyDDEOut2(PINTDDEINFO pi);
BOOL   _ClientFreeDDEHandle(HANDLE hDDE, DWORD flags);
DWORD  _ClientGetDDEFlags(HANDLE hDDE, DWORD flags);

/*
 * prototype for checking the drive letters used in the LUID DosDevice
 * map.  Does not check if the drive letters are used in the Global
 * DosDevices
 */
#ifdef RECVSIDE
DWORD  GetLUIDDosDrivesOnly();
#endif // RECVSIDE

typedef struct _GENERICHOOKHEADER {
    DWORD nCode;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} GENERICHOOKHEADER, * LPGENERICHOOKHEADER;

#ifdef RECVSIDE
ULONG_PTR CallHookWithSEH(GENERICHOOKHEADER *pmsg, LPVOID pData, LPDWORD pFlags, ULONG_PTR retval) {

    try {
        retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
                pmsg->nCode,
                pmsg->wParam,
                pData,
                pmsg->xParam);

    } except ((*pFlags & HF_GLOBAL) ? W32ExceptionHandler(FALSE, RIP_WARNING) : EXCEPTION_CONTINUE_SEARCH) {
        RIPMSG0(RIP_WARNING, "Hook Faulted");
        *pFlags |= HF_HOOKFAULTED;
    }

    return retval;
}
#endif // RECVSIDE

/**************************************************************************\
* fnOUTDWORDDWORD
*
* 14-Aug-1992 mikeke    created
\**************************************************************************/

typedef struct _FNOUTDWORDDWORDMSG {
    PWND pwnd;
    UINT msg;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNOUTDWORDDWORDMSG;

#ifdef SENDSIDE
SMESSAGECALL(OUTDWORDDWORD)
{
    SETUPPWND(FNOUTDWORDDWORD)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNOUTDWORDDWORD)

        LPDWORD lpdwW = (LPDWORD)wParam;
        LPDWORD lpdwL = (LPDWORD)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNOUTDWORDDWORD);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            try {
                *lpdwW = ProbeAndReadUlong((LPDWORD)pcbs->pOutput);
                *lpdwL = ProbeAndReadUlong((LPDWORD)pcbs->pOutput + 1);
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                MSGERROR();
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnOUTDWORDDWORD");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnOUTDWORDDWORD, FNOUTDWORDDWORDMSG)
{
    DWORD adwOut[2];
    BEGINRECV(0, adwOut, sizeof(adwOut));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            &adwOut[0],
            &adwOut[1],
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnOUTDWORDINDWORD
*
* 04-May-1993 IanJa     created (for MN_FINDMENUWINDOWFROMPOINT)
\**************************************************************************/

typedef struct _FNOUTDWORDINDWORDMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNOUTDWORDINDWORDMSG;

#ifdef SENDSIDE
SMESSAGECALL(OUTDWORDINDWORD)
{
    SETUPPWND(FNOUTDWORDINDWORD)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNOUTDWORDINDWORD)

        LPDWORD lpdwW = (LPDWORD)wParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->lParam = lParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNOUTDWORDINDWORD);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            try {
                *lpdwW = ProbeAndReadUlong((LPDWORD)pcbs->pOutput);
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                MSGERROR();
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnOUTDWORDINDWORD");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnOUTDWORDINDWORD, FNOUTDWORDINDWORDMSG)
{
    DWORD dwOut;
    BEGINRECV(0, &dwOut, sizeof(dwOut));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            &dwOut,
            CALLDATA(lParam),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnOPTOUTLPDWORDOPTOUTLPDWORD
*
* 25-Nov-1992 JonPa    created
\**************************************************************************/

typedef struct _FNOPTOUTLPDWORDOPTOUTLPDWORDMSG {
    PWND pwnd;
    UINT msg;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNOPTOUTLPDWORDOPTOUTLPDWORDMSG;

#ifdef SENDSIDE
SMESSAGECALL(OPTOUTLPDWORDOPTOUTLPDWORD)
{
    SETUPPWND(FNOPTOUTLPDWORDOPTOUTLPDWORD)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNOPTOUTLPDWORDOPTOUTLPDWORD)

        LPDWORD lpdwW = (LPDWORD)wParam;
        LPDWORD lpdwL = (LPDWORD)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNOPTOUTLPDWORDOPTOUTLPDWORD);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            try {
                if (lpdwW != NULL)
                    *lpdwW = ProbeAndReadUlong((LPDWORD)pcbs->pOutput);
                if (lpdwL != NULL)
                    *lpdwL = ProbeAndReadUlong((LPDWORD)pcbs->pOutput + 1);
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                MSGERROR();
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnOPTOUTLPDWORDOPTOUTLPDWORD");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnOPTOUTLPDWORDOPTOUTLPDWORD, FNOPTOUTLPDWORDOPTOUTLPDWORDMSG)
{
    DWORD adwOut[2];
    BEGINRECV(0, adwOut, sizeof(adwOut));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            &adwOut[0],
            &adwOut[1],
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnDWORDOPTINLPMSG
*
* 03-30-92 scottlu      Created
\**************************************************************************/

typedef struct _FNDWORDOPTINLPMSGMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPMSG pmsgstruct;
    ULONG_PTR xParam;
    PROC xpfnProc;
    MSG msgstruct;
} FNDWORDOPTINLPMSGMSG;

#ifdef SENDSIDE
SMESSAGECALL(DWORDOPTINLPMSG)
{
    SETUPPWND(FNDWORDOPTINLPMSG)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNDWORDOPTINLPMSG)

        LPMSG pmsgstruct = (LPMSG)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        COPYSTRUCTOPT(msgstruct);
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNDWORDOPTINLPMSG);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnDWORDOPTINLPMSG");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnDWORDOPTINLPMSG, FNDWORDOPTINLPMSGMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            PCALLDATAOPT(msgstruct),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnCOPYGLOBALDATA
*
* 6-20-92 Sanfords created
\**************************************************************************/

typedef struct _FNCOPYGLOBALDATAMSG {
    CAPTUREBUF CaptureBuf;
    DWORD cbSize;
    PBYTE pData;
} FNCOPYGLOBALDATAMSG;

#ifdef SENDSIDE
SMESSAGECALL(COPYGLOBALDATA)
{
    PBYTE pData = (PBYTE)lParam;

    SETUPPWND(FNCOPYGLOBALDATA)

    UNREFERENCED_PARAMETER(msg);
    UNREFERENCED_PARAMETER(xParam);
    UNREFERENCED_PARAMETER(xpfnProc);
    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSENDCAPTURE(FNCOPYGLOBALDATA, 1, wParam, TRUE)

        if (pData == 0) {
            MSGERROR();
        }

        MSGDATA()->cbSize = (DWORD)wParam;
        LARGECOPYBYTES(pData, (DWORD)wParam);

        LOCKPWND();
        MAKECALLCAPTURE(FNCOPYGLOBALDATA);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnCOPYGLOBALDATA");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnCOPYGLOBALDATA, FNCOPYGLOBALDATAMSG)
{
    PBYTE p;

    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)GlobalAlloc(GMEM_MOVEABLE, CALLDATA(cbSize));
    if (p = GlobalLock((HANDLE)retval)) {

        memcpy(p, (PVOID)CALLDATA(pData), CALLDATA(cbSize));
        USERGLOBALUNLOCK((HANDLE)retval);

    }

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnCOPYDATA
*
* 7-14-92 Sanfords created
\**************************************************************************/

typedef struct _FNCOPYDATAMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    HWND hwndFrom;
    BOOL fDataPresent;
    COPYDATASTRUCT cds;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNCOPYDATAMSG;

#ifdef SENDSIDE
SMESSAGECALL(COPYDATA)
{
    HWND hwndFrom = (HWND)wParam;
    PCOPYDATASTRUCT pcds = (PCOPYDATASTRUCT)lParam;
    DWORD cCapture, cbCapture;

    SETUPPWND(FNCOPYDATA)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    if (pcds == NULL) {
        cCapture = cbCapture = 0;
    } else {
        cCapture = 1;
        cbCapture = pcds->cbData;
    }
    BEGINSENDCAPTURE(FNCOPYDATA, cCapture, cbCapture, TRUE);

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->hwndFrom = hwndFrom;
        if (pcds != NULL) {
            MSGDATA()->fDataPresent = TRUE;
            MSGDATA()->cds = *pcds;
            LARGECOPYBYTES2(pcds->lpData, cbCapture, cds.lpData);
        } else {
            MSGDATA()->fDataPresent = FALSE;
        }
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNCOPYDATA);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnCOPYDATA");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnCOPYDATA, FNCOPYDATAMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = CALLPROC(CALLDATA(xpfnProc))(
        CALLDATA(pwnd),
        CALLDATA(msg),
        CALLDATA(hwndFrom),
        CALLDATA(fDataPresent) ? PCALLDATA(cds) : NULL,
        CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE


/**************************************************************************\
* fnSENTDDEMSG
*
* 11-5-92 Sanfords created
*
*   This thunks DDE messages that SHOULD be posted.  It will only work for
*   WOW apps.  This thunking is strictly for WOW compatability.  No 32 bit
*   app should be allowed to get away with this practice because it opens
*   the DDE protocol up to deadlocks.
\**************************************************************************/

typedef struct _FNSENTDDEMSGMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    BOOL fIsUnicodeProc;
} FNSENTDDEMSGMSG;

#ifdef SENDSIDE
SMESSAGECALL(SENTDDEMSG)
{
    MSG msgs;

    SETUPPWND(FNSENTDDEMSG)

    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNSENTDDEMSG)

        msg &= ~MSGFLAG_DDE_SPECIAL_SEND;
        if (msg & MSGFLAG_DDE_MID_THUNK) {
            /*
             * complete the thunking here.
             */
            msgs.hwnd = HW(pwnd);
            msgs.message = msg & ~MSGFLAG_DDE_MID_THUNK;
            msgs.wParam = wParam;
            msgs.lParam = lParam;
            xxxDDETrackGetMessageHook((PMSG)&msgs);

            MSGDATA()->pwnd = (PWND)((PBYTE)PW(msgs.hwnd) -
                    pci->ulClientDelta);
            MSGDATA()->msg = msgs.message;
            MSGDATA()->wParam = msgs.wParam;
            MSGDATA()->lParam = msgs.lParam;
        } else {
            MSGDATA()->pwnd = pwndClient;
            MSGDATA()->msg = msg;
            MSGDATA()->wParam = wParam;
            MSGDATA()->lParam = lParam;
        }
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;
        MSGDATA()->fIsUnicodeProc = !(dwSCMSFlags & SCMS_FLAGS_ANSI);

        LOCKPWND();
        MAKECALL(FNSENTDDEMSG);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnSENTDDEMSG");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnSENTDDEMSG, FNSENTDDEMSGMSG)
{
    BEGINRECV(0, NULL, 0);

    /*
     * A DDE message may have been sent via CallWindowProc due to subclassing.
     * Since IsWindowUnicode() cannot properly tell what proc a message will
     * ultimately reach, we make sure that the Ansi/Unicode form of any
     * WM_DDE_EXECUTE data is correct for the documented convention and
     * translate it as necessary.
     */
    if (CALLDATA(msg) == WM_DDE_EXECUTE) {
        BOOL fHandleChanged;

        fHandleChanged = FixupDdeExecuteIfNecessary((HGLOBAL *)PCALLDATA(lParam),
                CALLDATA(fIsUnicodeProc) &&
                IsWindowUnicode((HWND)CALLDATA(wParam)));
        /*
         * NOTE:
         * If the app didn't allocate this DDE memory GMEM_MOVEABLE,
         * the fixup may require the handle value to change.
         * If this happens things will fall appart when the other side
         * or the tracking layer tries to free the old handle value.
         */
        UserAssert(!fHandleChanged);
    }
    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            CALLDATA(lParam),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnDWORD
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNDWORDMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNDWORDMSG;

#ifdef SENDSIDE
SMESSAGECALL(DWORD)
{
    SETUPPWND(FNDWORD)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNDWORD)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->lParam = lParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNDWORD);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnDWORD");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnDWORD, FNDWORDMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            CALLDATA(lParam),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnNCDESTROY
*
* 07-24-00 MHamid    Created
\**************************************************************************/

typedef struct _FNNCDESTROYMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNNCDESTROYMSG;

#ifdef SENDSIDE
SMESSAGECALL(NCDESTROY)
{
    SETUPPWND(FNNCDESTROY)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNNCDESTROY)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->lParam = lParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNNCDESTROY);
        pwnd->pActCtx = NULL;
#ifdef LAME_BUTTON
        pwnd->pStackTrace = NULL;
#endif // LAME_BUTTON
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnNCDESTROY");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnNCDESTROY, FNNCDESTROYMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            CALLDATA(lParam),
            CALLDATA(xParam));

    if (CALLDATA(pwnd)->pActCtx) {
        RtlReleaseActivationContext(CALLDATA(pwnd)->pActCtx);
    }

#ifdef LAME_BUTTON
    if (CALLDATA(pwnd)->pStackTrace != NULL) {
        UserLocalFree(CALLDATA(pwnd)->pStackTrace);
    }
#endif // LAME_BUTTON

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINWPARAMCHAR
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINWPARAMCHARMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINWPARAMCHARMSG;

#ifdef SENDSIDE
SMESSAGECALL(INWPARAMCHAR)
{
    SETUPPWND(FNINWPARAMCHAR)

    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINWPARAMCHAR)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;

        /*
         * WM_CHARTOITEM has an index in the hi-word of wParam
         */
        if (dwSCMSFlags & SCMS_FLAGS_ANSI) {
            if (msg == WM_CHARTOITEM || msg == WM_MENUCHAR) {
                WPARAM dwT = wParam & 0xFFFF;                // mask of caret pos
                RtlWCSMessageWParamCharToMB(msg, &dwT);     // convert key portion
                UserAssert(HIWORD(dwT) == 0);
                wParam = MAKELONG(LOWORD(dwT),HIWORD(wParam));  // rebuild pos & key wParam
            } else {
                RtlWCSMessageWParamCharToMB(msg, &wParam);
            }
        }

        MSGDATA()->wParam = wParam;

        MSGDATA()->lParam = lParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNDWORD);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINWPARAMCHAR");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
/*
 * The fnDWORD routine is used for this message
 */
#endif // RECVSIDE

/**************************************************************************\
* fnINWPARAMDBCSCHAR
*
* 12-Feb-1996 hideyukn   Created
\**************************************************************************/

typedef struct _FNINWPARAMDBCSCHARMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    BOOL  bAnsi;
} FNINWPARAMDBCSCHARMSG;

#ifdef SENDSIDE
SMESSAGECALL(INWPARAMDBCSCHAR)
{
    SETUPPWND(FNINWPARAMDBCSCHAR)

    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINWPARAMDBCSCHAR)

        MSGDATA()->pwnd  = pwndClient;
        MSGDATA()->msg   = msg;
        MSGDATA()->bAnsi = dwSCMSFlags & SCMS_FLAGS_ANSI;

        /*
         * wParam in WM_CHAR/EM_SETPASSWORDCHAR should be converted to ANSI
         * ,if target is ANSI.
         */
        if (dwSCMSFlags & SCMS_FLAGS_ANSI) {
            RtlWCSMessageWParamCharToMB(msg, &wParam);
        }

        MSGDATA()->wParam = wParam;
        MSGDATA()->lParam = lParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINWPARAMDBCSCHAR);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINWPARAMDBCSCHAR");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINWPARAMDBCSCHAR, FNINWPARAMDBCSCHARMSG)
{
    BOOL bAnsiWndProc;

    BEGINRECV(0,NULL,0);

        bAnsiWndProc = CALLDATA(bAnsi);

        if (bAnsiWndProc) {

            PKERNEL_MSG  pmsgDbcsCB = GetCallBackDbcsInfo();
            WPARAM wParam         = pmsg->wParam;
            BOOL  bDbcsMessaging = FALSE;

            //
            // Check wParam has Dbcs character or not..
            //
            if (IS_DBCS_MESSAGE(pmsg->wParam)) {

                if (pmsg->wParam & WMCR_IR_DBCSCHAR) {

                    //
                    // This is reply for WM_IME_REPORT:IR_DBCSCHAR, then
                    // We send DBCS chararcter at one time...
                    // (Do not need to send twice for DBCS LeadByte and TrailByte).
                    //
                    // Validation for wParam.. (mask off the secret bit).
                    //
                    wParam = (pmsg->wParam & 0x0000FFFF);

                } else {

                    //
                    // Mark the wParam keeps Dbcs character..
                    //
                    bDbcsMessaging = TRUE;

                    //
                    // Backup current message. this backupped message will be used
                    // when Apps peek (or get) message from thier WndProc.
                    // (see GetMessageA(), PeekMessageA()...)
                    //
                    // pmsgDbcsCB->hwnd    = HW(pmsg->pwnd);
                    // pmsgDbcsCB->message = pmsg->msg;
                    // pmsgDbcsCB->wParam  = pmsg->wParam;
                    // pmsgDbcsCB->lParam  = pmsg->lParam;
                    // pmsgDbcsCB->time    = pmsg->time;
                    // pmsgDbcsCB->pt      = pmsg->pt;
                    //
                    COPY_MSG_TO_KERNELMSG(pmsgDbcsCB,(PMSG)pmsg);

                    //
                    // pwnd should be converted to hwnd.
                    //
                    pmsgDbcsCB->hwnd = HW(pmsg->pwnd);

                    //
                    // DbcsLeadByte will be sent below soon, we just need DbcsTrailByte
                    // for further usage..
                    //
                    pmsgDbcsCB->wParam = (pmsg->wParam & 0x000000FF);

                    //
                    // Pass the LeadingByte of the DBCS character to an ANSI WndProc.
                    //
                    wParam = (pmsg->wParam & 0x0000FF00) >> 8;
                }
            }

            //
            // Forward Dbcs LeadingByte or Sbcs character to Apps WndProc.
            //
            retval = CALLPROC(CALLDATA(xpfnProc))(
                    CALLDATA(pwnd),
                    CALLDATA(msg),
                    wParam,
                    CALLDATA(lParam),
                    CALLDATA(xParam) );

            //
            // Check we need to send trailing byte or not, if the wParam has Dbcs character.
            //
            if (bDbcsMessaging && pmsgDbcsCB->wParam) {

                //
                // If an app didn't peek (or get) the trailing byte from within
                // WndProc, and then pass the DBCS TrailingByte to the ANSI WndProc here
                // pmsgDbcsCB->wParam has DBCS TrailingByte here.. see above..
                //
                wParam = KERNEL_WPARAM_TO_WPARAM(pmsgDbcsCB->wParam);

                //
                // Invalidate cached message.
                //
                pmsgDbcsCB->wParam = 0;

                retval = CALLPROC(CALLDATA(xpfnProc))(
                        CALLDATA(pwnd),
                        CALLDATA(msg),
                        wParam,
                        CALLDATA(lParam),
                        CALLDATA(xParam) );
            } else {

                //
                // If an app called Get/PeekMessageA from its
                // WndProc, do not do anything.
                //
            }

        } else {

            //
            // Only LOWORD of WPARAM is valid for WM_CHAR....
            //  (Mask off DBCS messaging information.)
            //
            pmsg->wParam &= 0x0000FFFF;

            retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
                    pmsg->pwnd,
                    pmsg->msg,
                    pmsg->wParam,
                    pmsg->lParam,
                    pmsg->xParam);
        }

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINOUTDRAGMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    DROPSTRUCT ds;
} FNINOUTDRAGMSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTDRAG)
{
    SETUPPWND(FNINOUTDRAG)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNINOUTDRAG)

        LPDROPSTRUCT pds = (LPDROPSTRUCT)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->ds = *pds;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINOUTDRAG);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(pds, DROPSTRUCT);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTDRAG");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTDRAG, FNINOUTDRAGMSG)
{
    BEGINRECV(0, &pmsg->ds, sizeof(pmsg->ds));

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &pmsg->ds,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnGETTEXTLENGTHS
*
* Gets the Unicode & ANSI lengths
* Internally, lParam pints to the ANSI length in bytes and the return value
* is the Unicode length in bytes.  However, the public definition is maintained
* on the  client side, where lParam is not used and either ANSI or Unicode is
* returned.
*
* 10-Feb-1992 IanJa    Created
\**************************************************************************/

typedef struct _FNGETTEXTLENGTHSMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNGETTEXTLENGTHSMSG;

#ifdef SENDSIDE
SMESSAGECALL(GETTEXTLENGTHS)
{
    SETUPPWND(FNGETTEXTLENGTHS)

    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNGETTEXTLENGTHS)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNGETTEXTLENGTHS);
        UNLOCKPWND();
        CHECKRETURN();

        /*
         * ANSI client wndproc returns us cbANSI.  We want cchUnicode,
         * so we guess cchUnicode = cbANSI. (It may be less if
         * multi-byte characters are involved, but it will never be more).
         * Save cbANSI in *lParam in case the server ultimately returns
         * the length to an ANSI caller.
         *
         * Unicode client wndproc returns us cchUnicode.  If we want to know
         * cbANSI, we must guess how many 'ANSI' chars we would need.
         * We guess cbANSI = cchUnicode * 2. (It may be this much if all
         * 'ANSI' characters are multi-byte, but it will never be more).
         *
         * Return cchUnicode (server code is all Unicode internally).
         * Put cbANSI in *lParam to be passed along within the server in case
         * we ultimately need to return it to the client.
         *
         * NOTE: this will sometimes cause text lengths to be misreported
         * up to twice the real length, but that is expected to be harmless.
         * This will only * happen if an app sends WM_GETcode TEXTLENGTH to a
         * window with an ANSI client-side wndproc, or a ANSI WM_GETTEXTLENGTH
         * is sent to a Unicode client-side wndproc.
         */

    TRACECALLBACKMSG("SfnGETTEXTLENGTHS");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnGETTEXTLENGTHS, FNGETTEXTLENGTHSMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            0,                      // so we don't pass &cbAnsi to apps
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINLPCREATESTRUCTMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    CREATESTRUCT cs;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINLPCREATESTRUCTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPCREATESTRUCT)
{
    PCREATESTRUCTEX pcreatestruct = (PCREATESTRUCTEX)lParam;
    DWORD cbName = 0, cbClass = 0;
    DWORD cCapture = 0;
    BOOL fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);

    SETUPPWND(FNINLPCREATESTRUCT)

    UNREFERENCED_PARAMETER(psms);

    /*
     * Compute ANSI capture lengths.  Don't capture if
     * the strings are in the client's address space.
     */
    if (pcreatestruct) {
        if (pcreatestruct->cs.lpszName &&
                ((BOOL)pcreatestruct->strName.bAnsi != fAnsiReceiver ||
                IS_SYSTEM_ADDRESS((PVOID)pcreatestruct->cs.lpszName))) {
            CALC_SIZE_IN(cbName, &pcreatestruct->strName);
            cCapture++;
        }
        if (IS_PTR(pcreatestruct->cs.lpszClass) &&
                ((BOOL)pcreatestruct->strClass.bAnsi != fAnsiReceiver ||
                IS_SYSTEM_ADDRESS((PVOID)pcreatestruct->cs.lpszClass))) {
            CALC_SIZE_IN(cbClass, &pcreatestruct->strClass);
            cCapture++;
        }
    }

    BEGINSENDCAPTURE(FNINLPCREATESTRUCT, cCapture, cbName + cbClass, TRUE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->lParam = lParam;  // this could be NULL in WOW apps!

        if (pcreatestruct != NULL) {
            MSGDATA()->cs = pcreatestruct->cs;

            // Make it a "Large" copy because it could be an Edit control
            if (cbName) {
                if (!pcreatestruct->strName.bAnsi) {
                    WORD wOrdinal;

                    try {
                        wOrdinal = *(PWORD)pcreatestruct->cs.lpszName;
                    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                        goto errorexit;
                    }
                    if (wOrdinal == 0xffff) {

                        /*
                         * Copy out an ordinal of the form 0xffff, ID.
                         * If the receiver is ANSI, skip the first 0xff.
                         */
                        if (fAnsiReceiver) {
                            if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,
                                    (PBYTE)pcreatestruct->cs.lpszName + 1,
                                    3, (PVOID *)&mp->cs.lpszName)))
                                goto errorexit;
                        } else {
                            if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,
                                    (PBYTE)pcreatestruct->cs.lpszName,
                                    4, (PVOID *)&mp->cs.lpszName)))
                                goto errorexit;
                        }
                    } else if (fAnsiReceiver) {
                        LARGECOPYSTRINGLPWSTRA(&pcreatestruct->strName, cs.lpszName);
                    } else {
                        LARGECOPYSTRINGLPWSTR(&pcreatestruct->strName, cs.lpszName);
                    }
                } else {
                    BYTE bOrdinal;

                    try {
                        bOrdinal = *(PBYTE)pcreatestruct->cs.lpszName;
                    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                        goto errorexit;
                    }
                    if (bOrdinal == 0xff) {

                        /*
                         * Copy out an ordinal of the form 0xff, ID.
                         * If the receiver is UNICODE, expand the 0xff to 0xffff.
                         */
                        if (fAnsiReceiver) {
                            if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,
                                    (PBYTE)pcreatestruct->cs.lpszName,
                                    3, (PVOID *)&mp->cs.lpszName)))
                                goto errorexit;
                        } else {
                            DWORD dwOrdinal;

                            try {
                                dwOrdinal = MAKELONG(0xffff,
                                        (*(DWORD UNALIGNED *)pcreatestruct->cs.lpszName >> 8));
                            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                                goto errorexit;
                            }
                            if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,
                                    &dwOrdinal,
                                    4, (PVOID *)&mp->cs.lpszName)))
                                goto errorexit;
                        }
                    } else if (fAnsiReceiver) {
                        LARGECOPYSTRINGLPSTR(&pcreatestruct->strName, cs.lpszName);
                    } else {
                        LARGECOPYSTRINGLPSTRW(&pcreatestruct->strName, cs.lpszName);
                    }
                }
            }
            if (cbClass) {
                if (!pcreatestruct->strClass.bAnsi) {
                    if (fAnsiReceiver) {
                        LARGECOPYSTRINGLPWSTRA(&pcreatestruct->strClass, cs.lpszClass);
                    } else {
                        LARGECOPYSTRINGLPWSTR(&pcreatestruct->strClass, cs.lpszClass);
                    }
                } else {
                    if (fAnsiReceiver) {
                        LARGECOPYSTRINGLPSTR(&pcreatestruct->strClass, cs.lpszClass);
                    } else {
                        LARGECOPYSTRINGLPSTRW(&pcreatestruct->strClass, cs.lpszClass);
                    }
                }
            }
        }

        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNINLPCREATESTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINLPCREATESTRUCT");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPCREATESTRUCT, FNINLPCREATESTRUCTMSG)
{
    LPARAM lParam;

    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    if (pmsg->lParam != 0) {
        if ((ULONG_PTR)pmsg->cs.lpszName > gHighestUserAddress)
            pmsg->cs.lpszName = REBASEPTR(pmsg->pwnd, pmsg->cs.lpszName);
        if ((ULONG_PTR)pmsg->cs.lpszClass > gHighestUserAddress)
            pmsg->cs.lpszClass = REBASEPTR(pmsg->pwnd, pmsg->cs.lpszClass);
        lParam = (LPARAM)&pmsg->cs;

        if ((pmsg->cs.lpCreateParams != NULL) &&
            (TestWF(pmsg->pwnd, WEFMDICHILD))) {
               // Note -- do not test the flag in cs.dwExStyle -- it gets zapped for Old UI apps, like Quicken
            ((LPMDICREATESTRUCT)(pmsg->cs.lpCreateParams))->szClass = pmsg->cs.lpszClass;
            ((LPMDICREATESTRUCT)(pmsg->cs.lpCreateParams))->szTitle = pmsg->cs.lpszName;
        }
    } else
        lParam = 0;


    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            lParam,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINLPMDICREATESTRUCT
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINLPMDICREATESTRUCTMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    MDICREATESTRUCT mdics;
    ULONG_PTR xParam;
    PROC xpfnProc;
    int szClass;
    int szTitle;
} FNINLPMDICREATESTRUCTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPMDICREATESTRUCT)
{
    PMDICREATESTRUCTEX pmdicreatestruct = (PMDICREATESTRUCTEX)lParam;
    DWORD cbTitle = 0, cbClass = 0;
    DWORD cCapture = 0;
    BOOL fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);

    SETUPPWND(FNINLPMDICREATESTRUCT)

    UNREFERENCED_PARAMETER(psms);

    /*
     * Compute ANSI capture lengths.  Don't capture if
     * the strings are in the client's address space and
     * are Unicode.
     */
    if (pmdicreatestruct->mdics.szTitle &&
            (IS_SYSTEM_ADDRESS((PVOID)pmdicreatestruct->mdics.szTitle) ||
            ((BOOL)pmdicreatestruct->strTitle.bAnsi != fAnsiReceiver))) {
        CALC_SIZE_IN(cbTitle, &pmdicreatestruct->strTitle);
        cCapture = 1;
    }
    if (IS_PTR(pmdicreatestruct->mdics.szClass) &&
            (IS_SYSTEM_ADDRESS((PVOID)pmdicreatestruct->mdics.szClass) ||
            ((BOOL)pmdicreatestruct->strClass.bAnsi != fAnsiReceiver))) {
        CALC_SIZE_IN(cbClass, &pmdicreatestruct->strClass);
        cCapture++;
    }

    BEGINSENDCAPTURE(FNINLPMDICREATESTRUCT, cCapture, cbTitle + cbClass, TRUE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->mdics = pmdicreatestruct->mdics;

        if (cbTitle) {
            if (!pmdicreatestruct->strTitle.bAnsi) {
                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPWSTRA(&pmdicreatestruct->strTitle, mdics.szTitle);
                } else {
                    LARGECOPYSTRINGLPWSTR(&pmdicreatestruct->strTitle, mdics.szTitle);
                }
            } else {
                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPSTR(&pmdicreatestruct->strTitle, mdics.szTitle);
                } else {
                    LARGECOPYSTRINGLPSTRW(&pmdicreatestruct->strTitle, mdics.szTitle);
                }
            }
        }
        if (cbClass) {
            if (!pmdicreatestruct->strClass.bAnsi) {
                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPWSTRA(&pmdicreatestruct->strClass, mdics.szClass);
                } else {
                    LARGECOPYSTRINGLPWSTR(&pmdicreatestruct->strClass, mdics.szClass);
                }
            } else {
                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPSTR(&pmdicreatestruct->strClass, mdics.szClass);
                } else {
                    LARGECOPYSTRINGLPSTRW(&pmdicreatestruct->strClass, mdics.szClass);
                }
            }
        }
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNINLPMDICREATESTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINLPMDICREATESTRUCT");
    ENDSENDCAPTURE(LRESULT,0);
    DBG_UNREFERENCED_PARAMETER(wParam);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPMDICREATESTRUCT, FNINLPMDICREATESTRUCTMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &pmsg->mdics,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINPAINTCLIPBRD
*
* lParam is a supposed to be a Global Handle to DDESHARE memory.
*
* 22-Jul-1991 johnc     Created
\**************************************************************************/

typedef struct _FNINPAINTCLIPBRDMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    PAINTSTRUCT ps;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINPAINTCLIPBRDMSG;

#ifdef SENDSIDE
SMESSAGECALL(INPAINTCLIPBRD)
{
    PWND pwndDCOwner;

    /*
     * We need to check clipboard access rights because the app could
     * get the clipboard owner's window handle by enumeration etc and
     * send this message
     */

    SETUPPWND(FNINPAINTCLIPBRD)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINPAINTCLIPBRD)

        LPPAINTSTRUCT pps = (LPPAINTSTRUCT)lParam;

        if (RtlAreAllAccessesGranted(PpiCurrent()->amwinsta,
                WINSTA_ACCESSCLIPBOARD)) {

            MSGDATA()->pwnd = pwndClient;
            MSGDATA()->msg = msg;
            MSGDATA()->wParam = wParam;
            MSGDATA()->ps = *pps;
            MSGDATA()->xParam = xParam;
            MSGDATA()->xpfnProc = xpfnProc;

            /*
             * We can't just set the owner of the DC and pass the original DC
             * because currently GDI won't let you query the current owner
             * and we don't know if it is a public or privately owned DC
             */
            pwndDCOwner = _WindowFromDC(pps->hdc);
            MSGDATA()->ps.hdc = _GetDC(pwndDCOwner);

            LOCKPWND();
            MAKECALL(FNINPAINTCLIPBRD);
            UNLOCKPWND();
            CHECKRETURN();

            _ReleaseDC(MSGDATA()->ps.hdc);
        }

    TRACECALLBACKMSG("SfnINPAINTCLIPBRD");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINPAINTCLIPBRD, FNINPAINTCLIPBRDMSG)
{
    LPPAINTSTRUCT lpps;

    BEGINRECV(0, NULL, 0);

    lpps = (LPPAINTSTRUCT)GlobalAlloc(GMEM_FIXED | GMEM_DDESHARE, sizeof(PAINTSTRUCT));
    UserAssert(lpps);

    if (lpps) {
        *lpps = pmsg->ps;

        UserAssert(lpps->hdc);

        retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
                pmsg->pwnd,
                pmsg->msg,
                pmsg->wParam,
                lpps,
                pmsg->xParam);

        GlobalFree((HGLOBAL)lpps);
    }

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINSIZECLIPBRD
*
* lParam is a supposed to be a Global Handle to DDESHARE memory.
*
* 11-Jun-1992 sanfords  Created
\**************************************************************************/

typedef struct _FNINSIZECLIPBRDMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    RECT rc;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINSIZECLIPBRDMSG;

#ifdef SENDSIDE
SMESSAGECALL(INSIZECLIPBRD)
{
    /*
     * We need to check clipboard access rights because the app could
     * get the clipboard owner's window handle by enumeration etc and
     * send this message
     */

    SETUPPWND(FNINSIZECLIPBRD)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINSIZECLIPBRD)

        LPRECT prc = (LPRECT)lParam;

        if (RtlAreAllAccessesGranted(PpiCurrent()->amwinsta,
                WINSTA_ACCESSCLIPBOARD)) {

            MSGDATA()->pwnd = pwndClient;
            MSGDATA()->msg = msg;
            MSGDATA()->wParam = wParam;
            MSGDATA()->rc = *prc;
            MSGDATA()->xParam = xParam;
            MSGDATA()->xpfnProc = xpfnProc;

            LOCKPWND();
            MAKECALL(FNINSIZECLIPBRD);
            UNLOCKPWND();
            CHECKRETURN();
        }

    TRACECALLBACKMSG("SfnINSIZECLIPBRD");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINSIZECLIPBRD, FNINSIZECLIPBRDMSG)
{
    LPRECT lprc;

    BEGINRECV(0, NULL, 0);

    lprc = (LPRECT)GlobalAlloc(GMEM_FIXED | GMEM_DDESHARE, sizeof(RECT));
    UserAssert(lprc);

    if (lprc) {
        *lprc = pmsg->rc;

        retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
                pmsg->pwnd,
                pmsg->msg,
                pmsg->wParam,
                lprc,
                pmsg->xParam);

        GlobalFree((HGLOBAL)lprc);
    }

    ENDRECV();
}
#endif // RECVSIDE


/**************************************************************************\
* fnINDESTROYCLIPBRD
*
* Special handler so we can call ClientEmptyClipboard on client
*
* 01-16-93 scottlu  Created
\**************************************************************************/

typedef struct _FNINDESTROYCLIPBRDMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINDESTROYCLIPBRDMSG;

#ifdef SENDSIDE
SMESSAGECALL(INDESTROYCLIPBRD)
{
    SETUPPWND(FNINDESTROYCLIPBRD)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINDESTROYCLIPBRD)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->lParam = lParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINDESTROYCLIPBRD);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINDESTROYCLIPBRD");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINDESTROYCLIPBRD, FNINDESTROYCLIPBRDMSG)
{
    void ClientEmptyClipboard(void);

    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            pmsg->lParam,
            pmsg->xParam);

    /*
     * Now empty the client side clipboard cache.
     * Don't do this if this is a 16bit app.  We don't want to clear out the
     * clipboard just because one app is going away.  All of the 16bit apps
     * share one clipboard.
     */
    if ((GetClientInfo()->CI_flags & CI_16BIT) == 0) {
        ClientEmptyClipboard();
    }

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINOUTLPSCROLLINFOMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    SCROLLINFO info;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINOUTLPSCROLLINFOMSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTLPSCROLLINFO)
{
    SETUPPWND(FNINOUTLPSCROLLINFO)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNINOUTLPSCROLLINFO)

        LPSCROLLINFO pinfo = (LPSCROLLINFO)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->info = *pinfo;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINOUTLPSCROLLINFO);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(pinfo, SCROLLINFO);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTLPSCROLLINFO");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTLPSCROLLINFO, FNINOUTLPSCROLLINFOMSG)
{
    BEGINRECV(0, &pmsg->info, sizeof(pmsg->info));

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &pmsg->info,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINOUTLPPOINT5MSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    POINT5 point5;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINOUTLPPOINT5MSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTLPPOINT5)
{
    SETUPPWND(FNINOUTLPPOINT5)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNINOUTLPPOINT5)

        LPPOINT5 ppoint5 = (LPPOINT5)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->point5 = *ppoint5;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINOUTLPPOINT5);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
             OUTSTRUCT(ppoint5, POINT5);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTLPPOINT5");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTLPPOINT5, FNINOUTLPPOINT5MSG)
{
    BEGINRECV(0, &pmsg->point5, sizeof(POINT5));

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &pmsg->point5,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINOUTLPRECTMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    RECT rect;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINOUTLPRECTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTLPRECT)
{
    SETUPPWND(FNINOUTLPRECT)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNINOUTLPRECT)

        LPRECT prect = (LPRECT)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->rect = *prect;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINOUTLPRECT);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(prect, RECT);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTLPRECT");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTLPRECT, FNINOUTLPRECTMSG)
{
    BEGINRECV(0, &pmsg->rect, sizeof(pmsg->rect));

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &pmsg->rect,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 11-25-92 ScottLu      Created.
\**************************************************************************/

typedef struct _FNINOUTNCCALCSIZEMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    union {
        RECT rc;
        struct {
            NCCALCSIZE_PARAMS params;
            WINDOWPOS pos;
        } p;
    } u;
} FNINOUTNCCALCSIZEMSG;

typedef struct _OUTNCCALCSIZE {
    NCCALCSIZE_PARAMS params;
    WINDOWPOS pos;
} OUTNCCALCSIZE, *POUTNCCALCSIZE;

#ifdef SENDSIDE
SMESSAGECALL(INOUTNCCALCSIZE)
{
    SETUPPWND(FNINOUTNCCALCSIZE)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNINOUTNCCALCSIZE)

        LPWINDOWPOS lppos;
        UINT cbCallback;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        /*
         * If wParam != 0, lParam points to a NCCALCSIZE_PARAMS structure,
         * otherwise it points to a rectangle.
         */
        if (wParam != 0) {
            MSGDATA()->u.p.params = *((LPNCCALCSIZE_PARAMS)lParam);
            MSGDATA()->u.p.pos = *(MSGDATA()->u.p.params.lppos);
            cbCallback = sizeof(FNINOUTNCCALCSIZEMSG);
        } else {
            MSGDATA()->u.rc = *((LPRECT)lParam);
            cbCallback = FIELD_OFFSET(FNINOUTNCCALCSIZEMSG, u) +
                    sizeof(RECT);
        }

        /*
         * Don't use the MAKECALL macro so we can
         * select the callback data size
         */
        LOCKPWND();
        LeaveCrit();
        Status = (DWORD)KeUserModeCallback(
            FI_FNINOUTNCCALCSIZE,
            mp,
            cbCallback,
            &pcbs,
            &cbCBStatus);
        EnterCrit();
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            try {
                ProbeForRead(pcbs->pOutput, pcbs->cbOutput, sizeof(DWORD));
                if (wParam != 0) {
                    lppos = ((LPNCCALCSIZE_PARAMS)lParam)->lppos;
                    *((LPNCCALCSIZE_PARAMS)lParam) =
                            ((POUTNCCALCSIZE)pcbs->pOutput)->params;
                    *lppos = ((POUTNCCALCSIZE)pcbs->pOutput)->pos;
                    ((LPNCCALCSIZE_PARAMS)lParam)->lppos = lppos;
                } else {
                    *((LPRECT)lParam) = *(PRECT)pcbs->pOutput;
                }
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                MSGERROR();
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTNCCALCSIZE");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTNCCALCSIZE, FNINOUTNCCALCSIZEMSG)
{
    BEGINRECV(0, &pmsg->u, sizeof(pmsg->u));

    if (CALLDATA(wParam) != 0)
        CALLDATA(u.p.params).lppos = PCALLDATA(u.p.pos);

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            (LPARAM)&pmsg->u,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 9/30/94 Sanfords created
\**************************************************************************/

typedef struct _FNINOUTSTYLECHANGEMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    STYLESTRUCT ss;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINOUTSTYLECHANGEMSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTSTYLECHANGE)
{
    SETUPPWND(FNINOUTSTYLECHANGE)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINOUTSTYLECHANGE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;
        MSGDATA()->ss = *((LPSTYLESTRUCT)lParam);

        LOCKPWND();
        MAKECALL(FNINOUTSTYLECHANGE);
        UNLOCKPWND();
        CHECKRETURN();

        if (msg == WM_STYLECHANGING)
            OUTSTRUCT(((LPSTYLESTRUCT)lParam), STYLESTRUCT);

    TRACECALLBACKMSG("SfnINOUTSTYLECHANGE");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTSTYLECHANGE, FNINOUTSTYLECHANGEMSG)
{
    BEGINRECV(0, &pmsg->ss, sizeof(pmsg->ss));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            (LPARAM)&pmsg->ss,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNOUTLPRECTMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNOUTLPRECTMSG;

#ifdef SENDSIDE
SMESSAGECALL(OUTLPRECT)
{
    SETUPPWND(FNOUTLPRECT)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNOUTLPRECT)

        LPRECT prect = (LPRECT)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNOUTLPRECT);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(prect, RECT);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnOUTLPRECT");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnOUTLPRECT, FNOUTLPRECTMSG)
{
    RECT rc;

    BEGINRECV(0, &rc, sizeof(rc));

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &rc,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINLPCOMPAREITEMSTRUCTMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    COMPAREITEMSTRUCT compareitemstruct;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINLPCOMPAREITEMSTRUCTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPCOMPAREITEMSTRUCT)
{
    SETUPPWND(FNINLPCOMPAREITEMSTRUCT)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINLPCOMPAREITEMSTRUCT)

        LPCOMPAREITEMSTRUCT pcompareitemstruct = (LPCOMPAREITEMSTRUCT)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->compareitemstruct = *pcompareitemstruct;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINLPCOMPAREITEMSTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINLPCOMPAREITEMSTRUCT");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPCOMPAREITEMSTRUCT, FNINLPCOMPAREITEMSTRUCTMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &(pmsg->compareitemstruct),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINLPDELETEITEMSTRUCTMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    DELETEITEMSTRUCT deleteitemstruct;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINLPDELETEITEMSTRUCTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPDELETEITEMSTRUCT)
{
    SETUPPWND(FNINLPDELETEITEMSTRUCT)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINLPDELETEITEMSTRUCT)

        LPDELETEITEMSTRUCT pdeleteitemstruct = (LPDELETEITEMSTRUCT)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->deleteitemstruct = *pdeleteitemstruct;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINLPDELETEITEMSTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINLPDELETEITEMSTRUCT");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPDELETEITEMSTRUCT, FNINLPDELETEITEMSTRUCTMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &(pmsg->deleteitemstruct),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* FNINHLPSTRUCT
*
* 06-08-92 SanfordS Created
\**************************************************************************/

typedef struct _FNINLPHLPSTRUCTMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPHLP lphlp;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINLPHLPSTRUCTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPHLPSTRUCT)
{
    LPHLP lphlp = (LPHLP)lParam;

    SETUPPWND(FNINLPHLPSTRUCT)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSENDCAPTURE(FNINLPHLPSTRUCT, 1, lphlp->cbData, TRUE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        COPYBYTES(lphlp, lphlp->cbData);
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNINLPHLPSTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINLPHLPSTRUCT");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPHLPSTRUCT, FNINLPHLPSTRUCTMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            FIXUP(lphlp),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

#ifndef WINHELP4

/**************************************************************************\
* FNINHELPINFOSTRUCT
*
* 06-08-92 SanfordS Created
\**************************************************************************/

typedef struct _FNINLPHELPFINFOSTRUCTMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPHELPINFO lphlp;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINLPHELPINFOSTRUCTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPHELPINFOSTRUCT)
{
    LPHELPINFO lphlp = (LPHELPINFO)lParam;

    SETUPPWND(FNINLPHELPINFOSTRUCT)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSENDCAPTURE(FNINLPHELPINFOSTRUCT, 1, lphlp->cbSize, TRUE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        COPYBYTES(lphlp, lphlp->cbSize);
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNINLPHELPINFOSTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINLPHELPINFOSTRUCT");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPHELPINFOSTRUCT, FNINLPHELPINFOSTRUCTMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            FIXUP(lphlp),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE
#endif // WINHELP4

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINLPDRAWITEMSTRUCTMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    DRAWITEMSTRUCT drawitemstruct;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINLPDRAWITEMSTRUCTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPDRAWITEMSTRUCT)
{
    SETUPPWND(FNINLPDRAWITEMSTRUCT)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINLPDRAWITEMSTRUCT)

        LPDRAWITEMSTRUCT pdrawitemstruct = (LPDRAWITEMSTRUCT)lParam;
        HDC hdcOriginal = (HDC)NULL;

        /*
         * Make sure that this is not an OLE inter-process DrawItem
         */
        if (GreGetObjectOwner((HOBJ)pdrawitemstruct->hDC, DC_TYPE) !=
                W32GetCurrentPID()) {
            if (pdrawitemstruct->hDC) {
                PWND pwndItem;

                pwndItem = _WindowFromDC(pdrawitemstruct->hDC);

                if (pwndItem) {
                    hdcOriginal = pdrawitemstruct->hDC;
                    pdrawitemstruct->hDC = _GetDC(pwndItem);
                }
            }
        }


        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->drawitemstruct = *pdrawitemstruct;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINLPDRAWITEMSTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

        if (hdcOriginal) {
            _ReleaseDC(pdrawitemstruct->hDC);
            pdrawitemstruct->hDC = hdcOriginal;
        }
    TRACECALLBACKMSG("SfnINLPDRAWITEMSTRUCT");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPDRAWITEMSTRUCT, FNINLPDRAWITEMSTRUCTMSG)
{
    BEGINRECV(0, NULL, 0);

    if (pmsg->drawitemstruct.hDC == NULL)
        MSGERRORCODE(ERROR_INVALID_HANDLE);

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &(pmsg->drawitemstruct),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINOUTLPMEASUREITEMSTRUCT
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINOUTLPMEASUREITEMSTRUCTMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    MEASUREITEMSTRUCT measureitemstruct;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINOUTLPMEASUREITEMSTRUCTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTLPMEASUREITEMSTRUCT)
{
    SETUPPWND(FNINOUTLPMEASUREITEMSTRUCT)

    BEGINSEND(FNINOUTLPMEASUREITEMSTRUCT)

        PMEASUREITEMSTRUCT pmeasureitemstruct = (PMEASUREITEMSTRUCT)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg & ~MSGFLAG_MASK;
        MSGDATA()->wParam = wParam;
        MSGDATA()->measureitemstruct = *pmeasureitemstruct;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINOUTLPMEASUREITEMSTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(pmeasureitemstruct, MEASUREITEMSTRUCT);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTLPMEASUREITEMSTRUCT");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTLPMEASUREITEMSTRUCT, FNINOUTLPMEASUREITEMSTRUCTMSG)
{
    BEGINRECV(0, &pmsg->measureitemstruct, sizeof(pmsg->measureitemstruct));

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            &pmsg->measureitemstruct,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINSTRING
*
* 22-Jul-1991 mikeke    Created
* 27-Jan-1992 IanJa     Unicode/ANSI
\**************************************************************************/

typedef struct _FNINSTRINGMSG {
    CAPTUREBUF CaptureBuf;
    PWND       pwnd;
    UINT       msg;
    WPARAM     wParam;
    ULONG_PTR   xParam;
    PROC       xpfnProc;
    LPTSTR     pwsz;
} FNINSTRINGMSG;

#ifdef SENDSIDE
SMESSAGECALL(INSTRING)
{
    PLARGE_STRING pstr = (PLARGE_STRING)lParam;
    DWORD         cbCapture;
    DWORD         cCapture;
    BOOL          fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);

    SETUPPWND(FNINSTRING)

    UNREFERENCED_PARAMETER(psms);

    /*
     * Compute ANSI capture lengths.  Don't capture if
     * the strings are in the client's address space and
     * of the correct type.
     */
    if (pstr &&
        (IS_SYSTEM_ADDRESS((PVOID)pstr->Buffer) ||
        ((BOOL)pstr->bAnsi != fAnsiReceiver))) {

        cCapture = 1;
        CALC_SIZE_IN(cbCapture, pstr);

    } else {

        cbCapture = 0;
        cCapture  = 0;
    }

    BEGINSENDCAPTURE(FNINSTRING, cCapture, cbCapture, TRUE)

        MSGDATA()->pwnd   = pwndClient;
        MSGDATA()->msg    = msg;
        MSGDATA()->wParam = wParam;

        if (cCapture) {

            if (!pstr->bAnsi) {

                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPWSTRA(pstr, pwsz);
                } else {
                    LARGECOPYSTRINGLPWSTR(pstr, pwsz);
                }

            } else {

                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPSTR(pstr, pwsz);
                } else {
                    LARGECOPYSTRINGLPSTRW(pstr, pwsz);
                }
            }

        } else {

            MSGDATA()->pwsz = (pstr ? pstr->Buffer : NULL);
        }

        MSGDATA()->xParam   = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNINSTRING);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINSTRING");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINSTRING, FNINSTRINGMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            pmsg->pwsz,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINSTRINGNULL
*
* Server-side stub translates Unicode to ANSI if required.
*
* 22-Jul-1991 mikeke    Created
* 28-Jan-1992 IanJa     Unicode/ANSI  (Server translate to ANSI if rquired)
\**************************************************************************/

typedef struct _FNINSTRINGNULLMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    LPTSTR pwsz;
} FNINSTRINGNULLMSG;

#ifdef SENDSIDE
SMESSAGECALL(INSTRINGNULL)
{
    PLARGE_STRING pstr = (PLARGE_STRING)lParam;
    DWORD cbCapture;
    DWORD cCapture;
    BOOL fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);

    SETUPPWND(FNINSTRINGNULL)

    UNREFERENCED_PARAMETER(psms);

    cCapture = 0;
    cbCapture = 0;
    if (pstr) {

        /*
         * Compute ANSI capture lengths.  Don't capture if
         * the strings are in the client's address space and
         * of the correct type.
         */
        if (IS_SYSTEM_ADDRESS((PVOID)pstr->Buffer) ||
                (BOOL)pstr->bAnsi != fAnsiReceiver) {
            cCapture = 1;
            CALC_SIZE_IN(cbCapture, pstr);
        }
    }

    BEGINSENDCAPTURE(FNINSTRINGNULL, cCapture, cbCapture, TRUE)


        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        if (cCapture) {
            if (!pstr->bAnsi) {
                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPWSTRA(pstr, pwsz);
                } else {
                    LARGECOPYSTRINGLPWSTR(pstr, pwsz);
                }
            } else {
                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPSTR(pstr, pwsz);
                } else {
                    LARGECOPYSTRINGLPSTRW(pstr, pwsz);
                }
            }
        } else
            MSGDATA()->pwsz = pstr ? pstr->Buffer : NULL;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNINSTRINGNULL);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINSTRINGNULL");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINSTRINGNULL, FNINSTRINGNULLMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            pmsg->pwsz,
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 27-May-1997 GregoryW  Created
\**************************************************************************/

typedef struct _FNINLPKDRAWSWITCHWNDMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    LPWSTR pwsz;
    RECT rcRect;
} FNINLPKDRAWSWITCHWNDMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPKDRAWSWITCHWND)
{
    PLARGE_UNICODE_STRING pstr = &((LPKDRAWSWITCHWND *)lParam)->strName;
    DWORD cbCapture;
    DWORD cCapture = 1;  // Always capture the string
    PWND pwndDCOwner;
    HDC hdcSwitch;
    COLORREF clrOldText, clrOldBk;
    HFONT hOldFont;
    BOOL fAnsiReceiver = FALSE;  // The string is always Unicode

    SETUPPWND(FNINLPKDRAWSWITCHWND)

    UNREFERENCED_PARAMETER(psms);
    UNREFERENCED_PARAMETER(dwSCMSFlags);

    CALC_SIZE_IN(cbCapture, pstr);

    BEGINSENDCAPTURE(FNINLPKDRAWSWITCHWND, cCapture, cbCapture, TRUE)

        LARGECOPYSTRINGLPWSTR(pstr, pwsz);

        pwndDCOwner = _WindowFromDC((HDC)wParam);
        hdcSwitch = _GetDC(pwndDCOwner);
        clrOldText = GreSetTextColor(hdcSwitch, SYSRGB(BTNTEXT));
        clrOldBk   = GreSetBkColor(hdcSwitch, SYSRGB(3DFACE));
        hOldFont = GreSelectFont(hdcSwitch, gpsi->hCaptionFont);

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = (WPARAM)hdcSwitch;
        MSGDATA()->rcRect = ((LPKDRAWSWITCHWND *)lParam)->rcRect;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNINLPKDRAWSWITCHWND);
        UNLOCKPWND();

        GreSelectFont(hdcSwitch, hOldFont);
        GreSetBkColor(hdcSwitch, clrOldBk);
        GreSetTextColor(hdcSwitch, clrOldText);
        _ReleaseDC(hdcSwitch);

        CHECKRETURN();

    TRACECALLBACKMSG("SfnINLPKDRAWSWITCHWND");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPKDRAWSWITCHWND, FNINLPKDRAWSWITCHWNDMSG)
{
    DRAWTEXTPARAMS  dtp;

    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    dtp.cbSize = sizeof(dtp);
    dtp.iLeftMargin = 0;
    dtp.iRightMargin = 0;
    retval = DrawTextExW(
                 (HDC)pmsg->wParam,
                 pmsg->pwsz,
                 -1,
                 &(pmsg->rcRect),
                 DT_NOPREFIX | DT_END_ELLIPSIS | DT_SINGLELINE,
                 &dtp
                 );
    ENDRECV();
}
#endif // RECVSIDE

typedef struct _FNINDEVICECHANGEMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    LPTSTR pwsz;
    BOOL fAnsi;
} FNINDEVICECHANGEMSG;

#ifdef SENDSIDE
SMESSAGECALL(INDEVICECHANGE)
{
    PVOID pstr = (PVOID)lParam;
    DWORD cbCapture;
    BOOL fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);
    BOOL fPtr    = (BOOL)((wParam & 0x8000) == 0x8000);

    SETUPPWND(FNINDEVICECHANGE)

    UNREFERENCED_PARAMETER(psms);

    cbCapture = 0;
    if (fPtr && (pstr != NULL)) {

        /*
         * Compute ANSI capture lengths.  Don't capture if
         * the strings are in the client's address space and
         * of the correct type.
         */
        if (IS_SYSTEM_ADDRESS((PVOID)pstr)) {
            cbCapture = *((DWORD *)pstr);
        }
    }

    BEGINSENDCAPTURE(FNINDEVICECHANGE, 1, cbCapture, TRUE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        if (cbCapture) {
           LARGECOPYBYTES2(pstr, *((DWORD *)pstr), pwsz);
        } else {
           MSGDATA()->pwsz = (LPTSTR)pstr;
        }

        MSGDATA()->fAnsi = fAnsiReceiver;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNINDEVICECHANGE);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINDEVICECHANGE");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINDEVICECHANGE, FNINDEVICECHANGEMSG)
{

    struct _DEV_BROADCAST_HEADER *pHdr;
    PDEV_BROADCAST_PORT_A pPortA = NULL;
    PDEV_BROADCAST_PORT_W pPortW;
    PDEV_BROADCAST_DEVICEINTERFACE_A pInterfaceA = NULL;
    PDEV_BROADCAST_DEVICEINTERFACE_W pInterfaceW;
    PDEV_BROADCAST_HANDLE pHandleA = NULL;
    PDEV_BROADCAST_HANDLE pHandleW;
    PDEV_BROADCAST_VOLUME pVolume;


    int iStr, iSize;
    LPSTR lpStr;
    LPARAM lParam;

    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    lParam = (LPARAM)pmsg->pwsz;

    pHdr = (struct _DEV_BROADCAST_HEADER *)lParam;

    if (!lParam || !(pmsg->wParam & 0x8000) ||
        (!pmsg->fAnsi &&
        ((pHdr->dbcd_devicetype != DBT_DEVTYP_VOLUME) || (pmsg->msg != WM_DEVICECHANGE))
        )) {
        goto shipit;
    }

    switch (pHdr->dbcd_devicetype) {
    case DBT_DEVTYP_PORT:
        pPortW = (PDEV_BROADCAST_PORT_W)lParam;
        iStr = wcslen(pPortW->dbcp_name);
        iSize = FIELD_OFFSET(DEV_BROADCAST_PORT_A, dbcp_name) + DBCS_CHARSIZE*(iStr+1);
        pPortA = UserLocalAlloc(0, iSize);
        if (pPortA == NULL)
            MSGERROR();
        RtlCopyMemory(pPortA, pPortW, FIELD_OFFSET(DEV_BROADCAST_PORT_A, dbcp_name));
        lpStr = pPortA->dbcp_name;
        if (iStr) {
            WCSToMB(pPortW->dbcp_name, -1, &lpStr, iStr, FALSE);
        }
        lpStr[iStr] = 0;
        pPortA->dbcp_size = iSize;
        lParam = (LPARAM)pPortA;
        break;
    case DBT_DEVTYP_DEVICEINTERFACE:
        pInterfaceW = (PDEV_BROADCAST_DEVICEINTERFACE_W)lParam;
        iStr = wcslen(pInterfaceW->dbcc_name);
        iSize = FIELD_OFFSET(DEV_BROADCAST_DEVICEINTERFACE_A, dbcc_name) + DBCS_CHARSIZE*(iStr+1);
        pInterfaceA = UserLocalAlloc(0, iSize);
        if (pInterfaceA == NULL)
            MSGERROR();
        RtlCopyMemory(pInterfaceA, pInterfaceW, FIELD_OFFSET(DEV_BROADCAST_DEVICEINTERFACE_A, dbcc_name));
        lpStr = pInterfaceA->dbcc_name;
        if (iStr) {
            WCSToMB(pInterfaceW->dbcc_name, -1, &lpStr, iStr, FALSE);
        }
        lpStr[iStr] = 0;
        pInterfaceA->dbcc_size = iSize;
        lParam = (LPARAM)pInterfaceA;
        break;
    case DBT_DEVTYP_HANDLE:
        pHandleW = (PDEV_BROADCAST_HANDLE)lParam;
        if ((pmsg->wParam != DBT_CUSTOMEVENT) || (pHandleW->dbch_nameoffset < 0)) break;
        iStr = wcslen((LPWSTR)(pHandleW->dbch_data+pHandleW->dbch_nameoffset));
        iSize = pHandleW->dbch_size;
        /*
         * MB size can't be bigger than UNICODE size
         */
        pHandleA = UserLocalAlloc(0, iSize);
        if (pHandleA == NULL)
            MSGERROR();
        RtlCopyMemory(pHandleA, pHandleW, FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_data)+ pHandleW->dbch_nameoffset);
        lpStr = pHandleA->dbch_data+pHandleA->dbch_nameoffset;
        if (iStr) {
            WCSToMB((LPWSTR)(pHandleW->dbch_data+pHandleW->dbch_nameoffset), -1, &lpStr, iStr, FALSE);
        }
        lpStr[iStr] = 0;
        pHandleA->dbch_size = iSize;
        lParam = (LPARAM)pHandleA;
        break;
    case DBT_DEVTYP_VOLUME:
        pVolume = (PDEV_BROADCAST_VOLUME)lParam;
        if (((pmsg->wParam == DBT_DEVICEREMOVECOMPLETE) ||
             (pmsg->wParam == DBT_DEVICEARRIVAL)) &&
            (pVolume->dbcv_unitmask & DBV_FILTER_MSG)) {
            DWORD LUIDDriveMask, ResultDriveMask;

            LUIDDriveMask = GetLUIDDosDrivesOnly();

            /*
             * Filter out the common drive letter bits & DBV_FILTER_MSG
             */
            ResultDriveMask = (((LUIDDriveMask & pVolume->dbcv_unitmask) ^
                                pVolume->dbcv_unitmask) ^
                               DBV_FILTER_MSG);

            if (ResultDriveMask == 0) {
                goto cleanup;
            }
            pVolume->dbcv_unitmask = ResultDriveMask;
            lParam = (LPARAM)pVolume;
        }
        break;
    }
shipit:
    retval = (ULONG_PTR)CALLPROC(pmsg->xpfnProc)(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            lParam,
            pmsg->xParam);

cleanup:
    if (pInterfaceA) UserLocalFree(pInterfaceA);
    if (pPortA) UserLocalFree(pPortA);
    if (pHandleA) UserLocalFree(pHandleA);

    ENDRECV();
}
#endif // RECVSIDE


/**************************************************************************\
* fnOUTSTRING
*
* Warning this message copies but does not count the NULL in retval
* as in WM_GETTEXT
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNOUTSTRINGMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    PBYTE pOutput;
    DWORD cbOutput;
} FNOUTSTRINGMSG;

#ifdef SENDSIDE
SMESSAGECALL(OUTSTRING)
{
    PLARGE_STRING pstr = (PLARGE_STRING)lParam;
    DWORD cbCapture;
    BOOL fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);
    BOOL bInflateWParam = FALSE;

    SETUPPWND(FNOUTSTRING)

    CALC_SIZE_OUT_STRING(cbCapture, pstr);

    BEGINSENDCAPTURE(FNOUTSTRING, 1, cbCapture, FALSE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;

        /*
         * Need to wParam MBCS bytes may be required to form wParam Unicode bytes
         */
        if (fAnsiReceiver && !(pstr->bAnsi)) {
            /*
             * Unicode -> Ansi
             */
            MSGDATA()->wParam = (wParam * sizeof(WCHAR));
            PtiCurrent()->TIF_flags |= TIF_ANSILENGTH;
            bInflateWParam = TRUE;
        } else {
            /*
             * if wParam is already adjusted for ANSI, we need to re-adjust for Unicode...
             *
             * This logic is for following cases...
             *
             * +========+===============+=============+================+=============+
             * |WndProc |Unicode WndProc->Ansi WndProc->Unicode WndProc->Ansi WndProc|
             * +--------+---------------+-------------+----------------+-------------+
             * |Length  |      X        ->  (X * 2)   ->       X       ->  (X * 2)   |
             * +--------+---------------+-------------+----------------+-------------+
             */
            if (!fAnsiReceiver && (PtiCurrent()->TIF_flags & TIF_ANSILENGTH)) {
                /* adjust limit also... */
                MSGDATA()->wParam = wParam / sizeof(WCHAR);
                PtiCurrent()->TIF_flags &= ~TIF_ANSILENGTH;
            } else {
                MSGDATA()->wParam = wParam;
            }
        }
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        RESERVEBYTES(cbCapture, pOutput, cbOutput);

        LOCKPWND();
        MAKECALLCAPTURE(FNOUTSTRING);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            if (retval) {
                /*
                 * Non-zero retval means some text to copy out.  Do not copy out
                 * more than the requested byte count 'wParam'.
                 */
                COPYOUTLPWSTRLIMIT(pstr, (int)wParam);
            } else {
                /*
                 * A dialog function returning FALSE means no text to copy out,
                 * but an empty string also has retval == 0: put a null char in
                 * pstr for the latter case.
                 */
                if (wParam != 0) {
                    if (pstr->bAnsi) {
                         *(PCHAR)pstr->Buffer = 0;
                    } else {
                         *(PWCHAR)pstr->Buffer = 0;
                    }
                }
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnOUTSTRING");
    ENDSENDCAPTUREOUTSTRING(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnOUTSTRING, FNOUTSTRINGMSG)
{
    BYTE abOutput[CALLBACKSTACKLIMIT];

    BEGINRECV(0, NULL, pmsg->cbOutput);
    FIXUPPOINTERS();
    if (pmsg->cbOutput <= CALLBACKSTACKLIMIT)
        CallbackStatus.pOutput = abOutput;
    else
        CallbackStatus.pOutput = pmsg->pOutput;

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            (LPARAM)KPVOID_TO_PVOID(CallbackStatus.pOutput),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINCNTOUTSTRING
*
* Does NOT NULL terminate string
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINCNTOUTSTRING {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    WORD cchMax;
    PBYTE pOutput;
    DWORD cbOutput;
} FNINCNTOUTSTRINGMSG;

#ifdef SENDSIDE
SMESSAGECALL(INCNTOUTSTRING)
{
    PLARGE_STRING pstr = (PLARGE_STRING)lParam;
    DWORD cbCapture;
    WORD cchOriginal;
    BOOL fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);

    SETUPPWND(FNINCNTOUTSTRING)

    CALC_SIZE_OUT(cbCapture, pstr);

    BEGINSENDCAPTURE(FNINCNTOUTSTRING, 1, cbCapture, FALSE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        cchOriginal = (WORD)pstr->MaximumLength;
        if (!pstr->bAnsi)
            cchOriginal /= sizeof(WCHAR);

        MSGDATA()->cchMax = (WORD)min(cchOriginal, 0xffff);
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        RESERVEBYTES(cbCapture, pOutput, cbOutput);

        LOCKPWND();
        MAKECALLCAPTURE(FNINCNTOUTSTRING)
        UNLOCKPWND();
        CHECKRETURN();

        /*
         * We don't want to do the copy out of the sender died or if
         * this message was just sent as part of a CALLWNDPROC hook processing
         */
        BEGINCOPYOUT()
            if (retval) {
                /*
                 * Non-zero retval means some text to copy out.  Do not copy out
                 * more than the requested char count 'wParam'.
                 */
                COPYOUTLPWSTRLIMIT(pstr, (int)cchOriginal);
            } else {
                /*
                 * A dialog function returning FALSE means no text to copy out,
                 * but an empty string also has retval == 0: put a null char in
                 * pstr for the latter case.
                 */
                if (pstr->bAnsi) {
                    *(PCHAR)pstr->Buffer = 0;
                } else {
                    *(PWCHAR)pstr->Buffer = 0;
                }
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINCNTOUTSTRING");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINCNTOUTSTRING, FNINCNTOUTSTRINGMSG)
{
    BYTE abOutput[CALLBACKSTACKLIMIT];

    BEGINRECV(0, NULL, pmsg->cbOutput);
    FIXUPPOINTERS();
    if (pmsg->cbOutput <= CALLBACKSTACKLIMIT)
        CallbackStatus.pOutput = abOutput;
    else
        CallbackStatus.pOutput = pmsg->pOutput;

    *(KPWORD)CallbackStatus.pOutput = CALLDATA(cchMax);

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            (LPARAM)KPVOID_TO_PVOID(CallbackStatus.pOutput),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINCNTOUTSTRINGNULL
*
* wParam specifies the maximum number of bytes to copy
* the string is NULL terminated
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINCNTOUTSTRINGNULL {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    PBYTE pOutput;
    DWORD cbOutput;
} FNINCNTOUTSTRINGNULLMSG;

#ifdef SENDSIDE
SMESSAGECALL(INCNTOUTSTRINGNULL)
{
    PLARGE_STRING pstr = (PLARGE_STRING)lParam;
    DWORD cbCapture;
    BOOL fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);

    SETUPPWND(FNINCNTOUTSTRINGNULL)

    CALC_SIZE_OUT(cbCapture, pstr);

    BEGINSENDCAPTURE(FNINCNTOUTSTRINGNULL, 1, cbCapture, FALSE)

        if (wParam < 2) {   // However unlikely, this prevents a possible GP
            MSGERROR();     // on the server side.
        }

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        RESERVEBYTES(cbCapture, pOutput, cbOutput);

        LOCKPWND();
        MAKECALLCAPTURE(FNINCNTOUTSTRINGNULL)
        UNLOCKPWND();
        CHECKRETURN();

        /*
         * We don't want to do the copy out of the sender died or if
         * this message was just sent as part of a CALLWNDPROC hook processing
         */
        BEGINCOPYOUT()
            if (pcbs->cbOutput != 0) {

                /*
                 * Buffer changed means some text to copy out.  Do not copy out
                 * more than the requested byte count 'wParam'.
                 */
                COPYOUTLPWSTRLIMIT(pstr, (int)wParam);
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINCNTOUTSTRINGNULL");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINCNTOUTSTRINGNULL, FNINCNTOUTSTRINGNULLMSG)
{
    BYTE abOutput[CALLBACKSTACKLIMIT];

    BEGINRECV(0, NULL, pmsg->cbOutput);
    FIXUPPOINTERS();
    if (pmsg->cbOutput <= CALLBACKSTACKLIMIT)
        CallbackStatus.pOutput = abOutput;
    else
        CallbackStatus.pOutput = pmsg->pOutput;

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            (LPARAM)KPVOID_TO_PVOID(CallbackStatus.pOutput),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnPOUTLPINT
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNPOUTLPINTMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
    PBYTE pOutput;
    DWORD cbOutput;
} FNPOUTLPINTMSG;

#ifdef SENDSIDE
SMESSAGECALL(POUTLPINT)
{
    DWORD cbCapture;
    LPINT pint = (LPINT)lParam;

    SETUPPWND(FNPOUTLPINT)

    cbCapture = (UINT)wParam * sizeof(INT);

    BEGINSENDCAPTURE(FNPOUTLPINT, 1, cbCapture, FALSE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        /*
         * Hooks should see the buffer content
         */
        if (dwSCMSFlags & SCMS_FLAGS_INONLY) {
            MSGDATA()->cbOutput = cbCapture;
            LARGECOPYBYTES2(pint, cbCapture, pOutput);
        } else {
            RESERVEBYTES(cbCapture, pOutput, cbOutput);
        }

        LOCKPWND();
        MAKECALLCAPTURE(FNPOUTLPINT);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            try {
                ProbeForRead(pcbs->pOutput, pcbs->cbOutput, sizeof(DWORD));
                memcpy(pint, pcbs->pOutput, cbCapture);
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                MSGERROR();
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnPOUTLPINT");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnPOUTLPINT, FNPOUTLPINTMSG)
{
    BYTE abOutput[CALLBACKSTACKLIMIT];

    BEGINRECV(0, NULL, pmsg->cbOutput);
    FIXUPPOINTERS();
    if (pmsg->cbOutput <= CALLBACKSTACKLIMIT)
        CallbackStatus.pOutput = abOutput;
    else
        CallbackStatus.pOutput = pmsg->pOutput;

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            (LPARAM)KPVOID_TO_PVOID(CallbackStatus.pOutput),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnPOPTINLPUINT
*
* NOTE!!! -- This function actually thunks arrays of INTs (32bit) and not
* WORDs (16bit).  The name was left the same to prevent a global rebuild
* of client and server.  The name should be changed to fnPOPTINLPINT as
* soon as we ship the beta!  The corresponding callforward function in
* cf2.h should also have its name changed.
*
* 22-Jul-1991 mikeke    Created
* 07-Jan-1993 JonPa     Changed to pass INTs instead of WORDs
\**************************************************************************/

typedef struct _FNPOPTINLPUINTMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPWORD pw;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNPOPTINLPUINTMSG;

#ifdef SENDSIDE
SMESSAGECALL(POPTINLPUINT)
{
    LPWORD pw = (LPWORD)lParam;
    DWORD cCapture, cbCapture;

    SETUPPWND(FNPOPTINLPUINT);

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    if (lParam) {
        cCapture = 1;
        cbCapture = (UINT)wParam * sizeof(UINT);
    } else {
        cCapture = cbCapture = 0;
    }

    BEGINSENDCAPTURE(FNPOPTINLPUINT, cCapture, cbCapture, TRUE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        COPYBYTESOPT(pw, cbCapture);
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALLCAPTURE(FNPOPTINLPUINT);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnPOPTINLPUINT");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnPOPTINLPUINT, FNPOPTINLPUINTMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            (LPDWORD)FIRSTFIXUPOPT(pw),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnINOUTLPWINDOWPOS (for WM_WINDOWPOSCHANGING message)
*
* 08-11-91 darrinm      Created.
\**************************************************************************/

typedef struct _FNINOUTLPWINDOWPOSMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    WINDOWPOS wp;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINOUTLPWINDOWPOSMSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTLPWINDOWPOS)
{
    SETUPPWND(FNINOUTLPWINDOWPOS)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNINOUTLPWINDOWPOS)

        LPWINDOWPOS pwp = (LPWINDOWPOS)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->wp = *pwp;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINOUTLPWINDOWPOS);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(pwp, WINDOWPOS);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTLPWINDOWPOS");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTLPWINDOWPOS, FNINOUTLPWINDOWPOSMSG)
{
    BEGINRECV(0, &pmsg->wp, sizeof(pmsg->wp));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            PCALLDATA(wp),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE


/**************************************************************************\
* fnINLPWINDOWPOS (for WM_WINDOWPOSCHANGED message)
*
* 08-11-91 darrinm      Created.
\**************************************************************************/

typedef struct _FNINLPWINDOWPOSMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    WINDOWPOS wp;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINLPWINDOWPOSMSG;

#ifdef SENDSIDE
SMESSAGECALL(INLPWINDOWPOS)
{
    SETUPPWND(FNINLPWINDOWPOS)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNINLPWINDOWPOS)

        LPWINDOWPOS pwp = (LPWINDOWPOS)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->wp = *pwp;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINLPWINDOWPOS);
        UNLOCKPWND();
        CHECKRETURN();

    TRACECALLBACKMSG("SfnINLPWINDOWPOS");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINLPWINDOWPOS, FNINLPWINDOWPOSMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            PCALLDATA(wp),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE




/**************************************************************************\
* fnINOUTNEXTMENU
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNINOUTNEXTMENUMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    MDINEXTMENU mnm;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINOUTNEXTMENUMSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTNEXTMENU)
{
    SETUPPWND(FNINOUTNEXTMENU)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNINOUTNEXTMENU)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;
        MSGDATA()->mnm = *((PMDINEXTMENU)lParam);

        LOCKPWND();
        MAKECALL(FNINOUTNEXTMENU);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(((PMDINEXTMENU)lParam), MDINEXTMENU);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTNEXTMENU");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTNEXTMENU, FNINOUTNEXTMENUMSG)
{
    BEGINRECV(0, &pmsg->mnm, sizeof(pmsg->mnm));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            &CALLDATA(mnm),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnHkINLPCBTCREATESTRUCT
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _CREATESTRUCTDATA {
    CREATESTRUCT cs;
    HWND hwndInsertAfter;
} CREATESTRUCTDATA;

typedef struct _FNHKINLPCBTCREATESTRUCTMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    CREATESTRUCTDATA d;
    PROC xpfnProc;
    BOOL bAnsi;
} FNHKINLPCBTCREATESTRUCTMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPCBTCREATESTRUCT(
    UINT msg,
    WPARAM wParam,
    LPCBT_CREATEWND pcbt,
    PROC xpfnProc,
    BOOL fAnsiReceiver)
{
    DWORD cbTitle = 0, cbClass = 0;
    DWORD cCapture = 0;
    CREATESTRUCTDATA csdOut;
    PCREATESTRUCTEX pcreatestruct;
    PWND pwnd = _GetDesktopWindow();

    SETUPPWND(FNHKINLPCBTCREATESTRUCT)

    /*
     * Compute ANSI capture lengths.  Don't capture if
     * the strings are in the client's address space.
     */
    pcreatestruct = (PCREATESTRUCTEX)pcbt->lpcs;
    if (pcreatestruct->cs.lpszName &&
            ((BOOL)pcreatestruct->strName.bAnsi != fAnsiReceiver ||
            IS_SYSTEM_ADDRESS((PVOID)pcreatestruct->cs.lpszName))) {
        CALC_SIZE_IN(cbTitle, &pcreatestruct->strName);
        cCapture++;
    }
    if (IS_PTR(pcreatestruct->cs.lpszClass) &&
            ((BOOL)pcreatestruct->strClass.bAnsi != fAnsiReceiver ||
            IS_SYSTEM_ADDRESS((PVOID)pcreatestruct->cs.lpszClass))) {
        CALC_SIZE_IN(cbClass, &pcreatestruct->strClass);
        cCapture++;
    }

    BEGINSENDCAPTURE(FNHKINLPCBTCREATESTRUCT, cCapture, cbTitle + cbClass, TRUE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;

        MSGDATA()->d.cs = *(pcbt->lpcs);

        if (cbTitle) {
            if (!pcreatestruct->strName.bAnsi) {
                WORD wOrdinal;

                try {
                    wOrdinal = *(PWORD)pcreatestruct->cs.lpszName;
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                    goto errorexit;
                }
                if (wOrdinal == 0xffff) {

                    /*
                     * Copy out an ordinal of the form 0xffff, ID.
                     * If the receiver is ANSI, skip the first 0xff.
                     */
                    if (fAnsiReceiver) {
                        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,
                                (PBYTE)pcreatestruct->cs.lpszName + 1,
                                3, (PVOID *)&mp->d.cs.lpszName)))
                            goto errorexit;
                    } else {
                        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,
                                (PBYTE)pcreatestruct->cs.lpszName,
                                4, (PVOID *)&mp->d.cs.lpszName)))
                            goto errorexit;
                    }
                } else if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPWSTRA(&pcreatestruct->strName, d.cs.lpszName);
                } else {
                    LARGECOPYSTRINGLPWSTR(&pcreatestruct->strName, d.cs.lpszName);
                }
            } else {
                BYTE bOrdinal;

                try {
                    bOrdinal = *(PBYTE)pcreatestruct->cs.lpszName;
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                    goto errorexit;
                }
                if (bOrdinal == 0xff) {

                    /*
                     * Copy out an ordinal of the form 0xff, ID.
                     * If the receiver is UNICODE, expand the 0xff to 0xffff.
                     */
                    if (fAnsiReceiver) {
                        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,
                                (PBYTE)pcreatestruct->cs.lpszName,
                                3, (PVOID *)&mp->d.cs.lpszName)))
                            goto errorexit;
                    } else {
                        DWORD dwOrdinal;

                        try {
                            dwOrdinal = MAKELONG(0xffff,
                                    (*(DWORD UNALIGNED *)pcreatestruct->cs.lpszName >> 8));
                        } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                            goto errorexit;
                        }
                        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,
                                &dwOrdinal,
                                4, (PVOID *)&mp->d.cs.lpszName)))
                            goto errorexit;
                    }
                } else if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPSTR(&pcreatestruct->strName, d.cs.lpszName);
                } else {
                    LARGECOPYSTRINGLPSTRW(&pcreatestruct->strName, d.cs.lpszName);
                }
            }
        }
        if (cbClass) {
            if (!pcreatestruct->strClass.bAnsi) {
                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPWSTRA(&pcreatestruct->strClass, d.cs.lpszClass);
                } else {
                    LARGECOPYSTRINGLPWSTR(&pcreatestruct->strClass, d.cs.lpszClass);
                }
            } else {
                if (fAnsiReceiver) {
                    LARGECOPYSTRINGLPSTR(&pcreatestruct->strClass, d.cs.lpszClass);
                } else {
                    LARGECOPYSTRINGLPSTRW(&pcreatestruct->strClass, d.cs.lpszClass);
                }
            }
        }

        MSGDATA()->d.hwndInsertAfter = pcbt->hwndInsertAfter;
        MSGDATA()->xpfnProc = xpfnProc;
        MSGDATA()->bAnsi = fAnsiReceiver;

        LOCKPWND();
        MAKECALLCAPTURE(FNHKINLPCBTCREATESTRUCT);
        UNLOCKPWND();
        CHECKRETURN();

        /*
         * Probe output data
         */
        OUTSTRUCT(&csdOut, CREATESTRUCTDATA);

        // MS Visual C centers its dialogs with the CBT_CREATEHOOK
        pcbt->hwndInsertAfter = csdOut.hwndInsertAfter;
        pcbt->lpcs->x  = csdOut.cs.x;
        pcbt->lpcs->y  = csdOut.cs.y;
        pcbt->lpcs->cx = csdOut.cs.cx;
        pcbt->lpcs->cy = csdOut.cs.cy;

    TRACECALLBACK("SfnHkINLPCBTCREATESTRUCT");
    ENDSENDCAPTURE(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPCBTCREATESTRUCT, FNHKINLPCBTCREATESTRUCTMSG)
{
    CBT_CREATEWND cbt;

    BEGINRECV(0, &pmsg->d, sizeof(pmsg->d));
    FIXUPPOINTERS();

    cbt.lpcs = &pmsg->d.cs;
    cbt.hwndInsertAfter = pmsg->d.hwndInsertAfter;
    if ((ULONG_PTR)pmsg->d.cs.lpszName > gHighestUserAddress)
        pmsg->d.cs.lpszName = REBASEPTR(pmsg->pwnd, pmsg->d.cs.lpszName);
    if ((ULONG_PTR)pmsg->d.cs.lpszClass > gHighestUserAddress)
        pmsg->d.cs.lpszClass = REBASEPTR(pmsg->pwnd, pmsg->d.cs.lpszClass);

    if (pmsg->bAnsi) {
        retval = DispatchHookA(
                pmsg->msg,
                pmsg->wParam,
                (LPARAM)&cbt,
                (HOOKPROC)pmsg->xpfnProc);
    } else {
        retval = DispatchHookW(
                pmsg->msg,
                pmsg->wParam,
                (LPARAM)&cbt,
                (HOOKPROC)pmsg->xpfnProc);
    }

    pmsg->d.hwndInsertAfter = cbt.hwndInsertAfter;
    pmsg->d.cs.x  = cbt.lpcs->x;
    pmsg->d.cs.y  = cbt.lpcs->y;
    pmsg->d.cs.cx = cbt.lpcs->cx;
    pmsg->d.cs.cy = cbt.lpcs->cy;

    ENDRECV();
}
#endif // RECVSIDE

#ifdef REDIRECTION

/**************************************************************************\
* fnHkINLPPOINT
*
* 29-Jan-1999 clupu    Created
\**************************************************************************/

typedef struct _FNHKINLPPOINTMSG {
    DWORD nCode;
    WPARAM wParam;
    POINT pt;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNHKINLPPOINTMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPPOINT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN OUT LPPOINT ppt,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc)
{
    SETUP(FNHKINLPPOINT)

    BEGINSEND(FNHKINLPPOINT)

        MSGDATA()->nCode = nCode;
        MSGDATA()->wParam = wParam;
        MSGDATA()->pt = *ppt;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        MAKECALL(FNHKINLPPOINT);
        CHECKRETURN();

        /*
         * Probe output data
         */
        OUTSTRUCT(ppt, POINT);

    TRACECALLBACK("SfnHkINLPPOINT");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPPOINT, FNHKINLPPOINTMSG)
{
    BEGINRECV(0, &pmsg->pt, sizeof(POINT));

    retval = (DWORD)CALLPROC(pmsg->xpfnProc)(
            pmsg->nCode,
            pmsg->wParam,
            PCALLDATA(pt),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

#endif // REDIRECTION


/**************************************************************************\
* fnHkINLPRECT
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNHKINLPRECTMSG {
    DWORD nCode;
    WPARAM wParam;
    RECT rect;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNHKINLPRECTMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPRECT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN OUT LPRECT prect,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc)
{
    SETUP(FNHKINLPRECT)

    BEGINSEND(FNHKINLPRECT)

        MSGDATA()->nCode = nCode;
        MSGDATA()->wParam = wParam;
        MSGDATA()->rect = *prect;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        MAKECALL(FNHKINLPRECT);
        CHECKRETURN();

        /*
         * Probe output data
         */
        OUTSTRUCT(prect, RECT);

    TRACECALLBACK("SfnHkINLPRECT");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPRECT, FNHKINLPRECTMSG)
{
    BEGINRECV(0, &pmsg->rect, sizeof(RECT));

    retval = (DWORD)CALLPROC(pmsg->xpfnProc)(
            pmsg->nCode,
            pmsg->wParam,
            PCALLDATA(rect),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNHKINDWORDMSG {
    GENERICHOOKHEADER ghh;
    DWORD flags;
    LPARAM lParam;
} FNHKINDWORDMSG;

#ifdef SENDSIDE
LRESULT fnHkINDWORD(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPARAM lParam,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc,
    IN OUT LPDWORD lpFlags)
{
    SETUP(FNHKINDWORD)

    BEGINSEND(FNHKINDWORD)

        MSGDATA()->ghh.nCode = nCode;
        MSGDATA()->ghh.wParam = wParam;
        MSGDATA()->lParam = lParam;
        MSGDATA()->ghh.xParam = xParam;
        MSGDATA()->ghh.xpfnProc = xpfnProc;
        MSGDATA()->flags = *lpFlags;

        MAKECALL(FNHKINDWORD);
        CHECKRETURN();

        /*
         * Probe output data
         */
        OUTBITMASK(lpFlags, DWORD, HF_HOOKFAULTED);

    TRACECALLBACK("SfnHkINDWORD");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINDWORD, FNHKINDWORDMSG)
{
    BEGINRECV(0, &pmsg->flags, sizeof(pmsg->flags));

    retval = CallHookWithSEH((LPGENERICHOOKHEADER)pmsg, (LPVOID)pmsg->lParam, &pmsg->flags, retval);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNHKINLPMSGDATA {
    MSG msg;
    DWORD flags;
} FNHKINLPMSGDATA;

typedef struct _FNHKINLPMSGMSG {
    GENERICHOOKHEADER ghh;
    FNHKINLPMSGDATA d;
} FNHKINLPMSGMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPMSG(
    DWORD nCode,
    WPARAM wParam,
    LPMSG pmsg,
    ULONG_PTR xParam,
    PROC xpfnProc,
    BOOL bAnsi,
    LPDWORD lpFlags)
{
    SETUP(FNHKINLPMSG)
    WPARAM wParamOriginal;

    BEGINSEND(FNHKINLPMSG)

        MSGDATA()->ghh.nCode = nCode;
        MSGDATA()->ghh.wParam = wParam;

        MSGDATA()->d.msg = *pmsg;
        if (((WM_CHAR == pmsg->message) || (WM_SYSCHAR == pmsg->message)) && bAnsi) {
            wParamOriginal = pmsg->wParam;
            RtlWCSMessageWParamCharToMB(pmsg->message, &(MSGDATA()->d.msg.wParam));
        }

        MSGDATA()->ghh.xParam = xParam;
        MSGDATA()->ghh.xpfnProc = xpfnProc;
        MSGDATA()->d.flags = *lpFlags;

        MAKECALL(FNHKINLPMSG);
        CHECKRETURN();

        /*
         * Probe output data
         */
        try {
            ProbeForRead(pcbs->pOutput, sizeof(FNHKINLPMSGDATA), sizeof(DWORD));
            *pmsg = ((FNHKINLPMSGDATA *)pcbs->pOutput)->msg;
            COPY_FLAG(*lpFlags, ((FNHKINLPMSGDATA *)pcbs->pOutput)->flags, HF_HOOKFAULTED);
        } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
            MSGERROR();
        }

        if (((WM_CHAR == pmsg->message) || (WM_SYSCHAR == pmsg->message)) && bAnsi) {
            /*
             * LATER, DBCS should be handled correctly.
             */
            /*
             * If the ANSI hook didn't change the wParam we sent it, restore
             * the Unicode value we started with, otherwise we just collapse
             * Unicode chars to an ANSI codepage (best visual fit or ?)
             * The rotten "Intellitype" point32.exe does this.
             */
            if (MSGDATA()->d.msg.wParam == pmsg->wParam) {
                pmsg->wParam = wParamOriginal;
            } else {
                RtlMBMessageWParamCharToWCS(pmsg->message, &pmsg->wParam);
            }
        }

    TRACECALLBACK("SfnHkINLPMSG");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPMSG, FNHKINLPMSGMSG)
{
    BEGINRECV(0, &pmsg->d, sizeof(pmsg->d));

    /*
     * LATER, DBCS should be handled correctly.
     */

    retval = CallHookWithSEH((LPGENERICHOOKHEADER)pmsg, &pmsg->d.msg, &pmsg->d.flags, retval);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNHKINLPMOUSEHOOKSTRUCTEXMSG {
    GENERICHOOKHEADER ghh;
    DWORD flags;
    MOUSEHOOKSTRUCTEX mousehookstructex;
} FNHKINLPMOUSEHOOKSTRUCTEXMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPMOUSEHOOKSTRUCTEX(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPMOUSEHOOKSTRUCTEX pmousehookstructex,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc,
    IN OUT LPDWORD lpFlags)
{
    SETUP(FNHKINLPMOUSEHOOKSTRUCTEX)

    BEGINSEND(FNHKINLPMOUSEHOOKSTRUCTEX)

        MSGDATA()->ghh.nCode = nCode;
        MSGDATA()->ghh.wParam = wParam;
        MSGDATA()->mousehookstructex = *pmousehookstructex;
        MSGDATA()->ghh.xParam = xParam;
        MSGDATA()->ghh.xpfnProc = xpfnProc;
        MSGDATA()->flags = *lpFlags;

        MAKECALL(FNHKINLPMOUSEHOOKSTRUCTEX);
        CHECKRETURN();

        /*
         * Probe output data
         */
        OUTBITMASK(lpFlags, DWORD, HF_HOOKFAULTED);

    TRACECALLBACK("SfnHkINLPMOUSEHOOKSTRUCTEX");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPMOUSEHOOKSTRUCTEX, FNHKINLPMOUSEHOOKSTRUCTEXMSG)
{
    BEGINRECV(0, &pmsg->flags, sizeof(pmsg->flags));

    retval = CallHookWithSEH((LPGENERICHOOKHEADER)pmsg, &pmsg->mousehookstructex, &pmsg->flags, retval);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* kbdll
*
* 06-Jun-1996 clupu    Created
\**************************************************************************/

typedef struct _FNHKINLPKBDLLHOOKSTRUCTMSG {
    GENERICHOOKHEADER ghh;
    KBDLLHOOKSTRUCT   kbdllhookstruct;
} FNHKINLPKBDLLHOOKSTRUCTMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPKBDLLHOOKSTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPKBDLLHOOKSTRUCT pkbdllhookstruct,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc)
{
    SETUP(FNHKINLPKBDLLHOOKSTRUCT)

    BEGINSEND(FNHKINLPKBDLLHOOKSTRUCT)

        MSGDATA()->ghh.nCode       = nCode;
        MSGDATA()->ghh.wParam      = wParam;
        MSGDATA()->kbdllhookstruct = *pkbdllhookstruct;
        MSGDATA()->ghh.xParam      = xParam;
        MSGDATA()->ghh.xpfnProc    = xpfnProc;

        MAKECALL(FNHKINLPKBDLLHOOKSTRUCT);
        CHECKRETURN();

    TRACECALLBACK("SfnHkINLPKBDLLHOOKSTRUCT");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPKBDLLHOOKSTRUCT, FNHKINLPKBDLLHOOKSTRUCTMSG)
{
    BEGINRECV(0, &pmsg->kbdllhookstruct, sizeof(pmsg->kbdllhookstruct));

    retval = (DWORD)CALLPROC(pmsg->ghh.xpfnProc)(
            pmsg->ghh.nCode,
            pmsg->ghh.wParam,
            &pmsg->kbdllhookstruct,
            pmsg->ghh.xParam);

    ENDRECV();
}
#endif // RECVSIDE


/**************************************************************************\
* msll
*
* 06-Jun-1996 clupu    Created
\**************************************************************************/

typedef struct _FNHKINLPMSLLHOOKSTRUCTMSG {
    GENERICHOOKHEADER ghh;
    MSLLHOOKSTRUCT    msllhookstruct;
} FNHKINLPMSLLHOOKSTRUCTMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPMSLLHOOKSTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPMSLLHOOKSTRUCT pmsllhookstruct,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc)
{
    SETUP(FNHKINLPMSLLHOOKSTRUCT)

    BEGINSEND(FNHKINLPMSLLHOOKSTRUCT)

        MSGDATA()->ghh.nCode      = nCode;
        MSGDATA()->ghh.wParam     = wParam;
        MSGDATA()->msllhookstruct = *pmsllhookstruct;
        MSGDATA()->ghh.xParam     = xParam;
        MSGDATA()->ghh.xpfnProc   = xpfnProc;

        MAKECALL(FNHKINLPMSLLHOOKSTRUCT);
        CHECKRETURN();

    TRACECALLBACK("SfnHkINLPMSLLHOOKSTRUCT");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPMSLLHOOKSTRUCT, FNHKINLPMSLLHOOKSTRUCTMSG)
{
    BEGINRECV(0, &pmsg->msllhookstruct, sizeof(pmsg->msllhookstruct));

    retval = (DWORD)CALLPROC(pmsg->ghh.xpfnProc)(
            pmsg->ghh.nCode,
            pmsg->ghh.wParam,
            &pmsg->msllhookstruct,
            pmsg->ghh.xParam);

    ENDRECV();
}
#endif // RECVSIDE

#ifdef REDIRECTION
/**************************************************************************\
* ht
*
* 21-Jan-1999 clupu    Created
\**************************************************************************/

typedef struct _FNHKINLPHTHOOKSTRUCTMSG {
    GENERICHOOKHEADER ghh;
    HTHOOKSTRUCT      hthookstruct;
} FNHKINLPHTHOOKSTRUCTMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPHTHOOKSTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN OUT LPHTHOOKSTRUCT phthookstruct,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc)
{
    SETUP(FNHKINLPHTHOOKSTRUCT)

    BEGINSEND(FNHKINLPHTHOOKSTRUCT)

        MSGDATA()->ghh.nCode      = nCode;
        MSGDATA()->ghh.wParam     = wParam;
        MSGDATA()->hthookstruct   = *phthookstruct;
        MSGDATA()->ghh.xParam     = xParam;
        MSGDATA()->ghh.xpfnProc   = xpfnProc;

        MAKECALL(FNHKINLPHTHOOKSTRUCT);
        CHECKRETURN();

        /*
         * Probe output data
         */
        if (phthookstruct != NULL)
            OUTSTRUCT(phthookstruct, HTHOOKSTRUCT);

    TRACECALLBACK("SfnHkINLPHTHOOKSTRUCT");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPHTHOOKSTRUCT, FNHKINLPHTHOOKSTRUCTMSG)
{
    BEGINRECV(0, &pmsg->hthookstruct, sizeof(pmsg->hthookstruct));

    retval = (DWORD)CALLPROC(pmsg->ghh.xpfnProc)(
            pmsg->ghh.nCode,
            pmsg->ghh.wParam,
            &pmsg->hthookstruct,
            pmsg->ghh.xParam);

    ENDRECV();
}
#endif // RECVSIDE

#endif // REDIRECTION

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _FNHKOPTINLPEVENTMSGMSG {
    DWORD nCode;
    WPARAM wParam;
    LPEVENTMSGMSG peventmsgmsg;
    ULONG_PTR xParam;
    PROC xpfnProc;
    EVENTMSG eventmsgmsg;
} FNHKOPTINLPEVENTMSGMSG;

#ifdef SENDSIDE
LRESULT fnHkOPTINLPEVENTMSG(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN OUT LPEVENTMSGMSG peventmsgmsg,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc)
{
    SETUP(FNHKOPTINLPEVENTMSG)

    BEGINSEND(FNHKOPTINLPEVENTMSG)

        MSGDATA()->nCode = nCode;
        MSGDATA()->wParam = wParam;
        COPYSTRUCTOPT(eventmsgmsg);
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        MAKECALL(FNHKOPTINLPEVENTMSG);
        CHECKRETURN();

        /*
         * Probe output data
         */
        if (peventmsgmsg != NULL)
            OUTSTRUCT(peventmsgmsg, EVENTMSG);

    TRACECALLBACK("SfnHkOPTINLPEVENTMSG");
    ENDSEND(DWORD,-1);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkOPTINLPEVENTMSG, FNHKOPTINLPEVENTMSGMSG)
{
    PHOOK phk;

    BEGINRECV(-1, &pmsg->eventmsgmsg, sizeof(pmsg->eventmsgmsg));

    if (pmsg->wParam) {
        phk = (PHOOK)HMValidateHandle((HANDLE)pmsg->wParam, TYPE_HOOK);

        if (phk != NULL) {
            /*
             * The HF_NEEDHC_SKIP bit is passed on from the pti when we need to
             * pass on a HC_SKIP
             */
            if ((phk->flags & HF_NEEDHC_SKIP) &&
                    (HIWORD(pmsg->nCode) == WH_JOURNALPLAYBACK)) {
                UserAssert(LOWORD(pmsg->nCode) == HC_GETNEXT);
                CALLPROC(pmsg->xpfnProc)(
                    MAKELONG(HC_SKIP, HIWORD(pmsg->nCode)),
                    0,
                    0,
                    pmsg->xParam);
            }

            /*
             * Make sure the hook wasn't free'd during the last call to the app
             */
            if (HMIsMarkDestroy(phk)) {
                retval = (DWORD)-1;
                goto AllDoneHere;
            }
        }
    }

    pmsg->wParam = 0;

    retval = (DWORD)CALLPROC(pmsg->xpfnProc)(
            pmsg->nCode,
            pmsg->wParam,
            PCALLDATAOPT(eventmsgmsg),
            pmsg->xParam);

AllDoneHere:
    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

/*
 * Create a structure big enough to hold the larges item LPARAM points to.
 */
typedef union _DEBUGLPARAM {
    MSG msg;                // WH_GETMESSAGE, WH_MSGFILTER, WH_SYSMSGFILTER
    CWPSTRUCT cwp;          // WH_CALLWNDPROC
    CWPRETSTRUCT cwpret;    // WH_CALLWNDPROCRET
    MOUSEHOOKSTRUCTEX mhs;  // WH_MOUSE, HCBT_CLICKSKIPPED
    EVENTMSG em;            // WH_JOURNALRECORD, WH_JOURNALPLAYBACK
    CBTACTIVATESTRUCT as;   // HCBT_ACTIVATE
    CBT_CREATEWND cw;       // HCBT_CREATEWND
    RECT rc;                // HCBT_MOVESIZE
} DEBUGLPARAM;


typedef struct _FNHKINLPDEBUGHOOKSTRUCTMSG {
    DWORD nCode;
    WPARAM wParam;
    DEBUGHOOKINFO debughookstruct;
    DEBUGLPARAM dbgLParam;
    DWORD cbDbgLParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNHKINLPDEBUGHOOKSTRUCTMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPDEBUGHOOKSTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPDEBUGHOOKINFO pdebughookstruct,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc)
{
    SETUP(FNHKINLPDEBUGHOOKSTRUCT)

    BEGINSEND(FNHKINLPDEBUGHOOKSTRUCT)

        MSGDATA()->nCode = nCode;
        MSGDATA()->wParam = wParam;
        MSGDATA()->debughookstruct = *pdebughookstruct;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;
        MSGDATA()->cbDbgLParam = GetDebugHookLParamSize(wParam, pdebughookstruct);

        switch(wParam) {
        case WH_MOUSE_LL:
        case WH_KEYBOARD_LL:
            return 0;
         }

        /*
         * if LPARAM in the debug hook points to struct then copy it over
         */
        if (MSGDATA()->cbDbgLParam) {
            try {
                RtlCopyMemory(&MSGDATA()->dbgLParam, (BYTE *)pdebughookstruct->lParam,
                        MSGDATA()->cbDbgLParam);
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                MSGERROR();
            }
        }

        MAKECALL(FNHKINLPDEBUGHOOKSTRUCT);
        CHECKRETURN();

    TRACECALLBACK("SfnHkINLPDEBUGHOOKSTRUCT");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPDEBUGHOOKSTRUCT, FNHKINLPDEBUGHOOKSTRUCTMSG)
{
    BEGINRECV(0, NULL, 0);

    if (pmsg->cbDbgLParam) {
        pmsg->debughookstruct.lParam = (LPARAM)&(pmsg->dbgLParam);
    }

    retval = (DWORD)CALLPROC(pmsg->xpfnProc)(
            pmsg->nCode,
            pmsg->wParam,
            &(pmsg->debughookstruct),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

DWORD GetDebugHookLParamSize(
    IN WPARAM wParam,
    IN PDEBUGHOOKINFO pdebughookstruct)
{
    DWORD cbDbgLParam = 0;

    switch(wParam) {
    case WH_MSGFILTER:
    case WH_SYSMSGFILTER:
    case WH_GETMESSAGE:
        cbDbgLParam = sizeof(MSG);
        break;

    case WH_CALLWNDPROC:
        cbDbgLParam = sizeof(CWPSTRUCT);
        break;

    case WH_CALLWNDPROCRET:
        cbDbgLParam = sizeof(CWPRETSTRUCT);
        break;

    case WH_MOUSE:
        cbDbgLParam = sizeof(MOUSEHOOKSTRUCTEX);
        break;

    case WH_JOURNALRECORD:
    case WH_JOURNALPLAYBACK:
        cbDbgLParam = sizeof(EVENTMSG);
        break;

    case WH_CBT:
        switch (pdebughookstruct->code) {
        case HCBT_ACTIVATE:
            cbDbgLParam = sizeof(CBTACTIVATESTRUCT);
            break;
        case HCBT_CLICKSKIPPED:
            cbDbgLParam = sizeof(MOUSEHOOKSTRUCTEX);
            break;
        case HCBT_CREATEWND:
            cbDbgLParam = sizeof(CBT_CREATEWND);
            break;
        case HCBT_MOVESIZE:
            cbDbgLParam = sizeof(RECT);
            break;
        }
        break;

    case WH_SHELL:
        if (pdebughookstruct->code == HSHELL_GETMINRECT) {
            cbDbgLParam = sizeof(RECT);
        }
        break;
    }
    return cbDbgLParam;
}

/**************************************************************************\
* fnHkINLPCBTACTIVATESTRUCT
*
* 17-Mar-1992 jonpa    Created
\**************************************************************************/

typedef struct _FNHKINLPCBTACTIVATESTRUCTMSG {
    DWORD nCode;
    WPARAM wParam;
    CBTACTIVATESTRUCT cbtactivatestruct;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNHKINLPCBTACTIVATESTRUCTMSG;

#ifdef SENDSIDE
LRESULT fnHkINLPCBTACTIVATESTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPCBTACTIVATESTRUCT pcbtactivatestruct,
    IN ULONG_PTR xParam,
    IN PROC xpfnProc)
{
    SETUP(FNHKINLPCBTACTIVATESTRUCT)

    BEGINSEND(FNHKINLPCBTACTIVATESTRUCT)

        MSGDATA()->nCode = nCode;
        MSGDATA()->wParam = wParam;
        MSGDATA()->cbtactivatestruct = *pcbtactivatestruct;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        MAKECALL(FNHKINLPCBTACTIVATESTRUCT);
        CHECKRETURN();

    TRACECALLBACK("SfnHkINLPCBTACTIVATESTRUCT");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnHkINLPCBTACTIVATESTRUCT, FNHKINLPCBTACTIVATESTRUCTMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (DWORD)CALLPROC(pmsg->xpfnProc)(
            pmsg->nCode,
            pmsg->wParam,
            &(pmsg->cbtactivatestruct),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE


/**************************************************************************\
* ClientLoadMenu
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _CLIENTLOADMENUMSG {
    CAPTUREBUF CaptureBuf;
    HANDLE hmod;
    UNICODE_STRING strName;
} CLIENTLOADMENUMSG;

#ifdef SENDSIDE
PMENU xxxClientLoadMenu(
    IN HANDLE hmod,
    IN PUNICODE_STRING pstrName)
{
    DWORD cCapture, cbCapture;

    SETUP(CLIENTLOADMENU)

    if (pstrName->MaximumLength) {
        cCapture = 1;
        cbCapture = pstrName->MaximumLength;
    } else
        cCapture = cbCapture = 0;

    BEGINSENDCAPTURE(CLIENTLOADMENU, cCapture, cbCapture, TRUE)

        MSGDATA()->hmod = hmod;
        COPYSTRINGID(strName);

        MAKECALLCAPTURE(CLIENTLOADMENU);
        CHECKRETURN();

        retval = (ULONG_PTR)HtoP((HMENU)retval);

    TRACECALLBACK("ClientLoadMenu");
    ENDSENDCAPTURE(PMENU,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientLoadMenu, CLIENTLOADMENUMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)LoadMenu(
            CALLDATA(hmod) ? CALLDATA(hmod) : hmodUser,
            (LPTSTR)FIXUPSTRINGID(strName));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* xxxClientLoadImage
*
* 28-Aug-1995 ChrisWil    Created
\**************************************************************************/

typedef struct _CLIENTLOADIMAGEMSG {
    CAPTUREBUF     CaptureBuf;
    UNICODE_STRING strModName;
    UNICODE_STRING strName;
    UINT           uImageType;
    int            cxDesired;
    int            cyDesired;
    UINT           LR_flags;
    BOOL           fWallpaper;
} CLIENTLOADIMAGEMSG;

#ifdef SENDSIDE
HANDLE xxxClientLoadImage(
    IN PUNICODE_STRING pstrName,
    IN ATOM            atomModName,
    IN WORD            wImageType,
    IN int             cxDesired,
    IN int             cyDesired,
    IN UINT            LR_flags,
    IN BOOL            fWallpaper)
{
    DWORD           cCapture;
    DWORD           cbCapture;
    WCHAR           awszModName[MAX_PATH];
    UNICODE_STRING  strModName;
    PUNICODE_STRING pstrModName = &strModName;

    SETUP(CLIENTLOADIMAGE)

    if (pstrName->MaximumLength) {
        cCapture  = 1;
        cbCapture = pstrName->MaximumLength;
    } else {
        cCapture  =
        cbCapture = 0;
    }
    if (atomModName && atomModName != atomUSER32) {
        UserGetAtomName(atomModName, awszModName, MAX_PATH);
        RtlInitUnicodeString(&strModName, awszModName);
    } else {
        strModName.Length = strModName.MaximumLength = 0;
        strModName.Buffer = NULL;
    }
    if (pstrModName->MaximumLength) {
        cCapture++;
        cbCapture += pstrModName->MaximumLength;
    }

    BEGINSENDCAPTURE(CLIENTLOADIMAGE, cCapture, cbCapture, TRUE)

        COPYSTRINGOPT(strModName);
        COPYSTRINGID(strName);
        MSGDATA()->uImageType = (UINT)wImageType;
        MSGDATA()->cxDesired  = cxDesired;
        MSGDATA()->cyDesired  = cyDesired;
        MSGDATA()->LR_flags   = LR_flags;
        MSGDATA()->fWallpaper = fWallpaper;

        MAKECALLCAPTURE(CLIENTLOADIMAGE);
        CHECKRETURN();

        if (retval && (wImageType != IMAGE_BITMAP)) {
            retval = (ULONG_PTR)HMRevalidateHandle((HANDLE)retval);
        }

    TRACECALLBACK("ClientLoadImage");
    ENDSENDCAPTURE(PCURSOR,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientLoadImage, CLIENTLOADIMAGEMSG)
{
    HMODULE hmod;
    LPTSTR  filepart;
    LPTSTR  lpszName;
    TCHAR   szFullPath[MAX_PATH];
    TCHAR   szExpandedPath[MAX_PATH];
    DWORD   dwRet;

    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    if (hmod = (HMODULE)FIXUPSTRINGIDOPT(strModName)) {

        if ((hmod = GetModuleHandle((LPTSTR)hmod)) == NULL) {
            MSGERROR();
        }
    }

    /*
     * Find the file.  This normalizes the filename.
     */
    lpszName = (LPTSTR)FIXUPSTRINGID(strName);

    if (CALLDATA(fWallpaper)) {

        /*
         * Expand any environment strings in the path. This is beneficial
         * for people using roaming profiles. See bug #89188.
         */
        dwRet = ExpandEnvironmentStrings(lpszName, szExpandedPath, MAX_PATH);

        /*
         * dwRet > MAX_PATH means that the buffer we supplied was too small. If
         * this happens, there's no way the LoadImage can succeed - even if the
         * buffer were big enough, as the filename can't possibly refer to a
         * valid file - so fail the call.
         */
        if (dwRet == 0 || dwRet > MAX_PATH) {
            MSGERROR();
        }

        if (!SearchPath(NULL,
                       szExpandedPath,
                       TEXT(".bmp"),
                       ARRAY_SIZE(szFullPath),
                       szFullPath,
                       &filepart)) {

            MSGERROR();
        }

        lpszName = szFullPath;
    }

    retval = (ULONG_PTR)LoadImage(hmod,
                              lpszName,
                              CALLDATA(uImageType),
                              CALLDATA(cxDesired),
                              CALLDATA(cyDesired),
                              CALLDATA(LR_flags));

    ENDRECV();
}
#endif // RECVSIDE

/***********************************************************************\
* xxxClientCopyImage
*
* Returns: hIconCopy - note LR_flags could cause this to be the same as
*       what came in.
*
* 11/3/1995 Created SanfordS
\***********************************************************************/

typedef struct _CLIENTCOPYIMAGEMSG {
    HANDLE         hImage;
    UINT           uImageType;
    int            cxDesired;
    int            cyDesired;
    UINT           LR_flags;
} CLIENTCOPYIMAGEMSG;

#ifdef SENDSIDE
HANDLE xxxClientCopyImage(
    IN HANDLE          hImage,
    IN UINT            uImageType,
    IN int             cxDesired,
    IN int             cyDesired,
    IN UINT            LR_flags)
{
    SETUP(CLIENTCOPYIMAGE)

    BEGINSEND(CLIENTCOPYIMAGE)

        MSGDATA()->hImage     = hImage;
        MSGDATA()->uImageType = uImageType;
        MSGDATA()->cxDesired  = cxDesired;
        MSGDATA()->cyDesired  = cyDesired;
        MSGDATA()->LR_flags   = LR_flags;

        MAKECALL(CLIENTCOPYIMAGE);
        CHECKRETURN();

        if (retval && (uImageType != IMAGE_BITMAP)) {
            retval = (ULONG_PTR)HMRevalidateHandle((HANDLE)retval);
        }

    TRACECALLBACK("ClientCopyImage");
    ENDSEND(HANDLE,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientCopyImage, CLIENTCOPYIMAGEMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)InternalCopyImage(CALLDATA(hImage),
                                      CALLDATA(uImageType),
                                      CALLDATA(cxDesired),
                                      CALLDATA(cyDesired),
                                      CALLDATA(LR_flags));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _CLIENTGETLISTBOXSTRINGMSG {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfn;
    PBYTE pOutput;
    DWORD cbOutput;
} CLIENTGETLISTBOXSTRINGMSG;

#ifdef SENDSIDE
DWORD ClientGetListboxString(
    IN PWND pwnd,
    IN UINT msg,
    IN WPARAM wParam,
    OUT PVOID pdata,
    IN ULONG_PTR xParam,
    IN PROC xpfn,
    IN DWORD dwSCMSFlags,
    IN BOOL bNotString,
    IN PSMS psms)
{
    DWORD cbCapture;
    DWORD cchRet;
    PLARGE_STRING pstr;
    BOOL fAnsiReceiver = (dwSCMSFlags & SCMS_FLAGS_ANSI);

    SETUPPWND(CLIENTGETLISTBOXSTRING)

    CheckLock(pwnd);

    pstr = (PLARGE_STRING)pdata;
    cbCapture = pstr->MaximumLength;

    BEGINSENDCAPTURE(CLIENTGETLISTBOXSTRING, 1, cbCapture, FALSE)

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfn = xpfn;

        RESERVEBYTES(cbCapture, pOutput, cbOutput);

        LOCKPWND();
        MAKECALLCAPTURE(CLIENTGETLISTBOXSTRING);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            if (bNotString) {
                /*
                 * This is a 4-byte "object" for ownerdraw listboxes without
                 * the LBS_HASSTRINGS style.
                 */
                OUTSTRUCT((PULONG_PTR)pstr->Buffer, ULONG_PTR);
            } else {
                COPYOUTLPWSTRLIMIT(pstr,
                        pstr->bAnsi ? (int)pstr->MaximumLength :
                        (int)pstr->MaximumLength / sizeof(WCHAR));
            }

            cchRet = pstr->Length;
            if (!pstr->bAnsi)
                cchRet *= sizeof(WCHAR);
            if (!bNotString && retval != LB_ERR && retval > cchRet) {
                RIPMSG2(RIP_WARNING, "GetListBoxString: limit %lX chars to %lX\n",
                        retval, cchRet);
                retval = cchRet;
            }
        ENDCOPYOUT()

    TRACECALLBACK("ClientGetListboxString");
    ENDSENDCAPTURE(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientGetListboxString, CLIENTGETLISTBOXSTRINGMSG)
{
    BYTE abOutput[CALLBACKSTACKLIMIT];

    BEGINRECV(0, NULL, pmsg->cbOutput);
    FIXUPPOINTERS();
    if (pmsg->cbOutput <= CALLBACKSTACKLIMIT)
        CallbackStatus.pOutput = abOutput;
    else
        CallbackStatus.pOutput = pmsg->pOutput;

    retval = (DWORD)_ClientGetListboxString(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            (LPSTR)KPVOID_TO_PVOID(CallbackStatus.pOutput),
            CALLDATA(xParam),
            CALLDATA(xpfn));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _CLIENTLOADLIBRARYMSG {
    CAPTUREBUF CaptureBuf;
    UNICODE_STRING strLib;
    ULONG_PTR      offPfnInitUserApiHook;
} CLIENTLOADLIBRARYMSG;

#ifdef SENDSIDE
HANDLE ClientLoadLibrary(
    IN PUNICODE_STRING pstrLib,
    IN ULONG_PTR offPfnInitUserApiHook)
{
    SETUP(CLIENTLOADLIBRARY)

    BEGINSENDCAPTURE(CLIENTLOADLIBRARY, 1, pstrLib->MaximumLength, TRUE)

        MSGDATA()->offPfnInitUserApiHook = offPfnInitUserApiHook;
        COPYSTRING(strLib);

        MAKECALLCAPTURE(CLIENTLOADLIBRARY);
        CHECKRETURN();

    TRACECALLBACK("ClientLoadLibrary");
    ENDSENDCAPTURE(HANDLE,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientLoadLibrary, CLIENTLOADLIBRARYMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (ULONG_PTR)LoadLibraryEx((LPTSTR)FIXUPSTRING(strLib), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    /*
     * If we're loading the module containing the UserApiHook's,
     * make sure it's correctly initialized.
     */
    if ((retval != 0) && CALLDATA(offPfnInitUserApiHook)) {
        if (!InitUserApiHook((HMODULE)retval, CALLDATA(offPfnInitUserApiHook))) {
            FreeLibrary((HMODULE)retval);
            retval = 0;
            MSGERROR();
        }
    }

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* yyy
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _CLIENTFREELIBRARYMSG {
    HANDLE hmod;
} CLIENTFREELIBRARYMSG;

#ifdef SENDSIDE
BOOL ClientFreeLibrary(
    IN HANDLE hmod)
{
    SETUP(CLIENTFREELIBRARY)

    BEGINSEND(CLIENTFREELIBRARY)

        MSGDATA()->hmod = hmod;

        MAKECALL(CLIENTFREELIBRARY);
        CHECKRETURN();

    TRACECALLBACK("ClientFreeLibrary");
    ENDSEND(BOOL,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientFreeLibrary, CLIENTFREELIBRARYMSG)
{
    BEGINRECV(0, NULL, 0);

    /*
     * Make sure we don't free a UserApiHook module that's in use.
     */
    if (!ClearUserApiHook(CALLDATA(hmod))) {
        MSGERROR();
    }

    retval = (DWORD)FreeLibrary(CALLDATA(hmod));

    ENDRECV();
}
#endif // RECVSIDE


#ifdef MESSAGE_PUMP_HOOK

/**************************************************************************\
* GetMessageMPH()
*
* 06-Dec-2000   JStall      Created
\**************************************************************************/

typedef struct _CLIENTGETMESSAGEMPHMSG {
    HWND        hwndFilter;
    UINT        msgMin;
    UINT        msgMax;
    UINT        flags;
    BOOL        fGetMessage;
} CLIENTGETMESSAGEMPHMSG;

#ifdef SENDSIDE
BOOL ClientGetMessageMPH(
    IN MSG * pmsg,
    IN HWND hwndFilter,
    IN UINT msgMin,
    IN UINT msgMax,
    IN UINT flags,
    IN BOOL fGetMessage)
{
    SETUP(CLIENTGETMESSAGEMPH)

    BEGINSEND(CLIENTGETMESSAGEMPH)

        MSGDATA()->hwndFilter = hwndFilter;
        MSGDATA()->msgMin = msgMin;
        MSGDATA()->msgMax = msgMax;
        MSGDATA()->flags = flags;
        MSGDATA()->fGetMessage = fGetMessage;

        MAKECALL(CLIENTGETMESSAGEMPH);
        CHECKRETURN();

        OUTSTRUCT(pmsg, MSG);

    TRACECALLBACK("ClientGetMessageMPH");
    ENDSEND(BOOL,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientGetMessageMPH, CLIENTGETMESSAGEMPHMSG)
{
    MSG msg;

    BEGINRECV(0, &msg, sizeof(msg));

    retval = (ULONG_PTR)(gmph.pfnInternalGetMessage)(&msg, CALLDATA(hwndFilter),
            CALLDATA(msgMin), CALLDATA(msgMax), CALLDATA(flags), CALLDATA(fGetMessage));

    ENDRECV();
}
#endif // RECVSIDE


/**************************************************************************\
* WaitMessageMPH()
*
* 06-Dec-2000   JStall      Created
\**************************************************************************/

typedef struct _CLIENTWAITMESSAGEEXMPHMSG {
    UINT        fsWakeMask;
    DWORD       Timeout;
} CLIENTWAITMESSAGEEXMPHMSG;

#ifdef SENDSIDE
BOOL ClientWaitMessageExMPH(
    IN UINT fsWakeMask,
    IN DWORD Timeout)
{
    SETUP(CLIENTWAITMESSAGEEXMPH)

    BEGINSEND(CLIENTWAITMESSAGEEXMPH)

        MSGDATA()->fsWakeMask = fsWakeMask;
        MSGDATA()->Timeout = Timeout;

        MAKECALL(CLIENTWAITMESSAGEEXMPH);
        CHECKRETURN();

    TRACECALLBACK("ClientWaitMessageExMPH");
    ENDSEND(BOOL,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientWaitMessageExMPH, CLIENTWAITMESSAGEEXMPHMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = (ULONG_PTR)(gmph.pfnWaitMessageEx)(CALLDATA(fsWakeMask), CALLDATA(Timeout));

    ENDRECV();
}
#endif // RECVSIDE

#endif // MESSAGE_PUMP_HOOK


/**************************************************************************\
* xxxClientGetCharsetInfo
*
* 96-06-11  IanJa     Created
\**************************************************************************/

typedef struct _CLIENTGETCHARSETINFOMSG {
    LCID lcid;
    CHARSETINFO cs;
} CLIENTGETCHARSETINFOMSG;

#ifdef SENDSIDE
BOOL xxxClientGetCharsetInfo(
    IN LCID lcid,
    OUT PCHARSETINFO pcs)
{
    SETUP(CLIENTGETCHARSETINFO)

    BEGINSEND(CLIENTGETSCHARSETINFO)

        MSGDATA()->lcid = lcid;

        MAKECALL(CLIENTGETCHARSETINFO);
        CHECKRETURN();

        OUTSTRUCT(pcs, CHARSETINFO);

    TRACECALLBACK("ClientGetCharsetInfo");
    ENDSEND(BOOL,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientGetCharsetInfo, CLIENTGETCHARSETINFOMSG)
{
    BEGINRECV(0, &pmsg->cs, sizeof(CHARSETINFO));

    // TCI_SRCLOCALE = 0x1000
    // Sundown: lcid value should be zero-extended in the TCI_SRCLOCALE case.
    retval = (DWORD)TranslateCharsetInfo((DWORD *)ULongToPtr( pmsg->lcid ), &pmsg->cs, TCI_SRCLOCALE);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* ClientFreeDDEHandle
*
* 9-29-91 sanfords     Created.
\**************************************************************************/

typedef struct _CLIENTFREEDDEHANDLEMSG {
    HANDLE hClient;
    DWORD flags;
} CLIENTFREEDDEHANDLEMSG;

#ifdef SENDSIDE
DWORD ClientFreeDDEHandle(
    IN HANDLE hClient,
    IN DWORD flags)
{
    SETUP(CLIENTFREEDDEHANDLE)

    BEGINSEND(CLIENTFREEDDEHANDLE)

        MSGDATA()->hClient = hClient;
        MSGDATA()->flags = flags;

        MAKECALL(CLIENTFREEDDEHANDLE);
        CHECKRETURN();

    TRACECALLBACK("ClientFreeDDEHandle");
    ENDSEND(DWORD, 0);
}
#endif // SENDSIDE



#ifdef RECVSIDE
RECVCALL(ClientFreeDDEHandle, CLIENTFREEDDEHANDLEMSG)
{
    BEGINRECV(0, NULL, 0);
    _ClientFreeDDEHandle(CALLDATA(hClient), CALLDATA(flags));
    ENDRECV();
}
#endif // RECVSIDE




/**************************************************************************\
* ClientGetDDEFlags
*
* This function is used to get a peek at the wStatus flags packed within
* DDE handles - this could either be within the DdePack structure directly
* or within the direct data handle given or referenced via the DdePack
* structure.  flags is used to figure out the right thing to do.
*
* 9-29-91 sanfords     Created.
\**************************************************************************/

typedef struct _CLIENTGETDDEFLAGSMSG {
    HANDLE hClient;
    DWORD flags;
} CLIENTGETDDEFLAGSMSG;

#ifdef SENDSIDE
DWORD ClientGetDDEFlags(
    IN HANDLE hClient,
    IN DWORD flags)
{
    SETUP(CLIENTGETDDEFLAGS)

    BEGINSEND(CLIENTGETDDEFLAGS)

        MSGDATA()->hClient = hClient;
        MSGDATA()->flags = flags;

        MAKECALL(CLIENTGETDDEFLAGS);
        CHECKRETURN();

    TRACECALLBACK("ClientGetDDEFlags");
    ENDSEND(DWORD, 0);
}
#endif // SENDSIDE



#ifdef RECVSIDE
RECVCALL(ClientGetDDEFlags, CLIENTGETDDEFLAGSMSG)
{
    BEGINRECV(0, NULL, 0);
    retval = _ClientGetDDEFlags(CALLDATA(hClient), CALLDATA(flags));
    ENDRECV();
}
#endif // RECVSIDE



/************************************************************************
* ClientCopyDDEIn1
*
* History:
* 10-22-91    sanfords    Created
\***********************************************************************/

typedef struct _CLIENTCOPYDDEIN1MSG {
    HANDLE hClient;      // client side DDE handle - non-0 on initial call
    DWORD flags;
} CLIENTCOPYDDEIN1MSG;

#ifdef SENDSIDE
DWORD xxxClientCopyDDEIn1(
    HANDLE hClient,
    DWORD flags,
    PINTDDEINFO *ppi)
{
    PINTDDEINFO pi;
    INTDDEINFO IntDdeInfo;

    SETUP(CLIENTCOPYDDEIN1)

    BEGINSEND(CLIENTCOPYDDEIN1)

        retval = FAIL_POST;
        *ppi = NULL;
        MSGDATA()->hClient = hClient;
        MSGDATA()->flags = flags;

        MAKECALL(CLIENTCOPYDDEIN1);
        CHECKRETURN();

        if (retval != DO_POST) {
            MSGERROR();
        }

        try {
            OUTSTRUCT(&IntDdeInfo, INTDDEINFO);

            pi = (PINTDDEINFO)UserAllocPool(
                    sizeof(INTDDEINFO) + IntDdeInfo.cbDirect +
                    IntDdeInfo.cbIndirect, TAG_DDE);

            if (pi != NULL) {
                *ppi = pi;
                *pi = IntDdeInfo;

                if (IntDdeInfo.cbDirect) {
                    RtlCopyMemory((PBYTE)pi + sizeof(INTDDEINFO),
                            IntDdeInfo.pDirect,
                            IntDdeInfo.cbDirect);
                }

                if (IntDdeInfo.cbIndirect) {
                    RtlCopyMemory((PBYTE)pi + sizeof(INTDDEINFO) +
                                IntDdeInfo.cbDirect,
                            IntDdeInfo.pIndirect,
                            IntDdeInfo.cbIndirect);
                }

                xxxClientCopyDDEIn2(pi);

            } else {
                retval = FAILNOFREE_POST;
            }
        } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
            if (pi != NULL)
                UserFreePool(pi);
            retval = FAILNOFREE_POST;
            MSGERROR();
        }

    TRACECALLBACK("ClientCopyDDEIn1");
    ENDSEND(DWORD, retval);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientCopyDDEIn1, CLIENTCOPYDDEIN1MSG)
{
    INTDDEINFO IntDdeInfo;

    BEGINRECV(0, &IntDdeInfo, sizeof(INTDDEINFO));

    IntDdeInfo.flags = CALLDATA(flags);
    retval = _ClientCopyDDEIn1(CALLDATA(hClient), &IntDdeInfo);

    ENDRECV();
}
#endif // RECVSIDE


/************************************************************************
* ClientCopyDDEIn2
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/

typedef struct _CLIENTCOPYDDEIN2MSG {
    INTDDEINFO IntDdeInfo;
} CLIENTCOPYDDEIN2MSG;

#ifdef SENDSIDE
BOOL xxxClientCopyDDEIn2(
    PINTDDEINFO pi)
{
    SETUP(CLIENTCOPYDDEIN2)

    BEGINSEND(CLIENTCOPYDDEIN2)

        MSGDATA()->IntDdeInfo = *pi;

        MAKECALL(CLIENTCOPYDDEIN2);
        CHECKRETURN();

    TRACECALLBACK("ClientCopyDDEIn2");
    ENDSEND(BOOL, 0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientCopyDDEIn2, CLIENTCOPYDDEIN2MSG)
{
    BEGINRECV(0, NULL, 0);

    _ClientCopyDDEIn2(PCALLDATA(IntDdeInfo));

    ENDRECV();
}
#endif // RECVSIDE



/************************************************************************
* ClientCopyDDEOut2
*
* History:
* 10-22-91    sanfords    Created
\***********************************************************************/

typedef struct _CLIENTCOPYDDEOUT2MSG {
    INTDDEINFO IntDdeInfo;
} CLIENTCOPYDDEOUT2MSG;

#ifdef SENDSIDE
DWORD xxxClientCopyDDEOut2(
    PINTDDEINFO pi)
{
    SETUP(CLIENTCOPYDDEOUT2)

    BEGINSEND(CLIENTCOPYDDEOUT2)

        MSGDATA()->IntDdeInfo = *pi;

        MAKECALL(CLIENTCOPYDDEOUT2);
        /*
         * This read is covered by a try/except in ClientCopyDDEOut1.
         */
        pi->hDirect = MSGDATA()->IntDdeInfo.hDirect;
        CHECKRETURN();

    TRACECALLBACK("ClientCopyDDEOut2");
    ENDSEND(DWORD, 0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientCopyDDEOut2, CLIENTCOPYDDEOUT2MSG)
{
    BEGINRECV(0, NULL, 0);

    retval = _ClientCopyDDEOut2(PCALLDATA(IntDdeInfo));

    ENDRECV();
}
#endif // RECVSIDE

/************************************************************************
* ClientCopyDDEOut1
*
* History:
* 10-22-91    sanfords    Created
\***********************************************************************/

typedef struct _CLIENTCOPYDDEOUT1MSG {
    INTDDEINFO IntDdeInfo;
} CLIENTCOPYDDEOUT1MSG;

#ifdef SENDSIDE
HANDLE xxxClientCopyDDEOut1(
    PINTDDEINFO pi)
{
    INTDDEINFO IntDdeInfo;

    SETUP(CLIENTCOPYDDEOUT1)

    BEGINSEND(CLIENTCOPYDDEOUT1)

        MSGDATA()->IntDdeInfo = *pi;

        MAKECALL(CLIENTCOPYDDEOUT1);
        CHECKRETURN();

        if (retval) {
            try {
                OUTSTRUCT(&IntDdeInfo, INTDDEINFO);

                if (pi->cbDirect) {
                    ProbeForWrite(IntDdeInfo.pDirect,
                            pi->cbDirect,
                            sizeof(BYTE));
                    RtlCopyMemory(IntDdeInfo.pDirect,
                            (PBYTE)pi + sizeof(INTDDEINFO),
                            pi->cbDirect);
                }

                if (pi->cbIndirect) {
                    ProbeForWrite(IntDdeInfo.pIndirect,
                            pi->cbIndirect,
                            sizeof(BYTE));
                    RtlCopyMemory(IntDdeInfo.pIndirect,
                            (PBYTE)pi + sizeof(INTDDEINFO) + pi->cbDirect,
                            pi->cbIndirect);
                }

                if (IntDdeInfo.hDirect != NULL) {
                    BOOL fSuccess = xxxClientCopyDDEOut2(&IntDdeInfo);
                    if (fSuccess && IntDdeInfo.flags & XS_EXECUTE) {
                        /*
                         * In case value was changed by Execute Fixup.
                         */
                        retval = (ULONG_PTR)IntDdeInfo.hDirect;
                    }
                }
                *pi = IntDdeInfo;
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                retval = 0;
                MSGERROR();
            }
        }

    TRACECALLBACK("ClientCopyDDEOut1");
    ENDSEND(HANDLE, 0);
}
#endif // SENDSIDE



#ifdef RECVSIDE
RECVCALL(ClientCopyDDEOut1, CLIENTCOPYDDEOUT1MSG)
{
    BEGINRECV(0, &pmsg->IntDdeInfo, sizeof(INTDDEINFO));

    retval = (ULONG_PTR)_ClientCopyDDEOut1(&pmsg->IntDdeInfo);

    ENDRECV();
}
#endif // RECVSIDE



/**************************************************************************\
* ClientEventCallback
*
* 11-11-91  sanfords    Created
\**************************************************************************/

typedef struct _CLIENTEVENTCALLBACKMSG {
    CAPTUREBUF CaptureBuf;
    PVOID pcii;
    PVOID pep;
} CLIENTEVENTCALLBACKMSG;

#ifdef SENDSIDE
DWORD ClientEventCallback(
    IN PVOID pcii,
    IN PEVENT_PACKET pep)
{
    DWORD cbCapture = pep->cbEventData +
            sizeof(EVENT_PACKET) - sizeof(DWORD);

    SETUP(CLIENTEVENTCALLBACK)

    BEGINSENDCAPTURE(CLIENTEVENTCALLBACK, 1, cbCapture, TRUE)

        MSGDATA()->pcii = pcii;
        COPYBYTES(pep, cbCapture);

        MAKECALLCAPTURE(CLIENTEVENTCALLBACK);
        CHECKRETURN();

    TRACECALLBACK("ClientEventCallback");
    ENDSENDCAPTURE(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientEventCallback, CLIENTEVENTCALLBACKMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    _ClientEventCallback(CALLDATA(pcii), (PEVENT_PACKET)FIXUP(pep));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* ClientGetDDEHookData
*
* 11-11-91  sanfords    Created
\**************************************************************************/

typedef struct _CLIENTGETDDEHOOKDATAMSG {
    UINT message;
    LPARAM lParam;
    DDEML_MSG_HOOK_DATA dmhd;
} CLIENTGETDDEHOOKDATAMSG;

#ifdef SENDSIDE
DWORD ClientGetDDEHookData(
    IN UINT message,
    IN LPARAM lParam,
    OUT PDDEML_MSG_HOOK_DATA pdmhd)
{
    SETUP(CLIENTGETDDEHOOKDATA)

    BEGINSEND(CLIENTGETDDEHOOKDATA)

        MSGDATA()->lParam = lParam;
        MSGDATA()->message = message;

        MAKECALL(CLIENTGETDDEHOOKDATA);
        CHECKRETURN();

        OUTSTRUCT(pdmhd, DDEML_MSG_HOOK_DATA);

    TRACECALLBACK("ClientGetDDEHookData");
    ENDSEND(DWORD,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientGetDDEHookData, CLIENTGETDDEHOOKDATAMSG)
{
    BEGINRECV(0, &pmsg->dmhd, sizeof(DDEML_MSG_HOOK_DATA));

    _ClientGetDDEHookData(CALLDATA(message), CALLDATA(lParam),
            (PDDEML_MSG_HOOK_DATA)&pmsg->dmhd);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
*
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _CLIENTCHARTOWCHARMSG {
    WORD CodePage;
    WORD wch;
} CLIENTCHARTOWCHARMSG;

#ifdef SENDSIDE
WCHAR xxxClientCharToWchar(
    IN WORD CodePage,
    IN WORD wch)
{
    SETUP(CLIENTCHARTOWCHAR)

    BEGINSEND(CLIENTCHARTOWCHAR)

        MSGDATA()->CodePage = CodePage;
        MSGDATA()->wch = wch;

        MAKECALL(CLIENTCHARTOWCHAR);
        CHECKRETURN();

    TRACECALLBACK("ClientCharToWchar");
    ENDSEND(WCHAR, L'_');
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientCharToWchar, CLIENTCHARTOWCHARMSG)
{
    char ach[2];
    WCHAR wch = L'_';

    BEGINRECV(0, NULL, 0);

    ach[0] = LOBYTE(CALLDATA(wch));
    ach[1] = HIBYTE(CALLDATA(wch));

    MultiByteToWideChar(
            CALLDATA(CodePage),                // CP_THREAD_ACP, 437, 850 etc.
            MB_PRECOMPOSED | MB_USEGLYPHCHARS, // visual map to precomposed
            ach, ach[1] ? 2 : 1,               // source & length
            &wch,                              // destination
            1);                                // max poss. precomposed length

    retval = (DWORD)wch;

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
*
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _CLIENTFINDMNEMCHARMSG {
    CAPTUREBUF CaptureBuf;
    UNICODE_STRING strSrc;
    WCHAR ch;
    BOOL fFirst;
    BOOL fPrefix;
} CLIENTFINDMNEMCHARMSG;

#ifdef SENDSIDE
int xxxClientFindMnemChar(
    IN PUNICODE_STRING pstrSrc,
    IN WCHAR ch,
    IN BOOL fFirst,
    IN BOOL fPrefix)
{
    SETUP(CLIENTFINDMNEMCHAR)

    BEGINSENDCAPTURE(CLIENTFINDMNEMCHAR, 1, pstrSrc->MaximumLength, TRUE)

        MSGDATA()->ch = ch;
        MSGDATA()->fFirst = fFirst;
        MSGDATA()->fPrefix = fPrefix;
        COPYSTRING(strSrc);

        MAKECALLCAPTURE(CLIENTFINDMNEMCHAR);
        CHECKRETURN();

    TRACECALLBACK("ClientFindMnemChar");
    ENDSENDCAPTURE(BOOL,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientFindMnemChar, CLIENTFINDMNEMCHARMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (DWORD)FindMnemChar((LPWSTR)FIXUPSTRING(strSrc),
            CALLDATA(ch), CALLDATA(fFirst), CALLDATA(fPrefix));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* xxxClientPSMTextOut
*
* Called when a client-side LanguagePack (LPK) is installed
*
* 18-Sep-1996 GregoryW  Created
* 11-Dec-1997 SamerA    Calling LPK with user-mode accessible DC
\**************************************************************************/

typedef struct _CLIENTPSMTEXTOUTMSG {
    CAPTUREBUF CaptureBuf;
    UNICODE_STRING strSrc;
    HDC hdc;
    int xLeft;
    int yTop;
    int cch;
    DWORD dwFlags;
} CLIENTPSMTEXTOUTMSG;

#ifdef SENDSIDE
void xxxClientPSMTextOut(
    IN HDC hdc,
    IN int xLeft,
    IN int yTop,
    IN PUNICODE_STRING pstrSrc,
    IN int cch,
    IN DWORD dwFlags)
{
    SETUPDC(CLIENTPSMTEXTOUT)

    /*
     * Make sure this routine is called when a client LanguagePack (LPK)
     * is installed.
     */
    UserAssert(CALL_LPK(PtiCurrentShared()));

    BEGINSENDCAPTUREVOIDDC(CLIENTPSMTEXTOUT, 1, pstrSrc->MaximumLength, TRUE)

    CheckPublicDC ("xxxClientPSMTextOut: Public DC passed to LPK. hdcUse=%lX", hdcUse);

        MSGDATA()->hdc = hdcUse;
        MSGDATA()->xLeft = xLeft;
        MSGDATA()->yTop = yTop;
        MSGDATA()->cch = cch;
        MSGDATA()->dwFlags = dwFlags;
        COPYSTRING(strSrc);

        MAKECALLCAPTUREDC(CLIENTPSMTEXTOUT);

        CHECKRETURN();

    TRACECALLBACK("ClientPSMTextOut");
    ENDSENDCAPTUREVOIDDC();
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientPSMTextOut, CLIENTPSMTEXTOUTMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    PSMTextOut(CALLDATA(hdc), CALLDATA(xLeft), CALLDATA(yTop),
        (LPWSTR)FIXUPSTRING(strSrc), CALLDATA(cch), CALLDATA(dwFlags));

    retval = 0;
    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* xxxClientLpkDrawTextEx
*
* Called when a client-side LanguagePack (LPK) is installed
*
* 18-Sep-1996 GregoryW  Created
* 11-Dec-1997 SamerA    Calling LPK with user-mode accessible DC
\**************************************************************************/

typedef struct _CLIENTLPKDRAWTEXTEXMSG {
    CAPTUREBUF CaptureBuf;
    UNICODE_STRING strSrc;
    HDC hdc;
    int xLeft;
    int yTop;
    int nCount;
    BOOL fDraw;
    UINT wFormat;
    DRAWTEXTDATA DrawInfo;
    UINT bAction;
    int iCharSet;
} CLIENTLPKDRAWTEXTEXMSG;

#ifdef SENDSIDE
int xxxClientLpkDrawTextEx(
    IN HDC hdc,
    IN int xLeft,
    IN int yTop,
    IN LPCWSTR lpsz,
    IN int nCount,
    IN BOOL fDraw,
    IN UINT wFormat,
    IN LPDRAWTEXTDATA lpDrawInfo,
    IN UINT bAction,
    IN int iCharSet)
{
    SETUPDC(CLIENTLPKDRAWTEXTEX)
    UNICODE_STRING strSrc;
    UNICODE_STRING *pstrSrc   = &strSrc;

    /*
     * Make sure this routine is called when a client LanguagePack (LPK)
     * is installed.
     */
    UserAssert(CALL_LPK(PtiCurrentShared()));


    RtlInitUnicodeString(pstrSrc, lpsz);

    BEGINSENDCAPTUREDC(CLIENTLPKDRAWTEXTEX, 1, nCount, TRUE)

    CheckPublicDC ("xxxClientLpkDrawTextEx: Public DC passed to LPK. hdcUse=%lX", hdcUse);

        MSGDATA()->hdc = hdcUse;
        MSGDATA()->xLeft = xLeft;
        MSGDATA()->yTop = yTop;
        MSGDATA()->nCount = nCount;
        MSGDATA()->fDraw = fDraw;
        MSGDATA()->wFormat = wFormat;
        MSGDATA()->DrawInfo = *lpDrawInfo;
        MSGDATA()->bAction = bAction;
        MSGDATA()->iCharSet = iCharSet;
        COPYSTRING(strSrc);

        MAKECALLCAPTUREDC(CLIENTLPKDRAWTEXTEX);

        CHECKRETURN();

    TRACECALLBACK("ClientLpkDrawTextEx");
    ENDSENDCAPTUREDC(int, 0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientLpkDrawTextEx, CLIENTLPKDRAWTEXTEXMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = (*fpLpkDrawTextEx)(CALLDATA(hdc), CALLDATA(xLeft), CALLDATA(yTop),
        (LPWSTR)FIXUPSTRING(strSrc), CALLDATA(nCount), CALLDATA(fDraw),
        CALLDATA(wFormat), PCALLDATA(DrawInfo), CALLDATA(bAction), CALLDATA(iCharSet));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* xxxClientExtTextOutW
*
* Called when a client-side LanguagePack (LPK) is installed
*
* 26-Jan-1997 GregoryW  Created
* 11-Dec-1997 SamerA    Calling LPK with user-mode accessible DC
\**************************************************************************/

typedef struct _CLIENTEXTTEXTOUTW {
    CAPTUREBUF CaptureBuf;
    UNICODE_STRING strSrc;
    HDC hdc;
    int x;
    int y;
    int flOpts;
    RECT rcl;
    UINT cwc;
    BOOL fNullRect;
} CLIENTEXTTEXTOUTWMSG;

#ifdef SENDSIDE
BOOL xxxClientExtTextOutW(
    IN HDC hdc,
    IN int x,
    IN int y,
    IN int flOpts,
    IN RECT *prcl,
    IN LPCWSTR pwsz,
    IN UINT cwc,
    IN INT *pdx)
{
    SETUPDC(CLIENTEXTTEXTOUTW)
    UNICODE_STRING strSrc;
    UNICODE_STRING *pstrSrc = &strSrc;

    /*
     * Make sure this routine is called when a client LanguagePack (LPK)
     * is installed.
     */
    UserAssert(CALL_LPK(PtiCurrentShared()));


    RtlInitUnicodeString(pstrSrc, pwsz);

    BEGINSENDCAPTUREDC(CLIENTEXTTEXTOUTW, 1, cwc, TRUE)

    CheckPublicDC ("xxxClientExtTextOutW: Public DC passed to LPK. hdcUse=%lX", hdcUse);

        MSGDATA()->hdc = hdcUse;
        MSGDATA()->x = x;
        MSGDATA()->y = y;
        MSGDATA()->flOpts = flOpts;
        /* In order not to pass a NULL ptr */
        if( prcl ){
            MSGDATA()->rcl = *prcl;
            MSGDATA()->fNullRect=TRUE;
        }
        else {
            MSGDATA()->fNullRect=FALSE;
        }
        MSGDATA()->cwc = cwc;
        COPYSTRING(strSrc);

        MAKECALLCAPTUREDC(CLIENTEXTTEXTOUTW);

        CHECKRETURN();

    TRACECALLBACK("ClientExtTextOutW");
    ENDSENDCAPTUREDC(BOOL, 0);

    UNREFERENCED_PARAMETER(pdx);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientExtTextOutW, CLIENTEXTTEXTOUTWMSG)
{
    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = ExtTextOutW(CALLDATA(hdc), CALLDATA(x), CALLDATA(y),
        CALLDATA(flOpts), (CALLDATA(fNullRect)) ? PCALLDATA(rcl) : NULL , (LPWSTR)FIXUPSTRING(strSrc),
        CALLDATA(cwc), NULL);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* xxxClientGetTextExtentPointW
*
* Called when a client-side LanguagePack (LPK) is installed
*
* 06-Feb-1997 GregoryW  Created
* 19-Jan-1998 SamerA    EIP_ERROR if a public DC is passed other than hdcGray
\**************************************************************************/

typedef struct _CLIENTGETTEXTEXTENTPOINTW {
    CAPTUREBUF CaptureBuf;
    UNICODE_STRING strSrc;
    HDC hdc;
    int cch;
    SIZE size;
} CLIENTGETTEXTEXTENTPOINTWMSG;

#ifdef SENDSIDE
BOOL xxxClientGetTextExtentPointW(
    IN HDC hdc,
    IN LPCWSTR lpstr,
    IN int cch,
    OUT PSIZE psize)
{
    SETUPDC(CLIENTGETTEXTEXTENTPOINTW)
    UNICODE_STRING strSrc;
    UNICODE_STRING *pstrSrc = &strSrc;

    /*
     * Make sure this routine is called when a client LanguagePack (LPK)
     * is installed.
     */
    UserAssert(CALL_LPK(PtiCurrentShared()));

    RtlInitUnicodeString(pstrSrc, lpstr);

    BEGINSENDCAPTUREDC(CLIENTGETTEXTEXTENTPOINTW, 1, cch, TRUE)

    CheckPublicDC ("xxxGetTextExtentPointW: Public DC passed to LPK. hdcUse=%lX", hdcUse);

        MSGDATA()->hdc = hdcUse;
        MSGDATA()->cch = cch;
        COPYSTRING(strSrc);

        MAKECALLCAPTUREDC(CLIENTGETTEXTEXTENTPOINTW);

        CHECKRETURN();

        OUTSTRUCT(psize, SIZE);

    TRACECALLBACK("ClientGetTextExtentPointW");
    ENDSENDCAPTUREDC(BOOL, 0);

}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientGetTextExtentPointW, CLIENTGETTEXTEXTENTPOINTWMSG)
{
    BEGINRECV(0, &pmsg->size, sizeof(SIZE));
    FIXUPPOINTERS();

    retval = GetTextExtentPointW(CALLDATA(hdc), (LPWSTR)FIXUPSTRING(strSrc),
        CALLDATA(cch), PCALLDATA(size));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
*
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

typedef struct _CLIENTADDFONTRESOURCEWMSG {
    CAPTUREBUF CaptureBuf;
    UNICODE_STRING strSrc;
    DWORD dwFlags;
    DESIGNVECTOR   dv;
} CLIENTADDFONTRESOURCEWMSG;

#ifdef SENDSIDE
int xxxClientAddFontResourceW(
    IN PUNICODE_STRING pstrSrc,
    IN DWORD dwFlags,
    IN DESIGNVECTOR *pdv)
{
    SETUP(CLIENTADDFONTRESOURCEW)

    BEGINSENDCAPTURE(CLIENTADDFONTRESOURCEW, 1, pstrSrc->MaximumLength, TRUE)

        COPYSTRING(strSrc);
        MSGDATA()->dwFlags = dwFlags;

        if (pdv && pdv->dvNumAxes) {
            MSGDATA()->dv = *pdv;
        } else {
            MSGDATA()->dv.dvNumAxes = 0;
        }

        MAKECALLCAPTURE(CLIENTADDFONTRESOURCEW);
        CHECKRETURN();

    TRACECALLBACK("ClientAddFontResourceW");
    ENDSENDCAPTURE(int,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE


RECVCALL(ClientAddFontResourceW, CLIENTADDFONTRESOURCEWMSG)
{
    DWORD AddFont(LPWSTR, DWORD, DESIGNVECTOR*);

    BEGINRECV(0, NULL, 0);
    FIXUPPOINTERS();

    retval = GdiAddFontResourceW((LPWSTR)FIXUPSTRING(strSrc),
                                  CALLDATA(dwFlags), CALLDATA(dv).dvNumAxes ? &CALLDATA(dv) : NULL);

    ENDRECV();
}
#endif // RECVSIDE



/******************************Public*Routine******************************\
*
* FontSweep()
*
* History:
*  23-Oct-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



#ifdef SENDSIDE
VOID ClientFontSweep(VOID)
{
    PVOID p;
    ULONG cb;

    LeaveCrit();
    KeUserModeCallback(
        FI_CLIENTFONTSWEEP,
        NULL,
        0,
        &p,
        &cb);
    EnterCrit();
    return;
}
#endif // SENDSIDE

#ifdef RECVSIDE

DWORD __ClientFontSweep(
    PVOID p)
{
    UNREFERENCED_PARAMETER(p);
    vFontSweep();
    return NtCallbackReturn(NULL, 0, STATUS_SUCCESS);
}
#endif // RECVSIDE


/******************************Public*Routine******************************\
*
* VOID ClientLoadLocalT1Fonts(VOID)
* very similar to above, only done for t1 fonts
*
* History:
*  25-Apr-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



#ifdef SENDSIDE
VOID ClientLoadLocalT1Fonts(VOID)
{
    PVOID p;
    ULONG cb;

    LeaveCrit();
    KeUserModeCallback(
        FI_CLIENTLOADLOCALT1FONTS,
        NULL,
        0,
        &p,
        &cb);
    EnterCrit();
    return;
}
#endif // SENDSIDE

#ifdef RECVSIDE



DWORD __ClientLoadLocalT1Fonts(
    PVOID p)
{
    UNREFERENCED_PARAMETER(p);
    vLoadLocalT1Fonts();
    return NtCallbackReturn(NULL, 0, STATUS_SUCCESS);
}
#endif // RECVSIDE



/******************************Public*Routine******************************\
*
* VOID ClientLoadRemoteT1Fonts(VOID)
* very similar to above, only done for t1 fonts
*
* History:
*  25-Apr-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



#ifdef SENDSIDE
VOID ClientLoadRemoteT1Fonts(VOID)
{
    PVOID p;
    ULONG cb;

    LeaveCrit();
    KeUserModeCallback(
        FI_CLIENTLOADREMOTET1FONTS,
        NULL,
        0,
        &p,
        &cb);
    EnterCrit();
    return;
}
#endif // SENDSIDE

#ifdef RECVSIDE



DWORD __ClientLoadRemoteT1Fonts(
    PVOID p)
{
    UNREFERENCED_PARAMETER(p);
    vLoadRemoteT1Fonts();
    return NtCallbackReturn(NULL, 0, STATUS_SUCCESS);
}
#endif // RECVSIDE

/**************************************************************************\
* pppUserModeCallback
*
* Same as xxxUserModeCallback except not leaving/re-entering critical section
*
* 12/9/97 LingyunW     Copied from xxxUserModeCallback
\**************************************************************************/
#ifdef SENDSIDE
NTSTATUS pppUserModeCallback (ULONG uApi, PVOID pIn, ULONG cbIn, PVOID pOut, ULONG cbOut)
{
    NTSTATUS Status;
    PVOID pLocalOut;
    ULONG cbLocalOut;

    /*
     * Call the client
     */
    Status = KeUserModeCallback(uApi, pIn, cbIn, &pLocalOut, &cbLocalOut);

    /*
     * If it failed, bail
     */
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    /*
     * If we didn't get the right amount of data, fail.
     */
    if (cbLocalOut != cbOut) {
        RIPMSG3(RIP_WARNING, "pppUserModeCallback: uAPi: %#lx cbOut: %#lx cbLocalOut: %#lx",
                uApi, cbOut, cbLocalOut);
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * If we were expecting some data, copy it.
     */
    if (cbOut != 0) {
        try {
            ProbeForRead(pLocalOut, cbLocalOut, sizeof(DWORD));
            RtlCopyMemory(pOut, pLocalOut, cbLocalOut);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            RIPMSG2(RIP_WARNING, "pppUserModeCallback: uAPi: %#lx Exception: %#lx", uApi, GetExceptionCode());
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    return Status;
}
#endif // SENDSIDE

/******************************Public*Routine******************************\
* ClientPrinterThunk
*
* Callback used as the kernel-to-user transport layer.
*
* Note: User critical section is not held by the caller.
*
* History:
*  22-Jun-1997 -by- Gilman Wong [gilmanw]
*  11/13/97 -by- Lingyun Wang [lingyunw] clean up
*
* Wrote it.
\**************************************************************************/

#define CLIENTPRINTERTHUNKMSG UMTHDR

#ifdef SENDSIDE
DWORD ClientPrinterThunk(PVOID pvIn, ULONG cjIn, PVOID pvOut, ULONG cjOut)
{
    NTSTATUS Status;

    /*
     * (Temporarly..) we return failure if we are holding USERK's crit section
     */
    if (ExIsResourceAcquiredExclusiveLite(gpresUser)
            || (ExIsResourceAcquiredSharedLite(gpresUser) != 0)) {
        RIPMSG0(RIP_ERROR, "ClientPrinterThunk: Holding USERK critical section!");
        return 0xffffffff;
    }

    /*
     * The pvIn buffer must have at least a CLIENTPRINTERTHUNK header.
     */
    UserAssertMsg1(cjIn >= sizeof(CLIENTPRINTERTHUNKMSG), "ClientPrinterThunk: incorrect cjIn:%#lx", cjIn);

    /*
     * Set the private cjOut.  The receive-side uses this to allocate
     *  a return buffer.
     */
    ((CLIENTPRINTERTHUNKMSG *) pvIn)->ulReserved1      = cjOut;
    ((CLIENTPRINTERTHUNKMSG *) pvIn)->ulReserved2 = 0;


    /*
     * Do the callback.
     */
    Status = pppUserModeCallback(FI_CLIENTPRINTERTHUNK, pvIn, cjIn, pvOut, cjOut);

    return (NT_SUCCESS(Status) ? 0 : 0xFFFFFFFF);
}
#endif // SENDSIDE

#ifdef RECVSIDE
DWORD __ClientPrinterThunk(CLIENTPRINTERTHUNKMSG *pMsg)
{
    PVOID pv;
    ULONG aul[526];
    NTSTATUS Status;

    /*
     * Check that the local buffer is big enough.
     */
    if (pMsg->ulReserved1 <= sizeof(aul)) {
        pv = (PVOID) aul;
        /*
         * Call GDI to process command.
         */
        if (GdiPrinterThunk((UMTHDR *) pMsg, pv, pMsg->ulReserved1) != GPT_ERROR) {
            Status = STATUS_SUCCESS;
        } else {
            RIPMSG0(RIP_WARNING, "ClientPrinterThunk failed");
            Status = STATUS_UNSUCCESSFUL;
        }
    } else {
        RIPMSG0(RIP_WARNING, "ClientPrinterThunk: buffer too big!");
        Status = STATUS_NO_MEMORY;
    }


    /*
     * Return to kernel.
     */
    if (NT_SUCCESS(Status)) {
        return UserCallbackReturn(pv, pMsg->ulReserved1, Status);
    } else {
        return UserCallbackReturn(NULL, 0, Status);
    }
}
#endif // RECVSIDE

/**************************************************************************\
*
*
* 22-Jul-1991 mikeke    Created
\**************************************************************************/

#ifdef SENDSIDE
VOID ClientNoMemoryPopup(VOID)
{
    PVOID p;
    ULONG cb;

    LeaveCrit();
    KeUserModeCallback(
        FI_CLIENTNOMEMORYPOPUP,
        NULL,
        0,
        &p,
        &cb);
    EnterCrit();
    return;
}
#endif // SENDSIDE

#ifdef RECVSIDE

DWORD __ClientNoMemoryPopup(
    PVOID p)
{
    WCHAR szNoMem[200];

    UNREFERENCED_PARAMETER(p);

    if (LoadStringW(hmodUser, STR_NOMEMBITMAP, szNoMem,
            sizeof(szNoMem) / sizeof(WCHAR))) {
        MessageBoxW(GetActiveWindow(), szNoMem, NULL, MB_OK);
    }

    return NtCallbackReturn(NULL, 0, STATUS_SUCCESS);
}
#endif // RECVSIDE

/**************************************************************************\
* ClientThreadSetup
*
* Callback to the client to perform thread initialization.
*
* 04-07-95 JimA         Created.
\**************************************************************************/

#ifdef SENDSIDE
NTSTATUS xxxClientThreadSetup(VOID)
{
    PVOID p;
    ULONG cb;
    NTSTATUS Status;

    LeaveCrit();
    Status = KeUserModeCallback(
        FI_CLIENTTHREADSETUP,
        NULL,
        0,
        &p,
        &cb);
    EnterCrit();
    return Status;
}
#endif // SENDSIDE

#ifdef RECVSIDE
DWORD __ClientThreadSetup(
    PVOID p)
{
    BOOL fSuccess;
    BOOL ClientThreadSetup(VOID);

    UNREFERENCED_PARAMETER(p);

    fSuccess = ClientThreadSetup();
    return NtCallbackReturn(NULL, 0,
            fSuccess ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}
#endif // RECVSIDE

/**************************************************************************\
* ClientDeliverUserApc
*
* Callback to the client to handle a user APC.  This is needed to
* ensure that a thread will exit promptly when terminated.
*
* 08-12-95 JimA         Created.
\**************************************************************************/

#ifdef SENDSIDE
VOID ClientDeliverUserApc(VOID)
{
    PVOID p;
    ULONG cb;

    LeaveCrit();
    KeUserModeCallback(
        FI_CLIENTDELIVERUSERAPC,
        NULL,
        0,
        &p,
        &cb);
    EnterCrit();
}
#endif // SENDSIDE

#ifdef RECVSIDE
DWORD __ClientDeliverUserApc(
    PVOID p)
{
    UNREFERENCED_PARAMETER(p);
    return NtCallbackReturn(NULL, 0, STATUS_SUCCESS);
}
#endif // RECVSIDE


/**************************************************************************\
* ClientImmLoadLayout
*
* 29-Jan-1996 wkwok   Created
\**************************************************************************/

typedef struct _CLIENTIMMLOADLAYOUTMSG {
    HKL hKL;
} CLIENTIMMLOADLAYOUTMSG;

#ifdef SENDSIDE
BOOL ClientImmLoadLayout(
    IN HKL hKL,
    OUT PIMEINFOEX piiex)
{
    SETUP(CLIENTIMMLOADLAYOUT)

    BEGINSEND(CLIENTIMMLOADLAYOUT)

        MSGDATA()->hKL = hKL;

        MAKECALL(CLIENTIMMLOADLAYOUT);
        CHECKRETURN();

        if (retval)
            OUTSTRUCT(piiex, IMEINFOEX);

    TRACECALLBACK("ClientImmLoadLayout");
    ENDSEND(BOOL, 0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientImmLoadLayout, CLIENTIMMLOADLAYOUTMSG)
{
    IMEINFOEX iiex;

    BEGINRECV(0, &iiex, sizeof(iiex));

    retval = fpImmLoadLayout(CALLDATA(hKL), &iiex);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* ClientImmProcessKey
*
* 03-Mar-1996 TakaoK   Created
\**************************************************************************/

typedef struct _CLIENTIMMPROCESSKEYMSG {
    HWND hWnd;
    HKL  hkl;
    UINT uVKey;
    LPARAM lParam;
    DWORD dwHotKeyID;
} CLIENTIMMPROCESSKEYMSG;

#ifdef SENDSIDE
DWORD ClientImmProcessKey(
    IN HWND hWnd,
    IN HKL  hkl,
    IN UINT uVKey,
    IN LPARAM lParam,
    IN DWORD dwHotKeyID)
{
    SETUP(CLIENTIMMPROCESSKEY)

    UserAssert(IS_IME_ENABLED());

    BEGINSEND(CLIENTIMMPROCESSKEY)

        MSGDATA()->hWnd = hWnd,
        MSGDATA()->hkl = hkl;
        MSGDATA()->uVKey = uVKey;
        MSGDATA()->lParam = lParam;
        MSGDATA()->dwHotKeyID = dwHotKeyID;

        MAKECALL(CLIENTIMMPROCESSKEY);
        CHECKRETURN();

    TRACECALLBACK("ClientImmProcessKey");
    ENDSEND(DWORD, 0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientImmProcessKey, CLIENTIMMPROCESSKEYMSG)
{
    BEGINRECV(0, NULL, 0);

    retval = fpImmProcessKey(CALLDATA(hWnd),
                CALLDATA(hkl),
                CALLDATA(uVKey),
                CALLDATA(lParam),
                CALLDATA(dwHotKeyID));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnIMECONTROL
*
* 22-Apr-1996 wkwok    Created
\**************************************************************************/

typedef struct _FNIMECONTROL {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    union {
        PCANDIDATEFORM pCandForm;
        PCOMPOSITIONFORM pCompForm;
        PLOGFONTA pLogFontA;
        PLOGFONTW pLogFontW;
        PSOFTKBDDATA pSoftKbdData;
        LPARAM lParam;
    } u;
    ULONG_PTR xParam;
    PROC xpfnProc;
    PBYTE pOutput;
    DWORD cbOutput;
} FNIMECONTROLMSG;

#ifdef SENDSIDE
void CopyLogFontAtoW(
    PLOGFONTW pdest,
    PLOGFONTA psrc)
{
    LPSTR lpstrFont = (LPSTR)(&psrc->lfFaceName);
    LPWSTR lpstrFontW = (LPWSTR)(&pdest->lfFaceName);

    memcpy((LPBYTE)pdest, psrc, sizeof(LOGFONTA) - LF_FACESIZE);
    memset(pdest->lfFaceName, 0, LF_FACESIZE * sizeof(WCHAR));
    MBToWCS(lpstrFont, -1, &lpstrFontW, LF_FACESIZE, FALSE);
}

SMESSAGECALL(IMECONTROL)
{
    DWORD cCapture, cbCapture;

    SETUPPWND(FNIMECONTROL)

    switch (wParam) {
        case IMC_GETCANDIDATEPOS:
        case IMC_SETCANDIDATEPOS:
            cCapture  = 1;
            cbCapture = sizeof(CANDIDATEFORM);
            break;

        case IMC_GETCOMPOSITIONWINDOW:
        case IMC_SETCOMPOSITIONWINDOW:
            cCapture  = 1;
            cbCapture = sizeof(COMPOSITIONFORM);
            break;

        case IMC_GETCOMPOSITIONFONT:
        case IMC_SETCOMPOSITIONFONT:
        case IMC_GETSOFTKBDFONT:
            cCapture  = 1;
            cbCapture = (dwSCMSFlags & SCMS_FLAGS_ANSI)
                      ? sizeof(LOGFONTA) : sizeof(LOGFONTW) ;
            break;

        case IMC_SETSOFTKBDDATA:
            cCapture  = 1;
            cbCapture = FIELD_OFFSET(SOFTKBDDATA, wCode[0])
                      + ((PSOFTKBDDATA)lParam)->uCount * sizeof(WORD) * 256;

            break;

        default:
            cCapture  = 0;
            cbCapture = 0;
            break;
    }

    BEGINSENDCAPTURE(FNIMECONTROL, cCapture, cbCapture, TRUE);

        MSGDATA()->pwnd     = pwndClient;
        MSGDATA()->msg      = msg;
        MSGDATA()->wParam   = wParam;
        MSGDATA()->u.lParam = lParam;
        MSGDATA()->xParam   = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();

        switch (wParam) {

        case IMC_GETCANDIDATEPOS:
        case IMC_GETCOMPOSITIONWINDOW:
        case IMC_GETCOMPOSITIONFONT:
        case IMC_GETSOFTKBDFONT:

            RESERVEBYTES(cbCapture, pOutput, cbOutput);
            MAKECALLCAPTURE(FNIMECONTROL);
            UNLOCKPWND();
            CHECKRETURN();

            BEGINCOPYOUT()
                try {
                    ProbeForRead(pcbs->pOutput, pcbs->cbOutput, sizeof(DWORD));
                    switch (wParam) {
                    case IMC_GETCANDIDATEPOS:
                    case IMC_GETCOMPOSITIONWINDOW:
                        memcpy((LPBYTE)lParam, pcbs->pOutput, cbCapture);
                        break;

                    case IMC_GETCOMPOSITIONFONT:
                    case IMC_GETSOFTKBDFONT:
                        if (dwSCMSFlags & SCMS_FLAGS_ANSI) {
                            CopyLogFontAtoW((PLOGFONTW)lParam, (PLOGFONTA)pcbs->pOutput);
                        }
                        else {
                            memcpy((LPBYTE)lParam, pcbs->pOutput, cbCapture);
                        }
                        break;
                    }
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                    MSGERROR();
                }
            ENDCOPYOUT()

            break;

        case IMC_SETCANDIDATEPOS:
        case IMC_SETCOMPOSITIONWINDOW:
        case IMC_SETCOMPOSITIONFONT:
        case IMC_SETSOFTKBDDATA:
            if (wParam == IMC_SETCANDIDATEPOS) {
                PCANDIDATEFORM pCandForm = (PCANDIDATEFORM)lParam;
                LARGECOPYBYTES2(pCandForm, sizeof(CANDIDATEFORM), u.pCandForm);
            }
            else if (wParam == IMC_SETCOMPOSITIONWINDOW) {
                PCOMPOSITIONFORM pCompForm = (PCOMPOSITIONFORM)lParam;
                LARGECOPYBYTES2(pCompForm, sizeof(COMPOSITIONFORM), u.pCompForm);
            }
            else if (wParam == IMC_SETCOMPOSITIONFONT) {
                if (dwSCMSFlags & SCMS_FLAGS_ANSI) {
                    LOGFONTA LogFontA;
                    LPSTR  lpstrFontA = LogFontA.lfFaceName;
                    LPWSTR lpstrFontW = ((PLOGFONTW)lParam)->lfFaceName;

                    memcpy(&LogFontA, (PBYTE)lParam, sizeof(LOGFONTA)-LF_FACESIZE);
                    memset(lpstrFontA, 0, LF_FACESIZE * sizeof(CHAR));
                    WCSToMB(lpstrFontW, -1, &lpstrFontA, LF_FACESIZE, FALSE);
                    LARGECOPYBYTES2(&LogFontA, sizeof(LOGFONTA), u.pLogFontA);
                }
                else {
                    PLOGFONTW pLogFontW = (PLOGFONTW)lParam;
                    LARGECOPYBYTES2(pLogFontW, sizeof(LOGFONTW), u.pLogFontW);
                }
            }
            else if (wParam == IMC_SETSOFTKBDDATA) {
                PSOFTKBDDATA pSoftKbdData;

                if (dwSCMSFlags & SCMS_FLAGS_ANSI) {
                    PWORD pCodeA;
                    PWSTR pCodeW;
                    CHAR  ch[2];
                    PSTR  pch = (PSTR)&ch;
                    UINT  i;

                    pSoftKbdData = (PSOFTKBDDATA)UserAllocPool(cbCapture, TAG_IME);
                    if (pSoftKbdData == NULL)
                        MSGERROR();

                    pCodeA = &pSoftKbdData->wCode[0][0];
                    pCodeW = (PWSTR)&((PSOFTKBDDATA)lParam)->wCode[0][0];

                    pSoftKbdData->uCount = ((PSOFTKBDDATA)lParam)->uCount;

                    i = pSoftKbdData->uCount * 256;

                    while (i--) {
                        pch[1] = '\0';
                        WCSToMBEx(THREAD_CODEPAGE(), pCodeW, 1, &pch, 2, FALSE);
                        if (pch[1]) {
                            *pCodeA = MAKEWORD(pch[1], pch[0]);
                        } else {
                            *pCodeA = MAKEWORD(pch[0], 0);
                        }
                        pCodeA++; pCodeW++;
                    }

                    LARGECOPYBYTES2(pSoftKbdData, cbCapture, u.pSoftKbdData);

                    UserFreePool(pSoftKbdData);
                }
                else {
                    pSoftKbdData = (PSOFTKBDDATA)lParam;
                    LARGECOPYBYTES2(pSoftKbdData, cbCapture, u.pSoftKbdData);
                }
            }

            /*
             * Fall thur.
             */

        default:
            MAKECALLCAPTURE(FNIMECONTROL);
            UNLOCKPWND();
            CHECKRETURN();
            break;
        }


    TRACECALLBACKMSG("SfnINSTRINGNULL");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnIMECONTROL, FNIMECONTROLMSG)
{
    BYTE abOutput[CALLBACKSTACKLIMIT];
    LPARAM lParam;

    BEGINRECV(0, NULL, pmsg->cbOutput);
    FIXUPPOINTERS();
    if (pmsg->cbOutput <= CALLBACKSTACKLIMIT)
        CallbackStatus.pOutput = abOutput;
    else
        CallbackStatus.pOutput = pmsg->pOutput;

    switch (CALLDATA(wParam)) {
        case IMC_GETCANDIDATEPOS:
        case IMC_GETCOMPOSITIONWINDOW:
        case IMC_GETCOMPOSITIONFONT:
        case IMC_GETSOFTKBDFONT:
            lParam = (LPARAM)CallbackStatus.pOutput;
            break;

        case IMC_SETCANDIDATEPOS:
        case IMC_SETCOMPOSITIONWINDOW:
        case IMC_SETCOMPOSITIONFONT:
        case IMC_SETSOFTKBDDATA:
            lParam = FIRSTFIXUP(u.lParam);
            break;

       default:
            lParam = CALLDATA(u.lParam);
            break;
    }

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            lParam,
            CALLDATA(xParam));


    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnIMEREQUEST
*
* 22-Apr-1996     Created
\**************************************************************************/

#ifdef LATER
typedef struct _FNIMEREQUEST {
    CAPTUREBUF CaptureBuf;
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    union {
        LPCANDIDATEFORM         pCandidateForm;
        LPLOGFONTA              pLogFontA;
        LPLOGFONTW              pLogFontW;
        LPCOMPOSITIONFORM       pCompositionForm;
        LPRECONVERTSTRING       pReconvertString;
        LPPrivateIMECHARPOSITION pImeCharPosition;
        LPARAM                  lParam;
    } u;
    ULONG_PTR xParam;
    PROC xpfnProc;
    PBYTE pOutput;
    DWORD cbOutput;
    BOOL fAnsi;
} FNIMEREQUESTMSG;

#ifdef SENDSIDE

SMESSAGECALL(IMEREQUEST)
{
    DWORD cCapture, cbCapture;

    SETUPPWND(FNIMEREQUEST)

    //
    // IMEREQUEST assumes the callback is within the thread
    // (see MESSAGECALL(IMEREQUEST) in kernel/ntstubs.c.)
    //
    // All the data pointed by lParam should point the valid
    // client side address. Thus all the validation and copy
    // (if needed) will be done in the receiver side.
    //
    UserAssert(psms == NULL || psms->ptiSender == psms->ptiReceiver);

    switch (wParam) {
    case IMR_CANDIDATEWINDOW:
        cCapture  = 1;
        cbCapture = sizeof(CANDIDATEFORM);
        break;

    case IMR_COMPOSITIONWINDOW:
        cCapture = 1;
        cbCapture = sizeof(COMPOSITIONFORM);
        break;

    case IMR_CONFIRMRECONVERTSTRING:
    case IMR_RECONVERTSTRING:
    case IMR_DOCUMENTFEED:
    case IMR_QUERYCHARPOSITION:
        cCapture = 0;
        cbCapture = 0;
        break;

    case IMR_COMPOSITIONFONT:   // only the exception to the rule above.
        cCapture = 1;
        cbCapture = (dwSCMSFlags & SCMS_FLAGS_ANSI) ? sizeof(LOGFONTA) : sizeof(LOGFONTW);
        break;

    default:
        UserAssert(FALSE);
        cCapture  = 0;
        cbCapture = 0;
        break;
    }

    BEGINSENDCAPTURE(FNIMEREQUEST, cCapture, cbCapture, TRUE);

        MSGDATA()->pwnd     = pwndClient;
        MSGDATA()->msg      = msg;
        MSGDATA()->wParam   = wParam;
        MSGDATA()->u.lParam = lParam;
        MSGDATA()->xParam   = xParam;
        MSGDATA()->xpfnProc = xpfnProc;
        MSGDATA()->fAnsi    = (dwSCMSFlags & SCMS_FLAGS_ANSI);

        LOCKPWND();

        //
        // Preparation
        //

        switch (wParam) {
        case IMR_COMPOSITIONFONT:
            RESERVEBYTES(cbCapture, pOutput, cbOutput);
            break;
        }

        MAKECALLCAPTURE(FNIMEREQUEST);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            try {
                switch (wParam) {
                case IMR_COMPOSITIONFONT:
                    ProbeForRead(pcbs->pOutput, pcbs->cbOutput, sizeof(DWORD));
                    if (dwSCMSFlags & SCMS_FLAGS_ANSI) {
                        CopyLogFontAtoW((PLOGFONTW)lParam, (PLOGFONTA)pcbs->pOutput);
                    }
                    else {
                        memcpy((LPBYTE)lParam, pcbs->pOutput, cbCapture);
                    }
                    break;
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                MSGERROR();
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnIMEREQUEST");
    ENDSENDCAPTURE(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnIMEREQUEST, FNIMEREQUESTMSG)
{
    BYTE abOutput[CALLBACKSTACKLIMIT];
    LPVOID pvNew = NULL;
    LPARAM lParam;

    BEGINRECV(0, NULL, pmsg->cbOutput);
    FIXUPPOINTERS();
    if (pmsg->cbOutput <= CALLBACKSTACKLIMIT)
        CallbackStatus.pOutput = abOutput;
    else
        CallbackStatus.pOutput = pmsg->pOutput;

    lParam = CALLDATA(u.lParam);

    switch (CALLDATA(wParam)) {
    case IMR_COMPOSITIONWINDOW:
    case IMR_CANDIDATEWINDOW:
//        lParam = CALLDATA(lParam);
        break;

    case IMR_COMPOSITIONFONT:
        lParam = (LPARAM)CallbackStatus.pOutput;
        break;

    case IMR_QUERYCHARPOSITION:
        if (CALLDATA(fAnsi)) {
            LPPrivateIMECHARPOSITION lpCharPos;

            pvNew = UserLocalAlloc(0, sizeof(PrivateIMECHARPOSITION));
            if (pvNew == NULL) {
                goto error_return;
            }
            lpCharPos = pvNew;
            *lpCharPos = *CALLDATA(u.pImeCharPosition);
            lpCharPos->dwCharPos = lpCharPos->dwCharPositionA;
        }
        break;

    case IMR_RECONVERTSTRING:
    case IMR_CONFIRMRECONVERTSTRING:
    case IMR_DOCUMENTFEED:
        // Real W/A conversion may be needed.
        if (CALLDATA(fAnsi) && lParam) {
            PRECONVERTSTRING Source = (LPRECONVERTSTRING)lParam;
            // Do conversion.
            DWORD dwNewSize = ImmGetReconvertTotalSize(((LPRECONVERTSTRING)lParam)->dwSize, FROM_IME, TRUE);
            if (dwNewSize == 0) {
                goto error_return;
            }

            pvNew = UserLocalAlloc(0, dwNewSize);
            if (pvNew == NULL) {
                goto error_return;
            }
            lParam = (LPARAM)pvNew;

            #define lpReconv ((LPRECONVERTSTRING)lParam)
            // setup the information in the allocated structure
            lpReconv->dwVersion = 0;
            lpReconv->dwSize = dwNewSize;
            if (CALLDATA(wParam) == IMR_CONFIRMRECONVERTSTRING) {
                ImmReconversionWorker(lpReconv, (LPRECONVERTSTRING)lParam, TRUE, CP_ACP);
            }
        }
        break;

   default:
        lParam = CALLDATA(u.lParam);
        break;
    }

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            lParam,
            CALLDATA(xParam));

    switch (CALLDATA(wParam)) {
    case IMR_RECONVERTSTRING:
    case IMR_DOCUMENTFEED:
        if (CALLDATA(fAnsi)) {
            retval = ImmGetReconvertTotalSize((DWORD)retval, FROM_APP, TRUE);
            if (lParam) {
                retval = ImmReconversionWorker((LPRECONVERTSTRING)CALLDATA(u.lParam), (LPRECONVERTSTRING)pvNew, FALSE, CP_ACP);
            }
        }
        break;
    }

    if (pvNew) {
        UserLocalFree(pvNew);
    }
error_return:
    ENDRECV();
}

#undef lpReconv

#endif // RECVSIDE

#endif

/**************************************************************************\
* fnGETDBCSTEXTLENGTHS (DBCS-aware Version)
*
* Gets the Unicode & ANSI lengths
* Internally, lParam pints to the ANSI length in bytes and the return value
* is the Unicode length in bytes.  However, the public definition is maintained
* on the  client side, where lParam is not used and either ANSI or Unicode is
* returned.
*
* 14-Mar-1996 HideyukN  Created
\**************************************************************************/

#if (WM_GETTEXTLENGTH - WM_GETTEXT) != 1
#error "WM_GETTEXT Messages no longer 1 apart. Error in code."
#endif
#if (LB_GETTEXTLEN - LB_GETTEXT) != 1
#error "LB_GETTEXT Messages no longer 1 apart. Error in code."
#endif
#if (CB_GETLBTEXTLEN - CB_GETLBTEXT) != 1
#error "CB_GETLBTEXT Messages no longer 1 apart. Error in code."
#endif

typedef struct _FNGETDBCSTEXTLENGTHSMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNGETDBCSTEXTLENGTHSMSG;

#ifdef SENDSIDE
SMESSAGECALL(GETDBCSTEXTLENGTHS)
{
    BOOL fAnsiSender   = !!(BOOL)lParam;
    BOOL fAnsiReceiver = ((dwSCMSFlags & SCMS_FLAGS_ANSI) != 0);
    LPVOID pfnSavedWndProc = pwnd->lpfnWndProc;

    SETUPPWND(FNGETDBCSTEXTLENGTHS)

    BEGINSEND(FNGETDBCSTEXTLENGTHS)

    UserAssert((fAnsiReceiver & 1) == fAnsiReceiver && (fAnsiSender & 1) == fAnsiSender);

    MSGDATA()->pwnd = pwndClient;
    MSGDATA()->msg = msg;
    MSGDATA()->wParam = wParam;
    MSGDATA()->xParam = xParam;
    MSGDATA()->xpfnProc = xpfnProc;

    LOCKPWND();
    MAKECALL(FNGETTEXTLENGTHS);
    UNLOCKPWND();
    CHECKRETURN1();

    /*
     * ANSI client wndproc returns us cbANSI.  We want cchUnicode,
     * so we guess cchUnicode = cbANSI. (It may be less if
     * multi-byte characters are involved, but it will never be more).
     * Save cbANSI in *lParam in case the server ultimately returns
     * the length to an ANSI caller.
     *
     * Unicode client wndproc returns us cchUnicode.  If we want to know
     * cbANSI, we must guess how many 'ANSI' chars we would need.
     * We guess cbANSI = cchUnicode * 2. (It may be this much if all
     * 'ANSI' characters are multi-byte, but it will never be more).
     *
     * Return cchUnicode (server code is all Unicode internally).
     * Put cbANSI in *lParam to be passed along within the server in case
     * we ultimately need to return it to the client.
     *
     * NOTE: this will sometimes cause text lengths to be misreported
     * up to twice the real length, but that is expected to be harmless.
     * This will only * happen if an app sends WM_GETcode TEXTLENGTH to a
     * window with an ANSI client-side wndproc, or a ANSI WM_GETTEXTLENGTH
     * is sent to a Unicode client-side wndproc.
     */

    BEGINCOPYOUT()

        //
        // retval can be [CB|LB]_ERR (-1) or [CB|LB]_ERRSPACE (-2)
        // then, it should be grater then zero. otherwise we can handle
        // it as error, or zero length string.
        //
        if ((LONG)retval > 0) {

            //
            // Check we need to Ansi <-> Unicode conversion.
            //
            if (fAnsiSender != fAnsiReceiver) {
                if (pwnd->lpfnWndProc != pfnSavedWndProc) {
                    // The window procedure is changed during the first callback.
                    // Let's take a guess for the worst case.
                    RIPMSG1(RIP_WARNING, "GETTEXTLENGTHS(pwnd=%x): The subclass status of winproc changed during 1st callback.",
                            pwnd);
                    retval *= 2;
                }
                else {
                    BOOL bNotString = FALSE; // default is string....

                    if (msg != WM_GETTEXTLENGTH) {
                        DWORD dw;

                        if (!RevalidateHwnd(HW(pwnd))) {
                            MSGERROR1();
                        }

                        //
                        // Get window style.
                        //
                        dw = pwnd->style;

                        if (msg == LB_GETTEXTLEN) {
                            //
                            // See if the control is ownerdraw and does not have the LBS_HASSTRINGS
                            // style.
                            //
                            bNotString =  (!(dw & LBS_HASSTRINGS) &&
                                            (dw & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)));
                        } else if (msg == CB_GETLBTEXTLEN) {
                            //
                            // See if the control is ownerdraw and does not have the CBS_HASSTRINGS
                            // style.
                            //
                            bNotString = (!(dw & CBS_HASSTRINGS) &&
                                           (dw & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE)));
                        } else {
                            MSGERROR1();
                        }

                        //
                        // if so, the length should be ULONG_PTR.
                        //
                        if (bNotString) {
                            retval = sizeof(ULONG_PTR);
                        }
                    }

                    //
                    // if the target data is "string", get it, and compute the length
                    //
                    if (!bNotString) {
                        if (PtiCurrent()->TIF_flags & TIF_INGETTEXTLENGTH) {
                            if (fAnsiSender) {
                                UserAssert(!fAnsiReceiver);
                                //
                                // retval has Unicode character count, guessed DBCS length.
                                //
                                retval *= 2;
                            }
                        } else {
                            //
                            // fAnsiReceiver == 1, retval has MBCS character count.
                            // fAnsiReceiver == 0, retval has Unicode character count.
                            //
                            // Add 1 to make room for zero-terminator.
                            //
                            DWORD cchText   = (DWORD)retval + 1;
                            DWORD cbCapture = cchText;

                            SETUPPWND(FNOUTSTRING)

                            PtiCurrent()->TIF_flags |= TIF_INGETTEXTLENGTH;

                            //
                            // if reciver is Unicode, The buffder should be reserved as musg as
                            // (TextLength * sizeof(WCHAR).
                            //
                            if (!fAnsiReceiver) {
                                cbCapture *= sizeof(WCHAR);
                            }

                            BEGINSENDCAPTURE(FNOUTSTRING, 1, cbCapture, FALSE)

                                MSGDATA()->pwnd = pwndClient;

                                //
                                // Use (msg-1) for sending the WM_GETTEXT, LB_GETTEXT or CB_GETLBTEXT
                                // since the above precompiler checks passed.
                                //
                                MSGDATA()->msg = msg-1;

                                if (msg == WM_GETTEXTLENGTH) {
                                    //
                                    // WM_GETTEXT:
                                    //    wParam = cchTextMax; // number of character to copy.
                                    //    lParam = lpszText;   // address of buffer for text.
                                    //
                                    MSGDATA()->wParam = cchText;
                                } else {
                                    //
                                    // LB_GETTEXT:
                                    // CB_GETLBTEXT:
                                    //    wParam = index;      // item index
                                    //    lParam = lpszText;   // address of buffer for text.
                                    //
                                    MSGDATA()->wParam = wParam;
                                }

                                MSGDATA()->xParam = xParam;
                                MSGDATA()->xpfnProc = xpfnProc;

                                RESERVEBYTES(cbCapture, pOutput, cbOutput);

                                LOCKPWND();
                                MAKECALLCAPTURE(FNOUTSTRING);
                                UNLOCKPWND();
                                CHECKRETURN();

                                BEGINCOPYOUT()
                                        //
                                        // retval can be [CB|LB]_ERR (-1) or [CB|LB]_ERRSPACE (-2)
                                        // then, it should be grater then zero.
                                        //
                                        if ((LONG)retval > 0) {
                                        /*
                                         * Non-zero retval means some text to copy out.
                                         */
                                        CALC_SIZE_STRING_OUT((LONG)retval);
                                    }
                                ENDCOPYOUT()

                                PtiCurrent()->TIF_flags &= ~TIF_INGETTEXTLENGTH;

                            TRACECALLBACKMSG("SfnOUTSTRING");
                            ENDSENDCAPTURE(LRESULT,0);
                        }
                    }
                }
            }
        }
    ENDCOPYOUT()

    TRACECALLBACKMSG("SfnGETDBCSTEXTLENGTHS");
    ENDSEND1(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
/*
 * The fnGETTEXTLENGTHS routine is used for this message (see... client\dispcb.tpl)
 */
#endif // RECVSIDE

/***************************************************************************\
* xxxClientMonitorEnumProc
*
* Calls the client callback given to EnumDisplayMonitors.
*
* History:
* 05-Sep-1996 adams     Created.
\***************************************************************************/

typedef struct _CLIENTMONITORENUMPROCMSG {
    HMONITOR        hMonitor;
    HDC             hdcMonitor;
    RECT            rc;
    LPARAM          dwData;
    MONITORENUMPROC xpfnProc;
} CLIENTMONITORENUMPROCMSG;

#ifdef SENDSIDE
BOOL xxxClientMonitorEnumProc(
    HMONITOR        hMonitor,
    HDC             hdcMonitor,
    LPRECT          lprc,
    LPARAM          dwData,
    MONITORENUMPROC xpfnProc)
{
    SETUP(CLIENTMONITORENUMPROC)

    BEGINSEND(CLIENTMONITORENUMPROCMSG)

        MSGDATA()->hMonitor = hMonitor;
        MSGDATA()->hdcMonitor = hdcMonitor;
        MSGDATA()->rc = *lprc;
        MSGDATA()->dwData = dwData;
        MSGDATA()->xpfnProc = xpfnProc;

        MAKECALL(CLIENTMONITORENUMPROC);
        CHECKRETURN();

    TRACECALLBACK("SxxxClientMonitorEnumProc");
    ENDSEND(BOOL,FALSE);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientMonitorEnumProc, CLIENTMONITORENUMPROCMSG)
{
    BEGINRECV(FALSE, NULL, 0);

    retval = (DWORD)CALLPROC(pmsg->xpfnProc)(
            CALLDATA(hMonitor),
            CALLDATA(hdcMonitor),
            PCALLDATA(rc),
            CALLDATA(dwData));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* xxxUserModeCallback
*
* Generic kernel callback stub
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
#ifdef SENDSIDE
NTSTATUS xxxUserModeCallback (ULONG uApi, PVOID pIn, ULONG cbIn, PVOID pOut, ULONG cbOut)
{
    NTSTATUS Status;
    PVOID pLocalOut;
    ULONG cbLocalOut;

    /*
     * Call the client
     */
    LeaveCrit();
    Status = KeUserModeCallback(uApi, pIn, cbIn, &pLocalOut, &cbLocalOut);
    EnterCrit();

    /*
     * If it failed, bail
     */
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    /*
     * If we didn't get the right amount of data, fail.
     */
    if (cbLocalOut != cbOut) {
        RIPMSG3(RIP_WARNING, "xxxUserModeCallback: uAPi: %#lx cbOut: %#lx cbLocalOut: %#lx",
                uApi, cbOut, cbLocalOut);
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * If we were expecting some data, copy it.
     */
    if (cbOut != 0) {
        try {
            ProbeForRead(pLocalOut, cbLocalOut, sizeof(DWORD));
            RtlCopyMemory(pOut, pLocalOut, cbLocalOut);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            RIPMSG2(RIP_WARNING, "xxxUserModeCallback: uAPi: %#lx Exception: %#lx", uApi, GetExceptionCode());
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    return Status;
}
#endif // SENDSIDE

/**************************************************************************\
* fnINOUTMENUGETOBJECT
*
* 11/12/96 GerardoB     Created
\**************************************************************************/
typedef struct _FNINOUTMENUGETOBJECTMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    MENUGETOBJECTINFO mngoi;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNINOUTMENUGETOBJECTMSG;

#ifdef SENDSIDE
SMESSAGECALL(INOUTMENUGETOBJECT)
{
    SETUPPWND(FNINOUTMENUGETOBJECT)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNOUTDWORDINDWORD)

    PMENUGETOBJECTINFO pmngoi = (PMENUGETOBJECTINFO)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->mngoi = *pmngoi;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNINOUTMENUGETOBJECT);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            try {
                UserAssert(pcbs->cbOutput == sizeof(pmngoi->pvObj));
                ProbeForRead(pcbs->pOutput, sizeof(pmngoi->pvObj), sizeof(DWORD));
                pmngoi->pvObj = *((PVOID *)(pcbs->pOutput));
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                MSGERROR();
            }
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnINOUTMENUGETOBJECT");
    ENDSEND(LRESULT, 0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnINOUTMENUGETOBJECT, FNINOUTMENUGETOBJECTMSG)
{
    BEGINRECV(0, &(pmsg->mngoi.pvObj), sizeof(pmsg->mngoi.pvObj));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            PCALLDATA(mngoi),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* fnLOGONNOTIFY
*
* 2/1/97   JerrySh      Created
\**************************************************************************/
typedef struct _FNLOGONNOTIFYMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    POWERSTATEPARAMS psParams;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNLOGONNOTIFYMSG;

#ifdef SENDSIDE
SMESSAGECALL(LOGONNOTIFY)
{
    SETUPPWND(FNLOGONNOTIFY)

    UNREFERENCED_PARAMETER(dwSCMSFlags);
    UNREFERENCED_PARAMETER(psms);

    BEGINSEND(FNLOGONNOTIFY)

        PPOWERSTATEPARAMS ppsParams = (PPOWERSTATEPARAMS)lParam;

        if (wParam == LOGON_POWERSTATE ||
            wParam == LOGON_REMOVE_POWER_MESSAGE ||
            wParam == LOGON_SHOW_POWER_MESSAGE) {
            MSGDATA()->psParams = *((PPOWERSTATEPARAMS)lParam);
        }

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->lParam = lParam;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNLOGONNOTIFY);
        UNLOCKPWND();
        CHECKRETURN();

        if (wParam == LOGON_POWERSTATE) {
            BEGINCOPYOUT()
                OUTSTRUCT(ppsParams, POWERSTATEPARAMS);
            ENDCOPYOUT()
        }

    TRACECALLBACKMSG("SfnLOGONNOTIFY");
    ENDSEND(LRESULT, 0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnLOGONNOTIFY, FNLOGONNOTIFYMSG)
{
    BEGINRECV(0, &pmsg->psParams, sizeof(pmsg->psParams));

    if (CALLDATA(wParam) == LOGON_POWERSTATE ||
       CALLDATA(wParam) == LOGON_REMOVE_POWER_MESSAGE ||
       CALLDATA(wParam) == LOGON_SHOW_POWER_MESSAGE) {
       CALLDATA(lParam) = (LPARAM)&CALLDATA(psParams);
    }

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            CALLDATA(pwnd),
            CALLDATA(msg),
            CALLDATA(wParam),
            CALLDATA(lParam),
            CALLDATA(xParam));

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* xxxClientCallWinEventProc
*
* cf. Win'97 Call32BitEventProc() in user_40\user32\user.c
*
* 1996-10-18 IanJa     Created
\**************************************************************************/

typedef struct _CLIENTCALLWINEVENTPROCMSG {
    WINEVENTPROC  pfn;
    HWINEVENTHOOK hWinEventHook;
    DWORD         event;
    HWND          hwnd;
    LONG          idObject;
    LONG          idChild;
    DWORD         idEventThread;
    DWORD         dwmsEventTime;
} CLIENTCALLWINEVENTPROCMSG;

#ifdef SENDSIDE
BOOL xxxClientCallWinEventProc(
    WINEVENTPROC pfn,
    PEVENTHOOK pEventHook,
    PNOTIFY pNotify)
{
    SETUP(CLIENTCALLWINEVENTPROC)

    BEGINSEND(CLIENTCALLWINEVENTPROC)

        MSGDATA()->pfn = pfn;
        MSGDATA()->hWinEventHook = (HWINEVENTHOOK)PtoH(pEventHook);
        MSGDATA()->hwnd = pNotify->hwnd;
        MSGDATA()->event = pNotify->event;
        MSGDATA()->idObject = pNotify->idObject;
        MSGDATA()->idChild = pNotify->idChild;
        MSGDATA()->idEventThread = pNotify->idSenderThread;
        MSGDATA()->dwmsEventTime = pNotify->dwEventTime;

        MAKECALL(CLIENTCALLWINEVENTPROC);
        CHECKRETURN();

    TRACECALLBACK("xxxClientCallWinEventProc");
    ENDSEND(BOOL, FALSE);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientCallWinEventProc, CLIENTCALLWINEVENTPROCMSG)
{
    BEGINRECV(FALSE, NULL, 0);

    retval = (DWORD)CALLPROC(pmsg->pfn)(
            CALLDATA(hWinEventHook),
            CALLDATA(event),
            CALLDATA(hwnd),
            CALLDATA(idObject),
            CALLDATA(idChild),
            CALLDATA(idEventThread),
            CALLDATA(dwmsEventTime));

    ENDRECV();

}
#endif // RECVSIDE



/**************************************************************************\
* WOWGetProcModule
*
* 3/25/97 FritzS created
\**************************************************************************/

typedef struct _CLIENTWOWGETPROCMODULEMSG {
    WNDPROC_PWND pfn;
} CLIENTWOWGETPROCMODULEMSG;



#ifdef SENDSIDE
WORD xxxClientWOWGetProcModule(
    WNDPROC_PWND pfn)
{
    SETUP(CLIENTWOWGETPROCMODULE)

    BEGINSEND(CLIENTWOWGETPROCMODULE)

        MSGDATA()->pfn = pfn;

        MAKECALL(CLIENTWOWGETPROCMODULE);
        CHECKRETURN();

    TRACECALLBACK("xxxWOWGetProcModule");
    ENDSEND(WORD, FALSE);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientWOWGetProcModule, CLIENTWOWGETPROCMODULEMSG)
{
    ULONG ulReal;
    BEGINRECV(0, NULL, 0);

    if ((pfnWowGetProcModule == NULL) || !IsWOWProc(CALLDATA(pfn))) {
        retval = 0;
    } else {
        UnMarkWOWProc(CALLDATA(pfn),ulReal);
        retval = (pfnWowGetProcModule)(ulReal);
    }

    ENDRECV();

}
#endif // RECVSIDE

/**************************************************************************\
* WOWTask16SchedNotify
*
* 12/20/00 ARR created
\**************************************************************************/

typedef struct _CLIENTWOWTASK16SCHEDNOTIFYMSG {
    DWORD NotifyParm;
    DWORD dwParam;
} CLIENTWOWTASK16SCHEDNOTIFYMSG;

#ifdef SENDSIDE
DWORD xxxClientWOWTask16SchedNotify(
    DWORD NotifyParm,
    DWORD dwParam)
{
    SETUP(CLIENTWOWTASK16SCHEDNOTIFY)

    BEGINSEND(CLIENTWOWTASK16SCHEDNOTIFY)

    MSGDATA()->NotifyParm = NotifyParm;
    MSGDATA()->dwParam = dwParam;

    MAKECALL(CLIENTWOWTASK16SCHEDNOTIFY);
        CHECKRETURN();

    TRACECALLBACK("xxxWOWTask16SchedNotify");
    ENDSEND(DWORD, FALSE);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(ClientWOWTask16SchedNotify, CLIENTWOWTASK16SCHEDNOTIFYMSG)
{
    BEGINRECV(0, NULL, 0);

    if (pfnWowTask16SchedNotify == NULL) {
    retval = 1;
    } else {
    retval = (pfnWowTask16SchedNotify)(CALLDATA(NotifyParm),CALLDATA(dwParam));
    }

    ENDRECV();

}
#endif // RECVSIDE

/**************************************************************************\
* xxxClientLoadStringW
*
* Called to load per user ToolTip strings
*
* 24-Feb-2000 Mhamid    Created
\**************************************************************************/

typedef struct _CLIENTLOADSTRINGWMSG {
    CAPTUREBUF CaptureBuf;
    UINT StrID;
    int cch;
    PBYTE pOutput;
    DWORD cbOutput;
} CLIENTLOADSTRINGWMSG;

#ifdef SENDSIDE
int xxxClientLoadStringW(
    IN UINT StrID,
    OUT LPWSTR szText,
    IN int cch)
{
    DWORD cbCapture;
    PLARGE_STRING pstr;
    BOOL fAnsiReceiver = FALSE;
    LARGE_UNICODE_STRING strName;

    SETUP(CLIENTLOADSTRINGW)

    cbCapture = cch * sizeof(WCHAR);
    RtlInitLargeUnicodeString(&strName, szText, cbCapture);
    pstr = (PLARGE_STRING)&strName;

    BEGINSENDCAPTURE(CLIENTLOADSTRINGW, 1, cbCapture, FALSE)


        MSGDATA()->StrID = StrID;
        MSGDATA()->cch = cch;

        RESERVEBYTES(cbCapture, pOutput, cbOutput);

        MAKECALLCAPTURE(CLIENTLOADSTRINGW);

        CHECKRETURN();

        COPYOUTLPWSTRLIMIT(pstr,cch);

    TRACECALLBACK("ClientLoadStringW");
    ENDSENDCAPTURE(int, 0);

}
#endif // SENDSIDE

#ifdef RECVSIDE
VOID CheckMsgFontDimensions();
RECVCALL(ClientLoadStringW, CLIENTLOADSTRINGWMSG)
{
    BYTE abOutput[CALLBACKSTACKLIMIT];

    BEGINRECV(0, NULL, pmsg->cbOutput);
    FIXUPPOINTERS();

    if (pmsg->cbOutput <= CALLBACKSTACKLIMIT)
        CallbackStatus.pOutput = abOutput;
    else
        CallbackStatus.pOutput = pmsg->pOutput;

    retval = (DWORD)LoadStringOrError(
            hmodUser,
            CALLDATA(StrID),
            (LPWSTR)KPVOID_TO_PVOID(CallbackStatus.pOutput),
            CALLDATA(cch),
            0);

    ENDRECV();
}
#endif // RECVSIDE



/**************************************************************************\
* fnOUTLPCOMBOBOXINFO       (for CB_GETCOMBOBOXINFO message)
*
* 05/12/00   MHamid         Created
\**************************************************************************/
typedef struct _FNOUTLPCOMBOBOXINFOMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    COMBOBOXINFO cbinfo;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNOUTLPCOMBOBOXINFOMSG;


#ifdef SENDSIDE
SMESSAGECALL(OUTLPCOMBOBOXINFO)
{
    SETUPPWND(FNOUTLPCOMBOBOXINFO)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNOUTLPCOMBOBOXINFO)

        PCOMBOBOXINFO pcbinfo = (PCOMBOBOXINFO)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->cbinfo = *pcbinfo;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNOUTLPCOMBOBOXINFO);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(pcbinfo, COMBOBOXINFO);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnOUTLPCOMBOBOXINFO");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnOUTLPCOMBOBOXINFO, FNOUTLPCOMBOBOXINFOMSG)
{
    BEGINRECV(0, &pmsg->cbinfo, sizeof(pmsg->cbinfo));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            PCALLDATA(cbinfo),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE


/**************************************************************************\
* fnOUTLPSCROLLBARINFO      (for SBM_GETSCROLLBARINFO message)
*
* 05/12/00   MHamid         Created
\**************************************************************************/
typedef struct _FNOUTLPSCROLLBARINFOMSG {
    PWND pwnd;
    UINT msg;
    WPARAM wParam;
    SCROLLBARINFO sbinfo;
    ULONG_PTR xParam;
    PROC xpfnProc;
} FNOUTLPSCROLLBARINFOMSG;


#ifdef SENDSIDE
SMESSAGECALL(OUTLPSCROLLBARINFO)
{
    SETUPPWND(FNOUTLPSCROLLBARINFO)

    UNREFERENCED_PARAMETER(dwSCMSFlags);

    BEGINSEND(FNOUTLPSCROLLBARINFO)

        PSCROLLBARINFO psbinfo = (PSCROLLBARINFO)lParam;

        MSGDATA()->pwnd = pwndClient;
        MSGDATA()->msg = msg;
        MSGDATA()->wParam = wParam;
        MSGDATA()->sbinfo = *psbinfo;
        MSGDATA()->xParam = xParam;
        MSGDATA()->xpfnProc = xpfnProc;

        LOCKPWND();
        MAKECALL(FNOUTLPSCROLLBARINFO);
        UNLOCKPWND();
        CHECKRETURN();

        BEGINCOPYOUT()
            OUTSTRUCT(psbinfo, SCROLLBARINFO);
        ENDCOPYOUT()

    TRACECALLBACKMSG("SfnOUTLPSCROLLBARINFO");
    ENDSEND(LRESULT,0);
}
#endif // SENDSIDE

#ifdef RECVSIDE
RECVCALL(fnOUTLPSCROLLBARINFO, FNOUTLPSCROLLBARINFOMSG)
{
    BEGINRECV(0, &pmsg->sbinfo, sizeof(pmsg->sbinfo));

    retval = (ULONG_PTR)CALLPROC(CALLDATA(xpfnProc))(
            pmsg->pwnd,
            pmsg->msg,
            pmsg->wParam,
            PCALLDATA(sbinfo),
            pmsg->xParam);

    ENDRECV();
}
#endif // RECVSIDE

/**************************************************************************\
* GetLUIDDosDrivesOnly
*
* Called to check the drive letters used in the LUID DosDevice
* map.  Does not check if the drive letters are used in the Global
* DosDevices
*
* 08/18/00   ELi         Created
\**************************************************************************/
#ifdef RECVSIDE
__inline DWORD  GetLUIDDosDrivesOnly()
{
    NTSTATUS Status;
    PROCESS_DEVICEMAP_INFORMATION_EX ProcessDeviceMapInfoEx;

    ProcessDeviceMapInfoEx.Flags = PROCESS_LUID_DOSDEVICES_ONLY;

    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessDeviceMap,
                                        &ProcessDeviceMapInfoEx,
                                        sizeof( ProcessDeviceMapInfoEx ),
                                        NULL
                                      );
    if (NT_SUCCESS( Status )) {
        return ProcessDeviceMapInfoEx.Query.DriveMap;
    }
    else {
        return 0;
    }
}
#endif // RECVSIDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\inc\ntuser.h ===
/****************************** Module Header ******************************\
* Module Name: ntuser.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains all kernel mode entry points
*
* History:
* 03-22-95 JimA         Created.
\***************************************************************************/

#ifndef _NTUSER_
#define _NTUSER_

#include "w32wow64.h"

#ifndef W32KAPI
#define W32KAPI  DECLSPEC_ADDRSAFE
#endif

#include "usercall.h"

#ifdef GENERIC_INPUT

W32KAPI
UINT
NtUserGetRawInputData(
    IN HRAWINPUT hRawInput,
    IN UINT uiCommand,
    OUT LPVOID pData OPTIONAL,
    IN OUT PUINT pcbSize,
    IN UINT cbSizeHeader);

W32KAPI
UINT
NtUserGetRawInputDeviceInfo(
    IN HANDLE hDevice,
    IN UINT uiCommand,
    OUT LPVOID pData OPTIONAL,
    IN OUT PUINT pcbSize);

W32KAPI
UINT
NtUserGetRawInputBuffer(
    OUT PRAWINPUT pData OPTIONAL,
    IN PUINT pcbSize,
#ifdef LATER
    IN DWORD dwFlags,
#endif
    IN UINT cbSizeHeader);

W32KAPI
UINT
NtUserGetRegisteredRawInputDevices(
    PRAWINPUTDEVICE pRawInputDevices,
    PUINT puiNumDevices,
    UINT cbSize);

W32KAPI
BOOL
NtUserRegisterRawInputDevices(
    PRAWINPUTDEVICE pRawInputDevices,
    UINT uiNumDevices,
    UINT cbSize);

W32KAPI
UINT NtUserGetRawInputDeviceList(
    PRAWINPUTDEVICELIST pRawInputDeviceList,
    PUINT puiNumDevices,
    UINT cbSize);

#endif // GENERIC_INPUT

W32KAPI
UINT
NtUserHardErrorControl(
    IN HARDERRORCONTROL dwCmd,
    IN HANDLE handle OPTIONAL,
    OUT PDESKRESTOREDATA pdrdRestore OPTIONAL);

W32KAPI
BOOL
NtUserGetObjectInformation(
    IN HANDLE hObject,
    IN int nIndex,
    OUT PVOID pvInfo,
    IN DWORD nLength,
    OUT LPDWORD pnLengthNeeded);

W32KAPI
BOOL
NtUserSetObjectInformation(
    IN HANDLE hObject,
    IN int nIndex,
    IN LPCVOID pvInfo,
    IN DWORD nLength);

W32KAPI
BOOL
NtUserWin32PoolAllocationStats(
    IN  LPDWORD parrTags,
    IN  SIZE_T  tagsCount,
    OUT SIZE_T* lpdwMaxMem,
    OUT SIZE_T* lpdwCrtMem,
    OUT LPDWORD lpdwMaxAlloc,
    OUT LPDWORD lpdwCrtAlloc);

#if DBG

W32KAPI
VOID
NtUserDbgWin32HeapFail(
    IN DWORD dwFlags,
    IN BOOL  bFail);

W32KAPI
DWORD
NtUserDbgWin32HeapStat(
    PDBGHEAPSTAT phs,
    DWORD   dwLen);

#endif // DBG

W32KAPI
NTSTATUS
NtUserConsoleControl(
    IN CONSOLECONTROL ConsoleCommand,
    IN PVOID ConsoleInformation,
    IN DWORD ConsoleInformationLength);

W32KAPI
HWINSTA
NtUserCreateWindowStation(
    IN POBJECT_ATTRIBUTES   pObja,
    IN ACCESS_MASK          amRequest,
    IN HANDLE               hKbdLayoutFile,
    IN DWORD                offTable,
    PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    IN PUNICODE_STRING      pstrKLID,
    IN UINT                 uKbdInputLocale);

W32KAPI
HWINSTA
NtUserOpenWindowStation(
    IN POBJECT_ATTRIBUTES pObja,
    IN ACCESS_MASK amRequest);

W32KAPI
BOOL
NtUserCloseWindowStation(
    IN HWINSTA hwinsta);

W32KAPI
BOOL
NtUserSetProcessWindowStation(
    IN HWINSTA hwinsta);

W32KAPI
HWINSTA
NtUserGetProcessWindowStation(
    VOID);

W32KAPI
BOOL
NtUserLockWorkStation(
    VOID);

W32KAPI
HDESK
NtUserCreateDesktop(
    IN POBJECT_ATTRIBUTES pObja,
    IN PUNICODE_STRING pstrDevice,
    IN LPDEVMODEW pDevmode,
    IN DWORD dwFlags,
    IN ACCESS_MASK amRequest);

W32KAPI
HDESK
NtUserOpenDesktop(
    IN POBJECT_ATTRIBUTES pObja,
    IN DWORD dwFlags,
    IN ACCESS_MASK amRequest);

W32KAPI
HDESK
NtUserOpenInputDesktop(
    IN DWORD dwFlags,
    IN BOOL fInherit,
    IN DWORD amRequest);

W32KAPI
NTSTATUS
NtUserResolveDesktopForWOW (
    IN OUT PUNICODE_STRING pstrDesktop);

W32KAPI
HDESK
NtUserResolveDesktop(
    IN HANDLE hProcess,
    IN PUNICODE_STRING pstrDesktop,
    IN BOOL fInherit,
    OUT HWINSTA *phwinsta);

W32KAPI
BOOL
NtUserCloseDesktop(
    IN HDESK hdesk);

W32KAPI
BOOL
NtUserSetThreadDesktop(
    IN HDESK hdesk);

W32KAPI
HDESK
NtUserGetThreadDesktop(
    IN DWORD dwThreadId,
    IN HDESK hdeskConsole);

W32KAPI
BOOL
NtUserSwitchDesktop(
    IN HDESK hdesk);

W32KAPI
NTSTATUS
NtUserInitializeClientPfnArrays(
    IN CONST PFNCLIENT *ppfnClientA OPTIONAL,
    IN CONST PFNCLIENT *ppfnClientW OPTIONAL,
    IN CONST PFNCLIENTWORKER *ppfnClientWorker OPTIONAL,
    IN HANDLE hModUser);

W32KAPI
BOOL
NtUserWaitForMsgAndEvent(
    IN HANDLE hevent);

W32KAPI
DWORD
NtUserDragObject(
    IN HWND hwndParent,
    IN HWND hwndFrom,
    IN UINT wFmt,
    IN ULONG_PTR dwData,
    IN HCURSOR hcur);

W32KAPI
BOOL
NtUserGetIconInfo(
    IN  HICON hicon,
    OUT PICONINFO piconinfo,
    IN  OUT OPTIONAL PUNICODE_STRING pstrInstanceName,
    IN  OUT OPTIONAL PUNICODE_STRING pstrResName,
    OUT OPTIONAL LPDWORD pbpp,
    IN  BOOL fInternal);

W32KAPI
BOOL
NtUserGetIconSize(
    IN HICON hIcon,
    IN UINT istepIfAniCur,
    OUT int *pcx,
    OUT int *pcy);

W32KAPI
BOOL
NtUserDrawIconEx(
    IN HDC hdc,
    IN int x,
    IN int y,
    IN HICON hicon,
    IN int cx,
    IN int cy,
    IN UINT istepIfAniCur,
    IN HBRUSH hbrush,
    IN UINT diFlags,
    IN BOOL fMeta,
    OUT DRAWICONEXDATA *pdid);

W32KAPI
HANDLE
NtUserDeferWindowPos(
    IN HDWP hWinPosInfo,
    IN HWND hwnd,
    IN HWND hwndInsertAfter,
    IN int x,
    IN int y,
    IN int cx,
    IN int cy,
    IN UINT wFlags);

W32KAPI
BOOL
NtUserEndDeferWindowPosEx(
    IN HDWP hWinPosInfo,
    IN BOOL fAsync);

W32KAPI
BOOL
NtUserGetMessage(
    OUT LPMSG pmsg,
    IN HWND hwnd,
    IN UINT wMsgFilterMin,
    IN UINT wMsgFilterMax);

#ifdef MESSAGE_PUMP_HOOK

W32KAPI
BOOL
NtUserRealInternalGetMessage(
    OUT LPMSG pmsg,
    IN HWND hwnd,
    IN UINT wMsgFilterMin,
    IN UINT wMsgFilterMax,
    IN UINT flags,
    BOOL fGetMessage);

#endif

W32KAPI
BOOL
NtUserMoveWindow(
    IN HWND hwnd,
    IN int x,
    IN int y,
    IN int cx,
    IN int cy,
    IN BOOL fRepaint);

W32KAPI
int
NtUserTranslateAccelerator(
    IN HWND hwnd,
    IN HACCEL hAccTable,
    IN LPMSG lpMsg);

W32KAPI
LONG
NtUserSetClassLong(
    IN HWND hwnd,
    IN int nIndex,
    IN LONG dwNewLong,
    IN BOOL bAnsi);

#ifdef _WIN64
W32KAPI
LONG_PTR
NtUserSetClassLongPtr(
    IN HWND hwnd,
    IN int nIndex,
    IN LONG_PTR dwNewLong,
    IN BOOL bAnsi);
#else
#define NtUserSetClassLongPtr   NtUserSetClassLong
#endif

W32KAPI
BOOL
NtUserSetKeyboardState(
    IN CONST BYTE *lpKeyState);

W32KAPI
BOOL
NtUserSetWindowPos(
    IN HWND hwnd,
    IN HWND hwndInsertAfter,
    IN int x,
    IN int y,
    IN int cx,
    IN int cy,
    IN UINT dwFlags);

W32KAPI
BOOL
NtUserSetShellWindowEx(
    IN HWND hwnd,
    IN HWND hwndBkGnd);

W32KAPI
BOOL
NtUserSystemParametersInfo(
    IN UINT wFlag,
    IN DWORD wParam,
    IN OUT LPVOID lpData,
    IN UINT flags);

W32KAPI
BOOL
NtUserUpdatePerUserSystemParameters(
    IN HANDLE hToken,
    IN DWORD  dwFlags);

W32KAPI
DWORD
NtUserDdeInitialize(
    OUT PHANDLE phInst,
    OUT HWND *phwnd,
    OUT LPDWORD pMonFlags,
    IN DWORD afCmd,
    IN PVOID pcii);

W32KAPI
DWORD
NtUserUpdateInstance(
    IN HANDLE hInst,
    OUT LPDWORD pMonFlags,
    IN DWORD afCmd);

W32KAPI
DWORD
NtUserEvent(
    IN PEVENT_PACKET pep);

W32KAPI
BOOL
NtUserFillWindow(
    IN HWND hwndBrush,
    IN HWND hwndPaint,
    IN HDC hdc,
    IN HBRUSH hbr);

W32KAPI
PCLS
NtUserGetWOWClass(
    IN HINSTANCE hInstance,
    IN PUNICODE_STRING pString);

W32KAPI
UINT
NtUserGetInternalWindowPos(
    IN HWND hwnd,
    OUT LPRECT lpRect OPTIONAL,
    OUT LPPOINT lpPoint OPTIONAL);

W32KAPI
NTSTATUS
NtUserInitTask(
    IN UINT dwExpWinVer,
    IN DWORD dwAppCompatFlags,
    IN DWORD dwUserWOWCompatFlags,
    IN PUNICODE_STRING pstrModName,
    IN PUNICODE_STRING pstrBaseFileName,
    IN DWORD hTaskWow,
    IN DWORD dwHotkey,
    IN DWORD idTask,
    IN DWORD dwX,
    IN DWORD dwY,
    IN DWORD dwXSize,
    IN DWORD dwYSize);

W32KAPI
BOOL
NtUserPostThreadMessage(
    IN DWORD id,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam);

W32KAPI
BOOL
NtUserRegisterTasklist(
    IN HWND hwndTasklist);

W32KAPI
BOOL
NtUserSetClipboardData(
    IN UINT wFmt,
    IN HANDLE hMem,
    IN PSETCLIPBDATA scd);

W32KAPI
BOOL
NtUserCloseClipboard(
    VOID);

W32KAPI
BOOL
NtUserEmptyClipboard(
    VOID);

W32KAPI
HANDLE
NtUserConvertMemHandle(
    IN LPBYTE lpData,
    IN UINT cbNULL);

W32KAPI
NTSTATUS
NtUserCreateLocalMemHandle(
    IN HANDLE hMem,
    OUT LPBYTE lpData OPTIONAL,
    IN UINT cbData,
    OUT PUINT lpcbNeeded OPTIONAL);

W32KAPI
HHOOK
NtUserSetWindowsHookEx(
    IN HANDLE hmod,
    IN PUNICODE_STRING pstrLib OPTIONAL,
    IN DWORD idThread,
    IN int nFilterType,
    IN PROC pfnFilterProc,
    IN DWORD dwFlags);

W32KAPI
BOOL
NtUserSetInternalWindowPos(
    IN HWND hwnd,
    IN UINT cmdShow,
    IN CONST RECT *lpRect,
    IN CONST POINT *lpPoint);

W32KAPI
BOOL
NtUserChangeClipboardChain(
    IN HWND hwndRemove,
    IN HWND hwndNewNext);

W32KAPI
DWORD
NtUserCheckMenuItem(
    IN HMENU hmenu,
    IN UINT wIDCheckItem,
    IN UINT wCheck);

W32KAPI
HWND
NtUserChildWindowFromPointEx(
    IN HWND hwndParent,
    IN POINT point,
    IN UINT flags);

W32KAPI
BOOL
NtUserClipCursor(
    IN CONST RECT *lpRect OPTIONAL);

W32KAPI
HACCEL
NtUserCreateAcceleratorTable(
    IN LPACCEL lpAccel,
    IN INT cAccel);

W32KAPI
BOOL
NtUserDeleteMenu(
    IN HMENU hmenu,
    IN UINT nPosition,
    IN UINT dwFlags);

W32KAPI
BOOL
NtUserDestroyAcceleratorTable(
    IN HACCEL hAccel);

W32KAPI
BOOL
NtUserDestroyCursor(
    IN HCURSOR hcurs,
    IN DWORD cmd);

W32KAPI
HANDLE
NtUserGetClipboardData(
    IN UINT fmt,
    OUT PGETCLIPBDATA pgcd);

W32KAPI
BOOL
NtUserDestroyMenu(
    IN HMENU hmenu);

W32KAPI
UINT
NtUserPaintMenuBar(
    IN HWND hwnd,
    IN HDC hdc,
    IN int iLeftOffset,
    IN int iRightOffset,
    IN int iTopOffset,
    IN DWORD dwFlags);

W32KAPI
UINT
NtUserCalcMenuBar(
    IN HWND hwnd,
    IN int iLeftOffset,
    IN int iRightOffset,
    IN int iTopOffset,
    IN LPCRECT prcWnd);

W32KAPI
BOOL
NtUserDestroyWindow(
    IN HWND hwnd);

W32KAPI
LRESULT
NtUserDispatchMessage(
    IN CONST MSG *pmsg);

W32KAPI
BOOL
NtUserEnableMenuItem(
    IN HMENU hMenu,
    IN UINT wIDEnableItem,
    IN UINT wEnable);

W32KAPI
BOOL
NtUserAttachThreadInput(
    IN DWORD idAttach,
    IN DWORD idAttachTo,
    IN BOOL fAttach);

W32KAPI
BOOL
NtUserGetWindowPlacement(
    IN HWND hwnd,
    OUT PWINDOWPLACEMENT pwp);

W32KAPI
BOOL
NtUserSetWindowPlacement(
    IN HWND hwnd,
    IN CONST WINDOWPLACEMENT *lpwndpl);

W32KAPI
BOOL
NtUserLockWindowUpdate(
    IN HWND hwnd);

W32KAPI
BOOL
NtUserGetClipCursor(
    OUT LPRECT lpRect);

W32KAPI
BOOL
NtUserEnableScrollBar(
    IN HWND hwnd,
    IN UINT wSBflags,
    IN UINT wArrows);

W32KAPI
BOOL
NtUserDdeSetQualityOfService(
    IN HWND hwndClient,
    IN CONST SECURITY_QUALITY_OF_SERVICE *pqosNew,
    OUT PSECURITY_QUALITY_OF_SERVICE pqosPrev OPTIONAL);

W32KAPI
BOOL
NtUserDdeGetQualityOfService(
    IN HWND hwndClient,
    IN HWND hwndServer,
    OUT PSECURITY_QUALITY_OF_SERVICE pqos);

W32KAPI
DWORD
NtUserGetMenuIndex(
    IN HMENU hMenu,
    IN HMENU hSubMenu);

W32KAPI
VOID
NtUserSetRipFlags(
    DWORD dwRipFlags, DWORD PID);

W32KAPI
VOID
NtUserSetDbgTag(
    int     tag,
    DWORD   dwBitFlags);

W32KAPI
BOOL
NtUserThunkedMenuItemInfo(
    IN HMENU hMenu,
    IN UINT nPosition,
    IN BOOL fByPosition,
    IN BOOL fInsert,
    IN LPMENUITEMINFOW lpmii,
    IN PUNICODE_STRING pstrItem OPTIONAL);

W32KAPI
BOOL
NtUserThunkedMenuInfo(
    IN HMENU hMenu,
    IN LPCMENUINFO lpmi);

W32KAPI
BOOL
NtUserSetMenuDefaultItem(
    IN HMENU hMenu,
    IN UINT wID,
    IN UINT fByPosition
    );

W32KAPI
BOOL
NtUserDrawAnimatedRects(
    IN HWND hwnd,
    IN int idAni,
    IN CONST RECT * lprcFrom,
    IN CONST RECT * lprcTo);

W32KAPI
BOOL
NtUserDrawCaption(
    IN HWND hwnd,
    IN HDC hdc,
    IN CONST RECT *lprc,
    IN UINT flags);

W32KAPI
BOOL
NtUserFlashWindowEx(
    IN PFLASHWINFO pfwi);

W32KAPI
BOOL
NtUserPaintDesktop(
    IN HDC hdc);

W32KAPI
SHORT
NtUserGetAsyncKeyState(
    IN int vKey);

W32KAPI
HBRUSH
NtUserGetControlBrush(
    IN HWND hwnd,
    IN HDC hdc,
    IN UINT msg);

W32KAPI
HBRUSH
NtUserGetControlColor(
    IN HWND hwndParent,
    IN HWND hwndCtl,
    IN HDC hdc,
    IN UINT msg);

W32KAPI
BOOL
NtUserEndMenu(
    VOID);

W32KAPI
int
NtUserCountClipboardFormats(
    VOID);

W32KAPI
DWORD
NtUserGetClipboardSequenceNumber(
    VOID);

W32KAPI
UINT
NtUserGetCaretBlinkTime(
    VOID);

W32KAPI
HWND
NtUserGetClipboardOwner(
    VOID);

W32KAPI
HWND
NtUserGetClipboardViewer(
    VOID);

W32KAPI
UINT
NtUserGetDoubleClickTime(
    VOID);

W32KAPI
HWND
NtUserGetForegroundWindow(
    VOID);

W32KAPI
HWND
NtUserGetOpenClipboardWindow(
    VOID);

W32KAPI
int
NtUserGetPriorityClipboardFormat(
    OUT UINT *paFormatPriorityList,
    IN int cFormats);

W32KAPI
HMENU
NtUserGetSystemMenu(
    IN HWND hwnd,
    IN BOOL bRevert);

W32KAPI
BOOL
NtUserGetUpdateRect(
    IN HWND hwnd,
    IN LPRECT prect OPTIONAL,
    IN BOOL bErase);

W32KAPI
BOOL
NtUserHideCaret(
    IN HWND hwnd);

W32KAPI
BOOL
NtUserHiliteMenuItem(
    IN HWND hwnd,
    IN HMENU hMenu,
    IN UINT uIDHiliteItem,
    IN UINT uHilite);

W32KAPI
BOOL
NtUserInvalidateRect(
    IN HWND hwnd,
    IN CONST RECT *prect OPTIONAL,
    IN BOOL bErase);

W32KAPI
BOOL
NtUserIsClipboardFormatAvailable(
    IN UINT nFormat);

W32KAPI
BOOL
NtUserKillTimer(
    IN HWND hwnd,
    IN UINT_PTR nIDEvent);

W32KAPI
HWND
NtUserMinMaximize(
    IN HWND hwnd,
    IN UINT nCmdShow,
    IN BOOL fKeepHidden);

W32KAPI
BOOL
NtUserMNDragOver(
    IN POINT * ppt,
    OUT PMNDRAGOVERINFO pmndoi);

W32KAPI
BOOL
NtUserMNDragLeave(
    VOID);

W32KAPI
BOOL
NtUserOpenClipboard(
    IN HWND hwnd,
    OUT PBOOL pfEmptyClient);

W32KAPI
BOOL
NtUserPeekMessage(
    OUT LPMSG pmsg,
    IN HWND hwnd,
    IN UINT wMsgFilterMin,
    IN UINT wMsgFilterMax,
    IN UINT wRemoveMsg);

W32KAPI
BOOL
NtUserPostMessage(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam);

W32KAPI
BOOL
NtUserRegisterHotKey(
    IN HWND hwnd,
    IN int id,
    IN UINT fsModifiers,
    IN UINT vk);

W32KAPI
BOOL
NtUserRemoveMenu(
    IN HMENU hmenu,
    IN UINT nPosition,
    IN UINT dwFlags);

W32KAPI
BOOL
NtUserScrollWindowEx(
    IN HWND hwnd,
    IN int XAmount,
    IN int YAmount,
    IN CONST RECT *pRect OPTIONAL,
    IN CONST RECT *pClipRect OPTIONAL,
    IN HRGN hrgnUpdate,
    OUT LPRECT prcUpdate OPTIONAL,
    IN UINT flags);

W32KAPI
HWND
NtUserSetActiveWindow(
    IN HWND hwnd);

W32KAPI
HWND
NtUserSetCapture(
    IN HWND hwnd);

W32KAPI
WORD
NtUserSetClassWord(
    IN HWND hwnd,
    IN int nIndex,
    IN WORD wNewWord);

W32KAPI
HWND
NtUserSetClipboardViewer(
    IN HWND hwndNewViewer);

W32KAPI
HCURSOR
NtUserSetCursor(
    IN HCURSOR hCursor);

W32KAPI
HWND
NtUserSetFocus(
    IN HWND hwnd);

W32KAPI
BOOL
NtUserSetMenu(
    IN HWND  hwnd,
    IN HMENU hmenu,
    IN BOOL  fRedraw);

W32KAPI
BOOL
NtUserSetMenuContextHelpId(
    IN HMENU hMenu,
    IN DWORD dwContextHelpId);

W32KAPI
BOOL
NtUserSetMenuFlagRtoL(
    IN HMENU hMenu);

W32KAPI
HWND
NtUserSetParent(
    IN HWND hwndChild,
    IN HWND hwndNewParent);

W32KAPI
int
NtUserSetScrollInfo(
    IN HWND hwnd,
    IN int nBar,
    IN LPCSCROLLINFO pInfo,
    IN BOOL fRedraw);

W32KAPI
BOOL
NtUserSetSysColors(
    IN int cElements,
    IN CONST INT * lpaElements,
    IN CONST COLORREF * lpaRgbValues,
    IN UINT  uOptions);

W32KAPI
UINT_PTR
NtUserSetTimer(
    IN HWND hwnd,
    IN UINT_PTR nIDEvent,
    IN UINT wElapse,
    IN TIMERPROC pTimerFunc);

W32KAPI
LONG
NtUserSetWindowLong(
    IN HWND hwnd,
    IN int nIndex,
    IN LONG dwNewLong,
    IN BOOL bAnsi);

#ifdef _WIN64
W32KAPI
LONG_PTR
NtUserSetWindowLongPtr(
    IN HWND hwnd,
    IN int nIndex,
    IN LONG_PTR dwNewLong,
    IN BOOL bAnsi);
#else
#define NtUserSetWindowLongPtr  NtUserSetWindowLong
#endif

W32KAPI
WORD
NtUserSetWindowWord(
    IN HWND hwnd,
    IN int nIndex,
    IN WORD wNewWord);

W32KAPI
HHOOK
NtUserSetWindowsHookAW(
    IN int nFilterType,
    IN HOOKPROC pfnFilterProc,
    IN DWORD dwFlags);

W32KAPI
BOOL
NtUserShowCaret(
    IN HWND hwnd);

W32KAPI
BOOL
NtUserShowScrollBar(
    IN HWND hwnd,
    IN int iBar,
    IN BOOL fShow);

W32KAPI
BOOL
NtUserShowWindowAsync(
    IN HWND hwnd,
    IN int nCmdShow);

W32KAPI
BOOL
NtUserShowWindow(
    IN HWND hwnd,
    IN int nCmdShow);

W32KAPI
BOOL
NtUserTrackMouseEvent(
    IN OUT LPTRACKMOUSEEVENT lpTME
    );

W32KAPI
BOOL
NtUserTrackPopupMenuEx(
    IN HMENU hMenu,
    IN UINT uFlags,
    IN int x,
    IN int y,
    IN HWND hwnd,
    IN CONST TPMPARAMS *pparamst OPTIONAL);

W32KAPI
BOOL
NtUserTranslateMessage(
    IN CONST MSG *lpMsg,
    IN UINT flags);

W32KAPI
BOOL
NtUserUnhookWindowsHookEx(
    IN HHOOK hhk);

W32KAPI
BOOL
NtUserUnregisterHotKey(
    IN HWND hwnd,
    IN int id);

W32KAPI
BOOL
NtUserValidateRect(
    IN HWND hwnd,
    IN CONST RECT *lpRect OPTIONAL);

W32KAPI
DWORD
NtUserWaitForInputIdle(
    IN ULONG_PTR idProcess,
    IN DWORD dwMilliseconds,
    IN BOOL fSharedWow);

W32KAPI
HWND
NtUserWindowFromPoint(
    IN POINT Point);

W32KAPI
HDC
NtUserBeginPaint(
    IN HWND hwnd,
    OUT LPPAINTSTRUCT lpPaint);

W32KAPI
BOOL
NtUserCreateCaret(
    IN HWND hwnd,
    IN HBITMAP hBitmap,
    IN int nWidth,
    IN int nHeight);

W32KAPI
BOOL
NtUserEndPaint(
    IN HWND hwnd,
    IN CONST PAINTSTRUCT *lpPaint);

W32KAPI
int
NtUserExcludeUpdateRgn(
    IN HDC hDC,
    IN HWND hwnd);

W32KAPI
HDC
NtUserGetDC(
    IN HWND hwnd);

W32KAPI
HDC
NtUserGetDCEx(
    IN HWND hwnd,
    IN HRGN hrgnClip,
    IN DWORD flags);

W32KAPI
HDC
NtUserGetWindowDC(
    IN HWND hwnd);

W32KAPI
int
NtUserGetUpdateRgn(
    IN HWND hwnd,
    IN HRGN hRgn,
    IN BOOL bErase);

W32KAPI
BOOL
NtUserRedrawWindow(
    IN HWND hwnd,
    IN CONST RECT *lprcUpdate OPTIONAL,
    IN HRGN hrgnUpdate,
    IN UINT flags);

W32KAPI
BOOL
NtUserInvalidateRgn(
    IN HWND hwnd,
    IN HRGN hRgn,
    IN BOOL bErase);

W32KAPI
int
NtUserSetWindowRgn(
    IN HWND hwnd,
    IN HRGN hRgn,
    IN BOOL bRedraw);

W32KAPI
BOOL
NtUserScrollDC(
    IN HDC hDC,
    IN int dx,
    IN int dy,
    IN CONST RECT *lprcScroll OPTIONAL,
    IN CONST RECT *lprcClip OPTIONAL,
    IN HRGN hrgnUpdate,
    OUT LPRECT lprcUpdate OPTIONAL);

W32KAPI
int
NtUserInternalGetWindowText(
    IN HWND hwnd,
    OUT LPWSTR lpString,
    IN int nMaxCount);

W32KAPI
int
NtUserGetMouseMovePointsEx(
    IN UINT             cbSize,
    IN CONST MOUSEMOVEPOINT *lppt,
    OUT MOUSEMOVEPOINT *lpptBuf,
    IN UINT             nBufPoints,
    IN DWORD            resolution);

W32KAPI
int
NtUserToUnicodeEx(
    IN UINT wVirtKey,
    IN UINT wScanCode,
    IN CONST BYTE *lpKeyState,
    OUT LPWSTR lpszBuff,
    IN int cchBuff,
    IN UINT wFlags,
    IN HKL hKeyboardLayout);

W32KAPI
BOOL
NtUserYieldTask(
    VOID);

W32KAPI
BOOL
NtUserWaitMessage(
    VOID);

#ifdef MESSAGE_PUMP_HOOK

W32KAPI
BOOL
NtUserRealWaitMessageEx(
    IN UINT fsWakeMask,
    IN DWORD Timeout);

#endif

W32KAPI
UINT
NtUserLockWindowStation(
    IN HWINSTA hWindowStation);

W32KAPI
BOOL
NtUserUnlockWindowStation(
    IN HWINSTA hWindowStation);

W32KAPI
UINT
NtUserSetWindowStationUser(
    IN HWINSTA hWindowStation,
    IN PLUID pLuidUser,
    IN PSID pSidUser OPTIONAL,
    IN DWORD cbSidUser);

W32KAPI
BOOL
NtUserSetLogonNotifyWindow(
    IN HWND hwndNotify);

W32KAPI
BOOL
NtUserSetSystemCursor(
    IN HCURSOR hcur,
    IN DWORD id);

W32KAPI
HCURSOR
NtUserGetCursorFrameInfo(
    IN HCURSOR hcur,
    IN int iFrame,
    OUT LPDWORD pjifRate,
    OUT LPINT pccur);

W32KAPI
BOOL
NtUserSetCursorContents(
    IN HCURSOR hCursor,
    IN HCURSOR hCursorNew);

W32KAPI
HCURSOR
NtUserFindExistingCursorIcon(
    IN PUNICODE_STRING pstrModName,
    IN PUNICODE_STRING pstrResName,
    IN PCURSORFIND     pcfSearch);

W32KAPI
BOOL
NtUserSetCursorIconData(
    IN HCURSOR         hCursor,
    IN PUNICODE_STRING pstrModName,
    IN PUNICODE_STRING pstrResName,
    IN PCURSORDATA     pData);

W32KAPI
BOOL
NtUserGetMenuItemRect(
    IN HWND hwnd,
    IN HMENU hMenu,
    IN UINT uItem,
    OUT LPRECT lprcItem);

W32KAPI
int
NtUserMenuItemFromPoint(
    IN HWND hwnd,
    IN HMENU hMenu,
    IN POINT ptScreen);

W32KAPI
BOOL
NtUserGetCaretPos(
    OUT LPPOINT lpPoint);

W32KAPI
BOOL
NtUserDefSetText(
    IN HWND hwnd,
    IN PLARGE_STRING Text OPTIONAL);

W32KAPI
NTSTATUS
NtUserQueryInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    IN OUT PULONG ReturnLength OPTIONAL);

W32KAPI
NTSTATUS
NtUserSetInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength);

W32KAPI
NTSTATUS
NtUserSetInformationProcess(
    IN HANDLE hProcess,
    IN USERPROCESSINFOCLASS ProcessInfoClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength);

W32KAPI
BOOL
NtUserNotifyProcessCreate(
    IN DWORD dwProcessId,
    IN DWORD dwParentThreadId,
    IN ULONG_PTR dwData,
    IN DWORD dwFlags);

W32KAPI
NTSTATUS
NtUserTestForInteractiveUser(
    IN PLUID pluidCaller);

W32KAPI
BOOL
NtUserSetConsoleReserveKeys(
    IN HWND hwnd,
    IN DWORD fsReserveKeys);

W32KAPI
VOID
NtUserModifyUserStartupInfoFlags(
    IN DWORD dwMask,
    IN DWORD dwFlags);

W32KAPI
BOOL
NtUserSetWindowFNID(
    IN HWND hwnd,
    IN WORD fnid);

W32KAPI
VOID
NtUserAlterWindowStyle(
    IN HWND hwnd,
    IN DWORD mask,
    IN DWORD flags);

W32KAPI
VOID
NtUserSetThreadState(
    IN DWORD dwFlags,
    IN DWORD dwMask);

W32KAPI
ULONG_PTR
NtUserGetThreadState(
    IN USERTHREADSTATECLASS ThreadState);

W32KAPI
BOOL
NtUserValidateHandleSecure(
    IN HANDLE h);

W32KAPI
BOOL
NtUserUserHandleGrantAccess(
    IN HANDLE hUserHandle,
    IN HANDLE hJob,
    IN BOOL   bGrant);

W32KAPI
HWND
NtUserCreateWindowEx(
    IN DWORD dwExStyle,
    IN PLARGE_STRING pstrNVClassName,
    IN PLARGE_STRING pstrClassName,
    IN PLARGE_STRING pstrWindowName OPTIONAL,
    IN DWORD dwStyle,
    IN int x,
    IN int y,
    IN int nWidth,
    IN int nHeight,
    IN HWND hwndParent,
    IN HMENU hmenu,
    IN HANDLE hModule,
    IN LPVOID pParam,
    IN DWORD dwFlags,
    IN PACTIVATION_CONTEXT pActCtx);

W32KAPI
NTSTATUS
NtUserBuildHwndList(
    IN HDESK hdesk,
    IN HWND hwndNext,
    IN BOOL fEnumChildren,
    IN DWORD idThread,
    IN UINT cHwndMax,
    OUT HWND *phwndFirst,
    OUT PUINT pcHwndNeeded);

W32KAPI
NTSTATUS
NtUserBuildPropList(
    IN HWND hwnd,
    IN UINT cPropMax,
    OUT PPROPSET pPropSet,
    OUT PUINT pcPropNeeded);

W32KAPI
NTSTATUS
NtUserBuildNameList(
    IN HWINSTA hwinsta,
    IN UINT cbNameList,
    OUT PNAMELIST pNameList,
    OUT PUINT pcbNeeded);

W32KAPI
HKL
NtUserActivateKeyboardLayout(
    IN HKL hkl,
    IN UINT Flags);

W32KAPI
HKL
NtUserLoadKeyboardLayoutEx(
    IN HANDLE hFile,
    IN DWORD offTable,
    IN PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    IN HKL hkl,
    IN PUNICODE_STRING pstrKLID,
    IN UINT KbdInputLocale,
    IN UINT Flags);

W32KAPI
BOOL
NtUserUnloadKeyboardLayout(
    IN HKL hkl);

W32KAPI
BOOL
NtUserSetSystemMenu(
    IN HWND hwnd,
    IN HMENU hmenu);

W32KAPI
BOOL
NtUserDragDetect(
    IN HWND hwnd,
    IN POINT pt);

W32KAPI
UINT_PTR
NtUserSetSystemTimer(
    IN HWND hwnd,
    IN UINT_PTR nIDEvent,
    IN DWORD dwElapse,
    IN WNDPROC pTimerFunc);

W32KAPI
BOOL
NtUserQuerySendMessage(
    OUT PMSG pmsg);

W32KAPI
UINT
NtUserSendInput(
    IN UINT    cInputs,
    IN CONST INPUT *pInputs,
    IN int     cbSize);

W32KAPI
BOOL
NtUserImpersonateDdeClientWindow(
    IN HWND hwndClient,
    IN HWND hwndServer);

W32KAPI
ULONG_PTR
NtUserGetCPD(
    IN HWND hwnd,
    IN DWORD options,
    IN ULONG_PTR dwData);

W32KAPI
int
NtUserCopyAcceleratorTable(
    IN HACCEL hAccelSrc,
    IN OUT LPACCEL lpAccelDst OPTIONAL,
    IN int cAccelEntries);

W32KAPI
HWND
NtUserFindWindowEx(
    IN HWND hwndParent,
    IN HWND hwndChild,
    IN PUNICODE_STRING pstrClassName OPTIONAL,
    IN PUNICODE_STRING pstrWindowName OPTIONAL,
    IN DWORD dwType);

W32KAPI
BOOL
NtUserGetClassInfo(
    IN HINSTANCE hInstance OPTIONAL,
    IN PUNICODE_STRING pstrClassName,
    IN OUT LPWNDCLASSEXW lpWndClass,
    OUT LPWSTR *ppszMenuName,
    IN BOOL bAnsi);

W32KAPI
int
NtUserGetClassName(
    IN HWND hwnd,
    IN BOOL bReal,
    IN OUT PUNICODE_STRING pstrClassName);

W32KAPI
UINT
NtUserGetAtomName(
    IN ATOM atom,
    IN OUT PUNICODE_STRING pstrAtomName);

W32KAPI
int
NtUserGetClipboardFormatName(
    IN UINT format,
    OUT LPWSTR lpszFormatName,
    IN UINT chMax);

W32KAPI
int
NtUserGetKeyNameText(
    IN LONG lParam,
    OUT LPWSTR lpszKeyName,
    IN UINT chMax);

W32KAPI
BOOL
NtUserGetKeyboardLayoutName(
    IN OUT PUNICODE_STRING pstrKLID);

W32KAPI
UINT
NtUserGetKeyboardLayoutList(
    IN UINT nItems,
    OUT HKL *lpBuff);

W32KAPI
DWORD
NtUserGetGuiResources(
    HANDLE hProcess,
    DWORD dwFlags);

W32KAPI
UINT
NtUserMapVirtualKeyEx(
    IN UINT uCode,
    IN UINT uMapType,
    IN ULONG_PTR dwHKLorPKL,
    IN BOOL bHKL);

W32KAPI
ATOM
NtUserRegisterClassExWOW(
    IN WNDCLASSEX *lpWndClass,
    IN PUNICODE_STRING pstrClassName,
    IN PUNICODE_STRING pstrClassNameVer,
    IN PCLSMENUNAME pcmn,
    IN WORD fnid,
    IN DWORD dwFlags,
    IN LPDWORD pdwWOWstuff OPTIONAL);

W32KAPI
UINT
NtUserRegisterWindowMessage(
    IN PUNICODE_STRING pstrMessage);

W32KAPI
HANDLE
NtUserRemoveProp(
    IN HWND hwnd,
    IN DWORD dwProp);

W32KAPI
BOOL
NtUserSetProp(
    IN HWND hwnd,
    IN DWORD dwProp,
    IN HANDLE hData);

W32KAPI
BOOL
NtUserUnregisterClass(
    IN PUNICODE_STRING pstrClassName,
    IN HINSTANCE hInstance,
    OUT PCLSMENUNAME pcmn);

W32KAPI
SHORT
NtUserVkKeyScanEx(
    IN WCHAR ch,
    IN ULONG_PTR dwHKLorPKL,
    IN BOOL bHKL);

W32KAPI
NTSTATUS
NtUserEnumDisplayDevices(
    IN PUNICODE_STRING pstrDeviceName,
    IN DWORD iDevNum,
    IN OUT LPDISPLAY_DEVICEW lpDisplayDevice,
    IN DWORD dwFlags);

W32KAPI
HWINEVENTHOOK
NtUserSetWinEventHook(
    IN DWORD           eventMin,
    IN DWORD           eventMax,
    IN HMODULE         hmodWinEventProc,
    IN PUNICODE_STRING pstrLib OPTIONAL,
    IN WINEVENTPROC    pfnWinEventProc,
    IN DWORD           idEventProcess,
    IN DWORD           idEventThread,
    IN DWORD           dwFlags);

W32KAPI
BOOL
NtUserUnhookWinEvent(
    IN HWINEVENTHOOK hWinEventHook);

W32KAPI
VOID
NtUserNotifyWinEvent(
    IN DWORD event,
    IN HWND  hwnd,
    IN LONG  idObject,
    IN LONG  idChild);

W32KAPI
BOOL
NtUserRegisterUserApiHook(
    IN PUNICODE_STRING pstrLib,
    IN ULONG_PTR offPfnInitUserApiHook);

W32KAPI
BOOL
NtUserUnregisterUserApiHook(VOID);

W32KAPI
BOOL
NtUserGetGUIThreadInfo(
    IN DWORD idThread,
    IN OUT PGUITHREADINFO pgui);

W32KAPI
BOOL
NtUserGetTitleBarInfo(
    IN HWND hwnd,
    IN OUT PTITLEBARINFO ptbi);

W32KAPI
BOOL
NtUserGetScrollBarInfo(
    IN HWND hwnd,
    IN LONG idObject,
    IN OUT PSCROLLBARINFO ptbi);

W32KAPI
BOOL
NtUserGetComboBoxInfo(
    IN HWND hwnd,
    IN OUT PCOMBOBOXINFO pcbi
    );

W32KAPI
DWORD
NtUserGetListBoxInfo(
    IN HWND hwnd
    );

W32KAPI
HWND
NtUserGetAncestor(
    IN HWND hwnd,
    IN UINT gaFlags);

W32KAPI
BOOL
NtUserGetCursorInfo(
    IN OUT PCURSORINFO pci);

W32KAPI
HWND
NtUserRealChildWindowFromPoint(
    IN HWND hwndParent,
    IN POINT pt
    );

W32KAPI
BOOL
NtUserGetAltTabInfo(
    IN HWND hwnd,
    IN int iItem,
    IN OUT PALTTABINFO pati,
    OUT LPWSTR lpszItemText,
    IN UINT cchItemText,
    IN BOOL bAnsi);

W32KAPI
BOOL
NtUserGetMenuBarInfo(
    IN HWND hwnd,
    IN long idObject,
    IN long idItem,
    IN OUT PMENUBARINFO pmbi);

W32KAPI
LONG
NtUserChangeDisplaySettings(
    IN PUNICODE_STRING pstrDeviceName,
    IN LPDEVMODEW lpDevMode,
    IN HWND hwnd,
    IN DWORD dwFlags,
    IN PVOID lParam);

W32KAPI
BOOL
NtUserCallMsgFilter(
    IN OUT LPMSG lpMsg,
    IN int nCode);

W32KAPI
int
NtUserDrawMenuBarTemp(
    IN HWND hwnd,
    IN HDC hdc,
    IN LPCRECT lprc,
    IN HMENU hMenu,
    IN HFONT hFont);

W32KAPI
BOOL
NtUserDrawCaptionTemp(
    IN HWND hwnd,
    IN HDC hdc,
    IN LPCRECT lprc,
    IN HFONT hFont,
    IN HICON hicon,
    IN PUNICODE_STRING pstrText,
    IN UINT flags);

W32KAPI
SHORT
NtUserGetKeyState(
    IN int vk);

W32KAPI
BOOL
NtUserGetKeyboardState(
    OUT PBYTE pb);

W32KAPI
HANDLE
NtUserQueryWindow(
    IN HWND hwnd,
    IN WINDOWINFOCLASS WindowInfo);

W32KAPI
BOOL
NtUserSBGetParms(
    IN HWND hwnd,
    IN int code,
    IN PSBDATA pw,
    IN OUT LPSCROLLINFO lpsi);

W32KAPI
BOOL
NtUserBitBltSysBmp(
    IN HDC hdc,
    IN int xDest,
    IN int yDest,
    IN int cxDest,
    IN int cyDest,
    IN int xSrc,
    IN int ySrc,
    IN DWORD dwRop);

W32KAPI
LRESULT
NtUserMessageCall(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam,
    IN ULONG_PTR xParam,
    IN DWORD xpfnProc,
    IN BOOL bAnsi);

W32KAPI
LRESULT
NtUserCallNextHookEx(
    IN int nCode,
    IN WPARAM wParam,
    IN LPARAM lParam,
    IN BOOL bAnsi);

W32KAPI
BOOL
NtUserEnumDisplayMonitors(
    IN HDC             hdc,
    IN LPCRECT         lprcClip,
    IN MONITORENUMPROC lpfnEnum,
    IN LPARAM          dwData);

W32KAPI
NTSTATUS
NtUserEnumDisplaySettings(
    IN PUNICODE_STRING pstrDeviceName,
    IN DWORD           iModeNum,
    OUT LPDEVMODEW     lpDevMode,
    IN  DWORD          dwFlags);

LONG
NtUserChangeDisplaySettings(
    IN PUNICODE_STRING pstrDeviceName,
    IN LPDEVMODEW lpDevMode,
    IN HWND hwnd,
    IN DWORD dwFlags,
    IN PVOID lParam);

W32KAPI
BOOL
NtUserQueryUserCounters(
    IN  DWORD       dwQueryType,
    IN  LPVOID      pvIn,
    IN  DWORD       dwInSize,
    OUT LPVOID      pvResult,
    IN  DWORD       dwOutSize
    );

W32KAPI
BOOL
NtUserUpdateLayeredWindow(
    IN HWND hwnd,
    IN HDC hdcDst,
    IN POINT *pptDst,
    IN SIZE *psize,
    IN HDC hdcSrc,
    IN POINT *pptSrc,
    IN COLORREF crKey,
    IN BLENDFUNCTION *pblend,
    IN DWORD dwFlags);

W32KAPI
BOOL
NtUserGetLayeredWindowAttributes(
    IN HWND hwnd,
    OUT COLORREF *pcrKey OPTIONAL,
    OUT BYTE *pbAlpha OPTIONAL,
    OUT DWORD * pdwFlags OPTIONAL);

W32KAPI
BOOL
NtUserSetLayeredWindowAttributes(
    IN HWND hwnd,
    IN COLORREF crKey,
    IN BYTE bAlpha,
    IN DWORD dwFlags);

W32KAPI
BOOL
NtUserPrintWindow(
    IN HWND hwnd,
    IN HDC hdcBlt,
    IN UINT nFlags);

W32KAPI
NTSTATUS
NtUserRemoteConnect(
    IN PDOCONNECTDATA pDoConnectData,
    IN ULONG DisplayDriverNameLength,
    IN PWCHAR DisplayDriverName );

W32KAPI
NTSTATUS
NtUserRemoteRedrawRectangle(
    IN WORD Left,
    IN WORD Top,
    IN WORD Right,
    IN WORD Bottom );

W32KAPI
NTSTATUS
NtUserRemoteRedrawScreen( VOID );

W32KAPI
NTSTATUS
NtUserRemoteStopScreenUpdates( VOID );

W32KAPI
NTSTATUS
NtUserCtxDisplayIOCtl(
    IN ULONG  DisplayIOCtlFlags,
    IN PUCHAR pDisplayIOCtlData,
    IN ULONG  cbDisplayIOCtlData);

W32KAPI
HPALETTE
NtUserSelectPalette(
    IN HDC hdc,
    IN HPALETTE hpalette,
    IN BOOL fForceBackground);

W32KAPI
NTSTATUS
NtUserProcessConnect(
    IN HANDLE    hProcess,
    IN OUT PVOID pConnectInfo,
    IN ULONG     cbConnectInfo);

W32KAPI
NTSTATUS
NtUserSoundSentry(VOID);

W32KAPI
NTSTATUS
NtUserInitialize(
    IN DWORD   dwVersion,
    IN HANDLE  hPowerRequestEvent,
    IN HANDLE  hMediaRequestEvent);


W32KAPI
BOOL
NtUserSetProcessRedirectionMode(
    IN HANDLE hProcess,
    IN BOOL bRedirectionMode);

W32KAPI
BOOL
NtUserGetProcessRedirectionMode(
    IN HANDLE hProcess,
    OUT PBOOL pbRedirectionMode);

W32KAPI
BOOL
NtUserSetDesktopRedirectionMode(
    IN HANDLE hProcess,
    IN BOOL bRedirectionMode);

W32KAPI
BOOL
NtUserGetDesktopRedirectionMode(
    IN HANDLE hProcess,
    OUT PBOOL pbRedirectionMode);

W32KAPI
BOOL
NtUserValidateTimerCallback(
    IN HWND hwnd,
    IN ULONG_PTR wParam,
    IN ULONG_PTR lParam);

#endif  // _NTUSER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\inc\usercall.h ===
/****************************** Module Header ******************************\
* Module Name: usercall.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains all kernel mode entry points
*
* History:
* 12-98 Hiroyama    Created
\***************************************************************************/

#ifndef _USERCALL_
#define _USERCALL_

#include "w32wow64.h"

#ifndef W32KAPI
#define W32KAPI  DECLSPEC_ADDRSAFE
#endif

W32KAPI
ULONG_PTR
NtUserCallNoParam(
    IN DWORD xpfnProc);

W32KAPI
ULONG_PTR
NtUserCallOneParam(
    IN ULONG_PTR dwParam,
    IN DWORD xpfnProc);

W32KAPI
KERNEL_ULONG_PTR
NtUserCallHwnd(
    IN HWND hwnd,
    IN DWORD xpfnProc);

W32KAPI
KERNEL_ULONG_PTR
NtUserCallHwndLock(
    IN HWND hwnd,
    IN DWORD xpfnProc);

W32KAPI
ULONG_PTR
NtUserCallHwndOpt(
    IN HWND hwnd,
    IN DWORD xpfnProc);

W32KAPI
ULONG_PTR
NtUserCallTwoParam(
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2,
    IN DWORD xpfnProc);

W32KAPI
ULONG_PTR
NtUserCallHwndParam(
    IN HWND hwnd,
    IN ULONG_PTR dwParam,
    IN DWORD xpfnProc);

W32KAPI
ULONG_PTR
NtUserCallHwndParamLock(
    IN HWND hwnd,
    IN ULONG_PTR dwParam,
    IN DWORD xpfnProc);

#endif  /* _USERCALL_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\inc\wow.h ===
/****************************** Module Header ******************************\
* Module Name: wow.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains macros to be used in rtl\wow.c client\ and kernel\
*
* History:
* 22-AUG-97 CLupu      created
\***************************************************************************/


#if !defined(_WIN64)

/*
 * WIN32 and WOW6432 version of StartValidateHandleMacro
 */
#define StartValidateHandleMacro(h)                                         \
{                                                                           \
    PHE phe;                                                                \
    DWORD dw;                                                               \
    WORD uniq;                                                              \
                                                                            \
    /*                                                                      \
     * This is a macro that does an AND with HMINDEXBITS,                   \
     * so it is fast.                                                       \
     */                                                                     \
    dw = HMIndexFromHandle(h);                                              \
                                                                            \
    /*                                                                      \
     * Make sure it is part of our handle table.                            \
     */                                                                     \
    if (dw < gpsi->cHandleEntries) {                                        \
        /*                                                                  \
         * Make sure it is the handle                                       \
         * the app thought it was, by                                       \
         * checking the uniq bits in                                        \
         * the handle against the uniq                                      \
         * bits in the handle entry.                                        \
         */                                                                 \
        phe = &gSharedInfo.aheList[dw];                                     \
        uniq = HMUniqFromHandle(h);                                         \
        if (   uniq == phe->wUniq                                           \
            || uniq == 0                                                    \
            || uniq == HMUNIQBITS                                           \
            ) {                                                             \

#else  /* _WIN64 */
#if defined(_USERK_)
/*
 * Allow 32bit process running on 64bit OS to mask the uniq bits (WOW64).
 */
#define ALLOWZEROFORWOW64  ((uniq == 0) && (PsGetProcessWow64Process(PsGetCurrentProcess()) != NULL))
#else
#define ALLOWZEROFORWOW64   0
#endif

/*
 * WIN64 version of StartValidateHandleMacro
 */
#define StartValidateHandleMacro(h)                                         \
{                                                                           \
    PHE phe;                                                                \
    DWORD dw;                                                               \
    WORD uniq;                                                              \
                                                                            \
    /*                                                                      \
     * This is a macro that does an AND with HMINDEXBITS,                   \
     * so it is fast.                                                       \
     */                                                                     \
    dw = HMIndexFromHandle(h);                                              \
                                                                            \
    /*                                                                      \
     * Make sure it is part of our handle table.                            \
     */                                                                     \
    if (dw < gpsi->cHandleEntries) {                                        \
        /*                                                                  \
         * Make sure it is the handle                                       \
         * the app thought it was, by                                       \
         * checking the uniq bits in                                        \
         * the handle against the uniq                                      \
         * bits in the handle entry.                                        \
         * For Win64 uniq can't be zero!                                    \
         */                                                                 \
        phe = &gSharedInfo.aheList[dw];                                     \
        uniq = HMUniqFromHandle(h);                                         \
        if (   uniq == phe->wUniq                                           \
            || uniq == HMUNIQBITS                                           \
            || ALLOWZEROFORWOW64                                            \
            ) {                                                             \

#endif /* _WIN64 */

#define BeginAliveValidateHandleMacro() \
          /*                                                                   \
           * Now make sure that the handle is not destroyed.  On free          \
           * builds the RIP disappears and the main line is straightthrough.   \
           */                                                                  \
            if (!(phe->bFlags & HANDLEF_DESTROY)) {  \


#define EndAliveValidateHandleMacro() \
            } else {                                \
                RIPMSG2(RIP_WARNING, "ValidateAliveHandle: Object phe %#p is destroyed. Handle: %#p", \
                    phe, h);   \
            }   \


#define BeginTypeValidateHandleMacro(pobj, bTypeTest)                       \
            /*                                                              \
             * Now make sure the app is passing the right handle            \
             * type for this api. If the handle is TYPE_FREE, this'll       \
             * catch it.  Also let Generic requests through.                \
             */                                                             \
            if ((phe->bType == bTypeTest) ||                                \
                (bTypeTest == TYPE_GENERIC && phe->bType != TYPE_FREE)) {   \
                                                                            \
                /*                                                          \
                 * Instead of try/except we use the heap range check        \
                 * mechanism to verify that the given 'pwnd' belongs to     \
                 * the default desktop. We also have to do a Win 3.1 like   \
                 * check to make sure the window is not deleted             \
                 * See NT bug 12242 Kitchen app.  Also 6479                 \
                 *                                                          \
                 * TESTDESKOP returns the handle if the handle is valid     \
                 * in the current desktop                                   \
                 */                                                         \
                pobj = phe->phead;                                          \
                {                                                           \

#define EndTypeValidateHandleMacro                                          \
                }                                                           \
            }                                                               \

#define EndValidateHandleMacro                                              \
        }                                                                   \
    }                                                                       \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\makefile.inc ===
$(O)\$(TARGETNAME).c $(O)\$(TARGETNAME).h $(O)\$(TARGETNAME).rc $(O)\$(TARGETNAME).def: $(NTUSER_PATH)\kbd\txt\$(TARGETNAME).txt
    cd $(O)
    kbdtool $**
    cd $(MAKEDIR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\inc\user.h ===
/****************************** Module Header ******************************\
* Module Name: user.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains stuff shared by all the modules of the USER.DLL.
*
* History:
* 09-18-90 DarrinM      Created.
* 04-27-91 DarrinM      Merged in USERCALL.H, removed some dead wood.
\***************************************************************************/

#ifndef _USER_
#define _USER_

/******************************WOW64***NOTE********************************\
* Note: Win32k Memory shared with User-Mode and Wow64
*
* For Wow64 (Win32 apps on Win64) we build a 32-bit version
* of user32.dll & gdi32.dll which can run against the 64-bit kernel
* with no changes to the 64-bit kernel code.
*
* For the 32 on 64 bit dlls all data structures which are shared with
* win32k must be 64-bit. These data structures include the shared
* sections, as well as members of the TEB.
* These shared data structures are now declared so that they can be
* built as 32 bit in a 32 bit dll, 64 bit in a 64 bit dll, and now
* 64 bit in a 32 bit dll.
*
* The following rules should be followed when declaring
* shared data structures:
*
*     Pointers in shared data structures use the KPTR_MODIFIER in their
*     declaration.
*
*     Handles in shared data structures are declared KHxxx.
*
*     xxx_PTR changes to KERNEL_xxx_PTR.
*
*     Pointers to basic types are declared as KPxxx;
*
* Also on Wow64 every thread has both a 32-bit TEB and a 64-bit TEB.
* GetCurrentTeb() returns the current 32-bit TEB while the kernel
* will allways reference the 64-bit TEB.
*
* All client side references to shared data in the TEB should use
* the new GetCurrentTebShared() macro which returns the 64-bit TEB
* for Wow64 builds and returns GetCurrentTeb() for regular builds.
* The exception to this rule is LastErrorValue, which should allways
* be referenced through GetCurrentTeb().
*
* Ex:
*
* DECLARE_HANDLE(HFOO);
*
* typedef struct _MY_STRUCT *PMPTR;
*
* struct _SHARED_STRUCT
* {
*     struct _SHARED_STRUCT *   pNext;
*     PMPTR                     pmptr;
*     HFOO                      hFoo;
*     UINT_PTR                  cb;
*     PBYTE                     pb;
*     PVOID                     pv;
*
*     DWORD                     dw;
*     USHORT                    us;
* } SHARED_STRUCT;
*
*
* Changes to:
*
*
* DECLARE_HANDLE(HFOO);
* DECLARE_KHANDLE(HFOO);
*
* typedef struct _MY_STRUCT * KPTR_MODIFIER   PMPTR;
*
* struct _SHARED_STRUCT
* {
*     struct _SHARED_STRUCT * KPTR_MODIFIER   pNext;
*     PMPTR                     pmptr;
*     KHFOO                     hFoo;
*     KERNEL_UINT_PTR           cb;
*     KPBYTE                    pb;
*     KERNEL_PVOID              pv;
*
*     DWORD                     dw;
*     USHORT                    us;
* } SHARED_STRUCT;
*
\***************************************************************************/
#include "w32wow64.h"

DECLARE_KHANDLE(HIMC);

/*
 * Enable warnings that are turned off default for NT but we want on
 */
#ifndef RC_INVOKED       // RC can't handle #pragmas
    #pragma warning(error:4100)   // Unreferenced formal parameter
    #pragma warning(error:4101)   // Unreferenced local variable
    // #pragma warning(error:4702)   // Unreachable code
    #pragma warning(error:4705)   // Statement has no effect
#endif // RC_INVOKED

#if !defined(FASTCALL)
    #if defined(_X86_)
        #define FASTCALL    _fastcall
    #else // defined(_X86_)
        #define FASTCALL
    #endif // defined(_X86_)
#endif // !defined(FASTCALL)

#ifdef UNICODE
    #define UTCHAR WCHAR
#else // UINCODE
    #define UTCHAR UCHAR
#endif // UINCODE


/*
 * These types are needed before they are fully defined.
 */
typedef struct tagWINDOWSTATION     * KPTR_MODIFIER PWINDOWSTATION;
typedef struct _LOCKRECORD          * KPTR_MODIFIER PLR;
typedef struct _TL                  * KPTR_MODIFIER PTL;
typedef struct tagDESKTOP           * KPTR_MODIFIER PDESKTOP;
typedef struct tagTDB               * KPTR_MODIFIER PTDB;
typedef struct tagSVR_INSTANCE_INFO * PSVR_INSTANCE_INFO;
typedef struct _MOVESIZEDATA        * PMOVESIZEDATA;
typedef struct tagCURSOR            * KPTR_MODIFIER PCURSOR;
typedef struct tagPOPUPMENU         * KPTR_MODIFIER PPOPUPMENU;
typedef struct tagQMSG              * KPTR_MODIFIER PQMSG;
typedef struct tagWND               * KPTR_MODIFIER PWND;
typedef struct _ETHREAD             * PETHREAD;
typedef struct tagDESKTOPINFO       * KPTR_MODIFIER PDESKTOPINFO;
typedef struct tagDISPLAYINFO       * KPTR_MODIFIER PDISPLAYINFO;
typedef struct tagCLIENTTHREADINFO  * KPTR_MODIFIER PCLIENTTHREADINFO;
typedef struct tagDCE               * KPTR_MODIFIER PDCE;
typedef struct tagSPB               * KPTR_MODIFIER PSPB;
typedef struct tagQ                 * KPTR_MODIFIER PQ;
typedef struct tagTHREADINFO        * KPTR_MODIFIER PTHREADINFO;
typedef struct tagPROCESSINFO       * KPTR_MODIFIER PPROCESSINFO;
typedef struct tagWOWTHREADINFO     * PWOWTHREADINFO;
typedef struct tagPERUSERDATA       * PPERUSERDATA;
typedef struct tagPERUSERSERVERINFO * PPERUSERSERVERINFO;
typedef struct tagTERMINAL          * PTERMINAL;
typedef struct _CLIENTINFO          * PCLIENTINFO;
typedef struct tagMENU              * KPTR_MODIFIER PMENU;
typedef struct tagHOOK              * KPTR_MODIFIER PHOOK;
typedef struct _HANDLEENTRY         * KPTR_MODIFIER PHE;
typedef struct tagSERVERINFO        * KPTR_MODIFIER PSERVERINFO;
typedef struct _CALLPROCDATA        * KPTR_MODIFIER PCALLPROCDATA;
typedef struct tagCLS               * KPTR_MODIFIER PCLS;
typedef struct tagMONITOR           * KPTR_MODIFIER PMONITOR;

/*
 * MessageBox button strings.
 * They should be in the same order as IDOK... and SEB_OK... are
 */
#define STR_OK                      800
#define STR_CANCEL                  801
#define STR_ABORT                   802
#define STR_RETRY                   803
#define STR_IGNORE                  804
#define STR_YES                     805
#define STR_NO                      806
#define STR_CLOSE                   807
#define STR_HELP                    808
#define STR_TRYAGAIN                809
#define STR_CONTINUE                810

/*
 * ToolTip strings.
 */
#define STR_TT_MIN                  900
#define STR_TT_MAX                  901
#define STR_TT_RESUP                902
#define STR_TT_RESDOWN              903
#define STR_TT_HELP                 904
#define STR_TT_SCLOSE               905

/*
 * This name is used both in kernel\server.c and ntuser\server\exitwin.c
 */
#define ICON_PROP_NAME  L"SysIC"

/*
 * Define DbgPrint to be something bogus on free builds so we won't
 * include it accidentally.
 */
#if !DBG
#define DbgPrint UserDbgPrint
#endif

typedef struct tagMBSTRING
{
    WCHAR szName[15];
    UINT  uID;
    UINT  uStr;
} MBSTRING, * KPTR_MODIFIER PMBSTRING;

/*
 * SIZERECT is a rectangle represented by a top-left coordinate, width,
 * and height.
 *
 * Hungarian is "src".
 */
typedef struct tagSIZERECT {
    int x;
    int y;
    int cx;
    int cy;
} SIZERECT, *PSIZERECT, *LPSIZERECT;

typedef const SIZERECT * PCSIZERECT;
typedef const SIZERECT * LPCSIZERECT;


void RECTFromSIZERECT(PRECT prc, PCSIZERECT psrc);
void SIZERECTFromRECT(PSIZERECT psrc, LPCRECT prc);

/*
 * Use these macros to unpack things packed by MAKELPARAM.
 */

#define LOSHORT(l)          ((short)LOWORD(l))
#define HISHORT(l)          ((short)HIWORD(l))

#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lp)    ((int)(short)LOWORD(lp))
#endif

#ifndef GET_Y_LPARAM
#define GET_Y_LPARAM(lp)    ((int)(short)HIWORD(lp))
#endif

#ifdef _USERK_
    #define GetClientInfo() (((PTHREADINFO)(W32GetCurrentThread()))->pClientInfo)
#else
    // We don't grab it this way in the kernel in case it is a kernel only thread
    #define GetClientInfo() ((PCLIENTINFO)((NtCurrentTebShared())->Win32ClientInfo))
#endif

/* Used by xxxSleepTask */
#define HEVENT_REMOVEME ((HANDLE)IntToPtr(0xFFFFFFFF))


/*
 * Access to system metrics, colors, and brushes.
 */
#define SYSMETBOOL(i)         ((gpsi->aiSysMet[SM_BOOLEANS] & (1 << (SM_##i - SM_STARTBOOLRANGE))) != 0)
#define SYSMETBOOL2(index)    ((gpsi->aiSysMet[SM_BOOLEANS] & (1 << (index - SM_STARTBOOLRANGE))) != 0)
#define SETSYSMETBOOL(i, val) SET_OR_CLEAR_FLAG(gpsi->aiSysMet[SM_BOOLEANS], 1 << (SM_##i - SM_STARTBOOLRANGE), val)
#define SYSMET(i)             (gpsi->aiSysMet[SM_##i])
#define SYSMETRTL(i)          (gpsi->aiSysMet[SM_##i])
#define SYSRGB(i)             (gpsi->argbSystem[COLOR_##i])
#define SYSRGBRTL(i)          (gpsi->argbSystem[COLOR_##i])
#define SYSHBR(i)             KHBRUSH_TO_HBRUSH(gpsi->ahbrSystem[COLOR_##i])
#define SYSHBRUSH(i)          KHBRUSH_TO_HBRUSH(gpsi->ahbrSystem[i])

#ifdef _USERK_
    #define SYSMETFROMPROCESS(i)  gpsi->aiSysMet[SM_##i]
#endif

/*
 * These cool constants can be used to specify rops.
 */
#define DESTINATION (DWORD)0x00AA0000
#define SOURCE      (DWORD)0x00CC0000
#define PATTERN     (DWORD)0x00F00000

/*
 *  Chicago equates.
 */
#define BI_CHECKBOX       0
#define BI_RADIOBUTTON    1
#define BI_3STATE         2

#define NUM_BUTTON_TYPES  3
#define NUM_BUTTON_STATES 4

/*
 * Total number of strings used as button strings in MessageBoxes.
 */
#define  MAX_MB_STRINGS    11


/*
 * Rectangle macros.  I